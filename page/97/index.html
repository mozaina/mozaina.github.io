<!doctype html>
<html lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.59.1" />

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>开发者问答集锦 | </title>
    <meta property="og:title" content="开发者问答集锦 | ">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="">
    <meta name="description" content="">
    <meta property="og:url" content="https://zaina.newban.cn/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <link rel="alternate" type="application/rss+xml+xml" href="https://zaina.newban.cn/index.xml" title="开发者问答集锦" />
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="https://zaina.newban.cn">
                            开发者问答集锦
                        </a>
                    </h1>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bash%E7%99%BE%E5%AE%9D%E7%AE%B1shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9C%89%E5%93%AA%E4%BA%9B/" title="Bash百宝箱shell环境变量有哪些">Bash百宝箱shell环境变量有哪些</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            在shell中，有些环境变量如PATH、HOME、PWD等我们非常熟悉，有些则较为陌生，下面对shell现有的环境变量作个总结。
CDPATH：冒号分隔的一组目录名，用作内建命令cd的搜索路径。
HOME：当前用户主目录，也是内建命令cd不带参数时的目的路径，这个变量的值还用在波浪号扩展中。
IFS：用来分隔字段的一组字符，例如空格、水平制表符、换行符，在shell扩展中用于分隔单词。
MAIL：如果这个变量设置为一个文件名，且没有设置MAILPAH时，bash将通知用户在指定文件夹中有新邮件。
MAILPATH：冒号分隔的一组文件名，shell会在这些文件夹中定期检查有无新邮件，文件名后面可以是一个问号，接着是一则消息，有新邮件时就会显示指定消息，在消息文本中“$_”扩展为当前邮箱文件名。
OPTARG：内建命令getopts处理的上一个选项的参数。
OPTIND：内建命令getopts即将处理的下一个选项的索引。
PATH：冒号分隔的一组目录名，shell用它来搜索命令，长度为零的目录即空目录指当前目录，它可以在两个冒号之间，或者最前面的冒号的左边或最后面的冒号的右边。
PS1：主提示符，结尾为美元符号。
PS2：第二提示符，默认为右尖括号。
BASH：执行当前命令的bash完整路径。
BASHPID：当前bash的进程号，有时与“$$”不同，例如子shell不要求bash进行初始化。
BASH_ALIASES：一个键值对数组变量，元素同内建命令alias维护的别名列表，在这个数组变量中添加或删除元素也都会反应到alias别名列表。
BASH_ARGC：一个数组变量，其中的元素是当前bash的执行栈中每个帧的参数个数，当前子程序即shell函数或用内建命令source执行的shell脚本的参数个数在栈的顶端，执行子程序时，传递给它的参数被压入数组BASH_ARGV，只有shell运行在扩展的调试模式中才会设置这个数组。
BASH_ARGV：一个数组变量，包含当前bash的执行栈中的所有变量，最后一个子程序调用的最后一个参数在栈的顶端，而第一个子程序调用的第一个参数在栈的底部，在执行子程序时，传递给它的参数被压入数组BASH_ARGV，只有shell运行在扩展的调试模式中才会设置这个数组。
BASH_CMDS：一个键值对数组变量，元素同内建命令hash维护的散列表相对应，在这个数组变量中添加或删除元素也都会反应到hash散列表。
BASH_COMMAND：当前正在执行或即将执行的命令，如果这个命令来自内建命令trap，则表示触发trap的那个命令。
BASH_ENV：如果在启动bash执行shell脚本时设置了这个变量，它的值就会在执行脚本前进行扩展并当作初始化文件来读取。
BASH_EXECUTION_STRING：启动选项“-c”的命令参数。
BASH_LINENO：一个键值对数组变量，元素是与每个FUNCNAME对应的在源文件中调用的行号。
BASH_REMATCH：一个数组变量，元素由条件命令“[[”中的双目运算符“=~”来赋值，下标为0的元素是字符串中与整个正则表达式匹配的部分，下标为n的元素是字符串中与第n个括号的子模式匹配的部分，这个变量是只读的。
BASH_SOURCE：一个数组变量，其中的元素是与数组变量FUNCNAME的元素对应的源文件名。
BASH_SUBSHELL：每次创建一个子shell或在子shell环境中都把这个变量增加一，初始值为0。
BASH_VERSINFO：一个只读数组变量，元素为当前bash的版本信息，从下标0开始的数组元素依次为主版本号（发布号）、次版本号（版本号BASH_VERSION）、补丁级别、编译版本号、发布状态（如beta1）、MACHTYPE的值。
BASH_VERSION：当前bash版本号。
COLUMNS：内建命令select在打印待选列表时用这个变量来设置终端宽度，在收到信号SIGWINCH时这个变量会自动改变。
COMP_CWORD：在包含当前光标位置的单词“${COMP_WORDS}”中的下标，这个变量只能在可编程补全的shell函数中使用。
COMP_LINE：当前命令行，这个变量只能在可编程补全的shell函数中使用。
COMP_POINT：当前光标位置相对于当前命令行开头的下标，如果当前光标位置在当前命令行的尾部，则这个变量的值就与“${#COMP_LINE}”相同，这个变量只能在可编程补全的shell函数中使用。
COMP_TYPE：一个整数值，与触发调用补全函数时试图进行补全的类型相对应，正常补全为“TAB”，连续输入制表符后的补全列表为“?”，列出其它部分补全条目为“!”，没有修改单词而列出补全条目为“@”，补全菜单为“%”，这个变量只能在可编程补全的shell函数中使用。
COMP_KEY：触发当前补全函数的键，或键序列中的最后一个键。
COMP_WORDBREAKS：“readline”库进行单词补全时用作单词分隔的字符，如果没有设置这个变量，即使以后进行重置，它也会失去特殊作用。
COMP_WORDS：一个数组变量，包含当前命令行的每个单词，与“readline”一样当前行被COMP_WORDBREAKS拆分成单词，这个变量只能在可编程补全的shell函数中使用。
COMPREPLY：一个数组变量，bash从这个变量中读取可编程补全所调用的shell函数生成的补全条目。
DIRSTACK：一个数组变量，包含了当前目录栈的内容，目录在栈中按照内建命令dirs所显示的的顺序保存，可以通过对这个数组中元素赋值来修改栈中已有的目录，但必须用内建命令pushd和popd才能删除栈中的目录，对这个变量赋值时不会改变当前目录，如果没有设置这个变量，即使以后进行重置，它也会失去特殊作用。
EMACS：如果bash启动时设置了这个变量且值为“t”，就会认为它正在emacs的shell缓存中运行，并禁止行编辑。
EUID：当前用户的有效用户ID，为只读变量。
FCEDIT：内建命令fc使用选项“-e”时默认要使用的编辑器。
FIGNORE：进行文件名扩展时要忽略的冒号分隔的后缀，如果一个文件名的后缀和这个变量某个条目匹配，它就不会出现在匹配的文件名列表中，例如值为“.o:~”。
FUNCNAME：一个数组变量，包含当前执行栈中所有shell函数的名称，下标为0的元素是当前正在执行的shell函数，而栈底是“main”，这个变量只有在执行shell函数时才有，对FUNCNAME赋值不会生效并且会返回一个错误状态，如果没有设置这个变量，即使以后进行重置，它也会失去特殊作用。
GLOBIGNORE：冒号分隔的一组模式，它定义了文件名扩展时所要忽略的文件名，在文件名扩展中，如果匹配了一个文件名，而这个文件名又和GLOBIGNORE中的一个模式匹配，则它将被从匹配列表中删除。
GROUPS：一个数组变量，包含当前用户所属的用户组，对GROUPS赋值不会生效并且会返回一个错误的状态，如果没有设置这个变量，即使以后进行重置，它也会失去特殊作用。
histchars：不超过三个字符，用来控制历史扩展、快速替换、符号化。其中的第一个是历史扩展字符，即表示历史扩展开始的字符，它通常是个感叹号。第二个字符如果出现在行的开头，则表示要进行快速替换，它通常是字符“^”。第三个字符是可选的，它如果是一个单词的第一个字符，就表示本行中剩余的部分是注释，它通常是字符“#”，历史注释字符使得历史替换忽略本行中剩余的单词，而不一定表示shell解释器会把剩余部分当成注释。
HISTCMD：历史号，即当前命令在历史中的索引号，如果没有设置这个变量，即使以后进行重置，它也会失去特殊作用。
HISTCONTROL：冒号分隔的一组值，它控制命令怎么在历史中保存。如果值中包含“ignorespace”，则不在历史中保存以空格开头的行，值为“ignoredups”表示不保存与前一历史条目匹配的行，值为“ignoreboth”表示“ignorespace”和“ignoredups”，值为“erasedups”表示在保存本行时首先删除与本行匹配的前一行，此外的所有值都会被忽略。如果没有设置这个变量，或它不包含有效的值，则shell解释器会根据HISTIGNORE的值在历史中保存所有读取的行。多行命令的第二个和其余行不会进行如上的检测，不管这个变量如何设置都会保存到历史中。
HISTFILE：用来保存命令历史的文件，默认值是 “~/.bash_history”。
HISTFILESIZE：历史文件中包含的最多行数，如果给这个变量赋值，历史文件就会在必要时删除最早的记录，以保证不超过指定的行数，当交互式的shell退出运行时也会删除这个文件中的最早记录并只保留不超过指定的行数，这个变量的默认值是500。
HISTIGNORE：冒号分隔的一组模式，用以决定哪些命令可以保存在历史中，每个模式都定位在行的开头，必须和整行匹配（没有隐式加上“*”），在进行HISTCONTROL指定的检查后，每个模式都会和当前行匹配，除了shell中通常的模式匹配字符，还可以用“&amp;”来匹配历史中的前一行，如果要使用“&amp;”本身，可以用反斜杠转义，在匹配之前，这个反斜杠将被删除。多行命令的第二个和其余行不会进行检测，不管这个变量如何设置都会保存到历史中。HISTIGNORE包括了HISTCONTROL的功能，“&amp;”模式与“ignoredups”是等价的，而“[ ]*”模式和ignorespace是等价的，把这两个模式用冒号连接起来就和“ignoreboth ”是等价的。
HISTSIZE：历史中保存的最多命令个数，默认值是500。
HISTTIMEFORMAT：如果设置了这个变量且不为空，它的值将用作strftime的格式字符串，并被内部命令history显示历史条目时打印每条历史的时间戳。如果设置了这个变量，时间戳也会写入到历史文件中以便在不同的shell会话中保留这些信息。它使用历史注释字符以便把时间戳和其它历史行区别开来。
HOSTFILE：指定一个格式与“ /etc/hosts” 相同的文件，以便shell补全主机名时使用。在shell运行时可以更改主机名补全的条目。改变这个值后再进行主机名补全时，bash会把新文件中的内容加入到已有的列表中。如果设置了这个变量却没有指定值，bash就试图读取“ /etc/hosts” 来获得主机名补全的条目。如果重置这个变量，就会清空主机名列表。
HOSTNAME：当前主机的名称。
HOSTTYPE：一个字符串，它描述了运行bash的机器的类型。
IGNOREEOF：控制着shell读取到“EOF”字符作为整个输入时的行为。如果设置了，它的值表示连续“EOF”字符的个数；如果shell输入的行首有这么多“EOF”，就会退出。如果设置了这个变量，而其值却不是数值或没有值，则默认为10。如果这个变量不存在，“EOF”字符就表示shell输入的结束。这只有在交互式的shell中才有效。
INPUTRC：“readline”初始化文件的名称，用来覆盖默认值“~/.inputrc”。
LANG：如果语言类别没有特别地用“LC”开头的变量指定，就用这个变量来指定语言类别。
LC_ALL：这个变量覆盖变量LANG和其它LC开头的变量指定的语言类别。
LC_COLLATE：这个变量决定文件名扩展结果的排序顺序，以及文件名扩展和文件名匹配中的范围表达式、等价字符类、语言区域序列。
LC_CTYPE：这个变量决定文件名扩展和模式匹配中对字符的解释和字符类的行为。
LC_MESSAGES：这个变量决定翻译“$”后面的双引用字符串时所使用的语言区域。
LC_NUMERIC：这个变量决定格式化数字时所使用的语言区域。
LINENO：当前执行的脚本或shell函数的行号。……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bash%E7%99%BE%E5%AE%9D%E7%AE%B1shell%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9C%89%E5%93%AA%E4%BA%9B/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bash%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BA%A4%E4%BA%92%E5%BC%8Fshell/" title="Bash的功能交互式Shell">Bash的功能交互式Shell</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            有如下几种调用Bash进入交互式Shell的方式：  没有任何非选项参数
$ bash $ PS1=&ldquo;&gt;&gt; &rdquo; # 此处进入了交互式的子Shell里 &gt;&gt; exit # 退出子Shell exit $
 用-s选项，但不能用-c选项. 这种方式也可以进入交互式Shell.
-s选项后面的参数会作为位参传递给交互式Shell
$ bash -s a b c $ echo $1 $2 $3 a b c
 -i选项强制Shell以交互式方式运行
$ bash -i $ PS1=&ldquo;&gt;&gt; &rdquo; # 此处进入了交互式的子Shell里 &gt;&gt; exit # 退出子Shell exit $
  判断当前Shell是交互式的方法  用Shell特殊参数$-判断
$- 扩展为在调用时，由set命令或由Shell本身设置的当前选项标志。交互式的Shell有-i选项
$ echo &ldquo;$-&rdquo; himBHs $ case &ldquo;$-&rdquo; in &gt; i)echo This shell is interactive ;; &gt; *)echo This shell is not interactive ;; &gt; esac This shell is interactive……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bash%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BA%A4%E4%BA%92%E5%BC%8Fshell/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bash%E7%9A%84%E5%A4%9A%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E5%8F%8Agrep%E7%B3%BB/" title="bash的多命令执行shell脚本基础及grep系">bash的多命令执行shell脚本基础及grep系</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            bash的特性之多命令执行的逻辑关系
1.命令替换
COMMAND1 $(COMMAND2) ：先执行COMMAND2然后再作为COMMAND1的参数执行COMMAND1
[root@localhost ~]# ls /mnt a.sh a.txt ---------------------------------------------------------- [root@localhost mnt]# cat a.sh echo &quot;你好&quot; --------------------------------------------------------- [root@localhost mnt]# cat a.txt useradd xiaoming -c &quot;wang xiaoming&quot; -u 8089 -g 8089 passwd xiaoming -n 5 -x 30 -w 3 -i 7 ----------------------------------------------------------- [root@localhost ~]# cat $(ls /mnt) echo &quot;你好&quot; useradd xiaoming -c &quot;wang xiaoming&quot; -u 8089 -g 8089 passwd xiaoming -n 5 -x 30 -w 3 -i 7  2.……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bash%E7%9A%84%E5%A4%9A%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E5%8F%8Agrep%E7%B3%BB/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bash%E7%B3%BB%E5%88%971shell%E7%B1%BB%E5%9E%8B/" title="BASH系列1shell类型">BASH系列1shell类型</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            ……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bash%E7%B3%BB%E5%88%971shell%E7%B1%BB%E5%9E%8B/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bash%E7%BC%96%E7%A8%8Bshell%E7%BB%83%E4%B9%A0%E9%A2%98/" title="bash编程Shell练习题">bash编程Shell练习题</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            ……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bash%E7%BC%96%E7%A8%8Bshell%E7%BB%83%E4%B9%A0%E9%A2%98/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E4%BA%8Cbashshell%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/" title="Bash脚本编程二BashShell的退出状态">Bash脚本编程二BashShell的退出状态</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            | 〖正天时代〗HTC Touch2/T3333◆原厂原配
&mdash;|&mdash;
1690.0元 |
Bash Shell的退出状态  在上篇 bash 脚本编程文章的介绍中，我们知道所谓脚本就是包含了一组能被特定的 shell 解释并执行的命令集合。在这片文章中，我们会了解 shell 命令以及它们的内部 (internals) 。
命令就是一组单词序列的组合。第一个单词是将被执行的命令，剩下的单词将作为参数传递给这个命令。在这里参数 (arguments) 可以是选项 (options) ，也可以是参数值 (parameters) 。
在命令行中执行的命令有些是 shell 命令，比如 ls,lpr 以及 grep 命令。
$ ls -alF
$ lpr filename
$ grep &ldquo;string&rdquo; filename
Shell ****命令的退出状态 ****
命令的返回值就是它的退出状态，如果该命令被信号 n 终止，那么它的退出状态就是 128+n 。退出状态用来检查命令是否被成功执行。如果状态为 0 ，那么该命令执行成功。如果该命令执行失败，那么退出状态为非零。
Exit Value
|
Exit Status
&mdash;|&mdash;
0(Zero)
|
Success
Non-zero
|
Failure
2
|
Incorrect usage……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E4%BA%8Cbashshell%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9B%9B%E4%B9%8Bshell%E5%87%BD%E6%95%B0/" title="Bash脚本编程四之Shell函数">Bash脚本编程四之Shell函数</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            淘品牌 DM杂志

| 清仓特价 韩版 李孝利 欧美復古罗马斗士 凉鞋 高跟鞋 实拍
&mdash;|&mdash;
58.0元 |
Bash的Shell函数是一种能把若干UNIX/LINUX命令打包执行的方法，在执行时一个简单的名字就能够代替这些命令。执行函数就像执行普通的UNIX命令一样简单。Bash会在当前上下文的环境中执行Shell函数，而不再产生新的进程去解释函数。
Bash alias别名和函数都能帮你为长或复杂的命令定义快捷方式。但是，alias别名不允许控制流，参数，以及其他有技巧的事情。而这些事情，函数都能做到。我们将会在下面讲解。
这篇文章是我们正在进行的Bash脚本编程系列的一部分。你可以查看前三篇文章：Bash脚本编程简介，Bash的退出状态，以及Bash alias别名。
定义一个Bash函数的语法如下：
function functionname() { commands . . } &mdash; function是一个可选的关键字 &mdash; functionname是函数的名字 &mdash; commands 表示在函数中执行的命令。
$ functionname arg1 arg2 &mdash; shell解释一个linux命令时，会先查找特殊的内建函数，像break, continue, eval, exec等函数。然后，Shell才会查找自定义函数。 &mdash; 函数的退出状态也就是在函数体内最后一个命令的退出状态。 注：把Shell函数的定义放在一个Shell的启动文件中。这样，在命令行中你总能找到这个函数。你可以参考我们早些时候的文章Bash的启动顺序，以确定.bash_profile何时会被启动。
例1：一个显示指定后缀名文件的长列表的函数
函数“lsext”可以查找当前目录下的指定后缀名的文件。函数体内使用了find和ls命令。
$ function lsext() { find . -type f -iname &lsquo;*.&lsquo;${1}&rdquo; -exec ls -l {} /; ; } $ cd ~ $ lsext txt -rw-r&ndash;r&ndash; 1 root root 24 Dec 15 14:00 InMorning.……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9B%9B%E4%B9%8Bshell%E5%87%BD%E6%95%B0/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/batt%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8Cadbshell%E4%BB%A5%E5%90%8E%E7%9A%84%E5%91%BD%E4%BB%A4android%E6%8A%93%E5%8C%85/" title="batT脚本如何自动执行adbshell以后的命令android抓包">batT脚本如何自动执行adbshell以后的命令android抓包</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            bat脚本自动执行 adb shell 以后的命令
@echo off echo su &gt; test.txt echo 其它命令(如 cd /data) &gt;&gt; test.txt adb shell &lt; test.txt del test.txt  例如 Android自动抓包
@echo on title android抓包 f: echo su &gt; temp.txt echo cd /data/local &gt;&gt; temp.txt echo ./tcpdump -i wlan0 -p -s 0 -w /sdcard/capture.pcap &gt;&gt; temp.txt adb shell &lt; temp.txt del temp.txt  可参考相关博客 http://blog.csdn.net/xiangjai/article/details/26383119……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/batt%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8Cadbshell%E4%BB%A5%E5%90%8E%E7%9A%84%E5%91%BD%E4%BB%A4android%E6%8A%93%E5%8C%85/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bat%E6%89%B9%E5%A4%84%E7%90%86%E4%B8%8B%E5%A6%82%E4%BD%95%E5%83%8Fshell%E4%B8%80%E6%A0%B7%E5%B0%86%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%95%88%E6%9E%9C%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F/" title="bat批处理下如何像shell一样将命令执行的效果赋值给变量">bat批处理下如何像shell一样将命令执行的效果赋值给变量</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            在bat下如何实现像shell一样，把执行命令行后的结果赋值给变量呐？
刚开始，可真难为到我了。随着对bat批处理知识熟悉的加深。
学习到了！！！
举个 栗子：
svnlook uuid C:\Repository\test # 这行命令什么意思呐。它是svn服务器的命令（因为最近在搞svn的东西啦）。
所以这行命令实现的效果是 返回 test 仓库的 UUID shell 下会这样实现：
UUID=svnlook uuid C:\Repository\test # 这里是 · 哦。这个符号就是键盘ESC按键下的那个 · （好小哦&hellip;&hellip;&hellip;&hellip;&hellip;.）
==================================================
好的~~~看到了吧，shell下实现真的很简单，bat下也是可以实现的但是麻烦了点欸。
dos下： for /f “delims=” %t in (&lsquo;svnlook uuid C:\Repository\test&rsquo;) do set UUID=%t
bat文件中： for /f “delims=” %%t in (&lsquo;svnlook uuid C:\Repository\test&rsquo;) do set UUID=%%t
上面的区别就是 dos下执行 为 %t ， bat文件中执行就是 %%t 。
还有就是要注意 （）里面使用的是单引号，因为在bat里单引号就是引用命令的意思。
这里的 delims 值得就是分隔符的意思。我这里写的是 “delims=” 。没有分隔符，所以会进行 行分割，
这样就可以取到第一行的结果了。……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bat%E6%89%B9%E5%A4%84%E7%90%86%E4%B8%8B%E5%A6%82%E4%BD%95%E5%83%8Fshell%E4%B8%80%E6%A0%B7%E5%B0%86%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%95%88%E6%9E%9C%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F/">阅读全文</a></p>
    </article>
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/bat%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8Cadbshell%E4%BB%A5%E5%90%8E%E7%9A%84%E5%91%BD%E4%BB%A4/" title="BAT脚本如何自动执行adbshell以后的命令">BAT脚本如何自动执行adbshell以后的命令</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            http://mzywqwq.blog.163.com/blog/static/958701220134842449172/
参考：http://zhidao.baidu.com/question/496847483.html
普通情况，可以直接用 ”adb shell rm /data/tmp/xx.sh“ 之类的命令执行一条指令。
需要root权限情况，如果执行adb shell su的话，会进入控制台但是无法输入，用批处理的话也会卡在此处。
可以用输入重定向的方法来解决。
1.将所有需要执行的命令放到一个文本文档中，如cmd.txt
2.用输入重定向的方法： adb shell &lt; cmd.txt
这样就可以完全执行文本文档中的命令了。
例如 cmd.txt:
su
mount -o remount rw /system
touch /system/app/ttt
run.bat :
adb shell &lt; cmd.sh
pause
执行以后会在 /system/app/中生成一个ttt的文件，说明命令执行正常。……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/bat%E8%84%9A%E6%9C%AC%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8Cadbshell%E4%BB%A5%E5%90%8E%E7%9A%84%E5%91%BD%E4%BB%A4/">阅读全文</a></p>
    </article>
    
    



<ol class="page-navigator">
    
    <li class="prev">
        <a href="https://zaina.newban.cn/page/96/">上一页</a>
    </li>
    

    

    
        
        
    
    

    
        
        
        <li >
            <a href="https://zaina.newban.cn/">1</a>
        </li>
        
    
        
        <li>
            <span>...</span>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/page/95/">95</a>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/page/96/">96</a>
        </li>
        
    
        
        
        <li  class="current">
            <a href="https://zaina.newban.cn/page/97/">97</a>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/page/98/">98</a>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/page/99/">99</a>
        </li>
        
    
        
        <li>
            <span>...</span>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/page/1960/">1960</a>
        </li>
        
    

    
    

    <li class="next">
        <a href="https://zaina.newban.cn/page/98/">下一页</a>
    </li>
    
</ol>




</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>