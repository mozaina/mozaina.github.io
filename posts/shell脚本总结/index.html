<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell脚本总结 | 开发者问答集锦</title>
    <meta property="og:title" content="shell脚本总结 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell脚本总结">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E8%84%9A%E6%9C%AC%E6%80%BB%E7%BB%93/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell脚本总结</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p>shell总结</p>

<p>shell脚本的本质是shell命令的有序集合</p>

<p>建立shell脚本的步骤:建立shell脚本，编写任意多行操作系统命令或shell命令，增加文件的执行权限，结束</p>

<p>shell变量</p>

<p>shell允许用户建立变量存储数据，但不支持数据类型。将任何赋给变量的值都解释为一串字符</p>

<p>shell有如下四种变量：用户自定义变量，位置变量，预定义变量，环境变量</p>

<p>用户自定义变量：</p>

<p>定义变量：COUNT=1</p>

<p>使用时前面加$：echo $COUNT</p>

<p>删除变量的赋值：unset COUNT</p>

<p>位置变量：</p>

<p>$0 与键入的命令行一样，包含脚本文件名</p>

<p>$1,$2&hellip;$9 分别包含第一个到第九个命令行参数</p>

<p>$# 包含命令行参数的个数</p>

<p>$@ 包含所有命令行参数：“$1,$2&hellip;$9 ”</p>

<p>$? 包含前一个命令的退出状态</p>

<p>$* 包含所有命令行参数：“$1,$2&hellip;$9 ”</p>

<p>$$ 包含正在执行进程的ID号</p>

<p>shell环境变量</p>

<p>CDPATH 用于cd命令的查找路径</p>

<p>HOME 用户主目录</p>

<p>PATH 路径</p>

<p>shell 程序和语句</p>

<p>shell程序由0到n条shell语句构成，shell语句包括三大类：功能性语句、结构性语句、说明性语句</p>

<p>说明性语句：以#开始的部分，不被解释执行</p>

<p>可以出现在程序的任意位置，可以单独一行，也可以接在执行语句的后面</p>

<p>功能性语句：任意操作系统命令、shell内部命令、自编程序、等</p>

<p>read 从标准输入读出一行，赋给后面的变量</p>

<p>read var #把读入的数据全部赋给var</p>

<p>read var1 var2 var3 #把读入一行的第一、二个词分别赋给var1、var2，其他的都赋给var3</p>

<p>如果执行read语句时标准输入无数据，则程序在此停留等候，直到数据到来或终止运行</p>

<p>expr 主要用于简单的整数运算，包括 + - \* / % 等</p>

<p>反撇号用于引用命令的运行结果</p>

<p>test 用于测试三种对象：字符串、整数、文件属性</p>

<p>可用[ ]代替，注意左右都至少一个空格</p>

<p>如：test “$answer” = “yes” #变量answer的值是否为字符串yes</p>

<p>test $num -eq 18 #变量num的值是否为整数18</p>

<p>test -d tmp #测试tmp是否为一个目录名</p>

<p>结构性语句：条件测试语句、多路分支语句、循环语句、循环控制语句、后台执行语句</p>

<p>条件测试语句</p>

<p>if&hellip;then&hellip;else&hellip;fi</p>

<p>语法结构:</p>

<p>if 表达式</p>

<p>then</p>

<p>命令表1 #一条或者若干条命令</p>

<p>else</p>

<p>命令表2 #一条或者若干条命令</p>

<p>fi</p>

<p>如果表达式为真，执行命令表1，否则执行命令表2</p>

<p>例子；</p>

<p>if [ -f S1 ] #测试参数是否为文件</p>

<p>then</p>

<p>echo “File $1 exists”</p>

<p>fi</p>

<p>if [-d $HOME/$1] #测试参数是否为目录</p>

<p>then</p>

<p>echo “File $1 is a directory”</p>

<p>fi</p>

<p>多路分支语句</p>

<p>case&hellip;esac</p>

<p>语法结构：</p>

<p>case 字符串变量 in #case语句只能检测字符串变量</p>

<p>模式1）</p>

<p>命令表1</p>

<p>；；</p>

<p>模式2）</p>

<p>命令表2</p>

<p>；；</p>

<p>。。。。</p>

<p>*) # *表示其他所有</p>

<p>命令表n</p>

<p>;;</p>

<p>esac</p>

<p>例如：</p>

<p>case $1 in</p>

<p>file1)</p>

<p>echo “file1”</p>

<p>;;</p>

<p>file2)</p>

<p>echo “file2”</p>

<p>；；</p>

<p>*）</p>

<p>echo “others”</p>

<p>;;</p>

<p>esac</p>

<p>循环语句</p>

<p>for&hellip;do&hellip;done</p>

<p>当循环次数已知或者确定时，使用for循环语句来多次执行一条或一组命令，循环体由do和done来限定</p>

<p>for 变量名 in 单词表</p>

<p>do</p>

<p>命令表</p>

<p>done</p>

<p>说明：变量依次取单词表中的各个单词，每取依次单词，就执行一次循环体，循环次数为单词表中的单词个数，命令表中可以是一条或由分号隔开的多条命令</p>

<p>如果单词表是命令行上的所有位置参数时，可以省去 in 单词表</p>

<p>list=<code>ls</code></p>

<p>for file in $list</p>

<p>do</p>

<p>if[ $1 = $file ]</p>

<p>then</p>

<p>echo “$file found”;</p>

<p>exit; #退出shell脚本</p>

<p>fi</p>

<p>done</p>

<p>while&hellip;do&hellip;done</p>

<p>语法结构：</p>

<p>while 命令或表达式</p>

<p>do</p>

<p>命令表</p>

<p>done</p>

<p>说明：while首先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，知道为假，退出循环</p>

<p>until&hellip;do&hellip;done</p>

<p>语法结构：</p>

<p>until 命令或表达式</p>

<p>do</p>

<p>命令表</p>

<p>done</p>

<p>与上面的相反</p>

<p>循环控制语句:</p>

<p>break 和 continue</p>

<p>break n 跳出n层</p>

<p>continue 马上跳转到最近一层循环的下一轮循环</p>

<p>continue n 转到最近n层循环语句的下一轮循环上</p>

<p>shell函数</p>

<p>shell程序中，常把完成固定功能且多次使用的一组命令封装在一个函数中，每当要使用时，调用函数名即可</p>

<p>函数调用前必须先定义，即顺序上先定义函数，再调用</p>

<p>调用程序可以传递参数给函数，函数可以用return语句把运行结果返回调用程序</p>

<p>函数只在当前shell中起作用，不能输出到子shell中</p>

<p>shell函数定义格式</p>

<p>function funtion_name () #function可以省掉</p>

<p>{</p>

<p>&hellip;</p>

<p>}</p>

<p>函数调用方式</p>

<p>value_name = <code>function_name [arg1 arg2 ...]</code> #函数结果返回给变量</p>

<p>或</p>

<p>function_name [arg1 arg2 &hellip;]</p>

<p>echo $? #获取函数返回的状态</p>

<p>函数变量的作用域</p>

<p>全局作用域：在脚本的其他地方都可以访问该变量</p>

<p>局部作用域：只能在声明的作用域内访问</p>

<p>局部变量的声明: Local variable_name = value</p>

<p>脚本调试：</p>

<p>跟踪脚本执行结果：</p>

<p>在希望开始调试的地方插入 set -x</p>

<p>在希望结束调试的地方插入 set +x</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>Bash shell结构</p>

<p>1：shbang行：脚本的第一行，告之内核用哪个shell解释shell脚本，由#!加shell的完整路径组成</p>

<p>2：注释：#后面的为注释，可以在一行后</p>

<p>3：shell通配符或元字符:shell中字符意义比较特殊，如* ？ [] &gt; &gt;&gt; |等，防止这些字符被解释，则必须引用他们</p>

<p>4：局部变量：局部变量作用域在本shell中</p>

<p>5：全局变量：又称为环境变量，由内置的export命令创建，作用域在本shell及子shell中</p>

<p>6：提取变量值：$</p>

<p>7：参数：可以从命令行传递参数给脚本</p>

<p>8：命令替换：<code>A</code> $(A) 结果可以赋给一个变量或代替所在位置</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>正则表达式</p>

<p>正则表达式是一种字符模式，在查找过程中匹配指定的字符，可以用特殊的元字符来控制它们,正则表达式都被置于两个正斜杠//之间</p>

<p>元字符：表达的是不同于字符本身的含义</p>

<p>本书中的元字符有两类：shell元字符、正则表达式元字符，它们各司其职，shell元字符是由shell解析的，就是下面所讲的文件名置换；正则表达式元字符是由各种执行模式操作的程序来解析的，如vi、grep、sed、awk</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>正则表达式元字符：</p>

<p>^ 行首定位</p>

<p>$ 行尾定位</p>

<p>. 匹配单个字符</p>

<ul>
<li>匹配0或多个重复的位于*前的字符</li>
</ul>

<p>[] 匹配指定组字符中的任意一个 ；如[LlT]</p>

<p>[-] 匹配指定范围内的字符 ；如[x-yA-Z0-8]</p>

<p>[^] 匹配不在指定组内的字符</p>

<p>[^ - ]跟上面的相反</p>

<p>\ 转移跟在后面的字符 #转义元字符，使之不被解释</p>

<p>\词首定位符 #定位以什么开头的词</p>

<p>&gt; 词尾定位符 #定位以什么结尾的词</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>grep 家族</p>

<p>grep家族由grep、egrep、fgrep组成</p>

<p>grep命令在文件中全局查找指定的正则表达式，并打印所有包含该表达式的行</p>

<p>一般格式：grep [选项] 基本正则表达式 [文件]</p>

<p>选项：-n 显示行号 -i 大小写不敏感 -w表达式作为词来查找，也就是不是一个词的一部分 -r 递归查找</p>

<p>基本正则表达式：可为字符串，如果为字符串，最好用“”如果是模式匹配，用‘’调用变量时，也应该使用“”</p>

<p>文件：可以为多个文件；如 A1 A2</p>

<p>常用举例子</p>

<p>grep -n “your” www #文件www中查找含有your单词的行，且输出行号</p>

<p>grep -nw “your” www #文件www中查找含以your做单词的行，且输出行号</p>

<p>grep -nr ‘[a-zA-Z0-9].you’ ./ #递归./ 中查找含有以a-z A-Z 0-9开始的单词的行，且输出行号</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>find命令及xargs</p>

<p>find pathname -options [-print -exec -ok]</p>

<p>常用的options为name 此时记住要用引号将文件名模式引起来</p>

<p>find ./ “*org.txt” #在当前目录及子目录中寻找以org.txt结尾的文件</p>

<p>find 找到文件后可用xargs对其操作</p>

<p>find ./ “*org.txt” | xargs ls</p>

<p>find ./ “*org.txt” | xargs grep “device” #在结果中搜索device</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>启动</p>

<p>系统启动后</p>

<p>-&gt;init-&gt;getty进程</p>

<p>-&gt;/bin/login 初始化环境，启动shell</p>

<p>-&gt;/bin/bash 执行/ect/profile,执行~/.bash_profile ~/.bash_login ~/.profile,执行~/.bashrc</p>

<p>-&gt;等待用户输入</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>环境</p>

<p>一个进程的环境包括：变量等，它定义了可以从一个进程继承到下一个进程的特性</p>

<p>用户的shell配置定义在shell初始化文件中，bash
shell有许多启动文件，这些文件可以执行source命令，对一个文件执行source命令会使得这个文件中的所有设置称为当前shell的一部分，也就是说不会创建子shell</p>

<p>登陆时，会执行~/.bash_profile文件执行source命令，如无，则source ~/.bash_login,若无，则source
~/.profile,这三个文件只能source一个，再source ~/.bashrc</p>

<p>~/.bashrc：包含特定的变量和别名，当一个新的bash shell启动或bash脚本启动时会自动执行source ~/.bashrc</p>

<p>在当前提示符下输入shell或bash启动的是子shell</p>

<p>/etc/bashrc：系统级的函数和别名可以在/etc/bashrc文件中设置，主提示符一般在这设置</p>

<p>~/.profile：是一个用户定义的初始化文件，它是被Bourne shell使用的，因此不能包括对bash
shell的特定设置，运行bash时只有没找到其他文件时才source此文件，它允许用户定制和修改shell环境，也可以放应用程序的初始化</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>source命令或dot命令(.) 和 ./命令</p>

<p>source命令式内置的bash命令，来自C shell</p>

<p>dot命令也就是. 来自Bourne shell</p>

<p>二者完全一样，都是一个脚本名作为参数，shell将在当前的shell环境中执行这个脚本，也就是不启动子shell,脚本中的设置的所有参数将成为当前shell环境的一部分。</p>

<p>./执行脚本时是创建子shell,脚本中的设置参数在脚本退出后就无效了。</p>

<p>例子：在家目录下的.bashrc中加入WANG=”ni hao”</p>

<p>然后. .bash.rc</p>

<p>此时执行内容为 echo “$WANG”的 脚本</p>

<p>如用 ./sh.sh 则无输出 #./执行时是在起一个子shell</p>

<p>如用source sh.sh或 . sh.sh则输出ni hao #source是在本shell中执行</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>bash shell元字符(通配符)</p>

<p>\ 按字面含义解释后面的那个字符</p>

<p>&amp; 在后台处理的进程</p>

<p>； 分隔命令</p>

<p>$ 替换命令</p>

<ul>
<li>匹配任意字符</li>
</ul>

<p>? 匹配任意单个字符</p>

<p>[&hellip;] 匹配[]中的任意一个字符</p>

<p>[!&hellip;] 不匹配[]中!的任意一个字符</p>

<p>(cmds) 在子shell中执行命令</p>

<p>{cmds} 在当前shell中执行命令</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>文件名置换</p>

<p>计算命令行时，shell会用元字符来缩写能够匹配某个特定字符组的文件名或路径名</p>

<p>将元字符展开为文件名或路径名的过程称为文件名替换或globbing</p>

<ul>
<li>匹配文件（夹）名中的任意字符串</li>
</ul>

<p>如：ls app*</p>

<p>cd cmdd*</p>

<p>? 匹配文件（夹）名中的任意一个字符</p>

<p>[&hellip;] 匹配[]中的任意一个字符</p>

<p>[!&hellip;] 不匹配[]中!的任意一个字符</p>

<p>如：ls [a-z]*.o #匹配以a-z开头的已.o结尾的文件</p>

<p>ls [!0-9]*.o #匹配以非0-9开头的已.o结尾的文件</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>命令执行顺序</p>

<p>命令1 &amp;&amp; 命令2 #命令1执行成功才会执行命令2</p>

<p>命令1 || 命令2 #命令1执行不成功才会执行命令2</p>

<p>用（） 和 {}将命令结合在一起</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>Bash shell变量</p>

<p>变量可分为两种：局部变量和环境变量</p>

<p>局部变量只在创建他们的shell中可用，环境变量作用域可以扩展到子shell中去</p>

<p>变量命名规则：可以是字母、0-9、下划线组成，必须以字母或下划线开头，其他字符都标志着变量名的终止，变量名大小写敏感</p>

<p>有两个内置命令可以用来创建变量，他们是declare、typset，其选项可以控制变量的设置方式，建议使用declare.</p>

<p>格式：declare [选项] 变量=值</p>

<p>选项：-x 将变量设置成环境变量</p>

<p>-r 将变量设置成只读变量</p>

<p>-a 将变量当一个数组</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>创建局部变量</p>

<p>1：变量赋值：变量=值 #注意等号周围不能有任何空白字符，如果想赋空，可以在等号后跟上换行符</p>

<p>2：内置命令declare 变量=值 #注意等号周围不能有任何空白字符，如果想赋空，可以在等号后跟上换行符</p>

<p>例子：</p>

<p>设置：round=world 或 round=”world nice” #“”保护空白符</p>

<p>设置：declare round=world</p>

<p>输出：echo $round</p>

<p>设置：file.bak=”xxxx” 错，变量名中出现非法字符</p>

<p>local函数：函数内创建局部变量可以用local函数</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>创建环境变量</p>

<p>环境变量，又被称为全局变量，作用域可以扩展到子shell中，通常环境变量用大写</p>

<p>环境变量是已经用export内置命令导出的变量，如果想设置环境变量，只需在设置变量时或赋值后使用export命令即可，declare 带-x也是设置环境变量</p>

<p>设置环境变量：</p>

<p>1：export 变量=值 #注意等号周围不能有任何空白字符，如果想赋空，可以在等号后跟上换行符</p>

<p>2：变量=值; export 变量 #注意等号周围不能有任何空白字符，如果想赋空，可以在等号后跟上换行符</p>

<p>3：declare -x 变量=值 #注意等号周围不能有任何空白字符，如果想赋空，可以在等号后跟上换行符</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>设置只读变量</p>

<p>只读变量是不能被重新定义或复位的特殊变量，但是如果使用declare定义的变量，可以重定义，不能复位</p>

<p>设置：name=”TOM”</p>

<p>readonly name #设置只读</p>

<p>unset name #不能复位</p>

<p>name=Jem #不能重定义</p>

<p>设置：declare -r city=”shanghai”</p>

<p>unset city #不能复位</p>

<p>declare city=“beijin” #可以</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>提取变量的值</p>

<p>在变量前加$</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>复位变量</p>

<p>只要不被设置只读，局部变量和环境变量都可以用unset命令复位</p>

<p>格式：unset 变量名</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>显示变量值</p>

<p>1：echo [选项] 变量 #echo将他的参数显示到标准输出上</p>

<p>选项：-e #允许解释转义字符，如echo -e “\a” \a转义为报警</p>

<p>如：echo The name is $NAME</p>

<p>echo -e “\a” #报警</p>

<p>2：printf命令</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>变量扩展修饰符</p>

<p>可以用一些专用修饰符来测试和修改变量，修饰符首先进行简单的条件测试，检查某变量是否已被设置，然后根据测试结果给变量赋值</p>

<p>${VA:-word} #如变量VA已经设置且非空，则代入其值，否则代入word 临时替换默认值</p>

<p>${VA:=word} #如变量VA已经设置且非空，则代入其值，否则VA设置为word，代入VA永久替换默认值</p>

<p>${VA:+word} #如变量VA已经设置且非空，则代入word,否则代入空值 临时替换默认值</p>

<p>${VA:?word} #如变量VA已经设置且非空，则代入其值,否则输出word且从shell退出 基于默认值创建错误信息</p>

<p>注：不加冒号时，值为空也被认为已经设置</p>

<p>如：echo ${name-Joe} #结果为空</p>

<p>echo ${name:-Joe} #结果为Joe</p>

<p>echo ${namex:?”namex is undefined”}</p>

<p>echo ${y?} #如果y未设置，否则输出parameter null or not set</p>

<p>${VA:offset} #获取变量VA值中位置从offset开始的字串</p>

<p>${VA:offset:length} #获取变量VA值中位置从offset开始长度为length的字串 创建字串</p>

<p>如：var=notebook</p>

<p>echo ${var:0:4} #结果note</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>子串的变量扩展</p>

<p>模式匹配变量用来在串首或串尾截掉串的一部分，常用语删除路径名的头或尾</p>

<p>${变量%模式} #将变量值的尾部与模式进行最小匹配，并将匹配到的部分删除</p>

<p>${变量%%模式} #将变量值的尾部与模式进行最大匹配，并将匹配到的部分删除</p>

<p>${变量#模式} #将变量值的头部与模式进行最小匹配，并将匹配到的部分删除</p>

<p>${变量##模式} #将变量值的头部与模式进行最大匹配，并将匹配到的部分删除</p>

<p>${#变量} #替换为变量中的字符个数，如果是*或@ ，长度则是位置参量的个数</p>

<p>如：</p>

<p>pathname=”/usr/bin/local/bin”</p>

<p>echo ${pathname%/bin*} #结果/usr/bin/local/</p>

<p>echo ${pathname%%/bin*} #结果/usr</p>

<p>echo ${pathname#/usr} #结果/bin/local/bin</p>

<p>echo ${pathname##/usr} #结果bin</p>

<p>echo ${#pathname} #结果8</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>位置参量</p>

<p>下面这组专用内置变量常称为位置参量，通常被shell脚本用来从命令行接受参数，或被函数用来保存传递给它的参数</p>

<p>$0 #指当前shell脚本的名称</p>

<p>$1-$9 #代表第一个到第9个位置参量</p>

<p>${10} ${11} #第10、11个位置参量,不用$10,$11</p>

<p>$# 其值为位置参量的个数，不含$0</p>

<p>$*  其值为所有的位置参量</p>

<p>$@  同$*</p>

<p>“$*” 其值为“$1 $2 $3”</p>

<p>“$@” 其值为“$1”“$2”“$3”</p>

<p>位置参数可以用set命令来设置、重置或复位</p>

<p>set &ndash; #清除所有的位置参数</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>其他特殊变量</p>

<p>$ #当前shell的pid</p>

<p>_ #当前sh的选项设置</p>

<p>? #已执行的上一条命令的退出值</p>

<p>! #最后一个进入后台的作用的pid</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>引用</p>

<p>用来保护特殊的元字符不被解释和禁止参量扩展</p>

<p>引用有三种方式：反斜杠、单引号、双引号</p>

<p>需要引用的特殊元字符有:</p>

<p>;</p>

<p>&amp;</p>

<p>()</p>

<p>{}</p>

<p>|</p>

<p>空格 tab 换行符</p>

<p>$</p>

<ul>
<li>[] ?</li>
</ul>

<p>1：单引号和双引号必须成对出现</p>

<p>2：单引号保护特殊元字符免受解释，双引号也能，但双引号允许处理变量替换字符$和命令替换字符``和</p>

<p>3：双引号可以保护单引号，单引号可以保护双引号</p>

<p>4：如果有不匹配的引号，bash会出现次提示符</p>

<p>反斜杠：反斜杠用于引用(或转义)单个字符，使其免受解释。</p>

<p>单引号中的反斜杠不会被解释</p>

<p>如果在双引号中，反斜杠将保护$ ``和反斜杠免受解释</p>

<p>单引号：成对出现，保护所有元字符不被解释，打印双引号就必须用双引号将其括起来，或反斜杠转义</p>

<p>双引号：同单引号，但是允许进行变量替换$和命令替换``和</p>

<p>简言之：单引号中什么都不被解释。双引号中$ `` \这三个会被解释，如不想解释用\转义</p>

<p>注意：``同$()是一样的，所以$(date)也会展开</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>命令替换</p>

<p>命令替换的用处是将命令的输出结果赋给一个变量或将命令的输出结果代入命令所在位置</p>

<p>bash 允许使用两种格式：<code>命令</code>  和  $(命令)</p>

<p>执行扩展时，bash先执行命令，然后返回命令的标准输出，输出结果末尾的换行符都将被删除，如果不想删除，可用“”括起，如：echo “$(cal)”</p>

<p>如：echo “this is <code>date +%H</code>” #this is 09</p>

<p>d=$(date) #d存放命令date的结果</p>

<p><code>命令</code> \保留字面意思，除非后面跟$ <code>\ 且</code><code>中$ \生效，可用\转义之，</code><code>中再有</code>`的话必须用\转义</p>

<p>$(命令) 中的所有特殊字符都不会解释</p>

<p>命令替换可以被嵌套，`<code>必须使用\\</code>转义，如echo <code>basename \\</code>pwd\
#其中转义后的<code>pwd</code>也是当做命令替换的，如:$(basename $(pwd))</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>数组</p>

<p>bash 中可以创建一维数组，数组允许将一列词放到一个变量名中，可以用内置命令declare -a创建，或直接给变量名一个下标来创建，如x[0]=5
索引值为从0开始的整数，数组无上限，索引也不必是有序数。</p>

<p>取出数组中某个元素，语法为：${数组名[索引]}</p>

<p>创建数组：</p>

<p>declare 、local 、read-only内置命令也可以带-a选项来声明一个数组。read -a是读取一列词到数组中</p>

<p>declare -a va_name=(item1 item2 item3 &hellip;)</p>

<p>declare -ar va = {item1 item2 item3 &hellip;}</p>

<p>states=(ME [3]=CA [2]=CT) #数组states第0元素为ME 3元素为CA 2元素为CT</p>

<p>declare -a nums=(45 33 100 65)</p>

<p>name=(TOM Dick Harry)</p>

<p>echo ${va_name[*]} #输出数组所有元素</p>

<p>echo ${#va_name[*]} #输出数组大小</p>

<p>取消定义：unset name 或 unset name[2]</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>函数</p>

<p>bash函数用于在当前shell环境(不派生子shell)通过函数名执行一组命令，函数常常用于提高脚本的模块化程度。</p>

<p>函数可被重复调用。函数必须定义后才会被调用</p>

<p>定义函数：有两种格式声明一个bash函数</p>

<p>1：函数名后跟一对圆括号，再跟函数定义</p>

<p>function_name () { commands;commands; }</p>

<p>2:function关键词后跟函数名及函数定义，圆括号可选</p>

<p>function function_name { commands;commands;}</p>

<p>function function_name () { commands;commands;}</p>

<p>注意：命令之间用；隔开，最有一条命令必须以分号终结。花括号两侧空格是必须的。</p>

<p>传递给函数的任何参数被当做函数内的位置参数，一个函数的位置参数相对于函数来说是局部的</p>

<p>内置命令local允许在函数定义中创建局部变量</p>

<p>函数可以递归调用本身</p>

<p>函数中的命令是在当前shell环境下执行</p>

<p>全局函数：同变量一样，函数作用域可以扩展到子shell,只要用export -f全局化函数</p>

<p>export -f 函数名</p>

<p>说明：当函数命令列在单独的行，可以不用分号，最后一条还是需要。如果列在同一行，必须用分号隔开</p>

<p>如：function welcome { echo “Hi $1 and $2”; }</p>

<p>welcome tom joe #传递参数给函数，结果为Hi tom and joe</p>

<p>set jane anna lizzy</p>

<p>echo $1 $2</p>

<p>jane anna</p>

<p>unset -f welcome #清除函数定义</p>

<p>列出和清除函数</p>

<p>declare -f #列出该shell中定义的所有函数及他们的定义</p>

<p>declare -F #同上，只列出函数名</p>

<p>unset -f #清除函数定义</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>管道</p>

<p>管道（pipe）将管道符左侧命令的输出作为到管道符右侧命令的输入，一条管道线可能不止一个管道</p>

<p>管道符用竖杠 | 表示，一般形式：命令1 | 命令2 | 命令3</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>shell内置命令</p>

<p>shell中有许多内置到它的源码中的命令，shell无需到磁盘中定位他们，执行速度速度快很多。</p>

<dl>
<dt>常见内置命令如下：</dt>
<dd><p>#空命令</p></dd>
</dl>

<p>. #在当前进程的环境下执行程序，同source</p>

<p>alias #命令重命名</p>

<p>unalias #删除重命名</p>

<p>bg #将作业放到后台</p>

<p>cd</p>

<p>exit</p>

<p>fg #将作业放到前台</p>

<p>jobs #列出放在后台的作业</p>

<p>set #设置选项和位置参数</p>

<p>unset #删除变量值或函数</p>

<p>declare</p>

<p>export</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>Bash shell编程</p>

<p>shell脚本：当命令不在命令行上执行，而是通过一个文件执行时，该文件被称为shell脚本，脚本以非交互的方式运行。它先查找环境变量所指定的环境文件，通常为.bashrc，然后从该文件开始执行，然后才开始执行脚本中的命令</p>

<p>创建shell脚本的步骤：</p>

<p>1：第一行：#!/bin/bash</p>

<p>2：编写内容</p>

<p>shell脚本结构：由一组Unix/linux命令、bash shell命令、程序结构控制语句、注释 组成</p>

<p>3：增加执行权限 chmod +x files</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>读取用户输入</p>

<p>read命令</p>

<p>read是一个内置命令，用于从终端或文件读取一个输入行，直到换行符，行尾的换行符被转换成一个空字符，如果后面未跟变量名，则读取的行被赋给内置变量REPLY,可以用read中断脚本的运行，直至输入回车键</p>

<p>read var #把读入的数据全部赋给var</p>

<p>read var1 var2 var3 #把读入一行的第一、二个词分别赋给var1、var2，其他的都赋给var3</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>算术运算</p>

<p>整数运算(declare和let命令)</p>

<p>declare命令：可以用declare -i
定义整形变量，如果给一个整形变量赋一个字符串，则bash将把变量赋值为0，可以对已定义的整形变量执行算术运算(如果未定义为整形变量，内置的let命令也允许算术操作)，如果给整形变量赋一个浮点数值，则bash报语法错误。数字可以用不同基数的数字表示</p>

<p>如：declare -i num</p>

<p>num=5 + 5 #错</p>

<p>num=5+5 #对</p>

<p>num=”5 + 5” #对</p>

<p>num=5.6 #错</p>

<p>declare -i 将列出所有已经设置的整形变量及其值</p>

<p>用不同的基数表示数字</p>

<p>格式:variable=base#number</p>

<p>如：declare -i x=017</p>

<p>x=2#101</p>

<p>x=8#17</p>

<p>let命令：let命令式bash shell内置命令，用来执行整形算术运算和数值表达式测试；可用（（））表示let命令</p>

<p>let命令在执行算术运算时，不需要用$来展开变量，参数含有空格则用“”包含</p>

<p>如：let “i = i + 2”</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>位置参数</p>

<p>用户可以通过命令行向脚本传递信息，跟在脚本名后的用空白符分隔的每个词都称为参数,可以在脚本中使用位置参数来引用命令行参数</p>

<p>shell环境中的位置参数作用域在本shell,shell脚本执行时跟在后面的参数相当于局部的位置参数，只对本脚本生效</p>

<p>如：脚本内容 echo “$1”</p>

<p>执行时 source sh.sh wang #则输出wang</p>

<p>如果在命令行set hahaha</p>

<p>执行时 source sh.sh wang #则输出wang</p>

<p>执行时 source sh.sh #则输出hahaha</p>

<p>set命令与位置参数</p>

<p>可以用set命令设置或重设位置参数</p>

<p>带参数的set命令将重置位置参数，重置的是shell环境中的位置参数。清除所有位置参数，可以用set &ndash; 命令</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>条件结构和流程控制</p>

<p>条件结构能够根据某个特定的条件是否满足，来执行相应的任务</p>

<p>bash可以检测两种类型条件：命令成功或失败，表达式为真或假。在任何一种类型的测试中，都要使用退出状态，为0表示命令成功或表达式为真，非0表示命令失败或表达式为假。退出状态保存在状态变量?中<br />
简言之：bash中执行命令成功与否和表达式为真或假都会改变退出状态变量?</p>

<p>内置命令test</p>

<p>单方括号的test命令：通常使用内置的test命令测试表达式的值，test命令可以被链接到方括号上，这样即可使用单独的test命令，也可通过把表达式用单括号括起来，来测试表达式的值</p>

<p>用test命令或[]测试表达式时，表达式中的shell元字符不会被解释。由于对变量进行单词分离，因此包含空白符的字符串必须用引号括起来</p>

<p>双方括号的test命令：用[[]]来测试表达式的值，其中对变量不进行单词分离，但可以通过元字符扩展进行模式匹配。包含空白符的字符串必须用引号括起来,如果一个字符串（不管含不含空白符）仅仅是在表达式中作为一个普通字符串，而不是一个模式的一部分，则必须用引号括起来</p>

<p>逻辑操作符&amp;&amp;、||代替了与test命令一起使用的-a -o选项</p>

<p>说明：test可以用来测试字符串、数字、文件。test命令中表达式等号两侧必须有空格。单方括号第一个方括号后必须有空格，表达式两侧必须有空格。</p>

<p>简言之:</p>

<p>[]的测试表达式：表达式可为字符串比较、数字比较、文件测试。表达式等号两侧必须有空格，方括号必须有空格。表达式中的shell元字符不会被扩展。对变量进行单词分离，所以包含空格时必须用引号括起来</p>

<p>[[]]的测试表达式：表达式可为字符串比较、数字比较、文件测试。表达式等号两侧必须有空格，方括号必须有空格。表达式支持shell元字符，如果为普通字符串，防止误认为模式，必须用双引号括起来。支持逻辑&amp;&amp;
|| ，对应test中的-a -o ，其中对变量不进行单词分离，即使变量由多个词组成也不需要双引号括起来</p>

<p>let和带双圆括号的算术运算符（（））</p>

<p>对于计算算术表达式，可以不用test而用let命令，let命令含有丰富的操作符，let命令等同（（））</p>

<p>(())中的变量不需要使用$,操作符两侧必须空格，圆括号两侧必须空格</p>

<p>简言之：let命令更适合整形算术运算和数值表达式测试</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>if命令</p>

<p>if 结构后面的命令可以是bash内置命令或可执行程序，如ls</p>

<p>bash shell中跟在if后面的则是一条或一组命令。</p>

<p>exit 命令和变量? exit用于终止脚本并返回到命令行</p>

<p>检查空 检查变量的值是否为空时，必须用双引号把空括起来，否则test命令失败</p>

<p>if 命令</p>

<p>then</p>

<p>命令</p>

<p>elif 命令</p>

<p>then</p>

<p>命令</p>

<p>elif 命令</p>

<p>then</p>

<p>命令</p>

<p>fi</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>null命令(shell内置命令)</p>

<p>：代替null命令</p>

<p>null命令不做任何事，只是返回退出状态0(注意没退出，不同于exit 0)</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>case命令</p>

<p>格式：</p>

<p>case 变量 in</p>

<p>表达式1）</p>

<p>命令组</p>

<p>；；</p>

<p>表达式2）</p>

<p>命令组</p>

<p>；；</p>

<p>&hellip;</p>

<p>*）</p>

<p>命令组</p>

<p>；；</p>

<p>esac</p>

<p>变量的值逐一与表达式相比，符合则执行命令组，并跳到esac后继续执行</p>

<p>表达式可以使用shell通配符，还可以使用 | 将两值相或</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>循环命令</p>

<p>bash shell提供三种类型的循环：for while until</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>for命令</p>

<p>格式:</p>

<p>for 变量 in 词表</p>

<p>do</p>

<p>命令组</p>

<p>done</p>

<p>注：词表可以通过执行命令获得，如 for W in $(date)</p>

<p>词表支持shell元字符：如 for file in memo[1-5]</p>

<p>注意词表是$* $@ “$*” “$@”时的区别</p>

<p>如果没有“in 词表”则相当于“ for 变量 in $* ”</p>

<p>如果命令行参数为*，则它表示当前目录下的所有文件。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>while命令</p>

<p>格式：</p>

<p>while 测试命令</p>

<p>do</p>

<p>命令(命令组)</p>

<p>done</p>

<p>注：while 后的测试命令可以用test 或let或其他</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>until命令</p>

<p>同while命令，只不过相反，也就是until 后的命令执行不成功时执行命令组</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>循环控制命令</p>

<p>shift命令</p>

<p>shift 命令将参数左移指定次数，如：shift 5，没给参数时移动一次,当不够移动时，输出信息。</p>

<p>shift常用于while循环中遍历位置参数列表时。</p>

<p>如：while (( $# &gt; 0 ))</p>

<p>do</p>

<p>echo $1 #$1值不断变化</p>

<p>shift</p>

<p>done</p>

<p>ture命令：总是已状态0退出</p>

<p>break命令</p>

<p>break用于跳出循环，层数为跳出几层</p>

<p>continue命令 跳过本次循环，继续下次，参数为调到哪一层循环起点，默认为跳到最近一层</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>I/O重定向 与 子shell</p>

<p>shell可通过管道或重定向将输入从文件输入改为从循环读取输入，输出到循环改为输出到文件</p>

<p>shell启动一个子shell来处理I/O重定向和管道，循环结束后，在循环中定义的所有变量对脚本的其余部分都是不可见的</p>

<p>重定向一般是到文件，管道一般是到命令</p>

<p>将循环的输出重定向到一个文件：bash循环的输出不仅可以送到标准输出，还可以通过管道送到文件</p>

<p>将循环的输出管道到一个命令</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>后台执行循环</p>

<p>循环可以在后台执行，这样就可以继续往下执行其他程序而不必等待循环处理全部完成</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>函数</p>

<p>函数在当前环境中运行，函数共享调用它的脚本中的变量，还允许给函数传递参数，可以使用local功能在函数内部创建局部变量</p>

<p>在函数中调用exit将退出整个脚本。</p>

<p>函数中的return语句，返回函数执行的最后一条命令的退出状态，或返回指定参数值</p>

<p>使用export -f把函数导出到子shell</p>

<p>使用declare -f可以列出所有的函数名及其定义</p>

<p>如果函数保存在其他一些文件中，可以用source和dot命令把他们载入到当前脚本中</p>

<p>函数可以递归调用，次数没限制</p>

<p>清除函数</p>

<p>从内存中清除某个函数，使用unset命令</p>

<p>unset 函数名</p>

<p>函数的参数和返回值</p>

<p>当前shell环境中的变量对函数是可见的，在函数中对环境所做的任何改动也是会对shell环境生效的。</p>

<p>函数可以使用位置参数向函数传递参数，位置参数是函数私有的，也就是说，函数对参数的操作不会影响在函数外使用的任何位置参数</p>

<p>内置local功能:函数私有的局部变量，在函数退出后随即消失。</p>

<p>内置return命令:用来退出函数并将控制回转到程序调用函数的位置，如果未给return赋值，则返回最后一条命令的退出状态，如果赋值了，则该值保存在变量?中。可以是0-255之间整数。</p>

<p>获取函数的结果可以用 命令替换，如:$(函数名) <code>函数名</code></p>

<p>函数可以定义在文件中，当需要时，调用source或dot命令跟上函数名就能激活文件中的函数，函数会被加载到shell内存空间</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>调试</p>

<p>带-n选项的bash命令，能对脚本进行语法检查，但不去运行任何一条命令，如语法错误，则报错，否则不显示任何内容</p>

<p>最常见的调试脚本的手段是用带-x选项的set命令，或是调用带-x选项和脚本名为参数的bash</p>

<p>此时shell对脚本的每条命令处理过程为：先执行替换，接在显示，再去执行它。shell显示脚本中的行时，会在行首添加加号+</p>

<p>调试选项：</p>

<p>bash -x 脚本名 #回显 在变量替换之后，执行命令之前，显示脚本的每一行</p>

<p>bash -v 脚本名 #详细 在执行之前，按输入的原样打印脚本中的各行</p>

<p>bash -n 脚本名 #不执行 解释但不执行命令</p>

<p>set -x #打开回显 跟踪脚本执行</p>

<p>set +x #关闭回显 关闭跟踪功能</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>调试shell脚本</p>

<p>风格问题</p>

<p>1：加注释</p>

<p>2：定义有意义的变量名</p>

<p>3：确保健壮性</p>

<p>错误类型</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>