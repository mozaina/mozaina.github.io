<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linuxshell脚本编程实战篇一 | 开发者问答集锦</title>
    <meta property="og:title" content="Linuxshell脚本编程实战篇一 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linuxshell脚本编程实战篇一">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AF%87%E4%B8%80/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linuxshell脚本编程实战篇一</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>1. 编写简单的脚本实用工具</p>

<hr />

<p>对 Linux 系统管理员而言，没什么比编写脚本实用工具更有意义。Linux
系统管理员每天都会有各种各样的任务，从监测磁盘空间到备份重要文件再到管理用户账户。shell脚本实用工具可以让这些工作轻松许多。</p>

<p>1.1 归档</p>

<hr />

<p>不管负责的是商业环境还是家用环境的 Linux 系统，丢失数据都是一场灾难。为了防止这种倒霉事，最好是定时进行备份（或者是归档）。</p>

<p>如果正在用 Linux 系统作为一个重要项目的平台，可以创建一个 shell 脚本来自动获取特定目录的快照。在配置文件中指定所涉及的目录，这样一来，在<br />
项目发生变化时，就可以做出对应的修改。这有助于避免把时间耗在恢复主归档文件上。</p>

<p>本节介绍如何创建自动化 shell 脚本来获取指定目录的快照并保留旧数据的归档。</p>

<p>1.1.1 需要的功能<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
Linux 中归档数据的主要工具是 tar 命令。tar 命令可以将整个目录归档到单个文件中。</p>

<p>示例：<br />
[devalone@devalone ~]$ ll project/<br />
总用量 12<br />
-rwxr-xr-x. 1 devalone devalone 707 7月 14 11:58 JavadocTagTest.java<br />
-rwxr-xr-x. 1 devalone devalone 659 7月 14 11:58 JavadocTest.java<br />
-rwxr-xr-x. 1 devalone devalone 433 7月 14 11:58 Test.java</p>

<p>[devalone@devalone ~]$ tar -cf archive.tar /home/devalone/project/<em>.</em><br />
tar: 从成员名中删除开头的“/”</p>

<p>[devalone@devalone ~]$ ll -l archive.tar<br />
-rw-rw-r&ndash;. 1 devalone devalone 10240 7月 14 11:59 archive.tar</p>

<p>tar 命令会显示一条警告消息，表明它删除了路径名开头的斜线，将路径从绝对路径名变成相对路径名。这样就可以将 tar 归档文件解压到文件系统中的<br />
任何地方了。如果不想在脚本中出现这条消息。这种情况可以通过将 STDERR 重定向到 /dev/null文件来实现：</p>

<p>[devalone@devalone ~]$ tar -cf archive.tar /home/devalone/project/<em>.</em>
2&gt;/dev/null<br />
[devalone@devalone ~]$</p>

<p>由于 tar归档文件会消耗大量的磁盘空间，最好能够压缩一下该文件。这只需要加一个 -z 选项就行了。它会将 tar归档文件压缩成 gzip
格式的tar文件，<br />
这种文件也叫作 tarball。别忘了使用恰当的文件扩展名来表示这是个 tarball，用 .tar.gz或 .tgz都行。</p>

<p>示例：<br />
[devalone@devalone ~]$ tar -zcf archive.tar.gz /home/devalone/project/<em>.</em>
2&gt;/dev/null<br />
[devalone@devalone ~]$ ll -l archive.tar*<br />
-rw-rw-r&ndash;. 1 devalone devalone 10240 7月 14 12:04 archive.tar<br />
-rw-rw-r&ndash;. 1 devalone devalone 880 7月 14 12:07 archive.tar.gz</p>

<p>现在已经完成了归档脚本的主要部分。</p>

<p>不需要为待备份的新目录或文件修改或编写新的归档脚本，而是可以借助于配置文件。配置文件应该包含希望进行归档的每个目录或文件。</p>

<p>示例：<br />
[devalone@devalone 24]$ cat files_to_backup<br />
/home/devalone/project<br />
/home/devalone/test<br />
/home/devalone/devel<br />
/home/devalone/does_not_exist #用于测试不存在的文件</p>

<p>可以让脚本读取配置文件，然后将每个目录名加到归档列表中。要实现这一点，只需要使用 read 命令来读取该文件中的每一条记录就行了。不过不用像之前<br />
那样通过管道将 cat 命令的输出传给 while 循环，在这个脚本中我们使用 exec 命令来重定向标准输入（STDIN），用法如下：</p>

<p>exec &lt; $CONFIG_FILE</p>

<p>read FILE_NAME</p>

<p>注意，我们为归档配置文件使用了一个变量，CONFIG_FILE 。配置文件中每一条记录都会被读入。只要 read 命令在配置文件中发现还有记录可读，它就会<br />
在 ? 变量中返回一个表示成功的退出状态码 0。可以将它作为 while 循环的测试条件来读取配置文件中的所有记录：</p>

<p>while [ $? -eq 0 ]<br />
do<br />
[&hellip;]<br />
read FILE_NAME<br />
done</p>

<p>一旦 read 命令到了配置文件的末尾，它就会返回一个非零状态码。这时脚本会退出 while 循环。</p>

<p>在 while 循环中，需要做两件事。首先，必须将目录名加到归档列表中。更重要的是要检查那个目录是否存在。很可能从文件系统中删除了一个目录却忘了<br />
更新归档配置文件。可以用一个简单的 if 语句来检查目录存在与否。如果目录存在，它会被加入要归档目录列表 FILE_LIST 中，否则就显示一条警告消息。<br />
if 语句如下：</p>

<p>if [ -f $FILE_NAME -o -d $FILE_NAME ]<br />
then</p>

<h1 id="if-file-exists-add-its-name-to-the-list">If file exists, add its name to the list.</h1>

<p>FILE_LIST=&ldquo;$FILE_LIST $FILE_NAME&rdquo;<br />
else</p>

<h1 id="if-file-doesn-t-exist-issue-warning">If file doesn&rsquo;t exist, issue warning</h1>

<p>echo<br />
echo &ldquo;$FILE_NAME, does not exist.&rdquo;<br />
echo &ldquo;Obviously, I will not include it in this archive.&rdquo;<br />
echo &ldquo;It is listed on line $FILE_NO of the config file.&rdquo;<br />
echo &ldquo;Continuing to build archive list&hellip;&rdquo;<br />
echo<br />
fi</p>

<p>FILE_NO=$[$FILE_NO + 1] # Increase Line/File number by one.</p>

<p>由于归档配置文件中的记录可以是文件名，也可以是目录名，所以 if 语句会用 -f 选项和 -d 选项测试两者是否存在。or 选项 -o 考虑到了，在测试文件<br />
或目录的存在性时，只要其中一个测试为真，那么整个if语句就成立。</p>

<p>为了在跟踪不存在的目录和文件上提供一点额外帮助，我们添加了变量 FILE_NO。这样，这个脚本就可以告诉在归档配置文件中哪行中含有不正确或缺失的<br />
文件或目录。</p>

<p>1.1.2 创建逐日归档文件的存放位置<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
如果只是备份少量文件，那么将这些归档文件放在用户的个人目录中就行了。但如果要对多个目录进行备份，最好还是创建一个集中归档仓库目录。</p>

<p>示例：<br />
[devalone@devalone 24]$ sudo mkdir /archive<br />
[devalone@devalone 24]$ ls -ld /archive<br />
drwxr-xr-x. 2 root root 4096 7月 14 12:55 /archive</p>

<p>创建好集中归档目录后，需要授予某些用户访问权限。如果忘记了这一点，在该目录下创建文件时就会出错。</p>

<p>示例：<br />
[devalone@devalone 24]$ mv files_to_backup /archive/<br />
mv: 无法创建普通文件&rsquo;/archive/files_to_backup&rsquo;: Permission denied</p>

<p>可以通过 sudo 命令或者创建一个用户组的方式，为需要在集中归档目录中创建文件的用户授权。可以创建一个特殊的用户组 Archivers:</p>

<p>[devalone@devalone 24]$ sudo groupadd Archivers<br />
[devalone@devalone 24]$ sudo chgrp Archivers /archive<br />
[<br />
devalone@devalone 24]$ ls -ld /archive/<br />
drwxr-xr-x. 2 root Archivers 4096 7月 14 12:55 /archive/</p>

<p>[devalone@devalone 24]$ sudo usermod -aG Archivers devalone<br />
[devalone@devalone 24]$ sudo chmod 775 /archive<br />
[devalone@devalone 24]$ ls -ld /archive<br />
drwxrwxr-x. 2 root Archivers 4096 7月 14 12:55 /archive</p>

<p>将用户添加到 Archivers组后，用户必须先退出然后再登录，才能使组成员关系生效。现在只要是该组的成员，无需超级用户权限就可以在目录中创建文件：</p>

<p>[devalone@devalone 24]$ mv files_to_backup /archive/<br />
[devalone@devalone 24]$ ls -l /archive/<br />
总用量 4<br />
-rw-rw-r&ndash;. 1 devalone devalone 66 7月 14 12:13 files_to_backup</p>

<p>记住，Archivers 组的所有用户都可以在归档目录中添加和删除文件。为了避免组用户删除他人的归档文件，最好还是把目录的粘滞位加上。</p>

<p>1.1.3 创建按日归档的脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
daily_archive.sh 脚本会自动在指定位置创建一个归档，使用当前日期来唯一标识该文件。下面是脚本中的对应部分的代码：</p>

<p>DATE=$(date +%y%m%d)</p>

<h1 id="set-archive-file-name">Set Archive File Name</h1>

<p>FILE=archive$DATE.tar.gz</p>

<h1 id="set-configuration-and-destination-file">Set Configuration and Destination File</h1>

<p>CONFIG_FILE=/archive/files_to_backup<br />
DESTINATION=/archive/$FILE<br />
#</p>

<p>DESTINATION 变量会将归档文件的全路径名加上去。CONFIG_FILE
变量指向含有待归档目录信息的归档配置文件。如果需要，二者都可以很方便地改成备用<br />
目录和文件。</p>

<p>将所有的内容结合在一起，daily_archive.sh 脚本内容如下:</p>

<p>[devalone@devalone 24]$ cat daily_archive.sh<br />
#!/bin/bash</p>

<h1 id="dialy-archive-archive-designated-files-directories">dialy_archive - Archive designated files &amp; directories</h1>

<p>#################################################################################</p>

<h1 id="gather-current-date">Gather current date</h1>

<p>DATE=$(date +%y%m%d)</p>

<h1 id="set-archive-file-name-1">set archive file name</h1>

<p>FILE=archive$DATE.tar.gz</p>

<h1 id="set-configuration-and-destination-file-1">set configuration and destination file</h1>

<p>CONFIG_FILE=/archive/files_to_backup<br />
DESTINATION=/archive/$FILE</p>

<p>###################main script######################</p>

<h1 id="check-backup-config-file-exists">check backup config file exists</h1>

<p>if [ -f $CONFIG_FILE ] # make sure the config file still exists<br />
then # if it exist, do nothing but continue on.<br />
echo<br />
else # if it doesn&rsquo;t exist, issue error &amp; exit script.<br />
echo<br />
echo &ldquo;$CONFIG_FILE does not exist.&rdquo;<br />
echo &ldquo;backup not completed due to missing configuration file&rdquo;<br />
echo<br />
exit<br />
fi</p>

<h1 id="build-the-names-of-all-the-files-to-backup">build the names of all the files to backup</h1>

<p>FILE_NO=1 # start on line 1 of config file<br />
exec &lt; $CONFIG_FILE # redirect stdin to name of config file</p>

<p>read FILE_NAME # read 1st record<br />
while [ $? -eq 0 ] # create list of files to backup<br />
do</p>

<h1 id="make-sure-the-file-or-directory-exists">make sure the file or directory exists</h1>

<p>if [ -f $FILE_NAME -o -d $FILE_NAME ]<br />
then</p>

<h1 id="if-file-exists-add-its-name-to-the-list-1">if file exists, add its name to the list.</h1>

<p>FILE_LIST=&ldquo;$FILE_LIST $FILE_NAME&rdquo;<br />
else</p>

<h1 id="if-file-does-t-exist-issue-warning">if file does&rsquo;t exist, issue warning</h1>

<p>echo<br />
echo &ldquo;$FILE_NAME, does not exist.&rdquo;<br />
echo &ldquo;obviously, I will not include it in this archive.&rdquo;<br />
echo &ldquo;it is listed on line $FILE_NO of the config file.&rdquo;<br />
echo &ldquo;continuing to build archivelist&hellip;&rdquo;<br />
echo<br />
fi</p>

<p>FILE_NO=$[ $FILE_NO + 1 ] # increase line/file number by one<br />
read FILE_NAME # read next record<br />
done</p>

<p>##################################################################################</p>

<h1 id="backup-the-files-and-compress-archive">backup the files and compress archive</h1>

<p>echo &ldquo;starting archive&hellip;&rdquo;<br />
echo</p>

<p>tar -zcf $DESTINATION $FILE_LIST 2&gt; /dev/null</p>

<p>echo &ldquo;archive completed&rdquo;<br />
echo &ldquo;resulting archive file is: $DESTINATION&rdquo;<br />
echo</p>

<p>exit</p>

<p>1.1.4 运行按日归档的脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在测试脚本之前，别忘了修改脚本文件的权限。必须赋予文件属主可执行权限（x）才能够运行脚本。</p>

<p>示例：<br />
[devalone@devalone 24]$ ll daily_archive.sh<br />
-rwxrwxr&ndash;. 1 devalone devalone 1842 7月 14 14:36 daily_archive.sh</p>

<p>测试运行：<br />
[devalone@devalone 24]$ ./daily_archive.sh</p>

<p>/home/devalone/does_not_exist, does not exist.<br />
obviously, I will not include it in this archive.<br />
it is listed on line 4 of the config file.<br />
continuing to build archivelist&hellip;</p>

<p>starting archive&hellip;</p>

<p>archive completed<br />
resulting archive file is: /archive/archive180714.tar.gz</p>

<p>[devalone@devalone 24]$ ll /archive/<br />
总用量 487644<br />
-rw-rw-r&ndash;. 1 devalone devalone 499336851 7月 14 14:44 archive180714.tar.gz<br />
-rw-rw-r&ndash;. 1 devalone devalone 98 7月 14 14:43 files_to_backup</p>

<p>看到这个脚本发现了一个不存在的目录：/home/devalone/does_not_exist。脚本输出说明了这个错误的行在配置文件中的行号
4，然后继续创建列表和归档<br />
数据。现在数据已经稳妥地归档到了 tarball 文件中。</p>

<p>1.1.5 创建按小时归档的脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
如果是在文件更改很频繁的高容量生产环境中，那么按日归档可能不够用。如果要将归档频率提高到每小时一次，还要考虑另一个因素。</p>

<p>在按小时备份文件时，如果依然使用 date 命令为每个 tarball 文件加入时间戳，文件名很快就会变得不还看。筛选一个含有如下文件名的目录会很乏味：</p>

<p>archive180714110233.tar.gz</p>

<p>不必将所有的归档文件都放到同一目录中，可以为归档文件创建一个目录层级。归档目录包含了与一年中的各个月份对应的目录，将月的序号作为目录名。<br />
而每月的目录中又包含与当月各天对应的目录（用天的序号作为目录名）。这样只用给每个归档文件加上时间戳，然后将它们放到与月日对应的目录中。</p>

<p>首先，创建新目录/archive/hourly，并设置适当的权限。Archivers组有权在目录中创建归档文件。因此，这个新创建的目录也得修改它的属组以及组权限：</p>

<p>示例：<br />
[devalone@devalone 24]$ sudo mkdir /archive/hourly<br />
[devalone@devalone 24]$ sudo chgrp Archivers /archive/hourly/<br />
[devalone@devalone 24]$ ll -d /archive/hourly/<br />
drwxr-xr-x. 2 root Archivers 4096 7月 14 14:57 /archive/hourly/</p>

<p>[devalone@devalone 24]$ sudo chmod 775 /archive/hourly<br />
[devalone@devalone 24]$ ls -ld /archive/hourly<br />
drwxrwxr-x. 2 root Archivers 4096 7月 14 14:57 /archive/hourly</p>

<p>新目录设置好之后，将按小时归档的配置文件 files_to_backup 移动到该目录中：</p>

<p>[devalone@devalone 24]$ cat /archive/hourly/files_to_backup<br />
/home/devalone/shell_test<br />
/home/devalone/repo<br />
/home/file_does_not_exist #测试不存在的文件</p>

<p>还有个新问题要解决。这个脚本必须自动创建对应每月和每天的目录，如果这些目录已经存在的话，脚本就会报错，这不是我们想要的结果。</p>

<p>mkdir 命令的命令行选项有一个 -p 命令行选项。这个选项允许在单个命令中创建目录和子目录，就算目录已经存在，也不会产生错误消息。<br />
这正是我们的脚本中所需要的。</p>

<p>创建 hourly_archive.sh 脚本如下：</p>

<p>[devalone@devalone 24]$ cat hourly_archive.sh<br />
#!/bin/bash</p>

<h1 id="hourly-archive-every-hour-create-an-archive">hourly_archive - Every hour create an archive</h1>

<p>#################################################################################</p>

<h1 id="set-configuration-and-destination-file-2">set configuration and destination file</h1>

<p>CONFIG_FILE=/archive/hourly/files_to_backup</p>

<h1 id="set-base-archive-destination-location">set base archive destination location</h1>

<p>BASEDEST=/archive/hourly</p>

<h1 id="gather-current-year-day-month-time">gather current year, day, month &amp; time</h1>

<p>YEAR=$(date +%Y)<br />
DAY=$(date +%d)<br />
MONTH=$(date +%m)<br />
TIME=$(date +%H%M)</p>

<h1 id="create-archive-destination-directory">create archive destination directory</h1>

<p>mkdir -p $BASEDEST/$YEAR/$MONTH/$DAY</p>

<h1 id="build-archive-destination-file-name">build archive destination file name</h1>

<p>DESTINATION=$BASEDEST/$YEAR/$MONTH/$DAY/archive$TIME.tar.gz</p>

<p>################### main script ######################</p>

<h1 id="check-backup-config-file-exists-1">check backup config file exists</h1>

<p>if [ -f $CONFIG_FILE ] # make sure the config file still exists<br />
then # if it exist, do nothing but continue on.<br />
echo<br />
else # if it doesn&rsquo;t exist, issue error &amp; exit script.<br />
echo<br />
echo &ldquo;$CONFIG_FILE does not exist.&rdquo;<br />
echo &ldquo;backup not completed due to missing configuration file&rdquo;<br />
echo<br />
exit<br />
fi</p>

<h1 id="build-the-names-of-all-the-files-to-backup-1">build the names of all the files to backup</h1>

<p>FILE_NO=1 # start on line 1 of config file<br />
exec &lt; $CONFIG_FILE # redirect stdin to name of config file</p>

<p>read FILE_NAME # read 1st record<br />
while [ $? -eq 0 ] # create list of files to backup<br />
do</p>

<h1 id="make-sure-the-file-or-directory-exists-1">make sure the file or directory exists</h1>

<p>if [ -f $FILE_NAME -o -d $FILE_NAME ]<br />
then</p>

<h1 id="if-file-exists-add-its-name-to-the-list-2">if file exists, add its name to the list.</h1>

<p>FILE_LIST=&ldquo;$FILE_LIST $FILE_NAME&rdquo;<br />
else</p>

<h1 id="if-file-does-t-exist-issue-warning-1">if file does&rsquo;t exist, issue warning</h1>

<p>echo<br />
echo &ldquo;$FILE_NAME, does not exist.&rdquo;<br />
echo &ldquo;obviously, I will not include it in this archive.&rdquo;<br />
echo &ldquo;it is listed on line $FILE_NO of the config file.&rdquo;<br />
echo &ldquo;continuing to build archivelist&hellip;&rdquo;<br />
echo<br />
fi</p>

<p>FILE_NO=$[ $FILE_NO + 1 ] # increase line/file number by one<br />
read FILE_NAME # read next record<br />
done</p>

<p>##################################################################################</p>

<h1 id="backup-the-files-and-compress-archive-1">backup the files and compress archive</h1>

<p>echo &ldquo;starting archive&hellip;&rdquo;<br />
echo</p>

<p>tar -zcf $DESTINATION $FILE_LIST 2&gt; /dev/null</p>

<p>echo &ldquo;archive completed&rdquo;<br />
echo &ldquo;resulting archive file is: $DESTINATION&rdquo;<br />
echo</p>

<p>exit</p>

<p>1.1.6 运行按小时归档的脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
运行前修改脚本可执行权限：</p>

<p>[devalone@devalone 24]$ chmod a+x hourly_archive.sh</p>

<p>看下当前时间：<br />
[devalone@devalone 24]$ date +%k%M<br />
1520<br />
运行脚本<br />
[devalone@devalone 24]$ ./hourly_archive.sh</p>

<p>/home/file_does_not_exist, does not exist.<br />
obviously, I will not include it in this archive.<br />
it is listed on line 3 of the config file.<br />
continuing to build archivelist&hellip;</p>

<p>starting archive&hellip;</p>

<p>archive completed<br />
resulting archive file is: /archive/hourly/2018/07/14/archive1520.tar.gz</p>

<p>看到这个脚本发现了一个不存在的目录：/home/file_does_not_exist。脚本输出说明了这个错误的行在配置文件中的行号3，然后继续创建列表和归档数据。<br />
现在数据已经稳妥地归档到了 tarball 文件中。</p>

<p>验证：<br />
[devalone@devalone 24]$ ll /archive/hourly/2018/07/14/<br />
总用量 2868036<br />
-rw-rw-r&ndash;. 1 devalone devalone 2936863020 7月 14 15:24 archive1520.tar.gz</p>

<p>删除配置文件中不存在的目录配置。</p>

<p>1.2 管理用户账户<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
管理用户账户绝不仅仅是添加、修改和删除账户，还需要考虑安全问题、保留工作的需求以及对账户的精确管理。这可能是一份耗时的工作。在此将介绍另<br />
一个可以证明脚本工具能够促进效率的实例。</p>

<p>1.2.1 需要的功能<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
删除账户在管理账户工作中比较复杂。在删除账户时，至少需要4个步骤：</p>

<p>(1) 获得正确的待删除用户账户名；<br />
(2) 杀死正在系统上运行的属于该账户的进程；<br />
(3) 确认系统中属于该账户的所有文件；<br />
(4) 删除该用户账户。</p>

<p>1.2.1.1 获取正确的账户名<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
账户删除过程中的第一步最重要：获取待删除的用户账户的正确名称。</p>

<p>由于这是个交互式脚本，所以可以用 read 命令获取账户名称。如果脚本用户一直没有给出答复，可以在 read 命令中用 -t 选项，在超时退出之前给用户<br />
60 秒的时间回答问题：</p>

<p>echo &ldquo;Please enter the username of the user &rdquo;<br />
echo -e &ldquo;account you wish to delete from system: \c&rdquo;<br />
read -t 60 ANSWER</p>

<p>人毕竟难免因为其他事情而耽搁时间，所以最好给用户三次机会来回答问题。要实现这点，可以用一个 while 循环加 -z 选项来测试 ANSWER
变量是否为空。<br />
在脚本第一次进入 while 循环时，ANSWER 变量的内容为空，用来给该变量赋值的提问位于循环的底部：</p>

<p>while [ -z &ldquo;$ANSWER&rdquo; ]<br />
do<br />
[&hellip;]<br />
echo &ldquo;Please enter the username of the user &rdquo;<br />
echo -e &ldquo;account you wish to delete from system: \c&rdquo;<br />
read -t 60 ANSWER<br />
done</p>

<p>当第一次提问出现超时，当只剩下一次回答问题的机会时，或当出现其他情况时，需要跟脚本用户进行沟通。case 语句是最适合这里的结构化命令。通过给<br />
ASK_COUNT 变量增值，可以设定不同的消息来回应脚本用户。这部分的代码如下：</p>

<p>case $ASK_COUNT in<br />
2)<br />
echo<br />
echo &ldquo;Please answer the question.&rdquo;<br />
echo<br />
;;<br />
3)<br />
echo<br />
echo &ldquo;One last try&hellip;please answer the question.&rdquo;<br />
echo<br />
;;<br />
4)<br />
echo<br />
echo &ldquo;Since you refuse to answer the question&hellip;&rdquo;<br />
echo &ldquo;exiting program.&rdquo;<br />
echo</p>

<p>exit<br />
;;<br />
esac<br />
#</p>

<p>现在，这个脚本已经拥有了它所需要的全部结构，可以问用户要删除哪个账户了。在这个脚本中，还需要问用户另外一些问题，可之前只提那么一个问题就<br />
已经是一大堆代码了，因此，将这段代码放到一个函数中，以便在delete_user.sh脚本中重复使用。</p>

<p>1.2.1.2 创建函数获取正确的账户名<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
要做的第一件事是声明函数名 get_answer。下一步，用 unset 命令清除脚本用户之前给出的答案。完成这两件事的代码如下:</p>

<p>function get_answer {</p>

<p>unset ANSWER</p>

<p>在原来代码中要修改的另一处地方是对用户脚本的提问。这个脚本不会每次都问同一个问题，所以让创建两个新的变量 LINE1 和 LINE2来处理问题:</p>

<p>echo $LINE1<br />
echo -e $LINE2&rdquo; \c&rdquo;</p>

<p>然而，并不是每个问题都有两行要显示，有的只要一行。可以用 if 结构解决这个问题。这个函数会测试 LINE2 是否为空，如果为空，则只用 LINE1。</p>

<p>if [ -n &ldquo;$LINE2&rdquo; ]<br />
then<br />
echo $LINE1<br />
echo -e $LINE2&rdquo; \c&rdquo;<br />
else<br />
echo -e $LINE1&rdquo; \c&rdquo;<br />
fi</p>

<p>最终，函数需要通过清空 LINE1和 LINE2变量来清除一下自己。因此，现在这个函数看起来如下。</p>

<p>function get_answer {</p>

<p>unset ANSWER<br />
ASK_COUNT=0</p>

<p>while [ -z &ldquo;$ANSWER&rdquo; ]<br />
do<br />
ASK_COUNT=$[ $ASK_COUNT + 1 ]</p>

<p>case $ASK_COUNT in<br />
2)<br />
echo<br />
[&hellip;]<br />
esac</p>

<p>echo</p>

<p>if [ -n &ldquo;$LINE2&rdquo; ]<br />
then #Print 2 lines<br />
echo $LINE1<br />
echo -e $LINE2&rdquo; \c&rdquo;<br />
else #Print 1 line<br />
echo -e $LINE1&rdquo; \c&rdquo;<br />
fi</p>

<p>read -t 60 ANSWER<br />
done</p>

<p>unset LINE1<br />
unset LINE2</p>

<p>} #End of get_answer function</p>

<p>要问脚本用户删除哪个账户，需要设置一些变量，然后调用 get_answer 函数。使用新函数让脚本代码清爽了许多：</p>

<p>LINE1=&ldquo;Please enter the username of the user &rdquo;<br />
LINE2=&ldquo;account you wish to delete from system:&rdquo;<br />
get_answer<br />
USER_ACCOUNT=$ANSWER</p>

<p>1.2.1.3 验证输入的用户名<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
鉴于可能存在输入错误，应该验证一下输入的用户账户。这很容易，因为我们已经有了提问的代码。</p>

<p>LINE1=&ldquo;Is $USER_ACCOUNT the user account &ldquo;<br />
LINE2=&ldquo;you wish to delete from the system? [y/n]&rdquo;<br />
get_answer</p>

<p>在提出问题之后，脚本必须处理答案。变量 ANSWER 再次将脚本用户的回答带回问题中。如果用户回答了 yes，就得到了要删除的正确用户账户，脚本也可以<br />
继续执行。可以用 case 语句来处理答案。case 语句部分必须精心编码，这样它才会检查 yes 的多种输入方式。</p>

<p>case $ANSWER in<br />
y|Y|YES|yes|Yes|yEs|yeS|YEs|yES )</p>

<p>;;<br />
*)<br />
echo<br />
echo &ldquo;Because the account, $USER_ACCOUNT, is not &ldquo;<br />
echo &ldquo;the one you wish to delete, we are leaving the script&hellip;&rdquo;<br />
echo<br />
exit<br />
;;<br />
esac</p>

<p>这个脚本有时需要处理很多次用户的 yes/no 回答。因此，创建一个函数来处理这个任务是有意义的。只要对前面的代码作很少的改动就可以了。必须声明<br />
函数名，还要给 case 语句中加两个变量， EXIT_LINE1 和 EXIT_LINE2 。这些修改以及最后的一些变量清理工作就是
process_answer 函数的全部：</p>

<p>function process_answer {</p>

<p>case $ANSWER in</p>

<p>y|Y|YES|yes|Yes|yEs|yeS|YEs|yES )<br />
;;<br />
*)<br />
echo<br />
echo $EXIT_LINE1<br />
echo $EXIT_LINE2<br />
echo<br />
exit<br />
;;<br />
esac</p>

<p>unset EXIT_LINE1<br />
unset EXIT_LINE2</p>

<p>} #End of process_answer function</p>

<p>现在只用调用函数就可以处理答案了：</p>

<p>EXIT_LINE1=&ldquo;Because the account, $USER_ACCOUNT, is not &ldquo;<br />
EXIT_LINE2=&ldquo;the one you wish to delete, we are leaving the script&hellip;&rdquo;<br />
process_answer</p>

<p>1.2.1.4 确定账户是否存在<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
用户已经给了我们要删除的账户名并且验证过了。现在最好核对一下这个用户账户在系统上是否真实存在。还有，最好将完整的账户记录显示给脚本用户，<br />
核对这是不是真的要删除的那个账户。要完成这些工作，需使用变量 USER_ACCOUNT_RECORD，将它设成 grep 在
/etc/passwd文件中查找该用户账户的输出。<br />
-w 选项允许对这个特定用户账户进行精确匹配。</p>

<p>USER_ACCOUNT_RECORD=$(cat /etc/passwd | grep -w $USER_ACCOUNT)</p>

<p>如果在 /etc/passwd 中没找到用户账户记录，那意味着这个账户已被删除或者从未存在过。不管是哪种情况，都必须通知脚本用户，然后退出脚本。grep<br />
命令的退出状态码可以确定结果。如果没找到这条账户记录，? 变量会被设成 1。</p>

<p>if [ $? -eq 1 ]<br />
then<br />
echo<br />
echo &ldquo;Account, $USER_ACCOUNT, not found. &ldquo;<br />
echo &ldquo;Leaving the script&hellip;&rdquo;<br />
echo<br />
exit<br />
fi</p>

<p>如果找到了这条记录，仍然需要验证这个脚本用户是不是正确的账户。我们先前建立的函数在这里就能发挥作用了，要做的只是设置正确的变量并调用函数。</p>

<p>echo &ldquo;I found this record:&rdquo;<br />
echo $USER_ACCOUNT_RECORD<br />
echo</p>

<p>LINE1=&ldquo;Is this the correct User Account? [y/n]&rdquo;<br />
get_answer</p>

<p>EXIT_LINE1=&ldquo;Because the account, $USER_ACCOUNT, is not&rdquo;<br />
EXIT_LINE2=&ldquo;the one you wish to delete, we are leaving the script&hellip;&rdquo;<br />
process_answer</p>

<p>1.2.1.5 删除属于账户的进程<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
到目前为止，你已经得到并验证了要删除的用户账户的正确名称。为了从系统上删除该用户账户，这个账户不能拥有任何当前处于运行中的进程。因此，下<br />
一步就是查找并终止这些进程。</p>

<p>查找用户进程较为简单。这里脚本可以用 ps 命令和 -u 选项来定位属于该账户的所有处于运行中的进程。可以将输出重定向到/dev/null，这样用户就看不<br />
到任何输出信息了。这样做很方便，因为如果没有找到相关进程，ps 命令只会显示出一个标题，就会把脚本用户搞糊涂的。</p>

<p>ps -u $USER_ACCOUNT &gt;/dev/null #Are user processes running?</p>

<p>可以用 ps 命令的退出状态码和 case 结构来决定下一步做什么：</p>

<p>case $? in<br />
1) # No processes running for this User Account</p>

<p>echo &ldquo;There are no processes for this account currently running.&rdquo;<br />
echo<br />
;;<br />
0) # Processes running for this User Account.</p>

<h1 id="ask-script-user-if-wants-us-to-kill-the-processes">Ask Script User if wants us to kill the processes.</h1>

<p>echo &ldquo;$USER_ACCOUNT has the following processes running: &ldquo;<br />
echo<br />
ps -u $USER_ACCOUNT</p>

<p>LINE1=&ldquo;Would you like me to kill the process(es)? [y/n]&rdquo;<br />
get_answer</p>

<p>[&hellip;]<br />
esac</p>

<p>如果 ps 命令的退出状态码返回了 1，那么表明系统上没有属于该用户账户的进程在运行。但如果退出状态码返回了 0，那么系统上有属于该账户的进程在<br />
运行。在这种情况下，脚本需要询问脚本用户是否要杀死这些进程。可以用 get_answer 函数来完成这个任务。</p>

<p>可能会认为脚本下一步就是调用 process_answer 函数。很遗憾，接下来的任务对 process_answer 来说太复杂了。需要嵌入另一个
case 语句来处理脚本<br />
用户的答案。case 语句的第一部分看起来和 process_answer 函数很像。</p>

<p>case $ANSWER in<br />
y|Y|YES|yes|Yes|yEs|yeS|YEs|yES ) # If user answers &ldquo;yes&rdquo;,<br />
#kill User Account processes.<br />
[&hellip;]<br />
;;<br />
*) # If user answers anything but &ldquo;yes&rdquo;, do not kill.</p>

<p>echo<br />
echo &ldquo;Will not kill the process(es)&rdquo;<br />
echo<br />
;;<br />
esac</p>

<p>可以看出，case 语句本身并没什么特别的。值得留意的是 case 语句的 yes部分。在这里需要杀死该用户账户的进程。要实现这个目标，得使用三条命令。<br />
首先需要再用一次 ps命令，收集当前处于运行状态、属于该用户账户的进程 ID（PID）。命令的输出被保存在变量 COMMAND_1中。</p>

<p>COMMAND_1=&ldquo;ps -u $USER_ACCOUNT &ndash;no-heading&rdquo;</p>

<p>第二条命令用来提取PID。下面这条简单的 gawk 命令可以从 ps 命令输出中提取第一个字段，而这个字段恰好就是 PID。</p>

<p>gawk &lsquo;{print $1}&rsquo;</p>

<p>第三条命令是 xargs，该命令可以构建并执行来自标准输入 STDIN 的命令。它非常适合用在管道的末尾处。xargs 命令负责杀死 PID所对应的进程。</p>

<p>COMMAND_3=&ldquo;xargs -d \\n /usr/bin/sudo /bin/kill -9&rdquo;</p>

<p>xargs 命令被保存在变量 COMMAND_3中。选项 -d指明使用什么样的分隔符。换句话说，既然
xargs命令接收多个项作为输入，那么各个项之间要怎么区分呢？<br />
这里，\n（换行符）被作为各项的分隔符。当每个 PID发送给 xargs时，它将PID作为单个项来处理。又因为 xargs命令被赋给了一个变量，所以
\n中的反斜<br />
杠（\）必须再加上另一个反斜杠（\）进行转义。</p>

<p>注意，在处理PID时，xargs 命令需要使用命令的完整路径名。sudo 命令和 kill
命令用于杀死用户账户的运行进程。另外还注意到kill命令使用了信号-9。</p>

<p>这三条命令通过管道串联在了一起。ps 命令生成了处于运行状态的用户进程列表，其中包括每个进程的 PID。gawk 命令将 ps
命令的标准输出（STDOUT）<br />
作为自己的 STDIN，然后从中只提取出 PID。xargs 命令将 gawk 命令生成的每个 PID作为 STDIN，创建并执行 kill
命令，杀死用户所有的运行进程。<br />
这个命令管道如下：</p>

<p>$COMMAND_1 | gawk &lsquo;{print $1}&rsquo; | $COMMAND_3</p>

<p>因此，用于杀死用户账户所有的运行进程的完整的 case 语句如下所示：</p>

<p>case $ANSWER in<br />
y|Y|YES|yes|Yes|yEs|yeS|YEs|yES ) # If user answers &ldquo;yes&rdquo;,<br />
#kill User Account processes.</p>

<p>echo<br />
echo &ldquo;Killing off process(es)&hellip;&rdquo;</p>

<h1 id="list-user-processes-running-code-in-variable-command-1">List user processes running code in variable, COMMAND_1</h1>

<p>COMMAND_1=&ldquo;ps -u $USER_ACCOUNT &ndash;no-heading&rdquo;</p>

<h1 id="create-command-to-kill-proccess-in-variable-command-3">Create command to kill proccess in variable, COMMAND_3</h1>

<p>COMMAND_3=&ldquo;xargs -d \\n /usr/bin/sudo /bin/kill -9&rdquo;</p>

<h1 id="kill-processes-via-piping-commands-together">Kill processes via piping commands together</h1>

<p>$COMMAND_1 | gawk &lsquo;{print $1}&rsquo; | $COMMAND_3</p>

<p>echo<br />
echo &ldquo;Process(es) killed.&rdquo;<br />
;;</p>

<p>1.2.1.6 查找属于账户的文件<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在从系统上删除用户账户时，最好将属于该用户的所有文件归档。另外，还有一点比较重要的是，得删除这些文件或将文件的所属关系分配给其他账户。如果<br />
要删除的账户的 UID 是 1003，而没有删除或修改它们的所属关系，那么下一个创建的 UID为
1003的账户会拥有这些文件。这种情况下显然会出现安全隐患。</p>

<p>脚本 delete_user.sh 不会大包大揽，但它会创建一个在daily_archive.sh
脚本中作为备份配置文件的报告。可以用这个报告帮助删除文件或重新分配文件<br />
的所属关系。</p>

<p>要找到用户文件，可以用 find 命令。find 命令用 -u 选项查找整个文件系统，它能够准确查找到属于该用户的所有文件。该命令如下：</p>

<p>find / -user $USER_ACCOUNT &gt; $REPORT_FILE</p>

<p>1.2.1.7 删除账户<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
对删除系统中的用户账户慎之又慎总是好事。因此，应该再问一次脚本用户是否真的想删除该账户：</p>

<p>LINE1=&ldquo;Remove $User_Account&rsquo;s account from system? [y/n]&rdquo;<br />
get_answer</p>

<p>EXIT_LINE1=&ldquo;Since you do not wish to remove the user account,&rdquo;<br />
EXIT_LINE2=&ldquo;$USER_ACCOUNT at this time, exiting the script&hellip;&rdquo;<br />
process_answer</p>

<p>最后就是脚本的主要目的了：从系统中真正地删除该用户账户。这里用到了 userdel 命令:</p>

<p>userdel $USER_ACCOUNT</p>

<p>1.2.2 创建脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在脚本的顶部声明了两个函数，get_answer 和
process_answer。脚本通过四个步骤删除用户：获得并确认用户账户名，查找和终止用户的进程，创建一份<br />
属于该用户账户的所有文件的报告，删除用户账户。</p>

<p>完整的脚本如下：</p>

<p>[devalone@devalone 24]$ cat delete_user.sh<br />
#!/bin/bash</p>

<h1 id="delete-user-automates-the-4-step-to-remove-an-account">delete_user - automates the 4 step to remove an account</h1>

<p>###############################################################</p>

<h1 id="define-functions">define functions</h1>

<p>###############################################################<br />
function get_answer {</p>

<p>unset ANSWER<br />
ASK_COUNT=0</p>

<p>while [ -z &ldquo;$ANSWER&rdquo; ] # while no answer is given, keep asking.<br />
do<br />
ASK_COUNT=$[ $ASK_COUNT + 1 ]<br />
case $ASK_COUNT in # if user gives no answer in time allotted<br />
2)<br />
echo<br />
echo &ldquo;Please answer the question.&rdquo;<br />
echo<br />
;;<br />
3)<br />
echo<br />
echo &ldquo;One last try&hellip;please answer the question.&rdquo;<br />
echo<br />
;;<br />
4)<br />
echo<br />
echo &ldquo;Since you refuse to answer the question&hellip;&rdquo;<br />
echo &ldquo;exiting program.&rdquo;<br />
echo<br />
exit<br />
;;<br />
esac</p>

<p>echo</p>

<p>if [ -n &ldquo;$LINE2&rdquo; ]<br />
then<br />
echo $LINE1<br />
echo -e $LINE2&rdquo; \c&rdquo;<br />
else<br />
echo -e $LINE1&rdquo; \c&rdquo;<br />
fi</p>

<h1 id="allow-60-seconds-to-answer-before-time-out">allow 60 seconds to answer before time-out</h1>

<p>read -t 60 ANSWER<br />
done</p>

<h1 id="do-a-little-variable-clean-up">do a little variable clean-up</h1>

<p>unset LINE1<br />
unset LINE2<br />
} # end of get_answer function</p>

<p>#####################################################################################################</p>

<p>function process_answer {<br />
case $ANSWER in<br />
y|Y|YES|yes|Yes|yEs|yeS|YEs|yES )<br />
;;<br />
*)</p>

<h1 id="if-user-answers-anything-but-yes-exit-script">if user answers anything but &ldquo;yes&rdquo;, exit script</h1>

<p>echo<br />
echo $EXIT_LINE1<br />
echo $EXIT_LINE2<br />
echo<br />
exit<br />
;;<br />
esac</p>

<h1 id="do-a-little-variable-clean-up-1">do a little variable clean-up</h1>

<p>unset EXIT_LINE1<br />
unset EXIT_LINE2<br />
} # end of process_answer function</p>

<p>############################ main script
#############################################################</p>

<h1 id="get-name-of-user-account-to-check">get name of user account to check</h1>

<p>#</p>

<p>echo &ldquo;step #1 - determine user account name to delete&rdquo;<br />
echo<br />
LINE1=&ldquo;Please enter the username of the user &rdquo;<br />
LINE2=&ldquo;account you wish to delete from system:&rdquo;<br />
get_answer<br />
USER_ACCOUNT=$ANSWER</p>

<h1 id="double-check-with-script-user-that-this-is-the-correct-user-account">Double check with script user that this is the correct user account</h1>

<p>LINE1=&ldquo;Is $USER_ACCOUNT the user account &ldquo;<br />
LINE2=&ldquo;you wish to delete from the system? [y|n]&rdquo;<br />
get_answer</p>

<h1 id="call-process-answer">call process_answer</h1>

<h1 id="if-user-answers-anything-but-yes-exit-the-script">if user answers anything but &ldquo;yes&rdquo;, exit the script</h1>

<p>EXIT_LINE1=&ldquo;Because the account, $USER_ACCOUNT, is not &ldquo;<br />
EXIT_LINE2=&ldquo;the one you wish to delete, we are leaving the script&hellip;&rdquo;<br />
process_answer</p>

<p>########################################################################################################</p>

<h1 id="check-that-user-account-is-really-an-account-on-the-system">check that USER_ACCOUNT is really an account on the system</h1>

<p>USER_ACCOUNT_RECORD=$(cat /etc/passwd | grep -w $USER_ACCOUNT)</p>

<p>if [ $? -eq 1 ] # if the account is not found, exit script<br />
then<br />
echo<br />
echo &ldquo;Account, $USER_ACCOUNT, not found. &ldquo;<br />
echo &ldquo;Leaving the script&hellip;&rdquo;<br />
echo<br />
exit<br />
fi</p>

<p>echo<br />
echo &ldquo;I found this record:&rdquo;<br />
echo $USER_ACCOUNT_RECORD</p>

<p>LINE1=&ldquo;Is this the correct $USER_ACCOUNT? [y|n]&rdquo;<br />
get_answer</p>

<h1 id="call-process-answer-function">call process_answer function:</h1>

<h1 id="if-user-answers-anything-but-yes-exit-script-1">if user answers anything but &ldquo;yes&rdquo;, exit script</h1>

<p>EXIT_LINE1=&ldquo;Because the account, $USER_ACCOUNT, is not &ldquo;<br />
EXIT_LINE2=&ldquo;the one you wish to delete, we are leaving the script&hellip;&rdquo;<br />
process_answer</p>

<p>#####################################################################################################</p>

<h1 id="search-for-any-running-processes-that-belong-to-the-user-account">search for any running processes that belong to the user account</h1>

<p>echo<br />
echo &ldquo;Step #2 - find process on system belonging to user account&rdquo;<br />
echo</p>

<p>ps -u $USER_ACCOUNT &gt;/dev/null #are user processes running ?</p>

<p>case $? in<br />
1) # no processes running for this user account</p>

<p>echo &ldquo;there no processes for this account currently running.&rdquo;<br />
echo<br />
;;<br />
0) # processes running for this user account</p>

<h1 id="ask-script-user-if-wants-us-to-kill-the-processes-1">ask script user if wants us to kill the processes.</h1>

<p>echo &ldquo;$USER_ACCOUNT has the following processes running: &ldquo;<br />
echo<br />
ps -u $USER_ACCOUNT</p>

<p>LINE1=&ldquo;would you like me to kill the process(es)? [y|n]&rdquo;<br />
get_answer</p>

<p>case $ANSWER in<br />
y|Y|YES|yes|Yes|yEs|yeS|YEs|yES ) # if user answers &ldquo;yes&rdquo;,</p>

<h1 id="kill-user-account-processes">kill user account processes.</h1>

<p>echo<br />
echo &ldquo;Killing off process(es)&hellip;&rdquo;</p>

<h1 id="list-user-processes-running-code-in-variable-command-1-1">List user processes running code in variable, COMMAND_1</h1>

<p>COMMAND_1=&ldquo;ps -u $USER_ACCOUNT &ndash;no-heading&rdquo;</p>

<h1 id="create-command-to-kill-process-in-variable-command-3">create command to kill process in variable, COMMAND_3</h1>

<p>COMMAND_3=&ldquo;xargs -d \\n /usr/bin/sudo /bin/kill -9&rdquo;</p>

<h1 id="kill-processes-via-piping-command-together">kill processes via piping command together</h1>

<p>$COMMAND_1 | gawk &lsquo;{print $1}&rsquo; | $COMMAND_3</p>

<p>echo<br />
echo &ldquo;Process(es) killed.&rdquo;<br />
;;<br />
*)</p>

<h1 id="if-user-answers-anything-bu-yes-do-not-kill">if user answers anything bu &ldquo;yes&rdquo;, do not kill.</h1>

<p>echo<br />
echo &ldquo;will not kill the process(es)&rdquo;<br />
echo<br />
;;<br />
esac<br />
;;<br />
esac<br />
################################################################################################################</p>

<h1 id="create-a-report-of-all-files-owned-by-user-account">create a report of all files owned by user account</h1>

<p>echo<br />
echo &ldquo;Step 3 - Find files on system belonging to user account&rdquo;<br />
echo<br />
echo &ldquo;creating a report of all files owned by $USER_ACCOUNT.&rdquo;<br />
echo<br />
echo &ldquo;it is recommended that you backup/archive these files,&rdquo;<br />
echo &ldquo;and then do one of two things:&rdquo;<br />
echo &ldquo; 1) delete the files&rdquo;<br />
echo &ldquo; 2) change the files&rsquo; ownership to a current user account.&rdquo;<br />
echo<br />
echo &ldquo;please wait. this may take a while&hellip;&rdquo;</p>

<p>REPORT_DATE=$(date +%y%m%d)<br />
REPORT_FILE=$USER_ACCOUNT&rdquo;<em>Files</em>&rdquo;$REPORT_DATE&rdquo;.rpt&rdquo;</p>

<p>find / -user $USER_ACCOUNT &gt; $REPORT_FILE 2&gt;/dev/null</p>

<p>echo<br />
echo &ldquo;Report is complete.&rdquo;<br />
echo &ldquo;Name of report: $REPORT_FILE&rdquo;<br />
echo &ldquo;Location of report: $(pwd)&rdquo;<br />
echo</p>

<p>##################################################################################################################</p>

<h1 id="remove-user-account">remove user account</h1>

<p>echo<br />
echo &ldquo;Step #4 - remove user account&rdquo;<br />
echo</p>

<p>LINE1=&ldquo;Remove $USER_ACCOUNT&rsquo;s account from system? [y|n]&rdquo;<br />
get_answer</p>

<h1 id="call-process-answer-function-1">call process_answer function:</h1>

<h1 id="if-user-answers-anything-but-yes-exit-script-2">if user answers anything but &ldquo;yes&rdquo;, exit script</h1>

<p>EXIT_LINE1=&ldquo;Since you do not wish to remove the user account,&rdquo;<br />
EXIT_LINE2=&ldquo;$USER_ACCOUNT at this time, exiting the script&hellip;&rdquo;<br />
process_answer</p>

<p>userdel $USER_ACCOUNT # delete user account<br />
echo<br />
echo &ldquo;user account, $USER_ACCOUNT, has been removed&rdquo;<br />
echo<br />
exit</p>

<p>1.2.3 运行脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
由于被设计成了一个交互式脚本，delete_user.sh 脚本不应放入 cron 表中。但是，保证它能按期望工作仍然很重要。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
要运行这种脚本，必须以 root 用户账户的身份登录，或者使用 sudo 命令以 root用户账户身份运行脚本。</p>

<p>测试脚本之前，赋予脚本执行权限：</p>

<p>[devalone@devalone 24]$ chmod u+x delete_user.sh</p>

<p>通过删除一个系统上临时设置的 test_user 账户来测试这个脚本:</p>

<p>[devalone@devalone 24]$ sudo ./delete_user.sh<br />
step #1 - determine user account name to delete</p>

<p>Please enter the username of the user<br />
account you wish to delete from system:<br />
Please answer the question.</p>

<p>Please enter the username of the user<br />
account you wish to delete from system: test</p>

<p>Is test the user account<br />
you wish to delete from the system? [y|n] y</p>

<p>Account, test, not found.<br />
Leaving the script&hellip;</p>

<p>[devalone@devalone 24]$ sudo ./delete_user.sh<br />
step #1 - determine user account name to delete</p>

<p>Please enter the username of the user<br />
account you wish to delete from system: user_test</p>

<p>Is user_test the user account<br />
you wish to delete from the system? [y|n] y</p>

<p>I found this record:<br />
user_test:x:1001:1001::/home/user_test:/bin/bash</p>

<p>Is this the correct user_test? [y|n] y</p>

<p>Step #2 - find process on system belonging to user account</p>

<p>there no processes for this account currently running.</p>

<p>Step 3 - Find files on system belonging to user account</p>

<p>creating a report of all files owned by user_test.</p>

<p>it is recommended that you backup/archive these files,<br />
and then do one of two things:<br />
1) delete the files<br />
2) change the files&rsquo; ownership to a current user account.</p>

<p>please wait. this may take a while&hellip;</p>

<p>Report is complete.<br />
Name of report: user_test_Files_180714.rpt<br />
Location of report: /home/devalone/study/shell-script/24</p>

<p>Step #4 - remove user account</p>

<p>Remove user_test&rsquo;s account from system? [y|n] y</p>

<p>user account, user_test, has been removed</p>

<p>[devalone@devalone 24]$ grep user_test /etc/passwd<br />
[devalone@devalone 24]$</p>

<p>账户 user_test 被删除。</p>

<p>查看 user_test 所属的文件报告：<br />
[devalone@devalone 24]$ cat user_test_Files_180714.rpt<br />
/home/user_test<br />
/home/user_test/.bash_logout<br />
/home/user_test/.bash_history<br />
/home/user_test/testdir<br />
/home/user_test/file<br />
/home/user_test/.bashrc<br />
/home/user_test/testfile<br />
/home/user_test/.mozilla<br />
/home/user_test/.mozilla/plugins<br />
/home/user_test/.mozilla/extensions<br />
/home/user_test/.zshrc<br />
/home/user_test/.bash_profile<br />
/home/user_test/.emacs<br />
/var/spool/mail/user_test</p>

<p>1.3 监测磁盘空间<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
这个 shell 脚本工具会找出指定目录中磁盘空间使用量位居前十名的用户。它会生成一个以日期命名的报告，使得磁盘空间使用量可以监测。</p>

<p>1.3.1 需要的功能<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
要用到的第一个工具是 du 命令。该命令能够显示出单个文件和目录的磁盘使用情况。-s 选项用来总结目录一级的整体使用状况。这在计算单个用户使用的<br />
总体磁盘空间时很方便。下面的例子是使用 du 命令总结 /home 目录下每个用户的 $HOME 目录的磁盘占用情况：</p>

<p>[devalone@devalone ~]$ sudo du -s /home/*<br />
47523844 /home/devalone<br />
16 /home/lost+found<br />
437880 /home/user1</p>

<p>-s 选项能够很好地处理用户的 $HOME目录，但如果要查看系统目录（比如 /var/log）的磁盘使用情况：</p>

<p>[devalone@devalone ~]$ sudo du -s /var/log/*<br />
6700 /var/log/anaconda<br />
10576 /var/log/audit<br />
8 /var/log/boot.log<br />
0 /var/log/btmp<br />
0 /var/log/btmp-20180702<br />
4 /var/log/chrony<br />
4 /var/log/cluster<br />
4 /var/log/cups<br />
964 /var/log/dnf.librepo.log<br />
448 /var/log/dnf.librepo.log-20180506<br />
384 /var/log/dnf.librepo.log-20180629<br />
96 /var/log/dnf.librepo.log-20180702<br />
708 /var/log/dnf.librepo.log-20180708<br />
88 /var/log/dnf.log<br />
&hellip;</p>

<p>这个列表很快就变得过于琐碎。-S（大写的S）选项能更适合这个目的，它为每个目录和子目录分别提供了总计信息。这样就能快速地定位问题的根源：</p>

<p>[devalone@devalone ~]$ sudo du -S /var/log/<br />
4 /var/log/chrony<br />
4 /var/log/ntpstats<br />
6700 /var/log/anaconda<br />
4 /var/log/cluster<br />
4 /var/log/sssd<br />
4 /var/log/httpd<br />
655616 /var/log/journal/fd73c66c927142dda4afd46e8e2f53e7<br />
8 /var/log/journal<br />
4 /var/log/speech-dispatcher<br />
8 /var/log/hudson<br />
4 /var/log/glusterfs<br />
4 /var/log/libvirt/qemu<br />
4 /var/log/libvirt<br />
10580 /var/log/audit<br />
4 /var/log/cups<br />
4 /var/log/gdm<br />
4 /var/log/samba/old<br />
4 /var/log/samba<br />
4 /var/log/ppp<br />
216 /var/log/vmware<br />
3768 /var/log/</p>

<p>我们感兴趣的是占用磁盘空间最多的目录，所以需要使用 sort 命令对 du 产生的输出进行排序:</p>

<p>[devalone@devalone ~]$ sudo du -S /var/log/ | sort -rn<br />
655616 /var/log/journal/fd73c66c927142dda4afd46e8e2f53e7<br />
10584 /var/log/audit<br />
6700 /var/log/anaconda<br />
3768 /var/log/<br />
216 /var/log/vmware<br />
8 /var/log/journal<br />
8 /var/log/hudson<br />
4 /var/log/sssd<br />
4 /var/log/speech-dispatcher<br />
4 /var/log/samba/old<br />
4 /var/log/samba<br />
4 /var/log/ppp<br />
4 /var/log/ntpstats<br />
4 /var/log/libvirt/qemu<br />
4 /var/log/libvirt<br />
4 /var/log/httpd<br />
4 /var/log/glusterfs<br />
4 /var/log/gdm<br />
4 /var/log/cups<br />
4 /var/log/cluster<br />
4 /var/log/chrony</p>

<p>-n 选项允许按数字排序。-r 选项会先列出最大数字（逆序）。这对于找出占用磁盘空间最多的用户很有用。</p>

<p>sed 编辑器可以让这个列表更容易读懂。我们要关注的是磁盘用量的前 10 名文件，所以当到了第 11 行时，sed 会删除列表的剩余部分。</p>

<p>下一步是给列表中的每行加一个行号。使用 sed 的等号命令（=）来加入行号。要让行号和磁盘空间文本位于同一行，可以用 N 命令将文本行合并在一起，<br />
sed 命令如下:</p>

<p>sed &lsquo;{11,$D; =}&rsquo; |<br />
sed &lsquo;N; s/\n/ /&rsquo; |</p>

<p>现在可以用 gawk 命令清理输出了。sed 编辑器的输出会通过管道输出到 gawk 命令，然后用 printf 函数打印出来:</p>

<p>gawk &lsquo;{printf $1 &ldquo;:&rdquo; &ldquo;\t&rdquo; $2 &ldquo;\t&rdquo; $3 &ldquo;\n&rdquo;}&rsquo;</p>

<p>在行号后面，加了一个冒号（:），还给输出的每行文本的字段间放了一个制表符。这样就能得到一个格式精致的磁盘空间用量前 10 名的文件列表：</p>

<p>[devalone@devalone ~]$ sudo du -S /var/log/ |<br />
&gt; sort -rn |<br />
&gt; sed &lsquo;{11,$D; =}&rsquo; |<br />
&gt; sed &lsquo;N; s/\n/ /&rsquo; |<br />
&gt; gawk &lsquo;{printf $1 &ldquo;:&rdquo; &ldquo;\t&rdquo; $2 &ldquo;\t&rdquo; $3 &ldquo;\n&rdquo;}&rsquo;<br />
1: 655616 /var/log/journal/fd73c66c927142dda4afd46e8e2f53e7<br />
2: 10584 /var/log/audit<br />
3: 6700 /var/log/anaconda<br />
4: 3244 /var/log/<br />
5: 216 /var/log/vmware<br />
6: 8 /var/log/journal<br />
7: 8 /var/log/hudson<br />
8: 4 /var/log/sssd<br />
9: 4 /var/log/speech-dispatcher<br />
10: 4 /var/log/samba/old</p>

<p>1.3.2 创建脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
这个脚本会为多个指定目录创建报告。用一个 CHECK_DIRECTORIES 的变量来完成这一任务。出于演示，该变量只设置为包含两个目录：</p>

<p>CHECK_DIRECTORIES=&ldquo;/var/log /home&rdquo;</p>

<p>脚本使用 for 循环来对变量中列出的每个目录执行 du 命令。这个方法用来读取和处理列表中的值。每次 for 循环都会遍历变量
CHECK_DIRECTORIES 中的<br />
值列表，它会将列表中的下一个值赋给 DIR_CHECK 变量。</p>

<p>for DIR_CHECK in $CHECK_DIRECTORIES<br />
do<br />
[&hellip;]<br />
du -S $DIR_CHECK<br />
[&hellip;]<br />
done</p>

<p>为了方便识别，用 date 命令给报告的文件名加个日期戳。用 exec 命令将脚本的输出重定向到加带日期戳的报告文件中：</p>

<p>DATE=$(date &lsquo;+%m%d%y&rsquo;)<br />
exec &gt; disk<em>space</em>$DATE.rpt</p>

<p>为了生成格式精致的报告，脚本会用 echo 命令来输出一些报告标题：</p>

<p>echo &ldquo;Top Ten Disk Space Usage&rdquo;<br />
echo &ldquo;for $CHECK_DIRECTORIES Directories&rdquo;</p>

<p>完整的脚本代码如下：</p>

<p>[devalone@devalone 24]$ cat big_users.sh<br />
#!/bin/bash</p>

<h1 id="big-users-find-big-disk-space-users-in-various-directories">big_users - find big disk space users in various directories</h1>

<p>#######################################################################################</p>

<h1 id="parameters-for-script">parameters for script</h1>

<p>CHECK_DIRECTORIES=&ldquo;/var/log /home&rdquo; #directories to check</p>

<p>########################## main script
################################################</p>

<p>DATE=$(date &lsquo;+%Y%m%d&rsquo;) # date for report file</p>

<p>exec &gt; disk<em>space</em>$DATE.rpt # make report file STDOUT</p>

<p>echo &ldquo;Top ten disk space usage&rdquo; #report header<br />
echo &ldquo;for $CHECK_DIRECTORIES Directories&rdquo;</p>

<p>for DIR_CHECK in $CHECK_DIRECTORIES #loop to du directories<br />
do<br />
echo &ldquo;&rdquo;<br />
echo &ldquo;The $DIR_CHECK directory:&rdquo; #directory header</p>

<h1 id="create-a-listing-of-top-ten-disk-space-users-in-this-dir">create a listing of top ten disk space users in this dir</h1>

<p>du -S $DIR_CHECK 2&gt;/dev/null |<br />
sort -rn |<br />
sed &lsquo;{11, $D; =}&rsquo; |<br />
sed &lsquo;N; s/\n/ /&rsquo; |<br />
gawk &lsquo;{printf $1 &ldquo;:&rdquo; &ldquo;\t&rdquo; $2 &ldquo;\t&rdquo; $3 &ldquo;\n&rdquo;}&rsquo;</p>

<p>done<br />
#</p>

<p>1.3.3 运行脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
[devalone@devalone 24]$ chmod a+x big_users.sh<br />
[devalone@devalone 24]$ ./big_users.sh<br />
[devalone@devalone 24]$ ll<br />
总用量 28<br />
-rwxrwxr-x. 1 devalone devalone 871 1月 15 13:53 big_users.sh<br />
-rwxrwxr&ndash;. 1 devalone devalone 1842 7月 14 14:36 daily_archive.sh<br />
-rwxrwxr-x. 1 devalone devalone 5747 1月 15 13:53 delete_user.sh<br />
-rw-rw-r&ndash;. 1 devalone devalone 816 7月 16 10:35 disk_space_20180716.rpt<br />
-rwxrwxr-x. 1 devalone devalone 2080 7月 14 15:11 hourly_archive.sh<br />
-rw-r&ndash;r&ndash;. 1 root root 365 7月 14 17:46 user_test_Files_180714.rpt<br />
[devalone@devalone 24]$ cat disk_space_20180716.rpt<br />
Top ten disk space usage<br />
for /var/log /home Directories</p>

<p>The /var/log directory:<br />
1: 655616 /var/log/journal/fd73c66c927142dda4afd46e8e2f53e7<br />
2: 6700 /var/log/anaconda<br />
3: 3244 /var/log<br />
4: 216 /var/log/vmware<br />
5: 8 /var/log/journal<br />
6: 4 /var/log/sssd<br />
7: 4 /var/log/speech-dispatcher<br />
8: 4 /var/log/samba<br />
9: 4 /var/log/ppp<br />
10: 4 /var/log/ntpstats</p>

<p>The /home directory:<br />
1: 4580284 /home/devalone/software/eclipse/myeclipse<br />
2: 1978496 /home/devalone/文档<br />
3: 1650996 /home/devalone/workspaces/dearall/dearall/bakup<br />
4: 1210888 /home/devalone/下载<br />
5: 1073360 /home/devalone/repo/mysql-server/.git/objects/pack<br />
6: 931816 /home/devalone/software/Android<br />
7: 886600 /home/devalone/MyEclipse<br />
8: 865168 /home/devalone/sources/dearall<br />
9: 800076 /home/devalone/software/eclipse<br />
10: 733588 /home/devalone/software/java/oracle_jdk8</p>

<p>OK.</p>

<p>系列目录：</p>

<p>Linux shell 脚本编程-实战篇（一）</p>

<p>Linux shell 脚本编程-实战篇（二）</p>

<p>Linux shell 脚本编程-实战篇（三）</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
参考：</p>

<p>《Linux 命令行与 shell 脚本编程大全》 第 3 版 —— 2016.8（美）Richard Blum Cristine Bresnahan</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>