<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linuxshell笔记八 | 开发者问答集锦</title>
    <meta property="og:title" content="linuxshell笔记八 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linuxshell笔记八">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E7%AC%94%E8%AE%B0%E5%85%AB/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linuxshell笔记八</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p>Bash  程序设计</p>

<p>控制结构： <strong>控制结构有</strong> <strong>if&hellip;then</strong> **** <strong>、</strong> <strong>for&hellip;in</strong> **** <strong>、</strong> <strong>while</strong>
**** <strong>、</strong> <strong>until</strong> **** <strong>、</strong> <strong>case</strong> **** <strong>语句</strong> 。与控制结构配合使用的还有break
和continue 语句也可用于调整shell 脚本中的命令执行顺序。</p>

<p>if&hellip;then ：</p>

<p>if test-command</p>

<p>then</p>

<p>command</p>

<p>fi</p>

<p>test 内置命令：if 测试test-command 返回状态，并基于这个状态转移控制。if 语句的结束由fi 标记。</p>

<p>echo -n “word 1:”</p>

<p>read word1</p>

<p>echo -n “word 2:”</p>

<p>read word2</p>

<p>if test “$word1” = ”$word2”</p>

<p>then</p>

<p>echo “Match”</p>

<p>fi</p>

<p>echo “End of program.”</p>

<p>上面echo 利用&rsquo;-n&rsquo; 选项来表示输出echo 参数后不用换行。</p>

<p>在bash 中test 是一个内置命令，也就是它是shell 的一部分。同时还有一个单独的工具test
。通常某个命令的工具版本不存在，而内置命令版本可用时，使用后者。test 测试语句中使用的&rsquo;=&rsquo; 两边的空白字符不可以省略。</p>

<p>test 的操作符&rsquo;-eq&rsquo; 比较两个整数，特殊变量$# 表示命令行参数的个数。</p>

<p>if test $# -eq 0</p>

<p>then</p>

<p>echo “You must supply at least one argument.”</p>

<p>**exit 1 **</p>

<p>fi</p>

<p>echo “Program running.”</p>

<p>可以利用&rsquo;info test&rsquo; 得到完整的test 用法信息：</p>

<p>测试文件类型：&rsquo;-b FILE&rsquo; &lsquo;-c FILE&rsquo; &lsquo;-d FILE&rsquo; &lsquo;-f FILE&rsquo; &lsquo;-h FILE&rsquo; &lsquo;-L FILE&rsquo; &lsquo;-p FILE&rsquo;
&lsquo;-S FILE&rsquo; ‘-t FD’</p>

<p>访问权限测试：&rsquo;-g FILE&rsquo; &lsquo;-k FILE&rsquo; &lsquo;-r FILE&rsquo; &lsquo;-u FILE&rsquo; &lsquo;-w FILE&rsquo; &lsquo;-x FILE&rsquo; &lsquo;-O FILE&rsquo;</p>

<p>&rsquo;-G FILE&rsquo;</p>

<p>文件特征比较：&rsquo;-e FILE&rsquo; &lsquo;-s FILE&rsquo; &lsquo;FILE1 -nt FILE2&rsquo; &lsquo;FILE1 -ot FILE2&rsquo;</p>

<p>&lsquo;FILE1 -ef FILE2&rsquo;</p>

<p>字符串测试：&rsquo;-z STRING&rsquo; &lsquo;-n STRING&rsquo; &lsquo;STRING&rsquo; &lsquo;STRING1 = STRING2&rsquo;</p>

<p>&lsquo;STRING1 != STRING2&rsquo;</p>

<p>整数测试：&rsquo;ARG1 -eq ARG2&rsquo; &lsquo;ARG1 -ne ARG2&rsquo; &lsquo;ARG1 -lt ARG2&rsquo; &lsquo;ARG1 -le ARG2&rsquo;</p>

<p>&lsquo;ARG1 -gt ARG2&rsquo; &lsquo;ARG1 -ge ARG2&rsquo;</p>

<p>测试条件连接词：&rsquo; <strong>! EXPR</strong> &lsquo; &rsquo; <strong>EXPR1 -a EXPR2</strong> &lsquo; &rsquo; <strong>EXPR1 -o EXPR2</strong> &lsquo;(
注意中间的空白符号)</p>

<p>[] 与test 同义 可以把test 的参数用方括号括起来，以代替在脚本中使用关键字test 。括号两边必须有空白符</p>

<p>if [ $# -eq 0 ]</p>

<p>then</p>

<p>ehco “Usage : chkarg2 argument&hellip;” 1&gt;&amp;2</p>

<p>exit 1</p>

<p>fi</p>

<p>echo “Program running.”</p>

<p>exit 0</p>

<p>用法信息 上面例子显示的信息称为用法信息， <strong>使用</strong> <strong>&lsquo;1 &gt;&amp;2&rsquo;</strong> <strong>标记可把这个输出重定位到标准错误输出</strong>
<strong>。在脚本正常运行后一般退出状态为</strong> <strong>0</strong> **** <strong>，如果退出状态非</strong> <strong>0</strong> **** <strong>表示遇到一个错误。</strong></p>

<p>if&hellip;then&hellip;else</p>

<p>if test-command</p>

<p>then</p>

<p>commands</p>

<p>else</p>

<p>commands</p>

<p>fi</p>

<p>if test-command;then</p>

<p>commands</p>

<p>else</p>

<p>commands</p>

<p>fi</p>

<p>下面的shell 脚本，参数为文件名，该脚本将文件内容显示在终端上。如果第一个参数为&rsquo;-v&rsquo; ，该脚本将使用less 命令分页显示。</p>

<p>if [ $# -eq 0 ]</p>

<p>then</p>

<p>echo “Usage: out [-v] filename&hellip;” 1&gt;&amp;2</p>

<p>exit 1</p>

<p>fi</p>

<p>if [ “$1” = “-v” ]</p>

<p>then</p>

<p>**shift **</p>

<p>less &ndash; <strong>“$@”</strong></p>

<p>else</p>

<p>cat &ndash; <strong>“$@”</strong></p>

<p>fi</p>

<p>在上面的脚本中， <strong>cat</strong> <strong>和</strong> <strong>less</strong> <strong>命令的</strong> <strong>&rsquo;&ndash;&rsquo;</strong>
<strong>参数通知调用这些工具的命令行它后面再没有选项了，即不再把</strong> <strong>&rsquo;&ndash;&rsquo;</strong> <strong>后面以连字符开头的参数作为选项。‘</strong> <strong>rm &ndash;
-example.sh’(</strong> <strong>删除文件</strong> <strong>-example.sh).</strong></p>

<p>**shift ** <strong>和</strong> <strong>set</strong> **** <strong>对位置参数的操作。</strong></p>

<p>if … then … elif ：</p>

<p>if test-command</p>

<p>then</p>

<p>commands</p>

<p>elif test-command</p>

<p>then</p>

<p>commands</p>

<p>…</p>

<p>else</p>

<p>commands</p>

<p>fi</p>

<p>示例：</p>

<p>echo -n “Word 1:”</p>

<p>read word1</p>

<p>echo -n “Word 2:”</p>

<p>read word2</p>

<p>echo -n “Word 3:”</p>

<p>read word3</p>

<p>if [ “$word1” = “$word2” -a “$word1” = “$word3” ]</p>

<p>then</p>

<p>echo “Match : words 1,2 &amp; 3”</p>

<p>elif [ “$word1” = “$word2” ]</p>

<p>then</p>

<p>echo “Match : word 1 &amp; 2”</p>

<p>elif [ “$word2” = “$word3” ]</p>

<p>then</p>

<p>echo “Match : word 2 &amp; 3”</p>

<p>else</p>

<p>echo “No Match”</p>

<p>fi</p>

<p>上面的脚本第一个if 语句使用 <strong>布尔操作符</strong> <strong>AND(-a)</strong> **** <strong>作为</strong> <strong>test</strong> **** <strong>的一个参数。注意</strong>
<strong>&rsquo;=&rsquo; &lsquo;[&rsquo;</strong> **** <strong>和</strong> <strong>&rsquo;]&rsquo;</strong> **** <strong>两边的空白符不可省略。</strong></p>

<p>1 #!/bin/bash</p>

<p>2 # Identify links to a file</p>

<p>3 # Usage: lnks file [directory]</p>

<p>4 if <strong>[ $# -eq 0 -o $# -gt 2 ]</strong></p>

<p>5 then</p>

<p>6 echo &ldquo;Usage:lnks file [directory]&rdquo; 1&gt;&amp;2</p>

<p>7 exit 1</p>

<p>8 fi</p>

<p>9</p>

<p>10 if <strong>[ -d &ldquo;$1&rdquo; ]</strong></p>

<p>11 then</p>

<p>12 echo &ldquo;First argument cannot be a directory.&rdquo; 1&gt;&amp;2</p>

<p>13 exit 1</p>

<p>14 else</p>

<p>15 file=&ldquo;$1&rdquo;</p>

<p>16 fi</p>

<p>17 if <strong>[ $# -eq 1 ]</strong></p>

<p>18 then</p>

<p>19 directory=&ldquo;.&rdquo;</p>

<p>20 elif [ -d &ldquo;$2&rdquo; ]</p>

<p>21 then</p>

<p>22 directory=&ldquo;$2&rdquo;</p>

<p>23 else</p>

<p>24 echo &ldquo;Optional second argument must be a directory.&rdquo; 1&gt;&amp;2</p>

<p>25 echo &ldquo;Usage:lnks file [directory].&rdquo; 1&gt;&amp;2</p>

<p>26 exit 1</p>

<p>27 fi</p>

<p>28</p>

<p>29 #check that file exists and is a regular file:</p>

<p>30 if <strong>[ ! -f &ldquo;$file&rdquo; ]</strong></p>

<p>31 then</p>

<p>32 echo &ldquo;lnks:$file not found or special file&rdquo; 1&gt;&amp;2</p>

<p>33 exit 1</p>

<p>34 fi</p>

<p>35 #check link count on file</p>

<p>36 **** **set &ndash; $(ls -l &ldquo;$file&rdquo;) **</p>

<p>37 <strong>linkcnt=$2</strong></p>

<p>38 if <strong>[ &ldquo;$linkcnt&rdquo; -eq 1 ]</strong></p>

<p>39 then</p>

<p>40 echo &ldquo;lnks : no other hard links to $file&rdquo; 1&gt;&amp;2</p>

<p>41 exit 0</p>

<p>42 fi</p>

<p>43 #get the inode of the given file</p>

<p>44 **set $(ls -i &ldquo;$file&rdquo;) **</p>

<p>45</p>

<p>46 inode=$1</p>

<p>47 #find and print the files with that incite number</p>

<p>48 echo &ldquo;lnks:using find to search for links&hellip;&rdquo; 1&gt;&amp;2</p>

<p>49 find &ldquo;$directory&rdquo; -xdev -inum $inode -print</p>

<p>50</p>

<p>黑体黄底命令行使用了命令替换 $(command)</p>

<p>确定shell ，用法消息，注释，测试参数。</p>

<p><strong>内置命令</strong> <strong>set</strong> <strong>使用命令替换机制把位置参数设置为</strong> <strong>ls -l</strong> <strong>命令的输出。</strong>
输出的第二个字段就是链接的数目，因此就将linkcnt 就被设置为$2 。set 中的参数&rsquo;&ndash;&rsquo; 防止把&rsquo;-ls -l&rsquo;(
第一个输出字段是对文件的访问许可，一般以字符‘-’ 开头) 产生的信息作为选项。</p>

<p>比较与文件名关联的inode 来确定多个文件名是否链接到同一个文件，这是一种好方法。</p>

<p>find 工具用于查找满足其参数所指定条件的文件，查找的位置由第一个参数($directory) 指定并搜索其所有子目录。余下的参数指定把值为$inode
的文件的文件名送到标准输出。由于不同文件系统中的文件可能拥有相同的inode 号，并且没有链接，find 必须只查找同一文件系统中的目录。参数-xdev
防止find 命令搜索其他文件系统。</p>

<p><strong>可以使用</strong> <strong>-x</strong> **** <strong>选项来帮助调试脚本。该选项使得</strong> <strong>shell</strong> **** <strong>执行每条命令前把命令显示出来。</strong></p>

<p>可以在带参数&rsquo;-x&rsquo; 的shell 中运行上面的shell 脚本，在执行每条命令前先将该命令显示出来。要么为当前shell 设置&rsquo;-x&rsquo; 选项( 使用
set -x 命令) ，以使所有脚本的命令在执行前都显示出来。要么只在当前执行脚本中通过shell 使用&rsquo;-x&rsquo; 选项。</p>

<p>**&gt; bash -x lnks.sh example **</p>

<p>脚本中的每条命令前都会加上PS4 变量的值，默认是加号&rsquo;+&lsquo;. 因此可通过该值来区分是脚本输出还是调试输出。</p>

<p><strong>通过在脚本的开始位置加入带有</strong> <strong>&rsquo;-x&rsquo;</strong> **** <strong>参数的</strong> <strong>set</strong> **** <strong>，就可以设置运行该脚本的</strong>
<strong>shell</strong> **** <strong>。</strong> &lsquo;set -x&rsquo;</p>

<p>若要关闭调试则引应使用命令:&lsquo;set +x&rsquo;</p>

<p>&lsquo;set -x&rsquo;  同 &lsquo;set -xtrace&rsquo;</p>

<p>控制结构for&hellip;in 的语法如下：</p>

<p>for loop-index in argument-list</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<p>依照argument-list 中的每个参数( 将对应的每一个参数赋值给loop-index 变量) 重复执行do 和done 语句之间的命令。</p>

<p>例子1 ：</p>

<p><strong>1 for fruit in apples oranges pears bananas</strong></p>

<p><strong>2 do</strong></p>

<p><strong>3 echo &ldquo;$fruit&rdquo;</strong></p>

<p><strong>4 done</strong></p>

<p>例子2 ：</p>

<p>**1 for i in ***</p>

<p><strong>2 do</strong> ****</p>

<p><strong>3 if [ -d &ldquo;$i&rdquo; ]</strong> ****</p>

<p><strong>4 then</strong> ****</p>

<p><strong>5 echo &ldquo;$i&rdquo;</strong> ****</p>

<p><strong>6 fi</strong> ****</p>

<p><strong>7 done</strong> ****</p>

<p>*<em>&lsquo;</em>&rsquo; ** <strong>匹配当前目录下所有可见文件名，与运行该</strong> <strong>shell</strong> **** <strong>脚本的当前目录有关，而与</strong> <strong>shell</strong>
**** <strong>脚本所在目录无关。</strong></p>

<p>for 控制结构语法如下：</p>

<p>for loop-index</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<p><strong>loop-index</strong> <strong>用命令行参数中的每个参数值取代</strong> ，重复执行do 和done
之间的语句。除了参数来源不同，该结构语法同&rsquo;for&hellip;in&rsquo; 结构语法。</p>

<p>例子：</p>

<blockquote>
<p>cat -n for_test.sh</p>
</blockquote>

<p>1 for arg</p>

<p>2 do</p>

<p>3 echo &ldquo;$arg&rdquo;</p>

<p>4 done</p>

<p>5</p>

<blockquote>
<p>chmod a+rwx for_test.sh</p>

<p>./for_test.sh example example2 example4 example6</p>
</blockquote>

<p>**&lsquo;for arg&rsquo; ** **隐含表示 ** **&lsquo;for arg in “$@”&rsquo; ** **，这里将” ** **$@” **
<strong>扩展为一个命令行参数列表， 如”</strong> <strong>$1””$2””$3”</strong> <strong>等。</strong></p>

<blockquote>
<p>cat -n whos.sh</p>
</blockquote>

<p>1 #!/bin/bash</p>

<p>2 # adapted from finger.sh by Lee Sailer</p>

<p>3 # UNIX/WORLD</p>

<p>4</p>

<p>5 if [ $# -eq 0 ]</p>

<p>6 then</p>

<p>7 echo &ldquo;Usage: whos id &hellip;&rdquo; 1&gt;&amp;2</p>

<p>8 exit 1</p>

<p>9 fi</p>

<p>10</p>

<p>11 for id</p>

<p>12 do</p>

<p>13 <strong>gawk -F: &lsquo; {print $1,$5} &rsquo; /etc/passwd |</strong></p>

<p>14 <strong>grep -i &ldquo;$id&rdquo;</strong></p>

<p>15 done</p>

<p>16</p>

<blockquote>
<p>./whos.sh root “terry Zeng”</p>
</blockquote>

<p>脚本whos 演示了for 结构中$@ 符号所代表的含义。whos 脚本后面可以跟一个或几个用户名作为参数，执行whos
脚本就可以将这些与用户相关的信息显示出来。</p>

<p><strong>在这个脚本中的</strong> <strong>for</strong> <strong>循环中隐含的</strong> <strong>$@</strong> <strong>的使用特别有效果，因为它使得</strong> <strong>for</strong>
<strong>循环可以把带空格的参数视为一个单独的参数</strong> ( 如参数” terry Zeng”) 。</p>

<p>对于每个命令行参数，whos 搜索/etc/passwd 文件。在for 循环结构中gawk 的作用是从文件/etc/passwd 的行中提取第一个($1)
和第5 个($5) 字段的内容。第1 个和第5 个字段的内容通过一个管道传递给grep 。grep 在其输入中搜索内容为$id($id
就是输入的命令行参数) 的对象。选项&rsquo;-i&rsquo; 的作用是让grep 在搜索过程中忽略其他的事件，grep 在其输入中按照每行的格式显示包含$id 内容的对象。</p>

<p>行末的｜ 即便在管道标志后面还有换行，管道也能照常工作。</p>

<p>while ：</p>

<p>while 控制结构语法如下：</p>

<p>while test-command</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<p>只要测试条件的返回值为真，while 结构语句就要执行do 与done 语句之间的命令。</p>

<p>例子：</p>

<blockquote>
<p>cat -n count.sh</p>
</blockquote>

<p>1 #!/bin/bash</p>

<p>2 number=0</p>

<p>3 while [ &ldquo;$number&rdquo; -lt 10 ]</p>

<p>4 do</p>

<p>5 echo -n &ldquo;$number&rdquo;</p>

<p>6 <strong>((number += 1))</strong></p>

<p>7 done</p>

<p>8 <strong>echo</strong></p>

<p>test 内置命令：脚本使用了&rsquo;-lt&rsquo;
来执行数值比较测试。对于数值比较测试由以下几种测试选项：&rsquo;-ne&rsquo;,&lsquo;-eq&rsquo;,&lsquo;-gt&rsquo;,&lsquo;-ge&rsquo;,&lsquo;-lt&rsquo;,&lsquo;-le&rsquo;
。对于字符串的比较可以用&rsquo;=&rsquo; 或者&rsquo;!=&rsquo; 来进行测试比较。</p>

<p><strong>使用</strong> <strong>&rsquo;-n&rsquo;</strong> <strong>选项用来防止</strong> <strong>echo</strong> <strong>在其输出之后输出换行。最后的</strong> <strong>echo</strong>
<strong>使脚本在标准输出上输出一个新的字符行。</strong> <strong>((number += 1))</strong> <strong>赋值表达式。</strong></p>

<p>例子：</p>

<p>1 #!/bin/bash</p>

<p>2 # remove correct spellings from aspell output</p>

<p>3</p>

<p>4 if [ $# -ne 2 ]</p>

<p>5 then</p>

<p>6 echo &ldquo;Usage spell_check.sh file1 file2&rdquo; 1&gt;&amp;2</p>

<p>7 echo &ldquo;file1 list of correct spellings&rdquo; 1&gt;&amp;2</p>

<p>8 echo &ldquo;file2 file to be checked&rdquo; 1&gt;&amp;2</p>

<p>9 exit 1</p>

<p>10 fi</p>

<p>11</p>

<p>12 if <strong>[ ! -r &ldquo;$1&rdquo; ]</strong></p>

<p>13 then</p>

<p>14 echo &ldquo;spell ..check; $1 is not readable&rdquo; 1&gt;&amp;2</p>

<p>15 exit 1</p>

<p>16 fi</p>

<p>17</p>

<p>18 if [ ! -r &ldquo;$2&rdquo; ]</p>

<p>19 then</p>

<p>20 echo &ldquo;spell ..check; $2 is not readable&rdquo; 1&gt;&amp;2</p>

<p>21 exit 1</p>

<p>22 fi</p>

<p>23</p>

<p>24 **aspell -l &lt; &ldquo;$2&rdquo; | **</p>

<p>25 <strong>while read line</strong></p>

<p>26 do</p>

<p>27 if **! grep &ldquo;^$line$&rdquo; &ldquo;$1&rdquo; &gt; /dev/null **</p>

<p>28 then</p>

<p>29 echo $line</p>

<p>30 fi</p>

<p>31 done</p>

<p>32</p>

<p>上面的脚本中&rsquo;-r&rsquo; 参数判断一个文件是否是可读的，括号里的感叹号是对跟着的操作符进行相反的运算，与&rsquo;-r&rsquo; 参数联合起来用以判断一个文件是否是不可读的。</p>

<p>上面的脚本把aspell 脚本的输出( 使用参数-l 可以让aspell 脚本把所检查出的错误单词的列表送到标准输出上) 通过一个管道送到while
结构的标准输入上，while 结构从他的标准输入上一次读入一行内容( 每行只有一个单词) 。只要测试条件( 也就是read line)
能从标准输入上得到一个单词，那么它就返回一个true 状态。</p>

<p>在while 循环中if 语句用来检测grep 条件测试的返回值，grep 是用来判断被读取行是否在用户的正确单词列表中。grep 搜索的模式(
也就是$line) 前后都有特殊字符，这些字符分别用来指明一行的开始和结束( 分别是&rsquo;^&rsquo; 和&rsquo;$&rsquo; ； **&lsquo;^$line$&rsquo; ** <strong>理解为</strong>
<strong>&rsquo;^&mdash;$line&mdash;$&rsquo;</strong> **** <strong>其中</strong> <strong>&rsquo;^&rsquo;</strong> **** <strong>代表行的开始，第一个</strong> <strong>&rsquo;$&rsquo;</strong> ****
<strong>代表对变量</strong> <strong>&lsquo;line&rsquo;</strong> **** <strong>的引用，第二个</strong> <strong>&rsquo;$&rsquo;</strong> **** <strong>代表行的结束</strong> ) 。
这些特殊符号的作用是确保grep 搜索时只有当变量$line 的内容与用户输入的正确单词列表的一整行的内容相同时才形成匹配。grep
的标准输出被重定向到文件/dev/null 中，因为我们不关心输出结果，只关心返回状态。</p>

<p>**&rsquo; if ! grep &ldquo;^$line$&rdquo; &ldquo;$1&rdquo; &gt; /dev/null &lsquo;  ** <strong>可以替换为</strong> <strong>&rsquo; if ! grep -qw
“$line” “$1” &lsquo;</strong> **** <strong>。</strong> 其中&rsquo;-q&rsquo; 抑制了grep 的输出，这样只返回退出状态。&rsquo;-w&rsquo; 使得grep 只匹配整个单词。</p>

<p>until</p>

<p>until 与while 语句的语法结构相似。区别仅在于条件语句的测试位置：一个在语句的开始测试，一个在语句的结束测试。</p>

<p>until test-commands</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<p>例子：</p>

<p>1 #! /bin/bash</p>

<p>2 secretname=jenny</p>

<p>3 name=noname</p>

<p>4 echo &ldquo;Try to guess the secret name!&rdquo;</p>

<p>5 echo</p>

<p>6 until [ &ldquo;$name&rdquo; = &ldquo;$secretname&rdquo; ]</p>

<p>7 do</p>

<p>8 echo -n &ldquo;Your guess:&rdquo;</p>

<p>9 read name</p>

<p>10 done</p>

<p>11 echo &ldquo;Very good.&rdquo;</p>

<p>12</p>

<p>例子：</p>

<p>1 #!/bin/bash</p>

<p>2 # UNIX/WORLD</p>

<p>3 trap &lsquo; &rsquo; 1 2 3 18</p>

<p>4 <strong>stty -echo</strong></p>

<p>5 echo -n &ldquo;Key: &ldquo;</p>

<p>6 read key_1</p>

<p>7 echo</p>

<p>8 echo -n &ldquo;Again:&rdquo;</p>

<p>9 read key_2</p>

<p>10 echo</p>

<p>11 key3=</p>

<p>12 if [ &ldquo;$key_1&rdquo; = &ldquo;$key_2&rdquo; ]</p>

<p>13 then</p>

<p>14 tput clear</p>

<p>15 until [ &ldquo;$key_3&rdquo; = &ldquo;$key_2&rdquo; ]</p>

<p>16 do</p>

<p>17 read key_3</p>

<p>18 done</p>

<p>19 else</p>

<p>20 echo &ldquo;locktty: keys do not match&rdquo; 1&gt;&amp;2</p>

<p>21 fi</p>

<p>22 stty echo</p>

<p>23</p>

<p>如果运行上面的例子而忘记了脚本密码，可以登录另一个虚拟终端并终止该进程。</p>

<p>trap 内置命令： <strong>利用</strong> <strong>trap</strong> <strong>内置命令可以防止用户通过发送中断的方式来终止脚本的运行。通过捕获信号</strong> <strong>18</strong>
<strong>可以保证用户无法用</strong> <strong>CONTROL+Z</strong> <strong>组合键来挂起运行该脚本的进程。</strong> **stty -echo **
<strong>命令来防止终端把键盘输入的字符显示出来</strong> <strong>，这样可以保证输入的密码不被显示出来。</strong></p>

<p>break 与continue ：同c 语言可以用来中断for while until 语句的执行</p>

<p>1 #!/bin/bash</p>

<p>2 for index in 1 2 3 4 5 6 7 8 9</p>

<p>3 do</p>

<p>4 if [ $index -le 3 ]</p>

<p>5 then</p>

<p>6 echo &ldquo;continue&rdquo;</p>

<p>7 continue</p>

<p>8 fi</p>

<p>9 echo $index</p>

<p>10 if [ $index -ge 8 ]</p>

<p>11 then</p>

<p>12 echo &ldquo;break&rdquo;</p>

<p>13 break</p>

<p>14 fi</p>

<p>15 done</p>

<p>16</p>

<p>case ：一种多分支选择机制，同C 语言。</p>

<p>case test-string in</p>

<p>pattern-1)</p>

<p>commands-1</p>

<p>;;</p>

<p>pattern-2)</p>

<p>commands-2</p>

<p>;;</p>

<p>pattern-3)</p>

<p>commands-3</p>

<p>;;</p>

<p>&hellip;</p>

<p>esac</p>

<p>case 结构中的匹配类型类似于一个模糊文件引用。</p>

<p>字符‘*’:  匹配任意字符串，用作默认的case 匹配。</p>

<p>字符‘?’:  匹配 单个字符。</p>

<p>| :  分离带有选择的选项，这些选项满足case 结构的一个特别的分支。</p>

<p>例子：</p>

<p>1 echo -n &ldquo;Enter A,B,or C:&rdquo;</p>

<p>2 read letter</p>

<p>3 case &ldquo;$letter&rdquo; in</p>

<p>4 a|A)</p>

<p>5 echo &ldquo;You Entered A&rdquo;</p>

<p>6 ;;</p>

<p>7 b|B)</p>

<p>8 echo &ldquo;You Entered B&rdquo;</p>

<p>9 ;;</p>

<p>10 c|C)</p>

<p>11 echo &ldquo;You Entered C&rdquo;</p>

<p>12 ;;</p>

<p>13 *)</p>

<p>14 echo &ldquo;You did not enter A,B,or C&rdquo;</p>

<p>15 ;;</p>

<p>16 esac</p>

<p>例子：</p>

<p>1 #!/bin/bash</p>

<p>2</p>

<p>3 <strong>echo -e</strong> &ldquo;/n COMMAND MENU/n&rdquo;</p>

<p>4 echo &ldquo;a.Current date and time&rdquo;</p>

<p>5 echo &ldquo;b.Users currently logged in&rdquo;</p>

<p>6 echo &ldquo;c.Name of the working directory&rdquo;</p>

<p>7 <strong>echo -e</strong> &ldquo;d.Contents of the working directory/n&rdquo;</p>

<p>8 <strong>echo -n</strong> &ldquo;Enter a,b,c,or d:&rdquo;</p>

<p>9 read answer</p>

<p>10 echo</p>

<p>11 case &ldquo;$answer&rdquo; in</p>

<p>12 a)</p>

<p>13 date</p>

<p>14 ;;</p>

<p>15 b)</p>

<p>16 who</p>

<p>17 ;;</p>

<p>18 c)</p>

<p>19 pwd</p>

<p>20 ;;</p>

<p>21 d)</p>

<p>22 ls</p>

<p>23 ;;</p>

<p>24 *)</p>

<p>25 echo &ldquo;There is no selection:$answer&rdquo;</p>

<p>26 ;;</p>

<p>27 esac</p>

<p><strong>&lsquo;echo -e&rsquo;</strong> <strong>选项</strong> <strong>-e</strong> <strong>使</strong> <strong>echo</strong> <strong>把后面的</strong> <strong>&rsquo;/n&rsquo;</strong> <strong>解释为一个换行符，如果</strong>
<strong>echo</strong> <strong>后面不加这个参数</strong> <strong>&rsquo;-e&rsquo;</strong> <strong>，</strong> <strong>echo</strong> <strong>就会输出两个字符</strong> <strong>&rsquo;/n&rsquo;</strong>
**，而不是一个空行。 参数 ** **&lsquo;-e&rsquo; ** **使得 ** **echo ** **解释由反斜杠 ** **&lsquo;/&rsquo; ** <strong>转义的字符。
带有反斜杠的字符一定要引起来，否则反斜杠就要由</strong> <strong>shell</strong> <strong>来解释而不会传到</strong> <strong>echo</strong> <strong>由</strong> <strong>echo</strong>
<strong>解释。</strong></p>

<p>例子：</p>

<blockquote>
<p>cat -n safedit</p>
</blockquote>

<p>1 #!/bin/bash</p>

<p>2 **PATH=/bin:/usr/bin **</p>

<p>3 **script=$(basename $0) ** ****</p>

<p>4 case $# in</p>

<p>5 0)</p>

<p>6 vim</p>

<p>7 exit 0</p>

<p>8 ;;</p>

<p>9 1)</p>

<p>10 if [ ! -f &ldquo;$1&rdquo; ]</p>

<p>11 then</p>

<p>12 vim &ldquo;$1&rdquo;</p>

<p>13 exit 0</p>

<p>14 fi</p>

<p>15 if [ ! -r &ldquo;$1&rdquo; -o ! -w &ldquo;$1&rdquo; ]</p>

<p>16 then</p>

<p>17 echo &ldquo;$script:check permissions on $1&rdquo; 1&gt;&amp;2</p>

<p>18 exit 1</p>

<p>19 else</p>

<p>20 editfile=&ldquo;$1&rdquo;</p>

<p>21 fi</p>

<p>22 if [ ! -w &ldquo;.&rdquo; ]</p>

<p>23 then</p>

<p>24 echo &ldquo;$script:backup cannont be&rdquo;/</p>

<p>25 &ldquo;created in the working directory&rdquo; 1&gt;&amp;2</p>

<p>26 exit 1</p>

<p>27 fi</p>

<p>28 ;;</p>

<p>29 *)</p>

<p>30 echo &ldquo;Usage:$script [file-to-edit]&rdquo; 1&gt;&amp;2</p>

<p>31 exit 1</p>

<p>32 ;;</p>

<p>33 esac</p>

<p>34</p>

<p>35 **tempfile=/tmp/$$.$script **</p>

<p>36 cp $editfile $tempfile</p>

<p>37 if vim $editfile</p>

<p>38 then</p>

<p>39 **mv $tempfile bak.$(basename $editfile) **</p>

<p>40 echo &ldquo;$script:backup file created&rdquo;</p>

<p>41 else</p>

<p>42 mv $tempfile editerr</p>

<p>43 echo &ldquo;$script:edit error&ndash;copy of&rdquo; /</p>

<p>44 &ldquo;original file is in editerr&rdquo;1&gt;&amp;2</p>

<p>45 fi</p>

<p>46</p>

<blockquote>
<p>chmod u+x safedit</p>

<p>./safedit example.sh</p>
</blockquote>

<p>再另一个控制台上进入tmp 目录可以查看到一个nxxn.safedit 的临时文件，回到原来的控制台退出vim
编辑器，查看当前控制台当前工作目录下会生成一个备份文件格式bak.example.sh 。再打开新的控制台查看/tmp
目录发现最开始生成的临时文件已经被删除。</p>

<blockquote>
<p>ln safedit safedit.ln</p>

<p>./safedit.ln example.sh</p>
</blockquote>

<p>注意观察该命令行运行的过程，生成的中间文件，最后结果与上面文字描述的不同。</p>

<p><strong>设置</strong> <strong>PATH</strong> <strong>变量：该脚本设置了</strong> <strong>PATH</strong>
<strong>变量，目的是为了保证脚本中执行的命令是系统目录中的标准命令。避免了用户自己可能设置的</strong> <strong>PATH</strong>
<strong>包含自己定义的目录，而在该自定义目录下，用户可能编写了一些与脚本中调用命令同名的脚本或程序。</strong></p>

<p><strong>程序名：</strong> <strong>basename</strong> <strong>去掉前导的目录部分后打印名称，因此脚本中将</strong> <strong>script</strong>
<strong>设置为运行脚本的基本名称。通过命令替换实现。</strong> <strong>$0</strong>
<strong>存储脚本被调用时的命令。好处在于对脚本进行重命名或则创建链接后运行该脚本会得到正确的提示信息。</strong></p>

<p><strong>给临时文件命名：脚本中设置变量</strong> <strong>tempfile</strong> <strong>为临时文件名，以</strong> <strong>shell</strong> <strong>进程的</strong> <strong>PID</strong>
<strong>号作为开始并以脚本的名字作为结束。使用</strong> <strong>PID</strong> <strong>号是为了确保文件名的唯一性，脚本名字附在临时文件名后面，为了让用户知道其来源。</strong>
<strong>PID</strong> <strong>号放在前面是由于一些老版本</strong> <strong>unix</strong> <strong>上对文件名有长度限制，而</strong> <strong>PID</strong>
<strong>号可以确保其唯一性，所以放在前面避免由于文件名字长的限制而被切去。</strong></p>

<p><strong>测试条件：脚本中使用了一个测试条件</strong> <strong>vim $editfile</strong> <strong>。测试</strong> <strong>vim</strong> <strong>编辑器编辑文件完成后返回的</strong>
<strong>exit</strong> <strong>代码，</strong> <strong>if</strong> <strong>控制结构就是利用这个</strong> <strong>exit</strong> <strong>代码来决定分支。成功则返回</strong> <strong>0</strong> <strong>，</strong>
<strong>then</strong> <strong>被执行；不成功则返回非</strong> <strong>0</strong> <strong>，</strong> <strong>else</strong> <strong>语句被执行。</strong></p>

<p>select ：首先显示一个菜单，然后根据用户的选择给变量赋予相应的值，最后执行一系列命令。</p>

<p>select <em>varname</em> [in arg ….]</p>

<p>do</p>

<p><em>command</em></p>

<p>done</p>

<p>例子：</p>

<p>1 #! /bin/bash</p>

<p>2 <strong>PS3=</strong> &lsquo;Choose your favorite fruit from these from these possibilities:&rsquo;</p>

<p>3 select <strong>FRUIT</strong> in apple banana blueberry kiwi orange watermelon STOP</p>

<p>4 do</p>

<p>5 if [ <strong>&rdquo;$FRUIT&rdquo; = &ldquo;&rdquo;</strong> ];then</p>

<p>6 echo -e &ldquo;Invalid entry./n&rdquo;</p>

<p>7 continue</p>

<p>8 elif [ &ldquo; <strong>$FRUIT</strong> &ldquo; = STOP ];then</p>

<p>9 echo &ldquo;Thanks for playing.&rdquo;</p>

<p>10 break</p>

<p>11 fi</p>

<p>12 echo &ldquo;You Chose $FRUIT as your favorite.&rdquo;</p>

<p>13 echo -e &ldquo;That is choice number <strong>$REPLY</strong> ./n&rdquo;</p>

<p>14 done</p>

<p>15</p>

<p><strong>PS3</strong> <strong>：是</strong> <strong>select</strong> <strong>特有的提示符，在</strong> <strong>select</strong> <strong>语句输出菜单后，就会显示出</strong> <strong>PS3</strong>
<strong>的值。</strong> <strong>slect</strong> <strong>不断的发出</strong> <strong>PS3</strong> <strong>提示并按照用户的输入执行命令，直到有事情使其停止。</strong></p>

<p><strong>select</strong> <strong>将</strong> **<em>varname</em> ** **设置为输入的值 ** **( ** **例子中是变量 ** **FRUIT) **
**，同时将用户的响应存储在键盘变量 ** **REPLY ** **中。如果用用户非法输入， ** **shell ** **将 **
**<em>varname</em> ** **设置为空 ** **($FRUIT) ** **。 **</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>