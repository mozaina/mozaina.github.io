<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>使P2P能进行交互操作Jxta命令shell | 开发者问答集锦</title>
    <meta property="og:title" content="使P2P能进行交互操作Jxta命令shell - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="使P2P能进行交互操作Jxta命令shell">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/%E4%BD%BFp2p%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9Cjxta%E5%91%BD%E4%BB%A4shell/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">使P2P能进行交互操作Jxta命令shell</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /> |</p>

<h2 id="https-img-it610-com-image-info8-faa71289894b4f62a548a50076eba4bc-gif">| <img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></h2>

<p><strong>内容：</strong><br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></p>

<h2 id="安装-jxta">| 安装 Jxta</h2>

<p><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
剖析对等机<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
P2P 基础通信<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
扩展 shell：一个简单示例<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
编写一个复杂的 shell 扩展<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
测试 waitptext 命令<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
谈谈互操作性<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
下一步：延伸到网络<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
参考资料<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
关于作者<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
对本文的评价<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></p>

<h2 id="https-img-it610-com-image-info8-faa71289894b4f62a548a50076eba4bc-gif-1"><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></h2>

<p><strong>相关内容：</strong><br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></p>

<h2 id="对等计算">| 对等计算</h2>

<p><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
高级对等联网（Advanced Peer-to-Peer Networking，APPN）<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
系列第一部分：支持 Jxta 的基本概念和协议<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
更多的 dW Java 参考资料<br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></p>

<h2 id="https-img-it610-com-image-info8-faa71289894b4f62a548a50076eba4bc-gif-2"><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></h2>

<p><strong>订阅:</strong><br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></p>

<h2 id="developerworks-时事通讯">| developerWorks 时事通讯</h2>

<p><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
<img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></p>

<h2 id="https-img-it610-com-image-info8-faa71289894b4f62a548a50076eba4bc-gif-3"><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /></h2>

<p><img src="https://img.it610.com/image/info8/faa71289894b4f62a548a50076eba4bc.gif" alt="" /><br />
学习从头开始构建 P2P 应用</p>

<p>Sing Li<br />
作家, Wrox 出版社<br />
2001 年 9 月 12 日</p>

<blockquote>
<p>Jxta 工程按社区方式运作，旨在为对等应用构建实用应用程序底层。Jxta 最初的参考实现包含一个命令行 shell，使您无须编程就能试验核心 Jxta
平台。在本系列（共 3 部分）的第 2 部分，Sing Li 将带我们去实际体验一下 Jxta shell。您将��索它的命令集并用 Java
编程语言编写您自己的定制命令来扩展它的功能。请在 讨论论坛与作者和其他读者共享您关于本文的心得。</p>
</blockquote>

<p>Jxta 命令 shell 正是多数 Jxta 开发者将碰到的第一个 Jxta 应用。事实上，Jxta 开发包（Jxta development kit）把
shell 作为缺省应用包含在其中。这样做有一个很好的理由：一行代码都不用写，通过 shell 您就可以体会组成 Jxta 平台的组件。与大家熟悉的
UNIX 或 DOS shell 一样，shell 也是一个大量使用环境变量的命令行工具。在本系列的这一部分中，您将熟悉这个万能 shell
的基本命令，并学习如何编写您自己的命令来增强它的功能。</p>

<p>在我们开始之前，您必须先安装 Jxta shell。您可以从本文末尾的 参考资料部分中下载 Jxta shell 分发包（请选择一个稳定版本）。</p>

<p><strong>安装 Jxta shell</strong><br />
在您的机器上安装 Jxta，至少到 29i 版（正在编写的当前版本）为止，在多数家用和办公系统上是很不容易的。主要的困难是源于 Jxta
与防火墙代理和事实上标准的家用网络 NAT 路由器之间的工作方式。要在因特网之外与其它对等节点进行交互，您必须根据 Jxta
安装文档进行详细配置。然而，就本文来说，我们无须连接到我们的本地网之外，就可以试验
Jxta。只要安装该分发包并执行本文的指导就行了。在本系列的下一篇即最后一篇论文中，我们将讨论如何为因特网配置我们的 Jxta 系统。</p>

<hr />

<p>安装 Jxta<br />
请按照下列步骤安装进行本文试验所需的环境：</p>

<ol>
<li><p>下载 本文的分发源代码并将它解压到您选定的目录。在本文所有地方，我们都将称这个目录为 CODEROOT。</p></li>

<li><p>解压缩 Jxta shell 的二进制分发文件（jxtashell.zip）到同一个 CODEROOT 目录。</p></li>

<li><p>检查 CODEROOT 下的 lib 目录，确保其中已经包含 jxta.jar 和 jxtashell.jar。</p></li>

<li><p>进入 CODEROOT 下的 shell 目录并运行 runshell.bat 文件（包含在本文的分发代码中）。这将启动图 1 所示的 GUI 配置实用程序。</p></li>

<li><p>请在 GUI 配置实用程序的 peer name（对等机名）处输入 node1。确保选上 TCP 传输部分而且您所输入的主机名或 IP 地址须是机器的有效本地地址。同时确保您已经把本节点的 TCP 端口号指定为 9700。所有这些都显示在如下的图 1 中。</p></li>

<li><p>禁用 HTTP 传输，为此请不复选相应的复选框。HTTP 传输用于与防火墙之外的对等机进行通信（通过集中服务（rendezvous service））；我们不需要它。</p></li>

<li><p>单击 OK 按钮启动 Jxta shell 的一个实例。</p></li>
</ol>

<p><strong>图 1. Jxta GUI 配置实用程序</strong></p>

<p>剖析对等机<br />
是进行一些试验的时候了。跟 UNIX shell 中的情形一样，Jxta shell 的命令也与环境变量交互。要找出对等机的更多信息，试一下以下命令：</p>

<pre><code>JXTA&gt;whoami
</code></pre>

<hr />

<p>您的输出将是一个语法上类似于 XML 的结构化文档。</p>

<pre><code>node1
Netpeer group by default

jxta://59616261646162614A78746150325033DB1EB6636DCE4B2990CA888B36CD96C7000
  0000000000000000000000000000000000000000000000000000000000301

tcp://169.254.101.152:9700/
</code></pre>

<hr />

<p>这里，我们可以看到本地对等机名 <code>node1</code> 与一个很长的对等机 ID（包在 <code>元素中）相对应。请注意我们已经在一个名称为 `Netpeer`
的缺省对等组中。通达本对等机的传输地址包在</code> 元素中。如果我们没有特地修改过 shell 配置，那么 shell
引导机制将把我们放到缺省对等组中。事实上，我们可以通过以下命令更多地了解这个缺省组：</p>

<pre><code>JXTA&gt;whoami -g
</code></pre>

<hr />

<p>这个 <code>whoami</code> 命令的变体，使用 <code>-g</code> 开关，将检查我们当前是其中成员的组并将获得更多该组的信息。我们的输出看起来可能像这样：</p>

<pre><code>Netpeer group
Netpeer group by default

jxta://59616261646162614A757874614D504700000000000000000000000000000000000
  0000000000000000000000000000000000000000000000000000000000201

jxta.service.discovery
jxta.service.pipe
jxta.service.resolver
jxta.service.rendezvous
jxta.service.peerinfo
jxta.service.membership
</code></pre>

<hr />

<p>这就是缺省 <code>Netpeer</code> 组。请注意表中列出的所有可用核心对等组服务；每个服务都被包在 `` 标记中。</p>

<p>P2P 基础通信<br />
在对等机开机、运行并且是 <code>Netpeer</code> 组的成员的情况下，我们现在可以尝试进行一些 P2P Jxta 通信。我们将：</p>

<ol>
<li>创建一个管道</li>
<li>创建一条消息</li>
<li>通过管道把消息发送到另一个对等机</li>
</ol>

<p>为使用 Jxta shell 上可用的命令，我们须将上述任务分解为如下步骤：</p>

<ol>
<li>创建一条管道广告。</li>
<li>创建一条基于该广告的管道。</li>
<li>启动一个新的 shell 实例。</li>
<li>在新 shell 上，创建一条基于该广告的输出管道。</li>
<li>在新 shell 上，创建一条消息。</li>
<li>在新 shell 上，附加一个文件到该消息上。</li>
<li>阻塞老 shell，等待来自输入管道的消息。</li>
<li>在新 shell 上，发送该消息。</li>
</ol>

<p>现在，让我们一步一步地完成这个过程，并分析我们将用到的所有 shell 命令。我们将在这个过程中熟悉几乎所有当前可用的 shell 命令。</p>

<p>创建一条管道广告<br />
我们可以用如下的 shell 命令创建一条管道广告并将它指定给名为 <code>dwAdv</code> 的环境变量：</p>

<pre><code>JXTA&gt;dwAdv = mkadv -p
</code></pre>

<hr />

<p><code>mkadv</code> 命令用于为对等组或管道创建广告。（在这个案例中， <code>-p</code> 开关表示这是一条管道广告。）在 Jxta 的当前发展阶段上， <code>-t</code>
开关尚不能用，我们将用它来指定管道类型。最终您将可以用这个命令创建不同类型的管道广告（例如，广播管道广告，对等管道广告，等等；请参阅
本系列的第一部分获取更多详细信息）。</p>

<p>我们可以用如下命令看到 <code>mkadv</code> 的效果：</p>

<pre><code>JXTA&gt;env
</code></pre>

<hr />

<p><code>env</code> 列出所有环境变量。您将看到环境变量 <code>dwAdv</code> 现在已经被设置：</p>

<pre><code>dwAdv = PipeService Advertisement (class net.jxta.impl.protocol.PipeAdv)
</code></pre>

<hr />

<p>创建一条基于该广告的输入管道<br />
现在我们将创建一条与名为 <code>dwinpipe</code> 的环境变量联系在一起的输入管道：</p>

<pre><code>JXTA&gt;dwinpipe = mkpipe -i dwAdv
</code></pre>

<hr />

<p><code>-i</code> 开关表示输入管道， <code>dwAdv</code> 则是我们前面创建的管道广告。</p>

<p>用 <code>env</code> 命令将可以看到 <code>dwinpipe</code> 现在已经与该输入管道联系在一起：</p>

<pre><code>dwinpipe = InputPipe of dwAdv (class net.jxta.impl.pipe.InputPipeImpl)
</code></pre>

<hr />

<p>启动一个新 shell<br />
您可以用以下命令生成一个新的、带有当前环境变量的 shell 实例：</p>

<pre><code>JXTA&gt;Shell -s
</code></pre>

<hr />

<p><code>-s</code> 开关在一个新窗口中创建一个新的、继承老 shell 的所有环境变量的 shell。如果我们未使用 <code>-s</code> 开关，那么新 shell
的创建仍将继承所有环境变量，但它将被“嵌套”或“堆”在同一个窗口中现有 shell 上。没有新窗口会被显示，并且您将不能访问老 shell，直到您退出新
shell 为止。</p>

<p>在我们的示例中，请记住在两个 shell 实例中我们将处理同一个对等机。在本文的后一部分中，我们将与多个对等机一起工作。</p>

<p>创建一条输出管道<br />
在新近创建的 shell 实例中，我们可以创建一个与 <code>dwAdv</code> 广告联系在一起的输出管道。用到的命令是：</p>

<pre><code>JXTA&gt;dwoutpipe = mkpipe -o dwAdv
</code></pre>

<hr />

<p>这条新的、可通过环境变量 <code>dwoutpipe</code> 访问的管道将与我们前面创建的那条输入管道联系在一起，因为它们俩都基于同一条广告（ <code>dwAdv</code>
）。如果要用这条管道来连接两台不同的对等机，我们就须为这条管道 <em>做广告</em> ，这是我们将在以后讨论的主题。</p>

<p>创建一条消息<br />
我们现在要创建一条能通过该管道发送的消息。为此，我们首先创建一条与环境变量 <code>dwMsg</code> 联系在一起的空消息。</p>

<pre><code>JXTA&gt;dwMsg = mkmsg
</code></pre>

<hr />

<p>附加一个文件到该消息<br />
导入名为 <code>simple.txt</code> 的文本文件（在 <code>shell</code> 目录，它包含在 参考资料中提供的源代码中），并用如下命令把它与名为 dwData
的环境变量联系起来：</p>

<pre><code>JXTA&gt;importfile -f  simple.txt dwData
</code></pre>

<hr />

<p><code>-f</code> 开关是必须的。它表示紧接在后面的是一个文件名；这个用法跟 UNIX 的 <code>tar</code> 命令相似。省略它将导致未定义的行为，包括异常！</p>

<p>现在，将导入的文件作为一个标记值（与名为 <code>dwTag</code>
的标记联系在一起）附加到消息上。从概念上说，我们是在把属性附加到消息对象中。属性将与消息一起通过管道传送并可在另一端将它拆离。在下层，一个额外的 XML
片段被插入到结构化文档（消息）中，它包含附加文档，并以标记值命名；相关的报头也被修改以反映新的、更大的大小。用 <code>put</code>
命令就可以完成这一切。稍后，可以用 <code>get</code> 命令从消息中抽取相同的标记值， <code>get</code> 命令通过逆向进行上述过程找回所导入的文件。</p>

<p>为把标记值作为一个属性进行附加，我们用 <code>put</code> 命令：</p>

<pre><code>JXTA&gt;put dwMsg dwTag dwData
</code></pre>

<hr />

<p>这个命令将通过 <code>dwTag</code> 把文本文件添加到消息正文中。</p>

<p>准备接收消息<br />
在老的 shell 实例上，用以下命令开启在输入管道上阻塞着的接收：</p>

<pre><code>JXTA&gt;dwNewMsg = recv dwinpipe
</code></pre>

<hr />

<p>这个命令将设置 shell 以等待消息并把环境变量 <code>dwNewMsg</code> 与任何通过管道收到的进入消息联系起来。</p>

<p>通过管道发送该消息<br />
回到新 shell 实例中，现在我们可以用这个命令通过管道发送带有附加文件的消息：</p>

<pre><code>JXTA&gt;send dwoutpipe dwMsg
</code></pre>

<hr />

<p>验证消息和文件收据<br />
在接收器处于阻塞状态的老 shell 实例中，我们将看到：</p>

<pre><code>JXTA&gt;dwNewMsg = recv dwinpipe
recv has received a message
</code></pre>

<hr />

<p>现在，试一下 <code>env</code> 并请注意环境变量 <code>dwNewMsg</code> 现在已经与接收到的消息联系在一起。</p>

<pre><code>dwNewMsg = Message from  dwinpipe (class net.jxta.impl.endpoint.MessageImpl)
</code></pre>

<hr />

<p>事实上，我们可以用 <code>dwTag</code> 标记容易地从管道中抽取文件。用 <code>get</code> 命令使文件与环境变量 <code>dwNewFile</code> 联系在一起：</p>

<pre><code>JXTA&gt;dwNewFile = get dwNewMsg dwTag
</code></pre>

<hr />

<p>为查看传输文件的内容，我们可以使用如下命令：</p>

<pre><code>JXTA&gt;cat dwNewFile
</code></pre>

<hr />

<p>文件内容将作为一个 XML 文档显示：</p>

<pre><code>          This is a simple file for Jxta transfer. It can contain anything.
</code></pre>

<hr />

<p>要把消息保存到名为 received.txt 的文件，请用这个命令：</p>

<pre><code>JXTA&gt;exportfile -f received.txt dwNewFile
</code></pre>

<hr />

<p>这将把文件保存在 shell 最初从中启动的目录。 <code>-f</code> 开关仍表示后面所跟的是一个文件名。</p>

<p>在两个独立的对等机之间建立管道<br />
既然我们已经通过管道实际传输了一个文件，那就让我们把 Jxta 系统的一些独有特征重新整理一下：</p>

<ul>
<li>管道用它的广告唯一标识，广告是嵌入在 XML 文档中的一个标识符。</li>
<li>创建管道广告的时候并没有生成物理管道或连接；管道虽然存在但并未绑定到任何端点。</li>
<li>您可以在创建广告之后的任何时候独立地把输入和输出管道绑定到端点。</li>
<li>端点之间数据的实际传输通常由对等组内的下层管道服务协调。</li>
</ul>

<p>我们上面的示例只使用一个对等机或端点。我们可以容易地将它修改成能使用同一个缺省对等组内的两台对等机。为此，您可以按如下所述在同一台机器上安装 Jxta
shell 的另一个对等机实例，或者也可以在同一个局域网的两台独立机器上启动 Jxta shell。</p>

<p><strong>GUI 配置实用程序</strong><br />
GUI 配置实用程序只在您第一次启动一个 shell 实例时出现。此后，配置信息被存储在磁盘上并可被重用。这就是为什么我们要创建 shell 和
shell2 目录的原因 ― 包含配置数据的两套设置。如果您想再经历一遍配置过程，您可以在 <em>下次</em> 启动 shell 实例时， <em>当您在 Jxta
shell 中的时候</em> 输入 <code>peerconfig</code> 命令来启动 GUI 配置实用程序。</p>

<hr />

<p><strong>在同一台机器上安装两台独立的对等机</strong> 为模拟有两个节点的 P2P
网络，我们将在我们安装第一台对等机的同一台机器上安装第二台独立的对等机。有了这个安装，我们将不必在网络的几台机器之间来回奔波就可以工作。顺利进行这项工作的关键是把平台上的各个实例设置成在不同的
TCP 端口上运行。为此，您可以采取这些步骤：</p>

<ol>
<li>进入 CODEROOT 目录下的 shell2 目录。</li>
<li>运行 runshell.bat 文件启动 shell。</li>

<li><p>这样，Jxta GUI 配置实用程序将被启动。把 TCP 端口改成 9701（回想一下，另一个 shell 实例，即对等机 <code>node1</code> 是在端口 9700），并输入一个新的对等机名（本示例用的是 <code>node2</code> ）。</p></li>

<li><p>禁用 HTTP 传输协议（不复选相应的框）并完成配置。</p></li>
</ol>

<p>上述过程将启动一台独立的对等机，这台对等机虽然与 node1 在同一台机器上运行，但 TCP
端口是不同的。现在我们可以创建管道并在两台独立的对等机之间发送消息。从本质上说，我们可以把我们在前面的单个对等机的案例中所做的所有事情再做一遍 ―
但这次，我们将在新的对等机实例而不是第二个 shell 实例上做这些事情。</p>

<p>为方便起见，我们将把创建输入管道实例的对等机用它的对等机名 — node1 来称呼它 — 新的对等机实例则称为 node2。在 node1
上创建了输入管道之后，您必须使它的广告对 node2 可见。在独立的对等机之间，环境变量不自动共享；对同一台机器上的独立 shell
实例和连接在一个网络上的不同机器上的对等机而言，情况也是如此。要在对等组内发布广告，请使用 <code>share</code> 命令：</p>

<pre><code>JXTA&gt;share dwAdv
</code></pre>

<hr />

<p>要在 node2 上查看广告，您必须执行远程 <code>search</code> ：</p>

<pre><code>JXTA&gt;search -r
</code></pre>

<hr />

<p><code>-r</code> 开关表示该命令将搜索同一对等组内的远程对等机所发布的广告。记住，“远程”对等机可以是运行在同一台机器上的一个独立的 shell 实例。</p>

<p>接着，再次输入如下命令：</p>

<pre><code>JXTA&gt;search
</code></pre>

<hr />

<p>这个动作将轮询任何新近被发现的广告。最后您将在 node2 上看到一些类似这样的东西：</p>

<pre><code>JXTA&gt;search
JXTA Advertisement adv0 
</code></pre>

<hr />

<p>shell 将为每个被发现的广告指定一个名为 <code>adv _n_</code>的环境变量，其中 <em>n</em> 从 0 开始。在我们的示例中，shell 把变量 <code>adv0</code>
指定给新近被发现的广告。</p>

<p>现在您可以用 <code>adv0</code> 这个共享广告来建立输出管道：</p>

<pre><code>JXTA&gt;dwoutpipe = mkpipe -o adv0
</code></pre>

<hr />

<p>上面讨论了安装两台对等机的必要步骤；剩下的全部步骤跟单个对等机的案例中的步骤一样。用管道在一个对等组的对等机之间容易地交换文件、数据和代码是可能的。</p>

<p>扩展 shell：一个简单示例<br />
Jxta shell 被设计成用户可以容易地对它进行扩展的。这意味着您可以往 shell 添加定制命令。因为 Jxta shell 的参考实现是用 Java
语言实现的，所以动态类装入意味着可以动态地添加 Jxta shell 扩展，而不用重新编译 shell。这还意味着不同的用户可以使用同一个基础 shell
二进制文件，但却保留他们自己喜欢的扩展设置。事实上，要编写一个扩展，您甚至不必访问 Jxta shell
的源代码。说明这种令人惊奇的可扩展性的最好办法是举一个小的例子。我们打算往 shell 添加一个名为 <code>dwcmd</code> （ <em>developerWorks
command</em> 的缩写）的命令。执行 <code>dwcmd</code> 时只是打印一个文本字符串：</p>

<pre><code>JXTA&gt;dwcmd
This is a trivial Jxta shell extension.
</code></pre>

<hr />

<p>这里是 <code>dwcmd</code> 扩展的源代码（它很简单）：</p>

<pre><code>package net.jxta.impl.shell.bin.dwcmd;
import net.jxta.impl.shell.*;
public class dwcmd extends ShellApp {
  public dwcmd() {
  }

  public int startApp (String[] args) {
     println (&quot;This is a trivial Jxta shell extension.&quot;);
     return ShellApp.appNoError; 
  }

  public void stopApp () {
  }

}
</code></pre>

<hr />

<p>我们可以看到：</p>

<ul>
<li>扩展继承了 <code>net.jxta.impl.shell.ShellApp</code> 类。</li>
<li>它必须实现 <code>StartApp()</code> 和 <code>stopApp()</code> 方法。</li>
<li>它是 <code>net.jxta.impl.shell.bin</code> 包的一部分。</li>
</ul>

<p>所有 shell 扩展都按照这种模式。当从 shell 命令行调用该命令时， <code>StartApp()</code> 方法被调用，而当退出 shell 时，
<code>StopApp()</code> 方法被调用。</p>

<p>编译并配置 shell 扩展<br />
为成功编译dwcmd.java 文件，当要调用编译器时，我们必须把 jxtashell.jar 添加到 classpath 中。这一步使得 Java
编译器对 Jxta 核心类和 shell 扩展代码所使用的特定于 Jxta shell 的库类都能进行处理。code 目录已经提供了
<code>makeit.bat</code> 文件；文件内容如下：</p>

<pre><code>set CODEROOT=..
javac -classpath 
%CODEROOT%/lib/jxta.jar;%CODEROOT%/lib/jxtashell.jar 
  -d %CODEROOT%/dwclasses net/jxta/impl/shell/bin/dwcmd/*.java
</code></pre>

<hr />

<p>请注意 <code>dwcmd</code> 命令是 <code>net.jxta.impl.shell.bin</code> 包的一部分。事实上，所有 shell 命令都是以这种方式配置的。这是
Jxta shell 找到命令的方式（使用内省）。这也正是在运行期间动态地把扩展添加到 shell 中，而不要求重新编译 shell 本身的机制。</p>

<p>我们的 makeit.bat 编译过程把输出的类文件（classfiles）放在名为 dwclasses 的目录中。我们必须把这个目录添加到我们所运行的
shell 实例的 classpath 中。这在运行时把 shell 扩展类和 Jxta shell 实现类有效地合并在了一起。如果您看一下 shell
目录中的 runshell.bat 文件，那么您将可以看到 classpath 中包含了它：</p>

<pre><code>java -classpath 
../lib/jxta.jar;../lib/jxtashell.jar;../lib/log4j.jar;../dwclasses 
  net.jxta.impl.peergroup.Boot
</code></pre>

<hr />

<p>这里，我们已经把 ../dwclasses 目录添加到了运行 shell 的 VM 的 classpath 中。这把我们的
<code>net.jxta.impl.shell.bin.dwcmd</code> 包和 jxtashell.jar 中的其它 shell 命令有效地合并在了一起。图 2
说明了这些命令合并的工作机制。</p>

<p><strong>图 2. 把定制命令 dwcmd 添加到 shell</strong></p>

<p>现在如果您在 shell 目录中启动一个新的 shell 实例（用 runshell.bat），那么您将可以在该 shell 内访问新的 <code>dwcmd</code>
命令。亲自试试!</p>

<p>编写一个复杂的 shell 扩展<br />
既然我们已经熟悉创建 shell 扩展的基础知识，那我们就能够编写一个更复杂的、实际能执行有用的 Jxta 工作的扩展。事实上，我们将创建一个能做以下工作的
shell 扩展：</p>

<ol>
<li>创建一条管道广告</li>
<li>创建一条基于该广告的输入管道</li>
<li>在组内共享该广告</li>
<li>在输入管道上等待消息</li>
<li>从消息中抽取所附加的文本文件</li>
<li>打印出该文本文件的内容</li>
</ol>

<p>这与我们前面在 node1 上使用 shell 命令和 shell 变量时的顺序是一样的。现在，在扩展的帮助下，我们用一个定制命令就可以完成一切事情。</p>

<p>新的命令将被称为 <code>waitptext</code> （ <em>wait pipe text</em> 的缩写）。您可以在子树 <code>net.jxta.impl.shell.bin</code>
（所有 shell 命令都必须位于此处）下找到它的源代码。看看下面 <code>waitptext.java</code> 的导入清单以了解我们须导入的各个 Jxta 平台包。</p>

<pre><code>package net.jxta.impl.shell.bin.waitptext;
...
import net.jxta.pipe.*;
import net.jxta.endpoint.*;
import net.jxta.discovery.*;
import net.jxta.document.*;
import net.jxta.protocol.*;
</code></pre>

<hr />

<p>这里是所包含的包及其功能的概略介绍：</p>

<table>
<thead>
<tr>
<th><strong>包</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>net.jxta.pipe</code></td>
<td>包含用于管道实现 <code>InputPipe</code> 和 <code>Pipe</code> 接口</td>
</tr>

<tr>
<td><code>net.jxta.endpoint</code></td>
<td>包含用于消息实现的 <code>Message</code> 接口</td>
</tr>

<tr>
<td><code>net.jxta.document</code></td>
<td>包含用于结构化文档的一个类工厂（class factory）和一些接口，例如用在 Jxta 消息和广告中的</td>
</tr>
</tbody>
</table>

<p>XML 文档（适用于 Jxta 的参考实现）<br />
<code>net.jxta.protocol</code> | 包含用于管道广告实现的 <code>PipeAdvertisement</code> 接口；还包含一个用于创建新管道广告的类工厂<br />
<code>net.jxta.protocol</code> | 包含使用 Jxta 协议的类和接口</p>

<p>在类 <code>waitptext</code> 中，我们定义了将要使用的 Jxta
对象类型（广告、管道、消息和结构化文档等等）的私有（private）实例。在命令行上，一切都被指定为 shell 变量；在 Jxta
中，我们必须更具体地说明类型。</p>

<pre><code>public class waitptext extends ShellApp {

  private PipeAdvertisement myPipeAdv = null;
  private InputPipe myInpPipe = null;
  private Message myMesg = null;
  private InputStream myInpStream = null;
  private StructuredDocument myStructDoc = null;
  private Discovery myDiscovery = null;
  private PeerGroup myGroup;
</code></pre>

<hr />

<p><code>waitptext.java</code> 中最重要的方法是 <code>startApp()</code>
，命令的大部分工作都在这里完成。在这个案例中，我们把参数传递到命令中。这个参数是结构化文档标记的名称（在我们前面的示例中是 <code>dwTag</code>
），它就是我们为拆离随消息一起发送的文本文档所要找的。我们判断用户是否为消息标记名指定了参数；如果没有，我们就使用缺省值（预先设置为 <code>tmpTag</code> ）：</p>

<pre><code>private String tagName = &quot;tmpTag&quot;;
public int startApp (String[] args) {
  if (args.length != 0)
    tagName = args[0];
</code></pre>

<hr />

<p>创建一条管道广告<br />
我们用 <code>AdvertisementFactory</code> 静态类来创建管道广告，它是 <code>net.jxta.document</code>
包的一部分（因为广告是一个结构化文档）。您可以从本系列的 第 1 部分中回想起每条广告都有一个唯一的 ID；这里，我们通过创建一个新的 <code>PipeID</code>
实例来创建 ID。我们把当前组的 ID 作为参数传进去以构造 <code>PipeID</code> ，因为每个 <code>PipeID</code> 都包含它从中被创建的对等组的 ID。UUID
生成算法是内部平台核心库的一部分，并且新的 <code>PipeID()</code> 实现将在内部调用它。 <code>PipeID</code> 实际上包含一个嵌入的组
ID，因为管道总是属于一个对等组。它实际上是两个 UUID 的组合 ― 这就是为什么在构造 <code>PipeID</code> 期间要把组 ID 传进去的原因。请注意
<code>group</code> 是一个对每一个 shell 应用（包括 shell 的当前对等组）都可用的受保护（protected）变量。</p>

<pre><code>  try {
         myPipeAdv = (PipeAdvertisement) AdvertisementFactory.newAdvertisement(
                     PipeAdvertisement.getAdvertisementType());
         myPipeAdv.setPipeID( new PipeID(group.getID()) );
       } catch (Exception e) {
         e.printStackTrace();
         return ShellApp.appMiscError;
       }
      if (myPipeAdv == null) {
         println(&quot;waitptext: Cannot create a Pipe Advertisement&quot;);
         return ShellApp.appMiscError;
     }
     println(&quot;created a pipe advertisement...&quot;);
</code></pre>

<hr />

<p>创建一条输入管道<br />
创建了管道广告之后，我们必须创建一条基于该广告的输入管道。通过使用 <code>net.jxta.pipe.Pipe</code> 接口完成这项任务。这里，我们使用从
<code>ShellApp</code> 继承来的受保护 <code>pipes</code> 变量； <code>pipes</code> 总是包含 shell 的缺省组的缺省管道服务。</p>

<pre><code>       try {
           myInpPipe = pipes.createInputPipe (myPipeAdv);
          } catch (IOException e) {
           println(&quot;waitptext: Cannot create a Pipe&quot;);
           return ShellApp.appMiscError;
       }
       println(&quot;created an input pipe based on the advertisement...&quot;);
</code></pre>

<hr />

<p>发布管道广告<br />
现在我们须使该管道广告对组内的其它对等机可见。我们将使用原始的 Jxta 发现协议来发布该广告。在一个 P2P
应用产品中，当然，我们可以使用其它方式（也就是说，其它服务）传播广告。</p>

<pre><code>     try {
             myDiscovery = group.getDiscovery();
             myDiscovery.publish(myPipeAdv, Discovery.ADV);
     } catch( Exception e ) {
             println(&quot;waitptext: publish of pipe advertisement failed&quot;);
             return ShellApp.appMiscError;
     }
       println(&quot;published the pipe advertisement to the group...&quot;);
</code></pre>

<hr />

<p>等待输入消息<br />
使该广告可用之后，我们在该输入管道上阻塞，以等待传进来的消息。通过使用 <code>Pipe</code> 实例的 <code>poll()</code> 方法完成这项任务。timeout（超时）值为
0 表示我们将无限期地等待传入的消息。</p>

<pre><code>           println(&quot;waiting at the input pipe for a message...&quot;);

    try {

         myMesg = myInpPipe.poll(0);
    } catch (IOException e) {
     return ShellApp.appNoError;
    }
</code></pre>

<hr />

<p>抽取并打印附加文件<br />
如果代码执行到了这一步，我们将已经接收到一条消息。然后我们根据用户指定的数据标记创建一个结构化文档并把这个结构化文档的文本内容打印到命令窗口。</p>

<pre><code>    try {
        myInpStream = myMesg.pop (tagName);
println(&quot;tagName used is &quot; + tagName);
        myStructDoc =  StructuredDocumentFactory.newStructuredDocument (
               new MimeMediaType (&quot;text/xml&quot;),
               myInpStream);
        OutputStream out = new ByteArrayOutputStream();

        myStructDoc.sendToStream( out );
        println(&quot;received a message...&quot;);
        print ( out.toString() );
     } catch (Exception e) {
         println(&quot;waitptext: failed in messge receive&quot;);
         return ShellApp.appMiscError;
     }
      return ShellApp.appNoError;
 }
</code></pre>

<hr />

<p>这就是 <code>waitptext</code> 的全部！现在您可以用 makeit.bat 编译这个新命令。</p>

<p>测试 waitptext 命令<br />
启动 node1（在 shell 目录）和 node2（在 shell2 目录）上的 shell 实例。在两个实例中都输入如下命令：</p>

<pre><code>jxta&gt; search -f
</code></pre>

<hr />

<p>这将刷新所有现有的活动广告。因为 Jxta 节点应该免于重启，广告在缺省状态下是持久的。使用 <code>search -f</code>
将确保我们不会有从前面的试验中遗留下来的广告。</p>

<p>现在我们可以在 node1 上输入我们的新命令。您应该看到以下输出：</p>

<pre><code>JXTA&gt;waitptext dwTag
created a pipe advertisement...
created an input pipe based on the advertisement...
published the pipe advertisement to the group...
waiting at the input pipe for a message...
</code></pre>

<hr />

<p>此时，shell 实例正在等待传入的消息，</p>

<p>在 node2 实例上，重复我们在前面的 shell 试验中采用的步骤以：</p>

<ol>
<li>查找发布的管道广告（ <code>search -r</code> ）</li>
<li>生成一条基于该广告的输出管道（ <code>dwoutpipe = mkpipe -o adv0</code> ）</li>
<li>创建一条消息（ <code>dwMsg = mkmsg</code> ）</li>
<li>把文本文件装入到一个数据变量中（ <code>importfile -f simple.txt dwData</code> ）</li>
<li>把文本文件作为一个名为 <code>dwTag</code> 的元素附加上去（ <code>put dwMsg dwTag dwData</code> ）</li>
<li>通过管道发送消息（ <code>send dwMsg dwoutpipe</code> ）</li>
</ol>

<p>回到 node1，我们应该看到发送文件的内容：</p>

<pre><code>tagName used is dwTag
received a message...



          This is a simple file for Jxta transfer. It can contain anything.


JXTA&gt;
</code></pre>

<hr />

<p>我们已经完成了一个复杂的 shell 扩展的创建，并且揭示了如何用 Jxta 平台的功能创建 shell 扩展。</p>

<p>谈谈互操作性</p>

<p>因为我们的所有示例都基于 Java 平台，一些读者或许会怀疑 Jxta 的编程语言／平台的中立性，它是我们在
本系列的第一篇论文强调的一个特征。但请记住，我们在这里用的是 Jxta 核心的 Java 实现（Jxta 的参考实现）。另外，请考虑到 Jxta shell
实际上是在 Jxta 核心上工作的、基于 Java 的 Jxta 应用，并且您可以看到我们拥有的是一个完全以 Java 为中心的环境。但平台和 shell
的其它实现也都是可能的。</p>

<p>事实上，做实际工作的协议交互动作是完全可互操作的。例如：要加入一个对等组，我们须用 Jxta 对等成员资格（Jxta Peer
Membership）协议来联系成员资格对等组服务。要和一个管道沟通，我们必须用 Jxta 管道绑定（Jxta Pipe
Binding）协议来联系管道服务。要共享一个广告，我们必须用 Jxta 发现（Jxta Discovery）协议在对等组上发布它。假设根据 Jxta
协议规范中描述的基础协议来实现，那么您就可以在另一个平台上构建一个能与我们的 Jxta shell 应用容易地相互操作的 Jxta 和 Jxta shell
的实现。（要了解更多协议，请参阅 本系列的第一篇论文。）</p>

<p>下一步：延伸到网络<br />
Jxta shell 是试验和学习 P2P 基本原理的重要工具。它简单而优秀的可扩展性使我们可以容易地添加新功能。在本文中，我们已经广泛使用了 shell
的命令行，并粗略地创建了我们自己的复杂的 shell 扩展。</p>

<p>我们大部分时候只在同一个局域网内的一个对等组内的机器上工作。（事实上，我们基本上都在一台机器上工作）。回想一下本系列的第一篇论文，可以看到 Jxta
对等组的边界不受底层的物理网络拓扑结构的限制。在本系列的最后一篇论文中，我们将直接看看 Jxta
发现如何能够扩展到广域网（通过路由器）和越过因特网上的防火墙（通过集中服务（rendezvous service））。</p>

<p>参考资料</p>

<ul>
<li><p>您可以参阅本文在 developerWorks 全球站点上的 英文原文.</p></li>

<li><p>参加本文 讨论论坛。</p></li>

<li><p>本系列的 第 1 部分概述了 Jxta 工程和这种新技术如何能在不硬性规定不必要的规则或具体的应用操作模型的情况下简化 P2P 应用的设计。</p></li>

<li><p>下载本文的 源代码。</p></li>

<li><p>请访问 Jxta 社区的官方站点 Jxta.org，您可在这里找到最新的规范、文档、源代码和二进制文件。</p></li>

<li><p>如果您对基于 Jini 的技术的更多详细信息感兴趣，请参阅 Sing Li 的 <em>Professional Jini这本书</em> （Wrox Press，2000）。</p></li>

<li><p>另一个早期采用者 对等工作组已经建立。这个组的战略会是什么，它与 Jxta 的关系又会是什么，这一点还不清楚。</p></li>

<li><p>Todd Sundsted 的位于 developerWorks 的 <em>对等计算</em> 专栏讨论基于 P2P 的技术的所有方面。</p></li>

<li><p>要了解一个可与之替换的开放源代码的 P2P 系统，请查看 Freenet工程。</p></li>

<li><p>来自 IBM 的 高级对等连网（Advanced Peer-to-Peer Networking，APPN）提供了强伸缩性、高可用性、安全的网络解决方案。</p></li>

<li><p>IBM 的 Magstar Peer-to-Peer Virtual Tape Server被设计用来提高数据的可用性及改善您的灾难恢复的基础构造。</p></li>

<li><p>在 developerWorks Java 技术专区可找到更多的 Java 参考资料。</p></li>
</ul>

<p>关于作者<br />
Sing Li 是 <em>Professional Jini</em> 的作者，也是 Wrox 出版社的其他许多书籍的作者。 他定期为技术杂志投稿，同时还是 P2P</p>

<h2 id="革命的积极推动者-sing-是一位咨询专家和自由撰稿人-可通过-westmakaha-yahoo-com与他联系">革命的积极推动者。Sing 是一位咨询专家和自由撰稿人，可通过 westmakaha@yahoo.com与他联系。</h2>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>