<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux下的Shell编程基础知识 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux下的Shell编程基础知识 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux下的Shell编程基础知识">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E4%B8%8B%E7%9A%84shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux下的Shell编程基础知识</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>shell编程<br />
shell介绍<br />
/etc/shells保存系统支持的shell脚本类型<br />
/etc/passwd里面保存了每个用户的shell设置<br />
#：表示注释<br />
#！表示该脚本使用后面指定的解释器解释执行（必须第一行）</p>

<p>实际上shell会fork一个子进程并调用Exec执行脚本，<br />
实际上就是exec把进程中的原来程序段替换成现在新的程序段，<br />
我们也可以在c语言代码中利用system()函数执行</p>

<p>shell命令执行<br />
(pwd;ls -l)<br />
pwd &amp;&amp; ls -l<br />
pwd || ls -l</p>

<p>shell 变量有全大写字母加下划线组成，有两种类型：<br />
环境变量 本地变量<br />
环境变量 ：printenv<br />
本地变量：只存在于当前shell进程，用set命令可以显<br />
示当前shell进程中定义的所有变量（本地变量和环境变量）<br />
和函数</p>

<p>shell脚本的调试方法<br />
shell提供了 一些用于调试的选项<br />
-n 读一遍脚本中的命令但不执行，用于检查脚本中的<br />
语法错误<br />
-v 一边执行脚本，一遍2将执行过的脚本命令打印到标准错误输出<br />
-x 提供跟踪执行信息，将执行的每一条命令和结果一次打印出来<br />
sh -x ./test.sh</p>

<p>shell脚本命令<br />
bash的内部命令与外部命令<br />
exit :终止当前的shell命令<br />
export:设置一个环境变量，<br />
当前shell的所有子进程都可以访问这个<br />
环境变量<br />
kill: 终止某个进程的执行</p>

<p>命令通配符<br />
*：匹配任何字符和字符串，包括空字符串<br />
?: 匹配任意一个字符。例如 ？abc 匹配任何一abc结尾或以任意<br />
一个字符开头<br />
[&hellip;]匹配括号里列出的任何单字符 比如 abc[def]，可以匹配一abc<br />
开头，以def中任意一个字符结尾的字符串</p>

<p>使用命令的历史记录<br />
history 命令可以显示出命令的记录列表<br />
history [n]<br />
参数n是一个可选的整数。当没有参数时，会列出以前执行过的所有<br />
命令，有参数n时，会列出最后执行的n个命令<br />
history 5<br />
这个命令显示最后执行的5个命令操作列表</p>

<p>命令的别名<br />
给命令去个别名来代替命令的使用<br />
alias list=&lsquo;ls -l&rsquo; 定义一个文件列表的别名<br />
如果想取消别名<br />
unalias list 取消别名</p>

<p>环境变量<br />
环境变量是在一个用户的所有进程中都可以访问的变量。系统<br />
中常常使用环境变量来存储常用的信息</p>

<p>环境变量查看 export<br />
环境变量访问 echo $SSH_ASKPASS<br />
环境变量定义 export xx=1234<br />
在系统配置文件中定义环境变量<br />
环境变量的系统配置文件是/etc/profile<br />
gedit /etc/profile</p>

<p>位置变量<br />
位置变量指的是shell程序在运行时传入的参数。<br />
程序中可以用变量的形式<br />
来调用这些参数。这些参数存放到1-9的9个变量名中，<br />
被称为位置变量，<br />
同普通变量一样，位置变量用$前缀加这个数字表示<br />
$1,$2&hellip;..$9 脚本程序的参数<br />
$* 一个全体参数组成的清单，这是一个单独<br />
的变量，使用环境变量IFS中的第一个字<br />
符分隔开<br />
$@ “$*”一种，它不使用IFS环境变量</p>

<p>数**算<br />
算术运算<br />
+：两个变量相加<br />
-：两个变量相减<br />
*：两个变量相乘<br />
/：两个变量相除<br />
<strong>：两个变量的幂运算<br />
%：取模运算<br />
+=：加等于<br />
-=：减等于<br />
/=：除等于<br />
%=：取模等于<br />
shell中有三中方法可以更改运算顺序<br />
1.用expr改变运算的顺序。可以用echo <code>expr 1 + 2</code>来输出1+2的结果<br />
用expr表示后面的表达式为一个数</strong>算，需要注意的是` 并不是<br />
一个但引号，而是tab键上面的那个符号<br />
2.用let指示数<strong>算。可以先将运算的结果赋值个变量b，<br />
运算命令是<br />
b=let 1+2 ，然后用 echo $b来输出b的值，<br />
如果没有let 则会输出<br />
1+2<br />
3.用$[]表示数</strong>算，将一个数<strong>算写到$[]符号的中括号中，<br />
中括号中的内容将先进行数</strong>算，例如命令 echo $[1+2]</p>

<p>echo 命令的输入输出<br />
echo $a 输出变量a的值<br />
echo $a &gt; filename 输出变量a的值到文件filename 中<br />
echo $a &gt;&gt; filename 将变量a的值追加到文件filename 中</p>

<p>echo输出的内容可以有下面的格式控制字符<br />
/c 末尾加上/c 表示这一行输出完毕后不换行<br />
/t 输出一个跳格，相当于按下“tab”键<br />
/n 输出一个换行<br />
需要注意的是，如果在输出特殊的字符，必须加-e选项，否则输出<br />
的结果中会直接输出字符，加-n选项可以禁止echo输出后的换行<br />
echo &ldquo;hello beijing &rdquo; hello beijing<br />
echo &ldquo;hello /nbeijing&rdquo; hello beijing<br />
echo -e &ldquo;hello /nbeijing<br />
hello<br />
beijing<br />
echo lizhanglin lizhanglin<br />
echo li zhanglin 错误的输出，将不会有结果<br />
echo &ldquo;li zhanglin&rdquo; li zhanglin<br />
name=&ldquo;lizhanglin&rdquo;<br />
echo $name lizhanglin<br />
echo &ldquo;$name&rdquo; lizhanglin<br />
echo &lsquo;$name&rsquo; $name<br />
echo /$name $name<br />
a=&ldquo;asd&rsquo;fgh&rsquo;&rdquo;<br />
echo $a asd&rsquo;fgh&rsquo;<br />
read age 读入变量值<br />
20<br />
echo $age 20</p>

<p>read命令读取命令信息<br />
read命令可以从键盘或文件中读入信息，并赋给一个变量。<br />
read读取信息的各种方法如下：<br />
1.如果只读入一个变量，会把键盘上输入的信息赋值个这个变量。<br />
2.如果输入多个变量，用空格键将输入的变量隔开。如果输入变量<br />
的个数多与需要读取变量的个数，将会把剩余的变量赋值个最后一<br />
个变量<br />
3.在读取语句后面添加 &lt; filename，表示从文件中读取数据，并赋值<br />
给变量<br />
read a lizhanglin a=lizhanglin<br />
read a b c li zhang lin a=li b=zhang c=lin<br />
read a b li zhang lin a=li b=zhang lin<br />
vim a.txt li zhanglin<br />
read a b &lt; a.txt a=li b=zhanglin</p>

<p>文件重定向<br />
文件重定向指的是：在执行命令时指定命令的输入，输出和错误<br />
的输出和输入方式。例如可以命令的结果输出到一个文件中<br />
0：标准输入 1：标准输出 2：错误输出<br />
command &gt; filename 把标准输出重定向到一个文件中<br />
command &gt;&gt; filename 把标准输出以追加的方式重定向到一个文件中<br />
command 1 &gt; filename 把标准输出重定向到一个文件中<br />
command &gt; filename 2 &gt;&amp;1 把标准输出和错误输出一起重定向到<br />
一个文件中<br />
command 2 &gt; filename 把标准输出的错误重定向到一个文件中<br />
command 2 &gt;&gt; filename 把标准输出以追加的方式到一个文件中<br />
command &gt;&gt; filename 2 &gt; &amp;1<br />
把标准输出和错误追加到同一个文件中<br />
command &lt; filename &gt; filename2 把command命令以filename输入，<br />
并输出到文件filename2中<br />
command &lt; filename 把command 命令以filename文件作为标准输入</p>

<p>反引号 `<code>
反引号用于执行引号中的系统命令，然后将命令的结果返回  
这个返回的结果可以赋值给一个变量  
echo</code>date<code>12月 10 15:06:08 CST 2007  
a=</code>ls`<br />
echo $a 将输出本目录下的文件清单</p>

<p>测试语句<br />
对变量的大小，字符串，文件属性等内容内容进行判断<br />
test命令可以用于字符串，数字，文件状态等内容的测试<br />
文件状态测试<br />
文件状态测试指的是对文件的权限，有无，属性，类型等内容进行判断<br />
与其他语言不同的是。test命令的测试结果，返回0时表示测试成功<br />
返回1 时表示测试失败<br />
-d 测试文件是否是目录文件<br />
-s 测试文件是否非空<br />
-f 测试文件是否是正规文件<br />
-w 测试文件是否可写<br />
-L 测试文件是否是符号连接<br />
-u 测试文件是否有suid位设置<br />
-x 测试文件是否可执行<br />
-r 测试文件是否可读</p>

<p>test -d /windows 测试文件/window是否是一个目录<br />
输出结果 $?用于保存上一个命令的结果<br />
echo $?<br />
输出的结果1 表明/window不是一个目录</p>

<p>数字测试<br />
数字测试指的是比较两个数值的大小或相等关系<br />
1.test命令 test firstnumber 数值比较 secondnumber<br />
2.用中括号代替test命令。需要注意的是 [ 后面一定要有一个空格<br />
[ firstnumber 数值比较 secondnumber ]<br />
-eq 两个数是否相等<br />
-ne 两个数是否不相等<br />
-le 第一个数是否小于或等于第二个数<br />
-ge 第一个数是否大于或等于第二个数<br />
-gt 第一个数是否大于第二个数<br />
-lt 第一个数是否小于第二个数<br />
如：<br />
test 3 -lt 5 echo $? 0<br />
[ 3 -lt 5 ]</p>

<p>字符串测试<br />
字符串测试指的是比较两个字符串是否相等，或者判断一个字符串<br />
是否为空。判断常用来测试用户输入是否符合程序的要求<br />
字符串测试有下面4种常用的方法<br />
test 字符串 比较符 字符串<br />
test 字符串1 比较符 字符串2<br />
[ 字符串 比较符 字符串 ]<br />
[ 字符串1 比较符 字符串2 ]<br />
字符串比较有如下所示的4种<br />
=测试两个字符串是否相等<br />
!=测试两个字符串是否不相等<br />
-z:测试字符串是空字符串<br />
-n:测试字符串是非空字符串</p>

<p>逻辑测试<br />
逻辑测试指的是将多个条件进行逻辑运算<br />
-a 逻辑与<br />
-o 逻辑或<br />
!: 逻辑否<br />
[ -w a.txt -a -r b.txt ]</p>

<p>流程控制结构<br />
所谓的流程控制指的是使用逻辑判断，针对判断的结果<br />
执行不同的语句或不同的程序部分<br />
条件判断<br />
if语句<br />
1. if 条件<br />
then 命令<br />
fi</p>

<p>2. if 条件<br />
then 命令1<br />
else 命令2<br />
fi</p>

<p>3. if 条件1<br />
then 命令1<br />
elif 条件2<br />
then 命令2<br />
else 命令3<br />
fi</p>

<p>4. if 条件1;then 命令1<br />
elif 条件2;then 命令2<br />
else 命令3<br />
fi</p>

<p>5.case 语句<br />
case结构比我们前面见过的其他语句都稍微复杂些，语法如下<br />
case variable in<br />
pattern ( statements;;<br />
pattern ( statements;;<br />
esac<br />
case语句确实能够使我们通过一种比较深奥的机制把某个变量的内<br />
容与<br />
与多个摸版进行匹配，在根据成功匹配的摸版决定应该执行哪部分<br />
代码<br />
请注意每个摸版行都是以双引号（“；；”）结尾的。前后摸版之<br />
间可以<br />
有任意多余语句，因此这个双分号实际起到了分隔符的作用，<br />
它标志着<br />
前一个语句的结束和后一个，摸版的开始<br />
如：<br />
read timeofday<br />
case “$timeofday” in<br />
y ) echo &ldquo;goodmoring&rdquo;;;<br />
Y ) echo &ldquo;goodmoring&rdquo;;;<br />
n ) echo &ldquo;goodafternoon&rdquo;;;<br />
N ) echo &ldquo;goodafternoon&rdquo;;;<br />
* ) echo &ldquo;goodday&rdquo;;;<br />
esac<br />
*是通配符，可以匹配任何一个输入的字符，最后用到*，是为了<br />
对任何一个输入字符，都有一个处理。<br />
case 是按照顺序，从上到下去匹配执行，没有最优匹配，最容易<br />
匹配的放到最上面。<br />
如：<br />
read timeofday<br />
case &ldquo;$timeofday&rdquo; in<br />
yes | YES | y | Y ( echo &ldquo;goodmoring&rdquo;;;<br />
N | n ( echo &ldquo;goodafternoon&rdquo;;;<br />
* ( echo &ldquo;goodday&rdquo;;;<br />
esac</p>

<p>for语句<br />
1.for 变量名 in 列表<br />
do<br />
命令1<br />
命令2<br />
done<br />
2.当for语句省略后边的in关键字时，将接受输入时的参数作为循环<br />
变量集<br />
如：<br />
for str<br />
do<br />
echo $str<br />
done<br />
在终端输入下面的命令<br />
./test.sh a b c d e f<br />
程序会依次列出所输入的参数<br />
a<br />
b<br />
c<br />
d<br />
e<br />
f</p>

<p>2.for 嵌套循环<br />
for i in 1 2 3 4 5<br />
do<br />
for j in 1 2 3 4 5<br />
do<br />
done<br />
done</p>

<p>until 语句<br />
until 循环用于执行一个循环体，直至条件为真时停止<br />
until 条件<br />
do<br />
命令1<br />
done<br />
如：<br />
sum=0<br />
i=1<br />
until [ $i -gt 100 ]<br />
do<br />
sum=$[$sum+$i]<br />
i=$[$i+1]<br />
done<br />
echo $sum</p>

<p>shell函数<br />
在shell里允许定义函数，如果读者需要编写比较大型的脚本程序，<br />
就会想到利用它们来构造自己的代码<br />
在shell里定义一个函数的办法很简单，写出它的名字，然后是一对空<br />
括号“（）”，再把有关的语句放在一对花括号“{}”里<br />
function_name()<br />
{<br />
statements<br />
}<br />
如：<br />
writestring()<br />
{<br />
echo &ldquo;lizhanglin&rdquo;<br />
}<br />
echo &ldquo;function start&rdquo;<br />
writestring<br />
echo &ldquo;function end&rdquo;<br />
在调用函数之前必须要先定义，否则出错<br />
函数里面的变量叫局部变量，如果全句变量与局部变量同名后<br />
则局部变量会覆盖全局变量，所以局部变量声明<br />
local variable;<br />
如：<br />
samplevar=&ldquo;global var&rdquo;<br />
writestr()<br />
{<br />
local samplevar=&ldquo;local var&rdquo;<br />
echo &ldquo;writestr is executing&rdquo;<br />
echo $samplevar<br />
}<br />
echo &ldquo;script is executing&rdquo;<br />
echo $samplevar<br />
writestr<br />
echo &ldquo;scriot is ending&rdquo;<br />
echo $samplevar<br />
exit 0</p>

<p>如果在函数中没有用return返回一个值，那么返回的就是函数执行的最后<br />
一句状态码值<br />
yes_or_no()<br />
{<br />
echo &ldquo;is it your name yes or no$*?&rdquo;<br />
while true<br />
do<br />
echo &ldquo;enter yes or no&rdquo;<br />
read x<br />
case &ldquo;$x&rdquo; in<br />
y | yes ) return 0;;<br />
n | no ) return 1;;<br />
* ) echo &ldquo;answer yes or no?&rdquo;;;<br />
esac<br />
done<br />
}</p>

<p>echo &ldquo;orgion you name$1&rdquo; //$1 运行文件时输入的参数<br />
if yes_or_no &ldquo;$1&rdquo; //传递参数给函数yes_or_no<br />
then<br />
echo &ldquo;nice $1,nice name&rdquo;<br />
else<br />
echo &ldquo;never mind&rdquo;<br />
fi<br />
exit 0</p>

<p>函数的参数<br />
function getname()<br />
{<br />
_NAME=$1<br />
_AGE=$2</p>

<p>echo $_NAME<br />
echo $_AGE<br />
}</p>

<p>function main()<br />
{<br />
read name age<br />
echo &ldquo;start test function&rdquo;<br />
getname $name $age<br />
echo $?<br />
}</p>

<p>main</p>

<h1 id="clear">Clear</h1>

<p>exit 0</p>

<p>函数返回值<br />
function getsum()<br />
{<br />
_DATA=$1;<br />
sum=0<br />
while [ $_DATA -ge 1 ]<br />
do<br />
sum=$[$sum+$_DATA]<br />
_DATA=$[$_DATA-1]<br />
done<br />
echo $sum<br />
}</p>

<p>function main()<br />
{<br />
read data<br />
resu=<code>getsum $data</code><br />
echo $resu<br />
}</p>

<p>main<br />
exit 0</p>

<p>递归函数应用<br />
function factorial()<br />
{<br />
if [ $1 -eq 1 ]<br />
then<br />
echo 1<br />
else<br />
local temp=$[$1-1]<br />
local result=<code>factorial $temp</code><br />
echo $[$result*$1]<br />
fi<br />
}<br />
read -p &ldquo;enter value:&rdquo; value<br />
result=<code>factorial $value</code><br />
echo &ldquo;the factorial of $value is $result&rdquo;</p>

<p>数组用法</p>

<p>arr=(123 34 3 5)<br />
echo $arr // 默认获取第一个元素</p>

<p>$ echo ${arr[1]} // 通过下标访问</p>

<p>$ echo ${arr[@]} // 访问整个数组 ，@或者* 获取整个数组</p>

<p>$ echo ${#arr[@]} // 获取数组的长度（最大下标） ，#获取长度 数组中是最后一个下标</p>

<p>$ echo ${#arr[3]} // 获取字符串长度</p>

<p>$ echo ${arr[@]:1:2} // 切片方式获取一部分数组内容</p>

<p>$ echo ${arr[@]:2} // 从第二个元素开始</p>

<p>$ echo ${arr[@]::2} // 到第二个元素</p>

<p>允许把变量当成数组来操作，即使这个变量没有明确地被声明为数组. 1 string=abcABC123ABCabc<br />
echo ${string[@]}<br />
echo ${string[*]}<br />
echo ${string[0]}<br />
echo ${string[1]}<br />
echo ${#string[@]}<br />
数组中只有一个元素. 且是这个字符串本身</p>

<p>shell<br />
数组操作<br />
myarray=(1 2 3 4 5)<br />
echo &ldquo;The original array is: ${myarray[*]}&ldquo;可以<br />
打印数组中的每一项，但是在函数中就不能只能打印出<br />
第一个值，如果非要在 函数中也能解析数组，则必须把<br />
每个值作为参数传给函数，然后在把所有参数组成一个数组<br />
如a6.sh例子</p>

<p>function testit()<br />
{<br />
echo &ldquo;the parameters are $@&rdquo;<br />
thisarray=$1;<br />
echo &ldquo;the received array is ${thisarray[<em>]}&rdquo;<br />
}<br />
myarray=(1 2 3 4 5)<br />
echo &ldquo;the original array is :${myarray[</em>]}&rdquo;<br />
testit $myarray</p>

<p>function test10()<br />
{<br />
local newarray<br />
newarray=(<code>echo &quot;$@&quot;</code>)<br />
echo &ldquo;the new array value is:${newarray[<em>]}&rdquo;<br />
}<br />
myarray=(1 2 3 4 5)<br />
echo &ldquo;the original array is ${myarray[</em>]}&rdquo;<br />
test10 ${myarray[*]}</p>

<p>function addarray()<br />
{<br />
local sum=0<br />
local newarray<br />
newarray=(<code>echo &quot;$@&quot;</code>)<br />
for value in ${newarray[<em>]}<br />
do<br />
sum=$[ $sum + $value ]<br />
done<br />
echo $sum<br />
}<br />
myarray=(1 2 3 4 5)<br />
echo &ldquo;the original array is :${myarray[</em>]}&rdquo;<br />
arg1=<code>echo ${myarray[*]}</code><br />
result=&lsquo;addarray $arg1&rsquo;<br />
echo &ldquo;the result is ${result[*]}&rdquo;</p>

<p>function arraydir()<br />
{<br />
local origarray<br />
local newarray<br />
local elements<br />
local i<br />
origarray=(<code>echo &quot;$@&quot;</code>)<br />
newarray=(<code>echo &quot;$@&quot;</code>)<br />
elements=$[$#-1]<br />
for ((i=0;i&lt;=$elements;i++))<br />
{<br />
newarray[$i]=$[${origarray[$i]}<em>2]<br />
}<br />
echo ${newarray[</em>]}<br />
}<br />
myarray=(1 2 3 4 5)<br />
echo &ldquo;the original array is: ${myarray[<em>]}&rdquo;<br />
arg1=<code>echo ${myarray[*]}</code><br />
result=(<code>arraydir $arg1</code>)<br />
echo &ldquo;the new array is: ${result[</em>]}&rdquo;</p>

<p>命令<br />
在shell脚本程序的内部我们可以执行两大类命令普通与内建<br />
命令。内建命令是在shell内部实现，内部命令执行效率高些</p>

<p>break命令<br />
从封闭的for while until循环里中途退出。break后面可以<br />
接一个参数n 表示退出第n个循环，不提倡这么使用<br />
如：<br />
rm -rf fred*<br />
echo &gt; fred1<br />
echo &gt; fred2<br />
echo &gt; fred3<br />
mkdir fred4<br />
echo &gt; fred5<br />
for file in fred*<br />
do<br />
if [ -d &ldquo;$file&rdquo; ];then<br />
break;<br />
fi<br />
done<br />
echo &ldquo;first directory is $file&rdquo;<br />
exit 0</p>

<dl>
<dt>if [ -f fred ];then<br /></dt>
<dd>
else<br />
echo &ldquo;the fred is not exsit&rdquo;<br />
fi<br />
exit 0

<br /></dd>
</dl>

<dl>
<dt>if [ -f fred ];then<br /></dt>
<dd>
else<br />
echo &ldquo;the fred is not exsit&rdquo;<br />
fi<br />
exit 0

<br /></dd>
</dl>

<dl>
<dt>if [ -f fred ];then<br /></dt>
<dd>
else<br />
echo &ldquo;the fred is not exsit&rdquo;<br />
fi<br />
exit 0

<br /></dd>
</dl>

<dl>
<dt>if [ -f fred ];then<br /></dt>
<dd>
else<br />
echo &ldquo;the fred is not exsit&rdquo;<br />
fi<br />
exit 0

<br /></dd>
</dl>

<p>he fred is not exsit&rdquo;<br />
fi<br />
exit 0</p>

<p>continue命令<br />
continue 类似于c语言中的 同名词，这个命令让for while until<br />
循环跳出到下一个循环继续执行，循环变量取循环清单里的下<br />
一个值<br />
如：<br />
rm -rf fred*<br />
echo &gt; fred1<br />
echo &gt; fred2<br />
echo &gt; fred3<br />
mkdir fred4<br />
echo &gt; fred5<br />
for file in fred*<br />
do<br />
if [ -d $file ];then<br />
echo $file is directory<br />
continue<br />
fi<br />
echo file is $file<br />
done<br />
rm -rf fred*<br />
exit 0</p>

<p>eval命令<br />
eval命令对参数进行求值操作<br />
如：</p>

<p>exit命令<br />
exit命令的作用是使脚本程序退出&rdquo;n&rdquo;结束运行<br />
在shell脚本程序设计实践中退出码<br />
&ldquo;0&rdquo;表示成功<br />
&ldquo;1&rdquo;-&ldquo;125&rdquo;之间的 数字是留给脚本程序用的错误代码<br />
&ldquo;126&rdquo; 文件不是可执行<br />
&ldquo;127&rdquo; 命令未找到<br />
&ldquo;128及以上&rdquo; 引发的一个信号</p>

<p>$(command)<br />
$(command)在脚本中执行其它命令<br />
如:<br />
echo the current path is $pwd &mdash;错误 没有输出<br />
echo the current path is $(pwd) &mdash;正确 输出当前路径<br />
echo the man is $(who)</p>

<p>cd及cd目录管理系统</p>

<p>shell函数讲解<br />
$n $1 表示第一个参数，$2 表示第二个参数 &hellip;<br />
$# 命令行参数的个数<br />
$0 当前程序的名称<br />
$? 前一个命令或函数的返回码（只能是0-255之间的一个值）<br />
$* 以&rdquo;参数1&rdquo; &ldquo;参数2&rdquo; &hellip; 形式保存所有参数<br />
$@ 以&rdquo;参数1 参数2 &hellip; &ldquo; 形式保存所有参数<br />
$$ 本程序的(进程ID号)PID<br />
$! 上一个命令的PID</p>

<p>正则表达式：<br />
grep：打印包含模式的所有行<br />
模式正则表达式<br />
*:包含一个或多个字符<br />
.：只包含一个字符<br />
[]：匹配[]里面的字符，<br />
可以是单个字符也可<br />
以是字符序列<br />
?：单个字符<br />
^：匹配行首<br />
$：匹配行尾<br />
/{2/}：出现的次数<br />
/{2,/}：至少出现的次数<br />
/{2,5/}：出现的次数在一定的范围</p>

<p>^$:空行<br />
^.$:只包含一个字符的行<br />
[^a-zA-Z] [^0-9]<br />
[0-9]/{4/}xx[0-9]/{4/}<br />
awk:提取每行的信息（分为域字段）<br />
awk &lsquo;{print $0}&rsquo; test.txt<br />
awk &lsquo;{print $1,$1}&rsquo; text.txt<br />
awk &lsquo;BEGIN {print &ldquo;name belt/n&mdash;&mdash;<br />
&rdquo;} {print $1&rdquo;/t&rdquo;$4}&rsquo; test.txt</p>

<p>awk条件操作符：<br />
&lt; &lt;= == != &gt; &gt;= ~(匹配正则表达式) !~(不匹配正则表达式)<br />
awk条件语句例子</p>

<p>awk &lsquo;{ print }&rsquo; /etc/pawasswd<br />
awk &lsquo;{ print $0 }&rsquo; /etc/passwd<br />
awk &lsquo;{ print &ldquo;&rdquo; }&rsquo; /etc/passwd<br />
awk &lsquo;{ print &ldquo;hiya&rdquo; }&rsquo; /etc/passwd<br />
awk -F &ldquo;:&rdquo; &lsquo;{ print $1 }&rsquo; /etc/passwd<br />
awk -F&rdquo;:&rdquo; &lsquo;{ print $1 $3 }&rsquo; /etc/passwd<br />
awk -F&rdquo;:&rdquo; &lsquo;{ print $1 &ldquo; &rdquo; $3 }&rsquo; /etc/passwd<br />
awk -F&rdquo;:&rdquo; &lsquo;{ print &ldquo;username: &ldquo; $1 &ldquo;/t/tuid:&rdquo; $3&rdquo; }&rsquo; /etc/passwd</p>

<p>awk &lsquo;{if($4~/brown/) print $0}&rsquo; test.txt<br />
awk &lsquo;$0 ~ /brown/&rsquo; test.txt<br />
awk &lsquo;{if($3~/48/) print $0}&rsquo; test.txt<br />
awk &lsquo;$3==&ldquo;48&rdquo; {print $0}&rsquo; test.txt<br />
awk &lsquo;$0 !~/brown/&rsquo; test.txt<br />
awk &lsquo;{if($4!~/brown/) print $0}&rsquo; test.txt<br />
awk &lsquo;$4 !=&ldquo;brown&rdquo; {print $0}&rsquo; test.txt<br />
awk &lsquo;if($6 awk &lsquo;{if($7 wak &lsquo;{if($6&gt;$7) print $1}&rsquo; test.txt<br />
awk &lsquo;/[gG]reen/&rsquo; test.txt<br />
awk &lsquo;$1 ~/^&hellip;a/&rsquo; test.txt<br />
awk &lsquo;$0~/(yellow|brown)/&rsquo; test.txt<br />
awk &lsquo;/48/&rsquo; test.txt<br />
awk &lsquo;/^48/&rsquo; test.txt<br />
awk &lsquo;{if($1==&ldquo;aaa&rdquo; &amp;&amp; $4==&ldquo;yellow&rdquo;) print $0}&rsquo; test.txt<br />
awk &lsquo;{if($1==&ldquo;aaa&rdquo; || $4==&ldquo;yellow&rdquo;) print $0}&rsquo; test.txt<br />
ls -l | awk &lsquo;/^[^d]/ {print $9&rdquo;/t&rdquo;$5} {tot+=$5} END {print &ldquo;total KB:&ldquo;tot}&rsquo;</p>

<p>awk内置变量：<br />
ARGC：命令行参数个数<br />
ARGV：命令行参数排列<br />
ENVIRON：支持队列中系统环境变量的使用<br />
FILENAME：awk浏览的文件名<br />
FNR：浏览文件的记录数<br />
FS：设置输入域分隔符，等价于命令行-F选项<br />
NF：浏览记录的域个数<br />
NR：已读的记录数<br />
OFS：输出域分隔符<br />
ORS：输出记录分隔符<br />
RS：控制记录分隔符</p>

<p>awk &lsquo;{print NF,NR,$0} END{print FILENAME}&rsquo; grade.txt<br />
awk &lsquo;{if(NR&gt;0 &amp;&amp; $4~/Brown/)print $0}&rsquo; grade.txt</p>

<p>awk内置函数<br />
gsub(r,s)：在整个$0中用s替代r<br />
gsub(r,s,t)：在整个t中用s替代r<br />
index(s,t)：返回s中字符串t的第一位置<br />
length(s)：返回s长度<br />
match(s,r)：测试s是否包含匹配r的字符串<br />
split(s,a,fs)：在fs上将s分成序列a<br />
sprint(fmt,exp)：返回经fmt格式化后的exp<br />
sub(r,s)：用$0中最左边最长的子串代替s<br />
substr(s,p)：返回字符串s中从p开始的后缀部分<br />
substr(s,p,n)：返回字符串s从p开始长度为n的后缀部分</p>

<p>awk &lsquo;gsub(/4842/,4899) {print $0}&rsquo; grade.txt<br />
awk &lsquo;BEGIN {print index(&ldquo;Bunny&rdquo;,&ldquo;ny&rdquo;)}&rsquo; grade.txt<br />
awk &lsquo;$1==&ldquo;J.Troll&rdquo; {print length($1)&rdquo; &ldquo; $1}&rsquo; grade.txt<br />
awk &lsquo;BEGIN {print match(&ldquo;ANCD&rdquo;,/d/)}&rsquo;;<br />
awk &lsquo;BEGIN {print match(&ldquo;ANCD&rdquo;,/c/)}&rsquo;;<br />
awk &lsquo;BEGIN {print split(&ldquo;123#454#raeqw&rdquo;,myarray,&ldquo;#&rdquo;)}&rsquo;</p>

<p>sed用法：</p>

<p>sed &lsquo;Command&rsquo; filename(s) 只显示结果而不修改文件。</p>

<p>1、sed &lsquo;2,5d&rsquo; file 显示文件file，除去2-5行，但行数超过文件实际行数时不会报错。</p>

<p>sed &lsquo;/10[1-4]/d&rsquo; file 显示文件file，除去包含101-104的行。</p>

<p>sed &lsquo;2,$d&rsquo; file 显示文件，只显示第一行。sed &lsquo;2,$!d&rsquo; file则只显示除第一行外的其它行。</p>

<p>sed &lsquo;/^ *$/d file 删除文件中的空行。</p>

<p>2、sed -n &lsquo;/10[1-4]/p&rsquo; file
只显示文件file中包含101-104的行。(-n和p必须同时使用，否则只有p时显示全部文件并多显示一次找到的行)</p>

<p>sed -n &lsquo;5p&rsquo; file 只显示文件的第5行</p>

<p>3、sed &rsquo;s/moding/moden/g&rsquo; file 将moding替换为moden</p>

<p>4、sed -n &rsquo;s/^west/north/p&rsquo; file 将west开头的行替换为north并显示出来。</p>

<p>5、sed &rsquo;s/[0-9][0-9][0-9]$/&amp;.5/&rsquo; file将file文件中以3个数字结尾的行替换为原数字加&rdquo;.5&rdquo;,&amp;代表搜索到的字符串。</p>

<p>6、sed &rsquo;s//(mod/)ing//1en/g file 将mod做为模式1封装在括号里，然后替换。</p>

<p>sed &rsquo;s/&hellip;$//&rsquo; file 删除每一行的最后三个字符。</p>

<p>sed &rsquo;s/^&hellip;//&rsquo; file 删除每一行的头三个字符。</p>

<p>7、sed &rsquo;s#moding#moden#g&rsquo; file 将moding替换为moden，s后面的#代表搜索串和替换串之间的分界符。</p>

<p>8、sed -n &lsquo;/101/,/105/p&rsquo; file 显示从101的匹配行到105的匹配行。如果只找到101的匹配行，则从101的匹配行到文件末。</p>

<p>sed -n &lsquo;2,/999/p&rsquo; file 显示从第2行到匹配行。</p>

<p>9、sed &lsquo;/101/,/105/s/$/ 20050119/&rsquo; file将从101的匹配行到105的匹配行的行末增加&rdquo; 20050119&rdquo;内容。</p>

<p>10、sed -e &lsquo;1,3d&rsquo; -e &rsquo;s/moding/moden/g&rsquo; file 先删除文件的1-3行，再进行替换。</p>

<p>sed -e &lsquo;/^#/!d&rsquo; file 显示文件以#开头的行。</p>

<p>11、sed &lsquo;/101/r newfile&rsquo; file 在每个匹配行增加文件newfile的内容</p>

<p>sed &lsquo;/101/w newfile&rsquo; file 把匹配行写入newfile。</p>

<p>12、sed &lsquo;/101/a/</p>

<blockquote>
<p>###&rsquo; file 在匹配行后增加一新行。</p>
</blockquote>

<p>sed &lsquo;/101/i/</p>

<blockquote>
<p>###&rsquo; file 在匹配行前增加一新行。</p>
</blockquote>

<p>sed &lsquo;/101/c/</p>

<blockquote>
<p>###&rsquo; file 用新行替换匹配行。</p>
</blockquote>

<p>13、sed &lsquo;y/abcd/ABCD/&rsquo; file 将a、b、c、d分别替换为ABCD。</p>

<p>14、sed &lsquo;5q&rsquo; file 显示到第5行时退出。</p>

<p>15、sed &lsquo;/101/{ n; s/moding/moden/g; }&rsquo; file 在文件中找到匹配行的后一行(n)再进行替换。</p>

<p>sed &lsquo;/101/{ s/moding/moden/g; q; }&rsquo; file 在文件中找到第一个匹配行后进行替换后再退出。</p>

<p>16、sed -e &lsquo;/101/{ h; d; }&rsquo; -e &lsquo;/104/{ G; }&rsquo; file
在文件中找到与101匹配行后先存在一个缓存中，再放在与104匹配行后。</p>

<p>sed -e &lsquo;/101/{ h; d; }&rsquo; -e &lsquo;/104/{ g; }&rsquo; file
在文件中找到与101匹配行后先存在一个缓存中，再替代104的匹配行。</p>

<p>sed -e &lsquo;/101/h&rsquo; -e &lsquo;$G&rsquo; file 将最后一个匹配行放在文件末。</p>

<p>sed -e &lsquo;/101/h&rsquo; -e &lsquo;$g&rsquo; file 将最后一个匹配行替换文件末行。</p>

<p>sed -e &lsquo;/101/h&rsquo; -e &lsquo;/104/x&rsquo; file 在文件中找到与101匹配行后先存在一个缓存中，再与104的匹配行进行互换。</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>