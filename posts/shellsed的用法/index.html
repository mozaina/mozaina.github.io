<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shellsed的用法 | 开发者问答集锦</title>
    <meta property="og:title" content="shellsed的用法 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shellsed的用法">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shellsed%E7%9A%84%E7%94%A8%E6%B3%95/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shellsed的用法</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>Sed命令是linux下的一个非常有用的命令，特别是在shell脚本中经常会使用到他。<br />
熟悉他你会觉得非常有趣哦！<br />
1.sed -n &lsquo;2&rsquo;p filename<br />
打印文件的第二行。<br />
2.sed -n &lsquo;1,3&rsquo;p filename<br />
打印文件的1到3行<br />
3. sed -n &lsquo;/Neave/&lsquo;p filename<br />
打印匹配Neave的行(模糊匹配)<br />
4. sed -n &lsquo;4,/The/&lsquo;p filename<br />
在第4行查询模式The<br />
5. sed -n &lsquo;1,$&lsquo;p filename<br />
打印整个文件，$表示最后一行。<br />
6. sed -n &lsquo;/.<em>ing/&lsquo;p filename<br />
匹配任意字母，并以ing结尾的单词(点号不能少)<br />
7 sed -n / -e &lsquo;/music/&rsquo;= filename<br />
打印匹配行的行号，-e 会打印文件的内容，同时在匹配行的前面标志行号。-n只打印出实际的行号。<br />
8.sed -n -e &lsquo;/music/&lsquo;p -e &lsquo;/music/&rsquo;= filename<br />
打印匹配的行和行号，行号在内容的下面<br />
9.sed &lsquo;/company/&rsquo; a\ &ldquo;Then suddenly it happend&rdquo; filename<br />
选择含有company的行，将后面的内容&rdquo;Then suddenly it
happend&rdquo;加入下一行。注意：它并不改变文件，所有操作在缓冲区，如果要保存输出，重定向到一个文件。<br />
10. sed &lsquo;/company/&rsquo; i\ &ldquo;Then suddenly it happend&rdquo; filename<br />
同9，只是在匹配的行前插入<br />
11.sed &lsquo;/company/&rsquo; c\ &ldquo;Then suddenly it happend&rdquo; filename<br />
用&rdquo;Then suddenly it happend&rdquo;替换匹配company的行的内容。<br />
12.sed &lsquo;1&rsquo;d ( &lsquo;1,3&rsquo;d &lsquo;$&rsquo;d &lsquo;/Neave/&rsquo;d) filename<br />
删除第一行(1到3行，最后一行，匹配Neave的行)<br />
13.[ address [，address]] s/ pattern-to-find /replacement-pattern/[g p w n]<br />
s选项通知s e d这是一个替换操作，并查询pattern-to-find，成功后用replacement-pattern替换它。<br />
替换选项如下：<br />
g 缺省情况下只替换第一次出现模式，使用g选项替换全局所有出现模式。<br />
p 缺省s e d将所有被替换行写入标准输出，加p选项将使- n选项无效。- n选项不打印输出结果。<br />
w 文件名使用此选项将输出定向到一个文件。(注意只将匹配替换的行写入文件，而不是整个内容)<br />
14.sed s&rsquo;/nurse/&ldquo;hello &ldquo;&amp;/&rsquo; filename<br />
将&rsquo;hello &lsquo;增加到&rsquo;nurse&rsquo; 的前面。<br />
15. sed &lsquo;/company/r append.txt&rsquo; filename<br />
在匹配company的行的下一行开始加入文件append.txt的内容。<br />
16. sed &lsquo;/company/&lsquo;q filename<br />
首次匹配company后就退出sed程序<br />
只所以看sed命令，是因为我遇到了这个一个问题。<br />
网上有很多教程，他们发表了很多程序代码，但是作者为了解释方便，都对程序作了行号编码，就像下面这样：<br />
代码::<br />
1:#!/bin/bash<br />
2:#rename file extesions<br />
3:#<br />
4:# rfe old_extensions new_extension<br />
假设这个文件名是tmp，那么我们可以使用下面的命令来去掉这个行号和冒号(：)<br />
代码::<br />
sed -e s&rsquo;/<sup class="footnote-ref" id="fnref:0-9"><a href="#fn:0-9">1</a></sup>\{1,\}://g&rsquo; tmp<br />
不过上面的命令的命令有一个缺点，那就是如果这个行号不是数字开头，而是有空格的话，那就需要修改匹配规则，规则应该修改为匹配第一个非空白字符是数字开始，后面接一个冒号的配对。命令如下：<br />
代码::<br />
sed -e s&rsquo;/^[^0-9a-zA-Z]</em>[0-9]\{1,\}://g&rsquo; tmp<br />
这令我很兴奋，于是想看看sed到底有多厉害，看了以后，明白的是不是sed有多厉害，就像awk一样，他们只是把正规表达式用到了极致。<br />
以 Redhat6.0 为测试环境<br />
事实上在solaris下的sed命令要比linux强，但因为没有测试<br />
环境，我这里只给在linux下经过测试的用法。<br />
★ 命令行参数简介<br />
★ 首先假设我们有这样一个文本文件 sedtest.txt<br />
★ 输出指定范围的行 p<br />
★ 在每一行前面增加一个制表符(^I)<br />
★ 在每一行后面增加&ndash;end<br />
★ 显示指定模式匹配行的行号 [/pattern/]=<br />
★ 在匹配行后面增加文本 [/pattern/]a\ 或者 [address]a\<br />
★ 删除匹配行 [/pattern/]d 或者 [address1][,address2]d<br />
★ 替换匹配行 [/pattern/]c\ 或者 [address1][,address2]c\<br />
★ 在匹配行前面插入文本 [/pattern/]i\ 或者 [address]i\<br />
★ 替换匹配串(注意不再是匹配行) [addr1][,addr2]s/old/new/g<br />
★ 限定范围后的模式匹配<br />
★ 指定替换每一行中匹配的第几次出现<br />
★ &amp;代表最后匹配<br />
★ 利用sed修改PATH环境变量<br />
★ 测试并提高sed命令运行效率<br />
★ 指定输出文件 [address1][,address2]w outputfile<br />
★ 指定输入文件 [address]r inputfile<br />
★ 替换相应字符 [address1][,address2]y/old/new/<br />
★ !号的使用<br />
★ \c正则表达式c 的使用<br />
★ sed命令中正则表达式的复杂性<br />
★ 转换man手册成普通文本格式(新)<br />
★ sed的man手册(用的就是上面的方法)<br />
★ 命令行参数简介<br />
sed<br />
-e script 指定sed编辑命令<br />
-f scriptfile 指定的文件中是sed编辑命令<br />
-n 寂静模式，抑制来自sed命令执行过程中的冗余输出信息，比如只<br />
显示那些被改变的行。<br />
不明白？不要紧，把这些肮脏丢到一边，跟我往下走，不过下面的介绍里<br />
不包括正则表达式的解释，如果你不明白，可能有点麻烦。<br />
★ 首先假设我们有这样一个文本文件 sedtest.txt<br />
cat &gt; sedtest.txt<br />
Sed is a stream editor<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
A stream editor is used to perform basic text transformations on an input
stream<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
While in some ways similar to an editor which permits scripted edits (such as
ed<br />
)<br />
,<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-<br />
-<br />
sed works by making only one pass over the input(s), and is consequently more<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
efficient. But it is sed&rsquo;s ability to filter text in a pipeline which
particular<br />
l<br />
y<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-<br />
★ 输出指定范围的行 p other types of editors.<br />
sed -e &ldquo;1,4p&rdquo; -n sedtest.txt<br />
sed -e &ldquo;/from/p&rdquo; -n sedtest.txt<br />
sed -e &ldquo;1,/from/p&rdquo; -n sedtest.txt<br />
★ 在每一行前面增加一个制表符(^I)<br />
sed &ldquo;s/^/^I/g&rdquo; sedtest.txt<br />
注意^I的输入方法是ctrl-v ctrl-i<br />
单个^表示行首<br />
★ 在每一行后面增加&ndash;end<br />
sed &ldquo;s/$/&ndash;end/g&rdquo; sedtest.txt<br />
单个$表示行尾<br />
★ 显示指定模式匹配行的行号 [/pattern/]=<br />
sed -e &lsquo;/is/=&rsquo; sedtest.txt<br />
1<br />
Sed is a stream editor<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
3<br />
A stream editor is used to perform basic text transformations on an input
stream<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
While in some ways similar to an editor which permits scripted edits (such as
ed<br />
)<br />
,<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-<br />
-<br />
7<br />
sed works by making only one pass over the input(s), and is consequently more<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
9<br />
efficient. But it is sed&rsquo;s ability to filter text in a pipeline which
particular<br />
l<br />
y<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-<br />
-<br />
意思是分析sedtest.txt，显示那些包含is串的匹配行的行号，注意11行中出现了is字符串<br />
这个输出是面向stdout的，如果不做重定向处理，则不影响原来的sedtest.txt<br />
★ 在匹配行后面增加文本 [/pattern/]a\ 或者 [address]a\<br />
^D<br />
sed -f sedadd.script sedtest.txt<br />
Sed is a stream editor<br />
A stream editor is used to perform basic text transformations on an input
stream<br />
While in some ways similar to an editor which permits scripted edits (such as
ed<br />
)<br />
,<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-<br />
-<br />
sed works by making only one pass over the input(s), and is consequently more<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
efficient. But it is sed&rsquo;s ability to filter text in a pipeline which
particular<br />
l<br />
y<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-<br />
-<br />
[scz@ /home/scz/src]&gt; sed -e &ldquo;a\\<br />
+++++++++<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
找到包含from字符串的行，在该行的下一行增加+++++++++。<br />
这个输出是面向stdout的，如果不做重定向处理，则不影响原来的sedtest.txt<br />
很多人想在命令行上直接完成这个操作而不是多一个sedadd.script，不幸的是，这需要用?nbsp;<br />
?nbsp;<br />
续行符\，<br />
[scz@ /home/scz/src]&gt; sed -e &ldquo;/from/a\\<br />
＞ +++++++++&rdquo; sedtest.txt<br />
[scz@ /home/scz/src]&gt; sed -e &ldquo;a\\<br />
＞ +++++++++&rdquo; sedtest.txt<br />
上面这条命令将在所有行后增加一个新行+++++++++<br />
[scz@ /home/scz/src]&gt; sed -e &ldquo;1 a\\<br />
＞ +++++++++&rdquo; sedtest.txt<br />
把下面这两行copy/paste到一个shell命令行上，效果一样<br />
+++++++++&rdquo; sedtest.txt<br />
[address]a\ 只接受一个地址指定<br />
对于a命令，不支持单引号，只能用双引号，而对于d命令等其他命令，同时<br />
★ 删除匹配行 [/pattern/]d 或者 [address1][,address2]d<br />
sed -e &lsquo;/&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;/d&rsquo; sedtest.txt<br />
Sed is a stream editor<br />
A stream editor is used to perform basic text transformations on an input
stream<br />
While in some ways similar to an editor which permits scripted edits (such as
ed<br />
)<br />
,<br />
sed works by making only one pass over the input(s), and is consequently more<br />
efficient. But it is sed&rsquo;s ability to filter text in a pipeline which
particular<br />
l<br />
y<br />
sed -e &lsquo;6,10d&rsquo; sedtest.txt<br />
删除6-10行的内容，包括6和10<br />
sed -e &ldquo;2d&rdquo; sedtest.txt<br />
删除第2行的内容<br />
sed &ldquo;1,/^$/d&rdquo; sedtest.txt<br />
删除从第一行到第一个空行之间的所有内容<br />
注意这个命令很容易带来意外的结果，当sedtest.txt中从第一行开始并没有空行，则sed删<br />
?nbsp;<br />
?nbsp;<br />
sed &ldquo;1,/from/d&rdquo; sedtest.txt<br />
删除从第一行到第一个包含from字符串的行之间的所有内容，包括第一个包含<br />
from字符串的行。<br />
★ 替换匹配行 [/pattern/]c\ 或者 [address1][,address2]c\<br />
sed -e &ldquo;/is/c\\<br />
*******<strong><em>&rdquo; sedtest.txt<br />
寻找所有包含is字符串的匹配行，替换成</em></strong>*******</p>

<hr />

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<hr />

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
While in some ways similar to an editor which permits scripted edits (such as
ed<br />
)<br />
,<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-<br />
-</p>

<hr />

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<hr />

<dl>
<dt>Zero-address ``commands&rdquo;<br /></dt>
<dd>label<br />
Label for b and t commands.<br />
#comment<br />
The comment extends until the next newline (or the<br />
end of a -e script fragment).<br />
} The closing bracket of a { } block.<br />
Zero- or One- address commands<br />
= Print the current line number.<br />
a \<br />
text Append text, which has each embedded newline pre-<br />
ceeded by a backslash.<br />
i \<br />
text Insert text, which has each embedded newline pre-<br />
ceeded by a backslash.<br />
q Immediately quit the sed script without processing<br />
any more input, except that if auto-print is not<br />
diabled the current pattern space will be printed.<br />
r filename<br />
Append text read from filename.<br />
Commands which accept address ranges<br />
{ Begin a block of commands (end with a }).<br />
b label<br />
Branch to label; if label is omitted, branch to end<br />
of script.<br />
t label<br />
If a s/// has done a successful substitution since<br />
the last input line was read and since the last t<br />
command, then branch to label; if label is omitted,<br />
branch to end of script.<br />
c \<br />
text Replace the selected lines with text, which has<br />
each embedded newline preceeded by a backslash.<br />
d Delete pattern space. Start next cycle.<br />
D Delete up to the first embedded newline in the pat-<br />
tern space. Start next cycle, but skip reading<br />
from the input if there is still data in the pat-<br />
tern space.<br />
h H Copy/append pattern space to hold space.<br />
g G Copy/append hold space to pattern space.<br />
x Exchange the contents of the hold and pattern<br />
spaces.<br />
l List out the current line in a <code>visually unambigu-  
ous'' form.  
n N Read/append the next line of input into the pattern  
space.  
p Print the current pattern space.  
P Print up to the first embedded newline of the cur-  
rent pattern space.  
s/regexp/replacement/  
Attempt to match regexp against the pattern space.  
If successful, replace that portion matched with  
replacement. The replacement may contain the spe-  
cial character &amp; to refer to that portion of the  
pattern space which matched, and the special  
escapes \1 through \9 to refer to the corresponding  
matching sub-expressions in the regexp.  
w filename Write the current pattern space to file-  
name.  
y/source/dest/  
Transliterate the characters in the pattern space  
which appear in source to the corresponding charac-  
ter in dest.  
Addresses  
Sed commands can be given with no addresses, in which case  
the command will be executed for all input lines; with one  
address, in which case the command will only be executed  
for input lines which match that address; or with two  
addresses, in which case the command will be executed for  
all input lines which match the inclusive range of lines  
starting from the first address and continuing to the sec-  
ond address. Three things to note about address ranges:  
the syntax is addr1,addr2 (i.e., the addresses are sepa-  
rated by a comma); the line which addr1 matched will  
always be accepted, even if addr2 selects an earlier line;  
and if addr2 is a regexp, it will not be tested against  
the line that addr1 matched.  
After the address (or address-range), and before the com-  
mand, a ! may be inserted, which specifies that the com-  
mand shall only be executed if the address (or address-  
range) does not match.  
The following address types are supported:  
number Match only the specified line number.  
first~step  
Match every step'th line starting with line first.  
For example,</code>sed -n 1~2p&rdquo; will print all the<br />
odd-numbered lines in the input stream, and the<br />
address 2~5 will match every fifth line, starting<br />
with the second. (This is a GNU extension.)<br />
$ Match the last line.<br />
/regexp/<br />
Match lines matching the regular expression regexp.<br />
\cregexpc<br />
Match lines matching the regular expression regexp.<br />
The c may be any character.<br />
Regular expressions<br />
POSIX.2 BREs should be supported, but they aren&rsquo;t com-<br />
pletely yet. The \n sequence in a regular expression<br />
matches the newline character. There are also some GNU<br />
extensions. [XXX FIXME: more needs to be said. At the<br />
very least, a reference to another document which<br />
describes what is supported should be given.]<br />
Miscellaneous notes<br />
This version of sed supports a \ sequence in all<br />
regular expressions, the replacement part of a substitute<br />
(s) command, and in the source and dest parts of a<br />
transliterate (y) command. The \ is stripped, and the<br />
newline is kept.<br />
SEE ALSO<br />
awk(1), ed(1), expr(1), emacs(1), perl(1), tr(1), vi(1),<br />
regex(5) [well, one ought to be written&hellip; XXX], sed.info,<br />
any of various books on sed, the sed FAQ<br />
(<a href="http://www.wollery.demon.co.uk/sedtut10.txt">http://www.wollery.demon.co.uk/sedtut10.txt</a>,<br />
<a href="http://www.ptug.org/sed/sedfaq.htm)">http://www.ptug.org/sed/sedfaq.htm)</a>.<br />
BUGS<br />
E-mail bug reports to bug-gnu-utils@gnu.org. Be sure to<br />
include the word <code>sed'' somewhere in the</code>Subject:&rdquo;<br />
field.<br />
Sed学习笔记<br />
作者：Jims of

<br /></dd>
</dl>

<dl>
<dt>Zero-address ``commands&rdquo;<br /></dt>
<dd>label<br />
Label for b and t commands.<br />
#comment<br />
The comment extends until the next newline (or the<br />
end of a -e script fragment).<br />
} The closing bracket of a { } block.<br />
Zero- or One- address commands<br />
= Print the current line number.<br />
a \<br />
text Append text, which has each embedded newline pre-<br />
ceeded by a backslash.<br />
i \<br />
text Insert text, which has each embedded newline pre-<br />
ceeded by a backslash.<br />
q Immediately quit the sed script without processing<br />
any more input, except that if auto-print is not<br />
diabled the current pattern space will be printed.<br />
r filename<br />
Append text read from filename.<br />
Commands which accept address ranges<br />
{ Begin a block of commands (end with a }).<br />
b label<br />
Branch to label; if label is omitted, branch to end<br />
of script.<br />
t label<br />
If a s/// has done a successful substitution since<br />
the last input line was read and since the last t<br />
command, then branch to label; if label is omitted,<br />
branch to end of script.<br />
c \<br />
text Replace the selected lines with text, which has<br />
each embedded newline preceeded by a backslash.<br />
d Delete pattern space. Start next cycle.<br />
D Delete up to the first embedded newline in the pat-<br />
tern space. Start next cycle, but skip reading<br />
from the input if there is still data in the pat-<br />
tern space.<br />
h H Copy/append pattern space to hold space.<br />
g G Copy/append hold space to pattern space.<br />
x Exchange the contents of the hold and pattern<br />
spaces.<br />
l List out the current line in a <code>visually unambigu-  
ous'' form.  
n N Read/append the next line of input into the pattern  
space.  
p Print the current pattern space.  
P Print up to the first embedded newline of the cur-  
rent pattern space.  
s/regexp/replacement/  
Attempt to match regexp against the pattern space.  
If successful, replace that portion matched with  
replacement. The replacement may contain the spe-  
cial character &amp; to refer to that portion of the  
pattern space which matched, and the special  
escapes \1 through \9 to refer to the corresponding  
matching sub-expressions in the regexp.  
w filename Write the current pattern space to file-  
name.  
y/source/dest/  
Transliterate the characters in the pattern space  
which appear in source to the corresponding charac-  
ter in dest.  
Addresses  
Sed commands can be given with no addresses, in which case  
the command will be executed for all input lines; with one  
address, in which case the command will only be executed  
for input lines which match that address; or with two  
addresses, in which case the command will be executed for  
all input lines which match the inclusive range of lines  
starting from the first address and continuing to the sec-  
ond address. Three things to note about address ranges:  
the syntax is addr1,addr2 (i.e., the addresses are sepa-  
rated by a comma); the line which addr1 matched will  
always be accepted, even if addr2 selects an earlier line;  
and if addr2 is a regexp, it will not be tested against  
the line that addr1 matched.  
After the address (or address-range), and before the com-  
mand, a ! may be inserted, which specifies that the com-  
mand shall only be executed if the address (or address-  
range) does not match.  
The following address types are supported:  
number Match only the specified line number.  
first~step  
Match every step'th line starting with line first.  
For example,</code>sed -n 1~2p&rdquo; will print all the<br />
odd-numbered lines in the input stream, and the<br />
address 2~5 will match every fifth line, starting<br />
with the second. (This is a GNU extension.)<br />
$ Match the last line.<br />
/regexp/<br />
Match lines matching the regular expression regexp.<br />
\cregexpc<br />
Match lines matching the regular expression regexp.<br />
The c may be any character.<br />
Regular expressions<br />
POSIX.2 BREs should be supported, but they aren&rsquo;t com-<br />
pletely yet. The \n sequence in a regular expression<br />
matches the newline character. There are also some GNU<br />
extensions. [XXX FIXME: more needs to be said. At the<br />
very least, a reference to another document which<br />
describes what is supported should be given.]<br />
Miscellaneous notes<br />
This version of sed supports a \ sequence in all<br />
regular expressions, the replacement part of a substitute<br />
(s) command, and in the source and dest parts of a<br />
transliterate (y) command. The \ is stripped, and the<br />
newline is kept.<br />
SEE ALSO<br />
awk(1), ed(1), expr(1), emacs(1), perl(1), tr(1), vi(1),<br />
regex(5) [well, one ought to be written&hellip; XXX], sed.info,<br />
any of various books on sed, the sed FAQ<br />
(<a href="http://www.wollery.demon.co.uk/sedtut10.txt">http://www.wollery.demon.co.uk/sedtut10.txt</a>,<br />
<a href="http://www.ptug.org/sed/sedfaq.htm)">http://www.ptug.org/sed/sedfaq.htm)</a>.<br />
BUGS<br />
E-mail bug reports to bug-gnu-utils@gnu.org. Be sure to<br />
include the word <code>sed'' somewhere in the</code>Subject:&rdquo;<br />
field.<br />
Sed学习笔记<br />
作者：Jims of

<br /></dd>
</dl>

<p>pports a \ sequence in all<br />
regular expressions, the replacement part of a substitute<br />
(s) command, and in the source and dest parts of a<br />
transliterate (y) command. The \ is stripped, and the<br />
newline is kept.<br />
SEE ALSO<br />
awk(1), ed(1), expr(1), emacs(1), perl(1), tr(1), vi(1),<br />
regex(5) [well, one ought to be written&hellip; XXX], sed.info,<br />
any of various books on sed, the sed FAQ<br />
(<a href="http://www.wollery.demon.co.uk/sedtut10.txt">http://www.wollery.demon.co.uk/sedtut10.txt</a>,<br />
<a href="http://www.ptug.org/sed/sedfaq.htm)">http://www.ptug.org/sed/sedfaq.htm)</a>.<br />
BUGS<br />
E-mail bug reports to bug-gnu-utils@gnu.org. Be sure to<br />
include the word <code>sed'' somewhere in the</code>Subject:&rdquo;<br />
field.<br />
Sed学习笔记<br />
作者：Jims of</p>

<p>肥肥世家</p>

<p>Table of Contents<br />
1. Sed简介</p>

<p>2. 定址</p>

<p>3. Sed命令</p>

<p>4. 选项</p>

<p>5. 元字符集</p>

<p>6. 实例</p>

<p>7. 脚本<br />
1. Sed简介<br />
sed是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern
space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed
3.02。<br />
2. 定址<br />
可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围（包括行数表示的那两行）。如1，3表示1，2，3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定
。<br />
3. Sed命令<br />
调用sed命令有两种形式：<br />
sed [options] &lsquo;command&rsquo; file(s)<br />
sed [options] -f scriptfile file(s)<br />
a\<br />
在当前行后面加入一行文本。<br />
b lable<br />
分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。<br />
c\<br />
用新的文本改变本行的文本。<br />
d<br />
从模板块（Pattern space）位置删除行。<br />
D<br />
删除模板块的第一行。<br />
i\<br />
在当前行上面插入文本。<br />
h<br />
拷贝模板块的内容到内存中的缓冲区。<br />
H<br />
追加模板块的内容到内存中的缓冲区<br />
g<br />
获得内存缓冲区的内容，并替代当前模板块中的文本。<br />
G<br />
获得内存缓冲区的内容，并追加到当前模板块文本的后面。<br />
l<br />
列表不能打印字符的清单。<br />
n<br />
读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。<br />
N<br />
追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。<br />
p<br />
打印模板块的行。<br />
P（大写）<br />
打印模板块的第一行。<br />
q<br />
退出Sed。<br />
r file<br />
从file中读行。<br />
t label<br />
if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。<br />
T label<br />
错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。<br />
w file<br />
写并追加模板块到file末尾。<br />
W file<br />
写并追加模板块的第一行到file末尾。<br />
!<br />
表示后面的命令对所有没有被选定的行发生作用。<br />
s/re/string</p>

<h1 id="用string替换正则表达式re">用string替换正则表达式re。</h1>

<p>打印当前行号码。</p>

<p>把注释扩展到下一个换行符以前。<br />
以下的是替换标记<br />
g表示行内全面替换。<br />
p表示打印行。<br />
w表示把行写入一个文件。<br />
x表示互换模板块中的文本和缓冲区中的文本。<br />
y表示把一个字符翻译为另外的字符（但是不用于正则表达式）<br />
4. 选项<br />
-e command, &ndash;expression=command<br />
允许多台编辑。<br />
-h, &ndash;help<br />
打印帮助，并显示bug列表的地址。<br />
-n, &ndash;quiet, &ndash;silent<br />
取消默认输出。<br />
-f, &ndash;filer=script-file<br />
引导sed脚本文件名。<br />
-V, &ndash;version<br />
打印版本和版权信息。<br />
5. 元字符集<br />
^ 锚定行的开始 如：/^sed/匹配所有以sed开头的行。<br />
$ 锚定行的结束 如：/sed$/匹配所有以sed结尾的行。<br />
. 匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。<br />
* 匹配零或多个字符 如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。<br />
[] 匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。<br />
[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。<br />
\(..\) 保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。<br />
&amp; 保存搜索字符用来替换其他字符，如s/love/<strong>&amp;</strong>/，love这成<strong>love</strong>。<br />
\ 锚定单词的开始，如:/\匹配包含以love开头的单词的行。<br />
&gt; 锚定单词的结束，如/love&gt;/匹配包含以love结尾的单词的行。<br />
x\{m\}重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。<br />
x\{m,\} 重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。<br />
x\{m,n\}重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5&ndash;10个o的行。<br />
6. 实例<br />
删除：d命令<br />
$ sed &lsquo;2d&rsquo; example&mdash;&ndash;删除example文件的第二行。<br />
$ sed &lsquo;2,$d&rsquo; example&mdash;&ndash;删除example文件的第二行到末尾所有行。<br />
$ sed &lsquo;$d&rsquo; example&mdash;&ndash;删除example文件的最后一行。<br />
$ sed &lsquo;/test/&rsquo;d example&mdash;&ndash;删除example文件所有包含test的行。<br />
替换：s命令<br />
$ sed &rsquo;s/test/mytest/g&rsquo; example&mdash;&ndash;
在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。<br />
$ sed -n &rsquo;s/^test/mytest/p&rsquo;
example&mdash;&ndash;(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。<br />
$ sed &rsquo;s/^192.168.0.1/&amp;localhost/&rsquo;
example&mdash;&ndash;&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。<br />
$ sed -n &rsquo;s/\(love\)able/\1rs/p&rsquo; example&mdash;&ndash;
love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。<br />
$ sed &rsquo;s#10#100#g&rsquo; example&mdash;&ndash;
不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。<br />
选定行的范围：逗号<br />
$ sed -n &lsquo;/test/,/check/p&rsquo; example&mdash;&ndash;所有在模板test和check所确定的范围内的行都被打印。<br />
$ sed -n &lsquo;5,/^test/p&rsquo; example&mdash;&ndash;打印从第五行开始到第一个包含以test开始的行之间的所有行。<br />
$ sed &lsquo;/test/,/check/s/$/sed test/&rsquo; example&mdash;&ndash;对于模板test和west之间的行，每行的末尾用字符串sed
test替换。<br />
多点编辑：e命令<br />
$ sed -e &lsquo;1,5d&rsquo; -e &rsquo;s/test/check/&rsquo;
example&mdash;&ndash;(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。<br />
$ sed &ndash;expression=&rsquo;s/test/check/&rsquo; &ndash;expression=&lsquo;/love/d&rsquo; example&mdash;&ndash;一个比-
e更好的命令是&ndash;expression。它能给sed表达式赋值。<br />
从文件读入：r命令<br />
$ sed &lsquo;/test/r file&rsquo; example&mdash;&ndash;
file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。<br />
写入文件：w命令<br />
$ sed -n &lsquo;/test/w file&rsquo; example&mdash;&ndash;在example中所有包含test的行都被写入file里。<br />
追加命令：a命令<br />
$ sed &lsquo;/^test/a\\&mdash;&gt;this is a example&rsquo;
example被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。<br />
插入：i命令<br />
$ sed &lsquo;/test/i\\<br />
new line<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rsquo; example<br />
如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。<br />
下一个：n命令<br />
$ sed &lsquo;/test/{ n; s/aa/bb/; }&rsquo; example&mdash;&ndash;
如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。<br />
变形：y命令<br />
$ sed &lsquo;1,10y/abcde/ABCDE/&rsquo; example&mdash;&ndash;把1&ndash;
10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。<br />
退出：q命令<br />
$ sed &lsquo;10q&rsquo; example&mdash;&ndash;打印完第10行后，退出sed。<br />
保持和获取：h命令和G命令<br />
$ sed -e &lsquo;/test/h&rsquo; -e &lsquo;$G example&mdash;&ndash;
在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。<br />
保持和互换：h命令和x命令<br />
$ sed -e &lsquo;/test/h&rsquo; -e &lsquo;/check/x&rsquo; example
&mdash;&ndash;互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。<br />
7. 脚本<br />
Sed脚本是一个sed的命令清单，启动Sed时以-
f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:0-9">0-9 <a class="footnote-return" href="#fnref:0-9"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>