<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux基础命令SHELL脚本编程进阶 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux基础命令SHELL脚本编程进阶 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux基础命令SHELL脚本编程进阶">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux基础命令SHELL脚本编程进阶</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="linux基础命令-shell脚本编程进阶">Linux基础命令-SHELL脚本编程进阶</h3>

<ul>
<li>SHELL脚本编程进阶

<ul>
<li>一、循环

<ul>
<li>1. 循环概念</li>
<li>2. for循环</li>
<li>3. while循环</li>
<li>4. until循环</li>
<li>5. 循环控制语句continue</li>
<li>6. 循环控制语句break</li>
<li>7. 循环控制shift命令</li>
<li>8. select循环与菜单</li>
</ul></li>
<li>二、信号捕捉

<ul>
<li>1. 信号捕捉trap</li>
</ul></li>
<li>三、函数

<ul>
<li>1. 函数介绍</li>
<li>2. 定义函数</li>
<li>3. 函数使用</li>
<li>4. 函数返回值</li>
<li>5. 交互式环境下定义和使用函数</li>
<li>6. 在脚本中定义及使用函数</li>
<li>7. 使用函数文件</li>
<li>8. 创建，载入，检查函数</li>
<li>9. 执行shell函数</li>
<li>10. 删除shell函数</li>
<li>11. 函数参数，变量，递归</li>
<li>12. fork炸弹</li>
</ul></li>
<li>四、数组

<ul>
<li>1. 数组</li>
<li>2. 数组赋值</li>
<li>3. 引用数组</li>
<li>4. 数组数据处理</li>
<li>5. 示例</li>
</ul></li>
<li>五、高级字符串操作

<ul>
<li>1. 字符串切片</li>
<li>2. 字符串处理</li>
</ul></li>
<li>六、高级变量

<ul>
<li>1. 变量赋值</li>
<li>2. 高级变量用法-有类型变量</li>
<li>3. eval命令</li>
<li>4. mktemp命令</li>
<li>5. install命令</li>
<li>6. 间接变量引用</li>
</ul></li>
<li>七、expect

<ul>
<li>1. expect介绍</li>
<li>2. expect命令</li>
<li>3. 示例</li>
</ul></li>
</ul></li>
</ul>

<h1 id="shell脚本编程进阶">SHELL脚本编程进阶</h1>

<h2 id="一-循环">一、循环</h2>

<h3 id="1-循环概念">1. 循环概念</h3>

<pre><code>1.编程中的逻辑处理：
    顺序执行
    选择执行
    循环执行
2.循环执行
    将某代码段重复运行多次
    重复运行多少次
        循环次数事先已知
        循环次数事先未知
    有进入条件和退出条件
3.for, while, until
</code></pre>

<h3 id="2-for循环">2. for循环</h3>

<pre><code>1.  for 变量名 in 列表;do
        循环体
    done

2.执行机制：
依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直
到列表中的元素耗尽，循环结束

3.列表生成方式：
    (1) 直接给出列表
    (2) 整数列表：
        (a) {start..end}
        (b) $(seq [start [step]] end)
    (3) 返回列表的命令 $(COMMAND)
    (4) 使用glob，如：*.sh
    (5) 变量引用 $@, $*

4.双小括号方法，即((…))格式，也可以用于算术运算

5.双小括号方法也可以使bash Shell实现C语言风格的变量操作
    I=10
    ((I++))

6.for循环的特殊格式：
 for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))；do
    循环体
 done

7.控制变量初始化：仅在运行到循环代码段时执行一次

8.控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做
条件判断
</code></pre>

<h3 id="3-while循环">3. while循环</h3>

<pre><code>1.while CONDITION; do
    循环体
 done

2.CONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后
会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”
终止循环

3.因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正

4.进入条件：CONDITION为true

5.退出条件：CONDITION为false

6.创建无限循环体
    while true; do
        循环体
    done

7.while循环的特殊用法（遍历文件的每一行）
    while read line; do
        循环体
    done &lt; /PATH/FROM/SOMEFILE
依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line
</code></pre>

<h3 id="4-until循环">4. until循环</h3>

<pre><code>1.until CONDITION; do
    循环体
  done

2.进入条件： CONDITION 为false

3.退出条件： CONDITION 为true

4.创建无限循环体
    until false; do
        循环体
    Done
</code></pre>

<h3 id="5-循环控制语句continue">5. 循环控制语句continue</h3>

<pre><code>1.用于循环体中
2.continue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为
    第1层
    while CONDTIITON1; do
        CMD1
        ...
    if CONDITION2; then
        continue
    fi
        CMDn
        ...
    done
</code></pre>

<h3 id="6-循环控制语句break">6. 循环控制语句break</h3>

<pre><code>1.用于循环体中
2.break [N]：提前结束第N层循环，最内层为第1层
    while CONDTIITON1; do
        CMD1
        ...
    if CONDITION2; then
        break
    fi
        CMDn
        ...
    done
</code></pre>

<h3 id="7-循环控制shift命令">7. 循环控制shift命令</h3>

<pre><code>1.shift [n]

2.用于将参量列表 list 左移指定次数，缺省为左移一次。

3.参量列表 list 一旦被移动，最左端的那个参数就从列表中删除。while 循环遍
历位置参量列表时，常用到 shift

4.  ./doit.sh a b c d e f g h
#!/bin/bash
    while [ $# -gt 0 ] # or (( $# &gt; 0 ));do
        echo $*
        shift
    done

5.  ./shfit.sh a b c d e f g h
#!/bin/bash
    until [ -z &quot;$1&quot; ];do
        echo &quot;$1&quot;
        shift
    done
    echo
</code></pre>

<h3 id="8-select循环与菜单">8. select循环与菜单</h3>

<pre><code>1.select variable in list
    do
        循环体命令
    done
2.select 循环主要用于创建菜单，按数字顺序排列的菜单项将显示在标准错误上，
并显示 PS3 提示符，等待用户输入

3.用户输入菜单列表中的某个数字，执行相应的命令

4.用户输入被保存在内置变量 REPLY 中

5.select 是个无限循环，因此要记住用 break 命令退出循环，或用 exit 命令终止
脚本。也可以按 ctrl+c 退出循环

6.select 经常和 case 联合使用

7.与 for 循环类似，可以省略 in list，此时使用位置参量
</code></pre>

<h2 id="二-信号捕捉">二、信号捕捉</h2>

<h3 id="1-信号捕捉trap">1. 信号捕捉trap</h3>

<pre><code>1.trap '触发指令' 信号
    进程收到系统发出的指定信号后，将执行自定义指令，而不会执行原操作
2.trap '' 信号
    忽略信号的操作
3.trap '-' 信号
    恢复原信号的操作
4.trap -p
    列出自定义信号操作
5.trap finish EXIT
    当脚本退出时，执行finish函数
6.示例：
    #!/bin/bash
    trap 'echo “signal:SIGINT&quot;' int
    trap -p
    for((i=0;i&lt;=10;i++));do
         sleep 1
         echo $i
    done

    trap '' int
    trap -p
    for((i=11;i&lt;=20;i++)):do
         sleep 1
         echo $i
    done

    trap '-' int
    trap -p
    for((i=21;i&lt;=30;i++)):do
        sleep 1
         echo $i
    done
</code></pre>

<h2 id="三-函数">三、函数</h2>

<h3 id="1-函数介绍">1. 函数介绍</h3>

<pre><code>1.函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程
2.它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分
3.函数和shell程序比较相似，区别在于
    Shell程序在子Shell中运行
    而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改
</code></pre>

<h3 id="2-定义函数">2. 定义函数</h3>

<pre><code>1.函数由两部分组成：函数名和函数体
2.help function
3.语法一（常用）：
    f_name （）{
    ...函数体...
    }
4.语法二：
    function f_name {
    ...函数体...
    }
5.语法三：
    function f_name （） {
    ...函数体...
    } 
</code></pre>

<h3 id="3-函数使用">3. 函数使用</h3>

<pre><code>1.函数的定义和使用：
    可在交互式环境下定义函数
    可将函数放在脚本文件中作为它的一部分
    可放在只包含函数的单独文件中
2.调用：函数只有被调用才会执行
    调用：给定函数名
    函数名出现的地方，会被自动替换为函数代码
3.函数的生命周期：被调用时创建，返回时终止
</code></pre>

<h3 id="4-函数返回值">4. 函数返回值</h3>

<pre><code>1.函数有两种返回值：
2.函数的执行结果返回值：
    (1) 使用echo等命令进行输出
    (2) 函数体中调用命令的输出结果
3.函数的退出状态码：
    (1) 默认取决于函数中执行的最后一条命令的退出状态码
    (2) 自定义退出状态码，其格式为：
return 从函数中返回，用最后状态命令决定返回值
return 0 无错误返回
return 1-255 有错误返回
</code></pre>

<h3 id="5-交互式环境下定义和使用函数">5. 交互式环境下定义和使用函数</h3>

<pre><code>1.示例：
    dir() {
     &gt; ls -l
     &gt; }
2.定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同
    dir
3.该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令
    unset dir
</code></pre>

<h3 id="6-在脚本中定义及使用函数">6. 在脚本中定义及使用函数</h3>

<pre><code>1.函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它
后才能使用
2.调用函数仅使用其函数名即可
3.示例：
    cat func1
    #!/bin/bash
    # func1
    hello(){
        echo &quot;Hello there today's date is `date +%F`&quot;
    }
        echo &quot;now going to the function hello&quot;
        hello
        echo “back from the function”
</code></pre>

<h3 id="7-使用函数文件">7. 使用函数文件</h3>

<pre><code>1.可以将经常使用的函数存入函数文件，然后将函数文件载入shell
2.文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main
3.一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set命
  令查看所有定义的函数，其输出列表包括已经载入shell的所有函数
4.若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新载
  入此文件
</code></pre>

<h3 id="8-创建-载入-检查函数">8. 创建，载入，检查函数</h3>

<pre><code>1.函数文件示例：
    cat functions.main
    #!/bin/bash
    #functions.main
    findit(){
         if [ $# -lt 1 ] ; then
        echo &quot;Usage:findit file&quot;
         return 1
     fi
         find / -name $1 –print
     }

2.函数文件已创建好后，要将它载入shell
3.定位函数文件并载入shell的格式
    . filename 或 source filename
4.注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;
    这里的文件名要带正确路径
5.示例：
上例中的函数，可使用如下命令
     . functions.main

6.使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数
示例：
    set
     findit=( ){
        if [ $# -lt 1 ]; then
         echo &quot;usage :findit file&quot;;
        return 1
     fi
         find / -name $1 -print
     }
</code></pre>

<h3 id="9-执行shell函数">9. 执行shell函数</h3>

<pre><code>1.要执行函数，简单地键入函数名即可
2.示例：
    findit groups
    /usr/bin/groups
    /usr/local/backups/groups.bak
</code></pre>

<h3 id="10-删除shell函数">10. 删除shell函数</h3>

<pre><code>1.现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命
  令完成删除函数
2.命令格式为：
    unset function_name
3.示例：
    unset findit
    再键入set命令，函数将不再显示
4.环境函数
    使子进程也可使用
    声明：export -f function_name
    查看：export -f 或 declare -xf
</code></pre>

<h3 id="11-函数参数-变量-递归">11. 函数参数，变量，递归</h3>

<pre><code>参数：
1.函数可以接受参数：
    传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；
例如“testfunc arg1 arg2 ...”
    在函数体中当中，可使用$1, $2, ...调用这些参数；还可以使用$@, $*, $#
等特殊变量

变量：
1.变量作用域：
    环境变量：当前shell和子shell有效
    本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数
    局部变量：函数的生命周期；函数结束时变量被自动销毁
2.注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量
3.在函数中定义局部变量的方法
    local NAME=VALUE

递归：
1.函数递归：
    函数直接或间接调用自身
    注意递归层数
2.递归实例：
    阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语，一个正整数的阶
乘（factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1，自然
数n的阶乘写作n!
    n!=1×2×3×...×n
    阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n
    n!=n(n-1)(n-2)...1
    n(n-1)! = n(n-1)(n-2)!
3.示例：fact.sh
#!/bin/bash
#
    fact() {
        if [ $1 -eq 0 -o $1 -eq 1 ]; then
        echo 1
    else
        echo $[$1*$(fact $[$1-1])]
    fi
    }
    fact $1
</code></pre>

<h3 id="12-fork炸弹">12. fork炸弹</h3>

<pre><code>1.fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是
一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个
简单的程序迅速耗尽系统里面的所有资源
2.函数实现
     :(){ :|:&amp; };:
     bomb() { bomb | bomb &amp; }; bomb
3.脚本实现
     cat Bomb.sh
     #!/bin/bash
     ./$0|./$0&amp;
</code></pre>

<h2 id="四-数组">四、数组</h2>

<h3 id="1-数组">1. 数组</h3>

<pre><code>1.变量：存储单个元素的内存空间
2.数组：存储多个元素的连续的内存空间，相当于多个变量的集合
3.数组名和索引
    索引：编号从0开始，属于数值索引
    注意：索引可支持使用自定义的格式，而不仅是数值格式，即为关联索引，bash4.0版本之后开始支持
    bash的数组支持稀疏格式（索引不连续）
4.声明数组：
    declare -a ARRAY_NAME
    declare -A ARRAY_NAME 关联数组
    注意：两者不可相互转换
</code></pre>

<h3 id="2-数组赋值">2. 数组赋值</h3>

<pre><code>1.数组元素的赋值
    (1) 一次只赋值一个元素
        ARRAY_NAME[INDEX]=VALUE
        weekdays[0]=&quot;Sunday&quot;
        weekdays[4]=&quot;Thursday&quot;
    (2) 一次赋值全部元素
        ARRAY_NAME=(&quot;VAL1&quot; &quot;VAL2&quot; &quot;VAL3&quot; ...)
    (3) 只赋值特定元素
        ARRAY_NAME=([0]=&quot;VAL1&quot; [3]=&quot;VAL2&quot; ...)
    (4) 交互式数组值对赋值
        read -a ARRAY
2.显示所有数组：declare -a 
</code></pre>

<h3 id="3-引用数组">3. 引用数组</h3>

<pre><code>1.引用数组元素
    ${ARRAY_NAME[INDEX]}
    注意：省略[INDEX]表示引用下标为0的元素
2.引用数组所有元素
    ${ARRAY_NAME[*]}
    ${ARRAY_NAME[@]}
3.数组的长度(数组中元素的个数)
    ${#ARRAY_NAME[*]}
    ${#ARRAY_NAME[@]}
4.删除数组中的某元素：导致稀疏格式
    unset ARRAY[INDEX]
5.删除整个数组
    unset ARRAY
</code></pre>

<h3 id="4-数组数据处理">4. 数组数据处理</h3>

<pre><code>1.引用数组中的元素：
    数组切片：
        ${ARRAY[@]:offset:number}
            offset 要跳过的元素个数
            number 要取出的元素个数
        取偏移量之后的所有元素
        ${ARRAY[@]:offset}
2.向数组中追加元素：
    ARRAY[${#ARRAY[*]}]=value
3.关联数组：
    declare -A ARRAY_NAME
    ARRAY_NAME=([idx_name1]='val1' [idx_name2]='val2‘...)
    注意：关联数组必须先声明再调用
</code></pre>

<h3 id="5-示例">5. 示例</h3>

<pre><code>1.生成10个随机数保存于数组中，并找出其最大值和最小值
#!/bin/bash
declare -i min max
declare -a nums
for ((i=0;i&lt;10;i++));do
    nums[$i]=$RANDOM
    [ $i -eq 0 ] &amp;&amp; min=${nums[$i]} &amp;&amp; max=${nums[$i]}&amp;&amp; continue
    [ ${nums[$i]} -gt $max ] &amp;&amp; max=${nums[$i]}
    [ ${nums[$i]} -lt $min ] &amp;&amp; min=${nums[$i]}
done
echo “All numbers are ${nums[*]}”
echo Max is $max
echo Min is $min

2.编写脚本，定义一个数组，数组中的元素对应的值是/var/log目录下所有以.log结尾
的文件；统计出其下标为偶数的文件中的行数之和
#!/bin/bash
declare -a files
files=(/var/log/*.log)                                                      */
declare -i lines=0
for i in $(seq 0 $[${#files[*]}-1]); do
    if [ $[$i%2] -eq 0 ];then
        let lines+=$(wc -l ${files[$i]} | cut -d' ' -f1)
    fi
done
echo &quot;Lines: $lines.&quot;
</code></pre>

<h2 id="五-高级字符串操作">五、高级字符串操作</h2>

<h3 id="1-字符串切片">1. 字符串切片</h3>

<pre><code>1.${#var}:返回字符串变量var的长度

2.${var:offset}:返回字符串变量var中从第offset个字符后（
  不包括第offset个字符）的字符开始，到最后的部分，
  offset的取值在0 到 ${#var}-1 之间(bash4.2后，允许为负值)

3.${var:offset:number}：返回字符串变量var中从第offset个字符后
 （不包括第offset个字符）的字符开始，长度为number的部分

4.${var: -length}：取字符串的最右侧几个字符
  注意：冒号后必须有一空白字符

5.${var:offset:-length}：从最左侧跳过offset字符，
  一直向右取到距离最右侧lengh个字符之前的内容

6.${var: -length:-offset}：先从最右侧向左取到length个字符开始，
  再向右取到距离最右侧offset个字符之间的内容

注意：-length前空格
</code></pre>

<h3 id="2-字符串处理">2. 字符串处理</h3>

<pre><code>1.基于模式取子串
    ${var#*word}：其中word可以是指定的任意字符
    功能：自左而右，查找var变量所存储的字符串中，第一次出现的word,
        删除字符串开头至第一次出现word字符串（含）之间的所有字符
    ${var##*word}：同上，贪婪模式，不同的是，删除的是字符串开头至
        最后一次由word指定的字符之间的所有内容

2.示例：
    file=“var/log/messages”
    ${file#*/}: log/messages
    ${file##*/}: messages

3.${var%word*}：其中word可以是指定的任意字符
    功能：自右而左，查找var变量所存储的字符串中，第一次出现的word, 删除字符串最后一个字符向左至第一次出现word字符串（含）之间的所有字符
    file=&quot;/var/log/messages&quot;
    ${file%/*}: /var/log

4.${var%%word*}：（*/只是注释）同上，只不过删除字符串最右侧的字符向左至最后一次出现word字符之间的所有字符 

5.示例：
    url=http://www.magedu.com:80
    ${url##*:} 80
    ${url%%:*} http

6.查找替换
    ${var/pattern/substr}：查找var所表示的字符串中，第一次被pattern所匹
        配到的字符串，以substr替换之
    ${var//pattern/substr}: 查找var所表示的字符串中，所有能被pattern所匹
        配到的字符串，以substr替换之
    ${var/#pattern/substr}：查找var所表示的字符串中，行首被pattern所匹
        配到的字符串，以substr替换之
    ${var/%pattern/substr}：查找var所表示的字符串中，行尾被pattern所匹
        配到的字符串，以substr替换之

7.查找并删除
    ${var/pattern}：删除var表示的字符串中第一次被pattern匹配到的字符串
    ${var//pattern}：删除var表示的字符串中所有被pattern匹配到的字符串
    ${var/#pattern}：删除var表示的字符串中所有以pattern为行首匹配到的字符串
    ${var/%pattern}：删除var所表示的字符串中所有以pattern为行尾所匹配到的字符串

8.字符大小写转换
    ${var^^}：把var中的所有小写字母转换为大写
    ${var,,}：把var中的所有大写字母转换为小写
</code></pre>

<h2 id="六-高级变量">六、高级变量</h2>

<h3 id="1-变量赋值">1. 变量赋值</h3>

<p><a href="https://img.it610.com/image/info8/db67eba5ea54468a95e7f39bf0ab69a3.jpg"><img src="https://img.it610.com/image/info8/db67eba5ea54468a95e7f39bf0ab69a3.jpg" alt="Linux基础命令-
SHELL脚本编程进阶_第1张图片" /></a></p>

<h3 id="2-高级变量用法-有类型变量">2. 高级变量用法-有类型变量</h3>

<pre><code>1.Shell变量一般是无类型的，但是bash Shell提供了declare和typeset两个命令
  用于指定变量的类型，两个命令是等价的
2.declare [选项] 变量名
    -r 声明或显示只读变量
    -i 将变量定义为整型数
    -a 将变量定义为数组
    -A 将变量定义为关联数组
    -f 显示已定义的所有函数名及其内容
    -F 仅显示已定义的所有函数名
    -x 声明或显示环境变量和函数
    -l 声明变量为小写字母 declare –l var=UPPER
    -u 声明变量为大写字母 declare –u var=lower
</code></pre>

<h3 id="3-eval命令">3. eval命令</h3>

<pre><code>1.eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。该命令
  适用于那些一次扫描无法实现其功能的变量.该命令对变量进行两次扫描
2.示例：
    [root@server ~]# CMD=whoami
    [root@server ~]# echo $CMD
    whoami
    [root@server ~]# eval $CMD
    root
    [root@server ~]# n=10
    [root@server ~]# echo {0..$n}
    {0..10}
    [root@server ~]# eval echo {0..$n}
    0 1 2 3 4 5 6 7 8 9 10
</code></pre>

<h3 id="4-mktemp命令">4. mktemp命令</h3>

<pre><code>1.mktemp命令：创建并显示临时文件，可避免冲突
2.mktemp [OPTION]... [TEMPLATE]
    TEMPLATE: filenameXXX
    X至少要出现三个
3.OPTION：
    -d: 创建临时目录
    -p DIR或--tmpdir=DIR：指明临时文件所存放目录位置
4.示例：
    mktemp /tmp/testXXX
    tmpdir=`mktemp –d /tmp/testdirXXX`
    mktemp --tmpdir=/testdir testXXXXXX
</code></pre>

<h3 id="5-install命令">5. install命令</h3>

<pre><code>1.install命令：
     install [OPTION]... [-T] SOURCE DEST 单文件
     install [OPTION]... SOURCE... DIRECTORY
     install [OPTION]... -t DIRECTORY SOURCE...
     install [OPTION]... -d DIRECTORY...创建空目录
2.选项：
    -m MODE，默认755
    -o OWNER
    -g GROUP
3.示例：
    install -m 700 -o wang -g admins srcfile desfile
    install –m 770 –d /testdir/installdir
</code></pre>

<h3 id="6-间接变量引用">6. 间接变量引用</h3>

<pre><code>1.如果第一个变量的值是第二个变量的名字，从第一个变量引用第二个变量的值
  就称为间接变量引用
2.variable1的值是variable2，而variable2又是变量名，variable2的值为value，
  间接变量引用是指通过variable1获得变量值value的行为
    variable1=variable2
    variable2=value
3.bash Shell提供了两种格式实现间接变量引用
    eval tempvar=\$$variable1
    tempvar=${!variable1}
3.示例：
    [root@server ~]# N=NAME
    [root@server ~]# NAME=wangxiaochun
    [root@server ~]# N1=${!N}
    [root@server ~]# echo $N1
    wangxiaochun
    [root@server ~]# eval N2=\$$N
    [root@server ~]# echo $N2
    wangxiaochun
</code></pre>

<h2 id="七-expect">七、expect</h2>

<h3 id="1-expect介绍">1. expect介绍</h3>

<pre><code>    expect 是由Don Libes基于Tcl（ Tool Command Language ）语言开发的，主
要应用于自动化交互式操作的场景，借助 expect 处理交互的命令，可以将交互过
程如：ssh登录，ftp登录等写在一个脚本上，使之自动化完成。尤其适用于需要对
多台服务器执行相同操作的环境中，可以大大提高系统管理人员的工作效率
</code></pre>

<h3 id="2-expect命令">2. expect命令</h3>

<pre><code>1.expect 语法：
    expect [选项] [ -c cmds ] [ [ -[f|b] ] cmdfile ] [ args ]
2.选项
    -c：从命令行执行expect脚本，默认expect是交互地执行的
         示例：expect -c 'expect &quot;\n&quot; {send &quot;pressed enter\n&quot;}
    -d：可以输出输出调试信息
         示例：expect -d ssh.exp
3.expect中相关命令
    spawn 启动新的进程
    send 用于向进程发送字符串
    expect 从进程接收字符串
    interact 允许用户交互
    exp_continue 匹配多个字符串在执行动作后加此命令
4.expect最常用的语法(tcl语言:模式-动作)
5.单一分支模式语法：
    expect “hi” {send “You said hi\n&quot;}
    匹配到hi后，会输出“you said hi”，并换行
6.多分支模式语法：
    expect &quot;hi&quot; { send &quot;You said hi\n&quot; } \
    &quot;hehe&quot; { send &quot;Hehe yourself\n&quot; } \
    &quot;bye&quot; { send &quot;Good bye\n&quot; }

    匹配hi,hello,bye任意字符串时，执行相应输出。等同如下：
    expect {
    &quot;hi&quot; { send &quot;You said hi\n&quot;}
    &quot;hehe&quot; { send &quot;Hehe yourself\n&quot;}
    &quot;bye&quot; { send &quot; Good bye\n&quot;}
    }
</code></pre>

<h3 id="3-示例">3. 示例</h3>

<pre><code>1.
    #!/usr/bin/expect
    spawn scp /etc/fstab 192.168.8.100:/app
    expect {
         &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue }
         &quot;password&quot; { send &quot;magedu\n&quot; }
    }
    expect eof

2.
    #!/usr/bin/expect
    spawn ssh 192.168.8.100
    expect {
         &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue }
         &quot;password&quot; { send &quot;magedu\n&quot; }
    }
    interact
    #expect eof

3.变量
    #!/usr/bin/expect
    set ip 192.168.8.100
    set user root
    set password magedu
    set timeout 10
    spawn ssh $user@$ip
    expect {
         &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue }
         &quot;password&quot; { send &quot;$password\n&quot; }
    }
    interact

3.位置参数
    #!/usr/bin/expect
    set ip [lindex $argv 0]
    set user [lindex $argv 1]
    set password [lindex $argv 2]
    spawn ssh $user@$ip
    expect {
         &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue }
         &quot;password&quot; { send &quot;$password\n&quot; }
    }
    interact
    #./ssh3.exp 192.168.8.100 root magedu

4.执行多个命令
    #!/usr/bin/expect
    set ip [lindex $argv 0]
    set user [lindex $argv 1]
    set password [lindex $argv 2]
    set timeout 10
    spawn ssh $user@$ip
    expect {
         &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue }
         &quot;password&quot; { send &quot;$password\n&quot; }
    }
    expect &quot;]#&quot; { send &quot;useradd haha\n&quot; }
    expect &quot;]#&quot; { send &quot;echo magedu |passwd --stdin haha\n&quot; }
    send &quot;exit\n&quot;
    expect eof
    #./ssh4.exp 192.168.8.100 root magedu

5.shell脚本调用expect
    #!/bin/bash
    ip=$1
    user=$2
    password=$3
    expect &lt;&lt;EOF
    set timeout 20
    spawn ssh $user@$ip
    expect {
         &quot;yes/no&quot; { send &quot;yes\n&quot;;exp_continue }
         &quot;password&quot; { send &quot;$password\n&quot; }
    }
    expect &quot;]#&quot; { send &quot;useradd hehe\n&quot; }
    expect &quot;]#&quot; { send &quot;echo magedu |passwd --stdin hehe\n&quot; }
    expect &quot;]#&quot; { send &quot;exit\n&quot; }
    expect eof
    EOF
    #./ssh5.sh 192.168.8.100 root magedu
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>