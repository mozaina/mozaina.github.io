<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>BASHShell的脚本编程转 | 开发者问答集锦</title>
    <meta property="og:title" content="BASHShell的脚本编程转 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="BASHShell的脚本编程转">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/bashshell%E7%9A%84%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%BD%AC/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">BASHShell的脚本编程转</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p>BASH Shell的脚本编程(转)[@more@]</p>

<p>报告人 bjchenxu (ChinaUnix/linux版)</p>

<p>第一篇：超级工具／terminals，xterms 和 shells</p>

<p>shell是一个全功能的编程环境。其背景知识如下。</p>

<p>DEC公司推出的 PDP-11 ，体积小（被称为 mini）而且价格低（10000$），在大学中引起</p>

<p>了巨大的反响。为了方便移植，1969 年，Ken Thompson 开始写后来成为 Unix（与MULTICS相</p>

<p>对）的第一行代码。后来， Dennis Ritchie为这个新的操作系统设计了一种新的编程语言&ndash;</p>

<p>C 语言。</p>

<p>虽然 Unix 的效率不及原来的操作系统，但有三个突出的优点：</p>

<p>1. 可以任意移植到其他机器</p>

<p>2. 其中的 C 语言大大简化了编程</p>

<p>3. free。</p>

<p>终端（terminals）</p>

<p>Unix是可以在许多种机器上运行的操作系统，但人们又如何使用这些机器呢？他们是通过</p>

<p>哑终端来连接到这些机器，也就是用键盘、显示器及足够的 electronics（电子元件）组成的</p>

<p>机器与中央计算机(central computer)相连。在这些终端上，用户可以敲字符（teletypy），</p>

<p>这就是字符串&rsquo;tty&rsquo;表示终端设备文件，和&rsquo;getty&rsquo;命令的名称来历。</p>

<p>为了避免键盘布局的混乱，人们创建了一个含有所有不同终端特性的(capability)文件，</p>

<p>这就是&rsquo;termcap&rsquo;，参见&rsquo;/etc/termcap&rsquo;。linux 终端大多数用&rsquo;vt100&rsquo;或&rsquo;linux&rsquo;作为终端类型。</p>

<p>xterms</p>

<p>在八十年代初期，产生了X Window System 。九十年代早期，产生了XFree86 。</p>

<p>X Window 中一个很大的好处是可以运行多个虚拟(virtual)终端。甚至在 X Window 下就</p>

<p>有这么个应用程序&ndash;&lsquo;xterm&rsquo;。您将发现&rsquo;xterm&rsquo;和&rsquo;virtual terminal&rsquo;在很多情况下都是一样</p>

<p>的。其他的终端模拟器(terminal emulator)，如 rxvt、konsole、aterm、eterm、wterm 等等。</p>

<p>终端模拟器（又称为虚拟终端）通过伪(pseudo) tty 设备&ndash; pty 与系统相连，并且使用</p>

<p>自己的显示标准&ndash;xterm 。这导致不同的终端模拟器可能在一些按键或程序上存在细小的差别，</p>

<p>这取决于模拟器多大程度上遵守了&rsquo;xterm&rsquo;的显示标准。</p>

<p>shells</p>

<p>shell是用户和linux（或者更准确的说，是你和Linux内核）之间的接口程序。 你</p>

<p>在提示符下输入的每个命令都由shell先解释然后传给linux内核。</p>

<p>为了在终端中运行程序，需要 shell 。shell 是操作系统的一部分，用来与用户打交道，</p>

<p>并且可以用来协调各个命令。</p>

<p>第一个真正的 Unix shell &ndash; &lsquo;sh&rsquo;，亦称为&rsquo;Bourne shell&rsquo;，诞生于 1975 年， 作者是</p>

<p>Steve Bourne 。很快，出现了其他 shell ，如基于原始&rsquo;Bourne shell&rsquo;的&rsquo;ksh&rsquo;、&rsquo;zsh&rsquo;，后</p>

<p>者常用作专属 Unixes 系统中的标准 shell ；也有一些从 C 语言中衍生出来的 shell ， 如</p>

<p>&lsquo;csh&rsquo;或&rsquo;tcsh&rsquo;。</p>

<p>在 linux 中，标注的 shell 是&rsquo;bash&rsquo;，即 the GNU Bourne-Again Shell 。这个 shell</p>

<p>功能非常强大，压缩的 man page 就有 50 KB 。</p>

<p>Shell 起步</p>

<p>首先，有一点小说明：在平常应用中，建议您不要用&rsquo;root&rsquo;帐号运行 shell ， 如果您还</p>

<p>是新手，这一点尤其要注意。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果</p>

<p>是&rsquo;root&rsquo;，那就不同了，只要敲几个字母，就可能导致灾难性后果。</p>

<p>当您登入系统或打开一个 xterm 窗口，首先看到的是提示符(prompt)。Red Hat linux</p>

<p>的标准提示符包括了您的用户名、登入的主机名（没有设置的话，是&rsquo;localhost&rsquo;）、 当前所</p>

<p>在的目录(working directory)、提示符号：</p>

<p>[tom@belbo tom]$</p>

<p>我以用户名&rsquo;tom&rsquo;登入名为&rsquo;belbo&rsquo;的主机，当前在我的 home 目录&ndash;&lsquo;/home/tom&rsquo;中。</p>

<p>&lsquo;root&rsquo;的提示符：</p>

<p>[root@belbo root]#</p>

<p>除了不同的用户名外，提示符号由&rsquo;$&lsquo;变成了&rsquo;#&lsquo;。根据 Bourne shell 的传统，普通用户</p>

<p>的提示符以&rsquo;$&lsquo;结尾，而超级用户用&rsquo;#&lsquo;。</p>

<p>提示符的每个部分都可以定制，您在后面将有更深的了解。</p>

<p>要运行命令的话，您只要在提示符后敲进命令，然后在按 键。shell将在其路径</p>

<p>中（详情见后）搜索这个命令，找到以后就运行，并在终端里输出相应的结果（如果有的话），</p>

<p>命令结束后，再给出新的提示符：</p>

<p>[tom@belbo tom]$ whoami</p>

<p>tom</p>

<p>[tom@belbo tom]$</p>

<p>当您敲 ENTER 时，光标(cursor)在哪里并不要紧，因为 shell 总是会整行地读取。</p>

<p>基本的命令有：&rsquo;ls&rsquo;（list directory ，列出目录内容）、&rsquo;cp&rsquo;（copy ，复制）、&rsquo;mv&rsquo;</p>

<p>（move / rename ，移动／重命名），&rsquo;cd &lsquo;（change directory ，改变目录），这些命令后</p>

<p>面都可以跟上一帮可选项，这方面 man page 有详细的介绍（man ls, man mv 等等）。</p>

<p>下面简单介绍一下几个术语(terminology)。</p>

<p>命令可能带一些可选项（options）、参数（arguments）：</p>

<p>mv -i file dir</p>

<p>其中&rsquo;-i&rsquo;是命令&rsquo;mv&rsquo;的一个可选项，而&rsquo;file&rsquo;和&rsquo;dir&rsquo;则是参数。 所有可选项在该命令的</p>

<p>man page 都中有详细的介绍（此例中用 man mv），而参数则由您提供。可选项决定命令如何</p>

<p>工作，而参数则用于确定命令作用的目标。</p>

<p>第二篇：自动补齐／命令行的历史记录／编辑命令行／可用的 Shell 快捷方式</p>

<p>Unix （及后继者 linux）在命令行下面诞生，因此，Unix 中的命令行有许多非常实用的</p>

<p>功能。</p>

<p>自动补齐</p>

<p>如何用&rsquo;cd&rsquo;（改变目录，change directory）最快地从您当前所在的 home 目录跳到</p>

<p>&rsquo;/usr/src/redhat/&lsquo;呢？</p>

<p>cd /usrr</p>

<p>这称为&rsquo;命令行自动补齐&rsquo;(automatic command line completion)， 这在平常应用中是不</p>

<p>可缺少的。让我们仔细看看这个例子：</p>

<p>cd /u</p>

<p>扩展成了 cd /usr/ ，很简单吧。下面的</p>

<p>cd /usr</p>

<p>扩展为 cd /usr/src/ 。</p>

<p>如果您只敲了cd /us， &lsquo;/usr&rsquo;下匹配的（&rsquo;cd /u<em>/s</em>&lsquo;）三个子目录将列出供</p>

<p>您选择：&rsquo;/usr/sbin&rsquo;、&rsquo;/usr/share&rsquo;和&rsquo;/usr/src&rsquo;。</p>

<p>因此， 键可以很方便地用于根据前几个字母，来查找匹配的文件或子目录。比如，</p>

<p>ls /usr/bin/zip 将列出所有&rsquo;/usr/bin&rsquo;下面，以字符串&rsquo;zip&rsquo;开头的文件或子目录。当</p>

<p>然，完成这类任务还有更厉害的命令，但这个方法确实很管用。</p>

<p>另外，碰到长文件名时就显得特别方便。假设您要安装一个名为</p>

<p>&lsquo;boomshakalakwhizbang-4.6.4.5-i586.rpm&rsquo;的 RPM 包，您输入 rpm -i boom ，如果目</p>

<p>录下没有其他文件能够匹配，那 shell 就会自动帮忙补齐。</p>

<p>cd /usrl</p>

<p>将扩展成 cd /usr/src/linux ，并等待继续。&rsquo;/usr/src&rsquo;中有两个匹配的目录：</p>

<p>&rsquo;/usr/src/linux-[&hellip;]&lsquo;、&rsquo;/usr/src/linux&rsquo;。如何告诉 shell 您想要后面的那个呢？ 只要</p>

<p>跟一个斜线（/ ，slash），就可以选择后面的那个了。</p>

<p>假如您不确定是&rsquo;/usr/src/linux/Documentation&rsquo;还是&rsquo;/usr/src/linux/documentation&rsquo;。</p>

<p>而您知道，linux 是区分大小写的。如果已经仔细读过前面部分的话，您想到可以用：</p>

<p>cd /usrl/d</p>

<p>扩展成了&rsquo;/usr/src/linux/drivers/&lsquo;，因此应该是&rsquo;Documentation&rsquo;(大写的&rsquo;D&rsquo;)。</p>

<p>这种补齐对命令也有效：</p>

<p>[tom@belbo tom]$ gre</p>

<p>grecord grefer grep</p>

<p>[tom@belbo tom]$ gre</p>

<p>在这里 shell 将列出所有以字符串&rsquo;gre&rsquo;开头的已知命令。</p>

<p>命令行的历史记录</p>

<p>通过按向上方向键，您可以向后遍历近来在该控制台下输入的命令。用向下方向键可以向</p>

<p>前遍历。与 SHIFT 键连用的话，您还可以遍历以往在该控制台中的输出。 您也可以编辑旧的</p>

<p>命令，然后再运行。</p>

<p>按 后，shell 就进入&rdquo;reverse-i(ncremental)-search&rdquo;（向后增量搜索）模式。</p>

<p>现在输入您要找的命令的首字母：</p>

<p>(reverse-i-search)`&rsquo;:. 敲入 &lsquo;i&rsquo;可能会变成：</p>

<p>(reverse-i-search)`i&rsquo;: isdnctrl hangup ippp0</p>

<p>如果您再按 键，上面的命令将再次执行。而如果您按了向右、向左方向键或</p>

<p>，上面的命令将回到普通的命令行，这样您就可以进行适当编辑。</p>

<p>编辑命令行</p>

<p>通过光标和功能键（Home、End 等键），您可以浏览并编辑命令行，如果您需要，还可以</p>

<p>用键盘的快捷方式来完成一般的编辑：</p>

<p>CTRL k ： 删除从光标到行尾的部分</p>

<p>CTRL u ： 删除从光标到行首的部分</p>

<p>ALT d ： 删除从光标到当前单词结尾的部分</p>

<p>CTRL w ： 删除从光标到当前单词开头的部分</p>

<p>CTRL a ： 将光标移到行首</p>

<p>CTRL e ： 将光标移到行尾</p>

<p>ALT a ： 将光标移到当前单词头部</p>

<p>ALT e ： 将光标移到当前单词尾部</p>

<p>CTRL y ： 插入最近删除的单词</p>

<p>!$ ： 重复前一个命令最后的参数。</p>

<p>例如：您用命令 mkdir peter/pan/documents/tinkerbell 新建了一个目录，现在您向用</p>

<p>命令&rsquo;cd&rsquo;进入该目录，您可以用 cd !$，shell 将把前一个命令&rsquo;mkdir&rsquo;的参数添加到现在的</p>

<p>&lsquo;cd&rsquo;后面。</p>

<p>当您更深入了解linux后，将看到这些快捷方式在其他应用程序下输入时，有时也有效，</p>

<p>比如，在浏览器中的输入框中。</p>

<p>可用的 Shell 快捷方式</p>

<p>Red Hat linux 带有不少快捷方式，其中一部分是 bash 原来就有的，而还有一些则是为</p>

<p>您预先设置的（在后面您将看到如何设置）。</p>

<p>由于 home 目录是每位用户的活动中心，许多 Unix 对此有特殊的快捷方式。</p>

<p>&lsquo;~&lsquo;就是您的 home 目录的简写形式。我们假设您在其他目录， 想把一个名为&rsquo;sometext&rsquo;</p>

<p>的文件复制到您 home 目录下的 &lsquo;docs&rsquo;子目录中。除了输入：</p>

<p>cp sometext /home/myusername/docs</p>

<p>您还可以用简写：</p>

<p>cp sometext ~/docs</p>

<p>理论上，这也可以应用在命令&rsquo;cd&rsquo;上。无论当前路径在哪里，cd ~ 将回到您的home目录。</p>

<p>其实还可以简化，只要键入 cd ，就可以返回 home 目录了。</p>

<p>Red Hat linux 为您提供了一些预先设置的快捷方式（称为&rsquo;别名&rsquo;，aliases），比如：</p>

<p>ll ：将执行&rsquo;ls -l -k&rsquo;（以长格式列出目录内容，包括一些文件属性，并以 KB 而不是 byte 为单位显示文件大小）</p>

<p>ls ：将执行&rsquo;ls -F &ndash;color=auto&rsquo;（列出目录内容，加上文件类型标识，并使用颜色）</p>

<p>现在，您应该对 shell 及一些快捷方式有了进一步的了解，下面我们来看看除了应用一些简单的命令，shell 还能作什么。</p>

<p>第三篇：命令的排列／命令的任务调度／命令的替换</p>

<p>命令的排列</p>

<p>现在您将看到一些常用的命令排列。您可能想在一行中给出所有命令，然后就可以把注意</p>

<p>力转移到其他地方。没问题，shell 允许您在不同的命令之间，放上特殊的排列字符</p>

<p>(queuing characters) 。这儿将介绍最常用的两种。</p>

<p>请注意，为了看起来更清楚，我在这些字符两旁加了空格。而在实际应用中，您不一定要</p>

<p>这么做，&rsquo;ls -a ; du -hs&rsquo;和&rsquo;ls -a;du -hs&rsquo;的效果是一样的。</p>

<p>command1 ; command2</p>

<p>先执行 command1 ，不管 command1 是否出错，接下来执行 command2 。</p>

<p>例如：</p>

<p>ls -a ; du -hs</p>

<p>将先在屏幕上列出目录中的所有内容，然后列出所有目录及其子目录所占磁盘大小。</p>

<p>command1 &amp;&amp; command2</p>

<p>只有当 command1 正确运行完毕后，才执行 command2 。</p>

<p>例如：</p>

<p>ls -a bogusdir &amp;&amp; du -hs</p>

<p>将返回 ls: bogusdir: No such file or directory ， 而&rsquo;du&rsquo;则根本没有运行（这是因</p>

<p>为您没有&rsquo;bogusdir&rsquo;目录）。如果您将符号换成了&rsquo;;&lsquo;，&rsquo;du&rsquo;将被执行。</p>

<p>为了进一步说明&rsquo;;&lsquo;和&rsquo;&amp;&amp;&lsquo;的区别，及一般命令排列的用处，下面举一个经典的例子：linux</p>

<p>内核的编译和安装。</p>

<p>要编译、安装 linux ，您需要执行一串命令：&rsquo;make dep&rsquo;、&rsquo;make clean&rsquo;、&rsquo;make bzImage&rsquo;、</p>

<p>&lsquo;make modules&rsquo;、&rsquo;make modules_install&rsquo;和&rsquo;make install&rsquo;。如果要等一个命令完成后，再</p>

<p>输入下一个，再等，再输入，……，那就太麻烦了。另一方面，每个命令只有当前面的命令都</p>

<p>正确执行完毕后，才能开始执行。如果您用&rsquo;;&lsquo;来排列命令，则即使有命令执行失败， 后面的</p>

<p>也照常运行，最后，您可能在&rsquo;/boot&rsquo;目录下得到一个有问题的内核映像(image)。而用&rsquo;&amp;&amp;&lsquo;：</p>

<p>make dep &amp;&amp; make clean &amp;&amp; make bzImage &amp;&amp; make modules &amp;&amp; make modules_install
&amp;&amp; make install</p>

<p>不需要中途打断，就可以编译内核及其模块，并完成后面的安装。</p>

<p>命令的任务调度</p>

<p>当您在终端里运行一个命令或开启一个程序时，终端要等到命令或程序运行完毕后，才能</p>

<p>再被使用。在 Unix 中，我们称这样的命令或程序在前台(foreground)运行。如果您想在终端</p>

<p>下运行另一个命令，则需要再打开一个新的终端。</p>

<p>但这里还有一个更优雅的办法，称为任务调度(jobbing)或后台(backgrounding)。当您运</p>

<p>用任务的调度或将命令置于后台，终端就立即解放了，这样一来，终端立即就可以接受新的输</p>

<p>入。为实现这样的目的，您只需在命令后面添加一个 &amp; ：</p>

<p>gqview &amp;</p>

<p>告诉 shell 将图片查看器&rsquo;GQview&rsquo;放到后台去执行（即当成 job 来运行）。</p>

<p>命令 jobs 将告诉您，在这个终端窗口中，运行着哪些命令与程序：</p>

<p>jobs</p>

<p>[1]+ Running gqview &amp;</p>

<p>当您要关闭终端窗口时，这一点就很重要，因为关闭终端将导致所有在其中运行的任务都</p>

<p>将被中止，在此例中，如果您关闭了终端，由这个终端开启的 GQview 程序也将被关闭。</p>

<p>但如何将前台运行的一个程序放到后台去？没问题：</p>

<p>gqview</p>

<p>[2]+ Stopped gqview</p>

<p>bg</p>

<p>[2]+ gqview &amp;</p>

<p>组合键 将挂起终端中正在运行的程序，然后您就可以用 bg 命令将其放到后台</p>

<p>去执行。</p>

<p>请注意，在后台运行图形应用程序有时候是有用处的，这样可以在终端下显示这个程序的</p>

<p>出错信息，虽然这对您可能没有直接的帮助，当如果碰到了麻烦，向别人询问时，这些出错提</p>

<p>示就有用武之地了。</p>

<p>一些图形程序，很可能还处在测试期(Beta)，尽管在后台执行，也会在终端中输出一些信</p>

<p>息。如果您对此不满，可以用下面命令：</p>

<p>command &amp;&gt;/dev/null &amp;</p>

<p>这不仅将程序送到后台执行，还将其输出发到&rsquo;/dev/null&rsquo;文件。 &lsquo;/dev/null&rsquo;是系统的</p>

<p>&ldquo;碎纸机&rdquo; (shredder)，所有送到那里的信息都将消失殆尽。</p>

<p>命令的替换</p>

<p>命令替换(Command substitution)是一项很实用的功能。我们假设，您想看看 XFree86</p>

<p>文档中的 &lsquo;README.mouse&rsquo;文件，但您不知道这个文件的位置。但您是位机灵的用户，已经听说</p>

<p>了&rsquo;locate&rsquo;命令，也安装了&rsquo;slocate&rsquo;包，您就可以用：</p>

<p>locate README.mouse</p>

<p>发现那个文件在&rsquo;/usr/X11R6/lib/X11/doc&rsquo;。现在您就可以在终端里用&rsquo;less&rsquo;或在文件管</p>

<p>理器中进入那个目录然后读取文件。而命令替换可以给您带来一些便捷：</p>

<p>less $(locate README.mouse)</p>

<p>一步到位。命令&rsquo;locate README.mouse&rsquo;的输出(= /usr/X11R6/lib/X11/doc/README.mouse)</p>

<p>作为&rsquo;less&rsquo;的参数，然后就可以显示文件内容了。</p>

<p>这种机制的语法是：</p>

<p>command1 $(command2)</p>

<p>除了&rsquo;$( )&lsquo;，您还可以用后引号(backquote)：</p>

<p>command1 <code>command2</code></p>

<p>这样虽然可以减少输入，但可读性差，而且很容易就和没有替换功能的一般单引号混淆。</p>

<p>这里有另外一个例子。我们假设，您打算结束一个名为&rsquo;rob&rsquo;的程序。您先得用命令</p>

<p>&lsquo;pidof&rsquo;找出相应的进程号(Process ID)，然后以这个 PID 为参数，运行&rsquo;kill&rsquo;命令，这样就</p>

<p>可以结束&rsquo;rob&rsquo;程序。除了用：</p>

<p>pidof rob</p>

<p>567</p>

<p>kill 567</p>

<p>您还可以试试：</p>

<p>kill <code>pidof rob</code></p>

<p>怎么样，效率有所提高吧？</p>

<p>在下一篇中，我将接着介绍 shell 的另外两种实用的机制：文件名匹配、输出重定向。</p>

<p>第四篇：文件名匹配／输出重定向</p>

<p>文件名匹配</p>

<p>文件名匹配使得您不必一一写出名称，就可以指定多个文件。您将用到一些特殊的字符，</p>

<p>称为通配符(wildcards)。</p>

<p>假设您想用&rsquo;rm&rsquo;命令删除目录下所有以字符串&rsquo;.bak&rsquo;结尾的文件。除了在&rsquo;rm&rsquo;后跟上所</p>

<p>有文件名作为参数，您还可以用通配符&rsquo;*&lsquo;：</p>

<p>rm *.bak</p>

<p>&lsquo;*&lsquo;可匹配一个或多个字符。在本例中， 您告诉 shell 将命令&rsquo;rm&rsquo;的参数扩展到&rdquo;所有以</p>

<p>&lsquo;*.bak&rsquo;结尾的文件&rdquo;，shell 就将扩展后的参数告诉&rsquo;rm&rsquo;命令。</p>

<p>您将看到，shell 在命令执行前，就将读取并解释命令行。正是因为这个，您才可以将通</p>

<p>配符用于 shell 命令的参数中。</p>

<p>让我们更进一步来认识通配符&rsquo;*&lsquo;。假定您有个目录，其中含文件&rsquo;124.bak&rsquo;、&rsquo;346.bak&rsquo;</p>

<p>及&rsquo;583.bak&rsquo;。您想只保留文件&rsquo;583.bak&rsquo;，可以用：</p>

<p>rm <em>4</em>.bak</p>

<p>shell 就将&rsquo;<em>4</em>.bak&rsquo;扩展成&rdquo;所有含&rsquo;4&rsquo;并以&rsquo;.bak&rsquo;结尾的字符串&rdquo;。</p>

<p>注意到 rm 4*.bak 无法工作，因为这匹配的是以&rsquo;4&rsquo;开头的文件。由于目录中没有这样的</p>

<p>文件，shell 将这个模式扩展为空的字符串，故&rsquo;rm&rsquo;将返回出错信息：</p>

<p>rm: cannot remove `4*.bak&rsquo;: No such file or directory</p>

<p>如果您想保留文件&rsquo;346.bak&rsquo;，而删除&rsquo;124.bak&rsquo;和&rsquo;583.bak&rsquo;。这看起来有些难度， 因为</p>

<p>被删文件的名称除了后缀其他都不同。但幸运的是，您可以用不含有来指定文件：</p>

<p>rm *[!6].bak</p>

<p>这将被读为：除了以&rsquo;6.bak&rsquo;结尾的文件，删除其他所有以&rsquo;.bak&rsquo;结尾的文件。 您必须将</p>

<p>取反号(negation sign)与取反字符（这里是 6）放到括号中，不然的话，shell 会将惊叹号</p>

<p>(exclamation mark)解释成历史记录替换的开始(the beginning of a history substitution)。</p>

<p>取反号在本篇介绍的所有匹配模式中都有效。</p>

<p>请注意：通配符&rsquo;*&lsquo;与取反号连用，很容易产生问题。猜猜</p>

<p>rm <em>[!6]</em>.bak</p>

<p>表示什么？这个命令将删除所有文件，甚至包括名称中包含&rsquo;6&rsquo;的文件。如果您将通配符</p>

<p>&lsquo;*&lsquo;放到了取反号前面和后面，实际上取反号将失效，因为 shell 将其解释为&rdquo;所有名称中任</p>

<p>何位置都不含该字符的文件&rdquo;。在我们的例子里，只有文件&rsquo;666.bak&rsquo;不符合该模式。</p>

<p>第二个通配符是问号(question mark)：&rsquo;?&lsquo;。在匹配时，一个问号只能代表一个字符。为</p>

<p>了示范其用途，我们在上例的假设中添加两个新文件：&rsquo;311.bak~&lsquo;和&rsquo;some.text&rsquo;。现在， 列</p>

<p>出所有在点号后有四个字符的文件：</p>

<p>ls *.????</p>

<p>问号通配符能够有效地避免上面提到的&rsquo;取反号陷阱&rsquo;(negation trap)：</p>

<p>rm <em>[!4]?.</em></p>

<p>将扩展成&rdquo;所有除了点号前倒数第二个字符为&rsquo;4&rsquo;的文件&rdquo;，也就是只保留文件&rsquo;346.bak&rsquo;。</p>

<p>您可能会问，有没有其他匹配方式？到目前为止，您只看到了在指定位置匹配唯一字符的</p>

<p>方法。但其实您也可以这样：</p>

<p>ls [13]*</p>

<p>将列出所有以字符&rsquo;1&rsquo;或&rsquo;3&rsquo;开头的文件；在我们的例子中，文件&rsquo;124.bak&rsquo;、&rsquo;311.bak~&rsquo;</p>

<p>和&rsquo;346.bak&rsquo;匹配。注意到您必须用中括号将匹配的模式括起来，否则模式只匹配以字符串&rsquo;13&rsquo;</p>

<p>开头的文件。</p>

<p>接下来，您将高兴地看到还可以定义匹配的范围：</p>

<p>ls <em>[3-8]?.</em></p>

<p>将列出所有点号前倒数第二个字符落在&rsquo;3&rsquo;到&rsquo;8&rsquo;范围的文件。在我们的例子中，匹配的文</p>

<p>件是&rsquo;346.bak&rsquo;和&rsquo;583.bak&rsquo;。</p>

<p>引用 shell 的特殊字符</p>

<p>但是，上面的那些机制存在一个缺点：shell 总在命令执行前，试着进行扩展。有时候，</p>

<p>会变得很棘手：</p>

<p>文件名包含特殊字符。</p>

<p>假设您在那个目录中还有一个名为&rsquo;!56.bak&rsquo;的文件。下面试图进行模式匹配：</p>

<p>rm !*</p>

<p>rm</p>

<p>rm: too few arguments</p>

<p>shell 将&rsquo;!*&lsquo;解释成历史记录的替换（加入前一个命令的所有参数），而不是匹配方式。</p>

<p>命令本身带特殊字符作参数。</p>

<p>一些 linux 下的命令行工具，比如 (e)grep、sed、awk、find 及 locate ，都使用自己</p>

<p>的正则表达式(regular expressions)。这些表达式与模式匹配看起来惊人地相似， 但在某些</p>

<p>地方又有所不同。</p>

<p>但为了使这些特殊命令生效，shell 就不能先将其当作模式匹配来解释：</p>

<p>find . -name [1-9]* -print</p>

<p>find: paths must precede expression</p>

<p>应该是：</p>

<p>find . -name &lsquo;[1-9]*&rsquo; -print</p>

<p>./346.bak</p>

<p>./124.bak</p>

<p>./583.bak</p>

<p>./311.bak~</p>

<p>您可以通过反斜线(back slash)来引用特殊字符，比如 ! 、$ 、? 或空格：</p>

<p>ls !*</p>

<p>!56.bak</p>

<p>或者用（单）引号：</p>

<p>ls &lsquo;!&rsquo;*</p>

<p>!56.bak</p>

<p>请注意，要看清楚引号应该放在什么位置。命令 ls &lsquo;!<em>&rsquo; 将查找名为&rsquo;!</em>&lsquo;的文件， 这是</p>

<p>由于通配符也在引号间，所以只能依照字面来解释。</p>

<p>输出重定向</p>

<p>Unix 的理念是汇集许多小程序，每个东东都有特殊的专长。 复杂的任务不是由大型软件</p>

<p>完成，而是运用 shell 的机制，组合许多小程序共同完成。重定向就在其中发挥着重要的作用。</p>

<p>在多个命令间重定向</p>

<p>这要通过管道(pipe)，由管道符号｜来标识。语法是：</p>

<p>command1 | command2 | command3 等等</p>

<p>这种格式您一定已经见到过了。管道经常将一个程序的输出送到&rsquo;more&rsquo;或&rsquo;less&rsquo;来阅读。</p>

<p>ls -l | less</p>

<p>其中，第一个命令提供目录内容，第二个则将其以翻页的方式显示。更复杂的例子如：</p>

<p>rpm -qa | grep ^x | less</p>

<p>第一个命令给出所有已安装的 RPM 包，第二个则将其过滤(filter：&rsquo;grep&rsquo;)，只剩下以</p>

<p>&rsquo;^x&rsquo;开头的包，第三个命令则将结果以翻页的方式显示。</p>

<p>重定向至文件</p>

<p>有时，您希望将命令的输出结果保存到文件中，或以文件内容作为命令的参数。这可以通</p>

<p>过&rsquo;&gt;&lsquo;和&rsquo;command &gt; file</p>

<p>将 command 的输出保存到 file 中，这将覆盖 file 中的内容：</p>

<p>ls &gt; dirlist</p>

<p>将当前目录的内容保存到&rsquo;dirlist&rsquo;文件。</p>

<p>command &lt; file</p>

<p>将 file 内容作为 command 的输入：</p>

<p>sort &lt; dirlist &gt; sdirlist</p>

<p>将文件&rsquo;dirlist&rsquo;的内容送到命令&rsquo;sort&rsquo;，然后再将排序后的结果送到文件&rsquo;sdirlist&rsquo;。当然，您也可以一步到位：</p>

<p>ls | sort &gt; sdirlist</p>

<p>一种特殊的方式是&rsquo;command 2&gt; file&rsquo;。这将 command 执行的出错信息送到 file 中。这个您到时候会需要……</p>

<p>另一种操作符是&rsquo;&gt;&gt;&lsquo;，这将输出添加到已存在的文件中：</p>

<p>echo &ldquo;string&rdquo; &gt;&gt; file</p>

<p>将 string 加到文件 file 中。这是不打开文件而完成编辑的好办法！</p>

<p>但是，&rdquo;操作符都有一个重要的限制：</p>

<p>command &lt; file1 &gt; file1</p>

<p>将删除 file1 的内容，而</p>

<p>command &lt; file1 &gt;&gt; file1</p>

<p>却可以很好地工作，将加工过的 file1 内容加回到文件中。</p>

<p>熟知了许多 shell 的机制后， 您可能急着想知道如何来定制环境。在后面的两篇中，您</p>

<p>将得到这方面的启示。在最后一篇中，还有一段如何处理 shell 出错信息的常见问答(FAQ)，</p>

<p>及一些配置技巧。</p>

<p>第五篇：bash 配置文件／提示符／改变 $PATH</p>

<p>bash 配置文件</p>

<p>在您的 home 目录下，运行</p>

<p>ls .bash*</p>

<p>您将看到这些文件：</p>

<p>.bash_history ：记录了您以前输入的命令，</p>

<p>.bash_logout ：当您退出 shell 时，要执行的命令，</p>

<p>.bash_profile ：当您登入 shell 时，要执行的命令，</p>

<p>.bashrc ：每次打开新的 shell 时，要执行的命令。</p>

<p>请注意后两个的区别：&rsquo;.bash_profile&rsquo;只在会话开始时被读取一次，而&rsquo;.bashrc&rsquo;则每次</p>

<p>打开新的终端（如新的 xterm 窗口）时，都要被读取。按照传统，您得将定义的变量，如</p>

<p>PATH ，放到&rsquo;.bash_profile&rsquo;中，而象 aliases（别名）和函数之类，则放在&rsquo;.bashrc&rsquo;。 但</p>

<p>由于&rsquo;.bash_profile&rsquo;经常被设置成先读取&rsquo;.bashrc&rsquo;的内容，您如果图省事的话，就把所有配</p>

<p>置都放进&rsquo;.bashrc&rsquo;。</p>

<p>这些文件是每一位用户的设置。系统级的设置存储在&rsquo;/etc/profile&rsquo;、&rsquo;/etc/bashrc&rsquo; 及</p>

<p>目录&rsquo;/etc/profile.d&rsquo;下的文件中。但您得习惯用各自的配置文件：编辑不需要&rsquo;root&rsquo;权限，</p>

<p>还可以使您的设置更有个性。当系统级与用户级的设置发生冲突时，将采用用户的设置。</p>

<p>提示符</p>

<p>每次当您打开一个控制台(console)或 xterm 时，最先看到的就是提示符(prompt)，类似于：</p>

<p>account@hostname ~ $</p>

<p>在默认设置下，提示符将显示您的用户名、主机名（默认是&rsquo;localhost&rsquo;）、当前所在目录</p>

<p>（在 Unix 中，&rsquo;~&lsquo;表示您的 home 目录）。</p>

<p>按照传统，最后一个字符可以标识您是普通用户（$），还是&rsquo;root&rsquo;（#）。</p>

<p>您可以通过 $PS1 变量来设置提示符。命令</p>

<p>echo $PS1</p>

<p>将显示当前的设定。其中可用字符的含义在 man bash 的&rsquo;PROMPTING&rsquo;部分有说明。</p>

<p>如何才能完成理想的设置呢？对于健忘的初学者来讲，默认设定有些不友好，因为提示符</p>

<p>只显示当前目录的最后一部分。如果您看到象这样的提示符</p>

<p>tom@localhost bin $</p>

<p>您的当前目录可能是&rsquo;/bin&rsquo;、&rsquo;/usr/bin&rsquo;、&rsquo;/usr/local/bin&rsquo;及&rsquo;/usr/X11R6/bin&rsquo;。当然，</p>

<p>您可以用</p>

<p>pwd （输出当前目录，print working directory）</p>

<p>能不能叫 shell 自动告诉您当前目录呢？</p>

<p>当然可以。这里我将提到的设定，包括提示符，大都包含在文件&rsquo;/etc/bashrc&rsquo;中。 您可</p>

<p>以通过编辑各自 home 目录下的&rsquo;.bash_profile&rsquo;和&rsquo;.bashrc&rsquo;来改变设置。</p>

<p>在 man bash 中的&rsquo;PROMPTING&rsquo;部分，对这些参数(parameter)有详细说明。您可以加入一</p>

<p>些小玩意，如不同格式的当前时间，命令的历史记录号，甚至不同的颜色。</p>

<p>在&rsquo;~/.bashrc&rsquo;中，我喜欢的设定是：</p>

<p>PS1=&rdquo;</p>

<p>来自 “ ITPUB博客 ”
，链接：<a href="http://blog.itpub.net/8225414/viewspace-944902/，如需转载，请注明出处，否则将追究法律责任。">http://blog.itpub.net/8225414/viewspace-944902/，如需转载，请注明出处，否则将追究法律责任。</a></p>

<p>转载于:<a href="http://blog.itpub.net/8225414/viewspace-944902/">http://blog.itpub.net/8225414/viewspace-944902/</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>