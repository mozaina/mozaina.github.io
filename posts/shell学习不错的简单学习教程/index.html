<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell学习不错的简单学习教程 | 开发者问答集锦</title>
    <meta property="og:title" content="shell学习不错的简单学习教程 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell学习不错的简单学习教程">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E5%AD%A6%E4%B9%A0%E4%B8%8D%E9%94%99%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell学习不错的简单学习教程</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="shell脚本">shell脚本</h1>

<p>Shell
Script，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，毕竟它使用了Linux/Unix下的命令。</p>

<p>S hell
Script，Shell脚本与Windows/Dos下的批处理相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个程序文件，主要是方便管理员进行设置或者管理用的。但是它比Windows下的批处理更强大，比用其他编程程序编辑的程序效率更高，毕竟它使用了Linux/Unix下的命令。</p>

<p>换一种说法也就是，shell
script是利用shell的功能所写的一个程序，这个程序是使用纯文本文件，将一些shell的语法与指令写在里面，然后用正规表示法，管线命令以及数据流重导向等功能，以达到我想要的处理目的。</p>

<p>更明白的来说，shell
script就像早期dos年代的.bat，最简单的功能就是将许多指令汇整写一起，让使用者很容易的就能够一个操作执行多个命令，而shell
script更是提供了数组，循环，条件以及逻辑判断等重要功能，让使用者可以直接以shell来写程序，而不必使用类似C程序语言等传统程序编写的语法。</p>

<p>shell是什么呢？确切一点说，Shell就是一个命令行解释器，它的作用就是遵循一定的语法将输入的命令加以解释并传给系统。它为用户提供了一个向Linux发送请求以便运行程序的接口系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。
Shell本身是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言(就是你所说的shell脚本)。作为命令语言，它互动式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高阶语言中才具有的控制结构，包括循环和分支。它虽然不是
Linux系统内核的一部分，但它调用了系统内核的大部分功能来执行程序、创建文档并以并行的方式协调各个程序的运行。</p>

<p>Shell教程一</p>

<p>目录;</p>

<p>Shell简介</p>

<p>几种常见的Shell</p>

<p>Shell与编译型语言的差异</p>

<p>什么时候使用Shell</p>

<p>第一个Shell脚本</p>

<p>Shell变量</p>

<p>Shell特殊变量</p>

<p>Shell替换</p>

<p>Shell运算符</p>

<p>Shell注释</p>

<p>Shell字符串</p>

<p>Shell数组</p>

<p>Shell echo命令</p>

<p>shell printf命令</p>

<p>Shell if else语句</p>

<p>Shell case esac语句</p>

<p>Shell for循环</p>

<p>Shell while循环</p>

<p>Shell until循环</p>

<p>Shell跳出循环</p>

<p>Shell函数</p>

<p>Shell函数参数</p>

<p>Shell输入输出重定向</p>

<p>Shell文件包含</p>

<p>Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。</p>

<p>它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，shell是最重要的实用程序，深入了解和熟练掌握shell的特性极其使用方法，是用好Unix/Linux系统的关键。</p>

<p>可以说，shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。</p>

<p>注意：单独地学习 Shell 是没有意义的，请先参考Unix/Linux入门教程，了解 Unix/Linux 基础。</p>

<p>Shell有两种执行命令的方式：</p>

<p>· 交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。</p>

<p>· 批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。</p>

<p>Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。</p>

<p>Shell初学者请注意，在平常应用中，建议不要用 root 帐号运行 Shell 。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是
root，那就不同了，只要敲几个字母，就可能导致灾难性后果。</p>

<p>2</p>

<p>上面提到过，Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本。</p>

<p>Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。</p>

<h2 id="bash">bash</h2>

<p>bash是Linux标准默认的shell，本教程也基于bash讲解。bash由Brian Fox和Chet Ramey共同完成，是BourneAgain
Shell的缩写，内部命令一共有40个。</p>

<p>Linux使用它作为默认的shell是因为它有诸如以下的特色：</p>

<p>· 可以使用类似DOS下面的doskey的功能，用方向键查阅和快速输入并修改命令。</p>

<p>· 自动通过查找匹配的方式给出以某字符串开头的命令。</p>

<p>· 包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助。</p>

<h2 id="sh">sh</h2>

<p>sh 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。</p>

<h2 id="ash">ash</h2>

<p>ash shell 是由Kenneth
Almquist编写的，Linux中占用系统资源最少的一个小shell，它只包含24个内部命令，因而使用起来很不方便。</p>

<h2 id="csh">csh</h2>

<p>csh 是Linux比较大的内核，它由以William
Joy为代表的共计47位作者编成，共有52个内部命令。该shell其实是指向/bin/tcsh这样的一个shell，也就是说，csh其实就是tcsh。</p>

<h2 id="ksh">ksh</h2>

<p>ksh 是Korn shell的缩写，由Eric
Gisin编写，共有42条内部命令。该shell最大的优点是几乎和商业发行版的ksh完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。</p>

<p>注意：bash是 Bourne Again Shell 的缩写，是linux标准的默认shell ，它基于Bourne shell，吸收了C
shell和Korn shell的一些特性。bash完全兼容sh，也就是说，用sh写的脚本可以不加修改的在bash中执行。</p>

<p>3</p>

<p>大体上，可以将程序设计语言可以分为两类：编译型语言和解释型语言。</p>

<h2 id="编译型语言">编译型语言</h2>

<p>很多传统的程序设计语言，例如Fortran、Ada、Pascal、C、C++和Java，都是编译型语言。这类语言需要预先将我们写好的源代码(source
code)转换成目标代码(object code)，这个过程被称作“编译”。</p>

<p>运行程序时，直接读取目标代码(object code)。由于编译后的目标代码(object
code)非常接近计算机底层，因此执行效率很高，这是编译型语言的优点。</p>

<p>但是，由于编译型语言多半运作于底层，所处理的是字节、整数、浮点数或是其他机器层级的对象，往往实现一个简单的功能需要大量复杂的代码。例如，在C++里，就很难进行“将一个目录里所有的文件复制到另一个目录中”之类的简单操作。</p>

<h2 id="解释型语言">解释型语言</h2>

<p>解释型语言也被称作“脚本语言”。执行这类程序时，解释器(interpreter)需要读取我们编写的源代码(source
code)，并将其转换成目标代码(object code)，再由计算机运行。因为每次执行程序都多了编译的过程，因此效率有所下降。</p>

<p>使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象；缺点是它们的效率通常不如编译型语言。不过权衡之下，通常使用脚本编程还是值得的：花一个小时写成的简单脚本，同样的功能用C或C++来编写实现，可能需要两天，而且一般来说，脚本执行的速度已经够快了，快到足以让人忽略它性能上的问题。脚本编程语言的例子有awk、Perl、Python、Ruby与Shell。</p>

<p>4</p>

<p>因为Shell似乎是各UNIX系统之间通用的功能，并且经过了POSIX的标准化。因此，Shell脚本只要“用心写”一次，即可应用到很多系统上。因此，之所以要使用Shell脚本是基于：</p>

<p>· 简单性：Shell是一个高级语言；通过它，你可以简洁地表达复杂的操作。</p>

<p>· 可移植性：使用POSIX所定义的功能，可以做到脚本无须修改就可在不同的系统上执行。</p>

<p>· 开发容易：可以在短时间内完成一个功能强大又妤用的脚本。</p>

<p>但是，考虑到Shell脚本的命令限制和效率问题，下列情况一般不使用Shell：</p>

<p>1. 资源密集型的任务，尤其在需要考虑效率时（比如，排序，hash等等）。</p>

<p>2. 需要处理大任务的数学操作，尤其是浮点运算，精确运算，或者复杂的算术运算（这种情况一般使用C++或FORTRAN 来处理）。</p>

<p>3. 有跨平台（操作系统）移植需求（一般使用C 或Java）。</p>

<p>4. 复杂的应用，在必须使用结构化编程的时候（需要变量的类型检查，函数原型，等等）。</p>

<p>5. 对于影响系统全局性的关键任务应用。</p>

<p>6. 对于安全有很高要求的任务，比如你需要一个健壮的系统来防止入侵、破解、恶意破坏等等。</p>

<p>7. 项目由连串的依赖的各个部分组成。</p>

<p>8. 需要大规模的文件操作。</p>

<p>9. 需要多维数组的支持。</p>

<p>10. 需要数据结构的支持，比如链表或数等数据结构。</p>

<p>11. 需要产生或操作图形化界面 GUI。</p>

<p>12. 需要直接操作系统硬件。</p>

<p>13. 需要 I/O 或socket 接口。</p>

<p>14. 需要使用库或者遗留下来的老代码的接口。</p>

<p>15. 私人的、闭源的应用（shell 脚本把代码就放在文本文件中，全世界都能看到）。</p>

<p>如果你的应用符合上边的任意一条，那么就考虑一下更强大的语言吧——或许是Perl、Tcl、Python、Ruby——或者是更高层次的编译语言比如C/C++，或者是Java。即使如此，你会发现，使用shell来原型开发你的应用，在开发步骤中也是非常有用的。</p>

<p>5</p>

<p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell
脚本，扩展名就用php好了。</p>

<p>输入一些代码：</p>

<p>1. #!/bin/bash</p>

<p>2. echo &ldquo;Hello World !&rdquo;</p>

<p>“#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。</p>

<p>运行Shell脚本有两种方法。</p>

<h2 id="作为可执行程序">作为可执行程序</h2>

<p>将上面的代码保存为test.sh，并 cd 到相应目录：</p>

<p>chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本</p>

<p>注意，一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin,
/sbin,
/usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p>

<p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p>

<p>这里的&rdquo;系统&rdquo;，其实就是shell这个应用程序（想象一下Windows
Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p>

<h2 id="作为解释器参数">作为解释器参数</h2>

<p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p>

<p>/bin/sh test.sh/bin/php test.php</p>

<p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>

<p>再看一个例子。下面的脚本使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. # Author : mozhiyan</p>

<p>4. # Copyright &copy; <a href="http://see.xidian.edu.cn/cpp/linux/">http://see.xidian.edu.cn/cpp/linux/</a></p>

<p>5. # Script follows here:</p>

<p>6.</p>

<p>7. echo &ldquo;What is your name?&rdquo;</p>

<p>8. read PERSON</p>

<p>9. echo &ldquo;Hello, $PERSON&rdquo;</p>

<p>运行脚本：</p>

<p>chmod +x ./test.sh$./test.shWhat is your name?mozhiyanHello, mozhiyan$</p>

<p>6</p>

<p>Shell支持自定义变量。</p>

<h2 id="定义变量">定义变量</h2>

<p>定义变量时，变量名不加美元符号（$），如：</p>

<p>1. variableName=&ldquo;value&rdquo;</p>

<p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>

<p>· 首个字符必须为字母（a-z，A-Z）。</p>

<p>· 中间不能有空格，可以使用下划线（_）。</p>

<p>· 不能使用标点符号。</p>

<p>· 不能使用bash里的关键字（可用help命令查看保留关键字）。</p>

<p>变量定义举例：</p>

<p>1. myUrl=&ldquo;<a href="http://see.xidian.edu.cn/cpp/linux/&quot;">http://see.xidian.edu.cn/cpp/linux/&quot;</a></p>

<p>2. myNum=100</p>

<h2 id="使用变量">使用变量</h2>

<p>使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，如：</p>

<p>1. your_name=&ldquo;mozhiyan&rdquo;</p>

<p>2. echo $your_name</p>

<p>3. echo ${your_name}</p>

<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>

<p>1. for skill in Ada Coffe Action Java</p>

<p>2. do</p>

<p>3.  echo &ldquo;I am good at ${skill}Script&rdquo;</p>

<p>4. done</p>

<p>如果不给skill变量加花括号，写成echo &ldquo;I am good at
$skillScript&rdquo;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>

<p>推荐给所有变量加上花括号，这是个好的编程习惯。</p>

<h2 id="重新定义变量">重新定义变量</h2>

<p>已定义的变量，可以被重新定义，如：</p>

<p>1. myUrl=&ldquo;<a href="http://see.xidian.edu.cn/cpp/linux/&quot;">http://see.xidian.edu.cn/cpp/linux/&quot;</a></p>

<p>2. echo ${myUrl}</p>

<p>3.</p>

<p>4. myUrl=&ldquo;<a href="http://see.xidian.edu.cn/cpp/shell/&quot;">http://see.xidian.edu.cn/cpp/shell/&quot;</a></p>

<p>5. echo ${myUrl}</p>

<p>这样写是合法的，但注意，第二次赋值的时候不能写
$myUrl=&ldquo;<a href="http://see.xidian.edu.cn/cpp/shell/&quot;，使用变量的时候才加美元符（$）。">http://see.xidian.edu.cn/cpp/shell/&quot;，使用变量的时候才加美元符（$）。</a></p>

<h2 id="只读变量">只读变量</h2>

<p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>

<p>下面的例子尝试更改只读变量，结果报错：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. myUrl=&ldquo;<a href="http://see.xidian.edu.cn/cpp/shell/&quot;">http://see.xidian.edu.cn/cpp/shell/&quot;</a></p>

<p>4. readonly myUrl</p>

<p>5. myUrl=&ldquo;<a href="http://see.xidian.edu.cn/cpp/danpianji/&quot;">http://see.xidian.edu.cn/cpp/danpianji/&quot;</a></p>

<p>运行脚本，结果如下：</p>

<p>/bin/sh: NAME: This variable is read only.</p>

<h2 id="删除变量">删除变量</h2>

<p>使用 unset 命令可以删除变量。语法：</p>

<p>1. unset variable_name</p>

<p>变量被删除后不能再次使用；unset 命令不能删除只读变量。</p>

<p>举个例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. myUrl=&ldquo;<a href="http://see.xidian.edu.cn/cpp/u/xitong/&quot;">http://see.xidian.edu.cn/cpp/u/xitong/&quot;</a></p>

<p>4. unset myUrl</p>

<p>5. echo $myUrl</p>

<p>上面的脚本没有任何输出。</p>

<h2 id="变量类型">变量类型</h2>

<p>运行shell时，会同时存在三种变量：</p>

<h4 id="1-局部变量">1) 局部变量</h4>

<p>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</p>

<h4 id="2-环境变量">2) 环境变量</h4>

<p>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p>

<h4 id="3-shell变量">3) shell变量</h4>

<p>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>

<p>7</p>

<p>前面已经讲到，变量名只能包含数字、字母和下划线，因为某些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。</p>

<p>例如，$ 表示当前Shell进程的ID，即pid，看下面的代码：</p>

<p>1. $echo $$</p>

<p>运行结果</p>

<p>29949</p>

<p>特殊变量列表</p>

<hr />

<p>变量</p>

<p>|</p>

<p>含义</p>

<p>$0</p>

<p>|</p>

<p>当前脚本的文件名</p>

<p>$n</p>

<p>|</p>

<p>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</p>

<p>$#</p>

<p>|</p>

<p>传递给脚本或函数的参数个数。</p>

<p>$*</p>

<p>|</p>

<p>传递给脚本或函数的所有参数。</p>

<p>$@</p>

<p>|</p>

<p>传递给脚本或函数的所有参数。被双引号(&rdquo; &ldquo;)包含时，与 $* 稍有不同，下面将会讲到。</p>

<p>$?</p>

<p>|</p>

<p>上个命令的退出状态，或函数的返回值。</p>

<p>$$</p>

<p>|</p>

<p>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</p>

<h2 id="命令行参数">命令行参数</h2>

<p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>

<p>请看下面的脚本：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. echo &ldquo;File Name: $0&rdquo;</p>

<p>4. echo &ldquo;First Parameter : $1&rdquo;</p>

<p>5. echo &ldquo;First Parameter : $2&rdquo;</p>

<p>6. echo &ldquo;Quoted Values: $@&rdquo;</p>

<p>7. echo &ldquo;Quoted Values: $*&rdquo;</p>

<p>8. echo &ldquo;Total Number of Parameters : $#&rdquo;</p>

<p>运行结果：</p>

<dl>
<dt>$./test.sh Zara AliFile Name : ./test.shFirst Parameter : ZaraSecond Parameter</dt>
<dd>AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters</dd>
<dd>2</dd>
</dl>

<h2 id="和-的区别">$* 和 $@ 的区别</h2>

<p>$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(&rdquo; &ldquo;)包含时，都以&rdquo;$1&rdquo; &ldquo;$2&rdquo; … &ldquo;$n&rdquo; 的形式输出所有参数。</p>

<p>但是当它们被双引号(&rdquo; &ldquo;)包含时，&rdquo;$*&rdquo; 会将所有的参数作为一个整体，以&rdquo;$1 $2 … $n&rdquo;的形式输出所有参数；&rdquo;$@&rdquo;
会将各个参数分开，以&rdquo;$1&rdquo; &ldquo;$2&rdquo; … &ldquo;$n&rdquo; 的形式输出所有参数。</p>

<p>下面的例子可以清楚的看到 $* 和 $@ 的区别：</p>

<p>1. #!/bin/bash</p>

<p>2. echo &ldquo;\$<em>=&rdquo; $</em></p>

<p>3. echo &ldquo;\&rdquo;\$<em>\&ldquo;=&rdquo; &ldquo;$</em>&ldquo;</p>

<p>4.</p>

<p>5. echo &ldquo;\$@=&rdquo; $@</p>

<p>6. echo &ldquo;\&rdquo;\$@\&ldquo;=&rdquo; &ldquo;$@&rdquo;</p>

<p>7.</p>

<p>8. echo &ldquo;print each param from \$*&rdquo;</p>

<p>9. for var in $*</p>

<p>10. do</p>

<p>11.  echo &ldquo;$var&rdquo;</p>

<p>12. done</p>

<p>13.</p>

<p>14. echo &ldquo;print each param from \$@&rdquo;</p>

<p>15. for var in $@</p>

<p>16. do</p>

<p>17.  echo &ldquo;$var&rdquo;</p>

<p>18. done</p>

<p>19.</p>

<p>20. echo &ldquo;print each param from \&rdquo;\$*\&ldquo;&rdquo;</p>

<p>21. for var in &ldquo;$*&rdquo;</p>

<p>22. do</p>

<p>23.  echo &ldquo;$var&rdquo;</p>

<p>24. done</p>

<p>25.</p>

<p>26. echo &ldquo;print each param from \&rdquo;\$@\&ldquo;&rdquo;</p>

<p>27. for var in &ldquo;$@&rdquo;</p>

<p>28. do</p>

<p>29.  echo &ldquo;$var&rdquo;</p>

<p>30. done</p>

<p>执行 ./test.sh &ldquo;a&rdquo; &ldquo;b&rdquo; &ldquo;c&rdquo; &ldquo;d&rdquo;，看到下面的结果：</p>

<p>$<em>= a b c d&rdquo;$</em>&rdquo;= a b c d$@= a b c d&rdquo;$@&ldquo;= a b c dprint each param from
$<em>abcdprint each param from $@abcdprint each param from &ldquo;$</em>&ldquo;a b c dprint each
param from &ldquo;$@&ldquo;abcd</p>

<h2 id="退出状态">退出状态</h2>

<p>$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p>

<p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p>

<p>不过，也有一些命令返回其他值，表示不同类型的错误。</p>

<p>下面例子中，命令成功执行：</p>

<dl>
<dt>$./test.sh Zara AliFile Name : ./test.shFirst Parameter : ZaraSecond Parameter</dt>
<dd>AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters</dd>
<dd>2$echo $?0$

<br /></dd>
</dl>

<p>$? 也可以表示函数的返回值，后续将会讲解。</p>

<p>8</p>

<p>如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。</p>

<p>举个例子：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. a=10</p>

<p>4. echo -e &ldquo;Value of a is $a \n&rdquo;</p>

<p>运行结果：</p>

<p>Value of a is 10</p>

<p>这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出：</p>

<p>Value of a is 10\n</p>

<p>下面的转义字符都可以用在 echo 中：</p>

<p>转义字符</p>

<p>|</p>

<p>含义</p>

<p>&mdash;|&mdash;</p>

<p>\</p>

<p>|</p>

<p>反斜杠</p>

<p>\a</p>

<p>|</p>

<p>警报，响铃</p>

<p>\b</p>

<p>|</p>

<p>退格（删除键）</p>

<p>\f</p>

<p>|</p>

<p>换页(FF)，将当前位置移到下页开头</p>

<p>\n</p>

<p>|</p>

<p>换行</p>

<p>\r</p>

<p>|</p>

<p>回车</p>

<p>\t</p>

<p>|</p>

<p>水平制表符（tab键）</p>

<p>\v</p>

<p>|</p>

<p>垂直制表符</p>

<p>可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。</p>

<h2 id="命令替换">命令替换</h2>

<p>命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。</p>

<p>命令替换的语法：</p>

<p>1. <code>command</code></p>

<p>注意是反引号，不是单引号，这个键位于 Esc 键下方。</p>

<p>下面的例子中，将命令执行结果保存在变量中：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. DATE=<code>date</code></p>

<p>4. echo &ldquo;Date is $DATE&rdquo;</p>

<p>5.</p>

<p>6. USERS=<code>who | wc -l</code></p>

<p>7. echo &ldquo;Logged in user are $USERS&rdquo;</p>

<p>8.</p>

<p>9. UP=<code>date ; uptime</code></p>

<p>10. echo &ldquo;Uptime is $UP&rdquo;</p>

<p>运行结果：</p>

<p>Date is Thu Jul 2 03:59:57 MST 2009Logged in user are 1Uptime is Thu Jul 2
03:59:57 MST 200903:59:57 up 20 days, 14:03, 1 user, load avg: 0.13, 0.07,
0.15</p>

<h2 id="变量替换">变量替换</h2>

<p>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值</p>

<p>可以使用的变量替换形式：</p>

<p>形式</p>

<p>|</p>

<p>说明</p>

<p>&mdash;|&mdash;</p>

<p>${var}</p>

<p>|</p>

<p>变量本来的值</p>

<p>${var:-word}</p>

<p>|</p>

<p>如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。</p>

<p>${var:=word}</p>

<p>|</p>

<p>如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。</p>

<p>${var:?message}</p>

<p>|</p>

<p>如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。<br />
若此替换出现在Shell脚本中，那么脚本将停止运行。</p>

<p>${var:+word}</p>

<p>|</p>

<p>如果变量 var 被定义，那么返回 word，但不改变 var 的值。</p>

<p>请看下面的例子：</p>

<p>#!/bin/bash echo ${var:-&ldquo;Variable is not set&rdquo;}echo &ldquo;1 - Value of var is
${var}&rdquo; echo ${var:=&ldquo;Variable is not set&rdquo;}echo &ldquo;2 - Value of var is ${var}&rdquo;
unset varecho ${var:+&ldquo;This is default value&rdquo;}echo &ldquo;3 - Value of var is $var&rdquo;
var=&ldquo;Prefix&rdquo;echo ${var:+&ldquo;This is default value&rdquo;}echo &ldquo;4 - Value of var is
$var&rdquo; echo ${var:?&ldquo;Print this message&rdquo;}echo &ldquo;5 - Value of var is ${var}&rdquo;</p>

<p>运行结果：</p>

<p>复制纯文本新窗口</p>

<p>1. Variable is not set</p>

<p>2. 1 - Value of var is</p>

<p>3. Variable is not set</p>

<p>4. 2 - Value of var is Variable is not set</p>

<p>5.</p>

<p>6. 3 - Value of var is</p>

<p>7. This is default value</p>

<p>8. 4 - Value of var is Prefix</p>

<p>9. Prefix</p>

<p>10. 5 - Value of var is Prefix</p>

<p>9</p>

<p>Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。</p>

<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>

<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>

<p>例如，两个数相加：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. val=<code>expr 2 + 2</code></p>

<p>4. echo &ldquo;Total value : $val&rdquo;</p>

<p>运行脚本输出：</p>

<p>Total value : 4</p>

<p>两点注意：</p>

<p>· 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</p>

<p>· 完整的表达式要被  包含，注意这个字符不是常用的单引号，在 Esc 键下边。</p>

<h2 id="算术运算符">算术运算符</h2>

<p>先来看一个使用算术运算符的例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. a=10</p>

<p>4. b=20</p>

<p>5. val=<code>expr $a + $b</code></p>

<p>6. echo &ldquo;a + b : $val&rdquo;</p>

<p>7.</p>

<p>8. val=<code>expr $a \- $b</code></p>

<p>9. echo &ldquo;a - b : $val&rdquo;</p>

<p>10.</p>

<p>11. val=<code>expr $a \\* $b</code></p>

<p>12. echo &ldquo;a * b : $val&rdquo;</p>

<p>13.</p>

<p>14. val=<code>expr $b / $a</code></p>

<p>15. echo &ldquo;b / a : $val&rdquo;</p>

<p>16.</p>

<p>17. val=<code>expr $b % $a</code></p>

<p>18. echo &ldquo;b % a : $val&rdquo;</p>

<p>19.</p>

<p>20. if [ $a == $b ]</p>

<p>21. then</p>

<p>22.  echo &ldquo;a is equal to b&rdquo;</p>

<p>23. fi</p>

<p>24.</p>

<p>25. if [ $a != $b ]</p>

<p>26. then</p>

<p>27.  echo &ldquo;a is not equal to b&rdquo;</p>

<p>28. fi</p>

<p>运行结果：</p>

<p>a + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a is not equal to b</p>

<p>注意：</p>

<p>· 乘号(*)前边必须加反斜杠(\)才能实现乘法运算；</p>

<p>· if&hellip;then&hellip;fi 是条件语句，后续将会讲解。</p>

<p>算术运算符列表</p>

<hr />

<p>运算符</p>

<p>|</p>

<p>说明</p>

<p>|</p>

<p>举例</p>

<p>+</p>

<p>|</p>

<p>加法</p>

<p>|</p>

<p><code>expr $a + $b</code> 结果为 30。</p>

<p>-</p>

<p>|</p>

<p>减法</p>

<p>|</p>

<p><code>expr $a - $b</code> 结果为 10。</p>

<p>*</p>

<p>|</p>

<p>乘法</p>

<p>|</p>

<p><code>expr $a \\* $b</code> 结果为 200。</p>

<p>/</p>

<p>|</p>

<p>除法</p>

<p>|</p>

<p><code>expr $b / $a</code> 结果为 2。</p>

<p>%</p>

<p>|</p>

<p>取余</p>

<p>|</p>

<p><code>expr $b % $a</code> 结果为 0。</p>

<p>=</p>

<p>|</p>

<p>赋值</p>

<p>|</p>

<p>a=$b 将把变量 b 的值赋给 a。</p>

<p>==</p>

<p>|</p>

<p>相等。用于比较两个数字，相同则返回 true。</p>

<p>|</p>

<p>[ $a == $b ] 返回 false。</p>

<p>!=</p>

<p>|</p>

<p>不相等。用于比较两个数字，不相同则返回 true。</p>

<p>|</p>

<p>[ $a != $b ] 返回 true。</p>

<p>注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。</p>

<h2 id="关系运算符">关系运算符</h2>

<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>

<p>先来看一个关系运算符的例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. a=10</p>

<p>4. b=20</p>

<p>5. if [ $a -eq $b ]</p>

<p>6. then</p>

<p>7.  echo &ldquo;$a -eq $b : a is equal to b&rdquo;</p>

<p>8. else</p>

<p>9.  echo &ldquo;$a -eq $b: a is not equal to b&rdquo;</p>

<p>10. fi</p>

<p>11.</p>

<p>12. if [ $a -ne $b ]</p>

<p>13. then</p>

<p>14.  echo &ldquo;$a -ne $b: a is not equal to b&rdquo;</p>

<p>15. else</p>

<p>16.  echo &ldquo;$a -ne $b : a is equal to b&rdquo;</p>

<p>17. fi</p>

<p>18.</p>

<p>19. if [ $a -gt $b ]</p>

<p>20. then</p>

<p>21.  echo &ldquo;$a -gt $b: a is greater than b&rdquo;</p>

<p>22. else</p>

<p>23.  echo &ldquo;$a -gt $b: a is not greater than b&rdquo;</p>

<p>24. fi</p>

<p>25.</p>

<p>26. if [ $a -lt $b ]</p>

<p>27. then</p>

<p>28.  echo &ldquo;$a -lt $b: a is less than b&rdquo;</p>

<p>29. else</p>

<p>30.  echo &ldquo;$a -lt $b: a is not less than b&rdquo;</p>

<p>31. fi</p>

<p>32.</p>

<p>33. if [ $a -ge $b ]</p>

<p>34. then</p>

<p>35.  echo &ldquo;$a -ge $b: a is greater or equal to b&rdquo;</p>

<p>36. else</p>

<p>37.  echo &ldquo;$a -ge $b: a is not greater or equal to b&rdquo;</p>

<p>38. fi</p>

<p>39.</p>

<p>40. if [ $a -le $b ]</p>

<p>41. then</p>

<p>42.  echo &ldquo;$a -le $b: a is less or equal to b&rdquo;</p>

<p>43. else</p>

<p>44.  echo &ldquo;$a -le $b: a is not less or equal to b&rdquo;</p>

<p>45. fi</p>

<p>运行结果：</p>

<p>10 -eq 20: a is not equal to b10 -ne 20: a is not equal to b10 -gt 20: a is
not greater than b10 -lt 20: a is less than b10 -ge 20: a is not greater or
equal to b10 -le 20: a is less or equal to b</p>

<p>关系运算符列表</p>

<hr />

<p>运算符</p>

<p>|</p>

<p>说明</p>

<p>|</p>

<p>举例</p>

<p>-eq</p>

<p>|</p>

<p>检测两个数是否相等，相等返回 true。</p>

<p>|</p>

<p>[ $a -eq $b ] 返回 true。</p>

<p>-ne</p>

<p>|</p>

<p>检测两个数是否相等，不相等返回 true。</p>

<p>|</p>

<p>[ $a -ne $b ] 返回 true。</p>

<p>-gt</p>

<p>|</p>

<p>检测左边的数是否大于右边的，如果是，则返回 true。</p>

<p>|</p>

<p>[ $a -gt $b ] 返回 false。</p>

<p>-lt</p>

<p>|</p>

<p>检测左边的数是否小于右边的，如果是，则返回 true。</p>

<p>|</p>

<p>[ $a -lt $b ] 返回 true。</p>

<p>-ge</p>

<p>|</p>

<p>检测左边的数是否大等于右边的，如果是，则返回 true。</p>

<p>|</p>

<p>[ $a -ge $b ] 返回 false。</p>

<p>-le</p>

<p>|</p>

<p>检测左边的数是否小于等于右边的，如果是，则返回 true。</p>

<p>|</p>

<p>[ $a -le $b ] 返回 true。</p>

<h2 id="布尔运算符">布尔运算符</h2>

<p>先来看一个布尔运算符的例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. a=10</p>

<p>4. b=20</p>

<p>5.</p>

<p>6. if [ $a != $b ]</p>

<p>7. then</p>

<p>8.  echo &ldquo;$a != $b : a is not equal to b&rdquo;</p>

<p>9. else</p>

<p>10.  echo &ldquo;$a != $b: a is equal to b&rdquo;</p>

<p>11. fi</p>

<p>12.</p>

<p>13. if [ $a -lt 100 -a $b -gt 15 ]</p>

<p>14. then</p>

<p>15.  echo &ldquo;$a -lt 100 -a $b -gt 15 : returns true&rdquo;</p>

<p>16. else</p>

<p>17.  echo &ldquo;$a -lt 100 -a $b -gt 15 : returns false&rdquo;</p>

<p>18. fi</p>

<p>19.</p>

<p>20. if [ $a -lt 100 -o $b -gt 100 ]</p>

<p>21. then</p>

<p>22.  echo &ldquo;$a -lt 100 -o $b -gt 100 : returns true&rdquo;</p>

<p>23. else</p>

<p>24.  echo &ldquo;$a -lt 100 -o $b -gt 100 : returns false&rdquo;</p>

<p>25. fi</p>

<p>26.</p>

<p>27. if [ $a -lt 5 -o $b -gt 100 ]</p>

<p>28. then</p>

<p>29.  echo &ldquo;$a -lt 100 -o $b -gt 100 : returns true&rdquo;</p>

<p>30. else</p>

<p>31.  echo &ldquo;$a -lt 100 -o $b -gt 100 : returns false&rdquo;</p>

<p>32. fi</p>

<p>运行结果：</p>

<p>10 != 20 : a is not equal to b10 -lt 100 -a 20 -gt 15 : returns true10 -lt 100
-o 20 -gt 100 : returns true10 -lt 5 -o 20 -gt 100 : returns false</p>

<p>布尔运算符列表</p>

<hr />

<p>运算符</p>

<p>|</p>

<p>说明</p>

<p>|</p>

<p>举例</p>

<p>!</p>

<p>|</p>

<p>非运算，表达式为 true 则返回 false，否则返回 true。</p>

<p>|</p>

<p>[ ! false ] 返回 true。</p>

<p>-o</p>

<p>|</p>

<p>或运算，有一个表达式为 true 则返回 true。</p>

<p>|</p>

<p>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</p>

<p>-a</p>

<p>|</p>

<p>与运算，两个表达式都为 true 才返回 true。</p>

<p>|</p>

<p>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>

<h2 id="字符串运算符">字符串运算符</h2>

<p>先来看一个例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. a=&ldquo;abc&rdquo;</p>

<p>4. b=&ldquo;efg&rdquo;</p>

<p>5.</p>

<p>6. if [ $a = $b ]</p>

<p>7. then</p>

<p>8.  echo &ldquo;$a = $b : a is equal to b&rdquo;</p>

<p>9. else</p>

<p>10.  echo &ldquo;$a = $b: a is not equal to b&rdquo;</p>

<p>11. fi</p>

<p>12.</p>

<p>13. if [ $a != $b ]</p>

<p>14. then</p>

<p>15.  echo &ldquo;$a != $b : a is not equal to b&rdquo;</p>

<p>16. else</p>

<p>17.  echo &ldquo;$a != $b: a is equal to b&rdquo;</p>

<p>18. fi</p>

<p>19.</p>

<p>20. if [ -z $a ]</p>

<p>21. then</p>

<p>22.  echo &ldquo;-z $a : string length is zero&rdquo;</p>

<p>23. else</p>

<p>24.  echo &ldquo;-z $a : string length is not zero&rdquo;</p>

<p>25. fi</p>

<p>26.</p>

<p>27. if [ -n $a ]</p>

<p>28. then</p>

<p>29.  echo &ldquo;-n $a : string length is not zero&rdquo;</p>

<p>30. else</p>

<p>31.  echo &ldquo;-n $a : string length is zero&rdquo;</p>

<p>32. fi</p>

<p>33.</p>

<p>34. if [ $a ]</p>

<p>35. then</p>

<p>36.  echo &ldquo;$a : string is not empty&rdquo;</p>

<p>37. else</p>

<p>38.  echo &ldquo;$a : string is empty&rdquo;</p>

<p>39. fi</p>

<p>运行结果：</p>

<p>abc = efg: a is not equal to babc != efg : a is not equal to b-z abc : string
length is not zero-n abc : string length is not zeroabc : string is not empty</p>

<p>字符串运算符列表</p>

<hr />

<p>运算符</p>

<p>|</p>

<p>说明</p>

<p>|</p>

<p>举例</p>

<p>=</p>

<p>|</p>

<p>检测两个字符串是否相等，相等返回 true。</p>

<p>|</p>

<p>[ $a = $b ] 返回 false。</p>

<p>!=</p>

<p>|</p>

<p>检测两个字符串是否相等，不相等返回 true。</p>

<p>|</p>

<p>[ $a != $b ] 返回 true。</p>

<p>-z</p>

<p>|</p>

<p>检测字符串长度是否为0，为0返回 true。</p>

<p>|</p>

<p>[ -z $a ] 返回 false。</p>

<p>-n</p>

<p>|</p>

<p>检测字符串长度是否为0，不为0返回 true。</p>

<p>|</p>

<p>[ -z $a ] 返回 true。</p>

<p>str</p>

<p>|</p>

<p>检测字符串是否为空，不为空返回 true。</p>

<p>|</p>

<p>[ $a ] 返回 true。</p>

<h2 id="文件测试运算符">文件测试运算符</h2>

<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>

<p>例如，变量 file 表示文件“/var/www/tutorialspoint/unix/test.sh”，它的大小为100字节，具有 rwx
权限。下面的代码，将检测该文件的各种属性：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. file=&ldquo;/var/www/tutorialspoint/unix/test.sh&rdquo;</p>

<p>4.</p>

<p>5. if [ -r $file ]</p>

<p>6. then</p>

<p>7.  echo &ldquo;File has read access&rdquo;</p>

<p>8. else</p>

<p>9.  echo &ldquo;File does not have read access&rdquo;</p>

<p>10. fi</p>

<p>11.</p>

<p>12. if [ -w $file ]</p>

<p>13. then</p>

<p>14.  echo &ldquo;File has write permission&rdquo;</p>

<p>15. else</p>

<p>16.  echo &ldquo;File does not have write permission&rdquo;</p>

<p>17. fi</p>

<p>18.</p>

<p>19. if [ -x $file ]</p>

<p>20. then</p>

<p>21.  echo &ldquo;File has execute permission&rdquo;</p>

<p>22. else</p>

<p>23.  echo &ldquo;File does not have execute permission&rdquo;</p>

<p>24. fi</p>

<p>25.</p>

<p>26. if [ -f $file ]</p>

<p>27. then</p>

<p>28.  echo &ldquo;File is an ordinary file&rdquo;</p>

<p>29. else</p>

<p>30.  echo &ldquo;This is sepcial file&rdquo;</p>

<p>31. fi</p>

<p>32.</p>

<p>33. if [ -d $file ]</p>

<p>34. then</p>

<p>35.  echo &ldquo;File is a directory&rdquo;</p>

<p>36. else</p>

<p>37.  echo &ldquo;This is not a directory&rdquo;</p>

<p>38. fi</p>

<p>39.</p>

<p>40. if [ -s $file ]</p>

<p>41. then</p>

<p>42.  echo &ldquo;File size is zero&rdquo;</p>

<p>43. else</p>

<p>44.  echo &ldquo;File size is not zero&rdquo;</p>

<p>45. fi</p>

<p>46.</p>

<p>47. if [ -e $file ]</p>

<p>48. then</p>

<p>49.  echo &ldquo;File exists&rdquo;</p>

<p>50. else</p>

<p>51.  echo &ldquo;File does not exist&rdquo;</p>

<p>52. fi</p>

<p>运行结果：</p>

<p>File has read accessFile has write permissionFile has execute permissionFile
is an ordinary fileThis is not a directoryFile size is zeroFile exists</p>

<p>文件测试运算符列表</p>

<hr />

<p>操作符</p>

<p>|</p>

<p>说明</p>

<p>|</p>

<p>举例</p>

<p>-b file</p>

<p>|</p>

<p>检测文件是否是块设备文件，如果是，则返回 true。</p>

<p>|</p>

<p>[ -b $file ] 返回 false。</p>

<p>-c file</p>

<p>|</p>

<p>检测文件是否是字符设备文件，如果是，则返回 true。</p>

<p>|</p>

<p>[ -b $file ] 返回 false。</p>

<p>-d file</p>

<p>|</p>

<p>检测文件是否是目录，如果是，则返回 true。</p>

<p>|</p>

<p>[ -d $file ] 返回 false。</p>

<p>-f file</p>

<p>|</p>

<p>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</p>

<p>|</p>

<p>[ -f $file ] 返回 true。</p>

<p>-g file</p>

<p>|</p>

<p>检测文件是否设置了 SGID 位，如果是，则返回 true。</p>

<p>|</p>

<p>[ -g $file ] 返回 false。</p>

<p>-k file</p>

<p>|</p>

<p>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</p>

<p>|</p>

<p>[ -k $file ] 返回 false。</p>

<p>-p file</p>

<p>|</p>

<p>检测文件是否是具名管道，如果是，则返回 true。</p>

<p>|</p>

<p>[ -p $file ] 返回 false。</p>

<p>-u file</p>

<p>|</p>

<p>检测文件是否设置了 SUID 位，如果是，则返回 true。</p>

<p>|</p>

<p>[ -u $file ] 返回 false。</p>

<p>-r file</p>

<p>|</p>

<p>检测文件是否可读，如果是，则返回 true。</p>

<p>|</p>

<p>[ -r $file ] 返回 true。</p>

<p>-w file</p>

<p>|</p>

<p>检测文件是否可写，如果是，则返回 true。</p>

<p>|</p>

<p>[ -w $file ] 返回 true。</p>

<p>-x file</p>

<p>|</p>

<p>检测文件是否可执行，如果是，则返回 true。</p>

<p>|</p>

<p>[ -x $file ] 返回 true。</p>

<p>-s file</p>

<p>|</p>

<p>检测文件是否为空（文件大小是否大于0），不为空返回 true。</p>

<p>|</p>

<p>[ -s $file ] 返回 true。</p>

<p>-e file</p>

<p>|</p>

<p>检测文件（包括目录）是否存在，如果是，则返回 true。</p>

<p>|</p>

<p>[ -e $file ] 返回 true。</p>

<p>10</p>

<p>以“#”开头的行就是注释，会被解释器忽略。</p>

<p>sh里没有多行注释，只能每一行加一个#号。只能像这样：</p>

<p>1. #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>2. # 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：</p>

<p>3. # <a href="https://github.com/webfrogs/xcode_shell/blob/master/ipa-build">https://github.com/webfrogs/xcode_shell/blob/master/ipa-build</a></p>

<p>4.</p>

<p>5. # 功能：自动为etao ios app打包，产出物为14个渠道的ipa包</p>

<p>6. # 特色：全自动打包，不需要输入任何参数</p>

<p>7. #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>8.</p>

<p>9. ##### 用户配置区 开始 #####</p>

<p>10. #</p>

<p>11. #</p>

<p>12. # 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了</p>

<p>13. # 应用名，确保和Xcode里Product下的target_name.app名字一致</p>

<p>14. #</p>

<p>15. ##### 用户配置区 结束 #####</p>

<p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>

<p>11</p>

<p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p>

<h2 id="单引号">单引号</h2>

<p>1. str=&lsquo;this is a string&rsquo;</p>

<p>单引号字符串的限制：</p>

<p>· 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</p>

<p>· 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p>

<h2 id="双引号">双引号</h2>

<p>1. your_name=&lsquo;qinjx&rsquo;</p>

<p>2. str=&ldquo;Hello, I know your are \&ldquo;$your_name\&ldquo;! \n&rdquo;</p>

<p>双引号的优点：</p>

<p>· 双引号里可以有变量</p>

<p>· 双引号里可以出现转义字符</p>

<h2 id="拼接字符串">拼接字符串</h2>

<p>1. your_name=&ldquo;qinjx&rdquo;</p>

<p>2. greeting=&ldquo;hello, &ldquo;$your_name&rdquo; !&rdquo;</p>

<p>3. greeting_1=&ldquo;hello, ${your_name} !&rdquo;</p>

<p>4.</p>

<p>5. echo $greeting $greeting_1</p>

<h2 id="获取字符串长度">获取字符串长度</h2>

<p>1. string=&ldquo;abcd&rdquo;</p>

<p>2. echo ${#string} #输出 4</p>

<h2 id="提取子字符串">提取子字符串</h2>

<p>1. string=&ldquo;alibaba is a great company&rdquo;</p>

<p>2. echo ${string:1:4} #输出liba</p>

<h2 id="查找子字符串">查找子字符串</h2>

<p>1. string=&ldquo;alibaba is a great company&rdquo;</p>

<p>2. echo <code>expr index &quot;$string&quot; is</code></p>

<p>12</p>

<p>Shell在编程方面比Windows批处理强大很多，无论是在循环、运算。</p>

<p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p>

<h2 id="定义数组">定义数组</h2>

<p>在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：<br />
array_name=(value1 &hellip; valuen)<br />
例如：</p>

<p>1. array_name=(value0 value1 value2 value3)</p>

<p>或者</p>

<p>1. array_name=(</p>

<p>2. value0</p>

<p>3. value1</p>

<p>4. value2</p>

<p>5. value3</p>

<p>6. )</p>

<p>还可以单独定义数组的各个分量：</p>

<p>1. array_name[0]=value0</p>

<p>2. array_name[1]=value1</p>

<p>3. array_name[2]=value2</p>

<p>可以不使用连续的下标，而且下标的范围没有限制。</p>

<h2 id="读取数组">读取数组</h2>

<p>读取数组元素值的一般格式是：<br />
${array_name[index]}<br />
例如：</p>

<p>1. valuen=${array_name[2]}</p>

<p>举个例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. NAME[0]=&ldquo;Zara&rdquo;</p>

<p>4. NAME[1]=&ldquo;Qadir&rdquo;</p>

<p>5. NAME[2]=&ldquo;Mahnaz&rdquo;</p>

<p>6. NAME[3]=&ldquo;Ayan&rdquo;</p>

<p>7. NAME[4]=&ldquo;Daisy&rdquo;</p>

<p>8. echo &ldquo;First Index: ${NAME[0]}&rdquo;</p>

<p>9. echo &ldquo;Second Index: ${NAME[1]}&rdquo;</p>

<p>运行脚本，输出：</p>

<p>$./test.shFirst Index: ZaraSecond Index: Qadir</p>

<p>使用@ 或 * 可以获取数组中的所有元素，例如：</p>

<p>1. ${array_name[*]}</p>

<p>2. ${array_name[@]}</p>

<p>举个例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. NAME[0]=&ldquo;Zara&rdquo;</p>

<p>4. NAME[1]=&ldquo;Qadir&rdquo;</p>

<p>5. NAME[2]=&ldquo;Mahnaz&rdquo;</p>

<p>6. NAME[3]=&ldquo;Ayan&rdquo;</p>

<p>7. NAME[4]=&ldquo;Daisy&rdquo;</p>

<p>8. echo &ldquo;First Method: ${NAME[*]}&rdquo;</p>

<p>9. echo &ldquo;Second Method: ${NAME[@]}&rdquo;</p>

<p>运行脚本，输出：</p>

<p>$./test.shFirst Method: Zara Qadir Mahnaz Ayan DaisySecond Method: Zara Qadir
Mahnaz Ayan Daisy</p>

<h2 id="获取数组的长度">获取数组的长度</h2>

<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>

<p>复制纯文本新窗口</p>

<p>1. # 取得数组元素的个数</p>

<p>2. length=${#array_name[@]}</p>

<p>3. # 或者</p>

<p>4. length=${#array_name[*]}</p>

<p>5. # 取得数组单个元素的长度</p>

<p>6. lengthn=${#array_name[n]}</p>

<p>12</p>

<p>echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。命令格式：</p>

<p>1. echo arg</p>

<p>您可以使用echo实现更复杂的输出格式控制。</p>

<h2 id="显示转义字符">显示转义字符</h2>

<p>1. echo &ldquo;\&ldquo;It is a test\&ldquo;&rdquo;</p>

<p>结果将是：<br />
&ldquo;It is a test&rdquo;</p>

<p>双引号也可以省略。</p>

<h2 id="显示变量">显示变量</h2>

<p>1. name=&ldquo;OK&rdquo;</p>

<p>2. echo &ldquo;$name It is a test&rdquo;</p>

<p>结果将是：<br />
OK It is a test</p>

<p>同样双引号也可以省略。</p>

<p>如果变量与其它字符相连的话，需要使用大括号（{ }）：</p>

<p>1. mouth=8</p>

<p>2. echo &ldquo;${mouth}-1-2009&rdquo;</p>

<p>结果将是：<br />
8-1-2009</p>

<h2 id="显示换行">显示换行</h2>

<p>1. echo &ldquo;OK!\n&rdquo;</p>

<p>2. echo &ldquo;It is a test&rdquo;</p>

<p>输出：<br />
OK!<br />
It is a test</p>

<h2 id="显示不换行">显示不换行</h2>

<p>1. echo &ldquo;OK!\c&rdquo;</p>

<p>2. echo &ldquo;It is a test&rdquo;</p>

<p>输出：<br />
OK!It si a test</p>

<h2 id="显示结果重定向至文件">显示结果重定向至文件</h2>

<p>1. echo &ldquo;It is a test&rdquo; &gt; myfile</p>

<h2 id="原样输出字符串">原样输出字符串</h2>

<p>若需要原样输出字符串（不进行转义），请使用单引号。例如：</p>

<p>1. echo &lsquo;$name\&ldquo;&rsquo;</p>

<h2 id="显示命令执行结果">显示命令执行结果</h2>

<p>1. echo <code>date</code></p>

<p>结果将显示当前日期</p>

<p>从上面可看出，双引号可有可无，单引号主要用在原样输出中。</p>

<p>13</p>

<p>printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。</p>

<p>注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。</p>

<p>如同 echo 命令，printf 命令也可以输出简单的字符串：</p>

<p>1. $printf &ldquo;Hello, Shell\n&rdquo;</p>

<p>2. Hello, Shell</p>

<p>3. $</p>

<p>printf 不像 echo 那样会自动换行，必须显式添加换行符(\n)。</p>

<p>printf 命令的语法：</p>

<p>printf format-string [arguments&hellip;]</p>

<p>format-string 为格式控制字符串，arguments 为参数列表。</p>

<p>printf()在C语言入门教程中已经讲到，功能和用法与 printf 命令类似，请查看：C语言格式输出函数printf()详解</p>

<p>这里仅说明与C语言printf()函数的不同：</p>

<p>· printf 命令不用加括号</p>

<p>· format-string 可以没有引号，但最好加上，单引号双引号均可。</p>

<p>· 参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。</p>

<p>· arguments 使用空格分隔，不用逗号。</p>

<p>请看下面的例子：</p>

<p>1. # format-string为双引号</p>

<p>2. $ printf &ldquo;%d %s\n&rdquo; 1 &ldquo;abc&rdquo;</p>

<p>3. 1 abc</p>

<p>4. # 单引号与双引号效果一样</p>

<p>5. $ printf &lsquo;%d %s\n&rsquo; 1 &ldquo;abc&rdquo;</p>

<p>6. 1 abc</p>

<p>7. # 没有引号也可以输出</p>

<p>8. $ printf %s abcdef</p>

<p>9. abcdef</p>

<p>10. # 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</p>

<p>11. $ printf %s abc def</p>

<p>12. abcdef</p>

<p>13. $ printf &ldquo;%s\n&rdquo; abc def</p>

<p>14. abc</p>

<p>15. def</p>

<p>16. $ printf &ldquo;%s %s %s\n&rdquo; a b c d e f g h i j</p>

<p>17. a b c</p>

<p>18. d e f</p>

<p>19. g h i</p>

<p>20. j</p>

<p>21. # 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</p>

<p>22. $ printf &ldquo;%s and %d \n&rdquo;</p>

<p>23. and 0</p>

<p>24. # 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0</p>

<p>25. $ printf &ldquo;The first program always prints&rsquo;%s,%d\n&rsquo;&rdquo; Hello Shell</p>

<p>26. -bash: printf: Shell: invalid number</p>

<p>27. The first program always prints &lsquo;Hello,0&rsquo;</p>

<p>28. $</p>

<p>注意，根据POSIX标准，浮点格式%e、%E、%f、%g与%G是“不需要被支持”。这是因为awk支持浮点预算，且有它自己的printf语句。这样Shell程序中需要将浮点数值进行格式化的打印时，可使用小型的awk程序实现。然而，内建于bash、ksh93和zsh中的printf命令都支持浮点格式。</p>

<p>14</p>

<p>if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if &hellip; else 语句：</p>

<p>· if &hellip; fi 语句；</p>

<p>· if &hellip; else &hellip; fi 语句；</p>

<p>· if &hellip; elif &hellip; else &hellip; fi 语句。</p>

<h2 id="1-if-else-语句">1) if &hellip; else 语句</h2>

<p>if &hellip; else 语句的语法：</p>

<p>if [ expression ]then Statement(s) to be executed if expression is truefi</p>

<p>如果 expression 返回 true，then 后边的语句将会被执行；如果返回 false，不会执行任何语句。</p>

<p>最后必须以 fi 来结尾闭合 if，fi 就是 if 倒过来拼写，后面也会遇见。</p>

<p>注意：expression 和方括号([ ])之间必须有空格，否则会有语法错误。</p>

<p>举个例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. a=10</p>

<p>4. b=20</p>

<p>5.</p>

<p>6. if [ $a == $b ]</p>

<p>7. then</p>

<p>8.  echo &ldquo;a is equal to b&rdquo;</p>

<p>9. fi</p>

<p>10.</p>

<p>11. if [ $a != $b ]</p>

<p>12. then</p>

<p>13.  echo &ldquo;a is not equal to b&rdquo;</p>

<p>14. fi</p>

<p>运行结果：</p>

<p>a is not equal to b</p>

<h2 id="2-if-else-fi-语句">2) if &hellip; else &hellip; fi 语句</h2>

<p>if &hellip; else &hellip; fi 语句的语法：</p>

<p>if [ expression ]then Statement(s) to be executed if expression is trueelse
Statement(s) to be executed if expression is not truefi</p>

<p>如果 expression 返回 true，那么 then 后边的语句将会被执行；否则，执行 else 后边的语句。</p>

<p>举个例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. a=10</p>

<p>4. b=20</p>

<p>5.</p>

<p>6. if [ $a == $b ]</p>

<p>7. then</p>

<p>8.  echo &ldquo;a is equal to b&rdquo;</p>

<p>9. else</p>

<p>10.  echo &ldquo;a is not equal to b&rdquo;</p>

<p>11. fi</p>

<p>执行结果：</p>

<p>a is not equal to b</p>

<h2 id="3-if-elif-fi-语句">3) if &hellip; elif &hellip; fi 语句</h2>

<p>if &hellip; elif &hellip; fi 语句可以对多个条件进行判断，语法为：</p>

<p>if [ expression 1 ]then Statement(s) to be executed if expression 1 is
trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is
trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is
trueelse Statement(s) to be executed if no expression is truefi</p>

<p>哪一个 expression 的值为 true，就执行哪个 expression 后面的语句；如果都为 false，那么不执行任何语句。</p>

<p>举个例子：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. a=10</p>

<p>4. b=20</p>

<p>5.</p>

<p>6. if [ $a == $b ]</p>

<p>7. then</p>

<p>8.  echo &ldquo;a is equal to b&rdquo;</p>

<p>9. elif [ $a -gt $b ]</p>

<p>10. then</p>

<p>11.  echo &ldquo;a is greater than b&rdquo;</p>

<p>12. elif [ $a -lt $b ]</p>

<p>13. then</p>

<p>14.  echo &ldquo;a is less than b&rdquo;</p>

<p>15. else</p>

<p>16.  echo &ldquo;None of the condition met&rdquo;</p>

<p>17. fi</p>

<p>运行结果：</p>

<p>a is less than b</p>

<p>if &hellip; else 语句也可以写成一行，以命令的方式来运行，像这样：</p>

<p>1. if test $[2*3] -eq $[1+5]; then echo &lsquo;The two numbers are equal!&rsquo;; fi;</p>

<p>if &hellip; else 语句也经常与 test 命令结合使用，如下所示：</p>

<p>1. num1=$[2*3]</p>

<p>2. num2=$[1+5]</p>

<p>3. if test $[num1] -eq $[num2]</p>

<p>4. then</p>

<p>5.  echo &lsquo;The two numbers are equal!&rsquo;</p>

<p>6. else</p>

<p>7.  echo &lsquo;The two numbers are not equal!&rsquo;</p>

<p>8. fi</p>

<p>输出：</p>

<p>The two numbers are equal!</p>

<p>test 命令用于检查某个条件是否成立，与方括号([ ])类似。</p>

<p>15</p>

<p>case &hellip; esac 与其他语言中的 switch &hellip; case 语句类似，是一种多分枝选择结构。</p>

<p>case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</p>

<p>case 值 in模式1) command1 command2 command3 ;;模式2） command1 command2 command3
;;*) command1 command2 command3 ;;esac</p>

<p>case工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至
;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。</p>

<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>

<p>下面的脚本提示输入1到4，与每一种模式进行匹配：</p>

<p>1. echo &lsquo;Input a number between 1 to 4&rsquo;</p>

<p>2. echo &lsquo;Your number is:\c&rsquo;</p>

<p>3. read aNum</p>

<p>4. case $aNum in</p>

<p>5.  1) echo &lsquo;You select 1&rsquo;</p>

<p>6.  ;;</p>

<p>7.  2) echo &lsquo;You select 2&rsquo;</p>

<p>8.  ;;</p>

<p>9.  3) echo &lsquo;You select 3&rsquo;</p>

<p>10.  ;;</p>

<p>11.  4) echo &lsquo;You select 4&rsquo;</p>

<p>12.  ;;</p>

<p>13.  *) echo &lsquo;You do not select a number between 1 to 4&rsquo;</p>

<p>14.  ;;</p>

<p>15. esac</p>

<p>输入不同的内容，会有不同的结果，例如：</p>

<p>Input a number between 1 to 4Your number is:3You select 3</p>

<p>再举一个例子：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. option=&ldquo;${1}&rdquo;</p>

<p>4. case ${option} in</p>

<p>5.  -f) FILE=&ldquo;${2}&rdquo;</p>

<p>6.  echo &ldquo;File name is $FILE&rdquo;</p>

<p>7.  ;;</p>

<p>8.  -d) DIR=&ldquo;${2}&rdquo;</p>

<p>9.  echo &ldquo;Dir name is $DIR&rdquo;</p>

<p>10.  ;;</p>

<p>11.  *)</p>

<p>12.  echo &ldquo;<code>basename ${0}</code>:usage: [-f file] | [-d directory]&rdquo;</p>

<p>13.  exit 1 # Command to come out of the program with status 1</p>

<p>14.  ;;</p>

<p>15. esac</p>

<p>运行结果：</p>

<p>$./test.shtest.sh: usage: [ -f filename ] | [ -d directory ]$ ./test.sh -f
index.htm$ vi test.sh$ ./test.sh -f index.htmFile name is index.htm$ ./test.sh
-d unixDir name is unix$</p>

<p>16</p>

<p>与其他编程语言类似，Shell支持for循环。</p>

<p>for循环一般格式为：</p>

<p>for 变量 in 列表do command1 command2 &hellip; commandNdone</p>

<p>列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。</p>

<p>in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。</p>

<p>例如，顺序输出当前列表中的数字：</p>

<p>1. for loop in 1 2 3 4 5</p>

<p>2. do</p>

<p>3.  echo &ldquo;The value is: $loop&rdquo;</p>

<p>4. done</p>

<p>运行结果：</p>

<p>The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5</p>

<p>顺序输出字符串中的字符：</p>

<p>1. for str in &lsquo;This is a string&rsquo;</p>

<p>2. do</p>

<p>3.  echo $str</p>

<p>4. done</p>

<p>运行结果：</p>

<p>This is a string</p>

<p>显示主目录下以 .bash 开头的文件：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. for FILE in $HOME/.bash*</p>

<p>4. do</p>

<p>5.  echo $FILE</p>

<p>6. done</p>

<p>运行结果：</p>

<p>/root/.bash_history/root/.bash_logout/root/.bash_profile/root/.bashrc</p>

<p>17</p>

<p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>

<p>while commanddo Statement(s) to be executed if command is truedone</p>

<p>命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。</p>

<p>以下是一个基本的while循环，测试条件是：如果COUNTER小于5，那么返回
true。COUNTER从0开始，每次循环处理时，COUNTER加1。运行上述脚本，返回数字1到5，然后终止。</p>

<p>1. COUNTER=0</p>

<p>2. while [ $COUNTER -lt 5 ]</p>

<p>3. do</p>

<p>4.  COUNTER=&lsquo;expr $COUNTER+1&rsquo;</p>

<p>5.  echo $COUNTER</p>

<p>6. done</p>

<p>运行脚本，输出：</p>

<p>12345</p>

<p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按结束循环。</p>

<p>1. echo &lsquo;type  to terminate&rsquo;</p>

<p>2. echo -n &lsquo;enter your most liked film: &lsquo;</p>

<p>3. while read FILM</p>

<p>4. do</p>

<p>5.  echo &ldquo;Yeah! great film the $FILM&rdquo;</p>

<p>6. done</p>

<p>运行脚本，输出类似下面：</p>

<p>type  to terminateenter your most liked film: Sound of MusicYeah! great film
the Sound of Music</p>

<p>18</p>

<p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while
循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。</p>

<p>until 循环格式为：</p>

<p>until commanddo Statement(s) to be executed until command is truedone</p>

<p>command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>

<p>例如，使用 until 命令输出 0 ~ 9 的数字：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. a=0</p>

<p>4.</p>

<p>5. until [ ! $a -lt 10 ]</p>

<p>6. do</p>

<p>7.  echo $a</p>

<p>8.  a=<code>expr $a + 1</code></p>

<p>9. done</p>

<p>运行结果：</p>

<p>0123456789</p>

<p>19</p>

<p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。</p>

<h2 id="break命令">break命令</h2>

<p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p>

<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。</p>

<p>1. #!/bin/bash</p>

<p>2. while :</p>

<p>3. do</p>

<p>4.  echo -n &ldquo;Input a number between 1 to 5: &ldquo;</p>

<p>5.  read aNum</p>

<p>6.  case $aNum in</p>

<p>7.  1|2|3|4|5) echo &ldquo;Your number is $aNum!&rdquo;</p>

<p>8.  ;;</p>

<p>9.  *) echo &ldquo;You do not select a number between 1 to 5, game is over!&rdquo;</p>

<p>10.  break</p>

<p>11.  ;;</p>

<p>12.  esac</p>

<p>13. done</p>

<p>在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：</p>

<p>1. break n</p>

<p>表示跳出第 n 层循环。</p>

<p>下面是一个嵌套循环的例子，如果 var1 等于 2，并且 var2 等于 0，就跳出循环：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. for var1 in 1 2 3</p>

<p>4. do</p>

<p>5.  for var2 in 0 5</p>

<p>6.  do</p>

<p>7.  if [ $var1 -eq 2 -a $var2 -eq 0 ]</p>

<p>8.  then</p>

<p>9.  break 2</p>

<p>10.  else</p>

<p>11.  echo &ldquo;$var1 $var2&rdquo;</p>

<p>12.  fi</p>

<p>13.  done</p>

<p>14. done</p>

<p>如上，break 2 表示直接跳出外层循环。运行结果：</p>

<p>1 01 5</p>

<h2 id="continue命令">continue命令</h2>

<p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>

<p>对上面的例子进行修改：</p>

<p>1. #!/bin/bash</p>

<p>2. while :</p>

<p>3. do</p>

<p>4.  echo -n &ldquo;Input a number between 1 to 5: &ldquo;</p>

<p>5.  read aNum</p>

<p>6.  case $aNum in</p>

<p>7.  1|2|3|4|5) echo &ldquo;Your number is $aNum!&rdquo;</p>

<p>8.  ;;</p>

<p>9.  *) echo &ldquo;You do not select a number between 1 to 5!&rdquo;</p>

<p>10.  continue</p>

<p>11.  echo &ldquo;Game is over!&rdquo;</p>

<p>12.  ;;</p>

<p>13.  esac</p>

<p>14. done</p>

<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句</p>

<p>1. echo &ldquo;Game is over!&rdquo;</p>

<p>永远不会被执行。</p>

<p>同样，continue 后面也可以跟一个数字，表示跳出第几层循环。</p>

<p>再看一个 continue 的例子：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. NUMS=&ldquo;1 2 3 4 5 6 7&rdquo;</p>

<p>4.</p>

<p>5. for NUM in $NUMS</p>

<p>6. do</p>

<p>7.  Q=<code>expr $NUM % 2</code></p>

<p>8.  if [ $Q -eq 0 ]</p>

<p>9.  then</p>

<p>10.  echo &ldquo;Number is an even number!!&rdquo;</p>

<p>11.  continue</p>

<p>12.  fi</p>

<p>13.  echo &ldquo;Found odd number&rdquo;</p>

<p>14. done</p>

<p>运行结果：</p>

<p>Found odd numberNumber is an even number!!Found odd numberNumber is an even
number!!Found odd numberNumber is an even number!!Found odd number</p>

<p>20</p>

<p>函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell
函数必须先定义后使用。</p>

<p>Shell 函数的定义格式如下：</p>

<p>function_name () { list of commands [ return value ]}</p>

<p>如果你愿意，也可以在函数名前加上关键字 function：</p>

<p>function function_name () { list of commands [ return value ]}</p>

<p>函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。</p>

<p>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return
其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。</p>

<p>如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。</p>

<p>先来看一个例子：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. # Define your function here</p>

<p>4. Hello () {</p>

<p>5.  echo &ldquo;Url is <a href="http://see.xidian.edu.cn/cpp/shell/&quot;">http://see.xidian.edu.cn/cpp/shell/&quot;</a></p>

<p>6. }</p>

<p>7.</p>

<p>8. # Invoke your function</p>

<p>9. Hello</p>

<p>运行结果：</p>

<p>$./test.shHello World$</p>

<p>调用函数只需要给出函数名，不需要加括号。</p>

<p>再来看一个带有return语句的函数：</p>

<p>1. #!/bin/bash</p>

<p>2. funWithReturn(){</p>

<p>3.  echo &ldquo;The function is to get the sum of two numbers&hellip;&rdquo;</p>

<p>4.  echo -n &ldquo;Input first number: &ldquo;</p>

<p>5.  read aNum</p>

<p>6.  echo -n &ldquo;Input another number: &ldquo;</p>

<p>7.  read anotherNum</p>

<p>8.  echo &ldquo;The two numbers are $aNum and $anotherNum !&rdquo;</p>

<p>9.  return $(($aNum+$anotherNum))</p>

<p>10. }</p>

<p>11. funWithReturn</p>

<p>12. # Capture value returnd by last command</p>

<p>13. ret=$?</p>

<p>14. echo &ldquo;The sum of two numbers is $ret !&rdquo;</p>

<p>运行结果：</p>

<p>The function is to get the sum of two numbers&hellip;Input first number: 25Input
another number: 50The two numbers are 25 and 50 !The sum of two numbers is 75
!</p>

<p>函数返回值在调用该函数后通过 $? 来获得。</p>

<p>再来看一个函数嵌套的例子：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. # Calling one function from another</p>

<p>4. number_one () {</p>

<p>5.  echo &ldquo;Url_1 is <a href="http://see.xidian.edu.cn/cpp/shell/&quot;">http://see.xidian.edu.cn/cpp/shell/&quot;</a></p>

<p>6.  number_two</p>

<p>7. }</p>

<p>8.</p>

<p>9. number_two () {</p>

<p>10.  echo &ldquo;Url_2 is <a href="http://see.xidian.edu.cn/cpp/u/xitong/&quot;">http://see.xidian.edu.cn/cpp/u/xitong/&quot;</a></p>

<p>11. }</p>

<p>12.</p>

<p>13. number_one</p>

<p>运行结果：</p>

<p>Url_1 is <a href="http://see.xidian.edu.cn/cpp/shell/Url_2">http://see.xidian.edu.cn/cpp/shell/Url_2</a> is
<a href="http://see.xidian.edu.cn/cpp/u/xitong/">http://see.xidian.edu.cn/cpp/u/xitong/</a></p>

<p>像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：</p>

<p>1. $unset .f function_name</p>

<p>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。</p>

<p>21</p>

<p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数&hellip;</p>

<p>带参数的函数示例：</p>

<p>1. #!/bin/bash</p>

<p>2. funWithParam(){</p>

<p>3.  echo &ldquo;The value of the first parameter is $1 !&rdquo;</p>

<p>4.  echo &ldquo;The value of the second parameter is $2 !&rdquo;</p>

<p>5.  echo &ldquo;The value of the tenth parameter is $10 !&rdquo;</p>

<p>6.  echo &ldquo;The value of the tenth parameter is ${10} !&rdquo;</p>

<p>7.  echo &ldquo;The value of the eleventh parameter is ${11} !&rdquo;</p>

<p>8.  echo &ldquo;The amount of the parameters is $# !&rdquo; # 参数个数</p>

<p>9.  echo &ldquo;The string of the parameters is $* !&rdquo; # 传递给函数的所有参数</p>

<p>10. }</p>

<p>11. funWithParam 1 2 3 4 5 6 7 8 9 34 73</p>

<p>运行脚本：</p>

<p>The value of the first parameter is 1 !The value of the second parameter is 2
!The value of the tenth parameter is 10 !The value of the tenth parameter is
34 !The value of the eleventh parameter is 73 !The amount of the parameters is
12 !The string of the parameters is 1 2 3 4 5 6 7 8 9 34 73 !&rdquo;</p>

<p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>

<p>另外，还有几个特殊变量用来处理参数，前面已经提到：</p>

<p>特殊变量</p>

<p>|</p>

<p>说明</p>

<p>&mdash;|&mdash;</p>

<p>$#</p>

<p>|</p>

<p>传递给函数的参数个数。</p>

<p>$*</p>

<p>|</p>

<p>显示所有传递给函数的参数。</p>

<p>$@</p>

<p>|</p>

<p>与$*相同，但是略有区别，请查看Shell特殊变量。</p>

<p>$?</p>

<p>|</p>

<p>函数的返回值。</p>

<p>22</p>

<p>Unix
命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。</p>

<h2 id="输出重定向">输出重定向</h2>

<p>命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。</p>

<p>命令输出重定向的语法为：</p>

<p>1. $ command &gt; file</p>

<p>这样，输出到显示器的内容就可以被重定向到文件。</p>

<p>例如，下面的命令在显示器上不会看到任何输出：</p>

<p>1. $ who &gt; users</p>

<p>打开 users 文件，可以看到下面的内容：</p>

<p>$ cat usersoko tty01 Sep 12 07:30ai tty15 Sep 12 13:32ruth tty21 Sep 12
10:10pat tty24 Sep 12 13:07steve tty25 Sep 12 13:03$</p>

<p>输出重定向会覆盖文件内容，请看下面的例子：</p>

<p>$ echo line 1 &gt; users$ cat usersline 1$</p>

<p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p>

<p>$ echo line 2 &gt;&gt; users$ cat usersline 1line 2$</p>

<h2 id="输入重定向">输入重定向</h2>

<p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p>

<p>1. command &lt; file</p>

<p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>

<p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(</p>

<p>例如，计算 users 文件中的行数，可以使用下面的命令：</p>

<p>$ wc -l users2 users$</p>

<p>也可以将输入重定向到 users 文件：</p>

<p>$ wc -l</p>

<p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p>

<h2 id="重定向深入讲解">重定向深入讲解</h2>

<p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>

<p>· 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</p>

<p>· 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</p>

<p>· 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p>

<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command</p>

<p>如果希望 stderr 重定向到 file，可以这样写：</p>

<p>1. $command 2 &gt; file</p>

<p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p>

<p>1. $command 2 &gt;&gt; file</p>

<p>2 表示标准错误文件(stderr)。</p>

<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p>

<p>1. $command &gt; file 2&gt;&amp;1</p>

<p>或</p>

<p>1. $command &gt;&gt; file 2&gt;&amp;1</p>

<p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p>

<p>1. $command &lt; file1 &gt;file2</p>

<p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>

<p>全部可用的重定向命令列表</p>

<hr />

<p>命令</p>

<p>|</p>

<p>说明</p>

<p>command &gt; file</p>

<p>|</p>

<p>将输出重定向到 file。</p>

<p>command</p>

<p>|</p>

<p>将输入重定向到 file。</p>

<p>command &gt;&gt; file</p>

<p>|</p>

<p>将输出以追加的方式重定向到 file。</p>

<p>n &gt; file</p>

<p>|</p>

<p>将文件描述符为 n 的文件重定向到 file。</p>

<p>n &gt;&gt; file</p>

<p>|</p>

<p>将文件描述符为 n 的文件以追加的方式重定向到 file。</p>

<p>n &gt;&amp; m</p>

<p>|</p>

<p>将输出文件 m 和 n 合并。</p>

<p>n</p>

<p>|</p>

<p>将输入文件 m 和 n 合并。</p>

<p>&lt;</p>

<p>|</p>

<p>将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>

<h2 id="here-document">Here Document</h2>

<p>Here Document 目前没有统一的翻译，这里暂译为”嵌入文档“。Here Document 是 Shell
中的一种特殊的重定向方式，它的基本的形式如下：</p>

<p>1. command &lt;&lt; delimiter</p>

<p>2.  document</p>

<p>3. delimiter</p>

<p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>

<p>注意：</p>

<p>· 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</p>

<p>· 开始的delimiter前后的空格会被忽略掉。</p>

<p>下面的例子，通过 wc -l 命令计算 document 的行数：</p>

<p>$wc -l &lt;</p>

<p>也可以 将 Here Document 用在脚本中，例如：</p>

<p>1. #!/bin/bash</p>

<p>2.</p>

<p>3. cat &lt;&lt; EOF</p>

<p>4. This is a simple lookup program</p>

<p>5. for good (and bad) restaurants</p>

<p>6. in Cape Town.</p>

<p>7. EOF</p>

<p>运行结果：</p>

<p>This is a simple lookup programfor good (and bad) restaurantsin Cape Town.</p>

<p>下面的脚本通过 vi 编辑器将 document 保存到 test.txt 文件：</p>

<p>1. #!/bin/sh</p>

<p>2.</p>

<p>3. filename=test.txt</p>

<p>4. vi $filename &lt;&lt;EndOfCommands</p>

<p>5. i</p>

<p>6. This file was created automatically from</p>

<p>7. a shell script</p>

<p>8. ^[</p>

<p>9. ZZ</p>

<p>10. EndOfCommands</p>

<p>运行脚本：</p>

<p>$ sh test.shVim: Warning: Input is not from a terminal$</p>

<p>打开 test.txt，可以看到下面的内容：</p>

<p>$ cat test.txtThis file was created automatically froma shell script$</p>

<h2 id="dev-null-文件">/dev/null 文件</h2>

<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>

<p>1. $ command &gt; /dev/null</p>

<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null
文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。</p>

<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>

<p>1. $ command &gt; /dev/null 2&gt;&amp;1</p>

<p>23</p>

<p>像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p>

<p>Shell 中包含脚本可以使用：</p>

<p>1. . filename</p>

<p>或</p>

<p>1. source filename</p>

<p>两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。</p>

<p>例如，创建两个脚本，一个是被调用脚本 subscript.sh，内容如下：</p>

<p>1. url=&ldquo;<a href="http://see.xidian.edu.cn/cpp/view/2738.html&quot;">http://see.xidian.edu.cn/cpp/view/2738.html&quot;</a></p>

<p>一个是主文件 main.sh，内容如下：</p>

<p>1. #!/bin/bash</p>

<p>2. . ./subscript.sh</p>

<p>3. echo $url</p>

<p>执行脚本：</p>

<p>$chomd +x main.sh./main.shhttp://see.xidian.edu.cn/cpp/view/2738.html$</p>

<p>注意：被包含脚本不需要有执行权限。</p>

<p>Shell教程二</p>

<p>一个很不错的bash脚本编写教程，至少没接触过BASH的也能看懂</p>

<p>建立一个脚本</p>

<p>Linux中有好多中不同的shell，但是通常我们使用bash (bourne again shell)
进行shell编程，因为bash是免费的并且很容易使用。所以在本文中笔者所提供的脚本都是使用bash（但是在大多数情况下，这些脚本同样可以在
bash的大姐，bourne shell中运行）。<br />
如同其他语言一样，通过我们使用任意一种文字编辑器，比如nedit、kedit、emacs、vi<br />
等来编写我们的shell程序。<br />
程序必须以下面的行开始（必须方在文件的第一行）：<br />
#!/bin/sh<br />
符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br />
当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br />
要使脚本可执行：<br />
chmod +x filename<br />
然后，您可以通过输入： ./filename 来执行您的脚本。<br />
注释<br />
在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。<br />
变量<br />
在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：<br />
变量名=值<br />
取出变量值可以加一个美元符号（$）在变量前面：</p>

<p>?</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>4</p>

<p>5</p>

<p>6</p>

<p>|</p>

<p>#!/bin/sh</p>

<p>#对变量赋值：</p>

<p>a=&ldquo;hello world&rdquo;</p>

<h1 id="现在打印变量a的内容">现在打印变量a的内容：</h1>

<p>echo &ldquo;A is:&rdquo;</p>

<p>echo $a</p>

<p>&mdash;|&mdash;</p>

<p>在您的编辑器中输入以上内容，然后将其保存为一个文件first。之后执行chmod +x first<br />
使其可执行，最后输入./first执行该脚本。<br />
这个脚本将会输出：<br />
A is:<br />
hello world<br />
有时候变量名很容易与其他文字混淆，比如：<br />
num=2<br />
echo &ldquo;this is the $numnd&rdquo;<br />
这并不会打印出&rdquo;this is the 2nd&rdquo;，而仅仅打印&rdquo;this is the
&ldquo;，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：<br />
num=2<br />
echo &ldquo;this is the ${num}nd&rdquo;<br />
这将打印： this is the 2nd<br />
有许多变量是系统自动设定的，这将在后面使用这些变量时进行讨论。<br />
如果您需要处理数学表达式，那么您需要使用诸如expr等程序（见下面）。<br />
除了一般的仅在程序内有效的shell变量以外，还有环境变量。由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。<br />
Shell命令和流程控制<br />
在shell脚本中可以使用三类命令：<br />
1)Unix 命令:<br />
虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。<br />
常用命令语法及功能<br />
echo &ldquo;some text&rdquo;: 将文字内容打印在屏幕上<br />
ls: 文件列表<br />
wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数<br />
cp sourcefile destfile: 文件拷贝<br />
mv oldname newname : 重命名文件或移动文件<br />
rm file: 删除文件<br />
grep &lsquo;pattern&rsquo; file: 在文件内搜索字符串比如：grep &lsquo;searchstring&rsquo; file.txt<br />
cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9
file.txt千万不要和cat命令混淆，这是两个完全不同的命令<br />
cat file.txt: 输出文件内容到标准输出设备（屏幕）上<br />
file somefile: 得到文件类型<br />
read var: 提示用户输入，并将输入赋值给变量<br />
sort file.txt: 对file.txt文件中的行进行排序<br />
uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq<br />
expr: 进行数学运算Example: add 2 and 3expr 2 &ldquo;+&rdquo; 3<br />
find: 搜索文件比如：根据文件名搜索find . -name filename -print<br />
tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile<br />
basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux<br />
dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin<br />
head file: 打印文本文件开头几行<br />
tail file : 打印文本文件末尾几行<br />
sed:
Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus
替换为 LinuxFocus ：cat text.file | sed &rsquo;s/linuxfocus/LinuxFocus/&rsquo; &gt; newtext.file<br />
awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk -F,
&lsquo;{print $1 &ldquo;,&rdquo; $3 }&lsquo;这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34,
IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA<br />
2) 概念: 管道, 重定向和 backtick<br />
这些不是系统命令，但是他们真的很重要。<br />
管道 (|) 将一个命令的输出作为另外一个命令的输入。<br />
grep &ldquo;hello&rdquo; file.txt | wc -l<br />
在file.txt中搜索包含有”hello”的行并计算其行数。<br />
在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。<br />
重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。<br />
&gt; 写入文件并覆盖旧文件<br />
&gt;&gt; 加到文件的尾部，保留旧文件内容。<br />
反短斜线<br />
使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br />
命令：<br />
find . -mtime -1 -type f -print<br />
用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本：<br />
#!/bin/sh</p>

<h1 id="the-ticks-are-backticks-not-normal-quotes">The ticks are backticks (`) not normal quotes (&lsquo;):</h1>

<p>tar -zcvf lastmod.tar.gz <code>find . -mtime -1 -type f -print</code><br />
3) 流程控制<br />
&ldquo;if&rdquo; 表达式 如果条件为真则执行then后面的部分：<br />
if &hellip;.; then<br />
&hellip;.<br />
elif &hellip;.; then<br />
&hellip;.<br />
else<br />
&hellip;.<br />
fi<br />
大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…<br />
通常用&rdquo; [ ] &ldquo;来表示条件测试。注意这里的空格很重要。要确保方括号的空格。<br />
[ -f &ldquo;somefile&rdquo; ] ：判断是否是一个文件<br />
[ -x &ldquo;/bin/ls&rdquo; ] ：判断/bin/ls是否存在并有可执行权限<br />
[ -n &ldquo;$var&rdquo; ] ：判断$var变量是否有值<br />
[ &ldquo;$a&rdquo; = &ldquo;$b&rdquo; ] ：判断$a和$b是否相等<br />
执行man test可以查看所有测试表达式可以比较和判断的类型。<br />
直接执行以下脚本：<br />
#!/bin/sh<br />
if [ &ldquo;$SHELL&rdquo; = &ldquo;/bin/bash&rdquo; ]; then<br />
echo &ldquo;your login shell is the bash (bourne again shell)&rdquo;<br />
else<br />
echo &ldquo;your login shell is not bash but $SHELL&rdquo;<br />
fi<br />
变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。<br />
快捷操作符<br />
熟悉C语言的朋友可能会很喜欢下面的表达式：<br />
[ -f &ldquo;/etc/shadow&rdquo; ] &amp;&amp; echo &ldquo;This computer uses shadow passwors&rdquo;<br />
这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印”
This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：<br />
#!/bin/sh<br />
mailfolder=/var/spool/mail/james<br />
[ -r &ldquo;$mailfolder&rdquo; ]&rsquo; &lsquo;{ echo &ldquo;Can not read $mailfolder&rdquo; ; exit 1; }<br />
echo &ldquo;$mailfolder has mail from:&rdquo;<br />
grep &ldquo;^From &rdquo; $mailfolder<br />
该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的&rdquo;From&rdquo;
一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：<br />
-打印错误信息<br />
-退出程序<br />
我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。<br />
不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。<br />
case表达式可以用来匹配一个给定的字符串，而不是数字。<br />
case &hellip; in<br />
&hellip;) do something here ;;<br />
esac<br />
让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：<br />
file lf.gz<br />
这将返回：<br />
lf.gz: gzip compressed data, deflated, original filename,<br />
last modified: Mon Aug 27 23:09:18 2001, os: Unix<br />
我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：<br />
#!/bin/sh<br />
ftype=<code>file &quot;$1&quot;</code><br />
case &ldquo;$ftype&rdquo; in<br />
&rdquo;$1: Zip archive&rdquo;<em>)<br />
unzip &ldquo;$1&rdquo; ;;<br />
&rdquo;$1: gzip compressed&rdquo;</em>)<br />
gunzip &ldquo;$1&rdquo; ;;<br />
&rdquo;$1: bzip2 compressed&rdquo;*)<br />
bunzip2 &ldquo;$1&rdquo; ;;<br />
*) error &ldquo;File $1 can not be uncompressed with smartzip&rdquo;;;<br />
esac<br />
您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：<br />
smartzip articles.zip<br />
$1 就是字符串 articles.zip<br />
select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。<br />
select var in &hellip; ; do<br />
break<br />
done<br />
&hellip;. now $var can be used &hellip;.<br />
下面是一个例子：<br />
#!/bin/sh<br />
echo &ldquo;What is your favourite OS?&rdquo;<br />
select var in &ldquo;Linux&rdquo; &ldquo;Gnu Hurd&rdquo; &ldquo;Free BSD&rdquo; &ldquo;Other&rdquo;; do<br />
break<br />
done<br />
echo &ldquo;You have selected $var&rdquo;<br />
下面是该脚本运行的结果：<br />
What is your favourite OS?<br />
1) Linux<br />
2) Gnu Hurd<br />
3) Free BSD<br />
4) Other<br />
#? 1<br />
You have selected Linux<br />
您也可以在shell中使用如下的loop表达式：<br />
while &hellip;; do<br />
&hellip;.<br />
done<br />
while-loop 将运行直到表达式测试为真。will run while the expression that we test for is
true. 关键字&rdquo;break&rdquo; 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。<br />
for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br />
for var in &hellip;.; do<br />
&hellip;.<br />
done<br />
在下面的例子中，将分别打印ABC到屏幕上：</p>

<p>复制代码 代码如下:</p>

<p>#!/bin/sh<br />
for var in A B C ; do<br />
echo &ldquo;var is $var&rdquo;<br />
done</p>

<p>下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：</p>

<p>?</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>4</p>

<p>5</p>

<p>6</p>

<p>7</p>

<p>8</p>

<p>9</p>

<p>10</p>

<p>11</p>

<p>12</p>

<p>|</p>

<p>#!/bin/sh</p>

<h1 id="list-a-content-summary-of-a-number-of-rpm-packages">list a content summary of a number of RPM packages</h1>

<h1 id="usage-showrpm-rpmfile1-rpmfile2">USAGE: showrpm rpmfile1 rpmfile2 &hellip;</h1>

<h1 id="example-showrpm-cdrom-redhat-rpms-rpm">EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm</h1>

<p>for rpmpackage in $*; do</p>

<p>if [ -r &ldquo;$rpmpackage&rdquo; ];then</p>

<p>echo &ldquo;=============== $rpmpackage ==============&rdquo;</p>

<p>rpm -qi -p $rpmpackage</p>

<p>else</p>

<p>echo &ldquo;ERROR: cannot read file $rpmpackage&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>&mdash;|&mdash;</p>

<p>这里出现了第二个特殊的变量$<em>，该变量包含了所有输入的命令行参数值。如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm<br />
此时 $</em> 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.<br />
引号<br />
在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符（比如*）替换成合适的文件名，它变量替换成变量值。为了防
止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。</p>

<p>#!/bin/sh<br />
echo <em>.jpg<br />
这将打印出&rdquo;mail.jpg tux.jpg&rdquo;的结果。<br />
引号 (单引号和双引号) 将防止这种通配符扩展：<br />
#!/bin/sh<br />
echo &ldquo;</em>.jpg&rdquo;<br />
echo &lsquo;<em>.jpg&rsquo;<br />
这将打印&rdquo;</em>.jpg&rdquo; 两次。<br />
单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。<br />
#!/bin/sh<br />
echo $SHELL<br />
echo &ldquo;$SHELL&rdquo;<br />
echo &lsquo;$SHELL&rsquo;<br />
运行结果为：<br />
/bin/bash<br />
/bin/bash<br />
$SHELL<br />
最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：<br />
echo *.jpg<br />
echo $SHELL<br />
这将输出：<br />
*.jpg<br />
$SHELL<br />
Here documents<br />
当要将几行文字传递给一个命令时，here
documents（译者注：目前还没有见到过对该词适合的翻译）一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here
documents就不必用echo函数一行行输出。 一个 &ldquo;Here document&rdquo; 以 &lt;</p>

<p>复制代码 代码如下:</p>

<p>#!/bin/sh</p>

<h1 id="we-have-less-than-3-arguments-print-the-help-text">we have less than 3 arguments. Print the help text:</h1>

<p>if [ $# -lt 3 ] ; then<br />
cat ren &ndash; renames a number of files using sed regular expressions<br />
USAGE: ren &lsquo;regexp&rsquo; &lsquo;replacement&rsquo; files&hellip;<br />
EXAMPLE: rename all *.HTM files in *.html:<br />
ren &lsquo;HTM$&rsquo; &lsquo;html&rsquo; *.HTM<br />
HELP<br />
exit 0<br />
fi<br />
OLD=&ldquo;$1&rdquo;<br />
NEW=&ldquo;$2&rdquo;</p>

<h1 id="the-shift-command-removes-one-argument-from-the-list-of">The shift command removes one argument from the list of</h1>

<h1 id="command-line-arguments">command line arguments.</h1>

<p>shift<br />
shift</p>

<h1 id="contains-now-all-the-files">$* contains now all the files:</h1>

<p>for file in $*; do<br />
if [ -f &ldquo;$file&rdquo; ] ; then<br />
newfile=<code>echo &quot;$file&quot; | sed &quot;s/${OLD}/${NEW}/g&quot;</code><br />
if [ -f &ldquo;$newfile&rdquo; ]; then<br />
echo &ldquo;ERROR: $newfile exists already&rdquo;<br />
else<br />
echo &ldquo;renaming $file to $newfile &hellip;&rdquo;<br />
mv &ldquo;$file&rdquo; &ldquo;$newfile&rdquo;<br />
fi<br />
fi<br />
done</p>

<p>这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是否小于3个 (特殊变量$# 表示包含参数的个数)
。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。如果输入参数等于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从参数列表中删除，这样原来的第三个参数就成为参数列表$*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。接着我们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目的：得到了旧文件名和新文件名。然后使用mv命令进行重命名。<br />
函数<br />
如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：</p>

<p>复制代码 代码如下:</p>

<p>functionname()<br />
{</p>

<h1 id="inside-the-body-1-is-the-first-argument-given-to-the-function">inside the body $1 is the first argument given to the function</h1>

<h1 id="2-the-second">$2 the second &hellip;</h1>

<p>body<br />
}</p>

<p>您需要在每个程序的开始对函数进行声明。</p>

<p>下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。</p>

<p>复制代码 代码如下:</p>

<p>#!/bin/sh</p>

<h1 id="vim-set-sw-4-ts-4-et">vim: set sw=4 ts=4 et:</h1>

<p>help()<br />
{<br />
cat xtitlebar &ndash; change the name of an xterm, gnome-terminal or kde konsole<br />
USAGE: xtitlebar [-h] &ldquo;string_for_titelbar&rdquo;<br />
OPTIONS: -h help text<br />
EXAMPLE: xtitlebar &ldquo;cvs&rdquo;<br />
HELP<br />
exit 0<br />
}</p>

<h1 id="in-case-of-error-or-if-h-is-given-we-call-the-function-help">in case of error or if -h is given we call the function help:</h1>

<p>[ -z &ldquo;$1&rdquo; ] &amp;&amp; help<br />
[ &ldquo;$1&rdquo; = &ldquo;-h&rdquo; ] &amp;&amp; help</p>

<h1 id="send-the-escape-sequence-to-change-the-xterm-titelbar">send the escape sequence to change the xterm titelbar:</h1>

<p>echo -e &ldquo;33]0;$107&rdquo;</p>

<p>在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。<br />
命令行参数<br />
我们已经见过$* 和 $1, $2 &hellip; $9
等特殊变量，这些特殊变量包含了用户从命令行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的参数和查看帮助的-
h选项）。但是在编写更复杂的程序时，您可能会发现您需要更多的自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (比如文件名)。<br />
有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。</p>

<p>复制代码 代码如下:</p>

<p>#!/bin/sh<br />
help()<br />
{<br />
cat This is a generic command line parser demo.<br />
USAGE EXAMPLE: cmdparser -l hello -f &ndash; -somefile1 somefile2<br />
HELP<br />
exit 0<br />
}<br />
while [ -n &ldquo;$1&rdquo; ]; do<br />
case $1 in<br />
-h) help;shift 1;; # function help is called<br />
-f) opt_f=1;shift 1;; # variable opt_f is set<br />
-l) opt_l=$2;shift 2;; # -l takes an argument -&gt; shift by 2<br />
--) shift;break;; # end of options<br />
-*) echo &ldquo;error: no such option $1. -h for help&rdquo;;exit 1;;<br />
*) break;;<br />
esac<br />
done</p>

<p>echo &ldquo;opt_f is $opt_f&rdquo;<br />
echo &ldquo;opt_l is $opt_l&rdquo;<br />
echo &ldquo;first arg is $1&rdquo;<br />
echo &ldquo;2nd arg is $2&rdquo;</p>

<p>您可以这样运行该脚本：<br />
cmdparser -l hello -f &ndash; -somefile1 somefile2<br />
返回的结果是：<br />
opt_f is 1<br />
opt_l is hello<br />
first arg is -somefile1<br />
2nd arg is somefile2<br />
这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，首先输入的应该是包含减号的参数。<br />
实例<br />
一般编程步骤<br />
现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：<br />
cp framework.sh myscript<br />
然后再插入自己的函数。<br />
让我们再看两个例子：<br />
二进制到十进制的转换<br />
脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：</p>

<p>复制代码 代码如下:</p>

<p>#!/bin/sh</p>

<h1 id="vim-set-sw-4-ts-4-et-1">vim: set sw=4 ts=4 et:</h1>

<p>help()<br />
{<br />
cat b2h &ndash; convert binary to decimal<br />
USAGE: b2h [-h] binarynum<br />
OPTIONS: -h help text<br />
EXAMPLE: b2h 111010<br />
will return 58<br />
HELP<br />
exit 0<br />
}<br />
error()<br />
{</p>

<h1 id="print-an-error-and-exit">print an error and exit</h1>

<p>echo &ldquo;$1&rdquo;<br />
exit 1<br />
}<br />
lastchar()<br />
{</p>

<h1 id="return-the-last-character-of-a-string-in-rval">return the last character of a string in $rval</h1>

<p>if [ -z &ldquo;$1&rdquo; ]; then</p>

<h1 id="empty-string">empty string</h1>

<p>rval=&ldquo;&rdquo;<br />
return<br />
fi</p>

<h1 id="wc-puts-some-space-behind-the-output-this-is-why-we-need-sed">wc puts some space behind the output this is why we need sed:</h1>

<p>numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed 's/ //g'</code></p>

<h1 id="now-cut-out-the-last-char">now cut out the last char</h1>

<p>rval=<code>echo -n &quot;$1&quot; | cut -b $numofchar</code><br />
}</p>

<p>chop()<br />
{</p>

<h1 id="remove-the-last-character-in-string-and-return-it-in-rval">remove the last character in string and return it in $rval</h1>

<p>if [ -z &ldquo;$1&rdquo; ]; then</p>

<h1 id="empty-string-1">empty string</h1>

<p>rval=&ldquo;&rdquo;<br />
return<br />
fi</p>

<h1 id="wc-puts-some-space-behind-the-output-this-is-why-we-need-sed-1">wc puts some space behind the output this is why we need sed:</h1>

<p>numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed 's/ //g'</code><br />
if [ &ldquo;$numofchar&rdquo; = &ldquo;1&rdquo; ]; then</p>

<h1 id="only-one-char-in-string">only one char in string</h1>

<p>rval=&ldquo;&rdquo;<br />
return<br />
fi<br />
numofcharminus1=<code>expr $numofchar &quot;-&quot; 1</code></p>

<h1 id="now-cut-all-but-the-last-char">now cut all but the last char:</h1>

<p>rval=<code>echo -n &quot;$1&quot; | cut -b 0-${numofcharminus1}</code><br />
}<br />
while [ -n &ldquo;$1&rdquo; ]; do<br />
case $1 in<br />
-h) help;shift 1;; # function help is called<br />
--) shift;break;; # end of options<br />
-*) error &ldquo;error: no such option $1. -h for help&rdquo;;;<br />
*) break;;<br />
esac<br />
done</p>

<h1 id="the-main-program">The main program</h1>

<p>sum=0<br />
weight=1</p>

<h1 id="one-arg-must-be-given">one arg must be given:</h1>

<p>[ -z &ldquo;$1&rdquo; ] &amp;&amp; help<br />
binnum=&ldquo;$1&rdquo;<br />
binnumorig=&ldquo;$1&rdquo;</p>

<p>while [ -n &ldquo;$binnum&rdquo; ]; do<br />
lastchar &ldquo;$binnum&rdquo;<br />
if [ &ldquo;$rval&rdquo; = &ldquo;1&rdquo; ]; then<br />
sum=<code>expr &quot;$weight&quot; &quot;+&quot; &quot;$sum&quot;</code><br />
fi</p>

<h1 id="remove-the-last-position-in-binnum">remove the last position in $binnum</h1>

<p>chop &ldquo;$binnum&rdquo;<br />
binnum=&ldquo;$rval&rdquo;<br />
weight=<code>expr &quot;$weight&quot; &quot;*&quot; 2</code><br />
done<br />
echo &ldquo;binary $binnumorig is decimal $sum&rdquo;<br />
#</p>

<p>该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制&rdquo;10&rdquo;可以这样转换成十进制：<br />
0 * 1 + 1 * 2 = 2<br />
为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc
–c计算字符个数，然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。<br />
文件循环程序<br />
或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的脚本rotatefile
可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，而对于outmail.1就变成了outmail.2
等等等等&hellip;</p>

<p>复制代码 代码如下:</p>

<p>#!/bin/sh</p>

<h1 id="vim-set-sw-4-ts-4-et-2">vim: set sw=4 ts=4 et:</h1>

<p>ver=&ldquo;0.1&rdquo;<br />
help()<br />
{<br />
cat rotatefile &ndash; rotate the file name</p>

<p>USAGE: rotatefile [-h] filename</p>

<p>OPTIONS: -h help text<br />
EXAMPLE: rotatefile out<br />
This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1<br />
and create an empty out-file<br />
The max number is 10<br />
version $ver<br />
HELP<br />
exit 0<br />
}</p>

<p>error()<br />
{<br />
echo &ldquo;$1&rdquo;<br />
exit 1<br />
}<br />
while [ -n &ldquo;$1&rdquo; ]; do<br />
case $1 in<br />
-h) help;shift 1;;<br />
--) break;;<br />
-*) echo &ldquo;error: no such option $1. -h for help&rdquo;;exit 1;;<br />
*) break;;<br />
esac<br />
done</p>

<h1 id="input-check">input check:</h1>

<p>if [ -z &ldquo;$1&rdquo; ] ; then<br />
error &ldquo;ERROR: you must specify a file, use -h for help&rdquo;<br />
fi<br />
filen=&ldquo;$1&rdquo;</p>

<h1 id="rename-any-1-2-etc-file">rename any .1 , .2 etc file:</h1>

<p>for n in 9 8 7 6 5 4 3 2 1; do<br />
if [ -f &ldquo;$filen.$n&rdquo; ]; then<br />
p=<code>expr $n + 1</code><br />
echo &ldquo;mv $filen.$n $filen.$p&rdquo;<br />
mv $filen.$n $filen.$p<br />
fi<br />
done</p>

<h1 id="rename-the-original-file">rename the original file:</h1>

<p>if [ -f &ldquo;$filen&rdquo; ]; then<br />
echo &ldquo;mv $filen $filen.1&rdquo;<br />
mv $filen $filen.1<br />
fi<br />
echo touch $filen<br />
touch $filen</p>

<p>这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。<br />
调试<br />
最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。<br />
shell也有一个真实的调试模式。如果在脚本&rdquo;strangescript&rdquo; 中有错误，您可以这样来进行调试：<br />
sh -x strangescript<br />
这将执行该脚本并显示所有变量的值。<br />
shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：<br />
sh -n your_script<br />
这将返回所有语法错误。<br />
我们希望您现在可以开始写您自己的shell脚本，希望您玩得开心。</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>