<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell编程大全 | 开发者问答集锦</title>
    <meta property="og:title" content="shell编程大全 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell编程大全">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell编程大全</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>译者序</p>

<p>毫无疑问，UNIX/Linux最重要的软件之一就是shell，目前最流行的shell被称为Bash(Bourne Again
Shell)，几乎所有的Linux和绝大部分的UNIX都<br />
可以使用Bash。作为系统与用户之间的交互接口，shell几乎是你在UNIX工作平台上最亲密的朋友，因此，学好shell，是学习Linux/UNIX的的开始，<br />
并且它会始终伴随你的工作学习。</p>

<p>shell是如此地重要，但令人惊奇的是，介绍shell的书没有真正令人满意的。所幸的是，我看到了这本被人称为abs的书，这本书介绍了bash大量的细<br />
节和广阔的范围，我遇到的绝大部分的技术问题&ndash;无论是我忘记的或是以前没有发现的&ndash;都可以在这本书里找到答案。这本使用大量的例子详细地介绍<br />
了Bash的语法，各种技巧，调试等等的技术，以循序渐进的学习方式，让你了解Bash的所有特性，在书中还有许多练习可以引导你思考，以得到更深入<br />
的知识。无论你是新手还是老手，或是使用其他语言的程序员，我能肯定你能在此书用受益。而本书除了介绍BASH的知识之外，也有许多有用的关<br />
于Linux/UNIX的知识和其他shell的介绍。</p>

<p>在看到本书的英文版后，我决定把它翻译出来，在Linuxsir论坛上结识了译者之一杨春敏共同翻译这本书，600多页的书是本大部头的书，我们花<br />
了6个月的业余时间才翻译完了。</p>

<p>关于版权的问题，英文版的作者Mendel Cooper对英文版的版权做了详细的约定，请参考：Appendix Q.
Copyright。中文版版权由译者杨春敏和黄<br />
毅共同所有，在遵守英文版版权相应条款的条件下，欢迎在保留本书译者名字和版权说明以非盈利的方式自由发布此中文版，以盈利目的的所有行<br />
为必须联系英文作者和两位中文译者以获得许可。</p>

<p>本书得以成稿，我（黄毅）要多谢我的女朋友，本该给予她的时间我用来了翻译，多谢你的理解，你是一个很棒的女朋友！</p>

<p>译者 杨春敏 黄毅<br />
2006.5.15</p>

<p>Advanced Bash-Scripting Guide<br />
&lt;&gt;<br />
一本深入学习shell脚本艺术的书籍</p>

<p>Version 3.7.2<br />
2005/11/16</p>

<p>作者:Mendel Cooper</p>

<p>mail:thegrendel@theriver.com</p>

<p>这本书假定你没有任何脚本或一般程序的编程知识,但是如果你有相关的知识,那么你将很容易<br />
达到中高级的水平&hellip;all the while sneaking in little snippets of UNIX? wisdom and<br />
lore(这句不知道怎么译).你可以把本书作为教材,自学手册,或者你获得shell脚本技术的文档.<br />
书中的练习和例子脚本中的注释将会与读者有更好的互动,但是最关键的前提是:<br />
想真正学习脚本编程的唯一途径就是编写脚本.</p>

<p>这本书也可作为教材来讲解一般的编程概念.</p>

<p>下载本书最新版本,<a href="http://personal.riverusers.com/~thegrendel/abs-guide-3.7.tar.bz2">http://personal.riverusers.com/~thegrendel/abs-guide-3.7.tar.bz2</a>,<br />
这是一个以tar和bzip2进行打包的,并且是以HTML来发行的.当然,你也可以获得本书的pdf版本<br />
在<a href="http://www.tldp.org/LDP/abs/abs-guide.pdf.可以在">http://www.tldp.org/LDP/abs/abs-guide.pdf.可以在</a><br />
<a href="http://personal.riverusers.com/~thegrendel/Change.log中查看修订历史">http://personal.riverusers.com/~thegrendel/Change.log中查看修订历史</a>.</p>

<p>译者:杨春敏，黄毅<br />
mail:chunmin.yang@gmail.com</p>

<p>一直想好好学习一下bash,可惜网上的资料都杂乱不堪,我还是喜欢通过一本书系统的学习.这本<br />
书来得正是时候.本书的作者真是非常的严谨,从例子里的改进人名单就能看出来.可惜我水平真<br />
的是非常有限,好多地方估计译得都有问题.希望阅读的朋友们多多提些修改建议.我会尽我的最<br />
大努力去修正它.</p>

<p>目录<br />
++++<br />
第一部分. 热身</p>

<p>1. 为什么使用shell编程<br />
2. 带着一个Sha-Bang出发(Sha-Bang指的是#!)</p>

<p>2.1. 调用一个脚本<br />
2.2. 初步的练习</p>

<p>第二部分. 基本</p>

<p>3. 特殊字符<br />
4. 变量和参数的介绍</p>

<p>4.1. 变量替换<br />
4.2. 变量赋值<br />
4.3. Bash变量是不分类型的<br />
4.4. 特殊的变量类型</p>

<p>5. 引用(翻译的可能有问题,特指引号)</p>

<p>5.1. 引用变量<br />
5.2. 转义(\)</p>

<p>6. 退出和退出状态<br />
7. Tests</p>

<p>7.1. Test结构<br />
7.2. 文件测试操作<br />
7.3. 其他比较操作<br />
7.4. 嵌套的if/then条件test<br />
7.5. 检查你的test知识</p>

<p>8. 操作符和相关的主题</p>

<p>8.1. 操作符<br />
8.2. 数字常量</p>

<p>第三部分. 超越基本</p>

<p>9. 变量重游</p>

<p>9.1. 内部变量<br />
9.2. 操作字符串<br />
9.3. 参数替换<br />
9.4. 指定类型的变量:declare或者typeset<br />
9.5. 变量的间接引用<br />
9.6. $RANDOM: 产生随机整数<br />
9.7. 双圆括号结构</p>

<p>10. 循环和分支</p>

<p>10.1. 循环<br />
10.2. 嵌套循环<br />
10.3. 循环控制<br />
10.4. 测试与分支(case和select结构)</p>

<p>11. 内部命令与内建</p>

<p>11.1. 作业控制命令</p>

<p>12. 外部过滤器,程序和命令</p>

<p>12.1. 基本命令<br />
12.2. 复杂命令<br />
12.3. 时间/日期 命令<br />
12.4. 文本处理命令<br />
12.5. 文件与归档命令<br />
12.6. 通讯命令<br />
12.7. 终端控制命令<br />
12.8. 数学计算命令<br />
12.9. 混杂命令</p>

<p>13. 系统与管理命令</p>

<p>13.1. 分析一个系统脚本</p>

<p>14. 命令替换<br />
15. 算术扩展<br />
16. I/O 重定向</p>

<p>16.1. 使用exec<br />
16.2. 代码块的重定向<br />
16.3. 应用</p>

<p>17. Here Documents</p>

<p>17.1. Here Strings</p>

<p>18. 休息时间</p>

<p>Part 4. 高级</p>

<p>19. 正则表达式</p>

<p>19.1. 一个简要的正则表达式介绍<br />
19.2. 通配</p>

<p>20. 子shell(Subshells)<br />
21. 受限shell(Restricted Shells)<br />
22. 进程替换<br />
23. 函数</p>

<p>23.1. 复杂函数和函数复杂性<br />
23.2. 局部变量<br />
23.3. 不使用局部变量的递归</p>

<p>24. 别名(Aliases)<br />
25. 列表结构<br />
26. 数组<br />
27. /dev 和 /proc</p>

<p>27.1. /dev<br />
27.2. /proc</p>

<p>28. 关于Zeros和Nulls<br />
29. 调试<br />
30. 选项<br />
31. Gotchas<br />
32. 脚本编程风格</p>

<p>32.1. 非官方的Shell脚本风格</p>

<p>33. 杂项</p>

<p>33.1. 交互式和非交互式的shells和脚本<br />
33.2. Shell 包装<br />
33.3. 测试和比较: 另一种方法<br />
33.4. 递归<br />
33.5. 彩色脚本<br />
33.6. 优化<br />
33.7. 各种小技巧<br />
33.8. 安全话题</p>

<p>33.8.1. 被感染的脚本<br />
33.8.2. 隐藏Shell脚本源码</p>

<p>33.9. 移植话题<br />
33.10. 在Windows下进行Shell编程</p>

<p>34. Bash, 版本 2 和 3</p>

<p>34.1. Bash, 版本2<br />
34.2. Bash, 版本3</p>

<p>35. 后记</p>

<p>35.1. 作者后记<br />
35.2. 关于作者<br />
35.3. 哪里可以取得帮助?<br />
35.4. 制作这本书的工具</p>

<p>35.4.1. 硬件<br />
35.4.2. 软件和排版软件</p>

<p>35.5. Credits</p>

<p>Bibliography<br />
A. Contributed Scripts<br />
B. Reference Cards<br />
C. A Sed and Awk Micro-Primer</p>

<p>C.1. Sed<br />
C.2. Awk</p>

<p>D. Exit Codes With Special Meanings<br />
E. A Detailed Introduction to I/O and I/O Redirection<br />
F. Standard Command-Line Options<br />
G. Important Files<br />
H. Important System Directories<br />
I. Localization<br />
J. History Commands<br />
K. A Sample .bashrc File<br />
L. Converting DOS Batch Files to Shell Scripts<br />
M. Exercises</p>

<p>M.1. Analyzing Scripts<br />
M.2. Writing Scripts</p>

<p>N. Revision History<br />
O. Mirror Sites<br />
P. To Do List<br />
Q. Copyright</p>

<p>表格清单:</p>

<p>11-1. 作业标识符<br />
30-1. Bash 选项<br />
33-1. 转义序列中数值和彩色的对应<br />
B-1. Special Shell Variables<br />
B-2. TEST Operators: Binary Comparison<br />
B-3. TEST Operators: Files<br />
B-4. Parameter Substitution and Expansion<br />
B-5. String Operations<br />
B-6. Miscellaneous Constructs<br />
C-1. Basic sed operators<br />
C-2. Examples of sed operators<br />
D-1. &ldquo;Reserved&rdquo; Exit Codes<br />
L-1. Batch file keywords / variables / operators, and their shell equivalents<br />
L-2. DOS commands and their UNIX equivalents<br />
N-1. Revision History</p>

<p>例子清单:</p>

<p>2-1. 清除:清除/var/log下的log文件<br />
2-2. 清除:一个改良的清除脚本<br />
2-3. cleanup:一个增强的和广义的删除logfile的脚本<br />
3-1. 代码块和I/O重定向<br />
3-2. 将一个代码块的结果保存到文件<br />
3-3. 在后台运行一个循环<br />
3-4. 备份最后一天所有修改的文件.<br />
4-1. 变量赋值和替换<br />
4-2. 一般的变量赋值<br />
4-3. 变量赋值,一般的和比较特殊的<br />
4-4. 整型还是string?<br />
4-5. 位置参数<br />
4-6. wh,whois节点名字查询<br />
4-7. 使用shift<br />
5-1. echo一些诡异的变量<br />
5-2. 转义符<br />
6-1. exit/exit状态<br />
6-2. 否定一个条件使用!<br />
7-1. 什么情况下为真?<br />
7-2. 几个等效命令test,/usr/bin/test,[],和/usr/bin/[<br />
7-3. 算数测试使用(( ))<br />
7-4. test死的链接文件<br />
7-5. 数字和字符串比较<br />
7-6. 测试字符串是否为null<br />
7-7. zmore<br />
8-1. 最大公约数<br />
8-2. 使用算术操作符<br />
8-3. 使用&amp;&amp;和||进行混合状态的test<br />
8-4. 数字常量的处理<br />
9-1. $IFS和空白<br />
9-2. 时间输入<br />
9-3. 再来一个时间输入<br />
9-4. Timed read<br />
9-5. 我是root?<br />
9-6. arglist:通过$*和$@列出所有的参数<br />
9-7. 不一致的$*和$@行为<br />
9-8. 当$IFS为空时的$*和$@<br />
9-9. 下划线变量<br />
9-10. 在一个文本文件的段间插入空行<br />
9-11. 利用修改文件名,来转换图片格式<br />
9-12. 模仿getopt命令<br />
9-13. 提取字符串的一种可选的方法<br />
9-14. 使用参数替换和error messages<br />
9-15. 参数替换和&rdquo;usage&rdquo;messages<br />
9-16. 变量长度<br />
9-17. 参数替换中的模式匹配<br />
9-18. 重命名文件扩展名<br />
9-19. 使用模式匹配来分析比较特殊的字符串<br />
9-20. 对字符串的前缀或后缀使用匹配模式<br />
9-21. 使用declare来指定变量的类型<br />
9-22. 间接引用<br />
9-23. 传递一个间接引用给awk<br />
9-24. 产生随机数<br />
9-25. 从一副扑克牌中取出一张随机的牌<br />
9-26. 两个指定值之间的随机数<br />
9-27. 使用随机数来摇一个骰子<br />
9-28. 重新分配随机数种子<br />
9-29. 使用awk产生伪随机数<br />
9-30. C风格的变量处理<br />
10-1. 循环的一个简单例子<br />
10-2. 每个[list]元素带两个参数的for循环<br />
10-3. 文件信息:对包含在变量中的文件列表进行操作<br />
10-4. 在for循环中操作文件<br />
10-5. 在for循环中省略[list]<br />
10-6. 使用命令替换来产生for循环的[list]<br />
10-7. 对于二进制文件的一个grep替换<br />
10-8. 列出系统上的所有用户<br />
10-9. 在目录的所有文件中查找源字串<br />
10-10. 列出目录中所有的符号连接文件<br />
10-11. 将目录中的符号连接文件名保存到一个文件中<br />
10-12. 一个C风格的for循环<br />
10-13. 在batch mode中使用efax<br />
10-14. 简单的while循环<br />
10-15. 另一个while循环<br />
10-16. 多条件的while循环<br />
10-17. C风格的while循环<br />
10-18. until循环<br />
10-19. 嵌套循环<br />
10-20. break和continue命令在循环中的效果<br />
10-21. 多层循环的退出<br />
10-22. 多层循环的continue<br />
10-23. 在实际的任务中使用&rdquo;continue N&rdquo;<br />
10-24. 使用case<br />
10-25. 使用case来创建菜单<br />
10-26. 使用命令替换来产生case变量<br />
10-27. 简单字符串匹配<br />
10-28. 检查是否是字母输入<br />
10-29. 用select来创建菜单<br />
10-30. 用函数中select结构来创建菜单<br />
11-1. 一个fork出多个自己实例的脚本<br />
11-2. printf<br />
11-3. 使用read,变量分配<br />
11-4. 当使用一个不带变量参数的read命令时,将会发生什么?<br />
11-5. read命令的多行输入<br />
11-6. 检测方向键<br />
11-7. 通过文件重定向来使用read<br />
11-8. 管道输出到read中的问题<br />
11-9. 修改当前的工作目录<br />
11-10. 用&rdquo;let&rdquo;命令来作算术操作.<br />
11-11. 显示eval命令的效果<br />
11-12. 强制登出(log-off)<br />
11-13. 另一个&rdquo;rot13&rdquo;的版本<br />
11-14. 在Perl脚本中使用eval命令来强制变量替换<br />
11-15. 使用set来改变脚本的位置参数<br />
11-16. 重新分配位置参数<br />
11-17. Unset一个变量<br />
11-18. 使用export命令传递一个变量到一个内嵌awk的脚本中<br />
11-19. 使用getopts命令来读取传递给脚本的选项/参数.<br />
11-20. &ldquo;Including&rdquo;一个数据文件<br />
11-21. 一个没什么用的,source自身的脚本<br />
11-22. exec的效果<br />
11-23. 一个exec自身的脚本<br />
11-24. 在继续处理之前,等待一个进程的结束<br />
11-25. 一个结束自身的脚本.<br />
12-1. 使用ls命令来创建一个烧录CDR的内容列表<br />
12-2. Hello or Good-bye<br />
12-3. 删除当前目录下文件名中包含一些特殊字符(包括空白)的文件..<br />
12-4. 通过文件的 inode 号来删除文件<br />
12-5. Logfile: 使用 xargs 来监控系统 log<br />
12-6. 把当前目录下的文件拷贝到另一个文件中<br />
12-7. 通过名字Kill进程<br />
12-8. 使用xargs分析单词出现的频率<br />
12-9. 使用 expr<br />
12-10. 使用 date 命令<br />
12-11. 分析单词出现的频率<br />
12-12. 那个文件是脚本?<br />
12-13. 产生10进制随机数<br />
12-14. 使用 tail 命令来监控系统log<br />
12-15. 在一个脚本中模仿 &ldquo;grep&rdquo; 的行为<br />
12-16. 在1913年的韦氏词典中查找定义<br />
12-17. 检查列表中单词的正确性<br />
12-18. 转换大写: 把一个文件的内容全部转换为大写.<br />
12-19. 转换小写: 将当前目录下的所有文全部转换为小写.<br />
12-20. Du: DOS 到 UNIX 文本文件的转换.<br />
12-21. rot13: rot13, 弱智加密.<br />
12-22. Generating &ldquo;Crypto-Quote&rdquo; Puzzles<br />
12-23. 格式化文件列表.<br />
12-24. 使用 column 来格式化目录列表<br />
12-25. nl: 一个自己计算行号的脚本.<br />
12-26. manview: 查看格式化的man页<br />
12-27. 使用 cpio 来拷贝一个目录树<br />
12-28. 解包一个 rpm 归档文件<br />
12-29. 从 C 文件中去掉注释<br />
12-30. Exploring /usr/X11R6/bin<br />
12-31. 一个&rdquo;改进过&rdquo;的 strings 命令<br />
12-32. 在一个脚本中使用 cmp 来比较2个文件.<br />
12-33. basename 和 dirname<br />
12-34. 检查文件完整性<br />
12-35. Uudecod 编码后的文件<br />
12-36. 查找滥用的连接来报告垃圾邮件发送者<br />
12-37. 分析一个垃圾邮件域<br />
12-38. 获得一份股票报价<br />
12-39. 更新 Fedora Core 4<br />
12-40. 使用 ssh<br />
12-41. 一个可以mail自己的脚本<br />
12-42. 按月偿还贷款<br />
12-43. 数制转换<br />
12-44. 使用 &ldquo;here document&rdquo; 来调用 bc<br />
12-45. 计算圆周率<br />
12-46. 将10进制数字转换为16进制数字<br />
12-47. 因子分解<br />
12-48. 计算直角三角形的斜边<br />
12-49. 使用 seq 来产生循环参数<br />
12-50. 字母统计<br />
12-51. 使用getopt来分析命令行选项<br />
12-52. 一个拷贝自身的脚本<br />
12-53. 练习dd<br />
12-54. 记录按键<br />
12-55. 安全的删除一个文件<br />
12-56. 文件名产生器<br />
12-57. 将米转换为英里<br />
12-58. 使用 m4<br />
13-1. 设置一个新密码<br />
13-2. 设置一个擦除字符<br />
13-3. 关掉终端对于密码的echo<br />
13-4. 按键检测<br />
13-5. Checking a remote server for identd<br />
13-6. pidof 帮助杀掉一个进程<br />
13-7. 检查一个CD镜像<br />
13-8. 在一个文件中创建文件系统<br />
13-9. 添加一个新的硬盘驱动器<br />
13-10. 使用umask来将输出文件隐藏起来<br />
13-11. killall, 来自于 /etc/rc.d/init.d<br />
14-1. 愚蠢的脚本策略<br />
14-2. 从循环的输出中产生一个变量<br />
14-3. 找anagram(回文构词法, 可以将一个有意义的单词, 变换为1个或多个有意义的单词, 但是还是原来的子母集合)<br />
16-1. 使用exec重定向标准输入<br />
16-2. 使用exec来重定向stdout<br />
16-3. 使用exec在同一脚本中重定向stdin和stdout<br />
16-4. 避免子shell<br />
16-5. while循环的重定向<br />
16-6. 另一种while循环的重定向<br />
16-7. until循环重定向<br />
16-8. for循环重定向<br />
16-9. for循环重定向 loop (将标准输入和标准输出都重定向了)<br />
16-10. 重定向if/then测试结构<br />
16-11. 用于上面例子的&rdquo;names.data&rdquo;数据文件<br />
16-12. 记录日志事件<br />
17-1. 广播: 发送消息给每个登录上的用户<br />
17-2. 仿造文件: 创建一个两行的仿造文件<br />
17-3. 使用cat的多行消息<br />
17-4. 带有抑制tab功能的多行消息<br />
17-5. 使用参数替换的here document<br />
17-6. 上传一个文件对到&rdquo;Sunsite&rdquo;的incoming目录<br />
17-7. 关闭参数替换<br />
17-8. 一个产生另外一个脚本的脚本<br />
17-9. Here documents与函数<br />
17-10. &ldquo;匿名&rdquo; here Document<br />
17-11. 注释掉一段代码块<br />
17-12. 一个自文档化(self-documenting)的脚本<br />
17-13. 在一个文件的开头添加文本<br />
20-1. 子shell中的变量作用域<br />
20-2. 列出用户的配置文件<br />
20-3. 在子shell里进行串行处理<br />
21-1. 在受限的情况下运行脚本<br />
23-1. 简单函数<br />
23-2. 带着参数的函数<br />
23-3. 函数和被传给脚本的命令行参数<br />
23-4. 传递间接引用给函数<br />
23-5. 解除传递给函数的参数引用<br />
23-6. 再次尝试解除传递给函数的参数引用<br />
23-7. 两个数中的最大者<br />
23-8. 把数字转化成罗马数字<br />
23-9. 测试函数最大的返回值<br />
23-10. 比较两个大整数<br />
23-11. 用户名的真实名<br />
23-12. 局部变量的可见范围<br />
23-13. 用局部变量来递归<br />
23-14. 汉诺塔<br />
24-1. 脚本中的别名<br />
24-2. unalias: 设置和删除别名<br />
25-1. 使用&rdquo;与列表(and list)&ldquo;来测试命令行参数<br />
25-2. 用&rdquo;与列表&rdquo;的另一个命令行参数测试<br />
25-3. &ldquo;或列表&rdquo;和&rdquo;与列表&rdquo;的结合使用<br />
26-1. 简单的数组用法<br />
26-2. 格式化一首诗<br />
26-3. 多种数组操作<br />
26-4. 用于数组的字符串操作符<br />
26-5. 将脚本的内容传给数组<br />
26-6. 一些数组专用的工具<br />
26-7. 关于空数组和空数组元素<br />
26-8. 初始化数组<br />
26-9. 复制和连接数组<br />
26-10. 关于连接数组的更多信息<br />
26-11. 一位老朋友: 冒泡排序<br />
26-12. 内嵌数组和间接引用<br />
26-13. 复杂数组应用: 埃拉托色尼素数筛子<br />
26-14. 模拟下推的堆栈<br />
26-15. 复杂的数组应用: 列出一种怪异的数学序列<br />
26-16. 模拟二维数组,并使它倾斜<br />
27-1. 利用/dev/tcp 来检修故障<br />
27-2. 搜索与一个PID相关的进程<br />
27-3. 网络连接状态<br />
28-1. 隐藏cookie而不再使用<br />
28-2. 用/dev/zero创建一个交换临时文件<br />
28-3. 创建ramdisk<br />
29-1. 一个错误的脚本<br />
29-2. 丢失关键字(keyword)<br />
29-3. 另一个错误脚本<br />
29-4. 用&rdquo;assert&rdquo;测试条件<br />
29-5. 捕捉 exit<br />
29-6. 在Control-C后清除垃圾<br />
29-7. 跟踪变量<br />
29-8. 运行多进程 (在多处理器的机器里)<br />
31-1. 数字和字符串比较是不相等同的<br />
31-2. 子SHELL缺陷<br />
31-3. 把echo的输出用管道输送给read命令<br />
33-1. shell 包装<br />
33-2. 稍微复杂一些的shell包装<br />
33-3. 写到日志文件的shell包装<br />
33-4. 包装awk的脚本<br />
33-5. 另一个包装awk的脚本<br />
33-6. 把Perl嵌入Bash脚本<br />
33-7. Bash 和 Perl 脚本联合使用<br />
33-8. 递归调用自己本身的(无用)脚本<br />
33-9. 递归调用自己本身的(有用)脚本<br />
33-10. 另一个递归调用自己本身的(有用)脚本<br />
33-11. 一个 &ldquo;彩色的&rdquo; 地址资料库<br />
33-12. 画盒子<br />
33-13. 显示彩色文本<br />
33-14. &ldquo;赛马&rdquo; 游戏<br />
33-15. 返回值技巧<br />
33-16. 整型还是string?<br />
33-17. 传递和返回数组<br />
33-18. anagrams游戏<br />
33-19. 在shell脚本中调用的窗口部件<br />
34-1. 字符串扩展<br />
34-2. 间接变量引用 - 新方法<br />
34-3. 使用间接变量引用的简单数据库应用<br />
34-4. 用数组和其他的小技巧来处理四人随机打牌</p>

<p>A-1. mailformat: Formatting an e-mail message<br />
A-2. rn: A simple-minded file rename utility<br />
A-3. blank-rename: renames filenames containing blanks<br />
A-4. encryptedpw: Upnning to an ftp site, using a locally encrypted password<br />
A-5. copy-cd: Copying a data CD<br />
A-6. Collatz series<br />
A-7. days-between: Calculate number of days between two dates<br />
A-8. Make a &ldquo;dictionary&rdquo;<br />
A-9. Soundex conversion<br />
A-10. &ldquo;Game of Life&rdquo;<br />
A-11. Data file for &ldquo;Game of Life&rdquo;<br />
A-12. behead: Removing mail and news message headers<br />
A-13. ftpget: Downloading files via ftp<br />
A-14. password: Generating random 8-character passwords<br />
A-15. fifo: Making daily backups, using named pipes<br />
A-16. Generating prime numbers using the modulo operator<br />
A-17. tree: Displaying a directory tree<br />
A-18. string functions: C-like string functions<br />
A-19. Directory information<br />
A-20. Object-oriented database<br />
A-21. Library of hash functions<br />
A-22. Colorizing text using hash functions<br />
A-23. Mounting USB keychain storage devices<br />
A-24. Preserving weblogs<br />
A-25. Protecting literal strings<br />
A-26. Unprotecting literal strings<br />
A-27. Spammer Identification<br />
A-28. Spammer Hunt<br />
A-29. Making wget easier to use<br />
A-30. A &ldquo;podcasting&rdquo; script<br />
A-31. Basics Reviewed<br />
A-32. An expanded cd command<br />
C-1. Counting Letter Occurrences<br />
K-1. Sample .bashrc file<br />
L-1. VIEWDATA.BAT: DOS Batch File<br />
L-2. viewdata.sh: Shell Script Conversion of VIEWDATA.BAT<br />
P-1. Print the server environment</p>

<p>第一部分 热身<br />
++++++++++++++++<br />
shell是一个命令解释器.是介于操作系统kernel与用户之间的一个绝缘层.准确地说,它也是一<br />
一种强力的计算机语言.一个shell程序,被称为一个脚本,是一种很容易使用的工具,它可以通过<br />
将系统调用,公共程序,工具,和编译过的二进制程序粘合在一起来建立应用.事实上,所有的UNIX<br />
命令和工具再加上公共程序,对于shell脚本来说,都是可调用的.如果这些你还觉得不够,那么<br />
shell内建命令,比如test与循环结构,也会给脚本添加强力的支持和增加灵活性.Shell脚本对于<br />
管理系统任务和其它的重复工作的例程来说,表现的非常好,根本不需要那些华而不实的成熟<br />
紧凑的程序语言.</p>

<h1 id="第1章-为什么使用shell编程">第1章 为什么使用shell编程</h1>

<p>没有程序语言是完美的.甚至没有一个唯一最好的语言,只有对于特定目的,比较适合和不适合<br />
的程序语言.<br />
Herbert Mayer</p>

<p>对于任何想适当精通一些系统管理知识的人来说,掌握shell脚本知识都是最基本的,即使这些<br />
人可能并不打算真正的编写一些脚本.想一下Linux机器的启动过程,在这个过程中,必将运行<br />
/etc/rc.d目录下的脚本来存储系统配置和建立服务.详细的理解这些启动脚本对于分析系统的<br />
行为是非常重要的,并且有时候可能必须修改它.</p>

<p>学习如何编写shell脚本并不是一件很困难的事,因为脚本可以分为很小的块,并且相对于shell<br />
特性的操作和选项[1]部分,只需要学习很小的一部分就可以了.语法是简单并且直观的,编写脚<br />
本很像是在命令行上把一些相关命令和工具连接起来,并且只有很少的一部分规则需要学习.<br />
绝大部分脚本第一次就可以正常的工作,而且即使调试一个长一些的脚本也是很直观的.</p>

<p>一个shell脚本是一个类似于小吃店的(quick and dirty)方法,在你使用原型设计一个复杂的<br />
应用的时候.在工程开发的第一阶段,即使从功能中取得很有限的一个子集放到shell脚本中来<br />
完成往往都是非常有用的.使用这种方法,程序的结果可以被测试和尝试运行,并且在处理使用<br />
诸如C/C++,Java或者Perl语言编写的最终代码前,主要的缺陷和陷阱往往就被发现了.</p>

<p>Shell脚本遵循典型的UNIX哲学,就是把大的复杂的工程分成小规模的子任务,并且把这些部件<br />
和工具组合起来.许多人认为这种办法更好一些,至少这种办法比使用那种高\大\全的语言更<br />
美,更愉悦,更适合解决问题.比如Perl就是这种能干任何事能适合任何人的语言,但是代价就是<br />
你需要强迫自己使用这种语言来思考解决问题的办法.</p>

<p>什么时候不使用Shell脚本</p>

<p>资源密集型的任务,尤其在需要考虑效率时(比如,排序,hash等等)</p>

<p>需要处理大任务的数学操作,尤其是浮点运算,精确运算,或者复杂的算术运算<br />
(这种情况一般使用C++或FORTRAN来处理)</p>

<p>有跨平台移植需求(一般使用C或Java)</p>

<p>复杂的应用,在必须使用结构化编程的时候(需要变量的类型检查,函数原型,等等)</p>

<p>对于影响系统全局性的关键任务应用。</p>

<p>对于安全有很高要求的任务,比如你需要一个健壮的系统来防止入侵,破解,恶意破坏等等.</p>

<p>项目由连串的依赖的各个部分组成。</p>

<p>需要大规模的文件操作</p>

<p>需要多维数组的支持</p>

<p>需要数据结构的支持,比如链表或数等数据结构</p>

<p>需要产生或操作图形化界面GUI</p>

<p>需要直接操作系统硬件</p>

<p>需要I/O或socket接口</p>

<p>需要使用库或者遗留下来的老代码的接口</p>

<p>私人的,闭源的应用(shell脚本把代码就放在文本文件中,全世界都能看到)</p>

<p>如果你的应用符合上边的任意一条,那么就考虑一下更强大的语言吧&ndash;或许是Perl,Tcl,Python,<br />
Ruby &ndash; 或者是更高层次的编译语言比如C/C++,或者是Java.即使如此,你会发现,使用shell<br />
来原型开发你的应用,在开发步骤中也是非常有用的.</p>

<p>我们将开始使用Bash,Bash是&rdquo;Bourne-Again shell&rdquo;首字母的缩写,也是Stephen Bourne的经典<br />
的Bourne shell的一个双关语,(译者:说实话,我一直搞不清这个双关语是什么意思,为什么叫<br />
&ldquo;Bourn-Again shell&rdquo;,这其中应该有个什么典故吧,哪位好心,告诉我一下^^).Bash已经成为了<br />
所有UNIX中shell脚本的事实上的标准了.同时这本书也覆盖了绝大部分的其他一些shell的原<br />
则,比如Korn Shell,Bash从ksh中继承了一部分特性,[2]C Shell和它的变种.(注意:C Shell<br />
编程是不被推荐的,因为一些特定的内在问题,Tom Christiansen在1993年10月指出了这个问题<br />
请在<a href="http://www.etext.org/Quartz/computer/unix/csh.harmful.gz中查看具体内容.)">http://www.etext.org/Quartz/computer/unix/csh.harmful.gz中查看具体内容.)</a></p>

<p>接下来是脚本的一些说明.在展示shell不同的特征之前,它可以减轻一些阅读书中例子<br />
的负担.本书中的例子脚本,都在尽可能的范围内进行了测试,并且其中的一些将使用在真<br />
实的生活中.读者可以运行这些例子脚本(使用scriptname.sh或者scriptname.bash的形式),<br />
[3]并给这些脚本执行权限(chmod u+rx scriptname),然后执行它们,看看发生了什么.如果存<br />
档的脚本不可用,那么就从本书的HTML,pdf或者text的发行版本中把它们拷贝粘贴出来.考虑到<br />
这些脚本中的内容在我们还没解释它之前就被列在这里,可能会影响读者的理解,这就需要读者<br />
暂时忽略这些内容.</p>

<p>除非特别注明,本书作者编写了本书中的绝大部分例子脚本.</p>

<p>注意事项:<br />
[1] 这些在builtins章节被引用,这些是shell的内部特征.<br />
[2] ksh88的许多特性,甚至是一些ksh93的特性都被合并到Bash中了.<br />
[3] 根据惯例,用户编写的Bourne shell脚本应该在脚本的名字后边加上.sh扩展名.<br />
一些系统脚本,比如那些在/etc/rc.d中的脚本,则不遵循这种命名习惯.</p>

<h1 id="第2章-带着一个sha-bang出发-sha-bang指的是">第2章 带着一个Sha-Bang出发(Sha-Bang指的是#!)</h1>

<p>在一个最简单的例子中,一个shell脚本其实就是将一堆系统命令列在一个文件中.它的最基本的<br />
用处就是,在你每次输入这些特定顺序的命令时可以少敲一些字.</p>

<p>Example 2-1 清除:清除/var/log下的log文件<br />
################################Start
Script#######################################<br />
1 # Cleanup<br />
2 # 当然要使用root身份来运行这个脚本<br />
3<br />
4 cd /var/log<br />
5 cat /dev/null &gt; messages<br />
6 cat /dev/null &gt; wtmp<br />
7 echo &ldquo;Logs cleaned up.&rdquo;<br />
################################End
Script#########################################<br />
这根本就没什么稀奇的, 只不过是命令的堆积, 来让从console或者xterm中一个一个的输入命<br />
令更方便一些.好处就是把所有命令都放在一个脚本中,不用每次都敲它们.这样的话,对于特定<br />
的应用来说,这个脚本就很容易被修改或定制.</p>

<p>Example 2-2 清除:一个改良的清除脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 一个Bash脚本的正确的开头部分.<br />
3<br />
4 # Cleanup, 版本 2<br />
5<br />
6 # 当然要使用root身份来运行.<br />
7 # 在此处插入代码,来打印错误消息,并且在不是root身份的时候退出.<br />
8<br />
9 LOG_DIR=/var/log<br />
10 # 如果使用变量,当然比把代码写死的好.<br />
11 cd $LOG_DIR<br />
12<br />
13 cat /dev/null &gt; messages<br />
14 cat /dev/null &gt; wtmp<br />
15<br />
16<br />
17 echo &ldquo;Logs cleaned up.&rdquo;<br />
18<br />
19 exit # 这个命令是一种正确并且合适的退出脚本的方法.<br />
################################End
Script#########################################</p>

<p>现在,让我们看一下一个真正意义的脚本.而且我们可以走得更远&hellip;<br />
Example 2-3. cleanup:一个增强的和广义的删除logfile的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 清除, 版本 3<br />
3<br />
4 # Warning:<br />
5 # &mdash;&mdash;-<br />
6 # 这个脚本有好多特征,这些特征是在后边章节进行解释的,大概是进行到本书的一半的<br />
7 # 时候,<br />
8 # 你就会觉得它没有什么神秘的了.<br />
9 #<br />
10<br />
11<br />
12<br />
13 LOG_DIR=/var/log<br />
14 ROOT_UID=0 # $UID为0的时候,用户才具有根用户的权限<br />
15 LINES=50 # 默认的保存行数<br />
16 E_XCD=66 # 不能修改目录?<br />
17 E_NOTROOT=67 # 非根用户将以error退出<br />
18<br />
19<br />
20 # 当然要使用根用户来运行<br />
21 if [ &ldquo;$UID&rdquo; -ne &ldquo;$ROOT_UID&rdquo; ]<br />
22 then<br />
23 echo &ldquo;Must be root to run this script.&rdquo;<br />
24 exit $E_NOTROOT<br />
25 fi<br />
26<br />
27 if [ -n &ldquo;$1&rdquo; ]<br />
28 # 测试是否有命令行参数(非空).<br />
29 then<br />
30 lines=$1<br />
31 else<br />
32 lines=$LINES # 默认,如果不在命令行中指定<br />
33 fi<br />
34<br />
35<br />
36 # Stephane Chazelas 建议使用下边<br />
37 #+ 的更好方法来检测命令行参数.<br />
38 #+ 但对于这章来说还是有点超前.<br />
39 #<br />
40 # E_WRONGARGS=65 # 非数值参数(错误的参数格式)<br />
41 #<br />
42 # case &ldquo;$1&rdquo; in<br />
43 # &ldquo;&rdquo; ) lines=50;;<br />
44 # <em>[!0-9]</em>) echo &ldquo;Usage: <code>basename $0</code> file-to-cleanup&rdquo;; exit
$E_WRONGARGS;;<br />
45 # * ) lines=$1;;<br />
46 # esac<br />
47 #<br />
48 #* 直到&rdquo;Loops&rdquo;的章节才会对上边的内容进行详细的描述.<br />
49<br />
50<br />
51 cd $LOG_DIR<br />
52<br />
53 if [ <code>pwd</code> != &ldquo;$LOG_DIR&rdquo; ] # 或者 if[ &ldquo;$PWD&rdquo; != &ldquo;$LOG_DIR&rdquo; ]<br />
54 # 不在 /var/log中?<br />
55 then<br />
56 echo &ldquo;Can&rsquo;t change to $LOG_DIR.&rdquo;<br />
57 exit $E_XCD<br />
58 fi # 在处理log file之前,再确认一遍当前目录是否正确.<br />
59<br />
60 # 更有效率的做法是<br />
61 #<br />
62 # cd /var/log || {<br />
63 # echo &ldquo;Cannot change to necessary directory.&rdquo; &gt;&amp;2<br />
64 # exit $E_XCD;<br />
65 # }<br />
66<br />
67<br />
68<br />
69<br />
70 tail -$lines messages &gt; mesg.temp # 保存log file消息的最后部分.<br />
71 mv mesg.temp messages # 变为新的log目录.<br />
72<br />
73<br />
74 # cat /dev/null &gt; messages<br />
75 #* 不再需要了,使用上边的方法更安全.<br />
76<br />
77 cat /dev/null &gt; wtmp # &lsquo;: &gt; wtmp&rsquo; 和 &lsquo;&gt; wtmp&rsquo;具有相同的作用<br />
78 echo &ldquo;Logs cleaned up.&rdquo;<br />
79<br />
80 exit 0<br />
81 # 退出之前返回0,返回0表示成功.<br />
82 #<br />
################################End
Script#########################################</p>

<p>因为你可能希望将系统log全部消灭,这个版本留下了log消息最后的部分.你将不断地找到新<br />
的方法来完善这个脚本,并提高效率.</p>

<p>要注意,在每个脚本的开头都使用&rdquo;#!&ldquo;,这意味着告诉你的系统这个文件的执行需要指定一个解<br />
释器.#!实际上是一个2字节[1]的魔法数字,这是指定一个文件类型的特殊标记, 换句话说, 在<br />
这种情况下,指的就是一个可执行的脚本(键入man magic来获得关于这个迷人话题的更多详细<br />
信息).在#!之后接着是一个路径名.这个路径名指定了一个解释脚本中命令的程序,这个程序可<br />
以是shell,程序语言或者是任意一个通用程序.这个指定的程序从头开始解释并且执行脚本中<br />
的命令(从#!行下边的一行开始),忽略注释.[2]<br />
如:<br />
1 #!/bin/sh<br />
2 #!/bin/bash<br />
3 #!/usr/bin/perl<br />
4 #!/usr/bin/tcl<br />
5 #!/bin/sed -f<br />
6 #!/usr/awk -f</p>

<p>上边每一个脚本头的行都指定了一个不同的命令解释器,如果是/bin/sh,那么就是默认shell<br />
(在Linux系统中默认是Bash).[3]使用#!/bin/sh,在大多数商业发行的UNIX上,默认是Bourne<br />
shell,这将让你的脚本可以正常的运行在非Linux机器上,虽然这将会牺牲Bash一些独特的特征.<br />
脚本将与POSIX[4] 的sh标准相一致.</p>

<p>注意: #! 后边给出的路径名必须是正确的,否则将会出现一个错误消息,通常是<br />
&ldquo;Command not found&rdquo;,这将是你运行这个脚本时所得到的唯一结果.</p>

<p>当然&rdquo;#!&ldquo;也可以被忽略,不过这样你的脚本文件就只能是一些命令的集合,不能够使用shell内建<br />
的指令了,如果不能使用变量的话,当然这也就失去了脚本编程的意义了.</p>

<p>注意:这个例子鼓励你使用模块化的方式来编写脚本,平时也要注意收集一些零碎的代码,<br />
这些零碎的代码可能用在你将来编写的脚本中.这样你就可以通过这些代码片段来构<br />
造一个较大的工程用例. 以下边脚本作为序,来测试脚本被调用的参数是否正确.<br />
################################Start
Script#######################################<br />
1 E_WRONG_ARGS=65<br />
2 script_parameters=&ldquo;-a -h -m -z&rdquo;<br />
3 # -a = all, -h = help, 等等.<br />
4<br />
5 if [ $# -ne $Number_of_expected_args ]<br />
6 then<br />
7 echo &ldquo;Usage: <code>basename $0</code> $script_parameters&rdquo;<br />
8 # <code>basename $0</code>是这个脚本的文件名<br />
9 exit $E_WRONG_ARGS<br />
10 fi<br />
################################End
Script#########################################<br />
大多数情况下,你需要编写一个脚本来执行一个特定的任务,在本章中第一个脚本就是一个这样<br />
的例子, 然后你会修改它来完成一个不同的,但比较相似的任务.用变量来代替写死的常量,就是<br />
一个好方法,将重复的代码放到一个函数中,也是一种好习惯.</p>

<p>2.1 调用一个脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;<br />
编写完脚本之后,你可以使用sh scriptname,[5]或者bash scriptname来调用它.<br />
(不推荐使用sh  更方便的方法是让脚本本身就具有可执行权限,通过chmod命令可以修改.</p>

<p>比如:<br />
chmod 555 scriptname (允许任何人都具有 可读和执行权限) [6]<br />
或:<br />
chmod +rx scriptname (允许任何人都具有 可读和执行权限)<br />
chmod u+rx scriptname (只给脚本的所有者 可读和执行权限)</p>

<p>既然脚本已经具有了可执行权限,现在你可以使用./scriptname.[7]来测试它了.如果这个脚本<br />
以一个&rdquo;#!&ldquo;行开头,那么脚本将会调用合适的命令解释器来运行.</p>

<p>最后一步,在脚本被测试和debug之后,你可能想把它移动到/usr/local/bin(当然是以root身份)<br />
,来让你的脚本对所有用户都有用.这样用户就可以直接敲脚本名字来运行了.</p>

<p>注意事项:<br />
[1] 那些具有UNIX味道的脚本(基于4.2BSD)需要一个4字节的魔法数字,在#!后边需要一个<br />
空格#! /bin/sh.<br />
[2] 脚本中的#!行的最重要的任务就是命令解释器(sh或者bash).因为这行是以#开始的,<br />
当命令解释器执行这个脚本的时候,会把它作为一个注释行.当然,在这之前,这行语句<br />
已经完成了它的任务,就是调用命令解释器.</p>

<p>如果在脚本的里边还有一个#!行,那么bash将把它认为是一个一般的注释行.<br />
1 #!/bin/bash<br />
2<br />
3 echo &ldquo;Part 1 of script.&rdquo;<br />
4 a=1<br />
5<br />
6 #!/bin/bash<br />
7 # 这将不会开始一个新脚本.<br />
8<br />
9 echo &ldquo;Part 2 of script.&rdquo;<br />
10 echo $a # Value of $a stays at 1.<br />
[3] 这里可以玩一些小技巧.<br />
1 #!/bin/rm<br />
2 # 自删除脚本.<br />
3<br />
4 # 当你运行这个脚本时,基本上什么都不会发生&hellip;除非这个文件消失不见.<br />
5<br />
6 WHATEVER=65<br />
7<br />
8 echo &ldquo;This line will never print (betcha!).&rdquo;<br />
9<br />
10 exit $WHATEVER # 没关系,脚本是不会在这退出的.<br />
当然,你还可以试试在一个README文件的开头加上#!/bin/more,并让它具有执行权限.<br />
结果将是文档自动列出自己的内容.(一个使用cat命令的here document可能是一个<br />
更好的选则,&ndash;见Example 17-3).<br />
[4] 可移植的操作系统接口,标准化类UNIX操作系统的一种尝试.POSIX规范可以在<br />
<a href="http://www.opengroup.org/onlinepubs/007904975/toc.htm中查阅">http://www.opengroup.org/onlinepubs/007904975/toc.htm中查阅</a>.<br />
[5] 小心:使用sh scriptname来调用脚本的时候将会关闭一些Bash特定的扩展,脚本可能<br />
因此而调用失败.<br />
[6] 脚本需要读和执行权限,因为shell需要读这个脚本.<br />
[7] 为什么不直接使用scriptname来调用脚本?如果你当前的目录下($PWD)正好有你想要<br />
执行的脚本,为什么它运行不了呢?失败的原因是,出于安全考虑,当前目录并没有被<br />
加在用户的$PATH变量中.因此,在当前目录下调用脚本必须使用./scriptname这种<br />
形式.</p>

<p>2.2 初步的练习<br />
-&mdash;&mdash;&mdash;&mdash;-<br />
1. 系统管理员经常会为了自动化一些常用的任务而编写脚本.举出几个这种有用的脚本的实例.<br />
2. 编写一个脚本,显示时间和日期,列出所有的登录用户,显示系统的更新时间.然后这个脚本<br />
将会把这些内容保存到一个log file中.</p>

<p>第二部分 基本<br />
++++++++++++++++</p>

<h1 id="第3章-特殊字符">第3章 特殊字符</h1>

<h1 id="注释-行首以-开头为注释-是个例外">注释,行首以#开头为注释(#!是个例外).</h1>

<p>1 # This line is a comment.</p>

<p>注释也可以存在于本行命令的后边.</p>

<p>1 echo &ldquo;A comment will follow.&rdquo; # 注释在这里<br />
2 # ^ 注意#前边的空白</p>

<p>注释也可以在本行空白的后边.</p>

<p>1 # A tab precedes this comment.</p>

<p>注意:命令是不能跟在同一行上注释的后边的,没有办法,在同一行上,注释的后边想<br />
要再使用命令,只能另起一行.<br />
当然,在echo命令中被转义的#是不能作为注释的.<br />
同样的,#也可以出现在特定的参数替换结构中或者是数字常量表达式中.</p>

<p>1 echo &ldquo;The # here does not begin a comment.&rdquo;<br />
2 echo &lsquo;The # here does not begin a comment.&rsquo;<br />
3 echo The \# here does not begin a comment.<br />
4 echo The # 这里开始一个注释<br />
5<br />
6 echo ${PATH#*:} # 参数替换,不是一个注释<br />
7 echo $(( 2#101011 )) # 数制转换,不是一个注释<br />
8<br />
9 # Thanks, S.C.</p>

<p>标准的引用和转义字符(&ldquo;&rsquo;\)可以用来转义#</p>

<p>; 命令分隔符,可以用来在一行中来写多个命令.</p>

<p>1 echo hello; echo there<br />
2<br />
3<br />
4 if [ -x &ldquo;$filename&rdquo; ]; then # 注意:&ldquo;if&rdquo;和&rdquo;then&rdquo;需要分隔<br />
5 # 为啥?<br />
6 echo &ldquo;File $filename exists.&rdquo;; cp $filename $filename.bak<br />
7 else<br />
8 echo &ldquo;File $filename not found.&rdquo;; touch $filename<br />
9 fi; echo &ldquo;File test complete.&rdquo;</p>

<p>有时候需要转义</p>

<p>;; 终止&rdquo;case&rdquo;选项.</p>

<p>1 case &ldquo;$variable&rdquo; in<br />
2 abc) echo &ldquo;\$variable = abc&rdquo; ;;<br />
3 xyz) echo &ldquo;\$variable = xyz&rdquo; ;;<br />
4 esac</p>

<p>. .命令等价于source命令(见Example 11-20).这是一个bash的内建命令.</p>

<p>. .作为文件名的一部分.如果作为文件名的前缀的话,那么这个文件将成为隐藏文件.<br />
将不被ls命令列出.</p>

<p>bash$ touch .hidden-file<br />
bash$ ls -l<br />
total 10<br />
-rw-r&ndash;r&ndash; 1 bozo 4034 Jul 18 22:04 data1.addressbook<br />
-rw-r&ndash;r&ndash; 1 bozo 4602 May 25 13:58 data1.addressbook.bak<br />
-rw-r&ndash;r&ndash; 1 bozo 877 Dec 17 2000 employment.addressbook</p>

<p>bash$ ls -al<br />
total 14<br />
drwxrwxr-x 2 bozo bozo 1024 Aug 29 20:54 ./<br />
drwx&mdash;&mdash; 52 bozo bozo 3072 Aug 29 20:51 ../<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 4034 Jul 18 22:04 data1.addressbook<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 4602 May 25 13:58 data1.addressbook.bak<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 877 Dec 17 2000 employment.addressbook<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 29 20:54 .hidden-file</p>

<p>.命令如果作为目录名的一部分的话,那么.表达的是当前目录.&ldquo;..&ldquo;表示上一级目录.</p>

<p>bash$ pwd<br />
/home/bozo/projects</p>

<p>bash$ cd .<br />
bash$ pwd<br />
/home/bozo/projects</p>

<p>bash$ cd ..<br />
bash$ pwd<br />
/home/bozo/</p>

<p>.命令经常作为一个文件移动命令的目的地.</p>

<p>bash$ cp /home/bozo/current_work/junk/* .</p>

<p>. .字符匹配,这是作为正则表达是的一部分,用来匹配任何的单个字符.</p>

<p>&rdquo; 部分引用.&ldquo;STRING&rdquo;阻止了一部分特殊字符,具体见第5章.</p>

<p>&rsquo; 全引用. &lsquo;STRING&rsquo; 阻止了全部特殊字符,具体见第5章.</p>

<p>, 逗号链接了一系列的算术操作,虽然里边所有的内容都被运行了,但只有最后一项被<br />
返回.</p>

<p>如:<br />
1 let &ldquo;t2 = ((a = 9, 15 / 3))&rdquo; # Set &ldquo;a = 9&rdquo; and &ldquo;t2 = 15 / 3&rdquo;</p>

<p>\ 转义字符,如\X等价于&rdquo;X&rdquo;或&rsquo;X&rsquo;,具体见第5章.</p>

<p>/ 文件名路径分隔符.或用来做除法操作.</p>

<dl>
<dt>` 后置引用,命令替换,具体见第14章</dt>
<dd><p>空命令,等价于&rdquo;NOP&rdquo;(no op,一个什么也不干的命令).也可以被认为与shell的内建命令(true)作用相同.&rdquo;:&ldquo;命令是一<br />
个bash的内建命令,它的返回值为0,就是shell返回的true.</p></dd>
</dl>

<p>如:<br />
1 :<br />
2 echo $? # 0</p>

<p>死循环,如:</p>

<p>1 while :<br />
2 do<br />
3 operation-1<br />
4 operation-2<br />
5 &hellip;<br />
6 operation-n<br />
7 done<br />
8<br />
9 # 与下边相同:<br />
10 # while true<br />
11 # do<br />
12 # &hellip;<br />
13 # done</p>

<p>在if/then中的占位符,如:<br />
1 if condition<br />
2 then : # 什么都不做,引出分支.<br />
3 else<br />
4 take-some-action<br />
5 fi</p>

<p>在一个2元命令中提供一个占位符,具体见Example 8-2,和&rdquo;默认参数&rdquo;.如:<br />
1 : ${username=<code>whoami</code>}<br />
2 # ${username=<code>whoami</code>} 如果没有&rdquo;:&ldquo;的话,将给出一个错误,除非&rdquo;username&rdquo;是<br />
3 # 个命令<br />
在here document中提供一个占位符,见Example 17-10.</p>

<p>使用&rdquo;参数替换&rdquo;来评估字符串变量(见Example 9-14).如:<br />
1 : ${HOSTNAME?} ${USER?} ${MAIL?}<br />
2 # 如果一个或多个必要的环境变量没被设置的话,<br />
3 #+ 就打印错误信息.</p>

<p>&ldquo;变量扩展/子串替换&rdquo;<br />
在和 &gt; (重定向操作符)结合使用时,把一个文件截断到0长度,没有修改它的权限.<br />
如果文件在之前并不存在,那么就创建它.如:<br />
1 : &gt; data.xxx #文件&rdquo;data.xxx&rdquo;现在被清空了.<br />
2<br />
3 #与 cat /dev/null &gt;data.xxx 的作用相同<br />
4 #然而,这不会产生一个新的进程,因为&rdquo;:&ldquo;是一个内建命令.<br />
具体参见Example 12-14.</p>

<p>在和&gt;&gt;重定向操作符结合使用时,将不会对想要附加的文件产生任何影响.<br />
如果文件不存在,将创建.<br />
注意: 这只适用于正规文件,而不是管道,符号连接,和某些特殊文件.</p>

<p>也可能用来作为注释行,虽然我们不推荐这么做.使用#来注释的话,将关闭剩余行的<br />
错误检查,所以可以在注释行中写任何东西.然而,使用:的话将不会这样.如:<br />
1 : This is a comment thar generates an error,(if [ $x -eq 3] ).</p>

<p>&ldquo;:&ldquo;还用来在/etc/passwd和$PATH变量中用来做分隔符.<br />
bash$ echo $PATH<br />
/usr/local/bin:/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games<br />
! 取反操作符,将反转&rdquo;退出状态&rdquo;结果,(见Example 6-2).也会反转test操作符的意义.比<br />
如修改=为!=.!操作是Bash的一个关键字.</p>

<p>在一个不同的上下文中,!也会出现在&rdquo;间接变量引用&rdquo;见Example 9-22.</p>

<p>在另一种上下文中,!还能反转bash的&rdquo;history mechanism&rdquo;(见附录J 历史命令)<br />
需要注意的是,在一个脚本中,&ldquo;history mechanism&rdquo;是被禁用的.</p>

<ul>
<li>万能匹配字符,用于文件名匹配(这个东西有个专有名词叫file globbing),或者是正则<br />
表达式中.注意:在正则表达式匹配中的作用和在文件名匹配中的作用是不同的.<br />
bash$ echo *<br />
abs-book.sgml add-drive.sh agram.sh alias.sh<br /></li>
<li>数学乘法.<br />
**是幂运算.<br />
? 测试操作.在一个确定的表达式中,用?来测试结果.<br />
(())结构可以用来做数学计算或者是写c代码,那?就是c语言的3元操作符的<br />
一个.<br />
在&rdquo;参数替换&rdquo;中,?测试一个变量是否被set了.<br />
? 在file globbing中和在正则表达式中一样匹配任意的单个字符.</li>
</ul>

<p>$ 变量替换<br />
1 var1=5<br />
2 var2=23skidoo<br />
3<br />
4 echo $var1 # 5<br />
5 echo $var2 # 23skidoo<br />
$ 在正则表达式中作为行结束符.<br />
${} 参数替换,见9.3节.<br />
$*,$@ 位置参数<br />
$? 退出状态变量.$?保存一个命令/一个函数或者脚本本身的退出状态.<br />
$$ 进程ID变量.这个$$变量保存运行脚本进程ID<br />
() 命令组.如:<br />
1 (a=hello;echo $a)<br />
注意:在()中的命令列表,将作为一个子shell来运行.<br />
在()中的变量,由于是在子shell中,所以对于脚本剩下的部分是不可用的.<br />
如:<br />
1 a=123<br />
2 ( a=321; )<br />
3<br />
4 echo &ldquo;a = $a&rdquo; # a = 123<br />
5 # 在圆括号中a变量,更像是一个局部变量.</p>

<p>用在数组初始化,如:<br />
1 Array=(element1,element2,element3)</p>

<p>{xxx,yyy,zzz&hellip;}<br />
大括号扩展,如:<br />
1 cat {file1,file2,file3} &gt; combined_file<br />
2 # 把file1,file2,file3连接在一起,并且重定向到combined_file中.<br />
3<br />
4<br />
5 cp file22.{txt,backup}<br />
6 # 拷贝&rdquo;file22.txt&rdquo; 到&rdquo;file22.backup&rdquo;中</p>

<p>一个命令可能会对大括号中的以逗号分割的文件列表起作用[1]. file globbing将对<br />
大括号中的文件名作扩展.<br />
注意: 在大括号中,不允许有空白,除非这个空白是有意义的.<br />
echo {file1,file2}\ :{\ A,&rdquo; B&rdquo;,&rsquo; C&rsquo;}<br />
file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C<br />
{} 代码块.又被称为内部组.事实上,这个结构创建了一个匿名的函数.但是与函数不同的<br />
是,在其中声明的变量,对于脚本其他部分的代码来说还是可见的.如:<br />
bash$<br />
{<br />
local a;<br />
a= 123;<br />
}<br />
bash中的local申请的变量只能够用在函数中.</p>

<p>1 a=123<br />
2 { a=321; }<br />
3 echo &ldquo;a = $a&rdquo; # a = 321 (说明在代码块中对变量a所作的修改,影响了外边的变量a)<br />
4<br />
5 # Thanks, S.C.</p>

<p>下边的代码展示了在{}结构中代码的I/O重定向.</p>

<p>Example 3-1. 代码块和I/O重定向<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 从 /etc/fstab中读行<br />
3<br />
4 File=/etc/fstab<br />
5<br />
6 {<br />
7 read line1<br />
8 read line2<br />
9 } &lt; $File<br />
10<br />
11 echo &ldquo;First line in $File is:&rdquo;<br />
12 echo &ldquo;$line1&rdquo;<br />
13 echo<br />
14 echo &ldquo;Second line in $File is:&rdquo;<br />
15 echo &ldquo;$line2&rdquo;<br />
16<br />
17 exit 0<br />
18<br />
19 # 现在,你怎么分析每行的分割域<br />
20 # 暗示: 使用 awk.<br />
################################End
Script#########################################</p>

<p>Example 3-2. 将一个代码块的结果保存到文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # rpm-check.sh<br />
3<br />
4 # 这个脚本的目的是为了描述,列表,和确定是否可以安装一个rpm包.<br />
5 # 在一个文件中保存输出.<br />
6 #<br />
7 # 这个脚本使用一个代码块来展示<br />
8<br />
9 SUCCESS=0<br />
10 E_NOARGS=65<br />
11<br />
12 if [ -z &ldquo;$1&rdquo; ]<br />
13 then<br />
14 echo &ldquo;Usage: <code>basename $0</code> rpm-file&rdquo;<br />
15 exit $E_NOARGS<br />
16 fi<br />
17<br />
18 {<br />
19 echo<br />
20 echo &ldquo;Archive Description:&rdquo;<br />
21 rpm -qpi $1 # 查询说明<br />
22 echo<br />
23 echo &ldquo;Archive Listing:&rdquo;<br />
24 rpm -qpl $1 # 查询列表<br />
25 echo<br />
26 rpm -i &ndash;test $1 # 查询rpm包是否可以被安装<br />
27 if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
28 then<br />
29 echo &ldquo;$1 can be installed.&rdquo;<br />
30 else<br />
31 echo &ldquo;$1 cannot be installed.&rdquo;<br />
32 fi<br />
33 echo<br />
34 } &gt; &ldquo;$1.test&rdquo; # 把代码块中的所有输出都重定向到文件中<br />
35<br />
36 echo &ldquo;Results of rpm test in file $1.test&rdquo;<br />
37<br />
38 # 查看rpm的man页来查看rpm的选项<br />
39<br />
40 exit 0<br />
################################End
Script#########################################<br />
注意: 与()中的命令不同的是,{}中的代码块将不能正常地开启一个新shell.[2]</p>

<p>{} \; 路径名.一般都在find命令中使用.这不是一个shell内建命令.<br />
注意: &ldquo;;&ldquo;用来结束find命令序列的-exec选项.</p>

<p>[] test.<br />
test的表达式将在[]中.<br />
值得注意的是[是shell内建test命令的一部分,并不是/usr/bin/test中的扩展命令<br />
的一个连接.</p>

<p>[[]] test.<br />
test表达式放在[[]]中.(shell关键字)<br />
具体查看[[]]结构的讨论.</p>

<p>[] 数组元素<br />
Array[1]=slot_1<br />
echo ${Array[1]}</p>

<p>[] 字符范围<br />
在正则表达式中使用,作为字符匹配的一个范围</p>

<p>(()) 数学计算的扩展<br />
在(())结构中可以使用一些数字计算.<br />
具体参阅((&hellip;))结构.</p>

<blockquote>
<p>&amp;&gt;&gt;&amp;&gt;&gt;&lt;<br />
重定向.<br />
scriptname &gt;filename 重定向脚本的输出到文件中.覆盖文件原有内容.<br />
command &amp;&gt;filename 重定向stdout和stderr到文件中<br />
command &gt;&amp;2 重定向command的stdout到stderr<br />
scriptname &gt;&gt;filename 重定向脚本的输出到文件中.添加到文件尾端,如果没有文件,<br />
则创建这个文件.</p>
</blockquote>

<p>进程替换,具体见&rdquo;进程替换部分&rdquo;,跟命令替换极其类似.<br />
(command)&gt;</p>

<p>可用来做字符串比较<br />
可用在数学计算比较</p>

<p>&lt;</p>

<p>&lt;&lt;</p>

<p>ASCII比较<br />
1 veg1=carrots<br />
2 veg2=tomatoes<br />
3<br />
4 if [[ &ldquo;$veg1&rdquo; &lt; &ldquo;$veg2&rdquo; ]]<br />
5 then<br />
6 echo &ldquo;Although $veg1 precede $veg2 in the dictionary,&rdquo;<br />
7 echo &ldquo;this implies nothing about my culinary preferences.&rdquo;<br />
8 else<br />
9 echo &ldquo;What kind of dictionary are you using, anyhow?&rdquo;<br />
10 fi</p>

<p>\ 正则表达式中的单词边界.如:<br />
bash$grep &lsquo;\&rsquo; textfile</p>

<p>| 管道.分析前边命令的输出,并将输出作为后边命令的输入.这是一种产生命令链的<br />
好方法.<br />
1 echo ls -l | sh<br />
2 # 传递&rdquo;echo ls -l&rdquo;的输出到shell中,<br />
3 #+ 与一个简单的&rdquo;ls -l&rdquo;结果相同.<br />
4<br />
5<br />
6 cat *.lst | sort | uniq<br />
7 # 合并和排序所有的&rdquo;.lst&rdquo;文件,然后删除所有重复的行.</p>

<p>管道是进程间通讯的一个典型办法,将一个进程的stdout放到另一个进程的stdin中.<br />
标准的方法是将一个一般命令的输出,比如cat或echo,传递到一个过滤命令中(在这个<br />
过滤命令中将处理输入),得到结果,如:<br />
cat $filename1 | $filename2 | grep $search_word</p>

<p>当然输出的命令也可以传递到脚本中.如:<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # uppercase.sh : 修改输出,全部转换为大写<br />
3<br />
4 tr &lsquo;a-z&rsquo; &lsquo;A-Z&rsquo;<br />
5 # 字符范围必须被&rdquo;&ldquo;引用起来<br />
6 #+ 来阻止产生单字符的文件名.<br />
7<br />
8 exit 0<br />
################################End
Script#########################################</p>

<p>现在让我们输送ls -l的输出到一个脚本中.<br />
bash$ ls -l | ./uppercase.sh<br />
-RW-RW-R&ndash; 1 BOZO BOZO 109 APR 7 19:49 1.TXT<br />
-RW-RW-R&ndash; 1 BOZO BOZO 109 APR 14 16:48 2.TXT<br />
-RW-R&ndash;R&ndash; 1 BOZO BOZO 725 APR 20 20:56 DATA-FILE</p>

<p>注意:管道中的一个进程的stdout必须被下一个进程作为stdin读入.否则,数据流会阻<br />
塞,并且管道将产生非预期的行为.<br />
如:<br />
1 cat file1 file2 | ls -l | sort<br />
2 #从&rdquo;cat file1 file2&rdquo;中的输出并没出现</p>

<p>作为子进程的运行的管道,不能够改变脚本的变量.<br />
1 variable=&ldquo;initial_value&rdquo;<br />
2 echo &ldquo;new_value&rdquo; | read variable<br />
3 echo &ldquo;variable = $variable&rdquo; #variable = initial_value<br />
如果管道中的某个命令产生了一个异常,并中途失败,那么这个管道将过早的终止.<br />
这种行为被叫做a broken pipe,并且这种状态下将发送一个SIGPIPE信号.</p>

<blockquote>
<p>| 强制重定向(即使设置了noclobber选项&ndash;就是-C选项).这将强制的覆盖一个现存文件.</p>
</blockquote>

<p>|| 或-逻辑操作.</p>

<p>&amp; 后台运行命令.一个命令后边跟一个&amp;,将表示在后台运行.<br />
bash$sleep 10 &amp;<br />
[1] 850<br />
[1]+ Done sleep 10<br />
在一个脚本中,命令和循环都可能运行在后台.</p>

<p>Example 3-3. 在后台运行一个循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 #background-loop.sh<br />
3<br />
4 for i in 1 2 3 4 5 6 7 8 9 10 #第一个循环<br />
5 do<br />
6 echo -n &ldquo;$i&rdquo;<br />
7 done&amp; #在后台运行这个循环<br />
8 #在第2个循环之后,将在某些时候执行.<br />
9<br />
10 echo #这个&rsquo;echo&rsquo;某些时候将不会显示.<br />
11<br />
12 for i in 11 12 13 14 15 16 17 18 19 20 #第二个循环<br />
13 do<br />
14 echo -n &ldquo;$i&rdquo;<br />
15 done<br />
16<br />
17 echo #这个&rsquo;echo&rsquo;某些时候将不会显示.<br />
18<br />
19 #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
20<br />
21 #期望的输出应该是<br />
22 #1 2 3 4 5 6 7 8 9 10<br />
23 #11 12 13 14 15 16 17 18 19 20<br />
24<br />
25 #然而实际的结果有可能是<br />
26 #11 12 13 14 15 16 17 18 19 20<br />
27 #1 2 3 4 5 6 7 8 9 10 bozo $<br />
28 #(第2个&rsquo;echo&rsquo;没执行,为什么?)<br />
29<br />
30 #也可能是<br />
31 #1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20<br />
32 #(第1个&rsquo;echo&rsquo;没执行,为什么?)<br />
33<br />
34 #非常少见的执行结果,也有可能是:<br />
35 #11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20<br />
36 #前台的循环先于后台的执行<br />
37<br />
38 exit 0<br />
39<br />
40 # Nasimuddin Ansari 建议加一句 sleep 1<br />
41 #+ 在 6行和14行的 echo -n &ldquo;$i&rdquo;之后加<br />
42 #+ 将看到一些乐趣<br />
################################End
Script#########################################<br />
注意:在一个脚本内后台运行一个命令,有可能造成这个脚本的挂起,等待一个按键<br />
响应.幸运的是,我们可以在Example 11-24附近,看到这个问题的解决办法.</p>

<p>&amp;&amp; 与-逻辑操作.</p>

<p>- 选项,前缀.在所有的命令内如果想使用选项参数的话,前边都要加上&rdquo;-&ldquo;.</p>

<p>COMMAND -[Option1][Option2][&hellip;]<br />
ls -al<br />
sort -dfu $filename<br />
set &ndash; $variable</p>

<p>1 if [ $file1 -ot $file2 ]<br />
2 then<br />
3 echo &ldquo;File $file1 is older than $file2.&rdquo;<br />
4 fi<br />
5<br />
6 if [ &ldquo;$a&rdquo; -eq &ldquo;$b&rdquo; ]<br />
7 then<br />
8 echo &ldquo;$a is equal to $b.&rdquo;<br />
9 fi<br />
10<br />
11 if [ &ldquo;$c&rdquo; -eq 24 -a &ldquo;$d&rdquo; -eq 47 ]<br />
12 then<br />
13 echo &ldquo;$c equals 24 and $d equals 47.&rdquo;<br />
14 fi</p>

<p>- 用于重定向 stdin 或 stdout.</p>

<p>################################Start
Script#######################################<br />
1 (cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)<br />
2 # 从一个目录移动整个目录树到另一个目录<br />
3 # [courtesy Alan Cox , with a minor change]<br />
4<br />
5 # 1) cd /source/directory 源目录<br />
6 # 2) &amp;&amp; 与操作,如果cd命令成功了,那么就执行下边的命令<br />
7 # 3) tar cf - . &lsquo;c&rsquo;创建一个新文档,&lsquo;f&rsquo;后边跟&rsquo;-&lsquo;指定目标文件作为stdout<br />
8 # &lsquo;-&lsquo;后边的&rsquo;f&rsquo;(file)选项,指明作为stdout的目标文件.<br />
9 # 并且在当前目录(&lsquo;.&rsquo;)执行.<br />
10 # 4) | 管道&hellip;<br />
11 # 5) ( &hellip; ) 一个子shell<br />
12 # 6) cd /dest/directory 改变当前目录到目标目录.<br />
13 # 7) &amp;&amp; 与操作,同上.<br />
14 # 8) tar xpvf - &lsquo;x&rsquo;解档,&lsquo;p&rsquo;保证所有权和文件属性,<br />
15 # &lsquo;v&rsquo;发完整消息到stdout<br />
16 # &lsquo;f&rsquo;后边跟&rsquo;-&lsquo;,从stdin读取数据<br />
17 #<br />
18 # 注意:&lsquo;x&rsquo; 是一个命令, &lsquo;p&rsquo;, &lsquo;v&rsquo;, &lsquo;f&rsquo; 是选项.<br />
19 # Whew!<br />
20<br />
21<br />
22<br />
23 # 更优雅的写法应该是<br />
24 # cd source/directory<br />
25 # tar cf - . | (cd ../dest/directory; tar xpvf -)<br />
26 #<br />
27 # 当然也可以这么写:<br />
28 # cp -a /source/directory/* /dest/directory<br />
29 # 或者:<br />
30 # cp -a /source/directory/* /source/directory/.[^.]* /dest/directory<br />
31 # 如果在/source/directory中有隐藏文件的话.<br />
################################End
Script#########################################</p>

<p>################################Start
Script#######################################<br />
1 bunzip2 linux-2.6.13.tar.bz2 | tar xvf -<br />
2 # &ndash;未解压的tar文件&ndash; | &ndash;然后把它传递到&rdquo;tar&rdquo;中&ndash;<br />
3 # 如果 &ldquo;tar&rdquo; 没能够正常的处理&rdquo;bunzip2&rdquo;,<br />
4 # 这就需要使用管道来执行2个单独的步骤来完成它.<br />
5 # 这个练习的目的是解档&rdquo;bzipped&rdquo;的kernel源文件.<br />
################################End
Script#########################################<br />
注意:在上边这个例子中&rsquo;-&lsquo;不太象是bash的操作符,而更像是tar的参数.<br />
bash$echo &ldquo;whatever&rdquo; | cat -<br />
whatever</p>

<p>在需要一个文件名的地方,-重定向输出到stdout(如在tar和cf命令中),或者从<br />
stdin中接受输入,而不是从一个文件中接受输入.这是在管道中作为一个过滤<br />
器,来使用文件定位工具的一种办法.<br />
bash$file<br />
用法: file [-bciknvzl] [-f namefile] [-m magicfiles] file&hellip;<br />
上边这个例子file将会出错,提示你如何使用file命令.</p>

<p>添加一个&rdquo;-&ldquo;将得到一个更有用的结果.这将使得shell等待用户输入.<br />
bash$file -<br />
abc<br />
standard input: ASCII text</p>

<p>bash$file -<br />
#!/bin/bash<br />
standard input: Bourn-Again shell script tesxt executable</p>

<p>现在命令从stdin中接受了输入,并分析它.</p>

<p>&rdquo;-&ldquo;常用于管道后边的命令,具体参看33.7节,来看使用技巧.<br />
使用diff命令来和另一个文件的一部分进行比较.<br />
grep Linux file1 | diff file2 -</p>

<p>最后,一个真实世界的使用tar命令的例子.</p>

<p>Example 3-4. 备份最后一天所有修改的文件.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 在一个&rdquo;tarball&rdquo;中(经过tar和gzip处理过的文件)<br />
4 #+ 备份最后24小时当前目录下d所有修改的文件.<br />
5<br />
6 BACKUPFILE=backup-$(date +%m-%d-%Y)<br />
7 # 在备份文件中嵌入时间.<br />
8 # Thanks, Joshua Tschida, for the idea.<br />
9 archive=${1:-$BACKUPFILE}<br />
10 # 如果在命令行中没有指定备份文件的文件名,<br />
11 #+ 那么将默认使用&rdquo;backup-MM-DD-YYYY.tar.gz&rdquo;.<br />
12<br />
13 tar cvf - <code>find . -mtime -1 -type f -print</code> &gt; $archive.tar<br />
14 gzip $archive.tar<br />
15 echo &ldquo;Directory $PWD backed up in archive file \&ldquo;$archive.tar.gz\&ldquo;.&rdquo;<br />
16<br />
17<br />
18 # Stephane Chazelas指出上边代码,<br />
19 #+ 如果在发现太多的文件的时候,或者是如果文件<br />
20 #+ 名包括空格的时候,将执行失败.<br />
21<br />
22 # Stephane Chazelas建议使用下边的两种代码之一<br />
23 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
24 # find . -mtime -1 -type f -print0 | xargs -0 tar rvf &ldquo;$archive.tar&rdquo;<br />
25 # 使用gnu版本的find.<br />
26<br />
27<br />
28 # find . -mtime -1 -type f -exec tar rvf &ldquo;$archive.tar&rdquo; &lsquo;{}&rsquo; \;<br />
29 # 对于其他风格的UNIX便于移植,但是比较慢.<br />
30 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
31<br />
32<br />
33 exit 0<br />
################################End
Script#########################################</p>

<p>注意:以&rdquo;-&ldquo;开头的文件名在使用&rdquo;-&ldquo;作为重定向操作符的时候,可能会产生问题.<br />
应该写一个脚本来检查这个问题,并给这个文件加上合适的前缀.如:<br />
./-FILENAME, $PWD/-FILENAME,或$PATHNAME/-FILENAME.</p>

<p>如果变量的值以&rdquo;-&ldquo;开头,可能也会引起问题.<br />
1 var=&ldquo;-n&rdquo;<br />
2 echo $var<br />
3 #具有&rdquo;echo -n&rdquo;的效果了,这样什么都不会输出的.</p>

<p>- 之前工作的目录.&ldquo;cd -&ldquo;将回到之前的工作目录,具体请参考&rdquo;$OLDPWD&rdquo;环境变量.<br />
注意:一定要和之前讨论的重定向功能分开,但是只能依赖上下文区分.</p>

<p>- 算术减号.</p>

<p>= 算术等号,有时也用来比较字符串.<br />
1 a=28<br />
2 echo $a # 28</p>

<p>+ 算术加号,也用在正则表达式中.<br />
+ 选项,对于特定的命令来说使用&rdquo;+&ldquo;来打开特定的选项,用&rdquo;-&ldquo;来关闭特定的选项.</p>

<p>% 算术取模运算.也用在正则表达式中.</p>

<p>~ home目录.相当于$HOME变量.~bozo是bozo的home目录,并且ls ~bozo将列出其中的<br />
内容. ~/就是当前用户的home目录,并且ls ~/将列出其中的内容,如:<br />
bash$ echo ~bozo<br />
/home/bozo</p>

<p>bash$ echo ~<br />
/home/bozo</p>

<p>bash$ echo ~/<br />
/home/bozo/</p>

<p>bash$ echo ~:<br />
/home/bozo:</p>

<p>bash$ echo ~nonexistent-user<br />
~nonexistent-user</p>

<p>~+ 当前工作目录,相当于$PWD变量.</p>

<p>~- 之前的工作目录,相当于$OLDPWD内部变量.</p>

<p>=~ 用于正则表达式,这个操作将在正则表达式匹配部分讲解,只有version3才支持.</p>

<p>^ 行首,正则表达式中表示行首.&ldquo;^&ldquo;定位到行首.</p>

<p>控制字符<br />
修改终端或文本显示的行为.控制字符以CONTROL + key组合.<br />
控制字符在脚本中不能正常使用.<br />
Ctl-B 光标后退,这应该依赖于bash输入的风格,默认是emacs风格的.<br />
Ctl-C Break,终止前台工作.<br />
Ctl-D 从当前shell登出(和exit很像)<br />
&ldquo;EOF&rdquo;(文件结束符).这也能从stdin中终止输入.<br />
在console或者在xterm window中输入的时候,Ctl-D将删除光标下字符.<br />
当没有字符时,Ctrl-D将退出当前会话.在xterm window也有关闭窗口<br />
的效果.<br />
Ctl-G beep.在一些老的终端,将响铃.<br />
Ctl-H backspace,删除光标前边的字符.如:<br />
1 #!/bin/bash<br />
2 # 在一个变量中插入Ctl-H<br />
3<br />
4 a=&ldquo;^H^H&rdquo; # 两个 Ctl-H (backspaces).<br />
5 echo &ldquo;abcdef&rdquo; # abcdef<br />
6 echo -n &ldquo;abcdef$a &rdquo; # abcd f<br />
7 # 注意结尾的空格 ^ ^ 两个 twice.<br />
8 echo -n &ldquo;abcdef$a&rdquo; # abcdef<br />
9 # 结尾没有空格 没有 backspace 的效果了(why?).<br />
10 # 结果并不像期望的那样<br />
11 echo; echo<br />
Ctl-I 就是tab键.<br />
Ctl-J 新行.<br />
Ctl-K 垂直tab.(垂直tab?新颖,没听过)<br />
作用就是删除光标到行尾的字符.<br />
Ctl-L clear,清屏.<br />
Ctl-M 回车<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # Thank you, Lee Maschmeyer, for this example.<br />
3<br />
4 read -n 1 -s -p $&lsquo;Control-M leaves cursor at beginning of this line. Press
Enter. \x0d&rsquo;<br />
5 #当然,&lsquo;0d&rsquo;就是二进制的回车.<br />
6 echo &gt;&amp;2 # &lsquo;-s&rsquo;参数使得任何输入都不将回显出来<br />
7 #+ 所以,明确的重起一行是必要的.<br />
8<br />
9 read -n 1 -s -p $&lsquo;Control-J leaves cursor on next line. \x0a&rsquo;<br />
10 echo &gt;&amp;2 # Control-J 是换行.<br />
11<br />
12 ###<br />
13<br />
14 read -n 1 -s -p $&lsquo;And Control-K\x0bgoes straight down.&rsquo;<br />
15 echo &gt;&amp;2 # Control-K 是垂直制表符.<br />
16<br />
17 # 关于垂直制表符效果的一个更好的例子见下边:<br />
18<br />
19 var=$&rsquo;\x0aThis is the bottom line\x0bThis is the top line\x0a&rsquo;<br />
20 echo &ldquo;$var&rdquo;<br />
21 # 这句与上边的例子使用的是同样的办法,然而:<br />
22 echo &ldquo;$var&rdquo; | col<br />
23 # 这将造成垂直制表符右边的部分在左边部分的上边.<br />
24 # 这也解释了为什么我们要在行首和行尾加上一个换行符&ndash;<br />
25 #+ 来避免一个混乱的屏幕输出.<br />
26<br />
27 # Lee Maschmeyer的解释:<br />
28 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
29 # In the [first vertical tab example] &hellip; the vertical tab<br />
29 # 在这里[第一个垂直制表符的例子中] &hellip; 这个垂直制表符<br />
30 #+ makes the printing go straight down without a carriage return.<br />
31 # This is true only on devices, such as the Linux console,<br />
32 #+ that can&rsquo;t go &ldquo;backward.&rdquo;<br />
33 # The real purpose of VT is to go straight UP, not down.<br />
34 # It can be used to print superscripts on a printer.<br />
34 # 它可以用来在一个打印机上打印上标.<br />
35 # col的作用,可以用来模仿VT的合适的行为.<br />
36<br />
37 exit 0<br />
################################End
Script#########################################<br />
Ctl-Q 继续(等价于XON字符),这个继续的标准输入在一个终端里<br />
Ctl-S 挂起(等价于XOFF字符),这个被挂起的stdin在一个终端里,用Ctl-Q恢复<br />
Ctl-U 删除光标到行首的所有字符,在某些设置下,删除全行.<br />
Ctl-V 当输入字符时,Ctl-V允许插入控制字符.比如,下边2个例子是等价的<br />
echo -e &lsquo;\x0a&rsquo;<br />
echo<br />
Ctl-V在文本编辑器中十分有用,在vim中一样.<br />
Ctl-W 删除当前光标到前边的最近一个空格之间的字符.<br />
在某些设置下,删除到第一个非字母或数字的字符.<br />
Ctl-Z 终止前台工作.</p>

<p>空白部分<br />
分割命令或者是变量.包括空格,tab,空行,或任何它们的组合.<br />
在一些特殊情况下,空白是不允许的,如变量赋值时,会引起语法错误.<br />
空白行在脚本中没有效果.<br />
&rdquo;$IFS&rdquo;,对于某些命令输入的特殊变量分割域,默认使用的是空白.<br />
如果想保留空白,使用引用.</p>

<p>注意事项:<br />
[1] shell做大括号的命令扩展.但是命令本身需要对扩展的结果作处理.<br />
[2] 例外:在pipe中的一个大括号中的代码段可能运行在一个子shell中.<br />
1 ls | { read firstline; read secondline; }<br />
2 # 错误,在打括号中的代码段,将运行到子shell中.<br />
3 #+ 所以ls的输出将不能传递到代码块中.<br />
4 echo &ldquo;First line is $firstline; second line is $secondline&rdquo; # 不能工作<br />
5<br />
6 # Thanks, S.C.<br />
[3] 换行符也被认为是空白.这也解释了为什么一个空行也会被认为是空白.</p>

<h1 id="第4章-变量和参数的介绍">第4章 变量和参数的介绍</h1>

<p>4.1 变量替换<br />
-&mdash;&mdash;&mdash;&ndash;<br />
$ 变量替换操作符<br />
只有在变量被声明,赋值,unset或exported或者是在变量代表一个signal的时候,<br />
变量才会是以本来的面目出现在脚本里.变量在被赋值的时候,可能需要使用&rdquo;=&ldquo;,<br />
read状态或者是在循环的头部.<br />
在&rdquo;&ldquo;中还是会发生变量替换,这被叫做部分引用,或叫弱引用.而在&rdquo;中就不会发生变<br />
量替换,这叫做全引用,也叫强引用.具体见第5章的讨论.</p>

<p>注意:$var与${var}的区别,不加{},在某些上下文将引起错误,为了安全,使用2.<br />
具体见9.3节 参数替换.</p>

<p>Example 4-1. 变量赋值和替换<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 变量赋值和替换<br />
4<br />
5 a=375<br />
6 hello=$a<br />
7<br />
8 #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
9 # 强烈注意,在赋值的前后一定不要有空格.<br />
10 # 如果有空格会发生什么?<br />
11<br />
12 # 如果&rdquo;VARIABLE =value&rdquo;,<br />
13 # ^<br />
14 #+ 脚本将尝试运行一个&rdquo;VARIABLE&rdquo;的命令,带着一个&rdquo;=value&rdquo;参数.<br />
15<br />
16 # 如果&rdquo;VARIABLE= value&rdquo;,<br />
17 # ^<br />
18 #+ script tries to run &ldquo;value&rdquo; command with<br />
18 #+ 脚本将尝试运行一个&rdquo;value&rdquo;的命令,带着<br />
19 #+ the environmental variable &ldquo;VARIABLE&rdquo; set to &ldquo;&rdquo;.<br />
19 #+ 一个被赋成&rdquo;&ldquo;值的环境变量&rdquo;VARIABLE&rdquo;.<br />
20 #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
21<br />
22<br />
23 echo hello # 没有变量引用,不过是个hello字符串<br />
24<br />
25 echo $hello<br />
26 echo ${hello} # 同上<br />
27<br />
28 echo &ldquo;$hello&rdquo;<br />
29 echo &ldquo;${hello}&rdquo;<br />
30<br />
31 echo<br />
32<br />
33 hello=&ldquo;A B C D&rdquo;<br />
34 echo $hello # A B C D<br />
35 echo &ldquo;$hello&rdquo; # A B C D<br />
36 # 就象你看到的echo $hello 和 echo &ldquo;$hello&rdquo; 将给出不同的结果.<br />
37 # ^ ^<br />
38 # Quoting a variable preserves whitespace.<br />
38 # 引用一个变量将保留其中的空白,当然,如果是变量替换就不会保留了.<br />
39<br />
40 echo<br />
41<br />
42 echo &lsquo;$hello&rsquo; # $hello<br />
43 # ^ ^<br />
44 # 全引用的作用<br />
45 #+ 将导致&rdquo;$&ldquo;变成一个单独的字符.<br />
46<br />
47 # 注意两种引用不同的效果<br />
48<br />
49<br />
50 hello= # 设置为空值<br />
51 echo &ldquo;\$hello (null value) = $hello&rdquo;<br />
52 # 注意设置一个变量为空,与unset它,不是一回事,虽然看起来一样<br />
53 #<br />
54<br />
55 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
56<br />
57 # 可以在同一行上设置多个变量.<br />
58 #+ 要以空白分隔<br />
59 # 小心,这会降低可读性,和可移植性.<br />
60<br />
61 var1=21 var2=22 var3=$V3<br />
62 echo<br />
63 echo &ldquo;var1=$var1 var2=$var2 var3=$var3&rdquo;<br />
64<br />
65 # 在老版本的&rdquo;sh&rdquo;上,可能会有问题.<br />
66<br />
67 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
68<br />
69 echo; echo<br />
70<br />
71 numbers=&ldquo;one two three&rdquo;<br />
72 # ^ ^<br />
73 other_numbers=&ldquo;1 2 3&rdquo;<br />
74 # ^ ^<br />
75 # 如果变量中有空白,那么引用就必要了.<br />
76 #<br />
77 echo &ldquo;numbers = $numbers&rdquo;<br />
78 echo &ldquo;other_numbers = $other_numbers&rdquo; # other_numbers = 1 2 3<br />
79 echo<br />
80<br />
81 echo &ldquo;uninitialized_variable = $uninitialized_variable&rdquo;<br />
82 # Uninitialized变量为空值(根本就没赋值).<br />
83 uninitialized_variable= # 声明,但是没被初始化<br />
84 #+ 其实和前边设置为空值得作用是一样的.<br />
85 echo &ldquo;uninitialized_variable = $uninitialized_variable&rdquo;<br />
86 # 还是一个空值<br />
87<br />
88 uninitialized_variable=23 # 赋值<br />
89 unset uninitialized_variable # Unset it.<br />
90 echo &ldquo;uninitialized_variable = $uninitialized_variable&rdquo;<br />
91 # 还是空值<br />
92 echo<br />
93<br />
94 exit 0<br />
################################End
Script#########################################<br />
注意: 一个空值变量,或者是根本就没声明的变量,在赋值之前使用它可能会引起问题.<br />
但是还是可以用来做算术运算<br />
################################Start
Script#######################################<br />
1 echo &ldquo;$uninitialized&rdquo; # (blank line)<br />
2 let &ldquo;uninitialized += 5&rdquo; # Add 5 to it.<br />
3 echo &ldquo;$uninitialized&rdquo; # 5<br />
4<br />
5 # 结论:<br />
6 # 对于一个空值变量在做算术操作的时候,就好像它的值为0一样.<br />
8 # This is undocumented (and probably non-portable) behavior.<br />
7 # 这并没被文档化(可能是不可移植)的行为.<br />
################################End
Script#########################################<br />
具体参考 Example 11-21</p>

<p>4.2 变量赋值<br />
-&mdash;&mdash;&mdash;&ndash;<br />
= 赋值操作符(前后都不能有空白)<br />
不要与-eq混淆,那个是test,并不是赋值.<br />
注意,=也可被用来做test操作,这依赖于上下文.</p>

<p>Example 4-2. 一般的变量赋值<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # &ldquo;裸体&rdquo;变量<br />
3<br />
4 echo<br />
5<br />
6 # 变量什么时候是&rdquo;裸体&rdquo;的,比如前边少了$的时候.<br />
7 # 当它被赋值的时候,而不是被引用的时候.<br />
8<br />
9 # 赋值<br />
10 a=879<br />
11 echo &ldquo;The value of \&ldquo;a\&rdquo; is $a.&rdquo;<br />
12<br />
13 # 使用let赋值<br />
14 let a=16+5<br />
15 echo &ldquo;The value of \&ldquo;a\&rdquo; is now $a.&rdquo;<br />
16<br />
17 echo<br />
18<br />
19 # 在for循环中<br />
20 echo -n &ldquo;Values of \&ldquo;a\&rdquo; in the loop are: &ldquo;<br />
21 for a in 7 8 9 11<br />
22 do<br />
23 echo -n &ldquo;$a &rdquo;<br />
24 done<br />
25<br />
26 echo<br />
27 echo<br />
28<br />
29 # 在read命令状态中<br />
30 echo -n &ldquo;Enter \&ldquo;a\&rdquo; &ldquo;<br />
31 read a<br />
32 echo &ldquo;The value of \&ldquo;a\&rdquo; is now $a.&rdquo;<br />
33<br />
34 echo<br />
35<br />
36 exit 0<br />
################################End
Script#########################################</p>

<p>Example 4-3. 变量赋值,一般的和比较特殊的<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 a=23 # Simple case<br />
4 echo $a<br />
5 b=$a<br />
6 echo $b<br />
7<br />
8 # 现在让我们来点小变化<br />
9<br />
10 a=<code>echo Hello!</code> # 把echo命令的结果传给变量a<br />
11 echo $a<br />
12 # 注意,如果在命令扩展结构中使用一个(!)的话,在命令行中将不能工作<br />
13 #+ 因为这触发了Bash的&rdquo;历史机制&rdquo;.<br />
14 # 但是,在校本里边使用的话,历史功能是被关闭的,所以就能够正常运行.<br />
15<br />
16<br />
17 a=<code>ls -l</code> # 把ls -l的结果给a<br />
18 echo $a # 别忘了,这么引用的话,ls的结果中的所有空白部分都没了(包括换行)<br />
19 echo<br />
20 echo &ldquo;$a&rdquo; # 这么引用就正常了,保留了空白<br />
21 # (具体参阅章节&rdquo;引用&rdquo;)<br />
22<br />
23 exit 0<br />
################################End
Script#########################################<br />
使用$(&hellip;)机制进行的变量赋值(除去使用``来赋值的另外一种新方法).事实上这两种方法都是<br />
命令替换的一种形式.</p>

<h1 id="来自于-ect-rc-d-rc-local">来自于/ect/rc.d/rc.local</h1>

<p>R=$(cat /ect/redhat-release)<br />
arch=$(uname -m)</p>

<p>4.3 Bash变量是不分类型的<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
不像其他程序语言一样,Bash并不对变量区分&rdquo;类型&rdquo;.本质上,Bash变量都是字符串.<br />
但是依赖于上下文,Bash也允许比较操作和算术操作.决定这些的关键因素就是,变量中的值<br />
是否只有数字.</p>

<p>Example 4-4 整型还是string?<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # int-or-string.sh: 整形还是string?<br />
3<br />
4 a=2334 # 整型<br />
5 let &ldquo;a += 1&rdquo;<br />
6 echo &ldquo;a = $a &rdquo; # a = 2335<br />
7 echo # 还是整型<br />
8<br />
9<br />
10 b=${a/23/BB} # 将23替换成BB<br />
11 # 这将把b变量从整型变为string<br />
12 echo &ldquo;b = $b&rdquo; # b = BB35<br />
13 declare -i b # 即使使用declare命令也不会对此有任何帮助,9.4节有解释<br />
14 echo &ldquo;b = $b&rdquo; # b = BB35<br />
15<br />
16 let &ldquo;b += 1&rdquo; # BB35 + 1 =<br />
17 echo &ldquo;b = $b&rdquo; # b = 1<br />
18 echo<br />
19<br />
20 c=BB34<br />
21 echo &ldquo;c = $c&rdquo; # c = BB34<br />
22 d=${c/BB/23} # S将BB替换成23<br />
23 # 这使得$d变为一个整形<br />
24 echo &ldquo;d = $d&rdquo; # d = 2334<br />
25 let &ldquo;d += 1&rdquo; # 2334 + 1 =<br />
26 echo &ldquo;d = $d&rdquo; # d = 2335<br />
27 echo<br />
28<br />
29 # 关于空变量怎么样?<br />
30 e=&ldquo;&rdquo;<br />
31 echo &ldquo;e = $e&rdquo; # e =<br />
32 let &ldquo;e += 1&rdquo; # 算术操作允许一个空变量?<br />
33 echo &ldquo;e = $e&rdquo; # e = 1<br />
34 echo # 空变量将转换成一个整型变量<br />
35<br />
36 # 关于未声明的变量怎么样?<br />
37 echo &ldquo;f = $f&rdquo; # f =<br />
38 let &ldquo;f += 1&rdquo; # 算术操作允许么?<br />
39 echo &ldquo;f = $f&rdquo; # f = 1<br />
40 echo # 未声明的变量将转换成一个整型变量<br />
41<br />
42<br />
43<br />
44 # 所以说Bash中的变量都是无类型的.<br />
45<br />
46 exit 0<br />
################################End
Script#########################################</p>

<p>4.4 特殊的变量类型<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
local variables<br />
这种变量只有在代码块或者是函数中才可见(具体见23.2和23章)<br />
environmental variables<br />
这种变量将改变用户接口和shell的行为.</p>

<p>在一般的上下文中,每个进程都有自己的环境,就是一组保持进程可能引用的信息的<br />
变量.这种情况下,shell于一个一般进程是相同的.</p>

<p>每次当shell启动时,它都将创建自己的环境变量.更新或者添加新的环境变量,将导<br />
致shell更新它的环境,同时也会影响所有继承自这个环境的所有子进程(由这个命令<br />
导致的).</p>

<p>注意:分配给环境变量的空间是受限的.创建太多的环境变量将引起空间溢出,这会引<br />
起问题.<br />
关于eval命令,具体见第11章<br />
bash$ eval &ldquo;<code>seq 10000 | sed -e 's/.*/export var&amp;=ZZZZZZZZZZZZZZ/'</code>&rdquo;<br />
bash$ du<br />
bash: /usr/bin/du: Argument list too long</p>

<p>如果一个脚本设置了环境变量,需要export它,来通知本脚本的环境,这是export<br />
命令的功能,关于export命令,具体见11章.</p>

<p>脚本只能对它产生的子进程export变量.一个从命令行被调用的脚本export的变量,将<br />
不能影响调用这个脚本的那个命令行shell的环境.</p>

<p>positional parameters<br />
就是从命令行中传进来的参数,$0, $1, $2, $3&hellip;</p>

<p>$0就是脚本文件的名字,$1是第一个参数,$2为第2个&hellip;,参见<a href="有$0的说明">1</a>,$9<br />
以后就需要打括号了,如${10},${11},${12}&hellip;<br />
两个值得注意的变量$*和$@(第9章有具体的描述),表示所有的位置参数.</p>

<p>Example 4-5 位置参数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 作为用例,调用这个脚本至少需要10个参数,如<br />
4 # ./scriptname 1 2 3 4 5 6 7 8 9 10<br />
5 MINPARAMS=10<br />
6<br />
7 echo<br />
8<br />
9 echo &ldquo;The name of this script is \&ldquo;$0\&ldquo;.&rdquo;<br />
10 # 添加./是为了当前目录<br />
11 echo &ldquo;The name of this script is \&rdquo;<code>basename $0</code>\&ldquo;.&rdquo;<br />
12 # 去掉目录信息,具体见&rsquo;basename&rsquo;命令<br />
13<br />
14 echo<br />
15<br />
16 if [ -n &ldquo;$1&rdquo; ] # 测试变量被被引用<br />
17 then<br />
18 echo &ldquo;Parameter #1 is $1&rdquo; # &ldquo;#&ldquo;没被转义<br />
19 fi<br />
20<br />
21 if [ -n &ldquo;$2&rdquo; ]<br />
22 then<br />
23 echo &ldquo;Parameter #2 is $2&rdquo;<br />
24 fi<br />
25<br />
26 if [ -n &ldquo;$3&rdquo; ]<br />
27 then<br />
28 echo &ldquo;Parameter #3 is $3&rdquo;<br />
29 fi<br />
30<br />
31 # &hellip;<br />
32<br />
33<br />
34 if [ -n &ldquo;${10}&rdquo; ] # 大于9的参数必须出现在{}中.<br />
35 then<br />
36 echo &ldquo;Parameter #10 is ${10}&rdquo;<br />
37 fi<br />
38<br />
39 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
40 echo &ldquo;All the command-line parameters are: &ldquo;$*&ldquo;&rdquo;<br />
41<br />
42 if [ $# -lt &ldquo;$MINPARAMS&rdquo; ] #$#是传到脚本里的位置参数的个数<br />
43 then<br />
44 echo<br />
45 echo &ldquo;This script needs at least $MINPARAMS command-line arguments!&rdquo;<br />
46 fi<br />
47<br />
48 echo<br />
49<br />
50 exit 0<br />
################################End
Script#########################################<br />
{}标记法是一种很好的使用位置参数的方法.这也需要间接引用(见Example 34-2)<br />
1 args=$# # 位置参数的个数<br />
2 lastarg=${!args}<br />
3 # 或: lastarg=${!#}<br />
4 # 注意 lastarg=${!$#} 将报错</p>

<p>一些脚本可能会依赖于使用不同的调用名字,而表现出不同的行为,这样一般都需要<br />
判断$0,而其他的名字都是通过ln命令产生的链接.(具体参见Example 12-2)</p>

<p>如果脚本需要一个命令行参数,而调用的时候,没用这个参数,这就有可能造成分配一个<br />
空变量,这样估计就会引起问题.一种解决办法就是在这个位置参数,和相关的变量后<br />
边,都添加一个额外的字符.具体见下边的例子.<br />
################################Start
Script#######################################<br />
1 variable1<em>=$1</em> # 而不是 variable1=$1<br />
2 # 这将阻止一个错误,即使在调用时没使用这个位置参数.<br />
3<br />
4 critical<em>argument01=$variable1</em><br />
5<br />
6 # 这个扩展的字符是可以被消除掉的,就像这样.<br />
7 variable1=${variable1<em>/</em>/}<br />
8 # 副作用就是$variable1_多了一个下划线<br />
9 # 这里使用了一个参数替换模版(后边会有具体的讨论)<br />
10 # (Leaving out the replacement pattern results in a deletion.)<br />
10 # (在一个删除动作中,节省了一个替换模式)<br />
11<br />
12<br />
13 # 一个解决这种问题的更简单的做法就是,判断一下这个位置参数是否传递下来了<br />
14 if [ -z $1 ]<br />
15 then<br />
16 exit $E_MISSING_POS_PARAM<br />
17 fi<br />
18<br />
19<br />
20 # 但是上边的方法将可能产生一个意外的副作用<br />
21 # 参数替换的更好的办法应该是:<br />
22 # ${1:-$DefaultVal}<br />
23 # 具体察看&rdquo;Parameter Substition&rdquo;节<br />
24 #+ 在第9章<br />
################################End
Script#########################################</p>

<p>Example 4-6 wh,whois节点名字查询<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # ex18.sh<br />
3<br />
4 # Does a &lsquo;whois domain-name&rsquo; lookup on any of 3 alternate servers:<br />
5 # ripe.net, cw.net, radb.net<br />
6<br />
7 # 把这个脚本重命名为&rsquo;wh&rsquo;,然后放到/usr/local/bin下<br />
8<br />
9 # 需要3个符号链接<br />
10 # ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe<br />
11 # ln -s /usr/local/bin/wh /usr/local/bin/wh-cw<br />
12 # ln -s /usr/local/bin/wh /usr/local/bin/wh-radb<br />
13<br />
14 E_NOARGS=65<br />
15<br />
16<br />
17 if [ -z &ldquo;$1&rdquo; ]<br />
18 then<br />
19 echo &ldquo;Usage: <code>basename $0</code> [domain-name]&rdquo;<br />
20 exit $E_NOARGS<br />
21 fi<br />
22<br />
23 # Check script name and call proper server.<br />
23 # 检查脚本名字,然后调用合适的服务器<br />
24 case <code>basename $0</code> in # Or: case ${0##*/} in<br />
25 &ldquo;wh&rdquo; ) whois $1@whois.ripe.net;;<br />
26 &ldquo;wh-ripe&rdquo;) whois $1@whois.ripe.net;;<br />
27 &ldquo;wh-radb&rdquo;) whois $1@whois.radb.net;;<br />
28 &ldquo;wh-cw&rdquo; ) whois $1@whois.cw.net;;<br />
29 * ) echo &ldquo;Usage: <code>basename $0</code> [domain-name]&ldquo;;;<br />
30 esac<br />
31<br />
32 exit $?<br />
################################End
Script#########################################</p>

<p>shift shift命令重新分配位置参数,其实就是向左移动一个位置.<br />
$1 老的$1将消失,但是$0(脚本名)是不会改变的.如果你使用了大量的位置参数,那么<br />
shift命令允许你存取超过10个参数.虽然{}表示法也允许这样.</p>

<p>Example 4-7 使用shift<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 使用&rsquo;shift&rsquo;来穿过所有的位置参数.<br />
3<br />
4 # 把这个脚本命名为shft,<br />
5 #+ 并且使用一些参数来调用它,如:<br />
6 # ./shft a b c def 23 skidoo<br />
7<br />
8 until [ -z &ldquo;$1&rdquo; ] # 知道所有参数都用光<br />
9 do<br />
10 echo -n &ldquo;$1 &rdquo;<br />
11 shift<br />
12 done<br />
13<br />
14 echo # 额外的换行.<br />
15<br />
16 exit 0<br />
################################End
Script#########################################<br />
在将参数传递到函数中时,shift的工作方式也基本差不多.具体见Example 33-15</p>

<p>注意事项:<br />
[1] 进程调用设置$0参数的脚本.一般的,这个参数就是脚本名字.具体察看execv的man页.</p>

<h1 id="第5章-引用-翻译的可能有问题-特指引号">第5章 引用(翻译的可能有问题,特指引号)</h1>

<p>引号的特殊效果就是,保护字符串中的特殊字符不被shell或者是shell脚本重新解释或者扩展.<br />
(我们这里所说的&rdquo;特殊&rdquo;指的是一些字符在shell中具有的特殊意义,比如<em>)<br />
如:<br />
bash$ ls -l [Vv]</em><br />
-rw-rw-r&ndash; 1 bozo bozo 324 Apr 2 15:05 VIEWDATA.BAT<br />
-rw-rw-r&ndash; 1 bozo bozo 507 May 4 14:25 vartrace.sh<br />
-rw-rw-r&ndash; 1 bozo bozo 539 Apr 14 17:11 viewdata.sh</p>

<p>bash$ ls -l &lsquo;[Vv]<em>&rsquo;<br />
ls: [Vv]</em>: No such file or directory</p>

<p>在我们一般的生活中,引号内的内容往往有特殊的含义,而在Bash中,当我们引用一个字符串,<br />
我们是保护它的字面含义.</p>

<p>特定的程序和工具能够重新解释或扩展特殊的字符.引用的一个重要的作用就是保护命令行中<br />
的参数,但还是允许正在调用的程序来扩展它.<br />
bash$ grep &lsquo;[Ff]irst&rsquo; *.txt<br />
file1.txt:This is the first line of file1.txt.<br />
file2.txt:This is the First line of file2.txt.</p>

<p>注意 grep [Ff]irst *.txt在Bash下的行为(其实就是正则表达式么),[1]</p>

<p>引用还可以抑制echo命令的换行作用.</p>

<p>bash$ echo $(ls -l)<br />
total 8 -rw-rw-r&ndash; 1 bozo bozo 130 Aug 21 12:57 t222.sh -rw-rw-r&ndash; 1 bozo bozo
78 Aug 21 12:57 t71.sh</p>

<p>bash$ echo &ldquo;$(ls -l)&rdquo;<br />
total 8<br />
-rw-rw-r&ndash; 1 bozo bozo 130 Aug 21 12:57 t222.sh<br />
-rw-rw-r&ndash; 1 bozo bozo 78 Aug 21 12:57 t71.sh</p>

<p>5.1 引用变量<br />
-&mdash;&mdash;&mdash;&ndash;<br />
在一个双引号中直接使用变量名,一般都是没有问题的.它阻止了所有在引号中的特殊字符的<br />
重新解释&ndash;包括变量名[2]&ndash;但是$,`和\除外.[3]保留$,作为特殊字符的意义,是为了能够在双<br />
引号中也能够正常地引用变量(&ldquo;$var&rdquo;).这样在&rdquo;&ldquo;中可以使用变量所表达的值(Example 4-1).</p>

<p>使用&rdquo;&ldquo;来防止单词分割.[4]如果在参数列表中使用双引号,将使得双引号中的参数作为一个参<br />
数.即使双引号中的字符串包含多个单词(也就是包含空白部分),也不会变为多个参数,如:<br />
1 variable1=&ldquo;a variable containing five words&rdquo;<br />
2 COMMAND This is $variable1 # COMMAND将以7个参数来执行<br />
3 # &ldquo;This&rdquo; &ldquo;is&rdquo; &ldquo;a&rdquo; &ldquo;variable&rdquo; &ldquo;containing&rdquo; &ldquo;five&rdquo; &ldquo;words&rdquo;<br />
4<br />
5 COMMAND &ldquo;This is $variable1&rdquo; # COMMAND将以1个参数来执行<br />
6 # &ldquo;This is a variable containing five words&rdquo;<br />
7<br />
8<br />
9 variable2=&ldquo;&rdquo; # 空值<br />
10<br />
11 COMMAND $variable2 $variable2 $variable2 # COMMAND将不带参数执行<br />
12 COMMAND &ldquo;$variable2&rdquo; &ldquo;$variable2&rdquo; &ldquo;$variable2&rdquo; # COMMAND将以3个空参数来执行<br />
13 COMMAND &ldquo;$variable2 $variable2 $variable2&rdquo; # COMMAND将以1个参数来执行(2空格)<br />
用双引号把参数封到echo中是很有必要的,只有在单词分隔或时保留空白时的时候可能<br />
有些问题.</p>

<p>Example 5-1 echo一些诡异的变量<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # weirdvars.sh: echo诡异的变量<br />
3<br />
4 var=&ldquo;&lsquo;(]\\{}\$\&ldquo;&rdquo;<br />
5 echo $var # &lsquo;(]\{}$&rdquo;<br />
6 echo &ldquo;$var&rdquo; # &lsquo;(]\{}$&rdquo; 并没有什么不同<br />
7<br />
8 echo<br />
9<br />
10 IFS=&rsquo;\&rsquo;<br />
11 echo $var # &lsquo;(] {}$&rdquo; \ 转换成空格了?明显和IFS有关系么!又不傻!<br />
12 echo &ldquo;$var&rdquo; # &lsquo;(]\{}$&rdquo;<br />
13<br />
14 exit 0<br />
################################End
Script#########################################</p>

<p>单引号操作总体上和&rdquo;&ldquo;很像,但不允许引用变量.因为$的特殊含义被关闭了.在&rdquo;中除了&rsquo;,其他<br />
字符都没有特殊的含义了.所以单引号比双引号严格.<br />
因为即使是\,在&rdquo;中都被关闭了,所以你想在&rdquo;中显示&rsquo;的含义,将得不到预期的效果.<br />
1 echo &ldquo;Why can&rsquo;t I write &rsquo;s between single quotes&rdquo;<br />
2<br />
3 echo<br />
4<br />
5 # 一种绕弯的方法<br />
6 echo &lsquo;Why can&rsquo;\&ldquo;t I write &lsquo;&rdquo;&rsquo;&ldquo;&rsquo;s between single quotes&rsquo;<br />
7 # |&mdash;&mdash;-| |&mdash;&mdash;&mdash;-| |&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|<br />
8 # 包含了2个单引号字符,原书好像有错误</p>

<p>注意事项:<br />
[1] 除非当前目录下,正好有个叫first的文件.<br />
[2] 即使是变量的值也是有副作用的(见下边)<br />
[3] 如果在&rdquo;&ldquo;中包含&rdquo;!&ldquo;的话,在命令行中将会出现错误.因为这个&rdquo;!&ldquo;被当作历史命令来解释了.<br />
在一个脚本中,这种情况是不会发生的,因为在脚本中,Bash历史记录被关闭了.</p>

<p>下边是一些关于&rdquo;\&ldquo;一些不协调的行为.<br />
bash$ echo hello\!<br />
hello!</p>

<p>bash$ echo &ldquo;hello\!&rdquo;<br />
hello\!</p>

<p>bash$ echo -e x\ty<br />
xty</p>

<p>bash$ echo -e &ldquo;x\ty&rdquo;<br />
x y</p>

<p>[4] &ldquo;单词分隔&rdquo;,在这个上下文中意味着,将一个字符串分隔为一些分离的参数.</p>

<p>5.2 转义(\)<br />
-&mdash;&mdash;&mdash;-<br />
转义是一种引用单个字符的方法.一个具有特殊含义的字符前边放上一个转义符(\)就告诉shell<br />
这个字符失去了特殊的含义.<br />
值得注意的是,在某些特定的命令和工具中,比如echo和sed,转义符往往会起到相反的效果,<br />
它反倒有可能引发出这个字符特殊的含义.</p>

<p>对于特定的转义符的特殊的含义<br />
在echo和sed中所使用的<br />
\n 意味着新的一行<br />
\r 回车<br />
\t tab键<br />
\v vertical tab(垂直tab),查前边的Ctl-K<br />
\b backspace,查前边的Ctl-H<br />
\a &ldquo;alert&rdquo;(如beep或flash)<br />
\0xx 转换成8进制ASCII解码,等价于oxx</p>

<p>Example 5-2 转义符<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # escaped.sh: 转义符<br />
3<br />
4 echo; echo<br />
5<br />
6 echo &ldquo;\v\v\v\v&rdquo; # 逐字的打印\v\v\v\v .<br />
7 # 使用-e选项的echo命令来打印转义符<br />
8 echo &ldquo;=============&rdquo;<br />
9 echo &ldquo;VERTICAL TABS&rdquo;<br />
10 echo -e &ldquo;\v\v\v\v&rdquo; # Prints 4 vertical tabs.<br />
11 echo &ldquo;==============&rdquo;<br />
12<br />
13 echo &ldquo;QUOTATION MARK&rdquo;<br />
14 echo -e &ldquo;\042&rdquo; # 打印&rdquo; (引号, 8进制的ASCII 码就是42).<br />
15 echo &ldquo;==============&rdquo;<br />
16<br />
17 # The $&rsquo;\X&rsquo; construct makes the -e option unnecessary.<br />
17 # 如果使用$&rsquo;\X&rsquo;结构,那-e选项就不必要了<br />
18 echo; echo &ldquo;NEWLINE AND BEEP&rdquo;<br />
19 echo $&rsquo;\n&rsquo; # 新行.<br />
20 echo $&rsquo;\a&rsquo; # Alert (beep).<br />
21<br />
22 echo &ldquo;===============&rdquo;<br />
23 echo &ldquo;QUOTATION MARKS&rdquo;<br />
24 # 版本2以后Bash允许使用$&rsquo;\nnn&rsquo;结构<br />
25 # 注意这种情况,&rsquo;\nnn\是8进制<br />
26 echo $&rsquo;\t \042 \t&rsquo; # Quote (&ldquo;) framed by tabs.<br />
27<br />
28 # 当然,也可以使用16进制的值,使用$&rsquo;\xhhh&rsquo; 结构<br />
29 echo $&rsquo;\t \x22 \t&rsquo; # Quote (&ldquo;) framed by tabs.<br />
30<br />
31 # 早一点的Bash版本允许&rsquo;\x022&rsquo;这种形式<br />
32 echo &ldquo;===============&rdquo;<br />
33 echo<br />
34<br />
35<br />
36 # 分配ASCII字符到变量中<br />
37 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
38 quote=$&rsquo;\042&rsquo; # \042是&rdquo;,分配到变量中<br />
39 echo &ldquo;$quote This is a quoted string, $quote and this lies outside the
quotes.&rdquo;<br />
40<br />
41 echo<br />
42<br />
43 # Concatenating ASCII chars in a variable.<br />
43 # 变量中的连续的ASCII char.<br />
44 triple<em>underline=$&rsquo;\137\137\137&rsquo; # 137 是8进制的ASCII 码&rsquo;</em>&rsquo;.<br />
45 echo &ldquo;$triple_underline UNDERLINE $triple_underline&rdquo;<br />
46<br />
47 echo<br />
48<br />
49 ABC=$&rsquo;\101\102\103\010&rsquo; # 101, 102, 103 是8进制的码A, B, C.<br />
50 echo $ABC<br />
51<br />
52 echo; echo<br />
53<br />
54 escape=$&rsquo;\033&rsquo; # 033 是8进制码for escape.<br />
55 echo &ldquo;\&ldquo;escape\&rdquo; echoes as $escape&rdquo;<br />
56 #&ldquo;escape&rdquo; echoes as 没有变量被输出<br />
57<br />
58 echo; echo<br />
59<br />
60 exit 0<br />
################################End
Script#########################################<br />
另一个关于$&ldquo;字符串扩展结果的例子见Example 34-1</p>

<p>\&rdquo; 表达引号本身<br />
1 echo &ldquo;Hello&rdquo; # Hello<br />
2 echo &ldquo;\&ldquo;Hello\&ldquo;, he said.&rdquo; # &ldquo;Hello&rdquo;, he said.</p>

<p>\$ $号本身,跟在\$后的变量名,将不能扩展<br />
1 echo &ldquo;\$variable01&rdquo; # 结果是$variable01</p>

<p>\\ \号本身.<br />
1 echo &ldquo;\\&rdquo; # 结果是\<br />
2<br />
3 # 相反的 &hellip;<br />
4<br />
5 echo &ldquo;\&rdquo; # 这会出现第2个命令提示符,说白了就是提示你命令不全,你再补个&rdquo;就<br />
6 # 好了.如果是在脚本里,就会给出一个错误.</p>

<p>注意:\的行为依赖于它是否被转义,被&rdquo;&ldquo;,或者是否在&rdquo;命令替换&rdquo;和&rdquo;here document&rdquo;中.<br />
################################Start
Script#######################################<br />
1 # 简单的转义和&rdquo;&rdquo;<br />
2 echo \z # z<br />
3 echo \\z # \z<br />
4 echo &lsquo;\z&rsquo; # \z<br />
5 echo &lsquo;\\z&rsquo; # \\z<br />
6 echo &ldquo;\z&rdquo; # \z<br />
7 echo &ldquo;\\z&rdquo; # \z<br />
8<br />
9 # 命令替换<br />
10 echo <code>echo \z</code> # z<br />
11 echo <code>echo \\\z</code> # z<br />
12 echo <code>echo \\\\\z</code> # \z<br />
13 echo <code>echo \\\\\\\z</code> # \z<br />
14 echo <code>echo \\\\\\\\\\\z</code> # \z<br />
15 echo <code>echo \\\\\\\\\\\\\z</code> # \\z<br />
16 echo <code>echo &quot;\z&quot;</code> # \z<br />
17 echo <code>echo &quot;\\\z&quot;</code> # \z<br />
18<br />
19 # Here document<br />
20 cat &lt; 21 \z<br />
22 EOF # \z<br />
23<br />
24 cat &lt; 25 \\z<br />
26 EOF # \z<br />
################################End
Script#########################################</p>

<p>分配给变量的字符串的元素也会被转义,但是只把一个转义符分配给变量将会报错.<br />
################################Start
Script#######################################<br />
1 variable=\<br />
2 echo &ldquo;$variable&rdquo;<br />
3 # Will not work - gives an error message:<br />
3 # 将不能正常工作- 将给出一个错误消息:<br />
4 # test.sh: : command not found<br />
5 # 一个&rdquo;裸体的&rdquo; 转义符将不能够安全的分配给变量.<br />
6 #<br />
7 # What actually happens here is that the &ldquo;\&rdquo; escapes the newline and<br />
7 # 这里其实真正发生的是variable=\,这句被shell认为是没有完成,\被认为是一个续行符<br />
8 #+ 这样,下边的这句echo,也被认为是上一行的补充.所以,总的来说就是一个非法变量分配<br />
9<br />
10 variable=\<br />
11 23skidoo<br />
12 echo &ldquo;$variable&rdquo; # 23skidoo<br />
13 # 这句就可以使用,因为这是一个合法的变量分配<br />
14<br />
15 variable=\<br />
16 # \^ 转义一个空格<br />
17 echo &ldquo;$variable&rdquo; # 显示空格<br />
18<br />
19 variable=\\<br />
20 echo &ldquo;$variable&rdquo; # \<br />
21<br />
22 variable=\\\<br />
23 echo &ldquo;$variable&rdquo;<br />
24 # 不能正常工作,给出一个错误<br />
25 # test.sh: : command not found<br />
26 #<br />
27 # 第一个转义符把第2个\转义了,但是第3个又变成&rdquo;裸体的&rdquo;了,<br />
28 #+ 与上边的例子的原因相同<br />
29<br />
30 variable=\\\\<br />
31 echo &ldquo;$variable&rdquo; # \\<br />
32 # 转了两个\<br />
33 # 没问题<br />
################################End
Script#########################################</p>

<p>转义一个空格,在命令行参数列表中将会阻止单词分隔问题.<br />
################################Start
Script#######################################<br />
1 file_list=&ldquo;/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7&rdquo;<br />
2 # 列出的文件都作为命令的参数.<br />
3<br />
4 # Add two files to the list, and list all.<br />
4 # 加2个文件到list中,并且列出全部.<br />
5 ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list<br />
6<br />
7 echo
&ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
8<br />
9 # 如果我们转义2个空格,会发生什么?<br />
10 ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list<br />
11 # 错误: 因为前3个路径名被合并成一个参数传给了&rsquo;ls -l&rsquo;<br />
12 # 因为2个转义符阻止了参数(单词)分离<br />
################################End
Script#########################################</p>

<p>转义符也提供续行功能.一般,每一行都包含一个不同的命令,但如果在行尾加上\,那就会接受<br />
新行的输入,作为这一行的补充.<br />
1 (cd /source/directory &amp;&amp; tar cf - . ) | \<br />
2 (cd /dest/directory &amp;&amp; tar xpvf -)<br />
3 # 重复了 Alan Cox的目录树拷贝命令<br />
4 # 为了增加可读性分成2行.<br />
5<br />
6 # 也可以使用如下方式:<br />
7 tar cf - -C /source/directory . |<br />
8 tar xpvf - -C /dest/directory<br />
9 # 察看下边的注意事项</p>

<p>注意:如果一个脚本以|(管道字符)结束.那么一个\(转义符),就不用非加上不可了.<br />
但是一个好的shell脚本编写风格,还是应该在行尾加上\,以增加可读性.<br />
################################Start
Script#######################################<br />
1 echo &ldquo;foo<br />
2 bar&rdquo;<br />
3 #foo<br />
4 #bar<br />
5<br />
6 echo<br />
7<br />
8 echo &lsquo;foo<br />
9 bar&rsquo; # 没区别<br />
10 #foo<br />
11 #bar<br />
12<br />
13 echo<br />
14<br />
15 echo foo\<br />
16 bar # 续行<br />
17 #foobar<br />
18<br />
19 echo<br />
20<br />
21 echo &ldquo;foo\<br />
22 bar&rdquo; # 与上边一样,\还是作为续行符<br />
23 #foobar<br />
24<br />
25 echo<br />
26<br />
27 echo &lsquo;foo\<br />
28 bar&rsquo; # 由于是强引用,所以\没被解释成续行符<br />
29 #foo\<br />
30 #bar<br />
################################End
Script#########################################</p>

<h1 id="第6章-退出和退出状态">第6章 退出和退出状态</h1>

<p>exit命令被用来结束脚本,就像C语言一样.他也会返回一个值来传给父进程,父进程会判断是否<br />
可用.</p>

<p>每个命令都会返回一个exit状态(有时候也叫return状态).成功返回0,如果返回一个非0值,通<br />
常情况下都会被认为是一个错误码.一个编写良好的UNIX命令,程序,和工具都会返回一个0作为<br />
退出码来表示成功,虽然偶尔也会有例外.</p>

<p>同样的,脚本中的函数和脚本本身都会返回退出状态.在脚本或者是脚本函数中执行的最后的命<br />
令会决定退出状态.在脚本中,exit nnn命令将会把nnn退出码传递给shell(nnn必须是10进制数<br />
0-255).</p>

<p>当一个脚本以不带参数exit来结束时,脚本的退出状态就由脚本中最后执行命令来决定.<br />
1 #!/bin/bash<br />
2<br />
3 COMMAND_1<br />
4<br />
5 &hellip;<br />
6<br />
7 # 将以最后的命令来决定退出状态<br />
8 COMMAND_LAST<br />
9<br />
10 exit $?</p>

<p>1 #!/bin/bash<br />
2<br />
3 COMMAND1<br />
4<br />
5 &hellip;<br />
6<br />
7 # 将以最后的命令来决定退出状态<br />
8 COMMAND_LAST</p>

<p>$?读取最后执行命令的退出码.函数返回后,$?给出函数最后执行的那条命令的退出码.这种给<br />
函数返回值的方法是Bash的方法.对于脚本来说也一样.总之,一般情况下,0为成功,非0失败W.<br />
Example 6-1 exit/exit状态<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 echo hello<br />
4 echo $? # 返回0,因为执行成功<br />
5<br />
6 lskdf # 不认识的命令.<br />
7 echo $? # 返回非0值,因为失败了.<br />
8<br />
9 echo<br />
10<br />
11 exit 113 # 将返回113给shell.<br />
12 # To verify this, type &ldquo;echo $?&rdquo; after script terminates.<br />
12 # 为了验证这个,在脚本结束的地方使用&rdquo;echo $?&rdquo;<br />
################################End
Script#########################################</p>

<p>$?对于测试脚本中的命令的结果特别有用(见Example 12-32和Example 12-17).<br />
注意: !逻辑非操作,将会反转test命令的结果,并且这会影响exit状态.<br />
Example 6-2 否定一个条件使用!<br />
################################Start
Script#######################################<br />
1 true # true是shell内建命令,什么事都不做,就是shell返回0<br />
2 echo &ldquo;exit status of \&ldquo;true\&rdquo; = $?&rdquo; # 0<br />
3<br />
4 ! true<br />
5 echo &ldquo;exit status of \&ldquo;! true\&rdquo; = $?&rdquo; # 1<br />
6 # 注意:&ldquo;!&ldquo;需要一个空格<br />
7 # !true 将导致一个&rdquo;command not found&rdquo;错误<br />
8 #<br />
9 # 如果一个命令以&rsquo;!&lsquo;开头,那么将使用Bash的历史机制.就是显示这个命令被使用的历史.<br />
10<br />
11 true<br />
12 !true<br />
13 # 这次就没有错误了.<br />
14 # 他不过是重复了之前的命令(true).<br />
################################End
Script#########################################</p>

<p>注意事项:<br />
特定的退出码都有预定的含义(见附录D),用户不应该在自己的脚本中指定他.</p>

<h1 id="第7章-tests">第7章 Tests</h1>

<p>每个完整的合理的编程语言都具有条件判断的功能.Bash具有test命令,不同的[]和()操作,和<br />
if/then结构.</p>

<p>7.1 Test结构<br />
-&mdash;&mdash;&mdash;&ndash;<br />
一个if/then结构可以测试命令的返回值是否为0(因为0表示成功),如果是的话,执行更多命令.</p>

<p>有一个专用命令&rdquo;[&ldquo;(左中括号,特殊字符).这个命令与test命令等价,但是出于效率上的考虑,<br />
它是一个内建命令.这个命令把它的参数作为比较表达式或是文件测试,并且根据比较的结果,<br />
返回一个退出码.</p>

<p>在版本2.02的Bash中,推出了一个新的[[&hellip;]]扩展test命令.因为这种表现形式可能对某些语<br />
言的程序员来说更加熟悉.注意&rdquo;[[&ldquo;是一个关键字,并不是一个命令.</p>

<p>Bash把[[ $a -lt $b ]]看作一个单独的元素,并且返回一个退出码.</p>

<p>((&hellip;))和let&hellip;结果也能够返回一个退出码,当它们所测试的算术表达式的结果为非0的时候,<br />
他们的退出码将返回0.这些算术扩展(见第15章)结构被用来做算术比较.<br />
1 let &ldquo;1&lt;2&rdquo; returns 0 (as &ldquo;1&lt;2&rdquo; expands to &ldquo;1&rdquo;)<br />
2 (( 0 &amp;&amp; 1 )) returns 1 (as &ldquo;0 &amp;&amp; 1&rdquo; expands to &ldquo;0&rdquo;)</p>

<p>if命令可以测试任何命令,不仅仅是括号中的条件.<br />
1 if cmp a b &amp;&gt; /dev/null # 阻止输出.<br />
2 then echo &ldquo;Files a and b are identical.&rdquo;<br />
3 else echo &ldquo;Files a and b differ.&rdquo;<br />
4 fi<br />
5<br />
6 # 非常有用的&rdquo;if-grep&rdquo; 结构:<br />
7 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
8 if grep -q Bash file<br />
9 then echo &ldquo;File contains at least one occurrence of Bash.&rdquo;<br />
10 fi<br />
11<br />
12 word=Linux<br />
13 letter_sequence=inu<br />
14 if echo &ldquo;$word&rdquo; | grep -q &ldquo;$letter_sequence&rdquo;<br />
15 # &ldquo;-q&rdquo;选项是用来阻止输出<br />
16 then<br />
17 echo &ldquo;$letter_sequence found in $word&rdquo;<br />
18 else<br />
19 echo &ldquo;$letter_sequence not found in $word&rdquo;<br />
20 fi<br />
21<br />
22<br />
23 if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED<br />
24 then echo &ldquo;Command succeeded.&rdquo;<br />
25 else echo &ldquo;Command failed.&rdquo;<br />
26 fi</p>

<p>一个if/then结构可以包含多级比较和tests.</p>

<p>1 if echo &ldquo;Next <em>if</em> is part of the comparison for the first <em>if</em>.&rdquo;<br />
2<br />
3 if [[ $comparison = &ldquo;integer&rdquo; ]]<br />
4 then (( a &lt; b ))<br />
5 else<br />
6 [[ $a &lt; $b ]]<br />
7 fi<br />
8<br />
9 then<br />
10 echo &lsquo;$a is less than $b&rsquo;<br />
11 fi</p>

<p>Example 7-1 什么情况下为真?<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 技巧:<br />
4 # 如果你不确定一个特定的条件如何判断.<br />
5 #+ 在一个if-test结构中测试它.<br />
6<br />
7 echo<br />
8<br />
9 echo &ldquo;Testing \&ldquo;0\&ldquo;&rdquo;<br />
10 if [ 0 ] # zero<br />
11 then<br />
12 echo &ldquo;0 is true.&rdquo;<br />
13 else<br />
14 echo &ldquo;0 is false.&rdquo;<br />
15 fi # 0 is true.<br />
16<br />
17 echo<br />
18<br />
19 echo &ldquo;Testing \&ldquo;1\&ldquo;&rdquo;<br />
20 if [ 1 ] # one<br />
21 then<br />
22 echo &ldquo;1 is true.&rdquo;<br />
23 else<br />
24 echo &ldquo;1 is false.&rdquo;<br />
25 fi # 1 is true.<br />
26<br />
27 echo<br />
28<br />
29 echo &ldquo;Testing \&ldquo;-1\&ldquo;&rdquo;<br />
30 if [ -1 ] # -1<br />
31 then<br />
32 echo &ldquo;-1 is true.&rdquo;<br />
33 else<br />
34 echo &ldquo;-1 is false.&rdquo;<br />
35 fi # -1 is true.<br />
36<br />
37 echo<br />
38<br />
39 echo &ldquo;Testing \&ldquo;NULL\&ldquo;&rdquo;<br />
40 if [ ] # NULL (控状态)<br />
41 then<br />
42 echo &ldquo;NULL is true.&rdquo;<br />
43 else<br />
44 echo &ldquo;NULL is false.&rdquo;<br />
45 fi # NULL is false.<br />
46<br />
47 echo<br />
48<br />
49 echo &ldquo;Testing \&ldquo;xyz\&ldquo;&rdquo;<br />
50 if [ xyz ] # 字符串<br />
51 then<br />
52 echo &ldquo;Random string is true.&rdquo;<br />
53 else<br />
54 echo &ldquo;Random string is false.&rdquo;<br />
55 fi # Random string is true.<br />
56<br />
57 echo<br />
58<br />
59 echo &ldquo;Testing \&rdquo;\$xyz\&ldquo;&rdquo;<br />
60 if [ $xyz ] # 测试$xyz是否为null,但是&hellip;(明显没人定义么!)<br />
61 # 只不过是一个未定义的变量<br />
62 then<br />
63 echo &ldquo;Uninitialized variable is true.&rdquo;<br />
64 else<br />
65 echo &ldquo;Uninitialized variable is false.&rdquo;<br />
66 fi # Uninitialized variable is false.<br />
67<br />
68 echo<br />
69<br />
70 echo &ldquo;Testing \&ldquo;-n \$xyz\&ldquo;&rdquo;<br />
71 if [ -n &ldquo;$xyz&rdquo; ] # 更学究的的检查<br />
72 then<br />
73 echo &ldquo;Uninitialized variable is true.&rdquo;<br />
74 else<br />
75 echo &ldquo;Uninitialized variable is false.&rdquo;<br />
76 fi # Uninitialized variable is false.<br />
77<br />
78 echo<br />
79<br />
80<br />
81 xyz= # 初始化了,但是将其设为空值<br />
82<br />
83 echo &ldquo;Testing \&ldquo;-n \$xyz\&ldquo;&rdquo;<br />
84 if [ -n &ldquo;$xyz&rdquo; ]<br />
85 then<br />
86 echo &ldquo;Null variable is true.&rdquo;<br />
87 else<br />
88 echo &ldquo;Null variable is false.&rdquo;<br />
89 fi # Null variable is false.<br />
90<br />
91<br />
92 echo<br />
93<br />
94<br />
95 # 什么时候&rdquo;flase&rdquo;为true?<br />
96<br />
97 echo &ldquo;Testing \&ldquo;false\&ldquo;&rdquo;<br />
98 if [ &ldquo;false&rdquo; ] # 看起来&rdquo;false&rdquo;只不过是个字符串而已.<br />
99 then<br />
100 echo &ldquo;\&ldquo;false\&rdquo; is true.&rdquo; #+ 并且它test的结果就是true.<br />
101 else<br />
102 echo &ldquo;\&ldquo;false\&rdquo; is false.&rdquo;<br />
103 fi # &ldquo;false&rdquo; is true.<br />
104<br />
105 echo<br />
106<br />
107 echo &ldquo;Testing \&rdquo;\$false\&ldquo;&rdquo; # 再来一个,未声明的变量<br />
108 if [ &ldquo;$false&rdquo; ]<br />
109 then<br />
110 echo &ldquo;\&rdquo;\$false\&rdquo; is true.&rdquo;<br />
111 else<br />
112 echo &ldquo;\&rdquo;\$false\&rdquo; is false.&rdquo;<br />
113 fi # &ldquo;$false&rdquo; is false.<br />
114 # 现在我们终于得到了期望的结果<br />
115<br />
116 # 如果我们test这个变量&rdquo;$true&rdquo;会发生什么结果?答案是和&rdquo;$flase&rdquo;一样,都为空,因为我<br />
117 #+ 们并没有定义它.<br />
118 echo<br />
119<br />
120 exit 0<br />
################################End
Script#########################################<br />
练习.解释上边例子的行为(我想我解释的已经够清楚了)</p>

<p>1 if [ condition-true ]<br />
2 then<br />
3 command 1<br />
4 command 2<br />
5 &hellip;<br />
6 else<br />
7 # 可选的(如果不需要可以省去)<br />
8 # 如果原始的条件测试结果是false,那么添加默认的代码来执行.<br />
9 command 3<br />
10 command 4<br />
11 &hellip;<br />
12 fi</p>

<p>注意:当if和then在一个条件测试的同一行中的话,必须使用&rdquo;;&ldquo;来终止if表达式.if和then都是<br />
关键字.关键字(或者命令)作为一个表达式的开头,并且在一个新的表达式开始之前,必须<br />
结束上一个表达式.<br />
1 if [ -x &ldquo;$filename&rdquo; ]; then</p>

<p>Else if和elif</p>

<p>elif<br />
elif是else if的缩减形式.<br />
1 if [ condition1 ]<br />
2 then<br />
3 command1<br />
4 command2<br />
5 command3<br />
6 elif [ condition2 ]<br />
7 # Same as else if<br />
8 then<br />
9 command4<br />
10 command5<br />
11 else<br />
12 default-command<br />
13 fi</p>

<p>使用if test condition-true这种形式和if[condition-true]这种形式是等价的.向我们前边<br />
所说的&rdquo;[&ldquo;是test的标记.并且以&rdquo;]&ldquo;结束.在if/test中并不应该这么严厉,但是新版本的Bash<br />
需要它.</p>

<p>注意:test命令是Bash的内建命令,用来测试文件类型和比较字符串.因此,在Bash脚本中,test<br />
并不调用/usr/bin/test的二进制版本(这是sh-utils工具包的一部分).同样的,[并不调用<br />
/usr/bin/[,被连接到/usr/bin/test.<br />
bash$ type test<br />
test is a shell builtin<br />
bash$ type &lsquo;[&rsquo;<br />
[ is a shell builtin<br />
bash$ type &lsquo;[[&rsquo;<br />
[[ is a shell keyword<br />
bash$ type &lsquo;]]&rsquo;<br />
]] is a shell keyword<br />
bash$ type &lsquo;]&rsquo;<br />
bash: type: ]: not found</p>

<p>Example 7-2 几个等效命令test,/usr/bin/test,[],和/usr/bin/[<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 echo<br />
4<br />
5 if test -z &ldquo;$1&rdquo;<br />
6 then<br />
7 echo &ldquo;No command-line arguments.&rdquo;<br />
8 else<br />
9 echo &ldquo;First command-line argument is $1.&rdquo;<br />
10 fi<br />
11<br />
12 echo<br />
13<br />
14 if /usr/bin/test -z &ldquo;$1&rdquo; # 与内建的test结果相同<br />
15 then<br />
16 echo &ldquo;No command-line arguments.&rdquo;<br />
17 else<br />
18 echo &ldquo;First command-line argument is $1.&rdquo;<br />
19 fi<br />
20<br />
21 echo<br />
22<br />
23 if [ -z &ldquo;$1&rdquo; ] # 与上边代码的作用相同<br />
24 # if [ -z &ldquo;$1&rdquo; 应该工作,但是&hellip;<br />
25 #+ Bash相应一个缺少关闭中括号的错误消息.<br />
26 then<br />
27 echo &ldquo;No command-line arguments.&rdquo;<br />
28 else<br />
29 echo &ldquo;First command-line argument is $1.&rdquo;<br />
30 fi<br />
31<br />
32 echo<br />
33<br />
34<br />
35 if /usr/bin/[ -z &ldquo;$1&rdquo; ] # 再来一个,与上边代码的作用相同<br />
36 # if /usr/bin/[ -z &ldquo;$1&rdquo; # 工作,但是给个错误消息<br />
37 # # 注意:<br />
38 # This has been fixed in Bash, version 3.x.<br />
38 # 在ver 3.x上,这个bug已经被Bash修正了.<br />
39 then<br />
40 echo &ldquo;No command-line arguments.&rdquo;<br />
41 else<br />
42 echo &ldquo;First command-line argument is $1.&rdquo;<br />
43 fi<br />
44<br />
45 echo<br />
46<br />
47 exit 0<br />
###############################End
Script#########################################</p>

<p>[[]]结构比Bash的[]更加灵活,这是一个扩展的test命令,从ksh88继承过来的.<br />
注意:在[[]]结构中,将没有文件扩展或者是单词分离,但是会发生参数扩展和命令替换.<br />
1 file=/etc/passwd<br />
2<br />
3 if [[ -e $file ]]<br />
4 then<br />
5 echo &ldquo;Password file exists.&rdquo;<br />
6 fi<br />
注意:使用[[]],而不是[],能够阻止脚本中的许多逻辑错误.比如,尽管在[]中将给出一个错误,<br />
但是&amp;&amp;,||,&lt;&gt;操作还是能够工作在一个[[]]test之中.<br />
注意:在if后边,test命令和[]或[[]]都不是必须的.如下:<br />
1 dir=/home/bozo<br />
2<br />
3 if cd &ldquo;$dir&rdquo; 2&gt;/dev/null; then # &ldquo;2&gt;/dev/null&rdquo; hides error message.<br />
4 echo &ldquo;Now in $dir.&rdquo;<br />
5 else<br />
6 echo &ldquo;Can&rsquo;t change to $dir.&rdquo;<br />
7 fi<br />
if命令将返回if后边的命令的退出码.</p>

<p>与此相似,当在一个在使用与或列表结构的时候,test或中括号的使用,也并不一定非的有if不可<br />
1 var1=20<br />
2 var2=22<br />
3 [ &ldquo;$var1&rdquo; -ne &ldquo;$var2&rdquo; ] &amp;&amp; echo &ldquo;$var1 is not equal to $var2&rdquo;<br />
4<br />
5 home=/home/bozo<br />
6 [ -d &ldquo;$home&rdquo; ] || echo &ldquo;$home directory does not exist.&rdquo;</p>

<p>(())结构扩展并计算一个算术表达式的结果.如果表达式的结果为0,它将返回1作为退出码,或<br />
者是&rdquo;false&rdquo;.而一个非0表达式的结果将返回0作为退出码,或者是&rdquo;true&rdquo;.</p>

<p>Example 7-3 算数测试使用(( ))<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 算数测试<br />
3<br />
4 # The (( &hellip; )) construct evaluates and tests numerical expressions.<br />
4 # (( &hellip; ))结构计算并测试算数表达式的结果.<br />
5 # 退出码将与[ &hellip; ]结构相反!<br />
6<br />
7 (( 0 ))<br />
8 echo &ldquo;Exit status of \&ldquo;(( 0 ))\&rdquo; is $?.&rdquo; # 1<br />
9<br />
10 (( 1 ))<br />
11 echo &ldquo;Exit status of \&ldquo;(( 1 ))\&rdquo; is $?.&rdquo; # 0<br />
12<br />
13 (( 5 &gt; 4 )) # true<br />
14 echo &ldquo;Exit status of \&ldquo;(( 5 &gt; 4 ))\&rdquo; is $?.&rdquo; # 0<br />
15<br />
16 (( 5 &gt; 9 )) # false<br />
17 echo &ldquo;Exit status of \&ldquo;(( 5 &gt; 9 ))\&rdquo; is $?.&rdquo; # 1<br />
18<br />
19 (( 5 - 5 )) # 0<br />
20 echo &ldquo;Exit status of \&ldquo;(( 5 - 5 ))\&rdquo; is $?.&rdquo; # 1<br />
21<br />
22 (( 5 / 4 )) # 除法也行<br />
23 echo &ldquo;Exit status of \&ldquo;(( 5 / 4 ))\&rdquo; is $?.&rdquo; # 0<br />
24<br />
25 (( 1 / 2 )) # 出发结果<1  
26 echo "Exit status of \"(( 1 / 2 ))\" is $?." # 结果将为0  
27 # 1  
28  
29 (( 1 / 0 )) 2>/dev/null # 除数为0的错误<br />
30 # ^^^^^^^^^^^<br />
31 echo &ldquo;Exit status of \&ldquo;(( 1 / 0 ))\&rdquo; is $?.&rdquo; # 1<br />
32<br />
33 # What effect does the &ldquo;2&gt;/dev/null&rdquo; have?<br />
33 # &ldquo;2&gt;/dev/null&rdquo;的作用是什么?<br />
34 # 如果删除&rdquo;2&gt;dev/null&rdquo;将会发生什么?<br />
35 # Try removing it, then rerunning the script.<br />
35 # 尝试删除它,然后再运行脚本.<br />
36<br />
37 exit 0<br />
################################End
Script#########################################</p>

<p>7.2 文件测试操作<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;<br />
返回true如果&hellip;</p>

<p>-e 文件存在<br />
-a 文件存在<br />
这个选项的效果与-e相同.但是它已经被弃用了,并且不鼓励使用<br />
-f file是一个regular文件(不是目录或者设备文件)<br />
-s 文件长度不为0<br />
-d 文件是个目录<br />
-b 文件是个块设备(软盘,cdrom等等)<br />
-c 文件是个字符设备(键盘,modem,声卡等等)<br />
-p 文件是个管道<br />
-h 文件是个符号链接<br />
-L 文件是个符号链接<br />
-S 文件是个socket<br />
-t 关联到一个终端设备的文件描述符<br />
这个选项一般都用来检测是否在一个给定脚本中的stdin[-t0]或[-t1]是一个终端<br />
-r 文件具有读权限(对于用户运行这个test)<br />
-w 文件具有写权限(对于用户运行这个test)<br />
-x 文件具有执行权限(对于用户运行这个test)<br />
-g set-group-id(sgid)标志到文件或目录上<br />
如果一个目录具有sgid标志,那么一个被创建在这个目录里的文件,这个目录属于创建<br />
这个目录的用户组,并不一定与创建这个文件的用户的组相同.对于workgroup的目录<br />
共享来说,这非常有用.见&lt;&gt;第58页.<br />
-u set-user-id(suid)标志到文件上<br />
如果运行一个具有root权限的文件,那么运行进程将取得root权限,即使你是一个普通<br />
用户.[1]这对于需要存取系统硬件的执行操作(比如pppd和cdrecord)非常有用.如果<br />
没有suid标志的话,那么普通用户(没有root权限)将无法运行这种程序.<br />
见&lt;&gt;第58页.<br />
-rwsr-xr-t 1 root 178236 Oct 2 2000 /usr/sbin/pppd<br />
对于设置了suid的文件,在它的权限标志中有&rdquo;s&rdquo;.<br />
-k 设置粘贴位,见&lt;&gt;第65页.<br />
对于&rdquo;sticky bit&rdquo;,save-text-mode标志是一个文件权限的特殊类型.如果设置了这<br />
个标志,那么这个文件将被保存在交换区,为了达到快速存取的目的.如果设置在目录<br />
中,它将限制写权限.对于设置了sticky bit位的文件或目录,权限标志中有&rdquo;t&rdquo;.<br />
drwxrwxrwt 7 root 1024 May 19 21:26 tmp/<br />
如果一个用户并不时具有stick bit位的目录的拥有者,但是具有写权限,那么用户只<br />
能在这个目录下删除自己所拥有的文件.这将防止用户在一个公开的目录中不慎覆盖<br />
或者删除别人的文件,比如/tmp(当然root或者是目录的所有者可以随便删除或重命名<br />
其中的文件).<br />
-O 你是文件的所有者.<br />
-G 文件的group-id和你的相同.<br />
-N 从文件最后被阅读到现在,是否被修改.</p>

<p>f1 -nt f2<br />
文件f1比f2新<br />
f1 -ot f2<br />
f1比f2老<br />
f1 -ef f2<br />
f1和f2都硬连接到同一个文件.</p>

<p>! 非&ndash;反转上边测试的结果(如果条件缺席,将返回true)</p>

<p>Example 7-4 test死的链接文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # broken-link.sh<br />
3 # Written by Lee bigelow<br />
4 # Used with permission.<br />
5<br />
6 #一个真正有用的shell脚本来找出死链接文件并且输出它们的引用<br />
7 #以便于它们可以被输入到xargs命令中进行处理 :)<br />
8 #比如: broken-link.sh /somedir /someotherdir|xargs rm<br />
9 #<br />
10 #这里,不管怎么说,是一种更好的方法<br />
11 #<br />
12 #find &ldquo;somedir&rdquo; -type l -print0|\<br />
13 #xargs -r0 file|\<br />
14 #grep &ldquo;broken symbolic&rdquo;|<br />
15 #sed -e &rsquo;s/^|: <em>broken symbolic.</em>$/&ldquo;/g&rsquo;<br />
16 #<br />
17 #但这不是一个纯粹的bash,最起码现在不是.<br />
18 #小心:小心/proc文件系统和任何的循环链接文件.<br />
19 ##############################################################<br />
20<br />
21<br />
22 #如果没对这个脚本传递参数,那么就使用当前目录.<br />
23 #否则就使用传递进来的参数作为目录来搜索.<br />
24 #<br />
25 ####################<br />
26 [ $# -eq 0 ] &amp;&amp; directorys=<code>pwd</code> || directorys=$@<br />
27<br />
28 #建立函数linkchk来检查传进来的目录或文件是否是链接和是否存在,<br />
29 #并且打印出它们的引用<br />
30 #如果传进来的目录有子目录,<br />
31 #那么把子目录也发送到linkchk函数中处理,就是递归目录.<br />
32 ##########<br />
33 linkchk () {<br />
34 for element in $1/*; do<br />
35 [ -h &ldquo;$element&rdquo; -a ! -e &ldquo;$element&rdquo; ] &amp;&amp; echo \&ldquo;$element\&rdquo;<br />
36 [ -d &ldquo;$element&rdquo; ] &amp;&amp; linkchk $element<br />
37 # Of course, &lsquo;-h&rsquo; tests for symbolic link, &lsquo;-d&rsquo; for directory.<br />
37 # 当然&rsquo;-h&rsquo;是测试链接,&lsquo;-d&rsquo;是测试目录.<br />
38 done<br />
39 }<br />
40<br />
41 #如果是个可用目录,那就把每个从脚本传递进来的参数都送到linkche函数中.<br />
42 #如果不是,那就打印出错误消息和使用信息.<br />
43 #<br />
44 ################<br />
45 for directory in $directorys; do<br />
46 if [ -d $directory ]<br />
47 then linkchk $directory<br />
48 else<br />
49 echo &ldquo;$directory is not a directory&rdquo;<br />
50 echo &ldquo;Usage: $0 dir1 dir2 &hellip;&rdquo;<br />
51 fi<br />
52 done<br />
53<br />
54 exit 0<br />
################################End
Script#########################################<br />
Example 28-1, Example 10-7, Example 10-3, Example 28-3, 和Example A-1 也会说明文件<br />
测试操作的使用过程.</p>

<p>注意事项:<br />
[1] 小心suid,可能引起安全漏洞,但是不会影响shell脚本.<br />
[2] 在当代UNIX系统中,已经不使用sticky bit了,只在目录中使用.</p>

<p>7.3 其他比较操作<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;<br />
二元比较操作符,比较变量或者比较数字.注意数字与字符串的区别.</p>

<p>整数比较</p>

<p>-eq 等于,如:if [ &ldquo;$a&rdquo; -eq &ldquo;$b&rdquo; ]<br />
-ne 不等于,如:if [ &ldquo;$a&rdquo; -ne &ldquo;$b&rdquo; ]<br />
-gt 大于,如:if [ &ldquo;$a&rdquo; -gt &ldquo;$b&rdquo; ]<br />
-ge 大于等于,如:if [ &ldquo;$a&rdquo; -ge &ldquo;$b&rdquo; ]<br />
-lt 小于,如:if [ &ldquo;$a&rdquo; -lt &ldquo;$b&rdquo; ]<br />
-le 小于等于,如:if [ &ldquo;$a&rdquo; -le &ldquo;$b&rdquo; ]<br />
&lt;= 小于等于(需要双括号),如:((&ldquo;$a&rdquo; &lt;= &ldquo;$b&rdquo;))<br />
&gt; 大于(需要双括号),如:((&ldquo;$a&rdquo; &gt; &ldquo;$b&rdquo;))<br />
&gt;= 大于等于(需要双括号),如:((&ldquo;$a&rdquo; &gt;= &ldquo;$b&rdquo;))</p>

<p>字符串比较<br />
= 等于,如:if [ &ldquo;$a&rdquo; = &ldquo;$b&rdquo; ]<br />
== 等于,如:if [ &ldquo;$a&rdquo; == &ldquo;$b&rdquo; ],与=等价<br />
注意:==的功能在[[]]和[]中的行为是不同的,如下:<br />
1 [[ $a == z* ]] # 如果$a以&rdquo;z&rdquo;开头(模式匹配)那么将为true<br />
2 [[ $a == &ldquo;z<em>&rdquo; ]] # 如果$a等于z</em>(字符匹配),那么结果为true<br />
3<br />
4 [ $a == z* ] # File globbing 和word splitting将会发生<br />
5 [ &ldquo;$a&rdquo; == &ldquo;z<em>&rdquo; ] # 如果$a等于z</em>(字符匹配),那么结果为true<br />
一点解释,关于File globbing是一种关于文件的速记法,比如&rdquo;*.c&rdquo;就是,再如~也是.<br />
但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.<br />
!= 不等于,如:if [ &ldquo;$a&rdquo; != &ldquo;$b&rdquo; ]<br />
这个操作符将在[[]]结构中使用模式匹配.<br />
if [[ &ldquo;$a&rdquo; &lt; &ldquo;$b&rdquo; ]]<br />
if [ &ldquo;$a&rdquo; &lt; &ldquo;$b&rdquo; ]<br />
注意:在[]结构中&rdquo; &gt; 大于,在ASCII字母顺序下.如:<br />
if [[ &ldquo;$a&rdquo; &gt; &ldquo;$b&rdquo; ]]<br />
if [ &ldquo;$a&rdquo; &gt; &ldquo;$b&rdquo; ]<br />
注意:在[]结构中&rdquo;&gt;&ldquo;需要被转义.<br />
具体参考Example 26-11来查看这个操作符应用的例子.<br />
-z 字符串为&rdquo;null&rdquo;.就是长度为0.<br />
-n 字符串不为&rdquo;null&rdquo;<br />
注意:<br />
使用-n在[]结构中测试必须要用&rdquo;&ldquo;把变量引起来.使用一个未被&rdquo;&ldquo;的字符串来使用! -z<br />
或者就是未用&rdquo;&ldquo;引用的字符串本身,放到[]结构中(见Example 7-6)虽然一般情况下可<br />
以工作,但这是不安全的.习惯于使用&rdquo;&ldquo;来测试字符串是一种好习惯.[1]</p>

<p>Example 7-5 数字和字符串比较<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 a=4<br />
4 b=5<br />
5<br />
6 # 这里的变量a和b既可以当作整型也可以当作是字符串.<br />
7 # 这里在算术比较和字符串比较之间有些混淆,<br />
8 #+ 因为Bash变量并不是强类型的.<br />
9<br />
10 # Bash允许对整型变量操作和比较<br />
11 #+ 当然变量中只包含数字字符.<br />
12 # 但是还是要考虑清楚再做.<br />
13<br />
14 echo<br />
15<br />
16 if [ &ldquo;$a&rdquo; -ne &ldquo;$b&rdquo; ]<br />
17 then<br />
18 echo &ldquo;$a is not equal to $b&rdquo;<br />
19 echo &ldquo;(arithmetic comparison)&rdquo;<br />
20 fi<br />
21<br />
22 echo<br />
23<br />
24 if [ &ldquo;$a&rdquo; != &ldquo;$b&rdquo; ]<br />
25 then<br />
26 echo &ldquo;$a is not equal to $b.&rdquo;<br />
27 echo &ldquo;(string comparison)&rdquo;<br />
28 # &ldquo;4&rdquo; != &ldquo;5&rdquo;<br />
29 # ASCII 52 != ASCII 53<br />
30 fi<br />
31<br />
32 # 在这个特定的例子中,&ldquo;-ne&rdquo;和&rdquo;!=&ldquo;都可以.<br />
33<br />
34 echo<br />
35<br />
36 exit 0<br />
################################End
Script#########################################</p>

<p>Example 7-6 测试字符串是否为null<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # str-test.sh: 测试null字符串和非引用字符串,<br />
3 #+ but not strings and sealing wax, not to mention cabbages and kings &hellip;<br />
4 #+ 上边这句没看懂<br />
5 # Using if [ &hellip; ]<br />
6<br />
7<br />
8 # 如果一个字符串没被初始化,那么它就没有定义的值(像这种话,总感觉像屁话)<br />
9 # 这种状态叫做&rdquo;null&rdquo;(与zero不同)<br />
10<br />
11 if [ -n $string1 ] # $string1 没被声明和初始化<br />
12 then<br />
13 echo &ldquo;String \&ldquo;string1\&rdquo; is not null.&rdquo;<br />
14 else<br />
15 echo &ldquo;String \&ldquo;string1\&rdquo; is null.&rdquo;<br />
16 fi<br />
17 # 错误的结果.<br />
18 # 显示$string1为非空,虽然他没被初始化.<br />
19<br />
20<br />
21 echo<br />
22<br />
23<br />
24 # 让我们再试一下.<br />
25<br />
26 if [ -n &ldquo;$string1&rdquo; ] # 这次$string1被引用了.<br />
27 then<br />
28 echo &ldquo;String \&ldquo;string1\&rdquo; is not null.&rdquo;<br />
29 else<br />
30 echo &ldquo;String \&ldquo;string1\&rdquo; is null.&rdquo;<br />
31 fi # &ldquo;&ldquo;的字符串在[]结构中<br />
32<br />
33<br />
34 echo<br />
35<br />
36<br />
37 if [ $string1 ] # 这次$string1变成&rdquo;裸体&rdquo;的了<br />
38 then<br />
39 echo &ldquo;String \&ldquo;string1\&rdquo; is not null.&rdquo;<br />
40 else<br />
41 echo &ldquo;String \&ldquo;string1\&rdquo; is null.&rdquo;<br />
42 fi<br />
43 # 这工作得很好.<br />
44 # 这个[]test操作检测string是否为null.<br />
45 # 然而,使用(&ldquo;$string1&rdquo;)是一种很好的习惯<br />
46 #<br />
47 # As Stephane Chazelas points out,<br />
48 # if [ $string1 ] 有1个参数 &ldquo;]&rdquo;<br />
49 # if [ &ldquo;$string1&rdquo; ] 有2个参数,空的&rdquo;$string1&rdquo;和&rdquo;]&rdquo;<br />
50<br />
51<br />
52<br />
53 echo<br />
54<br />
55<br />
56<br />
57 string1=initialized<br />
58<br />
59 if [ $string1 ] # 再来,$string1&rdquo;裸体了&rdquo;<br />
60 then<br />
61 echo &ldquo;String \&ldquo;string1\&rdquo; is not null.&rdquo;<br />
62 else<br />
63 echo &ldquo;String \&ldquo;string1\&rdquo; is null.&rdquo;<br />
64 fi<br />
65 # 再来,给出了正确的结果.<br />
66 # 不过怎么说(&ldquo;$string1&rdquo;)还是好很多,因为&hellip;<br />
67<br />
68<br />
69 string1=&ldquo;a = b&rdquo;<br />
70<br />
71 if [ $string1 ] # 再来,$string1 再次裸体了.<br />
72 then<br />
73 echo &ldquo;String \&ldquo;string1\&rdquo; is not null.&rdquo;<br />
74 else<br />
75 echo &ldquo;String \&ldquo;string1\&rdquo; is null.&rdquo;<br />
76 fi<br />
77 # 非引用的&rdquo;$string1&rdquo;现在给出了一个错误的结果!<br />
78<br />
79 exit 0<br />
80 # Thank you, also, Florian Wisser, for the &ldquo;heads-up&rdquo;.<br />
################################End
Script#########################################</p>

<p>Example 7-7 zmore<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # zmore<br />
3<br />
4 #使用&rsquo;more&rsquo;来查看gzip文件<br />
5<br />
6 NOARGS=65<br />
7 NOTFOUND=66<br />
8 NOTGZIP=67<br />
9<br />
10 if [ $# -eq 0 ] # 与 if [ -z &ldquo;$1&rdquo; ]同样的效果<br />
11 # 应该是说前边的那句注释有问题,$1是可以存在的,比如:zmore &ldquo;&rdquo; arg2 arg3<br />
12 then<br />
13 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo; &gt;&amp;2<br />
14 # 错误消息到stderr<br />
15 exit $NOARGS<br />
16 # 脚本返回65作为退出码.<br />
17 fi<br />
18<br />
19 filename=$1<br />
20<br />
21 if [ ! -f &ldquo;$filename&rdquo; ] # 将$filename &ldquo;&ldquo;起来,来允许可能的空白<br />
22 then<br />
23 echo &ldquo;File $filename not found!&rdquo; &gt;&amp;2<br />
24 # 错误消息到stderr<br />
25 exit $NOTFOUND<br />
26 fi<br />
27<br />
28 if [ ${filename##*.} != &ldquo;gz&rdquo; ]<br />
29 # 在变量替换中使用中括号<br />
30 then<br />
31 echo &ldquo;File $1 is not a gzipped file!&rdquo;<br />
32 exit $NOTGZIP<br />
33 fi<br />
34<br />
35 zcat $1 | more<br />
36<br />
37 # 使用过滤命令&rsquo;more&rsquo;<br />
38 # 如果你想的话也可使用&rsquo;less&rsquo;<br />
39<br />
40<br />
41 exit $? # 脚本将返回pipe的结果作为退出码<br />
42 # 事实上,不用非的有&rdquo;exit $?&ldquo;,但是不管怎么说,有了这句,能正规一些<br />
43 # 将最后一句命令的执行状态作为退出码返回<br />
################################End
Script#########################################</p>

<p>混合比较</p>

<p>-a 逻辑与<br />
exp1 -a exp2 如果exp1和exp2都为true的话,这个表达式将返回true</p>

<p>-o 逻辑或<br />
exp1 -o exp2 如果exp1和exp2中有一个为true的话,那么这个表达式就返回true</p>

<p>这与Bash的比较操作符&amp;&amp;和||很相像.在[[]]中使用它.<br />
1 [[ condition1 &amp;&amp; condition2 ]]<br />
-o和-a一般都是和test命令或者是[]一起工作.<br />
1 if [ &ldquo;$exp1&rdquo; -a &ldquo;$exp2&rdquo; ]</p>

<p>请参考Example 8-3,Example 26-16和Example A-28来查看混合比较操作的行为.</p>

<p>注意事项:<br />
[1] S.C.(这家伙是个人名)指出,在使用混合比较的时候即使&rdquo;$var&rdquo;也可能会产生问题.<br />
如果$string为空的话,[ -n &ldquo;$string&rdquo; -o &ldquo;$a&rdquo; = &ldquo;$b&rdquo; ]可能在某些版本的Bash中<br />
会有问题.为了附加一个额外的字符到可能的空变量中的一种安全的办法是,<br />
<a href="the &quot;x's&quot; cancel out"> &ldquo;x$string&rdquo; != x -o &ldquo;x$a&rdquo; = &ldquo;x$b&rdquo; </a>(没看懂).<br />
cancel out是抵消的意思.</p>

<p>7.4 嵌套的if/then条件test<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
可以使用if/then来进行嵌套的条件test.最终的结果和上边的使用&amp;&amp;混合比较操作是相同的.<br />
1 if [ condition1 ]<br />
2 then<br />
3 if [ condition2 ]<br />
4 then<br />
5 do-something # 这里只有在condition1和condition2都可用的时候才行.<br />
6 fi<br />
7 fi<br />
具体请查看Example 34-4.</p>

<p>7.5 检查你的test知识<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
系统范围的xinitrc文件可以用来启动X server.这个文件中包含了相当多的if/then test,<br />
就像下边的节选一样:<br />
1 if [ -f $HOME/.Xclients ]; then<br />
2 exec $HOME/.Xclients<br />
3 elif [ -f /etc/X11/xinit/Xclients ]; then<br />
4 exec /etc/X11/xinit/Xclients<br />
5 else<br />
6 # 故障保险设置,虽然我们永远都不会走到这来.<br />
7 # (我们在Xclients中也提供了相同的机制)它不会受伤的.<br />
8 xclock -geometry 100x100-5+5 &amp;<br />
9 xterm -geometry 80x50-50+150 &amp;<br />
10 if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then<br />
11 netscape /usr/share/doc/HTML/index.html &amp;<br />
12 fi<br />
13 fi</p>

<p>对上边的&rdquo;test&rdquo;结构进行解释,然后检查整个文件,/etc/X11/xinit/xinitrc,并分析if/then<br />
test结构.你可能需要查看一下后边才能讲解到的grep,sed和正则表达式的知识.</p>

<h1 id="第8章-操作符和相关的主题">第8章 操作符和相关的主题</h1>

<p>8.1 操作符<br />
-&mdash;&mdash;&mdash;</p>

<p>等号操作符</p>

<p>变量赋值</p>

<h1 id="初始化或者修改变量的值">初始化或者修改变量的值</h1>

<p>无论在算术运算还是字符串运算中,都是赋值语句.<br />
1 var=27<br />
2 category=minerals # No spaces allowed after the &ldquo;=&rdquo;.</p>

<p>注意:不要和&rdquo;=&ldquo;test操作符混淆.<br />
1 # = as a test operator<br />
2<br />
3 if [ &ldquo;$string1&rdquo; = &ldquo;$string2&rdquo; ]<br />
4 # if [ &ldquo;X$string1&rdquo; = &ldquo;X$string2&rdquo; ] is safer,<br />
5 # to prevent an error message should one of the variables be empty.<br />
6 # (The prepended &ldquo;X&rdquo; characters cancel out.)<br />
7 then<br />
8 command<br />
9 fi</p>

<p>算术操作符</p>

<p>+ 加法<br />
- 减法<br />
* 乘法<br />
/ 除法<br />
** 幂运算<br />
1 # Bash, version 2.02, introduced the &ldquo;<strong>&rdquo; exponentiation operator.<br />
2<br />
3 let &ldquo;z=5</strong>3&rdquo;<br />
4 echo &ldquo;z = $z&rdquo; # z = 125<br />
% 取模<br />
bash$ expr 5 % 3<br />
2</p>

<p><sup>5</sup>&frasl;<sub>3</sub>=1余2<br />
模运算经常用在其它的事情中,比如产生特定的范围的数字(Example 9-24,<br />
Example 9-27)和格式化程序的输出(Example 26-15,Example A-6).它甚至可以用来<br />
产生质数,(Example A-16).事实上取模运算在算术运算中使用的频率惊人的高.</p>

<p>Example 8-1 最大公约数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # gcd.sh: 最大公约数<br />
3 # 使用Euclid&rsquo;s 算法<br />
4<br />
5 # 最大公约数,就是2个数能够同时整除的最大的数.<br />
6 #<br />
7<br />
8 # Euclid&rsquo;s算法采用连续除法.<br />
9 # 在每个循环中<br />
10 #+ 被除数 11 #+ 除数 12 #+ 直到余数= 0.<br />
13 #+ 在最后的循环中The gcd = 被除数<br />
14 #<br />
15 # 关于这个算法更精彩的讨论<br />
16 # 见Jim Loy&rsquo;s site, <a href="http://www.jimloy.com/number/euclids.htm">http://www.jimloy.com/number/euclids.htm</a>.<br />
17<br />
18<br />
19 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
20 # 参数检查<br />
21 ARGS=2<br />
22 E_BADARGS=65<br />
23<br />
24 if [ $# -ne &ldquo;$ARGS&rdquo; ]<br />
25 then<br />
26 echo &ldquo;Usage: <code>basename $0</code> first-number second-number&rdquo;<br />
27 exit $E_BADARGS<br />
28 fi<br />
29 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
30<br />
31<br />
32 gcd ()<br />
33 {<br />
34<br />
35 dividend=$1 # 随便给值<br />
36 divisor=$2 #+ 即使$2大,也没关系.<br />
37 # Why not?<br />
38<br />
39 remainder=1 # 如果再循环中使用为初始化的变量.<br />
40 #+ 那将在第一次循环中产生一个错误消息.<br />
41<br />
42<br />
43 until [ &ldquo;$remainder&rdquo; -eq 0 ]<br />
44 do<br />
45 let &ldquo;remainder = $dividend % $divisor&rdquo;<br />
46 dividend=$divisor # 现在使用2个最小的数重复.<br />
47 divisor=$remainder<br />
48 done # Euclid&rsquo;s algorithm<br />
49<br />
50 } # Last $dividend is the gcd.<br />
50 } # 最后的$dividend就是gcd.<br />
51<br />
52<br />
53 gcd $1 $2<br />
54<br />
55 echo; echo &ldquo;GCD of $1 and $2 = $dividend&rdquo;; echo<br />
56<br />
57<br />
58 # 练习:<br />
59 # &mdash;&mdash;&ndash;<br />
60 # 检查命令行参数来确定它们都是整数,<br />
61 #+ and exit the script with an appropriate error message if not.<br />
61 #+ 否则就选择合适的错误消息退出.<br />
62<br />
63 exit 0<br />
################################End
Script#########################################</p>

<p>+= 加等于(通过常量增加变量)<br />
let &ldquo;var += 5&rdquo; #var将在本身值的基础上增加5<br />
-= 减等于<br />
*= 乘等于<br />
let &ldquo;var *= 4&rdquo;<br />
/= 除等于<br />
%= 取模赋值,算术操作经常使用expr或者let表达式.</p>

<p>Example 8-2 使用算术操作符<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # Counting to 11 in 10 different ways.<br />
3<br />
4 n=1; echo -n &ldquo;$n &rdquo;<br />
5<br />
6 let &ldquo;n = $n + 1&rdquo; # let &ldquo;n = n + 1&rdquo; 这么写也行<br />
7 echo -n &ldquo;$n &rdquo;<br />
8<br />
9<br />
10 : $((n = $n + 1))<br />
11 # &ldquo;:&rdquo; 是必须的,这是因为,如果没有&rdquo;:&ldquo;的话,Bash将<br />
12 #+ 尝试把&rdquo;$((n = $n + 1))&ldquo;解释成一个命令<br />
13 echo -n &ldquo;$n &rdquo;<br />
14<br />
15 (( n = n + 1 ))<br />
16 # 对于上边的方法的一个更简单的选则.<br />
17 # Thanks, David Lombard, for pointing this out.<br />
18 echo -n &ldquo;$n &rdquo;<br />
19<br />
20 n=$(($n + 1))<br />
21 echo -n &ldquo;$n &rdquo;<br />
22<br />
23 : $[ n = $n + 1 ]<br />
24 # &ldquo;:&rdquo; 是必须的,这是因为,如果没有&rdquo;:&ldquo;的话,Bash将<br />
25 #+ 尝试把&rdquo;$[ n = $n + 1 ]&rdquo; 解释成一个命令<br />
26 # 即使&rdquo;n&rdquo;被初始化成为一个字符串,这句也能工作.<br />
27 echo -n &ldquo;$n &rdquo;<br />
28<br />
29 n=$[ $n + 1 ]<br />
30 # 即使&rdquo;n&rdquo;被初始化成为一个字符串,这句也能工作.<br />
31 #* Avoid this type of construct, since it is obsolete and nonportable.<br />
31 #* 尽量避免这种类型的结果,因为这已经被废弃了,并且不具可移植性.<br />
32 # Thanks, Stephane Chazelas.<br />
33 echo -n &ldquo;$n &rdquo;<br />
34<br />
35 # 现在来个C风格的增量操作.<br />
36 # Thanks, Frank Wang, for pointing this out.<br />
37<br />
38 let &ldquo;n++&rdquo; # let &ldquo;++n&rdquo; also works.<br />
39 echo -n &ldquo;$n &rdquo;<br />
40<br />
41 (( n++ )) # (( ++n ) also works.<br />
42 echo -n &ldquo;$n &rdquo;<br />
43<br />
44 : $(( n++ )) # : $(( ++n )) also works.<br />
45 echo -n &ldquo;$n &rdquo;<br />
46<br />
47 : $[ n++ ] # : $[ ++n ]] also works<br />
48 echo -n &ldquo;$n &rdquo;<br />
49<br />
50 echo<br />
51<br />
52 exit 0<br />
################################End
Script#########################################</p>

<p>注意:在Bash中的整型变量事实上是32位的,范围是 -2147483648 到2147483647.如果超过这个<br />
范围进行算术操作,将不会得到你期望的结果(就是溢出么).<br />
1 a=2147483646<br />
2 echo &ldquo;a = $a&rdquo; # a = 2147483646<br />
3 let &ldquo;a+=1&rdquo; # 加1 &ldquo;a&rdquo;.<br />
4 echo &ldquo;a = $a&rdquo; # a = 2147483647<br />
5 let &ldquo;a+=1&rdquo; # 再加1 &ldquo;a&rdquo; ,将超过上限了.<br />
6 echo &ldquo;a = $a&rdquo; # a = -2147483648<br />
7 # 错误 (溢出了)<br />
在Bash 2.05b版本中,Bash支持64位整型了.</p>

<p>注意:Bash并不能理解浮点运算.它把包含的小数点看作字符串.<br />
1 a=1.5<br />
2<br />
3 let &ldquo;b = $a + 1.3&rdquo; # 错误.<br />
4 # t2.sh: let: b = 1.5 + 1.3: 表达式的语义错误(错误标志为&rdquo;.5 + 1.3&rdquo;)<br />
5<br />
6 echo &ldquo;b = $b&rdquo; # b=1<br />
如果真想做浮点运算的话,使用bc(见12.8节),bc可以进行浮点运算或调用数学库函数.</p>

<p>位操作符.<br />
(晕,有点强大过分了吧,位级操作都支持.)<br />
位操作符在shell脚本中极少使用.它们最主要的用途看起来就是操作和test从sockets中<br />
读出的变量.&ldquo;Bit flipping&rdquo;与编译语言的联系很紧密,比如c/c++,在这种语言中它可以<br />
运行得足够快.(原文有处on the fly,我查了一下,好像是没事干的意思,没理解)</p>

<p>&lt;</p>

<p>&lt;&lt;= 左移几位,=号后边将给出左移几位<br />
let &ldquo;var &lt;&lt;= 2&rdquo;就是左移2位(就是乘4)</p>

<blockquote>
<blockquote>
<p>右移1位(每次右移都将除2)</p>

<p>= 右移几位</p>
</blockquote>
</blockquote>

<p>&amp; 按位与</p>

<p>&amp;= 按位与赋值</p>

<p>| 按位或</p>

<p>|= 按位或赋值</p>

<p>~ 按位非</p>

<p>! 按位否?(没理解和上边的~有什么区别?),感觉是应该放到下边的逻辑操作中</p>

<p>^ 按位异或XOR</p>

<p>^= 异或赋值</p>

<p>逻辑操作:</p>

<p>&amp;&amp; 逻辑与<br />
1 if [ $condition1 ] &amp;&amp; [ $condition2 ]<br />
2 # 与: if [ $condition1 -a $condition2 ] 相同<br />
3 # 如果condition1和condition2都为true,那结果就为true.<br />
4<br />
5 if [[ $condition1 &amp;&amp; $condition2 ]] # 也可以.<br />
6 # 注意&amp;&amp;不允许出现在[ &hellip; ]中.<br />
注意:&amp;&amp;也可以用在and list中(见25章),但是使用的时候需要依赖上下文.</p>

<p>|| 逻辑或<br />
1 if [ $condition1 ] || [ $condition2 ]<br />
2 # 与: if [ $condition1 -o $condition2 ] 相同<br />
3 # 如果condition1或condition2为true,那结果就为true.<br />
4<br />
5 if [[ $condition1 || $condition2 ]] # 也可以<br />
6 # 注意||不允许出现在[ &hellip; ]中.<br />
注意:Bash将test每个连接到逻辑操作的状态的退出状态(见第6章).</p>

<p>Example 8-3 使用&amp;&amp;和||进行混合状态的test<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 a=24<br />
4 b=47<br />
5<br />
6 if [ &ldquo;$a&rdquo; -eq 24 ] &amp;&amp; [ &ldquo;$b&rdquo; -eq 47 ]<br />
7 then<br />
8 echo &ldquo;Test #1 succeeds.&rdquo;<br />
9 else<br />
10 echo &ldquo;Test #1 fails.&rdquo;<br />
11 fi<br />
12<br />
13 # 错误: if [ &ldquo;$a&rdquo; -eq 24 &amp;&amp; &ldquo;$b&rdquo; -eq 47 ]<br />
14 #+ 尝试执行&rsquo; [ &ldquo;$a&rdquo; -eq 24 &lsquo;<br />
15 #+ 因为没找到&rsquo;]&lsquo;所以失败了.<br />
16 #<br />
17 # 注意: 如果 [[ $a -eq 24 &amp;&amp; $b -eq 24 ]] 能够工作.<br />
18 # 那这个[[]]的test结构就比[]结构更灵活了.<br />
19 #<br />
20 # (在17行的&rdquo;&amp;&amp;&ldquo;与第6行的&rdquo;&amp;&amp;&ldquo;意义不同)<br />
21 # Thanks, Stephane Chazelas, for pointing this out.<br />
22<br />
23<br />
24 if [ &ldquo;$a&rdquo; -eq 98 ] || [ &ldquo;$b&rdquo; -eq 47 ]<br />
25 then<br />
26 echo &ldquo;Test #2 succeeds.&rdquo;<br />
27 else<br />
28 echo &ldquo;Test #2 fails.&rdquo;<br />
29 fi<br />
30<br />
31<br />
32 # -a和-o选项提供了<br />
33 #+ 一种可选的混合test方法.<br />
34 # Thanks to Patrick Callahan for pointing this out.<br />
35<br />
36<br />
37 if [ &ldquo;$a&rdquo; -eq 24 -a &ldquo;$b&rdquo; -eq 47 ]<br />
38 then<br />
39 echo &ldquo;Test #3 succeeds.&rdquo;<br />
40 else<br />
41 echo &ldquo;Test #3 fails.&rdquo;<br />
42 fi<br />
43<br />
44<br />
45 if [ &ldquo;$a&rdquo; -eq 98 -o &ldquo;$b&rdquo; -eq 47 ]<br />
46 then<br />
47 echo &ldquo;Test #4 succeeds.&rdquo;<br />
48 else<br />
49 echo &ldquo;Test #4 fails.&rdquo;<br />
50 fi<br />
51<br />
52<br />
53 a=rhino<br />
54 b=crocodile<br />
55 if [ &ldquo;$a&rdquo; = rhino ] &amp;&amp; [ &ldquo;$b&rdquo; = crocodile ]<br />
56 then<br />
57 echo &ldquo;Test #5 succeeds.&rdquo;<br />
58 else<br />
59 echo &ldquo;Test #5 fails.&rdquo;<br />
60 fi<br />
61<br />
62 exit 0<br />
################################End
Script#########################################<br />
&amp;&amp;和||操作也能在算术运算的上下文中找到.<br />
bash$ echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))<br />
1 0 1 0</p>

<p>混杂操作:<br />
, 逗号操作符<br />
逗号操作符可以连接2个或多个算术运算.所有的操作都会被执行,但是只有最后一个<br />
操作作为结果.<br />
1 let &ldquo;t1 = ((5 + 3, 7 - 1, 15 - 4))&rdquo;<br />
2 echo &ldquo;t1 = $t1&rdquo; # t1 = 11<br />
3<br />
4 let &ldquo;t2 = ((a = 9, 15 / 3))&rdquo; # Set &ldquo;a&rdquo; and calculate &ldquo;t2&rdquo;.<br />
5 echo &ldquo;t2 = $t2 a = $a&rdquo; # t2 = 5 a = 9<br />
&rdquo;,&ldquo;主要用在for循环中,具体见Example 10-12.</p>

<p>8.2 数字常量<br />
-&mdash;&mdash;&mdash;&ndash;<br />
shell脚本默认都是将数字作为10进制数处理,除非这个数字某种特殊的标记法或前缀开头.<br />
以0开头就是8进制.以0x开头就是16进制数.使用BASE#NUMBER这种形式可以表示其它进制<br />
表示法</p>

<p>Example 8-4 数字常量的处理<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # numbers.sh: 数字常量的几种不同的表示法<br />
3<br />
4 # 10进制: 默认<br />
5 let &ldquo;dec = 32&rdquo;<br />
6 echo &ldquo;decimal number = $dec&rdquo; # 32<br />
7 # 一切都很正常<br />
8<br />
9<br />
10 # 8进制: 以&rsquo;0&rsquo;(零)开头<br />
11 let &ldquo;oct = 032&rdquo;<br />
12 echo &ldquo;octal number = $oct&rdquo; # 26<br />
13 # 表达式的结果用10进制表示.<br />
14 #<br />
15<br />
16 # 16进制表示:数字以&rsquo;0x&rsquo;或者&rsquo;0X&rsquo;开头<br />
17 let &ldquo;hex = 0x32&rdquo;<br />
18 echo &ldquo;hexadecimal number = $hex&rdquo; # 50<br />
19 # 表达式的结果用10进制表示.<br />
20<br />
21 # 其它进制: BASE#NUMBER<br />
22 # BASE between 2 and 64.<br />
22 # 2到64进制都可以.<br />
23 # NUMBER必须在BASE的范围内,具体见下边.<br />
24<br />
25<br />
26 let &ldquo;bin = 2#111100111001101&rdquo;<br />
27 echo &ldquo;binary number = $bin&rdquo; # 31181<br />
28<br />
29 let &ldquo;b32 = 32#77&rdquo;<br />
30 echo &ldquo;base-32 number = $b32&rdquo; # 231<br />
31<br />
32 let &ldquo;b64 = 64#@_&rdquo;<br />
33 echo &ldquo;base-64 number = $b64&rdquo; # 4031<br />
34 # 这种64进制的表示法中的每位数字都必须在64进制表示法的限制字符内.<br />
35 # 10 个数字+ 26 个小写字母+ 26 个大写字母+ @ + _<br />
36<br />
37<br />
38 echo<br />
39<br />
40 echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))<br />
41 # 1295 170 44822 3375<br />
42<br />
43<br />
44 # 重要的注意事项:<br />
45 # &mdash;&mdash;&mdash;&mdash;&mdash;<br />
46 # 如果使用的每位数字超出了这个进制表示法规定字符的范围的话,<br />
47 #+ 将给出一个错误消息.<br />
48<br />
49 let &ldquo;bad_oct = 081&rdquo;<br />
50 # (部分的) 错误消息输出:<br />
51 # bad_oct = 081: too great for base (error token is &ldquo;081&rdquo;)<br />
52 # Octal numbers use only digits in the range 0 - 7.<br />
53<br />
54 exit 0 # Thanks, Rich Bartell and Stephane Chazelas, for clarification.<br />
################################End
Script#########################################</p>

<p>第三部分 超越基本<br />
++++++++++++++++++++</p>

<h1 id="第9章-变量重游">第9章 变量重游</h1>

<p>如果变量使用恰当,将会增加脚本的能量和灵活性.但是前提是这需要仔细学习变量的细节知识.</p>

<p>9.1 内部变量<br />
-&mdash;&mdash;&mdash;&ndash;<br />
Builtin variable<br />
这些内建的变量,将影响bash脚本的行为.</p>

<p>$BASH<br />
这个变量将指向Bash的二进制执行文件的位置.<br />
bash$ echo $BASH<br />
/bin/bash</p>

<p>$BASH_ENV<br />
这个环境变量将指向一个Bash启动文件,这个启动文件将在调用一个脚本时被读取.</p>

<p>$BASH_SUBSHELL<br />
这个变量将提醒subshell的层次,这是一个在version3才被添加到Bash中的新特性.<br />
见Example 20-1.</p>

<p>$BASH_VERSINFO[n]<br />
记录Bash安装信息的一个6元素的数组.与下边的$BASH_VERSION很像,但这个更加详细.<br />
1 # Bash version info:<br />
2<br />
3 for n in 0 1 2 3 4 5<br />
4 do<br />
5 echo &ldquo;BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}&rdquo;<br />
6 done<br />
7<br />
8 # BASH_VERSINFO[0] = 3 # 主版本号<br />
9 # BASH_VERSINFO[1] = 00 # 次版本号<br />
10 # BASH_VERSINFO[2] = 14 # Patch 次数.<br />
11 # BASH_VERSINFO[3] = 1 # Build version.<br />
12 # BASH_VERSINFO[4] = release # Release status.<br />
13 # BASH_VERSINFO[5] = i386-redhat-linux-gnu # Architecture</p>

<p>$BASH_VERSION<br />
安装在系统上的Bash的版本号.<br />
bash$ echo $BASH_VERSION<br />
3.00.14(1)-release<br />
tcsh% echo $BASH_VERSION<br />
BASH_VERSION: Undefined variable.<br />
使用这个变量对于判断系统上到底运行的是那个shll来说是一种非常好的办法.$SHELL<br />
有时将不能给出正确的答案.</p>

<p>$DIRSTACK<br />
在目录栈中最上边的值(将受到pushd和popd的影响).<br />
这个内建的变量与dirs命令是保持一致的,但是dirs命令将显示目录栈的整个内容.</p>

<p>$EDITOR<br />
脚本调用的默认编辑器,一般是vi或者是emacs.</p>

<p>$EUID<br />
&ldquo;effective&rdquo;用户ID号.<br />
当前用户被假定的任何id号.可能在su命令中使用.<br />
注意:$EUID并不一定与$UID相同.</p>

<p>$FUNCNAME<br />
当前函数的名字.<br />
1 xyz23 ()<br />
2 {<br />
3 echo &ldquo;$FUNCNAME now executing.&rdquo; # xyz23 现在正在被执行.<br />
4 }<br />
5<br />
6 xyz23<br />
7<br />
8 echo &ldquo;FUNCNAME = $FUNCNAME&rdquo; # FUNCNAME =<br />
9 # 出了函数就变为Null值了.</p>

<p>$GLOBIGNORE<br />
一个文件名的模式匹配列表,如果在file globbing中匹配到的文件包含这个列表中的<br />
某个文件,那么这个文件将被从匹配到的文件中去掉.</p>

<p>$GROUPS<br />
当前用户属于的组.<br />
这是一个当前用户的组id列表(数组),就像在/etc/passwd中记录的一样.<br />
root# echo $GROUPS<br />
0</p>

<p>root# echo ${GROUPS[1]}<br />
1</p>

<p>root# echo ${GROUPS[5]}<br />
6</p>

<p>$HOME<br />
用户的home目录,一般都是/home/username(见Example 9-14)</p>

<p>$HOSTNAME<br />
hostname命令将在一个init脚本中,在启动的时候分配一个系统名字.<br />
gethostname()函数将用来设置这个$HOSTNAME内部变量.(见Example 9-14)</p>

<p>$HOSTTYPE<br />
主机类型<br />
就像$MACHTYPE,识别系统的硬件.<br />
bash$ echo $HOSTTYPE<br />
i686</p>

<p>$IFS<br />
内部域分隔符.<br />
这个变量用来决定Bash在解释字符串时如何识别域,或者单词边界.<br />
$IFS默认为空白(空格,tab,和新行),但可以修改,比如在分析逗号分隔的数据文件时.<br />
注意:$*使用$IFS中的第一个字符,具体见Example 5-1.<br />
bash$ echo $IFS | cat -vte<br />
$</p>

<p>bash$ bash -c &lsquo;set w x y z; IFS=&rdquo;:-;&ldquo;; echo &ldquo;$*&ldquo;&rsquo;<br />
w:x:y:o</p>

<p>注意:$IFS并不像它处理其它字符一样处理空白.</p>

<p>Example 9-1 $IFS和空白<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # $IFS 处理空白的方法,与处理其它字符不同.<br />
3<br />
4 output_args_one_per_line()<br />
5 {<br />
6 for arg<br />
7 do echo &ldquo;[$arg]&rdquo;<br />
8 done<br />
9 }<br />
10<br />
11 echo; echo &ldquo;IFS=\&rdquo; \&ldquo;&rdquo;<br />
12 echo &ldquo;&mdash;&mdash;-&rdquo;<br />
13<br />
14 IFS=&rdquo; &ldquo;<br />
15 var=&rdquo; a b c &ldquo;<br />
16 output_args_one_per_line $var # output_args_one_per_line <code>echo &quot; a b c &quot;</code><br />
17 #<br />
18 # [a]<br />
19 # [b]<br />
20 # [c]<br />
21<br />
22<br />
23 echo; echo &ldquo;IFS=:&rdquo;<br />
24 echo &ldquo;&mdash;&ndash;&rdquo;<br />
25<br />
26 IFS=:<br />
27 var=&rdquo;:a::b:c:::&rdquo; # 与上边的一样,但是用&rdquo; &ldquo;替换了&rdquo;:&rdquo;<br />
28 output_args_one_per_line $var<br />
29 #<br />
30 # []<br />
31 # [a]<br />
32 # []<br />
33 # [b]<br />
34 # [c]<br />
35 # []<br />
36 # []<br />
37 # []<br />
38<br />
39 # 同样的事情也会发生在awk中的&rdquo;FS&rdquo;域分隔符.<br />
40<br />
41 # Thank you, Stephane Chazelas.<br />
42<br />
43 echo<br />
44<br />
45 exit 0<br />
################################End
Script#########################################<br />
Example 12-37也是使用$IFS的另一个启发性的例子.</p>

<p>$IGNOREEOF<br />
忽略EOF: 告诉shell在log out之前要忽略多少文件结束符(control-D).</p>

<p>$LC_COLLATE<br />
常在.bashrc或/etc/profile中设置,这个变量用来在文件名扩展和模式匹配校对顺序.<br />
如果$LC_COLLATE被错误的设置,那么将会在filename globbing中引起错误的结果.</p>

<p>注意:在2.05以后的Bash版本中,filename globbing将不在对[]中的字符区分大小写.<br />
比如:ls [A-M]* 将即匹配File1.txt也会匹配file1.txt.为了恢复[]的习惯用法,<br />
设置$LC_COLLATE的值为c,使用export LC_COLLATE=c 在/etc/profile或者是<br />
~/.bashrc中.</p>

<p>$LC_CTYPE<br />
这个内部变量用来控制globbing和模式匹配的字符串解释.</p>

<p>$LINENO<br />
这个变量记录它所在的shell脚本中它所在行的行号.这个变量一般用于调试目的.<br />
1 # *** BEGIN DEBUG BLOCK ***<br />
2 last_cmd<em>arg=$</em> # Save it.<br />
3<br />
4 echo &ldquo;At line number $LINENO, variable \&ldquo;v1\&rdquo; = $v1&rdquo;<br />
5 echo &ldquo;Last command argument processed = $last_cmd_arg&rdquo;<br />
6 # *** END DEBUG BLOCK ***</p>

<p>$MACHTYPE<br />
系统类型<br />
提示系统硬件<br />
bash$ echo $MACHTYPE<br />
i686</p>

<p>$OLDPWD<br />
老的工作目录(&ldquo;OLD-print-working-directory&rdquo;,你所在的之前的目录)</p>

<p>$OSTYPE<br />
操作系统类型.<br />
bash$ echo $OSTYPE<br />
linux</p>

<p>$PATH<br />
指向Bash外部命令所在的位置,一般为/usr/bin,/usr/X11R6/bin,/usr/local/bin等.<br />
当给出一个命令时,Bash将自动对$PATH中的目录做一张hash表.$PATH中以&rdquo;:&ldquo;分隔的<br />
目录列表将被存储在环境变量中.一般的,系统存储的$PATH定义在/ect/processed或<br />
~/.bashrc中(见Appendix G).</p>

<p>bash$ echo $PATH<br />
/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</p>

<p>PATH=${PATH}:/opt/bin将把/opt/bin目录附加到$PATH变量中.在脚本中,这是一个<br />
添加目录到$PATH中的便捷方法.这样在这个脚本退出的时候,$PATH将会恢复(因为这个<br />
shell是个子进程,像这样的一个脚本是不会将它的父进程的环境变量修改的)</p>

<p>注意:当前的工作目录&rdquo;./&ldquo;一般都在$PATH中被省去.</p>

<p>$PIPESTATUS<br />
数组变量将保存最后一个运行的前台管道的退出码.有趣的是,这个退出码和最后一个命令<br />
运行的退出码并不一定相同.<br />
bash$ echo $PIPESTATUS<br />
0</p>

<p>bash$ ls -al | bogus_command<br />
bash: bogus_command: command not found<br />
bash$ echo $PIPESTATUS<br />
141</p>

<p>bash$ ls -al | bogus_command<br />
bash: bogus_command: command not found<br />
bash$ echo $?<br />
127</p>

<p>$PIPESTATUS数组的每个成员都会保存一个管道命令的退出码,$PIPESTATUS[0]保存第<br />
一个管道命令的退出码,$PIPESTATUS[1]保存第2个,以此类推.</p>

<p>注意:$PIPESTATUS变量在一个login shell中可能会包含一个错误的0值(3.0以下版本)<br />
tcsh% bash</p>

<p>bash$ who | grep nobody | sort<br />
bash$ echo ${PIPESTATUS[*]}<br />
0<br />
包含在脚本中的上边这行将会产生一个期望的输出0 1 0.</p>

<p>注意:在某些上下文$PIPESTATUS可能不会给出正确的结果.<br />
bash$ echo $BASH_VERSION<br />
3.00.14(1)-release</p>

<p>bash$ $ ls | bogus_command | wc<br />
bash: bogus_command: command not found<br />
0 0 0</p>

<p>bash$ echo ${PIPESTATUS[@]}<br />
141 127 0</p>

<p>Chet Ramey把上边输出不成确原因归咎于ls的行为.因为如果把ls的结果放到管道上,<br />
并且这个输出没被读取,那么SIGPIPE将会kill掉它,并且退出码变为141,而不是我们期<br />
望的0.这种情况也会发生在tr命令中.</p>

<p>注意:$PIPESTATUS是一个&rdquo;volatile&rdquo;变量.在任何命令插入之前,并且在pipe询问之后,<br />
这个变量需要立即被捕捉.<br />
bash$ $ ls | bogus_command | wc<br />
bash: bogus_command: command not found<br />
0 0 0</p>

<p>bash$ echo ${PIPESTATUS[@]}<br />
0 127 0</p>

<p>bash$ echo ${PIPESTATUS[@]}<br />
0</p>

<p>$PPID<br />
一个进程的$PPID就是它的父进程的进程id(pid).[1]<br />
使用pidof命令对比一下.</p>

<p>$PROMPT_COMMAND<br />
这个变量保存一个在主提示符($PS1)显示之前需要执行的命令.</p>

<p>$PS1<br />
主提示符,具体见命令行上的显示.</p>

<p>$PS2<br />
第2提示符,当你需要额外的输入的时候将会显示,默认为&rdquo;&gt;&ldquo;.</p>

<p>$PS3<br />
第3提示符,在一个select循环中显示(见Example 10-29).</p>

<p>$PS4<br />
第4提示符,当使用-x选项调用脚本时,这个提示符将出现在每行的输出前边.<br />
默认为&rdquo;+&ldquo;.</p>

<p>$PWD<br />
工作目录(你当前所在的目录).<br />
与pwd内建命令作用相同.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 E_WRONG_DIRECTORY=73<br />
4<br />
5 clear # 清屏.<br />
6<br />
7 TargetDirectory=/home/bozo/projects/GreatAmericanNovel<br />
8<br />
9 cd $TargetDirectory<br />
10 echo &ldquo;Deleting stale files in $TargetDirectory.&rdquo;<br />
11<br />
12 if [ &ldquo;$PWD&rdquo; != &ldquo;$TargetDirectory&rdquo; ]<br />
13 then # 防止偶然删除错误的目录<br />
14 echo &ldquo;Wrong directory!&rdquo;<br />
15 echo &ldquo;In $PWD, rather than $TargetDirectory!&rdquo;<br />
16 echo &ldquo;Bailing out!&rdquo;<br />
17 exit $E_WRONG_DIRECTORY<br />
18 fi<br />
19<br />
20 rm -rf *<br />
21 rm .[A-Za-z0-9]* # Delete dotfiles.<br />
21 rm .[A-Za-z0-9]* # 删除&rdquo;.&ldquo;文件(隐含文件).<br />
22 # rm -f .[^.]* ..?* 为了删除以多个&rdquo;.&ldquo;开头的文件.<br />
23 # (shopt -s dotglob; rm -f *) 也行.<br />
24 # Thanks, S.C. for pointing this out.<br />
25<br />
26 # 文件名能够包含0-255范围的所有字符,除了&rdquo;/&ldquo;.<br />
27 # 删除以各种诡异字符开头的文件将作为一个练习留给大家.<br />
28<br />
29 # 这里预留给其他的必要操作.<br />
30<br />
31 echo<br />
32 echo &ldquo;Done.&rdquo;<br />
33 echo &ldquo;Old files deleted in $TargetDirectory.&rdquo;<br />
34 echo<br />
35<br />
36<br />
37 exit 0<br />
################################End
Script#########################################</p>

<p>$REPLY<br />
read命令如果没有给变量,那么输入将保存在$REPLY中.在select菜单中也可用,但是只<br />
提供选择的变量的项数,而不是变量本身的值.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # reply.sh<br />
3<br />
4 # REPLY是&rsquo;read&rsquo;命令结果保存的默认变量.<br />
5<br />
6 echo<br />
7 echo -n &ldquo;What is your favorite vegetable? &rdquo;<br />
8 read<br />
9<br />
10 echo &ldquo;Your favorite vegetable is $REPLY.&rdquo;<br />
11 # 当且仅当在没有变量提供给&rdquo;read&rdquo;命令时,<br />
12 #+ REPLY才保存最后一个&rdquo;read&rdquo;命令读入的值.<br />
13<br />
14 echo<br />
15 echo -n &ldquo;What is your favorite fruit? &rdquo;<br />
16 read fruit<br />
17 echo &ldquo;Your favorite fruit is $fruit.&rdquo;<br />
18 echo &ldquo;but&hellip;&rdquo;<br />
19 echo &ldquo;Value of \$REPLY is still $REPLY.&rdquo;<br />
20 # $REPLY还是保存着上一个read命令的值,<br />
21 #+ 因为变量$fruit被传入到了这个新的&rdquo;read&rdquo;命令中.<br />
22<br />
23 echo<br />
24<br />
25 exit 0<br />
################################End
Script#########################################</p>

<p>$SECONDS<br />
这个脚本已经运行的时间(单位为秒).<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 TIME_LIMIT=10<br />
4 INTERVAL=1<br />
5<br />
6 echo<br />
7 echo &ldquo;Hit Control-C to exit before $TIME_LIMIT seconds.&rdquo;<br />
8 echo<br />
9<br />
10 while [ &ldquo;$SECONDS&rdquo; -le &ldquo;$TIME_LIMIT&rdquo; ]<br />
11 do<br />
12 if [ &ldquo;$SECONDS&rdquo; -eq 1 ]<br />
13 then<br />
14 units=second<br />
15 else<br />
16 units=seconds<br />
17 fi<br />
18<br />
19 echo &ldquo;This script has been running $SECONDS $units.&rdquo;<br />
20 # 在一台比较慢的或者是负载很大的机器上,这个脚本可能会跳过几次循环<br />
21 #+ 在一个while循环中.<br />
22 sleep $INTERVAL<br />
23 done<br />
24<br />
25 echo -e &ldquo;\a&rdquo; # Beep!<br />
26<br />
27 exit 0<br />
################################End
Script#########################################</p>

<p>$SHELLOPTS<br />
这个变量里保存shell允许的选项,这个变量是只读的.<br />
bash$ echo $SHELLOPTS<br />
braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</p>

<p>$SHLVL<br />
Shell层次,就是shell层叠的层次,如果是命令行那$SHLVL就是1,如果命令行执行的脚<br />
本中,$SHLVL就是2,以此类推.</p>

<p>$TMOUT<br />
如果$TMOUT环境变量被设置为一个非零的时间值,那么在过了这个指定的时间之后,<br />
shell提示符将会超时,这会引起一个logout.</p>

<p>在2.05b版本的Bash中,已经支持在一个带有read命令的脚本中使用$TMOUT变量.<br />
1 # 需要使用Bash v2.05b或者以后的版本上<br />
2<br />
3 TMOUT=3 # Prompt times out at three seconds.<br />
3 TMOUT=3 # 设置超时的时间为3秒<br />
4<br />
5 echo &ldquo;What is your favorite song?&rdquo;<br />
6 echo &ldquo;Quickly now, you only have $TMOUT seconds to answer!&rdquo;<br />
7 read song<br />
8<br />
9 if [ -z &ldquo;$song&rdquo; ]<br />
10 then<br />
11 song=&ldquo;(no answer)&rdquo;<br />
12 # 默认响应.<br />
13 fi<br />
14<br />
15 echo &ldquo;Your favorite song is $song.&rdquo;</p>

<p>这里有一个更复杂的方法来在一个脚本中实现超时功能.一种办法就是建立一个时间循<br />
环,在超时的时候通知脚本.不过,这也需要一个信号处理机制,在超时的时候来产生中<br />
断.<br />
(参见Example 29-5)</p>

<p>Example 9-2 时间输入<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # timed-input.sh<br />
3<br />
4 # TMOUT=3 在新版本的Bash上也能工作.<br />
5<br />
6<br />
7 TIMELIMIT=3 # 在这个例子上是3秒,也可以设其他的值.<br />
8<br />
9 PrintAnswer()<br />
10 {<br />
11 if [ &ldquo;$answer&rdquo; = TIMEOUT ]<br />
12 then<br />
13 echo $answer<br />
14 else # 别想混合着两个例子.<br />
15 echo &ldquo;Your favorite veggie is $answer&rdquo;<br />
16 kill $! # kill将不再需要TimerOn函数运行在后台.<br />
17 # $! 是运行在后台的最后一个工作的PID.<br />
18 fi<br />
19<br />
20 }<br />
21<br />
22<br />
23<br />
24 TimerOn()<br />
25 {<br />
26 sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;<br />
27 # 等待3秒,然后发送一个信号给脚本.<br />
28 }<br />
29<br />
30 Int14Vector()<br />
31 {<br />
32 answer=&ldquo;TIMEOUT&rdquo;<br />
33 PrintAnswer<br />
34 exit 14<br />
35 }<br />
36<br />
37 trap Int14Vector 14 # 为了我们的目的,时间中断(14)被破坏了.<br />
38<br />
39 echo &ldquo;What is your favorite vegetable &rdquo;<br />
40 TimerOn<br />
41 read answer<br />
42 PrintAnswer<br />
43<br />
44<br />
45 # 很明显的,这是一个拼凑的实现.<br />
46 #+ 然而使用&rdquo;-t&rdquo;选项来&rdquo;read&rdquo;的话,将会简化这个任务.<br />
47 # 见&rdquo;t-out.sh&rdquo;,在下边.<br />
48<br />
49 # 如果你需要一个真正的幽雅的写法&hellip;<br />
50 #+ 建议你使用c/c++来写这个应用,<br />
51 #+ 使用合适的库来完成这个任务,比如&rsquo;alarm&rsquo;和&rsquo;setitimer&rsquo;.<br />
52<br />
53 exit 0<br />
################################End
Script#########################################<br />
使用stty也是一种选择.</p>

<p>Example 9-3 再来一个时间输入<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # timeout.sh<br />
3<br />
4 # Stephane Chazelas编写,<br />
5 #+ 本书作者进行了一些修改.<br />
6<br />
7 INTERVAL=5 # timeout间隔<br />
8<br />
9 timedout_read() {<br />
10 timeout=$1<br />
11 varname=$2<br />
12 old_tty_settings=<code>stty -g</code><br />
13 stty -icanon min 0 time ${timeout}0<br />
14 eval read $varname # 或者就是 read $varname<br />
15 stty &ldquo;$old_tty_settings&rdquo;<br />
16 # 察看&rdquo;stty&rdquo;的man页.<br />
17 }<br />
18<br />
19 echo; echo -n &ldquo;What&rsquo;s your name? Quick! &rdquo;<br />
20 timedout_read $INTERVAL your_name<br />
21<br />
22 # 这种方法可能不是每个终端类型都可以正常使用的.<br />
23 # 最大的timeout依赖于具体的终端.<br />
24 #+ (一般都是25.5秒).<br />
25<br />
26 echo<br />
27<br />
28 if [ ! -z &ldquo;$your_name&rdquo; ] # If name input before timeout&hellip;<br />
29 then<br />
30 echo &ldquo;Your name is $your_name.&rdquo;<br />
31 else<br />
32 echo &ldquo;Timed out.&rdquo;<br />
33 fi<br />
34<br />
35 echo<br />
36<br />
37 # 这个脚本的行为可能与&rdquo;timed-input.sh&rdquo;有点不同.<br />
38 # 在每次按键的时候,计数器都会重置.<br />
39<br />
40 exit 0<br />
################################End
Script#########################################<br />
或许,最简单的办法就是使用-t选项来read了.</p>

<p>Example 9-4 Timed read<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # t-out.sh<br />
3 # &ldquo;syngin seven&rdquo;的一个很好的提议 (thanks).<br />
4<br />
5<br />
6 TIMELIMIT=4 # 4 seconds<br />
7<br />
8 read -t $TIMELIMIT variable 9 # ^^^<br />
10 # 在这个例子中,对于Bash 1.x和2.x就需要使用&rdquo; 11 # 但对于Bash 3.x就不需要.<br />
12<br />
13 echo<br />
14<br />
15 if [ -z &ldquo;$variable&rdquo; ] # Is null?<br />
16 then<br />
17 echo &ldquo;Timed out, variable still unset.&rdquo;<br />
18 else<br />
19 echo &ldquo;variable = $variable&rdquo;<br />
20 fi<br />
21<br />
22 exit 0<br />
################################End
Script#########################################</p>

<p>$UID<br />
用户ID号.<br />
当前用户的id号,在/etc/passwd中记录.<br />
这个值不会因为用户使用了su命令而改变.$UID是只读变量,不容易在命令行或者是脚<br />
本中被修改,并且和内建的id命令很相像.<br />
Example 9-5 我是root?<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # am-i-root.sh: 我是不是root用户?<br />
3<br />
4 ROOT_UID=0 # Root的$UID是0.<br />
5<br />
6 if [ &ldquo;$UID&rdquo; -eq &ldquo;$ROOT_UID&rdquo; ] # 是否是root用户,请站出来.<br />
7 then<br />
8 echo &ldquo;You are root.&rdquo;<br />
9 else<br />
10 echo &ldquo;You are just an ordinary user (but mom loves you just the same).&rdquo;<br />
11 fi<br />
12<br />
13 exit 0<br />
14<br />
15<br />
16 # ============================================================= #<br />
17 # 下边的代码将不被执行,因为脚本已经退出了.<br />
18<br />
19 # 检验是root用户的一种可选方法:<br />
20<br />
21 ROOTUSER_NAME=root<br />
22<br />
23 username=<code>id -nu</code> # Or&hellip; username=<code>whoami</code><br />
24 if [ &ldquo;$username&rdquo; = &ldquo;$ROOTUSER_NAME&rdquo; ]<br />
25 then<br />
26 echo &ldquo;Rooty, toot, toot. You are root.&rdquo;<br />
27 else<br />
28 echo &ldquo;You are just a regular fella.&rdquo;<br />
29 fi<br />
################################End
Script#########################################<br />
见例子Example 2-3<br />
注意:变量$ENV,$LOGNAME,$MAIL,$TERM,$USER,和$USERNAME并不是Bash的内建变量.它<br />
们经常被设置成环境变量,它们一般都放在Bash的安装文件中.$SHELL,用户登录的<br />
shell的名字,可能是从/etc/passwd设置的,也可能是在一个&rdquo;init&rdquo;脚本中设置的,同样<br />
的,它也不是Bash的内建变量.<br />
tcsh% echo $LOGNAME<br />
bozo<br />
tcsh% echo $SHELL<br />
/bin/tcsh<br />
tcsh% echo $TERM<br />
rxvt</p>

<p>bash$ echo $LOGNAME<br />
bozo<br />
bash$ echo $SHELL<br />
/bin/tcsh<br />
bash$ echo $TERM<br />
rxvt</p>

<p>位置参数<br />
$0, $1, $2,等等&hellip;<br />
位置参数,从命令行传递给脚本,或者是传递给函数.或者赋职给一个变量.<br />
(具体见Example 4-5和Example 11-15)</p>

<p>$#<br />
命令行或者是位置参数的个数.(见Example 33-2)</p>

<p>$*<br />
所有的位置参数,被作为一个单词.<br />
注意:&ldquo;$*&ldquo;必须被&rdquo;&ldquo;引用.</p>

<p>$@<br />
与$*同义,但是每个参数都是一个独立的&rdquo;&ldquo;引用字串,这就意味着参数被完整地传递,<br />
并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的<br />
单词.<br />
注意:&ldquo;$@&ldquo;必须被引用.</p>

<p>Example 9-6 arglist:通过$<em>和$@列出所有的参数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # arglist.sh<br />
3 # 多使用几个参数来调用这个脚本,比如&rdquo;one tow three&rdquo;.<br />
4<br />
5 E_BADARGS=65<br />
6<br />
7 if [ ! -n &ldquo;$1&rdquo; ]<br />
8 then<br />
9 echo &ldquo;Usage: <code>basename $0</code> argument1 argument2 etc.&rdquo;<br />
10 exit $E_BADARGS<br />
11 fi<br />
12<br />
13 echo<br />
14<br />
15 index=1 # 初始化数量.<br />
16<br />
17 echo &ldquo;Listing args with \&rdquo;\$</em>\&rdquo;:&rdquo;<br />
18 for arg in &ldquo;$<em>&rdquo; # 如果&rdquo;$</em>&ldquo;不被&rdquo;&ldquo;引用,那么将不能正常地工作<br />
19 do<br />
20 echo &ldquo;Arg #$index = $arg&rdquo;<br />
21 let &ldquo;index+=1&rdquo;<br />
22 done # $* sees all arguments as single word.<br />
22 done # $* 认为所有的参数为一个单词<br />
23 echo &ldquo;Entire arg list seen as single word.&rdquo;<br />
24<br />
25 echo<br />
26<br />
27 index=1 # 重置数量.<br />
28 # 如果你忘了这句会发生什么?<br />
29<br />
30 echo &ldquo;Listing args with \&rdquo;\$@\&rdquo;:&rdquo;<br />
31 for arg in &ldquo;$@&rdquo;<br />
32 do<br />
33 echo &ldquo;Arg #$index = $arg&rdquo;<br />
34 let &ldquo;index+=1&rdquo;<br />
35 done # $@ 认为每个参数都一个单独的单词.<br />
36 echo &ldquo;Arg list seen as separate words.&rdquo;<br />
37<br />
38 echo<br />
39<br />
40 index=1 # 重置数量.<br />
41<br />
42 echo &ldquo;Listing args with \$* (unquoted):&rdquo;<br />
43 for arg in $*<br />
44 do<br />
45 echo &ldquo;Arg #$index = $arg&rdquo;<br />
46 let &ldquo;index+=1&rdquo;<br />
47 done # 未&rdquo;&ldquo;引用的$*把参数作为独立的单词.<br />
48 echo &ldquo;Arg list seen as separate words.&rdquo;<br />
49<br />
50 exit 0<br />
################################End
Script#########################################</p>

<p>在shift命令后边,$@将保存命令行中剩余的参数,而$1被丢掉了.<br />
1 #!/bin/bash<br />
2 # 使用 ./scriptname 1 2 3 4 5 来调用这个脚本<br />
3<br />
4 echo &ldquo;$@&rdquo; # 1 2 3 4 5<br />
5 shift<br />
6 echo &ldquo;$@&rdquo; # 2 3 4 5<br />
7 shift<br />
8 echo &ldquo;$@&rdquo; # 3 4 5<br />
9<br />
10 # 每个&rdquo;shift&rdquo;都丢弃$1.<br />
11 # &ldquo;$@&rdquo; 将包含剩下的参数.<br />
$@也作为为工具使用,用来过滤传给脚本的输入.<br />
cat &ldquo;$@&ldquo;结构接受从stdin传来的输入,也接受从参数中指定的文件传来的输入.<br />
具体见Example 12-21和Example 12-22.</p>

<p>注意:$*和$@的参数有时会不一致,发生令人迷惑的行为,这依赖于$IFS的设置.</p>

<p>Example 9-7 不一致的$<em>和$@行为<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # &ldquo;$</em>&ldquo;和&rdquo;$@&ldquo;的古怪行为,<br />
4 #+ 依赖于它们是否被&rdquo;&ldquo;引用.<br />
5 # 单词拆分和换行的不一致处理.<br />
6<br />
7<br />
8 set &ndash; &ldquo;First one&rdquo; &ldquo;second&rdquo; &ldquo;third:one&rdquo; &ldquo;&rdquo; &ldquo;Fifth: :one&rdquo;<br />
9 # 设置这个脚本参数,$1,$2,等等.<br />
10<br />
11 echo<br />
12<br />
13 echo &lsquo;IFS unchanged, using &ldquo;$<em>&rdquo;&rsquo;<br />
14 c=0<br />
15 for i in &ldquo;$</em>&rdquo; # 引用<br />
16 do echo &ldquo;$((c+=1)): [$i]&rdquo; # 这行在下边的每个例子中都一样.<br />
17 # Echo参数.<br />
18 done<br />
19 echo &mdash;<br />
20<br />
21 echo &lsquo;IFS unchanged, using $<em>&rsquo;<br />
22 c=0<br />
23 for i in $</em> # 未引用<br />
24 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
25 done<br />
26 echo &mdash;<br />
27<br />
28 echo &lsquo;IFS unchanged, using &ldquo;$@&rdquo;&rsquo;<br />
29 c=0<br />
30 for i in &ldquo;$@&rdquo;<br />
31 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
32 done<br />
33 echo &mdash;<br />
34<br />
35 echo &lsquo;IFS unchanged, using $@&rsquo;<br />
36 c=0<br />
37 for i in $@<br />
38 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
39 done<br />
40 echo &mdash;<br />
41<br />
42 IFS=:<br />
43 echo &lsquo;IFS=&rdquo;:&ldquo;, using &ldquo;$<em>&rdquo;&rsquo;<br />
44 c=0<br />
45 for i in &ldquo;$</em>&rdquo;<br />
46 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
47 done<br />
48 echo &mdash;<br />
49<br />
50 echo &lsquo;IFS=&rdquo;:&ldquo;, using $<em>&rsquo;<br />
51 c=0<br />
52 for i in $</em><br />
53 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
54 done<br />
55 echo &mdash;<br />
56<br />
57 var=$*<br />
58 echo &lsquo;IFS=&rdquo;:&ldquo;, using &ldquo;$var&rdquo; (var=$<em>)&rsquo;<br />
59 c=0<br />
60 for i in &ldquo;$var&rdquo;<br />
61 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
62 done<br />
63 echo &mdash;<br />
64<br />
65 echo &lsquo;IFS=&rdquo;:&ldquo;, using $var (var=$</em>)&rsquo;<br />
66 c=0<br />
67 for i in $var<br />
68 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
69 done<br />
70 echo &mdash;<br />
71<br />
72 var=&ldquo;$<em>&rdquo;<br />
73 echo &lsquo;IFS=&rdquo;:&ldquo;, using $var (var=&rdquo;$</em>&rdquo;)&rsquo;<br />
74 c=0<br />
75 for i in $var<br />
76 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
77 done<br />
78 echo &mdash;<br />
79<br />
80 echo &lsquo;IFS=&rdquo;:&ldquo;, using &ldquo;$var&rdquo; (var=&ldquo;$*&ldquo;)&rsquo;<br />
81 c=0<br />
82 for i in &ldquo;$var&rdquo;<br />
83 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
84 done<br />
85 echo &mdash;<br />
86<br />
87 echo &lsquo;IFS=&rdquo;:&ldquo;, using &ldquo;$@&rdquo;&rsquo;<br />
88 c=0<br />
89 for i in &ldquo;$@&rdquo;<br />
90 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
91 done<br />
92 echo &mdash;<br />
93<br />
94 echo &lsquo;IFS=&rdquo;:&ldquo;, using $@&rsquo;<br />
95 c=0<br />
96 for i in $@<br />
97 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
98 done<br />
99 echo &mdash;<br />
100<br />
101 var=$@<br />
102 echo &lsquo;IFS=&rdquo;:&ldquo;, using $var (var=$@)&rsquo;<br />
103 c=0<br />
104 for i in $var<br />
105 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
106 done<br />
107 echo &mdash;<br />
108<br />
109 echo &lsquo;IFS=&rdquo;:&ldquo;, using &ldquo;$var&rdquo; (var=$@)&rsquo;<br />
110 c=0<br />
111 for i in &ldquo;$var&rdquo;<br />
112 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
113 done<br />
114 echo &mdash;<br />
115<br />
116 var=&ldquo;$@&rdquo;<br />
117 echo &lsquo;IFS=&rdquo;:&ldquo;, using &ldquo;$var&rdquo; (var=&ldquo;$@&rdquo;)&rsquo;<br />
118 c=0<br />
119 for i in &ldquo;$var&rdquo;<br />
120 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
121 done<br />
122 echo &mdash;<br />
123<br />
124 echo &lsquo;IFS=&rdquo;:&ldquo;, using $var (var=&rdquo;$@&ldquo;)&rsquo;<br />
125 c=0<br />
126 for i in $var<br />
127 do echo &ldquo;$((c+=1)): [$i]&rdquo;<br />
128 done<br />
129<br />
130 echo<br />
131<br />
132 # 用ksh或者zsh -y来试试这个脚本.<br />
133<br />
134 exit 0<br />
135<br />
136 # This example script by Stephane Chazelas,<br />
137 # and slightly modified by the document author.<br />
################################End
Script#########################################<br />
注意:$@和$*中的参数只有在&rdquo;&ldquo;中才会不同.</p>

<p>Example 9-8 当$IFS为空时的$<em>和$@<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 如果$IFS被设置为空时,<br />
4 #+ 那么&rdquo;$</em>&rdquo; 和&rdquo;$@&rdquo; 将不会象期望那样echo出位置参数.<br />
5<br />
6 mecho () # Echo 位置参数.<br />
7 {<br />
8 echo &ldquo;$1,$2,$3&rdquo;;<br />
9 }<br />
10<br />
11<br />
12 IFS=&ldquo;&rdquo; # 设置为空.<br />
13 set a b c # 位置参数.<br />
14<br />
15 mecho &ldquo;$<em>&rdquo; # abc,,<br />
16 mecho $</em> # a,b,c<br />
17<br />
18 mecho $@ # a,b,c<br />
19 mecho &ldquo;$@&rdquo; # a,b,c<br />
20<br />
21 # 当$IFS设置为空时,$* 和$@ 的行为依赖于<br />
22 #+ 正在运行的Bash或者sh的版本.<br />
23 # 所以在脚本中使用这种&rdquo;feature&rdquo;不是明智的行为.<br />
24<br />
25<br />
26 # Thanks, Stephane Chazelas.<br />
27<br />
28 exit 0<br />
################################End
Script#########################################</p>

<p>其他的特殊参数</p>

<p>$-<br />
传递给脚本的falg(使用set命令).参考Example 11-15.</p>

<p>注意:这起初是ksh的特征,后来被引进到Bash中,但不幸的是,在Bash中它看上去也不<br />
能可靠的工作.使用它的一个可能的方法就是让这个脚本进行自我测试(查看是否是交<br />
互的).</p>

<p>$!<br />
在后台运行的最后的工作的PID(进程ID).<br />
1 LOG=$0.log<br />
2<br />
3 COMMAND1=&ldquo;sleep 100&rdquo;<br />
4<br />
5 echo &ldquo;Logging PIDs background commands for script: $0&rdquo; &gt;&gt; &ldquo;$LOG&rdquo;<br />
6 # 所以它们可以被监控,并且在必要的时候kill掉.<br />
7 echo &gt;&gt; &ldquo;$LOG&rdquo;<br />
8<br />
9 # Logging 命令.<br />
10<br />
11 echo -n &ldquo;PID of \&ldquo;$COMMAND1\&rdquo;: &ldquo; &gt;&gt; &ldquo;$LOG&rdquo;<br />
12 ${COMMAND1} &amp;<br />
13 echo $! &gt;&gt; &ldquo;$LOG&rdquo;<br />
14 # PID of &ldquo;sleep 100&rdquo;: 1506<br />
15<br />
16 # Thank you, Jacques Lederer, for suggesting this.</p>

<p>1 possibly_hanging_job &amp; { sleep ${TIMEOUT}; eval &lsquo;kill -9 $!&rsquo; &amp;&gt; /dev/null; }<br />
2 # 强制结束一个品行不良的程序.<br />
3 # 很有用,比如在init脚本中.<br />
4<br />
5 # Thank you,Sylvain Fourmanoit,for this creative use of the &ldquo;!&rdquo; variable.</p>

<p>$_<br />
保存之前执行的命令的最后一个参数.</p>

<p>Example 9-9 下划线变量<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 echo $_ # /bin/bash<br />
4 # 只是调用/bin/bash来运行这个脚本.<br />
5<br />
6 du &gt;/dev/null # 将没有命令的输出<br />
7 echo $_ # du<br />
8<br />
9 ls -al &gt;/dev/null # 没有命令输出<br />
10 echo $_ # -al (最后的参数)<br />
11<br />
12 :<br />
13 echo $_ # :<br />
################################End
Script#########################################</p>

<p>$?<br />
命令,函数或者脚本本身的退出状态(见Example 23-7)</p>

<p>$$<br />
脚本自身的进程ID.这个变量经常用来构造一个&rdquo;unique&rdquo;的临时文件名.<br />
(参考Example A-13,Example 29-6,Example 12-28和Example 11-25).<br />
这通常比调用mktemp来得简单.</p>

<p>注意事项:<br />
[1] 当前运行的脚本的PID为$$.<br />
[2] &ldquo;argument&rdquo;和&rdquo;parameter&rdquo;这两个单词经常不加区分的使用.在这整本书中,这两个<br />
单词的意思完全相同.(在翻译的时候就未加区分,统统翻译成参数)</p>

<p>9.2 操作字符串<br />
-&mdash;&mdash;&mdash;&mdash;-<br />
Bash支持超多的字符串操作,操作的种类和数量令人惊异.但不幸的是,这些工具缺乏集中性.<br />
一些是参数替换的子集,但是另一些则属于UNIX的expr命令.这就导致了命令语法的不一致和<br />
功能的重叠,当然也会引起混乱.</p>

<p>字符串长度</p>

<p>${#string}<br />
expr length $string<br />
expr &ldquo;$string&rdquo; : &lsquo;.*&rsquo;</p>

<p>1 stringZ=abcABC123ABCabc<br />
2<br />
3 echo ${#stringZ} # 15<br />
4 echo <code>expr length $stringZ</code> # 15<br />
5 echo <code>expr &quot;$stringZ&quot; : '.*'</code> # 15</p>

<p>Example 9-10 在一个文本文件的段间插入空行<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # paragraph-space.sh<br />
3<br />
4 # 在一个不空行的文本文件的段间插入空行.<br />
5 # Usage: $0  6<br />
7 MINLEN=45 # 可能需要修改这个值.<br />
8 # 假定行的长度小于$MINLEN指定的长度<br />
9 #+ $MINLEN中的值用来描述多少个字符结束一个段.<br />
10<br />
11 while read line # 对于需要多行输入的文件基本都是这个样子<br />
12 do<br />
13 echo &ldquo;$line&rdquo; # 输出line.<br />
14<br />
15 len=${#line}<br />
16 if [ &ldquo;$len&rdquo; -lt &ldquo;$MINLEN&rdquo; ]<br />
17 then echo # 在短行后边添加一个空行<br />
18 fi<br />
19 done<br />
20<br />
21 exit 0<br />
################################End
Script#########################################</p>

<p>从字符串开始的位置匹配子串的长度</p>

<p>expr match &ldquo;$string&rdquo; &lsquo;$substring&rsquo;<br />
$substring是一个正则表达式</p>

<p>expr &ldquo;$string&rdquo; : &lsquo;$substring&rsquo;<br />
$substring是一个正则表达式</p>

<p>1 stringZ=abcABC123ABCabc<br />
2 # |&mdash;&mdash;|<br />
3<br />
4 echo <code>expr match &quot;$stringZ&quot; 'abc[A-Z]*.2'</code> # 8<br />
5 echo <code>expr &quot;$stringZ&quot; : 'abc[A-Z]*.2'</code> # 8</p>

<p>索引</p>

<p>expr index $string $substring<br />
匹配到子串的第一个字符的位置.</p>

<p>1 stringZ=abcABC123ABCabc<br />
2 echo <code>expr index &quot;$stringZ&quot; C12</code> # 6<br />
3 # C position.<br />
4<br />
5 echo <code>expr index &quot;$stringZ&quot; 1c</code> # 3<br />
6 # &lsquo;c&rsquo; (in #3 position) matches before &lsquo;1&rsquo;.</p>

<p>在C语言中最近的等价函数为strchr().</p>

<p>提取子串</p>

<p>${string:position}<br />
在string中从位置$position开始提取子串.<br />
如果$string为&rdquo;*&ldquo;或&rdquo;@&ldquo;,那么将提取从位置$position开始的位置参数,[1]</p>

<p>${string:position:length}<br />
在string中从位置$position开始提取$length长度的子串.</p>

<p>################################Start
Script#######################################<br />
1 stringZ=abcABC123ABCabc<br />
2 # 0123456789&hellip;..<br />
3 # 0-based indexing.<br />
4<br />
5 echo ${stringZ:0} # abcABC123ABCabc<br />
6 echo ${stringZ:1} # bcABC123ABCabc<br />
7 echo ${stringZ:7} # 23ABCabc<br />
8<br />
9 echo ${stringZ:7:3} # 23A<br />
10 # 3个字符长度的子串.<br />
11<br />
12<br />
13<br />
14 # 有没有可能从字符结尾开始,反向提取子串?<br />
15<br />
16 echo ${stringZ:-4} # abcABC123ABCabc<br />
17 # 以${parameter:-default}方式,默认是提取完整地字符串.<br />
18 # 然而 &hellip;<br />
19<br />
20 echo ${stringZ:(-4)} # Cabc<br />
21 echo ${stringZ: -4} # Cabc<br />
22 # 现在,它可以工作了.<br />
23 # 使用圆括号或者添加一个空格来转义这个位置参数.<br />
24<br />
25 # Thank you, Dan Jacobson, for pointing this out.<br />
################################End
Script#########################################<br />
如果$string参数为&rdquo;<em>&ldquo;或&rdquo;@&ldquo;,那将最大的提取从$position开始的$length个位置参数.<br />
1 echo ${</em>:2} # Echo出第2个和后边所有的位置参数.<br />
2 echo ${@:2} # 与前边相同.<br />
3<br />
4 echo ${*:2:3} # 从第2个开始,Echo出后边3个位置参数.</p>

<p>expr substr $string $position $length<br />
在string中从位置$position开始提取$length长度的子串.<br />
1 stringZ=abcABC123ABCabc<br />
2 # 123456789&hellip;&hellip;<br />
3 # 1-based indexing.<br />
4<br />
5 echo <code>expr substr $stringZ 1 2</code> # ab<br />
6 echo <code>expr substr $stringZ 4 3</code> # ABC</p>

<p>expr match &ldquo;$string&rdquo; &lsquo;\($substring\)&rsquo;<br />
从$string的开始位置提取$substring,$substring是一个正则表达式.</p>

<p>expr &ldquo;$string&rdquo; : &lsquo;\($substring\)&rsquo;<br />
从$string的开始位置提取$substring,$substring是一个正则表达式.<br />
1 stringZ=abcABC123ABCabc<br />
2 # =======<br />
3<br />
4 echo <code>expr match &quot;$stringZ&quot; '\\(.[b-c]*[A-Z]..[0-9]\\)'</code> # abcABC1<br />
5 echo <code>expr &quot;$stringZ&quot; : '\\(.[b-c]*[A-Z]..[0-9]\\)'</code> # abcABC1<br />
6 echo <code>expr &quot;$stringZ&quot; : '\\(.......\\)'</code> # abcABC1<br />
7 # All of the above forms give an identical result.</p>

<p>子串削除</p>

<p>${string#substring}<br />
从$string的左边截掉第一个匹配的$substring<br />
${string##substring}<br />
从$string的左边截掉最后一个个匹配的$substring</p>

<p>1 stringZ=abcABC123ABCabc<br />
2 # |&mdash;-|<br />
3 # |&mdash;&mdash;&mdash;-|<br />
4<br />
5 echo ${stringZ#a*C} # 123ABCabc<br />
6 # 截掉&rsquo;a&rsquo;和&rsquo;C&rsquo;之间最近的匹配.<br />
7<br />
8 echo ${stringZ##a*C} # abc<br />
9 # 截掉&rsquo;a&rsquo;和&rsquo;C&rsquo;之间最远的匹配.</p>

<p>${string%substring}<br />
从$string的右边截掉第一个匹配的$substring<br />
${string%%substring}<br />
从$string的右边截掉最后一个匹配的$substring</p>

<p>1 stringZ=abcABC123ABCabc<br />
2 # ||<br />
3 # |&mdash;&mdash;&mdash;&mdash;|<br />
4<br />
5 echo ${stringZ%b*c} # abcABC123ABCa<br />
6 # 从$stringZ的后边开始截掉&rsquo;b&rsquo;和&rsquo;c&rsquo;之间的最近的匹配<br />
7<br />
8 echo ${stringZ%%b*c} # a<br />
9 # 从$stringZ的后边开始截掉&rsquo;b&rsquo;和&rsquo;c&rsquo;之间的最远的匹配</p>

<p>Example 9-11 利用修改文件名,来转换图片格式<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # cvt.sh:<br />
3 # 把一个目录下的所有MacPaint格式的图片文件都转换为&rdquo;pbm&rdquo;格式的图片文件.<br />
4<br />
5 # 使用来自&rdquo;netpbm&rdquo;包的&rdquo;macptopbm&rdquo;程序,<br />
6 #+ 这个程序主要是由Brian Henderson(bryanh@giraffe-data.com)来维护的.<br />
7 # Netpbm是大多数Linux发行版的标准部分.<br />
8<br />
9 OPERATION=macptopbm<br />
10 SUFFIX=pbm # 新的文件名后缀<br />
11<br />
12 if [ -n &ldquo;$1&rdquo; ]<br />
13 then<br />
14 directory=$1 # 如果目录名作为第1个参数给出&hellip;<br />
15 else<br />
16 directory=$PWD # 否则使用当前的工作目录.<br />
17 fi<br />
18<br />
19 # 假设在目标目录中的所有文件都是MacPaint格式的图片文件,<br />
20 #+ 以&rdquo;.mac&rdquo;为文件名的后缀.<br />
21<br />
22 for file in $directory/* # Filename globbing.<br />
23 do<br />
24 filename=${file%.*c} # 去掉文件名的&rdquo;.mac&rdquo;后缀<br />
25 #+ (&lsquo;.*c&rsquo; matches everything<br />
25 #+ (&lsquo;.<em>c&rsquo; 将匹配&rsquo;.&lsquo;和&rsquo;c&rsquo;之间的任何字符串).<br />
26<br />
27 $OPERATION $file &gt; &ldquo;$filename.$SUFFIX&rdquo;<br />
28 # 转换为新的文件名.<br />
29 rm -f $file # 转换完毕后删除原有的文件.<br />
30 echo &ldquo;$filename.$SUFFIX&rdquo; # 从stdout输出反馈.<br />
31 done<br />
32<br />
33 exit 0<br />
34<br />
35 # 练习:<br />
36 # &mdash;&mdash;&ndash;<br />
37 # 就像它现在这个样子,这个脚本把当前目录的所有文件都转换了.<br />
38 #<br />
39 # 修改这个脚本,让他只转换以&rdquo;.mac&rdquo;为后缀的文件.<br />
################################End
Script#########################################<br />
一个简单的模拟getopt命令的办法就是使用子串提取结构.<br />
Example 9-12 模仿getopt命令<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # getopt-simple.sh<br />
3 # Author: Chris Morgan<br />
4 # 授权使用在ABS Guide中.<br />
5<br />
6<br />
7 getopt_simple()<br />
8 {<br />
9 echo &ldquo;getopt_simple()&rdquo;<br />
10 echo &ldquo;Parameters are &lsquo;$</em>&rsquo;&rdquo;<br />
11 until [ -z &ldquo;$1&rdquo; ]<br />
12 do<br />
13 echo &ldquo;Processing parameter of: &lsquo;$1&rsquo;&rdquo;<br />
14 if [ ${1:0:1} = &lsquo;/&rsquo; ]<br />
15 then<br />
16 tmp=${1:1} # 去掉开头的&rsquo;/&rsquo; &hellip;<br />
17 parameter=${tmp%%=<em>} # 提取名字.<br />
18 value=${tmp##</em>=} # 提取值.<br />
19 echo &ldquo;Parameter: &lsquo;$parameter&rsquo;, value: &lsquo;$value&rsquo;&rdquo;<br />
20 eval $parameter=$value<br />
21 fi<br />
22 shift<br />
23 done<br />
24 }<br />
25<br />
26 # 传递所有的选项到getopt_simple().<br />
27 getopt_simple $*<br />
28<br />
29 echo &ldquo;test is &lsquo;$test&rsquo;&rdquo;<br />
30 echo &ldquo;test2 is &lsquo;$test2&rsquo;&rdquo;<br />
31<br />
32 exit 0<br />
33<br />
34 &mdash;<br />
35<br />
36 sh getopt_example.sh /test=value1 /test2=value2<br />
37<br />
38 Parameters are &lsquo;/test=value1 /test2=value2&rsquo;<br />
39 Processing parameter of: &lsquo;/test=value1&rsquo;<br />
40 Parameter: &lsquo;test&rsquo;, value: &lsquo;value1&rsquo;<br />
41 Processing parameter of: &lsquo;/test2=value2&rsquo;<br />
42 Parameter: &lsquo;test2&rsquo;, value: &lsquo;value2&rsquo;<br />
43 test is &lsquo;value1&rsquo;<br />
44 test2 is &lsquo;value2&rsquo;<br />
################################End
Script#########################################</p>

<p>子串替换</p>

<p>${string/substring/replacement}<br />
使用$replacement来替换第一个匹配的$substring.<br />
${string//substring/replacement}<br />
使用$replacement来替换所有匹配的$substring.</p>

<p>1 stringZ=abcABC123ABCabc<br />
2<br />
3 echo ${stringZ/abc/xyz} # xyzABC123ABCabc<br />
4 # 用&rsquo;xyz&rsquo;来替换第一个匹配的&rsquo;abc&rsquo;.<br />
5<br />
6 echo ${stringZ//abc/xyz} # xyzABC123ABCxyz<br />
7 # 用&rsquo;xyz&rsquo;来替换所有匹配的&rsquo;abc&rsquo;.</p>

<p>${string/#substring/replacement}<br />
如果$substring匹配$string的开头部分,那么就用$replacement来替换$substring.<br />
${string/%substring/replacement}<br />
如果$substring匹配$string的结尾部分,那么就用$replacement来替换$substring.<br />
1 stringZ=abcABC123ABCabc<br />
2<br />
3 echo ${stringZ/#abc/XYZ} # XYZABC123ABCabc<br />
4 # 用&rsquo;XYZ&rsquo;替换开头的&rsquo;abc&rsquo;<br />
5<br />
6 echo ${stringZ/%abc/XYZ} # abcABC123ABCXYZ<br />
7 # 用&rsquo;XYZ&rsquo;替换结尾的&rsquo;abc&rsquo;</p>

<p>9.2.1 使用awk来操作字符串<br />
~~~~~~~~~~~~~~~~~~~~~~~~~<br />
Bash脚本也可以使用awk来操作字符串.</p>

<p>Example 9-13 提取字符串的一种可选的方法<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # substring-extraction.sh<br />
3<br />
4 String=23skidoo1<br />
5 # 012345678 Bash<br />
6 # 123456789 awk<br />
7 # 注意,对于awk和Bash来说,它们使用的是不同的string索引系统:<br />
8 # Bash的第一个字符是从&rsquo;0&rsquo;开始记录的.<br />
9 # Awk的第一个字符是从&rsquo;1&rsquo;开始记录的.<br />
10<br />
11 echo ${String:2:4} # 位置3 (0-1-2), 4 个字符长<br />
12 # skid<br />
13<br />
14 # awk中等价于${string:pos:length}的命令是substr(string,pos,length).<br />
15 echo | awk &lsquo;<br />
16 { print substr(&ldquo;&lsquo;&rdquo;${String}&ldquo;&rsquo;&rdquo;,3,4) # skid<br />
17 }<br />
18 &lsquo;<br />
19 # 使用一个空的&rdquo;echo&rdquo;通过管道给awk一个假的输入,<br />
20 #+ 这样可以不用提供一个文件名.<br />
21<br />
22 exit 0<br />
################################End
Script#########################################</p>

<p>9.2.2 更深的讨论<br />
~~~~~~~~~~~~~~~~<br />
关于在脚本中使用字符串更深的讨论,请参考 9.3节,h和expr命令列表的相关章节.<br />
关于脚本的例子,见:</p>

<p>1 Example 12-9<br />
2 Example 9-16<br />
3 Example 9-17<br />
4 Example 9-18<br />
5 Example 9-20</p>

<p>注意事项:<br />
[1] 这适用于命令行参数和函数参数.</p>

<p>9.3 参数替换<br />
-&mdash;&mdash;&mdash;&ndash;</p>

<p>操作和扩展变量</p>

<p>${parameter}<br />
与$parameter相同,就是parameter的值.在特定的上下文中,只有少部分会产生<br />
${parameter}的混淆.可以组合起来一起赋指给字符串变量.</p>

<p>1 your_id=${USER}-on-${HOSTNAME}<br />
2 echo &ldquo;$your_id&rdquo;<br />
3 #<br />
4 echo &ldquo;Old \$PATH = $PATH&rdquo;<br />
5 PATH=${PATH}:/opt/bin #Add /opt/bin to $PATH for duration of script.<br />
6 echo &ldquo;New \$PATH = $PATH&rdquo;</p>

<p>${parameter-default},${parameter:-default}<br />
如果parameter没被set,那么就使用default.</p>

<p>1 echo ${username-<code>whoami</code>}<br />
2 # echo <code>whoami</code>的结果,如果没set username变量的话.</p>

<p>注意:${parameter-default}和${parameter:-default}大部分时候是相同的.<br />
额外的&rdquo;:&ldquo;在parameter被声明的时候(而且被赋空值),会有一些不同.</p>

<p>################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # param-sub.sh<br />
3<br />
4 # 一个变量是否被声明<br />
5 #+ 将会影响默认选项的触发<br />
6 #+ 甚至于这个变量被设为空.<br />
7<br />
8 username0=<br />
9 echo &ldquo;username0 has been declared, but is set to null.&rdquo;<br />
10 echo &ldquo;username0 = ${username0-<code>whoami</code>}&rdquo;<br />
11 # 将不会echo.<br />
12<br />
13 echo<br />
14<br />
15 echo username1 has not been declared.<br />
16 echo &ldquo;username1 = ${username1-<code>whoami</code>}&rdquo;<br />
17 # 将会echo.<br />
18<br />
19 username2=<br />
20 echo &ldquo;username2 has been declared, but is set to null.&rdquo;<br />
21 echo &ldquo;username2 = ${username2:-<code>whoami</code>}&rdquo;<br />
22 # ^<br />
23 # 将会echo因为使用的是:-而不是 -.<br />
24 # 和前边的第一个例子好好比较一下.<br />
25<br />
26<br />
27 #<br />
28<br />
29 # 再来一个:<br />
30<br />
31 variable=<br />
32 # 变量已经被声明了,但是被设置为空.<br />
33<br />
34 echo &ldquo;${variable-0}&rdquo; # (no output)<br />
35 echo &ldquo;${variable:-1}&rdquo; # 1<br />
36 # ^<br />
37<br />
38 unset variable<br />
39<br />
40 echo &ldquo;${variable-2}&rdquo; # 2<br />
41 echo &ldquo;${variable:-3}&rdquo; # 3<br />
42<br />
43 exit 0<br />
################################End
Script#########################################</p>

<p>如果脚本中并没有传入命令行参数,那么default parameter将被使用.<br />
1 DEFAULT_FILENAME=generic.data<br />
2 filename=${1:-$DEFAULT_FILENAME}<br />
3 # 如果没有参数被传递进来,那么下边的命令快将操作<br />
4 #+ 文件&rdquo;generic.data&rdquo;<br />
5 #<br />
6 # 后续命令.</p>

<p>另外参见Example 3-4,Example 28-2,和Example A-6.<br />
与&rdquo;使用一个与列表来支持一个默认的命令行参数&rdquo;的方法相比较.</p>

<p>${parameter=default},${parameter:=default}<br />
如果parameter未设置,那么就设置为default.<br />
这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候,<br />
才会有区别,[1]和上边的行为一样.<br />
1 echo ${username=<code>whoami</code>}<br />
2 # Variable &ldquo;username&rdquo; is now set to <code>whoami</code>.<br />
2 # 变量&rdquo;username&rdquo;被赋值为<code>whoami</code>.</p>

<p>${parameter+alt_value},${parameter:+alt_value}<br />
如果parameter被set了,那就使用alt_value,否则就使用null字符串.<br />
这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候,<br />
会有区别,见下.</p>

<p>################################Start
Script#######################################<br />
1 echo &ldquo;###### \${parameter+alt_value} ########&rdquo;<br />
2 echo<br />
3<br />
4 a=${param1+xyz}<br />
5 echo &ldquo;a = $a&rdquo; # a =<br />
6<br />
7 param2=<br />
8 a=${param2+xyz}<br />
9 echo &ldquo;a = $a&rdquo; # a = xyz<br />
10<br />
11 param3=123<br />
12 a=${param3+xyz}<br />
13 echo &ldquo;a = $a&rdquo; # a = xyz<br />
14<br />
15 echo<br />
16 echo &ldquo;###### \${parameter:+alt_value} ########&rdquo;<br />
17 echo<br />
18<br />
19 a=${param4:+xyz}<br />
20 echo &ldquo;a = $a&rdquo; # a =<br />
21<br />
22 param5=<br />
23 a=${param5:+xyz}<br />
24 echo &ldquo;a = $a&rdquo; # a =<br />
25 # 与a=${param5+xyz}有不同的结果.<br />
26<br />
27 param6=123<br />
28 a=${param6+xyz}<br />
29 echo &ldquo;a = $a&rdquo; # a = xyz<br />
################################End
Script#########################################</p>

<p>${parameter?err_msg}, ${parameter:?err_msg}<br />
如果parameter被set,那就是用set的值,否则print err_msg.<br />
这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候,<br />
会有区别,见上.</p>

<p>Example 9-14 使用参数替换和error messages<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 检查一些系统的环境变量.<br />
4 # 这是个好习惯.<br />
5 # 比如,如果$USER(在console上的用户名)没被set,<br />
6 #+ 那么系统就不会认你.<br />
7<br />
8 : ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}<br />
9 echo<br />
10 echo &ldquo;Name of the machine is $HOSTNAME.&rdquo;<br />
11 echo &ldquo;You are $USER.&rdquo;<br />
12 echo &ldquo;Your home directory is $HOME.&rdquo;<br />
13 echo &ldquo;Your mail INBOX is located in $MAIL.&rdquo;<br />
14 echo<br />
15 echo &ldquo;If you are reading this message,&rdquo;<br />
16 echo &ldquo;critical environmental variables have been set.&rdquo;<br />
17 echo<br />
18 echo<br />
19<br />
20 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
21<br />
22 # ${variablename?} 结果也可以用来<br />
23 #+ 在一个脚本中检查变量是否被set.<br />
24<br />
25 ThisVariable=Value-of-ThisVariable<br />
26 # 注意,顺便提一下,这个字符串变量可能在它们的名字中会被设置<br />
27 #+ 非法字符<br />
28 : ${ThisVariable?}<br />
29 echo &ldquo;Value of ThisVariable is $ThisVariable&rdquo;.<br />
30 echo<br />
31 echo<br />
32<br />
33<br />
34 : ${ZZXy23AB?&ldquo;ZZXy23AB has not been set.&rdquo;}<br />
35 # 如果ZZXy23AB没被set,<br />
36 #+ 那么这个脚本将以一个error message终止.<br />
37<br />
38 # 你可以指定错误消息.<br />
39 # : ${variablename?&ldquo;ERROR MESSAGE&rdquo;}<br />
40<br />
41<br />
42 # 同样的结果: dummy_variable=${ZZXy23AB?}<br />
43 # dummy_variable=${ZZXy23AB?&ldquo;ZXy23AB has not been set.&rdquo;}<br />
44 #<br />
45 # echo ${ZZXy23AB?} &gt;/dev/null<br />
46<br />
47 # 同&rdquo;set -u&rdquo;命令来比较这些检查变量是否被set的方法.<br />
48 #<br />
49<br />
50<br />
51<br />
52 echo &ldquo;You will not see this message, because script already terminated.&rdquo;<br />
53<br />
54 HERE=0<br />
55 exit $HERE # Will NOT exit here.<br />
56<br />
57 # 事实上,这个脚本将返回值1作为退出状态(echo $?).<br />
################################End
Script#########################################</p>

<p>Example 9-15 参数替换和&rdquo;usage&rdquo;messages<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # usage-message.sh<br />
3<br />
4 : ${1?&ldquo;Usage: $0 ARGUMENT&rdquo;}<br />
5 # 如果没有命令行参数,那么脚本将在此处退出.<br />
6 #+ 并且打出如下的错误消息.<br />
7 # usage-message.sh: 1: Usage: usage-message.sh ARGUMENT<br />
8<br />
9 echo &ldquo;These two lines echo only if command-line parameter given.&rdquo;<br />
10 echo &ldquo;command line parameter = \&ldquo;$1\&ldquo;&rdquo;<br />
11<br />
12 exit 0 # 如果有命令行参数,那么将在此处退出.<br />
13<br />
14 # 测试这个脚本,第1次测试带参数,第2次测试不带参数.<br />
15 # 如果有参数,那么&rdquo;$?&ldquo;就是0.<br />
16 # 如果没有,那么&rdquo;$?&ldquo;就是1.<br />
################################End
Script#########################################</p>

<p>参数替换和扩展<br />
下边的表达式是使用expr字符串匹配操作的补充(见Example 12-9).<br />
这些特定的使用方法绝大多数情况都是用来分析文件目录名.</p>

<p>变量长度/子串删除</p>

<p>${#var}<br />
字符串长度($var的字符数量).对于一个数组,${#array}是数组中第一个元素的长度.</p>

<p>一些例外:<br />
${#<em>}和${#@}将给出位置参数的个数.<br />
对于数组来说${#array[</em>]}和${$#array[@]}将给出数组元素的个数.<br />
Example 9-16 变量长度<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # length.sh<br />
3<br />
4 E_NO_ARGS=65<br />
5<br />
6 if [ $# -eq 0 ] # 这个demo脚本必须有命令行参数.<br />
7 then<br />
8 echo &ldquo;Please invoke this script with one or more command-line arguments.&rdquo;<br />
9 exit $E_NO_ARGS<br />
10 fi<br />
11<br />
12 var01=abcdEFGH28ij<br />
13 echo &ldquo;var01 = ${var01}&rdquo;<br />
14 echo &ldquo;Length of var01 = ${#var01}&rdquo;<br />
15 # 现在,让我们试试在里边嵌入一个空格.<br />
16 var02=&ldquo;abcd EFGH28ij&rdquo;<br />
17 echo &ldquo;var02 = ${var02}&rdquo;<br />
18 echo &ldquo;Length of var02 = ${#var02}&rdquo;<br />
19<br />
20 echo &ldquo;Number of command-line arguments passed to script = ${#@}&rdquo;<br />
21 echo &ldquo;Number of command-line arguments passed to script = ${#*}&rdquo;<br />
22<br />
23 exit 0<br />
################################End
Script#########################################</p>

<p>${var#Pattern}, ${var##Pattern}<br />
从$var开头删除最近或最远匹配$Pattern的子串.</p>

<p>来自Example A-7例子的一部分.<br />
1 # 来自&rdquo;days-between.sh&rdquo;例子的一个函数.<br />
2 # 去掉传递进来的参数开头的0.<br />
3<br />
4 strip_leading_zero () # 去掉开头的0<br />
5 { #+ 从传递进来的参数中.<br />
6 return=${1#0} # &ldquo;1&rdquo;指的是&rdquo;$1&rdquo; &ndash; 传进来的参数.<br />
7 } # &ldquo;0&rdquo;就是我们想从&rdquo;$1&rdquo;中删除的子串.</p>

<p>下边是Manfred Schwarb&rsquo;s对上边函数的一个改版.<br />
1 strip_leading_zero2 () # 去掉开头的0,因为如果不去掉的话<br />
2 { # Bash将会把这个值作为8进制解释.<br />
3 shopt -s extglob # 打开扩展globbing.<br />
4 local val=${1##+(0)} # 使用局部变量,匹配最长的连续的0.<br />
5 shopt -u extglob # 打开扩展globbing.<br />
6 _strip_leading_zero2=${val:-0}<br />
7 # 如果输入为0,那么返回0来代替&rdquo;&ldquo;.<br />
8 }</p>

<p>另一个例子<br />
1 echo <code>basename $PWD</code> # 当前工作目录的basename.<br />
2 echo &ldquo;${PWD##<em>/}&rdquo; # 当前工作目录的basename.<br />
3 echo<br />
4 echo <code>basename $0</code> # 脚本名字.<br />
5 echo $0 # 脚本名字.<br />
6 echo &ldquo;${0##</em>/}&rdquo; # 脚本名字.<br />
7 echo<br />
8 filename=test.data<br />
9 echo &ldquo;${filename##*.}&rdquo; # data</p>

<p>${var%Pattern}, ${var%%Pattern}<br />
从$var结尾删除最近或最远匹配$Pattern的子串.</p>

<p>Bash version2 添加了额外的选项.</p>

<p>Example 9-17 参数替换中的模式匹配<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # patt-matching.sh<br />
3<br />
4 # 使用# ## % %%来进行参数替换操作的模式匹配.<br />
5<br />
6 var1=abcd12345abc6789<br />
7 pattern1=a*c # * (通配符) 匹配a - c之间的任何字符.<br />
8<br />
9 echo<br />
10 echo &ldquo;var1 = $var1&rdquo; # abcd12345abc6789<br />
11 echo &ldquo;var1 = ${var1}&rdquo; # abcd12345abc6789<br />
12 # (alternate form)<br />
13 echo &ldquo;Number of characters in ${var1} = ${#var1}&rdquo;<br />
14 echo<br />
15<br />
16 echo &ldquo;pattern1 = $pattern1&rdquo; # a*c (everything between &lsquo;a&rsquo; and &lsquo;c&rsquo;)<br />
17 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
18 echo &lsquo;${var1#$pattern1} =&rsquo; &ldquo;${var1#$pattern1}&rdquo; # d12345abc6789<br />
19 # 最短的可能匹配, 去掉abcd12345abc6789的前3个字符<br />
20 # |-| ^^^<br />
21 echo &lsquo;${var1##$pattern1} =&rsquo; &ldquo;${var1##$pattern1}&rdquo; # 6789<br />
22 # 最远的匹配,去掉abcd12345abc6789的前12个字符.<br />
23 # |&mdash;&mdash;&mdash;-| ^^^^<br />
24<br />
25 echo; echo; echo<br />
26<br />
27 pattern2=b*9 # &lsquo;b&rsquo; 到&rsquo;9&rsquo;之间的任何字符<br />
28 echo &ldquo;var1 = $var1&rdquo; # 还是 abcd12345abc6789<br />
29 echo<br />
30 echo &ldquo;pattern2 = $pattern2&rdquo;<br />
31 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
32 echo &lsquo;${var1%pattern2} =&rsquo; &ldquo;${var1%$pattern2}&rdquo; # abcd12345a<br />
33 # 最近的匹配, 去掉abcd12345abc6789的最后6个字符<br />
34 # |&mdash;-| ^^^^<br />
35 echo &lsquo;${var1%%pattern2} =&rsquo; &ldquo;${var1%%$pattern2}&rdquo; # a<br />
36 # 最远匹配, 去掉abcd12345abc6789的最后12个字符<br />
37 # |&mdash;&mdash;&mdash;&mdash;-| ^^^^^^<br />
38<br />
39 # 记住, # 和## 从字符串的左边开始,并且去掉左边的字符串,<br />
40 # % 和 %% 从字符串的右边开始,并且去掉右边的子串.<br />
41<br />
42 echo<br />
43<br />
44 exit 0<br />
################################End
Script#########################################</p>

<p>Example 9-18 重命名文件扩展名<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # rfe.sh: 重命名文件扩展名.<br />
3 #<br />
4 # 用法: rfe old_extension new_extension<br />
5 #<br />
6 # 例子:<br />
7 # 将指定目录的所有 *.gif 文件都重命名为 *.jpg,<br />
8 # 用法: rfe gif jpg<br />
9<br />
10<br />
11 E_BADARGS=65<br />
12<br />
13 case $# in<br />
14 0|1) # &ldquo;|&rdquo; 在这里的意思是或操作.<br />
15 echo &ldquo;Usage: <code>basename $0</code> old_file_suffix new_file_suffix&rdquo;<br />
16 exit $E_BADARGS # 如果只有0个或1个参数,那么就退出.<br />
17 ;;<br />
18 esac<br />
19<br />
20<br />
21 for filename in *.$1<br />
22 # 以第一个参数为扩展名的全部文件的列表<br />
23 do<br />
24 mv $filename ${filename%$1}$2<br />
25 # 从筛选出的文件中先去掉以第一参数结尾的扩展名部门,<br />
26 #+ 然后作为扩展名把第2个参数添加上.<br />
27 done<br />
28<br />
29 exit 0<br />
################################End
Script#########################################</p>

<p>变量扩展/子串替换<br />
这些结构都是从ksh中吸收来的.</p>

<p>${var:pos}<br />
变量var从位置pos开始扩展.</p>

<p>${var:pos:len}<br />
从位置pos开始,并扩展len长度个字符.见Example A-14(这个例子里有这种操作的一个<br />
创造性用法)</p>

<p>${var/Pattern/Replacement}<br />
使用Replacement来替换var中的第一个Pattern的匹配.</p>

<p>${var//Pattern/Replacement}<br />
全局替换.在var中所有的匹配,都会用Replacement来替换.</p>

<p>向上边所说,如果Replacement被忽略的话,那么所有匹配到的Pattern都会被删除.</p>

<p>Example 9-19 使用模式匹配来分析比较特殊的字符串<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 var1=abcd-1234-defg<br />
4 echo &ldquo;var1 = $var1&rdquo;<br />
5<br />
6 t=${var1#<em>-</em>}<br />
7 echo &ldquo;var1 (with everything, up to and including first - stripped out) = $t&rdquo;<br />
8 # t=${var1#*-} 在这个例子中作用是一样的,<br />
9 #+ 因为 # 匹配这个最近的字符串,<br />
10 #+ 并且 * 匹配前边的任何字符串,包括一个空字符.<br />
11 # (Thanks, Stephane Chazelas, for pointing this out.)<br />
12<br />
13 t=${var1##<em>-</em>}<br />
14 echo &ldquo;If var1 contains a \&ldquo;-\&ldquo;, returns empty string&hellip; var1 = $t&rdquo;<br />
15<br />
16<br />
17 t=${var1%<em>-</em>}<br />
18 echo &ldquo;var1 (with everything from the last - on stripped out) = $t&rdquo;<br />
19<br />
20 echo<br />
21<br />
22 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
23 path_name=/home/bozo/ideas/thoughts.for.today<br />
24 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
25 echo &ldquo;path_name = $path_name&rdquo;<br />
26 t=${path_name##/<em>/}<br />
27 echo &ldquo;path_name, stripped of prefixes = $t&rdquo;<br />
28 # 在这个特定的例子中,与 t=<code>basename $path_name</code> 的作用一致.<br />
29 # t=${path_name%/}; t=${t##</em>/} 是一个更一般的解决办法,<br />
30 #+ 但有时还是不行.<br />
31 # 如果 $path_name 以一个新行结束, 那么<code>basename $path_name</code> 将不能工作,<br />
32 #+ 但是上边这个表达式可以.<br />
33 # (Thanks, S.C.)<br />
34<br />
35 t=${path_name%/<em>.</em>}<br />
36 # 与 t=<code>dirname $path_name</code> 效果相同.<br />
37 echo &ldquo;path_name, stripped of suffixes = $t&rdquo;<br />
38 # 在某些情况下将失效,比如 &ldquo;../&rdquo;, &ldquo;/foo////&rdquo;, # &ldquo;foo/&rdquo;, &ldquo;/&rdquo;.<br />
39 # 删除后缀,尤其是在basename没有后缀的时候,<br />
40 #+ 但是dirname还是会使问题复杂化.<br />
41 # (Thanks, S.C.)<br />
42<br />
43 echo<br />
44<br />
45 t=${path_name:11}<br />
46 echo &ldquo;$path_name, with first 11 chars stripped off = $t&rdquo;<br />
47 t=${path_name:11:5}<br />
48 echo &ldquo;$path_name, with first 11 chars stripped off, length 5 = $t&rdquo;<br />
49<br />
50 echo<br />
51<br />
52 t=${path_name/bozo/clown}<br />
53 echo &ldquo;$path_name with \&ldquo;bozo\&rdquo; replaced by \&ldquo;clown\&rdquo; = $t&rdquo;<br />
54 t=${path_name/today/}<br />
55 echo &ldquo;$path_name with \&ldquo;today\&rdquo; deleted = $t&rdquo;<br />
56 t=${path_name//o/O}<br />
57 echo &ldquo;$path_name with all o&rsquo;s capitalized = $t&rdquo;<br />
58 t=${path_name//o/}<br />
59 echo &ldquo;$path_name with all o&rsquo;s deleted = $t&rdquo;<br />
60<br />
61 exit 0<br />
################################End
Script#########################################</p>

<p>${var/#Pattern/Replacement}<br />
如果var的前缀匹配到了Pattern,那么就用Replacement来替换Pattern.</p>

<p>${var/%Pattern/Replacement}<br />
如果var的后缀匹配到了Pattern,那么就用Replacement来替换Pattern.</p>

<p>Example 9-20 对字符串的前缀或后缀使用匹配模式<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # var-match.sh:<br />
3 # 对字符串的前后缀使用匹配替换的一个样本<br />
4<br />
5 v0=abc1234zip1234abc # 原始变量.<br />
6 echo &ldquo;v0 = $v0&rdquo; # abc1234zip1234abc<br />
7 echo<br />
8<br />
9 # 匹配字符串的前缀<br />
10 v1=${v0/#abc/ABCDEF} # abc1234zip1234abc<br />
11 # |-|<br />
12 echo &ldquo;v1 = $v1&rdquo; # ABCDEF1234zip1234abc<br />
13 # |&mdash;-|<br />
14<br />
15 # 匹配字符串的后缀<br />
16 v2=${v0/%abc/ABCDEF} # abc1234zip123abc<br />
17 # |-|<br />
18 echo &ldquo;v2 = $v2&rdquo; # abc1234zip1234ABCDEF<br />
19 # |&mdash;-|<br />
20<br />
21 echo<br />
22<br />
23 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
24 # 必须在开头或结尾匹配,否则,<br />
25 #+ 将不会产生替换结果.<br />
26 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
27 v3=${v0/#<sup>123</sup>&frasl;<sub>000</sub>} # 匹配上了,但不是在字符串的开头<br />
28 echo &ldquo;v3 = $v3&rdquo; # abc1234zip1234abc<br />
29 # 没替换.<br />
30 v4=${v0/%<sup>123</sup>&frasl;<sub>000</sub>} # 匹配上了,但不是在字符串结尾.<br />
31 echo &ldquo;v4 = $v4&rdquo; # abc1234zip1234abc<br />
32 # 没替换.<br />
33<br />
34 exit 0<br />
################################End
Script#########################################</p>

<p>${!varprefix<em>}, ${!varprefix@}<br />
使用变量的前缀来匹配前边所有声明过的变量.<br />
1 xyz23=whatever<br />
2 xyz24=<br />
3<br />
4 a=${!xyz</em>} # 以&rdquo;xyz&rdquo;作为前缀,匹配所有前边声明过的变量.<br />
5 echo &ldquo;a = $a&rdquo; # a = xyz23 xyz24<br />
6 a=${!xyz@} # 同上.<br />
7 echo &ldquo;a = $a&rdquo; # a = xyz23 xyz24<br />
8<br />
9 # Bash, version 2.04, 添加了这个特征.</p>

<p>注意事项:<br />
[1] 如果在一个非交互脚本中,$parameter为空的话,那么这个脚本将以127返回.<br />
(127退出码对应的Bash错误码为&rdquo;command not found&rdquo;).</p>

<p>9.4 指定类型的变量:declare或者typeset<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
declare或者typeset内建命令(这两个命令是完全一样的)允许指定变量的具体类型.在某些特<br />
定的语言中,这是一种指定类型的很弱的形式.declare命令是在Bash版本2或之后的版本才被<br />
加入的.typeset命令也可以工作在ksh脚本中.</p>

<p>declare/typeset 选项</p>

<p>-r 只读<br />
1 declare -r var1<br />
(declare -r var1与readonly var1是完全一样的)<br />
这和C语言中的const关键字一样,都是强制指定只读.如果你尝试修改一个只读变量<br />
的值,那么你将得到一个错误消息.</p>

<p>-i 整形<br />
1 declare -i number<br />
2 # 这个脚本将把变量&rdquo;number&rdquo;后边的赋值视为一个整形.<br />
3<br />
4 number=3<br />
5 echo &ldquo;Number = $number&rdquo; # Number = 3<br />
6<br />
7 number=three<br />
8 echo &ldquo;Number = $number&rdquo; # Number = 0<br />
9 # 尝试把&rdquo;three&rdquo;解释为整形.</p>

<p>如果把一个变量指定为整形,那么即使没有expr和let命令,也允许使用特定的算术运算<br />
1 n=<sup>6</sup>&frasl;<sub>3</sub><br />
2 echo &ldquo;n = $n&rdquo; # n = <sup>6</sup>&frasl;<sub>3</sub><br />
3<br />
4 declare -i n<br />
5 n=<sup>6</sup>&frasl;<sub>3</sub><br />
6 echo &ldquo;n = $n&rdquo; # n = 2</p>

<p>-a 数组<br />
1 declae -a indices<br />
变量indices将被视为数组.</p>

<p>-f 函数<br />
1 declare -f<br />
如果使用declare -f而不带参数的话,将会列出这个脚本中之前定义的所有函数.<br />
1 declare -f function_name<br />
如果使用declare -f function_name这种形式的话,将只会列出这个函数的名字.</p>

<p>-x export<br />
1 declare -x var3<br />
这种使用方式,将会把var3 export出来.</p>

<p>Example 9-21 使用declare来指定变量的类型<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 func1 ()<br />
4 {<br />
5 echo This is a function.<br />
6 }<br />
7<br />
8 declare -f # 列出之前的所有函数.<br />
9<br />
10 echo<br />
11<br />
12 declare -i var1 # var1 是个整形.<br />
13 var1=2367<br />
14 echo &ldquo;var1 declared as $var1&rdquo;<br />
15 var1=var1+1 # 变量声明不需使用&rsquo;let&rsquo;命令.<br />
16 echo &ldquo;var1 incremented by 1 is $var1.&rdquo;<br />
17 # 尝试将变量修改为整形.<br />
18 echo &ldquo;Attempting to change var1 to floating point value, 2367.1.&rdquo;<br />
19 var1=2367.1 # 结果将是一个错误消息,并且变量并没有被修改.<br />
20 echo &ldquo;var1 is still $var1&rdquo;<br />
21<br />
22 echo<br />
23<br />
24 declare -r var2=13.36 # &lsquo;declare&rsquo; 允许设置变量的属性,<br />
25 #+ 并且同时分配变量的值.<br />
26 echo &ldquo;var2 declared as $var2&rdquo; # 尝试修改只读变量.<br />
27 var2=13.37 # 产生一个错误消息,并且从脚本退出了.<br />
28<br />
29 echo &ldquo;var2 is still $var2&rdquo; # 这行将不会被执行.<br />
30<br />
31 exit 0 # 脚本将不会在此处退出.<br />
################################End
Script#########################################</p>

<p>注意:使用declare内建命令将会限制变量的作用域.<br />
1 foo ()<br />
2 {<br />
3 FOO=&ldquo;bar&rdquo;<br />
4 }<br />
5<br />
6 bar ()<br />
7 {<br />
8 foo<br />
9 echo $FOO<br />
10 }<br />
11<br />
12 bar # Prints bar.</p>

<p>然而&hellip;<br />
1 foo (){<br />
2 declare FOO=&ldquo;bar&rdquo;<br />
3 }<br />
4<br />
5 bar ()<br />
6 {<br />
7 foo<br />
8 echo $FOO<br />
9 }<br />
10<br />
11 bar # Prints nothing.<br />
12<br />
13<br />
14 # Thank you, Michael Iatrou, for pointing this out.</p>

<p>9.5 变量的间接引用<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
假设一个变量的值是另一个变量的名字.我们有可能从第一个变量中取得第2个变量的值么?<br />
比如,如果a=letter_of_alphabet接着letter_of_alphabet=z,那么我们能从a中得到z么?<br />
答案是:当然可以,并且这被称为间接引用.它使用一个不常用的符号eval var1=\$$var2.</p>

<p>Example 9-22 间接引用<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # ind-ref.sh: 间接变量引用<br />
3 # 存取一个变量的值的值(这里翻译得有点拗口,不过凑合吧)<br />
4<br />
5 a=letter_of_alphabet # 变量&rdquo;a&rdquo;的值是另一个变量的名字.<br />
6 letter_of_alphabet=z<br />
7<br />
8 echo<br />
9<br />
10 # 直接引用.<br />
11 echo &ldquo;a = $a&rdquo; # a = letter_of_alphabet<br />
12<br />
13 # 间接引用.<br />
14 eval a=\$$a<br />
15 echo &ldquo;Now a = $a&rdquo; # Now a = z<br />
16<br />
17 echo<br />
18<br />
19<br />
20 # 现在,让我们试试修改第2个引用的值.<br />
21<br />
22 t=table_cell_3<br />
23 table_cell_3=24<br />
24 echo &ldquo;\&ldquo;table_cell_3\&rdquo; = $table_cell_3&rdquo; # &ldquo;table_cell_3&rdquo; = 24<br />
25 echo -n &ldquo;dereferenced \&ldquo;t\&rdquo; = &ldquo;; eval echo \$$t # 解引用 &ldquo;t&rdquo; = 24<br />
26 # 在这个简单的例子中,下边的表达式也能正常工作(为什么?).<br />
27 # eval t=\$$t; echo &ldquo;\&ldquo;t\&rdquo; = $t&rdquo;<br />
28<br />
29 echo<br />
30<br />
31 t=table_cell_3<br />
32 NEW_VAL=387<br />
33 table_cell_3=$NEW_VAL<br />
34 echo &ldquo;Changing value of \&ldquo;table_cell_3\&rdquo; to $NEW_VAL.&rdquo;<br />
35 echo &ldquo;\&ldquo;table_cell_3\&rdquo; now $table_cell_3&rdquo;<br />
36 echo -n &ldquo;dereferenced \&ldquo;t\&rdquo; now &ldquo;; eval echo \$$t<br />
37 # &ldquo;eval&rdquo; 将获得两个参数 &ldquo;echo&rdquo; 和 &ldquo;\$$t&rdquo; (与$table_cell_3等价)<br />
38<br />
39 echo<br />
40<br />
41 # (Thanks, Stephane Chazelas, 澄清了上边的行为.)<br />
42<br />
43<br />
44 # 另一个方法是使用${!t}符号,见&rdquo;Bash, 版本2&rdquo;小节.<br />
45 # 也请参阅ex78.sh.<br />
46<br />
47 exit 0<br />
################################End
Script#########################################<br />
间接应用到底有什么应用价值?它给Bash添加了一种类似于C语言指针的功能,在Example 34-3<br />
中有例子.并且,还有一些其它的有趣的应用&hellip;.</p>

<p>Nils Radtke展示了如何建立一个&rdquo;dynamic&rdquo;变量名字并且取出其中的值.当sourcing(包含)配置<br />
文件时,这很有用.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3<br />
4 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
5 # 这部分内容可能来自于单独的文件.<br />
6 isdnMyProviderRemoteNet=172.16.0.100<br />
7 isdnYourProviderRemoteNet=10.0.0.10<br />
8 isdnOnlineService=&ldquo;MyProvider&rdquo;<br />
9 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
10<br />
11<br />
12 remoteNet=$(eval &ldquo;echo \$$(echo isdn${isdnOnlineService}RemoteNet)&ldquo;)<br />
13 remoteNet=$(eval &ldquo;echo \$$(echo isdnMyProviderRemoteNet)&ldquo;)<br />
14 remoteNet=$(eval &ldquo;echo \$isdnMyProviderRemoteNet&rdquo;)<br />
15 remoteNet=$(eval &ldquo;echo $isdnMyProviderRemoteNet&rdquo;)<br />
16<br />
17 echo &ldquo;$remoteNet&rdquo; # 172.16.0.100<br />
18<br />
19 # ================================================================<br />
20<br />
21 # 同时,它甚至能更好.<br />
21 #<br />
22<br />
23 # 考虑下边的脚本,给出了一个变量getSparc,<br />
24 #+ 但是没给出变量getIa64:<br />
25<br />
26 chkMirrorArchs () {<br />
27 arch=&ldquo;$1&rdquo;;<br />
28 if [ &ldquo;$(eval &ldquo;echo \${$(echo get$(echo -ne $arch |<br />
29 sed &rsquo;s/^\(.\).<em>/\1/g&rsquo; | tr &lsquo;a-z&rsquo; &lsquo;A-Z&rsquo;; echo $arch |<br />
30 sed &rsquo;s/^.\(.</em>\)/\1/g&rsquo;)):-false}&ldquo;)&rdquo; = true ]<br />
31 then<br />
32 return 0;<br />
33 else<br />
34 return 1;<br />
35 fi;<br />
36 }<br />
37<br />
38 getSparc=&ldquo;true&rdquo;<br />
39 unset getIa64<br />
40 chkMirrorArchs sparc<br />
41 echo $? # 0<br />
42 # True<br />
43<br />
44 chkMirrorArchs Ia64<br />
45 echo $? # 1<br />
46 # False<br />
47<br />
48 # 注意:<br />
49 # &mdash;&ndash;<br />
50 # Even the to-be-substituted variable name part is built explicitly.<br />
51 # The parameters to the chkMirrorArchs calls are all lower case.<br />
52 # The variable name is composed of two parts: &ldquo;get&rdquo; and &ldquo;Sparc&rdquo; &hellip;<br />
################################End
Script#########################################</p>

<p>Example 9-23 传递一个间接引用给awk<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # &ldquo;column totaler&rdquo;脚本的另一个版本<br />
4 #+ 这个版本在目标文件中添加了一个特殊的列(数字的).<br />
5 # 这个脚本使用了间接引用.<br />
6<br />
7 ARGS=2<br />
8 E_WRONGARGS=65<br />
9<br />
10 if [ $# -ne &ldquo;$ARGS&rdquo; ] # 检查命令行参数是否是合适的个数.<br />
11 then<br />
12 echo &ldquo;Usage: <code>basename $0</code> filename column-number&rdquo;<br />
13 exit $E_WRONGARGS<br />
14 fi<br />
15<br />
16 filename=$1<br />
17 column_number=$2<br />
18<br />
19 #===== 上边的这部分,与原来的脚本一样 =====#<br />
20<br />
21<br />
22 # 一个多行的awk脚本被调用,通过 &lsquo; &hellip;.. &rsquo;<br />
23<br />
24<br />
25 # awk 脚本开始.<br />
26 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
27 awk &ldquo;<br />
28<br />
29 { total += \$${column_number} # 间接引用.<br />
30 }<br />
31 END {<br />
32 print total<br />
33 }<br />
34<br />
35 &ldquo; &ldquo;$filename&rdquo;<br />
36 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
37 # awk 脚本结束.<br />
38<br />
39 # 间接的变量引用避免了在一个内嵌的awk脚本中引用<br />
40 #+ 一个shell变量的问题.<br />
41 # Thanks, Stephane Chazelas.<br />
42<br />
43<br />
44 exit 0<br />
################################End
Script#########################################<br />
注意: 这个脚本有些狡猾.如果第2个变量修改了它的值,那么第一个变量必须被适当的解引用<br />
(像上边的例子一样).幸运的是,在Bash版本2中引入的${!variable}(参见Example 34-2)<br />
是的间接引用更加直观了.</p>

<p>注意: Bash并不支持指针的算术运算,并且这严格的限制了间接引用的使用.事实上,在脚本语言<br />
中,间接引用本来就是丑陋的部分.</p>

<p>9.6 $RANDOM: 产生随机整数<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
$RANDOM是Bash的内部函数(并不是常量),这个函数将返回一个范围在0 - 32767之间的一个伪<br />
随机整数.它不应该被用来产生密匙.</p>

<p>Example 9-24 产生随机数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # $RANDOM 在每次调用的时候,返回一个不同的随机整数.<br />
4 # 指定的范围是: 0 - 32767 (有符号的16-bit 整数).<br />
5<br />
6 MAXCOUNT=10<br />
7 count=1<br />
8<br />
9 echo<br />
10 echo &ldquo;$MAXCOUNT random numbers:&rdquo;<br />
11 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
12 while [ &ldquo;$count&rdquo; -le $MAXCOUNT ] # 产生10 ($MAXCOUNT) 个随机整数.<br />
13 do<br />
14 number=$RANDOM<br />
15 echo $number<br />
16 let &ldquo;count += 1&rdquo; # 数量加1.<br />
17 done<br />
18 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
19<br />
20 # 如果你需要在一个特定范围内产生一个随机int,那么使用&rsquo;modulo&rsquo;(模)操作.<br />
21 # 这将返回一个除法操作的余数.<br />
22<br />
23 RANGE=500<br />
24<br />
25 echo<br />
26<br />
27 number=$RANDOM<br />
28 let &ldquo;number %= $RANGE&rdquo;<br />
29 # ^^<br />
30 echo &ldquo;Random number less than $RANGE &mdash; $number&rdquo;<br />
31<br />
32 echo<br />
33<br />
34<br />
35<br />
36 # 如果你需要产生一个比你指定的最小边界大的随机数,<br />
37 #+ 那么建立一个test循环,来丢弃所有产生对比这个数小的随机数.<br />
38<br />
39 FLOOR=200<br />
40<br />
41 number=0 #initialize<br />
42 while [ &ldquo;$number&rdquo; -le $FLOOR ]<br />
43 do<br />
44 number=$RANDOM<br />
45 done<br />
46 echo &ldquo;Random number greater than $FLOOR &mdash; $number&rdquo;<br />
47 echo<br />
48<br />
49 # 让我们对上边的循环尝试一个小改动,也就是<br />
50 # 让&rdquo;number = $RANDOM + $FLOOR&rdquo;<br />
51 # 这将不再需要那个while循环,并且能够运行得更快.<br />
52 # 但是, 这可能会产生一个问题.那么这个问题是什么呢?(译者:这很简单,有可能溢出)<br />
53<br />
54<br />
55<br />
56 # 结合上边两个例子的技术,来达到获得在指定的上下限之间来产生随机数.<br />
57 number=0 #initialize<br />
58 while [ &ldquo;$number&rdquo; -le $FLOOR ]<br />
59 do<br />
60 number=$RANDOM<br />
61 let &ldquo;number %= $RANGE&rdquo; # 让$number依比例落在$RANGE范围内.<br />
62 done<br />
63 echo &ldquo;Random number between $FLOOR and $RANGE &mdash; $number&rdquo;<br />
64 echo<br />
65<br />
66<br />
67<br />
68 # 产生一个二元选择,就是&rdquo;true&rdquo;和&rdquo;false&rdquo;两个值.<br />
69 BINARY=2<br />
70 T=1<br />
71 number=$RANDOM<br />
72<br />
73 let &ldquo;number %= $BINARY&rdquo;<br />
74 # 注意,让&rdquo;number &gt;&gt;= 14&rdquo; 将给出一个更好的随机分配<br />
75 #+ (右移14位将把所有为全部清空,除了第15位,因为有符号,所以第16位是符号位).<br />
76 if [ &ldquo;$number&rdquo; -eq $T ]<br />
77 then<br />
78 echo &ldquo;TRUE&rdquo;<br />
79 else<br />
80 echo &ldquo;FALSE&rdquo;<br />
81 fi<br />
82<br />
83 echo<br />
84<br />
85<br />
86 # 抛骰子<br />
87 SPOTS=6 # 模6给出的范围就是0-5.<br />
88 # 加1就会得到期望的范围1 - 6.<br />
89 # Thanks, Paulo Marcel Coelho Aragao, for the simplification.<br />
90 die1=0<br />
91 die2=0<br />
92 # 是否让SPOTS=7比加1更好呢?解释行或者不行的原因?<br />
93<br />
94 # 每次抛骰子,都会给出均等的机会.<br />
95<br />
96 let &ldquo;die1 = $RANDOM % $SPOTS +1&rdquo; # 抛第一次.<br />
97 let &ldquo;die2 = $RANDOM % $SPOTS +1&rdquo; # 抛第二次.<br />
98 # 上边的那个算术操作,具有更高的优先级呢 &ndash;<br />
99 #+ 模操作(%)还是加法操作(+)?<br />
100<br />
101<br />
102 let &ldquo;throw = $die1 + $die2&rdquo;<br />
103 echo &ldquo;Throw of the dice = $throw&rdquo;<br />
104 echo<br />
105<br />
106<br />
107 exit 0<br />
################################End
Script#########################################</p>

<p>Example 9-25 从一副扑克牌中取出一张随机的牌<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # pick-card.sh<br />
3<br />
4 # 这是一个从数组中取出随机元素的一个例子.<br />
5<br />
6<br />
7 # 取出一张牌,任何一张.<br />
8<br />
9 Suites=&ldquo;Clubs<br />
10 Diamonds<br />
11 Hearts<br />
12 Spades&rdquo;<br />
13<br />
14 Denominations=&ldquo;2<br />
15 3<br />
16 4<br />
17 5<br />
18 6<br />
19 7<br />
20 8<br />
21 9<br />
22 10<br />
23 Jack<br />
24 Queen<br />
25 King<br />
26 Ace&rdquo;<br />
27<br />
28 # 注意变量的多行展开.<br />
29<br />
30<br />
31 suite=($Suites) # 读到数组变量中.<br />
32 denomination=($Denominations)<br />
33<br />
34 num_suites=${#suite[<em>]} # 计算有多少个元素.<br />
35 num_denominations=${#denomination[</em>]}<br />
36<br />
37 echo -n &ldquo;${denomination[$((RANDOM%num_denominations))]} of &ldquo;<br />
38 echo ${suite[$((RANDOM%num_suites))]}<br />
39<br />
40<br />
41 # $bozo sh pick-cards.sh<br />
42 # Jack of Clubs<br />
43<br />
44<br />
45 # Thank you, &ldquo;jipe,&rdquo; for pointing out this use of $RANDOM.<br />
46 exit 0<br />
################################End
Script#########################################</p>

<p>Jipe展示了一系列的在一定范围中产生随机数的方法.<br />
1 # 在6到30之间产生随机数.<br />
2 rnumber=$((RANDOM%25+6))<br />
3<br />
4 # 还是产生6-30之间的随机数,<br />
5 #+ 但是这个数字必须被3均分.<br />
6 rnumber=$(((RANDOM%<sup>30</sup>&frasl;<sub>3</sub>+1)*3))<br />
7<br />
8 # 注意,这可能不会在所有时候都能正常地运行.<br />
9 # It fails if $RANDOM returns 0.<br />
10<br />
11 # Frank Wang 建议用下班的方法来取代:<br />
12 rnumber=$(( RANDOM%<sup>27</sup>&frasl;<sub>3</sub>*3+6 ))</p>

<p>Bill Gradwohl 提出了一个重要的规则来产生正数.<br />
1 rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))</p>

<p>这里Bill给出了一个通用函数,这个函数返回一个在两个指定值之间的随机数</p>

<p>Example 9-26 两个指定值之间的随机数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # random-between.sh<br />
3 # 在两个指定值之间的随机数.<br />
4 # Bill Gradwohl编写的本脚本,本文作者作了较小的修改.<br />
5 # 允许使用.<br />
6<br />
7<br />
8 randomBetween() {<br />
9 # 产生一个正的或者负的随机数.<br />
10 #+ 在$max和$max之间<br />
11 #+ 并且可被$divisibleBy整除的.<br />
12 # 给出一个合理的随机分配的返回值.<br />
13 #<br />
14 # Bill Gradwohl - Oct 1, 2003<br />
15<br />
16 syntax() {<br />
17 # 在函数中内嵌函数<br />
18 echo<br />
19 echo &ldquo;Syntax: randomBetween [min] [max] [multiple]&rdquo;<br />
20 echo<br />
21 echo &ldquo;Expects up to 3 passed parameters, but all are completely optional.&rdquo;<br />
22 echo &ldquo;min is the minimum value&rdquo;<br />
23 echo &ldquo;max is the maximum value&rdquo;<br />
24 echo &ldquo;multiple specifies that the answer must be a multiple of this value.&rdquo;<br />
25 echo &ldquo; i.e. answer must be evenly divisible by this number.&rdquo;<br />
26 echo<br />
27 echo &ldquo;If any value is missing, defaults area supplied as: 0 32767 1&rdquo;<br />
28 echo &ldquo;Successful completion returns 0, unsuccessful completion returns&rdquo;<br />
29 echo &ldquo;function syntax and 1.&rdquo;<br />
30 echo &ldquo;The answer is returned in the global variable randomBetweenAnswer&rdquo;<br />
31 echo &ldquo;Negative values for any passed parameter are handled correctly.&rdquo;<br />
32 }<br />
33<br />
34 local min=${1:-0}<br />
35 local max=${2:-32767}<br />
36 local divisibleBy=${3:-1}<br />
37 # 默认值分配,用来处理没有参数传递进来的时候.<br />
38<br />
39 local x<br />
40 local spread<br />
41<br />
42 # 确认divisibleBy是正值.<br />
43 [ ${divisibleBy} -lt 0 ] &amp;&amp; divisibleBy=$((0-divisibleBy))<br />
44<br />
45 # 完整性检查.<br />
46 if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o ${min} -eq ${max} ]; then<br />
47 syntax<br />
48 return 1<br />
49 fi<br />
50<br />
51 # 察看是否min和max颠倒了.<br />
52 if [ ${min} -gt ${max} ]; then<br />
53 # 交换它们.<br />
54 x=${min}<br />
55 min=${max}<br />
56 max=${x}<br />
57 fi<br />
58<br />
59 # 如果min自己并不能够被$divisibleBy整除,<br />
60 #+ 那么就调整min的值,使其能够被$divisibleBy整除,前提是不能放大范围.<br />
61 if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then<br />
62 if [ ${min} -lt 0 ]; then<br />
63 min=$((min/divisibleBy*divisibleBy))<br />
64 else<br />
65 min=$((((min/divisibleBy)+1)*divisibleBy))<br />
66 fi<br />
67 fi<br />
68<br />
69 # 如果min自己并不能够被$divisibleBy整除,<br />
70 #+ 那么就调整max的值,使其能够被$divisibleBy整除,前提是不能放大范围.<br />
71 if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then<br />
72 if [ ${max} -lt 0 ]; then<br />
73 max=$((((max/divisibleBy)-1)*divisibleBy))<br />
74 else<br />
75 max=$((max/divisibleBy*divisibleBy))<br />
76 fi<br />
77 fi<br />
78<br />
79 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
80 # 现在,来做真正的工作.<br />
81<br />
82 # 注意,为了得到对于端点来说合适的分配,<br />
83 #+ 随机值的范围不得不落在<br />
84 #+ 0 和 abs(max-min)+divisibleBy之间, 而不是 abs(max-min)+1.<br />
85<br />
86 # 对于端点来说,<br />
87 #+ 这个少量的增加将会产生合适的分配.<br />
88<br />
89 # 修改这个公式,使用abs(max-min)+1来代替abs(max-min)+divisibleBy的话,<br />
90 #+ 也能够产生正确的答案, 但是在这种情况下生成的随机值对于正好为端点倍数<br />
91 #+ 的这种情况来说将是不完美的,因为在正好为端点倍数的情况的随机率比较低,<br />
92 #+ 因为你才加1而已,这比正常的公式所产生的机率要小得多(正常为加divisibleBy)<br />
93 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
94<br />
95 spread=$((max-min))<br />
96 [ ${spread} -lt 0 ] &amp;&amp; spread=$((0-spread))<br />
97 let spread+=divisibleBy<br />
98 randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))<br />
99<br />
100 return 0<br />
101<br />
102 # 然而,Paulo Marcel Coelho Aragao指出<br />
103 #+ 当$max和$min不能被$divisibleBy整除时,<br />
104 #+ 这个公式将会失败.<br />
105 #<br />
106 # 他建议使用如下的公式:<br />
107 # rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))<br />
108<br />
109 }<br />
110<br />
111 # 让我们测试一下这个函数.<br />
112 min=-14<br />
113 max=20<br />
114 divisibleBy=3<br />
115<br />
116<br />
117 # 产生一个数组answers,answers的下标用来表示在范围内可能出现的值,<br />
118 #+ 而内容记录的是对于这个值出现的次数,如果我们循环足够多次,一定会得到<br />
119 #+ 一次出现机会.<br />
120 declare -a answer<br />
121 minimum=${min}<br />
122 maximum=${max}<br />
123 if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then<br />
124 if [ ${minimum} -lt 0 ]; then<br />
125 minimum=$((minimum/divisibleBy*divisibleBy))<br />
126 else<br />
127 minimum=$((((minimum/divisibleBy)+1)*divisibleBy))<br />
128 fi<br />
129 fi<br />
130<br />
131<br />
132 # 如果maximum自己并不能够被$divisibleBy整除,<br />
133 #+ 那么就调整maximum的值,使其能够被$divisibleBy整除,前提是不能放大范围.<br />
134<br />
135 if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then<br />
136 if [ ${maximum} -lt 0 ]; then<br />
137 maximum=$((((maximum/divisibleBy)-1)*divisibleBy))<br />
138 else<br />
139 maximum=$((maximum/divisibleBy*divisibleBy))<br />
140 fi<br />
141 fi<br />
142<br />
143<br />
144 # 我们需要产生一个下标全为正的数组,<br />
145 #+ 所以我们需要一个displacement来保正都为正的结果.<br />
146<br />
147<br />
148 displacement=$((0-minimum))<br />
149 for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do<br />
150 answer[i+displacement]=0<br />
151 done<br />
152<br />
153<br />
154 # 现在我们循环足够多的次数来得到我们想要的答案.<br />
155 loopIt=1000 # 脚本作者建议 100000,<br />
156 #+ 但是这实在是需要太长的时间了.<br />
157<br />
158 for ((i=0; i 159<br />
160 # 注意,我们在这里调用randomBetween函数时,故意将min和max颠倒顺序<br />
161 #+ 我们是为了测试在这种情况下,此函数是否还能得到正确的结果.<br />
162<br />
163 randomBetween ${max} ${min} ${divisibleBy}<br />
164<br />
165 # 如果答案不是我们所预期的,那么就报告一个错误.<br />
166 [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ]
&amp;&amp; echo MIN or MAX error - ${randomBetweenAnswer}!<br />
167 [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] &amp;&amp; echo DIVISIBLE BY
error - ${randomBetweenAnswer}!<br />
168<br />
169 # 将统计值存到answer之中.<br />
170
answer[randomBetweenAnswer+displacement]=$((answer[randomBetweenAnswer+displacement]+1))<br />
171 done<br />
172<br />
173<br />
174<br />
175 # 让我们察看一下结果<br />
176<br />
177 for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do<br />
178 [ ${answer[i+displacement]} -eq 0 ] &amp;&amp; echo &ldquo;We never got an answer of
$i.&rdquo; || echo &ldquo;${i} occurred ${answer[i+displacement]} times.&rdquo;<br />
179 done<br />
180<br />
181<br />
182 exit 0<br />
################################End
Script#########################################</p>

<p>$RANDOM到底有多随机?最好的办法就是写个脚本来测试一下.跟踪随机数的分配情况.<br />
让我们用随机数摇一个骰子.<br />
Example 9-27 使用随机数来摇一个骰子<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # RANDOM到底有多random?<br />
3<br />
4 RANDOM=$$ # 使用脚本的进程ID来作为随机数的产生种子.<br />
5<br />
6 PIPS=6 # 一个骰子有6面.<br />
7 MAXTHROWS=600 # 如果你没别的事干,那么可以增加这个数值.<br />
8 throw=0 # 抛骰子的次数.<br />
9<br />
10 ones=0 # 必须把所有count都初始化为0,<br />
11 twos=0 #+ 因为未初始化的变量为null,不是0.<br />
12 threes=0<br />
13 fours=0<br />
14 fives=0<br />
15 sixes=0<br />
16<br />
17 print_result ()<br />
18 {<br />
19 echo<br />
20 echo &ldquo;ones = $ones&rdquo;<br />
21 echo &ldquo;twos = $twos&rdquo;<br />
22 echo &ldquo;threes = $threes&rdquo;<br />
23 echo &ldquo;fours = $fours&rdquo;<br />
24 echo &ldquo;fives = $fives&rdquo;<br />
25 echo &ldquo;sixes = $sixes&rdquo;<br />
26 echo<br />
27 }<br />
28<br />
29 update_count()<br />
30 {<br />
31 case &ldquo;$1&rdquo; in<br />
32 0) let &ldquo;ones += 1&rdquo;;; # 因为骰子没有0,所以给1.<br />
33 1) let &ldquo;twos += 1&rdquo;;; # 对tows做同样的事.<br />
34 2) let &ldquo;threes += 1&rdquo;;;<br />
35 3) let &ldquo;fours += 1&rdquo;;;<br />
36 4) let &ldquo;fives += 1&rdquo;;;<br />
37 5) let &ldquo;sixes += 1&rdquo;;;<br />
38 esac<br />
39 }<br />
40<br />
41 echo<br />
42<br />
43<br />
44 while [ &ldquo;$throw&rdquo; -lt &ldquo;$MAXTHROWS&rdquo; ]<br />
45 do<br />
46 let &ldquo;die1 = RANDOM % $PIPS&rdquo;<br />
47 update_count $die1<br />
48 let &ldquo;throw += 1&rdquo;<br />
49 done<br />
50<br />
51 print_result<br />
52<br />
53 exit 0<br />
54<br />
55 # 如果RANDOM是真正的随机,那么摇出来结果应该平均的.<br />
56 # $MAXTHROWS设为600,那么每面都应该为100,上下的出入不应该超过20.<br />
57 #<br />
58 # 记住RANDOM毕竟只是一个伪随机数,<br />
59 #+ 并且不是十分完美的.<br />
60<br />
61 # 随机数的产生是一个深奥并复杂的问题.<br />
62 # 足够长的随机序列,不但会展现杂乱无章的一面,<br />
63 #+ 而且会展现机会均等的一面.<br />
64<br />
65 # 一个很简单的练习:<br />
66 # &mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
67 # 重写这个例子,做成抛1000次硬币的形式.<br />
68 # 分为正反两面.<br />
################################End
Script#########################################<br />
像我们在上边的例子中看到的,最好在每次随机数产生时都使用新的种子.应为如果使用同样的<br />
种子的话,那么随机数将产生相同的序列.<a href="C中random()函数也会有这样的行为">2</a></p>

<p>Example 9-28 重新分配随机数种子<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # seeding-random.sh: 设置RANDOM变量作为种子.<br />
3<br />
4 MAXCOUNT=25 # 决定产生多少个随机数.<br />
5<br />
6 random_numbers ()<br />
7 {<br />
8 count=0<br />
9 while [ &ldquo;$count&rdquo; -lt &ldquo;$MAXCOUNT&rdquo; ]<br />
10 do<br />
11 number=$RANDOM<br />
12 echo -n &ldquo;$number &rdquo;<br />
13 let &ldquo;count += 1&rdquo;<br />
14 done<br />
15 }<br />
16<br />
17 echo; echo<br />
18<br />
19 RANDOM=1 # 为随机数的产生设置RANDOM种子.<br />
20 random_numbers<br />
21<br />
22 echo; echo<br />
23<br />
24 RANDOM=1 # 设置同样的种子&hellip;<br />
25 random_numbers # &hellip;将会和上边产生的随机数列相同.<br />
26 #<br />
27 # 复制一个相同的随机数序列在什么时候有用呢?<br />
28<br />
29 echo; echo<br />
30<br />
31 RANDOM=2 # 再试一下,但这次使用不同的种子&hellip;<br />
32 random_numbers # 将给出一个不同的随机数序列.<br />
33<br />
34 echo; echo<br />
35<br />
36 # RANDOM=$$ 使用脚本的进程id 作为随机数的种子.<br />
37 # 从&rsquo;time&rsquo;或&rsquo;date&rsquo;命令中取得RANDOM作为种子也是很常用的办法.<br />
38<br />
39 # 一个有想象力的方法&hellip;<br />
40 SEED=$(head -1 /dev/urandom | od -N 1 | awk &lsquo;{ print $2 }&rsquo;)<br />
41 # 首先从/dev/urandom(系统伪随机设备文件)中取出1行,<br />
42 #+ 然后着这个可打印行转换为(8进制)数,通过使用&rdquo;od&rdquo;命令,<br />
43 #+ 最后使用&rdquo;awk&rdquo;来获得一个数,<br />
44 #+ 这个数将作为随机数产生的种子.<br />
45 RANDOM=$SEED<br />
46 random_numbers<br />
47<br />
48 echo; echo<br />
49<br />
50 exit 0<br />
################################End
Script#########################################<br />
注意:/dev/urandom设备文件提供了一种比单独使用$RANDOM更好的,能产生更&rdquo;随机&rdquo;的随机数<br />
的方法.<br />
dd if=/dev/urandom of=targetfile bs=1 count=XX能够产生一个很分散的为随机数.<br />
然而,将这个数赋值到一个脚本文件的变量中,还需要可操作性,比如使用&rdquo;od&rdquo;命令<br />
(就像上边的例子,见Example 12-13),或者使用dd命令(见Example 12-55),或者管道到<br />
&ldquo;md5sum&rdquo;命令中(见Example 33-14).</p>

<p>当然还有其它的产生伪随机数的方法.Awk就可以提供一个方便的方法.<br />
Example 9-29 使用awk产生伪随机数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # random2.sh: 产生一个范围0 - 1的为随机数.<br />
3 # 使用awk的rand()函数.<br />
4<br />
5 AWKSCRIPT=&rsquo; { srand(); print rand() } &lsquo;<br />
6 # Command(s) / 传到awk中的参数<br />
7 # 注意,srand()函数用来产生awk的随机数种子.<br />
8<br />
9<br />
10 echo -n &ldquo;Random number between 0 and 1 = &rdquo;<br />
11<br />
12 echo | awk &ldquo;$AWKSCRIPT&rdquo;<br />
13 # 如果你省去&rsquo;echo&rsquo;那么将发生什么?<br />
14<br />
15 exit 0<br />
16<br />
17<br />
18 # Exercises:<br />
18 # 练习:<br />
19 # &mdash;&ndash;<br />
20<br />
21 # 1) 使用循环结构,打印出10个不同的随机数.<br />
22 # (提示: 在循环的每次执行过程中,你必须使用&rdquo;srand()&ldquo;函数来生成不同的<br />
23 #+ 种子.如果你没做这件事那么将发生什么?<br />
24<br />
25 # 2) 使用一个整数乘法作为一个放缩因子,在10到100的范围之间,<br />
26 #+ 来产生随机数.<br />
27<br />
28 # 3) 同上边的练习 #2,但这次产生随机整数.<br />
################################End
Script#########################################<br />
&ldquo;data&rdquo;命令也可以用来产生伪随机整数序列.</p>

<p>注意事项:<br />
[1] 真正的随机事件(在它存在的范围内),只发生在特定的几个未知的自然界现象中,比如<br />
放射性衰变.计算机只能产生模拟的随机事件,并且计算机产生的&rdquo;随机&rdquo;数因此只能称<br />
为伪随机数.<br />
[2] 计算机产生的伪随机数序列用的种子可以被看成是一种标识标签.比如,使用种子23所<br />
产生的伪随机数序列就被称作序列#23.</p>

<p>一个伪随机序列的特点就是在这个序列开始重复之前的所有元素的个数的和,也就是<br />
这个序列的长度.一个好的伪随机产生算法将可以产生一个非常长的不重复的序列.</p>

<p>9.7 双圆括号结构<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;<br />
((&hellip;))与let命令很像,允许算术扩展和赋值.举个简单的例子a=$(( 5 + 3 )),将把a设为<br />
&ldquo;5+3&rdquo;或者8.然而,双圆括号也是一种在Bash中允许使用C风格的变量处理的机制.</p>

<p>Example 9-30 C风格的变量处理<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 处理一个变量,C风格,使用((&hellip;))结构.<br />
3<br />
4<br />
5 echo<br />
6<br />
7 (( a = 23 )) # 给一个变量赋值,从&rdquo;=&ldquo;两边的空格就能看出这是c风格的处理.<br />
8 echo &ldquo;a (initial value) = $a&rdquo;<br />
9<br />
10 (( a++ )) # 变量&rsquo;a&rsquo;后加1,C风格.<br />
11 echo &ldquo;a (after a++) = $a&rdquo;<br />
12<br />
13 (( a&ndash; )) # 变量&rsquo;a&rsquo;后减1,C风格.<br />
14 echo &ldquo;a (after a&ndash;) = $a&rdquo;<br />
15<br />
16<br />
17 (( ++a )) # 变量&rsquo;a&rsquo;预加1,C风格.<br />
18 echo &ldquo;a (after ++a) = $a&rdquo;<br />
19<br />
20 (( &ndash;a )) # 变量&rsquo;a&rsquo;预减1,C风格.<br />
21 echo &ldquo;a (after &ndash;a) = $a&rdquo;<br />
22<br />
23 echo<br />
24<br />
25 ########################################################<br />
26 # 注意:在C语言中,预减和后减操作<br />
27 #+ 会有些不同的副作用.<br />
28<br />
29 n=1; let &ndash;n &amp;&amp; echo &ldquo;True&rdquo; || echo &ldquo;False&rdquo; # False<br />
30 n=1; let n&ndash; &amp;&amp; echo &ldquo;True&rdquo; || echo &ldquo;False&rdquo; # True<br />
31<br />
32 # Thanks, Jeroen Domburg.<br />
33 ########################################################<br />
34<br />
35 echo<br />
36<br />
37 (( t = a&lt;45?7:11 )) # C风格的3元操作.<br />
38 echo &ldquo;If a &lt; 45, then t = 7, else t = 11.&rdquo;<br />
39 echo &ldquo;t = $t &rdquo; # Yes!<br />
40<br />
41 echo<br />
42<br />
43<br />
44 # &mdash;&mdash;&mdash;&mdash;&mdash;-<br />
45 # 复活节彩蛋注意!<br />
46 # &mdash;&mdash;&mdash;&mdash;&mdash;-<br />
47 # Chet Ramey 显然的偷偷摸摸的做了一些未公开的C风格的结构<br />
48 #+ 放在Bash中(准确地说是根据ksh来改写的,这更接近些)<br />
49 # 在Bash文档中,Ramey调用((&hellip;))shell算法,<br />
50 #+ 但是它可以走得更远.<br />
51 # 对不起, Chet, 现在秘密被公开了.<br />
52<br />
53 # See also &ldquo;for&rdquo; and &ldquo;while&rdquo; loops using the ((&hellip;)) construct.<br />
53 # 也参考一些&rdquo;for&rdquo;和&rdquo;while&rdquo;循环中使用((&hellip;))结构的例子.<br />
54<br />
55 # 这些只能工作在2.04或者更高版本的Bash中.<br />
56<br />
57 exit 0<br />
################################End
Script#########################################<br />
见Example 10-12.</p>

<h1 id="第10章-循环和分支">第10章 循环和分支</h1>

<p>对代码块进行操作是有组织的结构化的shell脚本的关键.为了达到这个目的,循环和分支提供<br />
帮助.</p>

<p>10.1 循环<br />
-&mdash;&mdash;&ndash;<br />
循环就是重复一些命令的代码块,如果条件不满足就退出循环.</p>

<p>for loops</p>

<p>for arg in [list]<br />
这是一个基本的循环结构.它与C的相似结构有很大不同.</p>

<p>for arg in [list]<br />
do<br />
command(s)&hellip;<br />
done</p>

<p>注意:在循环的每次执行中,arg将顺序的存取list中列出的变量.<br />
1 for arg in &ldquo;$var1&rdquo; &ldquo;$var2&rdquo; &ldquo;$var3&rdquo; &hellip; &ldquo;$varN&rdquo;<br />
2 # 在第1次循环中, arg = $var1<br />
3 # 在第2次循环中, arg = $var2<br />
4 # 在第3次循环中, arg = $var3<br />
5 # &hellip;<br />
6 # 在第n次循环中, arg = $varN<br />
7<br />
8 # 在[list]中的参数加上双引号是为了阻止单词分离.</p>

<p>list中的参数允许包含通配符.<br />
如果do和for想在同一行出现,那么在它们之间需要添加一个&rdquo;;&ldquo;.<br />
for arg in [list]; do</p>

<p>Example 10-1 循环的一个简单例子<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 列出所有行星.<br />
3<br />
4 for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto<br />
5 do<br />
6 echo $planet # Each planet on a separate line.<br />
7 done<br />
8<br />
9 echo<br />
10<br />
11 for planet in &ldquo;Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune
Pluto&rdquo;<br />
12 # 所有的行星都在同一行上.<br />
13 # 完整的&rsquo;list&rsquo;作为一个变量都封在&rdquo;&ldquo;中<br />
14 do<br />
15 echo $planet<br />
16 done<br />
17<br />
18 exit 0<br />
################################End
Script#########################################</p>

<p>注意:每个[list]中的元素都可能包含多个参数.在处理参数组时,这是非常有用的.<br />
在这种情况下,使用set命令(见Example 11-15)来强制解析每个[list]中的元素,<br />
并且分配每个解析出来的部分到一个位置参数中.</p>

<p>Example 10-2 每个[list]元素带两个参数的for循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 还是行星.<br />
3<br />
4 # 分配行星的名字和它距太阳的距离.<br />
5<br />
6 for planet in &ldquo;Mercury 36&rdquo; &ldquo;Venus 67&rdquo; &ldquo;Earth 93&rdquo; &ldquo;Mars 142&rdquo; &ldquo;Jupiter 483&rdquo;<br />
7 do<br />
8 set &ndash; $planet # 解析变量&rdquo;planet&rdquo;并且设置位置参数.<br />
9 # &ldquo;&ndash;&rdquo; 将防止$planet为空,或者是以一个破折号开头.<br />
10<br />
11 # 可能需要保存原始的位置参数,因为它们被覆盖了.<br />
12 # 一种方法就是使用数组,<br />
13 # original_params=(&ldquo;$@&rdquo;)<br />
14<br />
15 echo &ldquo;$1 $2,000,000 miles from the sun&rdquo;<br />
16 #&mdash;&mdash;-two tabs&mdash;把后边的0和$2连接起来<br />
17 done<br />
18<br />
19 # (Thanks, S.C., for additional clarification.)<br />
20<br />
21 exit 0<br />
################################End
Script#########################################</p>

<p>可以在for循环中的[list]位置放入一个变量</p>

<p>Example 10-3 文件信息:对包含在变量中的文件列表进行操作<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # fileinfo.sh<br />
3<br />
4 FILES=&ldquo;/usr/sbin/accept<br />
5 /usr/sbin/pwck<br />
6 /usr/sbin/chroot<br />
7 /usr/bin/fakefile<br />
8 /sbin/badblocks<br />
9 /sbin/ypbind&rdquo; # 你关心的文件列表.<br />
10 # 扔进去一个假文件, /usr/bin/fakefile.<br />
11<br />
12 echo<br />
13<br />
14 for file in $FILES<br />
15 do<br />
16<br />
17 if [ ! -e &ldquo;$file&rdquo; ] # 检查文件是否存在.<br />
18 then<br />
19 echo &ldquo;$file does not exist.&rdquo;; echo<br />
20 continue # 继续下一个.<br />
21 fi<br />
22<br />
23 ls -l $file | awk &lsquo;{ print $9 &ldquo; file size: &ldquo; $5 }&rsquo; # 打印2个域.<br />
24 whatis <code>basename $file</code> # 文件信息.<br />
25 # 注意whatis数据库需要提前建立好.<br />
26 # 要想达到这个目的, 以root身份运行/usr/bin/makewhatis.<br />
27 echo<br />
28 done<br />
29<br />
30 exit 0<br />
################################End
Script#########################################</p>

<p>如果在for循环的[list]中有通配符(*和?),那将会产生文件名扩展,也就是file globbing.<br />
Example 10-4 在for循环中操作文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # list-glob.sh: 产生 [list] 在for循环中, 使用 &ldquo;globbing&rdquo;<br />
3<br />
4 echo<br />
5<br />
6 for file in *<br />
7 # ^ 在表达式中识别file globbing时,<br />
8 #+ Bash 将执行文件名扩展<br />
9 do<br />
10 ls -l &ldquo;$file&rdquo; # 列出所有在$PWD(当前目录)中的所有文件.<br />
11 # 回想一下,通配符&rdquo;<em>&ldquo;能够匹配所有文件,<br />
12 #+ 然而,在&rdquo;globbing&rdquo;中,是不能比配&rdquo;.&ldquo;文件的.<br />
13<br />
14 # If the pattern matches no file, it is expanded to itself.<br />
14 # 如果没匹配到任何文件,那它将扩展成自己.<br />
15 # 为了不让这种情况发生,那就设置nullglob选项<br />
16 #+ (shopt -s nullglob).<br />
17 # Thanks, S.C.<br />
18 done<br />
19<br />
20 echo; echo<br />
21<br />
22 for file in [jx]</em><br />
23 do<br />
24 rm -f $file # 只删除当前目录下以&rdquo;j&rdquo;或&rdquo;x&rdquo;开头的文件.<br />
25 echo &ldquo;Removed file \&ldquo;$file\&ldquo;&rdquo;.<br />
26 done<br />
27<br />
28 echo<br />
29<br />
30 exit 0<br />
################################End
Script#########################################</p>

<p>在一个for循环中忽略[list]的话,将会使循环操作$@(从命令行传递给脚本的参数列表).<br />
一个非常好的例子,见Example A-16.<br />
Example 10-5 在for循环中省略[list]<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 使用两种方法来调用这个脚本,一种是带参数的情况,另一种不带参数.<br />
4 #+ 观察此脚本的行为各是什么样的?<br />
5<br />
6 for a<br />
7 do<br />
8 echo -n &ldquo;$a &rdquo;<br />
9 done<br />
10<br />
11 # The &lsquo;in list&rsquo; missing, therefore the loop operates on &lsquo;$@&rsquo;<br />
11 # 没有[list],所以循环将操作&rsquo;$@&rsquo;<br />
12 #+ (包括空白的命令参数列表).<br />
13<br />
14 echo<br />
15<br />
16 exit 0<br />
################################End
Script#########################################</p>

<p>也可以使用命令替换来产生for循环的[list].具体见Example 12-49,Example 10-10,<br />
和Example 12-43.<br />
Example 10-6 使用命令替换来产生for循环的[list]<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # for-loopcmd.sh: 带[list]的for循环<br />
3 #+ [list]是由命令替换产生的.<br />
4<br />
5 NUMBERS=&ldquo;9 7 3 8 37.53&rdquo;<br />
6<br />
7 for number in <code>echo $NUMBERS</code> # for number in 9 7 3 8 37.53<br />
8 do<br />
9 echo -n &ldquo;$number &rdquo;<br />
10 done<br />
11<br />
12 echo<br />
13 exit 0<br />
################################End
Script#########################################<br />
下边是一个用命令替换来产生[list]的更复杂的例子.<br />
Example 10-7 对于二进制文件的一个grep替换<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # bin-grep.sh: 在一个二进制文件中定位匹配字串.<br />
3<br />
4 # 对于二进制文件的一个grep替换<br />
5 # 与&rdquo;grep -a&rdquo;的效果相似<br />
6<br />
7 E_BADARGS=65<br />
8 E_NOFILE=66<br />
9<br />
10 if [ $# -ne 2 ]<br />
11 then<br />
12 echo &ldquo;Usage: <code>basename $0</code> search_string filename&rdquo;<br />
13 exit $E_BADARGS<br />
14 fi<br />
15<br />
16 if [ ! -f &ldquo;$2&rdquo; ]<br />
17 then<br />
18 echo &ldquo;File \&ldquo;$2\&rdquo; does not exist.&rdquo;<br />
19 exit $E_NOFILE<br />
20 fi<br />
21<br />
22<br />
23 IFS=&rdquo;\n&rdquo; # 由Paulo Marcel Coelho Aragao提出的建议.<br />
24 for word in $( strings &ldquo;$2&rdquo; | grep &ldquo;$1&rdquo; )<br />
25 # &ldquo;strings&rdquo; 命令列出二进制文件中的所有字符串.<br />
26 # 输出到管道交给&rdquo;grep&rdquo;,然后由grep命令来过滤字符串.<br />
27 do<br />
28 echo $word<br />
29 done<br />
30<br />
31 # S.C. 指出, 行23 - 29 可以被下边的这行来代替,<br />
32 # strings &ldquo;$2&rdquo; | grep &ldquo;$1&rdquo; | tr -s &ldquo;$IFS&rdquo; &lsquo;[\n<em>]&rsquo;<br />
33<br />
34<br />
35 # 试试用&rdquo;./bin-grep.sh mem /bin/ls&rdquo;来运行这个脚本.<br />
36<br />
37 exit 0<br />
################################End
Script#########################################<br />
大部分相同.<br />
Example 10-8 列出系统上的所有用户<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # userlist.sh<br />
3<br />
4 PASSWORD_FILE=/etc/passwd<br />
5 n=1 # User number<br />
6<br />
7 for name in $(awk &lsquo;BEGIN{FS=&rdquo;:&ldquo;}{print $1}&rsquo; &lt; &ldquo;$PASSWORD_FILE&rdquo; )<br />
8 # 域分隔 = : ^^^^^^<br />
9 # 打印出第一个域 ^^^^^^^^<br />
10 # 从password文件中取得输入 ^^^^^^^^^^^^^^^^^<br />
11 do<br />
12 echo &ldquo;USER #$n = $name&rdquo;<br />
13 let &ldquo;n += 1&rdquo;<br />
14 done<br />
15<br />
16<br />
17 # USER #1 = root<br />
18 # USER #2 = bin<br />
19 # USER #3 = daemon<br />
20 # &hellip;<br />
21 # USER #30 = bozo<br />
22<br />
23 exit 0<br />
24<br />
25 # 练习 :<br />
26 # &mdash;&mdash;<br />
27 # 一个普通用户(或者是一个普通用户运行的脚本)<br />
28 #+ 怎么能读取/etc/password呢?<br />
29 # 这是否是一个安全漏洞? 为什么是?为什么不是?<br />
################################End
Script#########################################<br />
关于用命令替换来产生[list]的最后的例子.<br />
Example 10-9 在目录的所有文件中查找源字串<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # findstring.sh:<br />
3 # 在一个指定目录的所有文件中查找一个特定的字符串.<br />
4<br />
5 directory=/usr/bin/<br />
6 fstring=&ldquo;Free Software Foundation&rdquo; # 查看那个文件中包含FSF.<br />
7<br />
8 for file in $( find $directory -type f -name &lsquo;</em>&rsquo; | sort )<br />
9 do<br />
10 strings -f $file | grep &ldquo;$fstring&rdquo; | sed -e &ldquo;s%$directory%%&rdquo;<br />
11 # 在&rdquo;sed&rdquo;表达式中,<br />
12 #+ 我们必须替换掉正常的替换分隔符&rdquo;/&ldquo;,<br />
13 #+ 因为&rdquo;/&ldquo;碰巧是我们需要过滤的字串之一.<br />
14 # 如果不用&rdquo;%&ldquo;代替&rdquo;/&ldquo;作为分隔符,那么这个操作将失败,并给出一个错误消息.(试试)<br />
15 done<br />
16<br />
17 exit 0<br />
18<br />
19 # 练习 (easy):<br />
20 # &mdash;&mdash;&mdash;&mdash;<br />
21 # 将内部用的$directory和$fstring变量,用从<br />
22 #+ 命令行参数代替.<br />
################################End
Script#########################################</p>

<p>for循环的输出也可以通过管道传递到一个或多个命令中.<br />
Example 10-10 列出目录中所有的符号连接文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # symlinks.sh: 列出目录中所有的符号连接文件.<br />
3<br />
4<br />
5 directory=${1-<code>pwd</code>}<br />
6 # 如果没有其他的特殊指定,<br />
7 #+ 默认为当前工作目录.<br />
8 # 下边的代码块,和上边这句等价.<br />
9 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
10 # ARGS=1 # 需要一个命令行参数.<br />
11 #<br />
12 # if [ $# -ne &ldquo;$ARGS&rdquo; ] # 如果不是一个参数的话&hellip;<br />
13 # then<br />
14 # directory=<code>pwd</code> # 当前工作目录<br />
15 # else<br />
16 # directory=$1<br />
17 # fi<br />
18 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
19<br />
20 echo &ldquo;symbolic links in directory \&ldquo;$directory\&ldquo;&rdquo;<br />
21<br />
22 for file in &ldquo;$( find $directory -type l )&rdquo; # -type l 就是符号连接文件<br />
23 do<br />
24 echo &ldquo;$file&rdquo;<br />
25 done | sort # 否则列出的文件将是未排序的<br />
26 # 严格上说,此处并不一定非要一个循环不可,<br />
27 #+ 因为&rdquo;find&rdquo;命令的结果将被扩展成一个单词.<br />
28 # 然而,这种方式很容易理解和说明.<br />
29<br />
30 # Dominik &lsquo;Aeneas&rsquo; Schnitzer 指出,<br />
31 #+ 如果没将 $( find $directory -type l )用&rdquo;&ldquo;引用起来的话<br />
32 #+ 那么将会把一个带有空白部分的文件名拆成以空白分隔的两部分(文件名中允许有空白).<br />
33 # 即使这只将取出每个参数的第一个域.<br />
34<br />
35 exit 0<br />
36<br />
37<br />
38 # Jean Helou 建议使用下边的方法:<br />
39<br />
40 echo &ldquo;symbolic links in directory \&ldquo;$directory\&ldquo;&rdquo;<br />
41 # 当前IFS的备份.要小心使用这个值.<br />
42 OLDIFS=$IFS<br />
43 IFS=:<br />
44<br />
45 for file in $(find $directory -type l -printf &ldquo;%p$IFS&rdquo;)<br />
46 do # ^^^^^^^^^^^^^^^^<br />
47 echo &ldquo;$file&rdquo;<br />
48 done|sort<br />
################################End
Script#########################################</p>

<p>循环的输出可以重定向到文件中,我们对上边的例子做了一点修改.<br />
Example 10-11 将目录中的符号连接文件名保存到一个文件中<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # symlinks.sh: 列出目录中所有的符号连接文件.<br />
3<br />
4 OUTFILE=symlinks.list # 保存的文件<br />
5<br />
6 directory=${1-<code>pwd</code>}<br />
7 # 如果没有其他的特殊指定,<br />
8 #+ 默认为当前工作目录.<br />
9<br />
10<br />
11 echo &ldquo;symbolic links in directory \&ldquo;$directory\&ldquo;&rdquo; &gt; &ldquo;$OUTFILE&rdquo;<br />
12 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo; &gt;&gt; &ldquo;$OUTFILE&rdquo;<br />
13<br />
14 for file in &ldquo;$( find $directory -type l )&rdquo; # -type l 为符号链接<br />
15 do<br />
16 echo &ldquo;$file&rdquo;<br />
17 done | sort &gt;&gt; &ldquo;$OUTFILE&rdquo; # 循环的输出<br />
18 # ^^^^^^^^^^^^^ 重定向到一个文件中<br />
19<br />
20 exit 0<br />
################################End
Script#########################################</p>

<p>有一种非常像C语言的for循环的语法形式.这需要使用(()).<br />
Example 10-12 一个C风格的for循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 两种循环到10的方法.<br />
3<br />
4 echo<br />
5<br />
6 # 标准语法.<br />
7 for a in 1 2 3 4 5 6 7 8 9 10<br />
8 do<br />
9 echo -n &ldquo;$a &rdquo;<br />
10 done<br />
11<br />
12 echo; echo<br />
13<br />
14 # +==========================================+<br />
15<br />
16 # 现在, 让我们用C风格的语法做同样的事.<br />
17<br />
18 LIMIT=10<br />
19<br />
20 for ((a=1; a &lt;= LIMIT ; a++)) # Double parentheses, and &ldquo;LIMIT&rdquo; with no
&ldquo;$&rdquo;.<br />
20 for ((a=1; a &lt;= LIMIT ; a++)) # 双圆括号, 并且&rdquo;LIMIT&rdquo;变量前边没有 &ldquo;$&rdquo;.<br />
21 do<br />
22 echo -n &ldquo;$a &rdquo;<br />
23 done # 这是一个借用&rsquo;ksh93&rsquo;的结构.<br />
24<br />
25 echo; echo<br />
26<br />
27 #
+=========================================================================+<br />
28<br />
29 # 让我们使用C的逗号操作符,来同时增加两个变量的值.<br />
30<br />
31 for ((a=1, b=1; a &lt;= LIMIT ; a++, b++)) # 逗号将同时进行2条操作.<br />
32 do<br />
33 echo -n &ldquo;$a-$b &rdquo;<br />
34 done<br />
35<br />
36 echo; echo<br />
37<br />
38 exit 0<br />
################################End
Script#########################################<br />
参考Example 26-15,Example 26-16,和Example A-6.<br />
-&ndash;<br />
现在来一个现实生活中使用的for循环.<br />
Example 10-13 在batch mode中使用efax<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # Faxing (&lsquo;fax&rsquo; 必须已经被安装过了).<br />
3<br />
4 EXPECTED_ARGS=2<br />
5 E_BADARGS=65<br />
6<br />
7 if [ $# -ne $EXPECTED_ARGS ]<br />
8 # 检查命令行参数的个数是否正确.<br />
9 then<br />
10 echo &ldquo;Usage: <code>basename $0</code> phone# text-file&rdquo;<br />
11 exit $E_BADARGS<br />
12 fi<br />
13<br />
14<br />
15 if [ ! -f &ldquo;$2&rdquo; ]<br />
16 then<br />
17 echo &ldquo;File $2 is not a text file&rdquo;<br />
18 exit $E_BADARGS<br />
19 fi<br />
20<br />
21<br />
22 fax make $2 # 从文本文件中创建传真格式的文件.<br />
23<br />
24 for file in $(ls $2.0<em>) # 连接转换过的文件.<br />
25 # 在变量列表中使用通配符.<br />
26 do<br />
27 fil=&ldquo;$fil $file&rdquo;<br />
28 done<br />
29<br />
30 efax -d /dev/ttyS3 -o1 -t &ldquo;T$1&rdquo; $fil # 干活的地方.<br />
31<br />
32<br />
33 # S.C. 指出, 通过下边的命令可以省去for循环.<br />
34 # efax -d /dev/ttyS3 -o1 -t &ldquo;T$1&rdquo; $2.0</em><br />
35 # 但这并不十分有讲解意义[嘿嘿].<br />
36<br />
37 exit 0<br />
################################End
Script#########################################</p>

<p>while<br />
这种结构在循环的开头判断条件是否满足,如果条件一直满足,那就一直循环下去(0为退出<br />
码).与for循环的区别是,这种结构适合用在循环次数未知的情况下.</p>

<p>while [condition]<br />
do<br />
command&hellip;<br />
done</p>

<p>和for循环一样,如果想把do和条件放到同一行上还是需要一个&rdquo;;&ldquo;.</p>

<p>while [condition]; do</p>

<p>注意一下某种特定的while循环,比如getopts结构,好像和这里所介绍的模版有点脱节.</p>

<p>Example 10-14 简单的while循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 var0=0<br />
4 LIMIT=10<br />
5<br />
6 while [ &ldquo;$var0&rdquo; -lt &ldquo;$LIMIT&rdquo; ]<br />
7 do<br />
8 echo -n &ldquo;$var0 &rdquo; # -n 将会阻止产生新行.<br />
9 # ^ 空格,数字之间的分隔.<br />
10<br />
11 var0=<code>expr $var0 + 1</code> # var0=$(($var0+1)) 也可以.<br />
12 # var0=$((var0 + 1)) 也可以.<br />
13 # let &ldquo;var0 += 1&rdquo; 也可以.<br />
14 done # 使用其他的方法也行.<br />
15<br />
16 echo<br />
17<br />
18 exit 0<br />
################################End
Script#########################################</p>

<p>Example 10-15 另一个while循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 echo<br />
4 # 等价于:<br />
5 while [ &ldquo;$var1&rdquo; != &ldquo;end&rdquo; ] # while test &ldquo;$var1&rdquo; != &ldquo;end&rdquo;<br />
6 do<br />
7 echo &ldquo;Input variable #1 (end to exit) &rdquo;<br />
8 read var1 # 为什么不使用&rsquo;read $var1&rsquo;?<br />
9 echo &ldquo;variable #1 = $var1&rdquo; # 因为包含&rdquo;#&ldquo;字符,所以需要&rdquo;&rdquo;<br />
10 # 如果输入为&rsquo;end&rsquo;,那么就在这里echo.<br />
11 # 不在这里判断结束,在循环顶判断.<br />
12 echo<br />
13 done<br />
14<br />
15 exit 0<br />
################################End
Script#########################################</p>

<p>一个while循环可以有多个判断条件,但是只有最后一个才能决定是否退出循环.然而这需<br />
要一种有点不同的循环语法.<br />
Example 10-16 多条件的while循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 var1=unset<br />
4 previous=$var1<br />
5<br />
6 while echo &ldquo;previous-variable = $previous&rdquo;<br />
7 echo<br />
8 previous=$var1<br />
9 [ &ldquo;$var1&rdquo; != end ] # 记录之前的$var1.<br />
10 # 这个&rdquo;while&rdquo;循环中有4个条件, 但是只有最后一个能控制循环.<br />
11 # 退出状态由第4个条件决定.<br />
12 do<br />
13 echo &ldquo;Input variable #1 (end to exit) &rdquo;<br />
14 read var1<br />
15 echo &ldquo;variable #1 = $var1&rdquo;<br />
16 done<br />
17<br />
18 # 尝试理解这个脚本的运行过程.<br />
19 # 这里还是有点小技巧的.<br />
20<br />
21 exit 0<br />
################################End
Script#########################################</p>

<p>与for循环一样,while循环也可通过(())来使用C风格语法.(见Example 9-30)<br />
Example 10-17 C风格的while循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # wh-loopc.sh: 循环10次的while循环.<br />
3<br />
4 LIMIT=10<br />
5 a=1<br />
6<br />
7 while [ &ldquo;$a&rdquo; -le $LIMIT ]<br />
8 do<br />
9 echo -n &ldquo;$a &rdquo;<br />
10 let &ldquo;a+=1&rdquo;<br />
11 done # 到目前为止都没什么令人惊奇的地方.<br />
12<br />
13 echo; echo<br />
14<br />
15 # +=================================================================+<br />
16<br />
17 # 现在, 重复C风格的语法.<br />
18<br />
19 ((a = 1)) # a=1<br />
20 # 双圆括号允许赋值两边的空格,就像C语言一样.<br />
21<br />
22 while (( a &lt;= LIMIT )) # 双圆括号, 变量前边没有&rdquo;$&ldquo;.<br />
23 do<br />
24 echo -n &ldquo;$a &rdquo;<br />
25 ((a += 1)) # let &ldquo;a+=1&rdquo;<br />
26 # Yes, 看到了吧.<br />
27 # 双圆括号允许像C风格的语法一样增加变量的值.<br />
28 done<br />
29<br />
30 echo<br />
31<br />
32 # 现在,C程序员可以在Bash中找到回家的感觉了吧.<br />
33<br />
34 exit 0<br />
################################End
Script#########################################<br />
注意:while循环的stdin可以用 whild循环的stdin支持管道.</p>

<p>until<br />
这个结构在循环的顶部判断条件,并且如果条件一直为false那就一直循环下去.(与while<br />
相反)</p>

<p>until [condition-is-true]<br />
do<br />
command&hellip;<br />
done</p>

<p>注意: until循环的判断在循环的顶部,这与某些编程语言是不同的.</p>

<p>与for循环一样,如果想把do和条件放在一行里,就使用&rdquo;;&ldquo;.</p>

<p>until [condition-is-true]; do</p>

<p>Example 10-18 until循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 END_CONDITION=end<br />
4<br />
5 until [ &ldquo;$var1&rdquo; = &ldquo;$END_CONDITION&rdquo; ]<br />
6 # 在循环的顶部判断条件.<br />
7 do<br />
8 echo &ldquo;Input variable #1 &rdquo;<br />
9 echo &ldquo;($END_CONDITION to exit)&rdquo;<br />
10 read var1<br />
11 echo &ldquo;variable #1 = $var1&rdquo;<br />
12 echo<br />
13 done<br />
14<br />
15 exit 0<br />
################################End
Script#########################################</p>

<p>10.2 嵌套循环<br />
-&mdash;&mdash;&mdash;&mdash;<br />
嵌套循环就是在一个循环中还有一个循环,内部循环在外部循环体中.在外部循环的每次执行过<br />
程中都会触发内部循环,直到内部循环执行结束.外部循环执行了多少次,内部循环就完成多少<br />
次.当然,不论是外部循环或内部循环的break语句都会打断处理过程.</p>

<p>Example 10-19 嵌套循环<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # nested-loop.sh: 嵌套的&rdquo;for&rdquo; 循环.<br />
3<br />
4 outer=1 # 设置外部循环计数.<br />
5<br />
6 # 开始外部循环.<br />
7 for a in 1 2 3 4 5<br />
8 do<br />
9 echo &ldquo;Pass $outer in outer loop.&rdquo;<br />
10 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
11 inner=1 # 重设内部循环的计数.<br />
12<br />
13 # ===============================================<br />
14 # 开始内部循环.<br />
15 for b in 1 2 3 4 5<br />
16 do<br />
17 echo &ldquo;Pass $inner in inner loop.&rdquo;<br />
18 let &ldquo;inner+=1&rdquo; # 增加内部循环计数.<br />
19 done<br />
20 # 内部循环结束.<br />
21 # ===============================================<br />
22<br />
23 let &ldquo;outer+=1&rdquo; # 增加外部循环的计数.<br />
24 echo # 每次外部循环之间的间隔.<br />
25 done<br />
26 # 外部循环结束.<br />
27<br />
28 exit 0<br />
################################End
Script#########################################</p>

<p>10.3 循环控制<br />
-&mdash;&mdash;&mdash;&mdash;<br />
影响循环行为的命令</p>

<p>break,continue<br />
break和continue这两个循环控制命令[1]与其它语言的类似命令的行为是相同的.break<br />
命令将会跳出循环,continue命令将会跳过本次循环下边的语句,直接进入下次循环.</p>

<p>Example 10-20 break和continue命令在循环中的效果<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 LIMIT=19 # 上限<br />
4<br />
5 echo<br />
6 echo &ldquo;Printing Numbers 1 through 20 (but not 3 and 11).&rdquo;<br />
7<br />
8 a=0<br />
9<br />
10 while [ $a -le &ldquo;$LIMIT&rdquo; ]<br />
11 do<br />
12 a=$(($a+1))<br />
13<br />
14 if [ &ldquo;$a&rdquo; -eq 3 ] || [ &ldquo;$a&rdquo; -eq 11 ] # 除了3和11.<br />
15 then<br />
16 continue # 跳过本次循环剩下的语句.<br />
17 fi<br />
18<br />
19 echo -n &ldquo;$a &rdquo; # 在$a等于3和11的时候,这句将不会执行.<br />
20 done<br />
21<br />
22 # 练习:<br />
23 # 为什么循环会打印出20?<br />
24<br />
25 echo; echo<br />
26<br />
27 echo Printing Numbers 1 through 20, but something happens after 2.<br />
28<br />
29 ##################################################################<br />
30<br />
31 # Same loop, but substituting &lsquo;break&rsquo; for &lsquo;continue&rsquo;.<br />
31 # 同样的循环, 但是用&rsquo;break&rsquo;来代替&rsquo;continue&rsquo;.<br />
32<br />
33 a=0<br />
34<br />
35 while [ &ldquo;$a&rdquo; -le &ldquo;$LIMIT&rdquo; ]<br />
36 do<br />
37 a=$(($a+1))<br />
38<br />
39 if [ &ldquo;$a&rdquo; -gt 2 ]<br />
40 then<br />
41 break # 将会跳出整个循环.<br />
42 fi<br />
43<br />
44 echo -n &ldquo;$a &rdquo;<br />
45 done<br />
46<br />
47 echo; echo; echo<br />
48<br />
49 exit 0<br />
################################End
Script#########################################</p>

<p>break命令可以带一个参数.一个不带参数的break循环只能退出最内层的循环,而break N<br />
可以退出N层循环.<br />
Example 10-21 多层循环的退出<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # break-levels.sh: 退出循环.<br />
3<br />
4 # &ldquo;break N&rdquo; 退出N层循环.<br />
5<br />
6 for outerloop in 1 2 3 4 5<br />
7 do<br />
8 echo -n &ldquo;Group $outerloop: &ldquo;<br />
9<br />
10 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
11 for innerloop in 1 2 3 4 5<br />
12 do<br />
13 echo -n &ldquo;$innerloop &rdquo;<br />
14<br />
15 if [ &ldquo;$innerloop&rdquo; -eq 3 ]<br />
16 then<br />
17 break # 试试 break 2 来看看发生什么.<br />
18 # (内部循环和外部循环都被退出了.)<br />
19 fi<br />
20 done<br />
21 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
22<br />
23 echo<br />
24 done<br />
25<br />
26 echo<br />
27<br />
28 exit 0<br />
################################End
Script#########################################</p>

<p>continue命令也可以带一个参数.一个不带参数的continue命令只去掉本次循环的剩余代码<br />
.而continue N将会把N层循环剩余的代码都去掉,但是循环的次数不变.<br />
Example 10-22 多层循环的continue<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # &ldquo;continue N&rdquo; 命令, 将让N层的循环全部被continue.<br />
3<br />
4 for outer in I II III IV V # 外部循环<br />
5 do<br />
6 echo; echo -n &ldquo;Group $outer: &ldquo;<br />
7<br />
8 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
9 for inner in 1 2 3 4 5 6 7 8 9 10 # 内部循环<br />
10 do<br />
11<br />
12 if [ &ldquo;$inner&rdquo; -eq 7 ]<br />
13 then<br />
14 continue 2 # continue 2层, 也就是到outer循环上.<br />
15 # 将&rdquo;continue 2&rdquo;替换为一个单独的&rdquo;continue&rdquo;<br />
16 # 来看一下一个正常循环的行为.<br />
17 fi<br />
18<br />
19 echo -n &ldquo;$inner &rdquo; # 7 8 9 10 将不会被echo<br />
20 done<br />
21 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
22 #译者注:如果在此处添加echo的话,当然也不会输出.<br />
23 done<br />
24<br />
25 echo; echo<br />
26<br />
27 # 练习:<br />
28 # 准备一个有意义的&rdquo;continue N&rdquo;的使用,放在脚本中.<br />
29<br />
30 exit 0<br />
################################End
Script#########################################</p>

<p>Example 10-23 在实际的任务中使用&rdquo;continue N&rdquo;<br />
################################Start
Script#######################################<br />
1 # Albert Reiner 给出了一个关于使用&rdquo;continue N&rdquo;的例子:<br />
2 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
3<br />
4 # Suppose I have a large number of jobs that need to be run, with<br />
5 #+ any data that is to be treated in files of a given name pattern in a<br />
6 #+ directory. There are several machines that access this directory, and<br />
7 #+ I want to distribute the work over these different boxen. Then I<br />
8 #+ usually nohup something like the following on every box:<br />
9<br />
10 while true<br />
11 do<br />
12 for n in .iso.*<br />
13 do<br />
14 [ &ldquo;$n&rdquo; = &ldquo;.iso.opts&rdquo; ] &amp;&amp; continue<br />
15 beta=${n#.iso.}<br />
16 [ -r .Iso.$beta ] &amp;&amp; continue<br />
17 [ -r .lock.$beta ] &amp;&amp; sleep 10 &amp;&amp; continue<br />
18 lockfile -r0 .lock.$beta || continue<br />
19 echo -n &ldquo;$beta: &ldquo; <code>date</code><br />
20 run-isotherm $beta<br />
21 date<br />
22 ls -alF .Iso.$beta<br />
23 [ -r .Iso.$beta ] &amp;&amp; rm -f .lock.$beta<br />
24 continue 2<br />
25 done<br />
26 break<br />
27 done<br />
28<br />
29 # The details, in particular the sleep N, are particular to my<br />
30 #+ application, but the general pattern is:<br />
31<br />
32 while true<br />
33 do<br />
34 for job in {pattern}<br />
35 do<br />
36 {job already done or running} &amp;&amp; continue<br />
37 {mark job as running, do job, mark job as done}<br />
38 continue 2<br />
39 done<br />
40 break # Or something like <code>sleep 600' to avoid termination.  
41 done  
42  
43 # This way the script will stop only when there are no more jobs to do  
44 #+ (including jobs that were added during runtime). Through the use  
45 #+ of appropriate lockfiles it can be run on several machines  
46 #+ concurrently without duplication of calculations [which run a couple  
47 #+ of hours in my case, so I really want to avoid this]. Also, as search  
48 #+ always starts again from the beginning, one can encode priorities in  
49 #+ the file names. Of course, one could also do this without</code>continue 2&rsquo;,<br />
50 #+ but then one would have to actually check whether or not some job<br />
51 #+ was done (so that we should immediately look for the next job) or not<br />
52 #+ (in which case we terminate or sleep for a long time before checking<br />
53 #+ for a new job).<br />
################################End
Script#########################################<br />
注意:continue N结构如果被用在一个有意义的上下文中的话,往往都很难理解,并且技巧性<br />
很高.所以最好的方法就是尽量避免它.</p>

<p>注意事项:<br />
[1] 这两个命令是shell的内建命令,而不像其它的循环命令那样,比如while和case,这两个<br />
是关键字.</p>

<p>10.4 测试与分支(case和select结构)<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
case和select结构在技术上说不是循环,因为它们并不对可执行的代码块进行迭代.但是和循环<br />
相似的是,它们也依靠在代码块的顶部或底部的条件判断来决定程序的分支.</p>

<p>在代码块中控制程序分支</p>

<p>case (in) / esac<br />
在shell中的case同C/C++中的switch结构是相同的.它允许通过判断来选择代码块中多条<br />
路径中的一条.</p>

<p>case &ldquo;$variable&rdquo; in</p>

<p>&rdquo;$condition1&rdquo;)<br />
command&hellip;<br />
;;</p>

<p>&rdquo;$condition1&rdquo;)<br />
command&hellip;<br />
;;</p>

<p>esac</p>

<p>注意: 对变量使用&rdquo;&ldquo;并不是强制的,因为不会发生单词分离.<br />
每句测试行,都以右小括号)结尾.<br />
每个条件块都以两个分号结尾;;.<br />
case块的结束以esac(case的反向拼写)结尾.</p>

<p>Example 10-24 使用case<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 测试字符串范围<br />
3<br />
4 echo; echo &ldquo;Hit a key, then hit return.&rdquo;<br />
5 read Keypress<br />
6<br />
7 case &ldquo;$Keypress&rdquo; in<br />
8 [[:lower:]] ) echo &ldquo;Lowercase letter&rdquo;;;<br />
9 [[:upper:]] ) echo &ldquo;Uppercase letter&rdquo;;;<br />
10 [0-9] ) echo &ldquo;Digit&rdquo;;;<br />
11 * ) echo &ldquo;Punctuation, whitespace, or other&rdquo;;;<br />
12 esac # Allows ranges of characters in [square brackets],<br />
12 esac # 允许字符串的范围出现在[]中,<br />
13 #+ or POSIX ranges in [[double square brackets.<br />
13 #+ 或者POSIX范围在[[中.<br />
14<br />
15 # 在这个例子的第一个版本中,<br />
16 #+ 测试大写和小写字符串使用的是<br />
17 #+ [a-z] 和 [A-Z].<br />
18 # 这种用法将不会在某些特定的场合或Linux发行版中正常工作.<br />
19 # POSIX 更具可移植性.<br />
20 # 感谢Frank Wang 指出这点.<br />
21<br />
22 # 练习:<br />
23 # &mdash;&ndash;<br />
24 # 就像这个脚本所表现的,它只允许单个按键,然后就结束了.<br />
25 # 修改这个脚本,让它能够接受重复输入,<br />
26 #+ 报告每个按键,并且只有在&rdquo;X&rdquo;被键入时才结束.<br />
27 # 暗示: 将这些代码都用&rdquo;while&rdquo;循环圈起来.<br />
28<br />
29 exit 0<br />
################################End
Script#########################################</p>

<p>Example 10-25 使用case来创建菜单<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 未经处理的地址资料<br />
4<br />
5 clear # 清屏.<br />
6<br />
7 echo &ldquo; Contact List&rdquo;<br />
8 echo &ldquo; &mdash;&mdash;- &mdash;-&rdquo;<br />
9 echo &ldquo;Choose one of the following persons:&rdquo;<br />
10 echo<br />
11 echo &ldquo;[E]vans, Roland&rdquo;<br />
12 echo &ldquo;[J]ones, Mildred&rdquo;<br />
13 echo &ldquo;[S]mith, Julie&rdquo;<br />
14 echo &ldquo;[Z]ane, Morris&rdquo;<br />
15 echo<br />
16<br />
17 read person<br />
18<br />
19 case &ldquo;$person&rdquo; in<br />
20 # 注意,变量是被引用的.<br />
21<br />
22 &ldquo;E&rdquo; | &ldquo;e&rdquo; )<br />
23 # 接受大写或小写输入.<br />
24 echo<br />
25 echo &ldquo;Roland Evans&rdquo;<br />
26 echo &ldquo;4321 Floppy Dr.&rdquo;<br />
27 echo &ldquo;Hardscrabble, CO 80753&rdquo;<br />
28 echo &ldquo;(303) 734-9874&rdquo;<br />
29 echo &ldquo;(303) 734-9892 fax&rdquo;<br />
30 echo &ldquo;revans@zzy.net&rdquo;<br />
31 echo &ldquo;Business partner &amp; old friend&rdquo;<br />
32 ;;<br />
33 # 注意,在每个选项后边都需要以;;结尾.<br />
34<br />
35 &ldquo;J&rdquo; | &ldquo;j&rdquo; )<br />
36 echo<br />
37 echo &ldquo;Mildred Jones&rdquo;<br />
38 echo &ldquo;249 E. 7th St., Apt. 19&rdquo;<br />
39 echo &ldquo;New York, NY 10009&rdquo;<br />
40 echo &ldquo;(212) 533-2814&rdquo;<br />
41 echo &ldquo;(212) 533-9972 fax&rdquo;<br />
42 echo &ldquo;milliej@loisaida.com&rdquo;<br />
43 echo &ldquo;Ex-girlfriend&rdquo;<br />
44 echo &ldquo;Birthday: Feb. 11&rdquo;<br />
45 ;;<br />
46<br />
47 # 后边的Smith和Zane的信息在这里就省略了.<br />
48<br />
49 * )<br />
50 # 默认选项.<br />
51 # 空输入(敲RETURN).<br />
52 echo<br />
53 echo &ldquo;Not yet in database.&rdquo;<br />
54 ;;<br />
55<br />
56 esac<br />
57<br />
58 echo<br />
59<br />
60 # 练习:<br />
61 # &mdash;&ndash;<br />
62 # 修改这个脚本,让它能够接受多输入,<br />
63 #+ 并且能够显示多个地址.<br />
64<br />
65 exit 0<br />
################################End
Script#########################################</p>

<p>一个case的特殊用法,用来测试命令行参数.<br />
################################Start
Script#######################################<br />
1 #! /bin/bash<br />
2<br />
3 case &ldquo;$1&rdquo; in<br />
4 &ldquo;&rdquo;) echo &ldquo;Usage: ${0##<em>/} &ldquo;; exit $E_PARAM;; # 没有命令行参数,<br />
5 # 或者第一个参数为空.<br />
6 # Note that ${0##</em>/} is ${var##pattern} param substitution. Net result is
$0.<br />
6 # 注意:${0##<em>/} 是${var##pattern} 这种模式的替换. 得到的结果是$0.<br />
7<br />
8 -</em>) FILENAME=./$1;; # 如果传递进来的文件名参数($1)以一个破折号开头,<br />
9 #+ 那么用./$1来代替<br />
10 #+ 这样后边的命令将不会把它作为一个选项来解释.<br />
11<br />
12 * ) FILENAME=$1;; # 否则, $1.<br />
13 esac<br />
################################End
Script#########################################</p>

<p>这是一个更容易懂的命令行参数处理的一个例子.<br />
################################Start
Script#######################################<br />
1 #! /bin/bash<br />
2<br />
3<br />
4 while [ $# -gt 0 ]; do # 直到你用完所有的参数&hellip;<br />
5 case &ldquo;$1&rdquo; in<br />
6 -d|&ndash;debug)<br />
7 # &ldquo;-d&rdquo; or &ldquo;&ndash;debug&rdquo; parameter?<br />
8 DEBUG=1<br />
9 ;;<br />
10 -c|&ndash;conf)<br />
11 CONFFILE=&ldquo;$2&rdquo;<br />
12 shift<br />
13 if [ ! -f $CONFFILE ]; then<br />
14 echo &ldquo;Error: Supplied file doesn&rsquo;t exist!&rdquo;<br />
15 exit $E_CONFFILE # 文件没发现错误.<br />
16 fi<br />
17 ;;<br />
18 esac<br />
19 shift # 检查剩下的参数.<br />
20 done<br />
21<br />
22 # 来自Stefano Falsetto的 &ldquo;Log2Rot&rdquo; 脚本,<br />
23 #+ 他的&rdquo;rottlog&rdquo; 包的一部分.<br />
24 # 授权使用.<br />
################################End
Script#########################################</p>

<p>Example 10-26 使用命令替换来产生case变量<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # case-cmd.sh: 使用命令替换来产生&rdquo;case&rdquo;变量<br />
3<br />
4 case $( arch ) in # &ldquo;arch&rdquo; 返回机器的类型.<br />
5 # 等价于 &lsquo;uname -m&rsquo; &hellip;<br />
6 i386 ) echo &ldquo;80386-based machine&rdquo;;;<br />
7 i486 ) echo &ldquo;80486-based machine&rdquo;;;<br />
8 i586 ) echo &ldquo;Pentium-based machine&rdquo;;;<br />
9 i686 ) echo &ldquo;Pentium2+-based machine&rdquo;;;<br />
10 * ) echo &ldquo;Other type of machine&rdquo;;;<br />
11 esac<br />
12<br />
13 exit 0<br />
################################End
Script#########################################</p>

<p>case结构也可以过滤globbing模式的字符串.<br />
Example 10-27 简单字符串匹配<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # match-string.sh: 简单字符串匹配<br />
3<br />
4 match_string ()<br />
5 {<br />
6 MATCH=0<br />
7 NOMATCH=90<br />
8 PARAMS=2 # 函数需要2个参数.<br />
9 BAD_PARAMS=91<br />
10<br />
11 [ $# -eq $PARAMS ] || return $BAD_PARAMS<br />
12<br />
13 case &ldquo;$1&rdquo; in<br />
14 &ldquo;$2&rdquo;) return $MATCH;;<br />
15 * ) return $NOMATCH;;<br />
16 esac<br />
17<br />
18 }<br />
19<br />
20<br />
21 a=one<br />
22 b=two<br />
23 c=three<br />
24 d=two<br />
25<br />
26<br />
27 match_string $a # 参数个数错误.<br />
28 echo $? # 91<br />
29<br />
30 match_string $a $b # 不匹配<br />
31 echo $? # 90<br />
32<br />
33 match_string $b $d # 匹配<br />
34 echo $? # 0<br />
35<br />
36<br />
37 exit 0<br />
################################End
Script#########################################</p>

<p>Example 10-28 检查是否是字母输入<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # isalpha.sh: 使用&rdquo;case&rdquo;结构来过滤字符串.<br />
3<br />
4 SUCCESS=0<br />
5 FAILURE=-1<br />
6<br />
7 isalpha () # 检查输入的*第一个字符<em>是不是字母表上的字符.<br />
8 {<br />
9 if [ -z &ldquo;$1&rdquo; ] # 没有参数传进来?<br />
10 then<br />
11 return $FAILURE<br />
12 fi<br />
13<br />
14 case &ldquo;$1&rdquo; in<br />
15 [a-zA-Z]</em>) return $SUCCESS;; # 以一个字母开头?<br />
16 * ) return $FAILURE;;<br />
17 esac<br />
18 } # 同C语言的&rdquo;isalpha()&ldquo;函数相比较.<br />
19<br />
20<br />
21 isalpha2 () # 测试是否*整个字符串*为字母表字符.<br />
22 {<br />
23 [ $# -eq 1 ] || return $FAILURE<br />
24<br />
25 case $1 in<br />
26 <em>[!a-zA-Z]</em>|&ldquo;&rdquo;) return $FAILURE;;<br />
27 *) return $SUCCESS;;<br />
28 esac<br />
29 }<br />
30<br />
31 isdigit () # 测试是否*整个字符串*都是数字.<br />
32 { # 换句话说就是测试是否是整数变量.<br />
33 [ $# -eq 1 ] || return $FAILURE<br />
34<br />
35 case $1 in<br />
36 <em>[!0-9]</em>|&ldquo;&rdquo;) return $FAILURE;;<br />
37 <em>) return $SUCCESS;;<br />
38 esac<br />
39 }<br />
40<br />
41<br />
42<br />
43 check_var () # 测试 isalpha ().<br />
44 {<br />
45 if isalpha &ldquo;$@&rdquo;<br />
46 then<br />
47 echo &ldquo;\&ldquo;$</em>\&rdquo; begins with an alpha character.&rdquo;<br />
48 if isalpha2 &ldquo;$@&rdquo;<br />
49 then # 不需要测试第一个字符是否是non-alpha.<br />
50 echo &ldquo;\&ldquo;$<em>\&rdquo; contains only alpha characters.&rdquo;<br />
51 else<br />
52 echo &ldquo;\&ldquo;$</em>\&rdquo; contains at least one non-alpha character.&rdquo;<br />
53 fi<br />
54 else<br />
55 echo &ldquo;\&ldquo;$<em>\&rdquo; begins with a non-alpha character.&rdquo;<br />
56 # 如果没有参数传递进来,也是&rdquo;non-alpha&rdquo;.<br />
57 fi<br />
58<br />
59 echo<br />
60<br />
61 }<br />
62<br />
63 digit_check () # 测试 isdigit ().<br />
64 {<br />
65 if isdigit &ldquo;$@&rdquo;<br />
66 then<br />
67 echo &ldquo;\&ldquo;$</em>\&rdquo; contains only digits [0 - 9].&rdquo;<br />
68 else<br />
69 echo &ldquo;\&ldquo;$*\&rdquo; has at least one non-digit character.&rdquo;<br />
70 fi<br />
71<br />
72 echo<br />
73<br />
74 }<br />
75<br />
76 a=23skidoo<br />
77 b=H3llo<br />
78 c=-What?<br />
79 d=What?<br />
80 e=<code>echo $b</code> # 命令替换.<br />
81 f=AbcDef<br />
82 g=27234<br />
83 h=27a34<br />
84 i=27.34<br />
85<br />
86 check_var $a<br />
87 check_var $b<br />
88 check_var $c<br />
89 check_var $d<br />
90 check_var $e<br />
91 check_var $f<br />
92 check_var # 没有参数传进来,将发生什么?<br />
93 #<br />
94 digit_check $g<br />
95 digit_check $h<br />
96 digit_check $i<br />
97<br />
98<br />
99 exit 0 # S.C改进过这个脚本.<br />
100<br />
101 # Exercise:<br />
102 # &mdash;&mdash;&ndash;<br />
103 # 编写一个 &lsquo;isfloat ()&lsquo;函数来测试浮点数.<br />
104 # 暗示: 这个函数基本上与&rsquo;isdigit ()&lsquo;一样,<br />
105 #+ 但是要添加一部分小数点的处理.<br />
################################End
Script#########################################</p>

<p>select<br />
select结构是建立菜单的另一种工具,这种结构是从ksh中引入的.</p>

<p>select variable [in list]<br />
do<br />
command&hellip;<br />
break<br />
done</p>

<p>提示用户选择的内容比如放在变量列表中.注意:select命令使用PS3提示符[默认为(#? )]<br />
但是可以修改PS3.<br />
Example 10-29 用select来创建菜单<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 PS3=&lsquo;Choose your favorite vegetable: &lsquo; # 设置提示符字串.<br />
4<br />
5 echo<br />
6<br />
7 select vegetable in &ldquo;beans&rdquo; &ldquo;carrots&rdquo; &ldquo;potatoes&rdquo; &ldquo;onions&rdquo; &ldquo;rutabagas&rdquo;<br />
8 do<br />
9 echo<br />
10 echo &ldquo;Your favorite veggie is $vegetable.&rdquo;<br />
11 echo &ldquo;Yuck!&rdquo;<br />
12 echo<br />
13 break # 如果这里没有&rsquo;break&rsquo;会发生什么?<br />
14 done<br />
15<br />
16 exit 0<br />
################################End
Script#########################################</p>

<p>如果忽略了in list列表,那么select命令将使用传递到脚本的命令行参数,或者是函数参数<br />
前提是将select写到这个函数中.</p>

<p>与for variable [in list]结构在忽略[in list]时的行为相比较.<br />
Example 10-30 用函数中select结构来创建菜单<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 PS3=&lsquo;Choose your favorite vegetable: &lsquo;<br />
4<br />
5 echo<br />
6<br />
7 choice_of()<br />
8 {<br />
9 select vegetable<br />
10 # [in list] 被忽略, 所以&rsquo;select&rsquo;用传递给函数的参数.<br />
11 do<br />
12 echo<br />
13 echo &ldquo;Your favorite veggie is $vegetable.&rdquo;<br />
14 echo &ldquo;Yuck!&rdquo;<br />
15 echo<br />
16 break<br />
17 done<br />
18 }<br />
19<br />
20 choice_of beans rice carrots radishes tomatoes spinach<br />
21 # $1 $2 $3 $4 $5 $6<br />
22 # 传递给choice_of() 函数的参数<br />
23<br />
24 exit 0<br />
################################End
Script#########################################<br />
参见Example 34-3.</p>

<h1 id="第11章-内部命令与内建">第11章 内部命令与内建</h1>

<p>内建命令指的就是包含在Bash工具集中的命令.这主要是考虑到执行效率的问题&ndash;内建命令将<br />
比外部命令的执行得更快,外部命令通常需要fork出一个单独的进程来执行.另外一部分原因<br />
是特定的内建命令需要直接存取shell内核部分.</p>

<p>当一个命令或者是shell本身需要初始化(或者创建)一个新的子进程来执行一个任务的时候,这<br />
种行为被称为forking.这个新产生的进程被叫做子进程,并且这个进程是从父进程中分离出来<br />
的.当子进程执行它的任务时,同时父进程也在运行.</p>

<p>注意:当父进程取得子进程的进程ID的时候,父进程可以传递给子进程参数,而反过来则不行.<br />
这将产生不可思议的并且很难追踪的问题.</p>

<p>Example 11-1 一个fork出多个自己实例的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # spawn.sh<br />
3<br />
4<br />
5 PIDS=$(pidof sh $0) # 这个脚本不同实例的进程ID.<br />
6 P_array=( $PIDS ) # 把它们放到数组里(为什么?).<br />
7 echo $PIDS # 显示父进程和子进程的进程ID.<br />
8 let &ldquo;instances = ${#P_array[*]} - 1&rdquo; # 计算元素个数,至少为1.<br />
9 # 为什么减1?<br />
10 echo &ldquo;$instances instance(s) of this script running.&rdquo;<br />
11 echo &ldquo;[Hit Ctl-C to exit.]&ldquo;; echo<br />
12<br />
13<br />
14 sleep 1 # 等.<br />
15 sh $0 # 再来一次.<br />
16<br />
17 exit 0 # 没必要: 脚本永远不会走到这里.<br />
18 # 为什么走不到这里?<br />
19<br />
20 # 在使用Ctl-C退出之后,<br />
21 #+ 是否所有产生的进程都会被kill掉?<br />
22 # 如果是这样的话, 为什么?<br />
23<br />
24 # 注意:<br />
25 # &mdash;-<br />
26 # 小心,不要让这个脚本运行太长时间.<br />
27 # 它最后将吃掉你大部分的系统资源.<br />
28<br />
29 # 对于用脚本产生大量的自身实例来说,<br />
30 #+ 是否有适当的脚本技术.<br />
31 # 为什么是为什么不是?<br />
################################End
Script#########################################<br />
一般的,脚本中的内建命令在执行时将不会fork出一个子进程.但是脚本中的外部或过滤命令<br />
通常会fork一个子进程.</p>

<p>一个内建命令通常与一个系统命令同名,但是Bash在内部重新实现了这些命令.比如,Bash的<br />
echo命令与/bin/echo就不尽相同,虽然它们的行为绝大多数情况下是一样的.<br />
1 #!/bin/bash<br />
2<br />
3 echo &ldquo;This line uses the \&ldquo;echo\&rdquo; builtin.&rdquo;<br />
4 /bin/echo &ldquo;This line uses the /bin/echo system command.&rdquo;</p>

<p>关键字的意思就是保留字.对于shell来说关键字有特殊的含义,并且用来构建shell的语法结构.<br />
比如,&ldquo;for&rdquo;,&ldquo;while&rdquo;,&ldquo;do&rdquo;和&rdquo;!&ldquo;都是关键字.与内建命令相同的是,关键字也是Bash的骨干部分,<br />
但是与内建命令不同的是,关键字自身并不是命令,而是一个比较大的命令结构的一部分.[1]</p>

<p>I/O类</p>

<p>echo<br />
打印(到stdout)一个表达式或变量(见Example 4-1).<br />
1 echo Hello<br />
2 echo $a</p>

<p>echo需要使用-e参数来打印转移字符.见Example 5-2.<br />
一般的每个echo命令都会在终端上新起一行,但是-n选项将会阻止新起一行.</p>

<p>注意:echo命令可以用来作为一系列命令的管道输入.<br />
1 if echo &ldquo;$VAR&rdquo; | grep -q txt # if [[ $VAR = <em>txt</em> ]]<br />
2 then<br />
3 echo &ldquo;$VAR contains the substring sequence \&ldquo;txt\&ldquo;&rdquo;<br />
4 fi</p>

<p>注意:echo命令与命令替换相组合可以用来设置一个变量.<br />
a=<code>echo &quot;HELLO&quot; | tr A-Z a-z</code><br />
参见Example 12-19,Example 12-3,Example 12-42,和Example 12-43.</p>

<p>注意:echo <code>command</code>将会删除任何有命令产生的换行符.</p>

<p>$IFS(内部域分隔符)一般都会将\n(换行符)包含在它的空白字符集合中.Bash因此会根据<br />
参数中的换行来分离命令的输出.然后echo将以空格代替换行来输出这些参数.</p>

<p>bash$ ls -l /usr/share/apps/kjezz/sounds<br />
-rw-r&ndash;r&ndash; 1 root root 1407 Nov 7 2000 reflect.au<br />
-rw-r&ndash;r&ndash; 1 root root 362 Nov 7 2000 seconds.au</p>

<p>bash$ echo <code>ls -l /usr/share/apps/kjezz/sounds</code><br />
total 40 -rw-r&ndash;r&ndash; 1 root root 716 Nov 7 2000 reflect.au -rw-r&ndash;r&ndash; 1 root
root 362 Nov 7 2000 seconds.au</p>

<p>所以,我们怎么才能在一个需要echo出来的字符串中嵌入换行呢?<br />
################################Start
Script#######################################<br />
1 # 嵌入一个换行?<br />
2 echo &ldquo;Why doesn&rsquo;t this string \n split on two lines?&rdquo;<br />
3 # 上边这句的\n将被打印出来.达不到换行的目的.<br />
4<br />
5 # 让我们在试试其他方法.<br />
6<br />
7 echo<br />
8<br />
9 echo $&ldquo;A line of text containing<br />
10 a linefeed.&rdquo;<br />
11 # 打印出2个独立的行,(潜入换行成功了).<br />
12 # 但是,&ldquo;$&ldquo;前缀是否是必要的?<br />
13<br />
14 echo<br />
15<br />
16 echo &ldquo;This string splits<br />
17 on two lines.&rdquo;<br />
18 # 不用非得有&rdquo;$&ldquo;前缀.<br />
19<br />
20 echo<br />
21 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
22 echo<br />
23<br />
24 echo -n $&ldquo;Another line of text containing<br />
25 a linefeed.&rdquo;<br />
26 # 打印出2个独立的行,(潜入换行成功了).<br />
27 # 即使-n选项,也没能阻止换行(译者:-n 阻止了第2个换行)<br />
28<br />
29 echo<br />
30 echo<br />
31 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
32 echo<br />
33 echo<br />
34<br />
35 # 然而,下边的代码就没能像期望的那样运行.<br />
36 # Why not? Hint: Assignment to a variable.<br />
36 # 为什么失败? 提示: 因为分配到了变量.<br />
37 string1=$&ldquo;Yet another line of text containing<br />
38 a linefeed (maybe).&rdquo;<br />
39<br />
40 echo $string1<br />
41 # Yet another line of text containing a linefeed (maybe).<br />
42 # ^<br />
43 # 换行变成了空格.<br />
44<br />
45 # Thanks, Steve Parker, for pointing this out.<br />
################################End
Script#########################################<br />
注意: 这个命令是shell的一个内建命令,与/bin/echo不同,虽然行为相似.<br />
bash$ type -a echo<br />
echo is a shell builtin<br />
echo is /bin/echo</p>

<p>printf<br />
printf命令,格式化输出,是echo命令的增强.它是C语言printf()库函数的一个有限的变形,<br />
并且在语法上有些不同.</p>

<p>printf format-string&hellip; parameter&hellip;<br />
这是Bash的内建版本,与/bin/printf或/usr/bin/printf命令不同.想更深入的了解,请<br />
察看printf(系统命令)的man页.</p>

<p>注意:老版本的Bash可能不支持printf.<br />
Example 11-2 printf<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # printf demo<br />
3<br />
4 PI=3.14159265358979<br />
5 DecimalConstant=31373<br />
6 Message1=&ldquo;Greetings,&rdquo;<br />
7 Message2=&ldquo;Earthling.&rdquo;<br />
8<br />
9 echo<br />
10<br />
11 printf &ldquo;Pi to 2 decimal places = %1.2f&rdquo; $PI<br />
12 echo<br />
13 printf &ldquo;Pi to 9 decimal places = %1.9f&rdquo; $PI # 都能正确地结束.<br />
14<br />
15 printf &ldquo;\n&rdquo; # 打印一个换行,<br />
16 # 等价于 &lsquo;echo&rsquo; &hellip;<br />
17<br />
18 printf &ldquo;Constant = \t%d\n&rdquo; $DecimalConstant # 插入一个 tab (\t).<br />
19<br />
20 printf &ldquo;%s %s \n&rdquo; $Message1 $Message2<br />
21<br />
22 echo<br />
23<br />
24 # ==========================================#<br />
25 # 模仿C函数, sprintf().<br />
26 # 使用一个格式化的字符串来加载一个变量.<br />
27<br />
28 echo<br />
29<br />
30 Pi12=$(printf &ldquo;%1.12f&rdquo; $PI)<br />
31 echo &ldquo;Pi to 12 decimal places = $Pi12&rdquo;<br />
32<br />
33 Msg=<code>printf &quot;%s %s \n&quot; $Message1 $Message2</code><br />
34 echo $Msg; echo $Msg<br />
35<br />
36 # 向我们看到的一样,现在&rsquo;sprintf&rsquo;函数可以<br />
37 #+ 作为一个可被加载的模块<br />
38 #+ 但这是不可移植的.<br />
39<br />
40 exit 0<br />
################################End
Script#########################################</p>

<p>使用printf的最主要的应用就是格式化错误消息.<br />
1 E_BADDIR=65<br />
2<br />
3 var=nonexistent_directory<br />
4<br />
5 error()<br />
6 {<br />
7 printf &ldquo;$@&rdquo; &gt;&amp;2<br />
8 # 格式化传递进来的位置参数,并把它们送到stderr.<br />
9 echo<br />
10 exit $E_BADDIR<br />
11 }<br />
12<br />
13 cd $var || error $&ldquo;Can&rsquo;t cd to %s.&rdquo; &ldquo;$var&rdquo;<br />
14<br />
15 # Thanks, S.C.</p>

<p>read<br />
从stdin中读取一个变量的值,也就是与键盘交互取得变量的值.使用-a参数可以取得数组<br />
变量(见Example 26-6).<br />
Example 11-3 使用read,变量分配<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # &ldquo;Reading&rdquo; 变量.<br />
3<br />
4 echo -n &ldquo;Enter the value of variable &lsquo;var1&rsquo;: &ldquo;<br />
5 # -n选项,阻止换行.<br />
6<br />
7 read var1<br />
8 # 注意在var1前面没有&rsquo;$&lsquo;,因为变量正在被设置.<br />
9<br />
10 echo &ldquo;var1 = $var1&rdquo;<br />
11<br />
12<br />
13 echo<br />
14<br />
15 # 一个&rsquo;read&rsquo;命令可以设置多个变量.<br />
16 echo -n &ldquo;Enter the values of variables &lsquo;var2&rsquo; and &lsquo;var3&rsquo; (separated by a
space or tab): &ldquo;<br />
17 read var2 var3<br />
18 echo &ldquo;var2 = $var2 var3 = $var3&rdquo;<br />
19 # 如果你只输入了一个值,那么其他的变量还是未设置(null).<br />
20<br />
21 exit 0<br />
################################End
Script#########################################</p>

<p>一个不带变量参数的read命令,将把来自键盘的输入存入到专用变量$REPLY中.<br />
Example 11-4 当使用一个不带变量参数的read命令时,将会发生什么?<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # read-novar.sh<br />
3<br />
4 echo<br />
5<br />
6 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; #<br />
7 echo -n &ldquo;Enter a value: &ldquo;<br />
8 read var<br />
9 echo &ldquo;\&ldquo;var\&rdquo; = &ldquo;$var&rdquo;&rdquo;<br />
10 # 到这里为止,都与期望的相同.<br />
11 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; #<br />
12<br />
13 echo<br />
14<br />
15 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- #<br />
16 echo -n &ldquo;Enter another value: &ldquo;<br />
17 read # 没有变量分配给&rsquo;read&rsquo;命令,因此&hellip;<br />
18 #+ 输入将分配给默认变量,$REPLY.<br />
19 var=&ldquo;$REPLY&rdquo;<br />
20 echo &ldquo;\&ldquo;var\&rdquo; = &ldquo;$var&rdquo;&rdquo;<br />
21 # 这部分代码和上边的代码等价.<br />
22 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- #<br />
23<br />
24 echo<br />
25<br />
26 exit 0<br />
################################End
Script#########################################</p>

<p>通常情况下,在使用read命令时,输入一个\然后回车,将会阻止产生一个新行.-r选项将会<br />
让\转义.<br />
Example 11-5 read命令的多行输入<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 echo<br />
4<br />
5 echo &ldquo;Enter a string terminated by a \\, then press .&rdquo;<br />
6 echo &ldquo;Then, enter a second string, and again press .&rdquo;<br />
7 read var1 # &ldquo;\&ldquo;将会阻止产生新行,当read $var1时.<br />
8 # first line \<br />
9 # second line<br />
10<br />
11 echo &ldquo;var1 = $var1&rdquo;<br />
12 # var1 = first line second line<br />
13<br />
14 # For each line terminated by a &ldquo;\&rdquo;<br />
14 # 对于每个一个&rdquo;\&ldquo;结尾的行<br />
15 #+ 你都会看到一个下一行的提示符,让你继续向var1输入内容.<br />
16<br />
17 echo; echo<br />
18<br />
19 echo &ldquo;Enter another string terminated by a \\ , then press .&rdquo;<br />
20 read -r var2 # -r选项将会让&rdquo;\&ldquo;转义.<br />
21 # first line \<br />
22<br />
23 echo &ldquo;var2 = $var2&rdquo;<br />
24 # var2 = first line \<br />
25<br />
26 # 第一个就会结束var2变量的录入.<br />
27<br />
28 echo<br />
29<br />
30 exit 0<br />
################################End
Script#########################################</p>

<p>read命令有些有趣的选项,这些选项允许打印出一个提示符,然后在不输入的情况<br />
下,可以读入你的按键字符.<br />
1 # Read a keypress without hitting ENTER.<br />
1 # 不敲回车,读取一个按键字符.<br />
2<br />
3 read -s -n1 -p &ldquo;Hit a key &rdquo; keypress<br />
4 echo; echo &ldquo;Keypress was &ldquo;\&ldquo;$keypress\&ldquo;&rdquo;.&rdquo;<br />
5<br />
6 # -s 选项意味着不打印输入.<br />
7 # -n N 选项意味着直接受N个字符的输入.<br />
8 # -p 选项意味着在读取输入之前打印出后边的提示符.<br />
9<br />
10 # 使用这些选项是有技巧的,因为你需要使用正确的循序来使用它们.</p>

<p>read的-n选项也可以检测方向键,和一些控制按键.<br />
Example 11-6 检测方向键<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # arrow-detect.sh: 检测方向键,和一些非打印字符的按键.<br />
3 # Thank you, Sandro Magi告诉了我怎么做.<br />
4<br />
5 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
6 # 按键产生的字符编码.<br />
7 arrowup=&rsquo;\[A&rsquo;<br />
8 arrowdown=&rsquo;\[B&rsquo;<br />
9 arrowrt=&rsquo;\[C&rsquo;<br />
10 arrowleft=&rsquo;\[D&rsquo;<br />
11 insert=&rsquo;\[2&rsquo;<br />
12 delete=&rsquo;\[3&rsquo;<br />
13 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
14<br />
15 SUCCESS=0<br />
16 OTHER=65<br />
17<br />
18 echo -n &ldquo;Press a key&hellip; &rdquo;<br />
19 # 如果不是上边列表所列出的按键,可能还是需要按回车.(译者:因为一般按键是一个字符)<br />
20 read -n3 key # 读3个字符.<br />
21<br />
22 echo -n &ldquo;$key&rdquo; | grep &ldquo;$arrowup&rdquo; #检查输入字符是否匹配.<br />
23 if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
24 then<br />
25 echo &ldquo;Up-arrow key pressed.&rdquo;<br />
26 exit $SUCCESS<br />
27 fi<br />
28<br />
29 echo -n &ldquo;$key&rdquo; | grep &ldquo;$arrowdown&rdquo;<br />
30 if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
31 then<br />
32 echo &ldquo;Down-arrow key pressed.&rdquo;<br />
33 exit $SUCCESS<br />
34 fi<br />
35<br />
36 echo -n &ldquo;$key&rdquo; | grep &ldquo;$arrowrt&rdquo;<br />
37 if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
38 then<br />
39 echo &ldquo;Right-arrow key pressed.&rdquo;<br />
40 exit $SUCCESS<br />
41 fi<br />
42<br />
43 echo -n &ldquo;$key&rdquo; | grep &ldquo;$arrowleft&rdquo;<br />
44 if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
45 then<br />
46 echo &ldquo;Left-arrow key pressed.&rdquo;<br />
47 exit $SUCCESS<br />
48 fi<br />
49<br />
50 echo -n &ldquo;$key&rdquo; | grep &ldquo;$insert&rdquo;<br />
51 if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
52 then<br />
53 echo &ldquo;\&ldquo;Insert\&rdquo; key pressed.&rdquo;<br />
54 exit $SUCCESS<br />
55 fi<br />
56<br />
57 echo -n &ldquo;$key&rdquo; | grep &ldquo;$delete&rdquo;<br />
58 if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
59 then<br />
60 echo &ldquo;\&ldquo;Delete\&rdquo; key pressed.&rdquo;<br />
61 exit $SUCCESS<br />
62 fi<br />
63<br />
64<br />
65 echo &ldquo; Some other key pressed.&rdquo;<br />
66<br />
67 exit $OTHER<br />
68<br />
69 # 练习:<br />
70 # &mdash;&ndash;<br />
71 # 1) 通过使用&rsquo;case&rsquo;结构来代替&rsquo;if&rsquo;结构<br />
72 #+ 来简化这个脚本.<br />
73 # 2) Add detection of the &ldquo;Home,&rdquo; &ldquo;End,&rdquo; &ldquo;PgUp,&rdquo; and &ldquo;PgDn&rdquo; keys.<br />
73 # 2) 添加&rdquo;Home,&rdquo; &ldquo;End,&rdquo; &ldquo;PgUp,&rdquo; 和 &ldquo;PgDn&rdquo;这些按键的检查.<br />
################################End
Script#########################################<br />
注意: 对read命令来说,-n 选项将不会检测ENTER(新行)键.</p>

<p>read命令的-t选项允许时间输入(见Example 9-4).</p>

<p>read命令也可以从重定向的文件中读入变量的值.如果文件中的内容超过一行,那么只有第<br />
一行被分配到这个变量中.如果read命令有超过一个参数,那么每个变量都会从文件中取得<br />
以定义的空白分隔的字符串作为变量的值.小心!<br />
Example 11-7 通过文件重定向来使用read<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 read var1  4 echo &ldquo;var1 = $var1&rdquo;<br />
5 # var1将会把data-file的第一行的全部内容都作为它的值.<br />
6<br />
7 read var2 var3  8 echo &ldquo;var2 = $var2 var3 = $var3&rdquo;<br />
9 # 注意,这里&rdquo;read&rdquo;命令将会产生一种不直观的行为.<br />
10 # 1) 重新从文件的开头开始读入变量.<br />
11 # 2) 每个变量都设置成了以空白分割的字符串,<br />
12 # 而不是之前的以整行的内容作为变量的值.<br />
13 # 3) 而最后一个变量将会取得第一行剩余的全部部分(不管是否以空白分割).<br />
14 # 4) 如果需要赋值的变量的个数比文件中第一行一空白分割的字符串的个数多的话,<br />
15 # 那么这些变量将会被赋空值.<br />
16<br />
17 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
18<br />
19 # 如何用循环来解决上边所提到的问题:<br />
20 while read line<br />
21 do<br />
22 echo &ldquo;$line&rdquo;<br />
23 done  24 # Thanks, Heiner Steven for pointing this out.<br />
25<br />
26 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
27<br />
28 # 使用$IFS (内部域分隔变量)来将每行的输入单独的放到&rdquo;read&rdquo;中,<br />
29 # 如果你不想使用默认空白的话.<br />
30<br />
31 echo &ldquo;List of all users:&rdquo;<br />
32 OIFS=$IFS; IFS=: # /etc/passwd 使用 &ldquo;:&rdquo; 作为域分隔符.<br />
33 while read name passwd uid gid fullname ignore<br />
34 do<br />
35 echo &ldquo;$name ($fullname)&rdquo;<br />
36 done 37 IFS=$OIFS # 恢复原始的 $IFS.<br />
38 # 这个代码片段也是Heiner Steven写的.<br />
39<br />
40<br />
41<br />
42 # 在循环内部设置$IFS变量<br />
43 #+ 而不用把原始的$IFS<br />
44 #+ 保存到临时变量中.<br />
45 # Thanks, Dim Segebart, for pointing this out.<br />
46 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
47 echo &ldquo;List of all users:&rdquo;<br />
48<br />
49 while IFS=: read name passwd uid gid fullname ignore<br />
50 do<br />
51 echo &ldquo;$name ($fullname)&rdquo;<br />
52 done 53<br />
54 echo<br />
55 echo &ldquo;\$IFS still $IFS&rdquo;<br />
56<br />
57 exit 0<br />
################################End
Script#########################################</p>

<p>注意:管道输出到一个read命令中,使用管道echo输出到read会失败.<br />
然而使用管道cat输出看起来能够正常运行.<br />
1 cat file1 file2 |<br />
2 while read line<br />
3 do<br />
4 echo $line<br />
5 done</p>

<p>但是,像Bjon Eriksson指出的:<br />
Example 11-8 管道输出到read中的问题<br />
################################Start
Script#######################################<br />
1 #!/bin/sh<br />
2 # readpipe.sh<br />
3 # 这个例子是Bjon Eriksson捐献的.<br />
4<br />
5 last=&ldquo;(null)&rdquo;<br />
6 cat $0 |<br />
7 while read line<br />
8 do<br />
9 echo &ldquo;{$line}&rdquo;<br />
10 last=$line<br />
11 done<br />
12 printf &ldquo;\nAll done, last:$last\n&rdquo;<br />
13<br />
14 exit 0 # 代码结束.<br />
15 # 下边是这个脚本的部分输出.<br />
16 # 打印出了多余的大括号.<br />
17<br />
18 #############################################<br />
19<br />
20 ./readpipe.sh<br />
21<br />
22 {#!/bin/sh}<br />
23 {last=&ldquo;(null)&rdquo;}<br />
24 {cat $0 |}<br />
25 {while read line}<br />
26 {do}<br />
27 {echo &ldquo;{$line}&rdquo;}<br />
28 {last=$line}<br />
29 {done}<br />
30 {printf &ldquo;nAll done, last:$lastn&rdquo;}<br />
31<br />
32<br />
33 All done, last:(null)<br />
34<br />
35 变量(last)是设置在子shell中的而没设在外边.<br />
################################End
Script#########################################</p>

<p>在许多linux发行版上,gendiff脚本通常在/usr/bin下,将find的输出使用管道传递到一个<br />
while循环中.<br />
1 find $1 \( -name &ldquo;<em>$2&rdquo; -o -name &ldquo;.</em>$2&rdquo; \) -print |<br />
2 while read f; do<br />
3 &hellip;</p>

<p>文件系统类</p>

<p>cd<br />
cd,修改目录命令,在脚本中用得最多的时候就是,命令需要在指定目录下运行时,需要用cd<br />
修改当前工作目录.<br />
1 (cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)<br />
[之前有个例子,Alan Cox写的]</p>

<p>-P(physical)选项的作用是忽略符号连接.</p>

<p>cd - 将把工作目录改为$OLDPWD,就是之前的工作目录.</p>

<p>注意:当我们用两个/来作为cd命令的参数时,结果却出乎我们的意料.<br />
bash$ cd //<br />
bash$ pwd<br />
//</p>

<p>输出应该,并且当然是/.无论在命令行下还是在脚本中,这都是个问题.</p>

<p>pwd<br />
打印当前的工作目录.这将给用户(或脚本)当前的工作目录(见Example 11-9).使用这个<br />
命令的结果和从内键变量$PWD中读取的值是相同的.</p>

<p>pushd, popd, dirs<br />
这几个命令可以使得工作目录书签化,就是可以按顺序向前或向后移动工作目录.<br />
压栈的动作可以保存工作目录列表.选项可以允许对目录栈作不同的操作.</p>

<p>pushd dir-name 把路径dir-name压入目录栈,同时修改当前目录到dir-name.</p>

<p>popd 将目录栈中最上边的目录弹出,同时修改当前目录到弹出来的那个目录.</p>

<p>dirs 列出所有目录栈的内容(与$DIRSTACK便两相比较).一个成功的pushd或者popd将会<br />
自动的调用dirs命令.</p>

<p>对于那些并没有对当前工作目录做硬编码,并且需要对当前工作目录做灵活修改的脚本来说<br />
,使用这些命令是再好不过的了.注意内建$DIRSTACK数组变量,这个变量可以在脚本内存取,<br />
并且它们保存了目录栈的内容.</p>

<p>Example 11-9 修改当前的工作目录<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 dir1=/usr/local<br />
4 dir2=/var/spool<br />
5<br />
6 pushd $dir1<br />
7 # 将会自动运行一个 &lsquo;dirs&rsquo; (把目录栈的内容列到stdout上).<br />
8 echo &ldquo;Now in directory <code>pwd</code>.&rdquo; # Uses back-quoted &lsquo;pwd&rsquo;.<br />
9<br />
10 # 现在对&rsquo;dir1&rsquo;做一些操作.<br />
11 pushd $dir2<br />
12 echo &ldquo;Now in directory <code>pwd</code>.&rdquo;<br />
13<br />
14 # 现在对&rsquo;dir2&rsquo;做一些操作.<br />
15 echo &ldquo;The top entry in the DIRSTACK array is $DIRSTACK.&rdquo;<br />
16 popd<br />
17 echo &ldquo;Now back in directory <code>pwd</code>.&rdquo;<br />
18<br />
19 # 现在,对&rsquo;dir1&rsquo;做更多的操作.<br />
20 popd<br />
21 echo &ldquo;Now back in original working directory <code>pwd</code>.&rdquo;<br />
22<br />
23 exit 0<br />
24<br />
25 # 如果你不使用 &lsquo;popd&rsquo;将会发生什么 &ndash; 然后退出这个脚本?<br />
26 # 你最后将落在那个目录中?为什么?<br />
################################End
Script#########################################</p>

<p>变量类</p>

<p>let<br />
let命令将执行变量的算术操作.在许多情况下,它被看作是复杂的expr版本的一个简化版.<br />
Example 11-10 用&rdquo;let&rdquo;命令来作算术操作.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 echo<br />
4<br />
5 let a=11 # 与 &lsquo;a=11&rsquo; 相同<br />
6 let a=a+5 # 等价于let &ldquo;a = a + 5&rdquo;<br />
7 # (双引号和空格是这句话更具可读性.)<br />
8 echo &ldquo;11 + 5 = $a&rdquo; # 16<br />
9<br />
10 let &ldquo;a &lt;&lt;= 3&rdquo; # 等价于let &ldquo;a = a &lt;&lt; 3&rdquo;<br />
11 echo &ldquo;\&rdquo;\$a\&rdquo; (=16) left-shifted 3 places = $a&rdquo;<br />
12 # 128<br />
13<br />
14 let &ldquo;a /= 4&rdquo; # 等价于let &ldquo;a = a / 4&rdquo;<br />
15 echo &ldquo;128 / 4 = $a&rdquo; # 32<br />
16<br />
17 let &ldquo;a -= 5&rdquo; # 等价于let &ldquo;a = a - 5&rdquo;<br />
18 echo &ldquo;32 - 5 = $a&rdquo; # 27<br />
19<br />
20 let &ldquo;a *= 10&rdquo; # 等价于let &ldquo;a = a * 10&rdquo;<br />
21 echo &ldquo;27 * 10 = $a&rdquo; # 270<br />
22<br />
23 let &ldquo;a %= 8&rdquo; # 等价于let &ldquo;a = a % 8&rdquo;<br />
24 echo &ldquo;270 modulo 8 = $a (270 / 8 = 33, remainder $a)&rdquo;<br />
25 # 6<br />
26<br />
27 echo<br />
28<br />
29 exit 0<br />
################################End
Script#########################################</p>

<p>eval<br />
eval arg1 [arg2] &hellip; [argN]</p>

<p>将表达式中的参数,或者表达式列表,组合起来,并且评估它们.包含在表达式中的任何变量<br />
都将被扩展.结果将会被转化到命令中.这对于从命令行或者脚本中产生代码是很有用的.<br />
bash$ process=xterm<br />
bash$ show_process=&ldquo;eval ps ax | grep $process&rdquo;<br />
bash$ $show_process<br />
1867 tty1 S 0:02 xterm<br />
2779 tty1 S 0:00 xterm<br />
2886 pts/1 S 0:00 grep xterm</p>

<p>Example 11-11 显示eval命令的效果<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 y=<code>eval ls -l</code> # 与 y=<code>ls -l</code> 很相似<br />
4 echo $y #+ 但是换行符将被删除,因为echo的变量未被&rdquo;&ldquo;引用.<br />
5 echo<br />
6 echo &ldquo;$y&rdquo; # 用&rdquo;&ldquo;将变量引用,换行符就不会被空格替换了.<br />
7<br />
8 echo; echo<br />
9<br />
10 y=<code>eval df</code> # 与 y=<code>df</code> 很相似<br />
11 echo $y #+ 换行符又被空格替换了.<br />
12<br />
13 # 当没有LF(换行符)出现时,对于使用&rdquo;awk&rdquo;这样的工具来说,<br />
14 #+ 可能分析输出的结果更容易一些.<br />
15<br />
16 echo<br />
17 echo &ldquo;===========================================================&rdquo;<br />
18 echo<br />
19<br />
20 # Now, showing how to &ldquo;expand&rdquo; a variable using &ldquo;eval&rdquo; &hellip;<br />
20 # 现在,来看一下怎么用&rdquo;eval&rdquo;命令来扩展一个变量&hellip;<br />
21<br />
22 for i in 1 2 3 4 5; do<br />
23 eval value=$i<br />
24 # value=$i 将具有同样的效果. &ldquo;eval&rdquo;并不非得在这里使用.<br />
25 # 一个缺乏特殊含义的变量将被评估为自身 &ndash;<br />
26 #+ 也就是说,这个变量除了能够被扩展成自身所表示的字符,不能扩展成任何其他的含义.<br />
27 echo $value<br />
28 done<br />
29<br />
30 echo<br />
31 echo &ldquo;&mdash;&rdquo;<br />
32 echo<br />
33<br />
34 for i in ls df; do<br />
35 value=eval $i<br />
36 # value=$i has an entirely different effect here.<br />
36 # value=$i 在这里就与上边这句有了本质上的区别.<br />
37 # &ldquo;eval&rdquo; 将会评估命令 &ldquo;ls&rdquo; 和 &ldquo;df&rdquo; &hellip;<br />
38 # 术语 &ldquo;ls&rdquo; 和 &ldquo;df&rdquo; 就具有特殊含义,<br />
39 #+ 因为它们被解释成命令,<br />
40 #+ 而不是字符串本身.<br />
41 echo $value<br />
42 done<br />
43<br />
44<br />
45 exit 0<br />
################################End
Script#########################################</p>

<p>Example 11-12 强制登出(log-off)<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 结束ppp进程来强制登出log-off.<br />
3<br />
4 # 脚本应该以根用户的身份来运行.<br />
5<br />
6 killppp=&ldquo;eval kill -9 <code>ps ax | awk '/ppp/ { print $1 }'</code>&rdquo;<br />
7 # &mdash;&mdash;&ndash; ppp 的进程ID &mdash;&mdash;-<br />
8<br />
9 $killppp # 这个变量现在成为了一个命令.<br />
10<br />
11<br />
12 # 下边的命令必须以根用户的身份来运行.<br />
13<br />
14 chmod 666 /dev/ttyS3 # 恢复读写权限,否则什么?<br />
15 # 因为在ppp上执行一个SIGKILL将会修改串口的权限,<br />
16 #+ 我们把权限恢复到之前的状态.<br />
17<br />
18 rm /var/lock/LCK..ttyS3 # 删除串口琐文件.为什么?<br />
19<br />
20 exit 0<br />
21<br />
22 # 练习:<br />
23 # &mdash;&ndash;<br />
24 # 1) 编写一个脚本来验证是否跟用户正在运行它.<br />
25 # 2) 做一个检查,检查一下将要杀掉的进程<br />
26 #+ 再杀掉这个进程之前,它是否正在运行.<br />
27 # 3) 基于&rsquo;fuser&rsquo;来编写达到这个目的的另一个版本的脚本<br />
28 #+ if [ fuser -s /dev/modem ]; then &hellip;<br />
################################End
Script#########################################</p>

<p>Example 11-13 另一个&rdquo;rot13&rdquo;的版本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 使用&rsquo;eval&rsquo;的一个&rdquo;rot13&rdquo;的版本,(译者:rot13就是把26个字母,从中间分为2瓣,各13个)<br />
3 # 与脚本&rdquo;rot13.sh&rdquo; 比较一下.<br />
4<br />
5 setvar_rot_13() # &ldquo;rot13&rdquo; 函数<br />
6 {<br />
7 local varname=$1 varvalue=$2<br />
8 eval $varname=&lsquo;$(echo &ldquo;$varvalue&rdquo; | tr a-z n-za-m)&rsquo;<br />
9 }<br />
10<br />
11<br />
12 setvar_rot_13 var &ldquo;foobar&rdquo; # 用&rdquo;foobar&rdquo; 传递到rot13函数中.<br />
13 echo $var # 结果是sbbone<br />
14<br />
15 setvar_rot_13 var &ldquo;$var&rdquo; # 传递&rdquo;sbbone&rdquo; 到rot13函数中.<br />
16 # 又变成了原始值.<br />
17 echo $var # foobar<br />
18<br />
19 # 这个例子是Segebart Chazelas编写的.<br />
20 # 作者又修改了一下.<br />
21<br />
22 exit 0<br />
################################End
Script#########################################</p>

<p>Rory Winston捐献了下编的脚本,关于使用eval命令.<br />
Example 11-14 在Perl脚本中使用eval命令来强制变量替换<br />
################################Start
Script#######################################<br />
1 In the Perl script &ldquo;test.pl&rdquo;:<br />
2 &hellip;<br />
3 my $WEBROOT = ;<br />
4 &hellip;<br />
5<br />
6 To force variable substitution try:<br />
7 $export WEBROOT_PATH=/usr/local/webroot<br />
8 $sed &rsquo;s//$WEBROOT_PATH/&rsquo; &lt; test.pl &gt; out<br />
9<br />
10 But this just gives:<br />
11 my $WEBROOT = $WEBROOT_PATH;<br />
12<br />
13 However:<br />
14 $export WEBROOT_PATH=/usr/local/webroot<br />
15 $eval sed &rsquo;s%\%$WEBROOT_PATH%&rsquo; &lt; test.pl &gt; out<br />
16 # ====<br />
17<br />
18 That works fine, and gives the expected substitution:<br />
19 my $WEBROOT = /usr/local/webroot;<br />
20<br />
21<br />
22 ### Correction applied to original example by Paulo Marcel Coelho Aragao.<br />
################################End
Script#########################################</p>

<p>eval命令是有风险的,如果有更合适的方法来实现功能的话,尽量要避免使用它.<br />
eval命令将执行命令的内容,如果命令中有rm -rf*这种东西,可能就不是你想要的了.<br />
如果在一个不熟悉的人编写的脚本中使用eval命令将是危险的.</p>

<p>set<br />
set命令用来修改内部脚本变量的值.一个作用就是触发选项标志位来帮助决定脚本的行<br />
为.另一个应用就是以一个命令的结果(set <code>command</code>)来重新设置脚本的位置参数.脚本<br />
将会从命令的输出中重新分析出位置参数.<br />
Example 11-15 使用set来改变脚本的位置参数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # script &ldquo;set-test&rdquo;<br />
4<br />
5 # 使用3个命令行参数来调用这个脚本,<br />
6 # 比如, &ldquo;./set-test one two three&rdquo;.<br />
7<br />
8 echo<br />
9 echo &ldquo;Positional parameters before set \<code>uname -a\\</code> :&rdquo; #uname命令打印操作系统名<br />
10 echo &ldquo;Command-line argument #1 = $1&rdquo;<br />
11 echo &ldquo;Command-line argument #2 = $2&rdquo;<br />
12 echo &ldquo;Command-line argument #3 = $3&rdquo;<br />
13<br />
14<br />
15 set <code>uname -a</code> # 把<code>uname -a</code>的命令输出设置<br />
16 # 为新的位置参数.<br />
17<br />
18 echo $_ # 这要看你的unmae -a输出了,这句打印出的就是输出的最后一个单词.<br />
19 # 在脚本中设置标志.<br />
20<br />
21 echo &ldquo;Positional parameters after set \<code>uname -a\\</code> :&rdquo;<br />
22 # $1, $2, $3, 等等. 这些位置参数将被重新初始化为<code>uname -a</code>的结果<br />
23 echo &ldquo;Field #1 of &lsquo;uname -a&rsquo; = $1&rdquo;<br />
24 echo &ldquo;Field #2 of &lsquo;uname -a&rsquo; = $2&rdquo;<br />
25 echo &ldquo;Field #3 of &lsquo;uname -a&rsquo; = $3&rdquo;<br />
26 echo &mdash;<br />
27 echo $_ # &mdash;<br />
28 echo<br />
29<br />
30 exit 0<br />
################################End
Script#########################################</p>

<p>不使用任何选项或参数来调用set命令的话,将会列出所有的环境变量和其他所有的已经<br />
初始化过的命令.<br />
bash$ set<br />
AUTHORCOPY=/home/bozo/posts<br />
BASH=/bin/bash<br />
BASH_VERSION=$&lsquo;2.05.8(1)-release&rsquo;<br />
&hellip;<br />
XAUTHORITY=/home/bozo/.Xauthority<br />
_=/etc/bashrc<br />
variable22=abc<br />
variable23=xzy</p>

<p>使用参数&ndash;来调用set命令的话,将会明确的分配位置参数.如果&ndash;选项后边没有跟变量名<br />
的话,那么结果就使所有位置参数都比unset了.</p>

<p>Example 11-16 重新分配位置参数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 variable=&ldquo;one two three four five&rdquo;<br />
4<br />
5 set &ndash; $variable<br />
6 # 将位置参数的内容设为变量&rdquo;$variable&rdquo;的内容.<br />
7<br />
8 first_param=$1<br />
9 second_param=$2<br />
10 shift; shift # Shift past first two positional params.<br />
11 remaining_params=&ldquo;$*&rdquo;<br />
12<br />
13 echo<br />
14 echo &ldquo;first parameter = $first_param&rdquo; # one<br />
15 echo &ldquo;second parameter = $second_param&rdquo; # two<br />
16 echo &ldquo;remaining parameters = $remaining_params&rdquo; # three four five<br />
17<br />
18 echo; echo<br />
19<br />
20 # 再来一次.<br />
21 set &ndash; $variable<br />
22 first_param=$1<br />
23 second_param=$2<br />
24 echo &ldquo;first parameter = $first_param&rdquo; # one<br />
25 echo &ldquo;second parameter = $second_param&rdquo; # two<br />
26<br />
27 # ======================================================<br />
28<br />
29 set &ndash;<br />
30 # Unsets positional parameters if no variable specified.<br />
30 # 如果没指定变量,那么将会unset所有的位置参数.<br />
31<br />
32 first_param=$1<br />
33 second_param=$2<br />
34 echo &ldquo;first parameter = $first_param&rdquo; # (null value)<br />
35 echo &ldquo;second parameter = $second_param&rdquo; # (null value)<br />
36<br />
37 exit 0<br />
################################End
Script#########################################<br />
见Example 10-2,和Example 12-51.</p>

<p>unset<br />
unset命令用来删除一个shell变量,效果就是把这个变量设为null.注意:这个命令对位置<br />
参数无效.<br />
bash$ unset PATH</p>

<p>bash$ echo $PATH</p>

<p>bash$</p>

<p>Example 11-17 Unset一个变量<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # unset.sh: Unset一个变量.<br />
3<br />
4 variable=hello # 初始化.<br />
5 echo &ldquo;variable = $variable&rdquo;<br />
6<br />
7 unset variable # Unset.<br />
8 # 与 variable= 的效果相同.<br />
9 echo &ldquo;(unset) variable = $variable&rdquo; # $variable 设为 null.<br />
10<br />
11 exit 0<br />
################################End
Script#########################################</p>

<p>export<br />
export命令将会使得被export的变量在运行的脚本(或shell)的所有的子进程中都可用.<br />
不幸的是,没有办法将变量export到父进程(就是调用这个脚本或shell的进程)中.<br />
关于export命令的一个重要的使用就是用在启动文件中,启动文件是用来初始化并且<br />
设置环境变量,让用户进程可以存取环境变量.<br />
Example 11-18 使用export命令传递一个变量到一个内嵌awk的脚本中<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 这是&rdquo;求列的和&rdquo;脚本的另外一个版本(col-totaler.sh)<br />
4 #+ 那个脚本可以把目标文件中的指定的列上的所有数字全部累加起来,求和.<br />
5 # 这个版本将把一个变量通过export的形式传递到&rsquo;awk&rsquo;中 &hellip;<br />
6 #+ 并且把awk脚本放到一个变量中.<br />
7<br />
8<br />
9 ARGS=2<br />
10 E_WRONGARGS=65<br />
11<br />
12 if [ $# -ne &ldquo;$ARGS&rdquo; ] # 检查命令行参数的个数.<br />
13 then<br />
14 echo &ldquo;Usage: <code>basename $0</code> filename column-number&rdquo;<br />
15 exit $E_WRONGARGS<br />
16 fi<br />
17<br />
18 filename=$1<br />
19 column_number=$2<br />
20<br />
21 #===== 上边的这部分,与原始脚本完全一样 =====#<br />
22<br />
23 export column_number<br />
24 # 将列号通过export出来,这样后边的进程就可用了.<br />
25<br />
26<br />
27 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
28 awkscript=&lsquo;{ total += $ENVIRON[&ldquo;column_number&rdquo;] }<br />
29 END { print total }&rsquo;<br />
30 # 是的,一个变量可以保存一个awk脚本.<br />
31 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
32<br />
33 # 现在,运行awk脚本.<br />
34 awk &ldquo;$awkscript&rdquo; &ldquo;$filename&rdquo;<br />
35<br />
36 # Thanks, Stephane Chazelas.<br />
37<br />
38 exit 0<br />
################################End
Script#########################################</p>

<p>注意:可以在一个操作中同时赋值和export变量,如: export var1=xxx.</p>

<p>然而,像Greg Keraunen指出的,在某些情况下使用上边这种形式,将与先设置变量,然后<br />
export变量效果不同.</p>

<p>bash$ export var=(a b); echo ${var[0]}<br />
(a b)</p>

<p>bash$ var=(a b); export var; echo ${var[0]}<br />
a</p>

<p>declare, typeset<br />
declare和typeset命令被用来指定或限制变量的属性.</p>

<p>readonly<br />
与declare -r作用相同,设置变量的只读属性,也可以认为是设置常量.设置了这种属性之后<br />
如果你还要修改它,那么你将得到一个错误消息.这种情况与C语言中的const常量类型的情<br />
况是相同的.</p>

<p>getopts<br />
可以说这是分析传递到脚本的命令行参数的最强力工具.这个命令与getopt外部命令,和<br />
C语言中的库函数getopt的作用是相同的.它允许传递和连接多个选项[2]到脚本中,并能分<br />
配多个参数到脚本中.</p>

<p>getopts结构使用两个隐含变量.$OPTIND是参数指针(选项索引),和$OPTARG(选项参数)<br />
(可选的)可以在选项后边附加一个参数.在声明标签中,选项名后边的冒号用来提示<br />
这个选项名已经分配了一个参数.</p>

<p>getopts结构通常都组成一组放在一个while循环中,循环过程中每次处理一个选项和参数,<br />
然后增加隐含变量$OPTIND的值,再进行下一次的处理.</p>

<p>注意: 1.通过命令行传递到脚本中的参数前边必须加上一个减号(-).这是一个前缀,这样<br />
getopts命令将会认为这个参数是一个选项.事实上,getopts不会处理不带&rdquo;-&ldquo;前缀<br />
的参数,如果第一个参数就没有&rdquo;-&ldquo;,那么将结束选项的处理.</p>

<p>2.使用getopts的while循环模版还是与标准的while循环模版有些不同.没有标准<br />
while循环中的[]判断条件.</p>

<p>3.getopts结构将会取代getopt外部命令.</p>

<p>################################Start
Script#######################################<br />
1 while getopts &ldquo;:abcde:fg&rdquo; Option<br />
2 # Initial declaration.<br />
2 # 开始的声明.<br />
3 # a, b, c, d, e, f, 和 g 被认为是选项(标志).<br />
4 # e选项后边的:提示,这个选项带一个参数.<br />
5 do<br />
6 case $Option in<br />
7 a ) # Do something with variable &lsquo;a&rsquo;.<br />
7 a ) # 对选项&rsquo;a&rsquo;作些操作.<br />
8 b ) # 对选项&rsquo;b&rsquo;作些操作.<br />
9 &hellip;<br />
10 e) # Do something with &lsquo;e&rsquo;, and also with $OPTARG,<br />
10 e) # 对选项&rsquo;e&rsquo;作些操作, 同时处理一下$OPTARG,<br />
11 # which is the associated argument passed with option &lsquo;e&rsquo;.<br />
11 # 这个变量里边将保存传递给选项&rdquo;e&rdquo;的参数.<br />
12 &hellip;<br />
13 g ) # 对选项&rsquo;g&rsquo;作些操作.<br />
14 esac<br />
15 done<br />
16 shift $(($OPTIND - 1))<br />
17 # 将参数指针向下移动.<br />
18<br />
19 # 所有这些远没有它看起来的那么复杂.<br />
20<br />
################################End
Script#########################################</p>

<p>Example 11-19 使用getopts命令来读取传递给脚本的选项/参数.<br />
(我测试的结果与说明不同,我使用 ./scriptname -mnp,但是$OPTIND的值居然是1 1 2)<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 练习 getopts 和 OPTIND<br />
3 # 在Bill Gradwohl的建议下,这个脚本于 10/09/03 被修改.<br />
4<br />
5<br />
6 # 这里我们将学习 &lsquo;getopts&rsquo;如何处理脚本的命令行参数.<br />
7 # 参数被作为&rdquo;选项&rdquo;(标志)被解析,并且分配参数.<br />
8<br />
9 # 试一下通过如下方法来调用这个脚本<br />
10 # &lsquo;scriptname -mn&rsquo;<br />
11 # &lsquo;scriptname -oq qOption&rsquo; (qOption 可以是任意的哪怕有些诡异字符的字符串.)<br />
12 # &lsquo;scriptname -qXXX -r&rsquo;<br />
13 #<br />
14 # &lsquo;scriptname -qr&rsquo; - 意外的结果, &ldquo;r&rdquo; 将被看成是选项 &ldquo;q&rdquo; 的参数.<br />
15 # &lsquo;scriptname -q -r&rsquo; - 意外的结果, 同上.<br />
16 # &lsquo;scriptname -mnop -mnop&rsquo; - 意外的结果<br />
17 # (OPTIND is unreliable at stating where an option came from).<br />
18 #<br />
19 # 如果一个选项需要一个参数(&ldquo;flag:&ldquo;),那么它应该<br />
20 #+ 取得在命令行上挨在它后边的任何字符.<br />
21<br />
22 NO_ARGS=0<br />
23 E_OPTERROR=65<br />
24<br />
25 if [ $# -eq &ldquo;$NO_ARGS&rdquo; ] # 不带命令行参数就调用脚本?<br />
26 then<br />
27 echo &ldquo;Usage: <code>basename $0</code> options (-mnopqrs)&rdquo;<br />
28 exit $E_OPTERROR # 如果没有参数传进来,那就退出,并解释用法.<br />
29 fi<br />
30 # 用法: 脚本名 -选项名<br />
31 # 注意: 破折号(-)是必须的<br />
32<br />
33<br />
34 while getopts &ldquo;:mnopq:rs&rdquo; Option<br />
35 do<br />
36 case $Option in<br />
37 m ) echo &ldquo;Scenario #1: option -m- [OPTIND=${OPTIND}]&ldquo;;;<br />
38 n | o ) echo &ldquo;Scenario #2: option -$Option- [OPTIND=${OPTIND}]&ldquo;;;<br />
39 p ) echo &ldquo;Scenario #3: option -p- [OPTIND=${OPTIND}]&ldquo;;;<br />
40 q ) echo &ldquo;Scenario #4: option -q-\<br />
41 with argument \&ldquo;$OPTARG\&rdquo; [OPTIND=${OPTIND}]&ldquo;;;<br />
42 # 注意,选项&rsquo;q&rsquo;必须分配一个参数,<br />
43 #+ 否则默认将失败.<br />
44 r | s ) echo &ldquo;Scenario #5: option -$Option-&ldquo;;;<br />
45 * ) echo &ldquo;Unimplemented option chosen.&rdquo;;; # DEFAULT<br />
46 esac<br />
47 done<br />
48<br />
49 shift $(($OPTIND - 1))<br />
50 # 将参数指针减1,这样它将指向下一个参数.<br />
51 # $1 现在引用的是命令行上的第一个非选项参数<br />
52 #+ 如果有一个这样的参数存在的话.<br />
53<br />
54 exit 0<br />
55<br />
56 # 像 Bill Gradwohl 所说,<br />
57 # &ldquo;The getopts mechanism allows one to specify: scriptname -mnop -mnop<br />
58 #+ but there is no reliable way to differentiate what came from where<br />
59 #+ by using OPTIND.&rdquo;<br />
################################End
Script#########################################</p>

<p>脚本行为</p>

<p>source, . (点命令)<br />
这个命令在命令行上执行的时候,将会执行一个脚本.在一个文件内一个source file-name<br />
将会加载file-name文件.source一个文件(或点命令)将会在脚本中引入代码,并附加到脚<br />
本中(与C语言中的#include指令的效果相同).最终的结果就像是在使用&rdquo;sourced&rdquo;行上插<br />
入了相应文件的内容.这在多个脚本需要引用相同的数据,或函数库时非常有用.<br />
Example 11-20 &ldquo;Including&rdquo;一个数据文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 . data-file # 加载一个数据文件.<br />
4 # 与&rdquo;source data-file&rdquo;效果相同,但是更具可移植性.<br />
5<br />
6 # 文件&rdquo;data-file&rdquo;必须存在于当前工作目录,<br />
7 #+ 因为这个文件时使用&rsquo;basename&rsquo;来引用的.<br />
8<br />
9 # 现在,引用这个数据文件中的一些数据.<br />
10<br />
11 echo &ldquo;variable1 (from data-file) = $variable1&rdquo;<br />
12 echo &ldquo;variable3 (from data-file) = $variable3&rdquo;<br />
13<br />
14 let &ldquo;sum = $variable2 + $variable4&rdquo;<br />
15 echo &ldquo;Sum of variable2 + variable4 (from data-file) = $sum&rdquo;<br />
16 echo &ldquo;message1 (from data-file) is \&ldquo;$message1\&ldquo;&rdquo;<br />
17 # 注意 : 将双引号转义<br />
18<br />
19 print_message This is the message-print function in the data-file.<br />
20<br />
21<br />
22 exit 0<br />
################################End
Script#########################################<br />
Example 11-20使用的data-file.见上边,这个文件必须和上边的脚本放在同一目录下.<br />
################################Start
Script#######################################<br />
1 # 这是需要被脚本加载的data file.<br />
2 # 这种文件可以包含变量,函数,等等.<br />
3 # 在脚本中可以通过&rsquo;source&rsquo;或者&rsquo;.&lsquo;命令来加载.<br />
4<br />
5 # 让我们初始化一些变量.<br />
6<br />
7 variable1=22<br />
8 variable2=474<br />
9 variable3=5<br />
10 variable4=97<br />
11<br />
12 message1=&ldquo;Hello, how are you?&rdquo;<br />
13 message2=&ldquo;Enough for now. Goodbye.&rdquo;<br />
14<br />
15 print_message ()<br />
16 {<br />
17 # Echo出传递进来的任何消息.<br />
18<br />
19 if [ -z &ldquo;$1&rdquo; ]<br />
20 then<br />
21 return 1<br />
22 # 如果没有参数的话,出错.<br />
23 fi<br />
24<br />
25 echo<br />
26<br />
27 until [ -z &ldquo;$1&rdquo; ]<br />
28 do<br />
29 # 循环处理传递到函数中的参数.<br />
30 echo -n &ldquo;$1&rdquo;<br />
31 # 每次Echo 一个参数, -n禁止换行.<br />
32 echo -n &ldquo; &rdquo;<br />
33 # 在参数间插入空格.<br />
34 shift<br />
35 # 下一个.<br />
36 done<br />
37<br />
38 echo<br />
39<br />
40 return 0<br />
41 }<br />
################################End
Script#########################################</p>

<p>如果引入的文件本身就是一个可执行脚本的话,那么它将运行起来,当它return的时候,控制<br />
权又重新回到了引用它的脚本中.一个用source引入的脚本可以使用return 命令来达到这<br />
个目的.</p>

<p>也可以向需要source的脚本中传递参数.这些参数在source脚本中被认为是位置参数.<br />
1 source $filename $arg1 arg2</p>

<p>你甚至可以在脚本文件中source脚本文件自身,虽然看不出有什么实际的应用价值.<br />
Example 11-21 一个没什么用的,source自身的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # self-source.sh: 一个脚本递归的source自身.<br />
3 # 来自于&rdquo;Stupid Script Tricks,&rdquo; 卷 II.<br />
4<br />
5 MAXPASSCNT=100 # source自身的最大数量.<br />
6<br />
7 echo -n &ldquo;$pass_count &ldquo;<br />
8 # 在第一次运行的时候,这句只不过echo出2个空格,<br />
9 #+ 因为$pass_count还没被初始化.<br />
10<br />
11 let &ldquo;pass_count += 1&rdquo;<br />
12 # 假定这个为初始化的变量 $pass_count<br />
13 #+ 可以在第一次运行的时候+1.<br />
14 # 这句可以正常工作于Bash和pdksh,但是<br />
15 #+ 它依赖于不可移植(并且可能危险)的行为.<br />
16 # 更好的方法是在使用$pass_count之前,先把这个变量初始化为0.<br />
17<br />
18 while [ &ldquo;$pass_count&rdquo; -le $MAXPASSCNT ]<br />
19 do<br />
20 . $0 # 脚本&rdquo;sources&rdquo; 自身, 而不是调用自己.<br />
21 # ./$0 (应该能够正常递归) 但是不能在这正常运行. 为什么?<br />
22 done<br />
23<br />
24 # 这里发生的动作并不是真正的递归,<br />
25 #+ 因为脚本成功的展开了自己,换句话说,<br />
26 #+ 在每次循环的过程中<br />
27 #+ 在每个&rsquo;source&rsquo;行(第20行)上<br />
28 # 都产生了新的代码.<br />
29 #<br />
30 # 当然,脚本会把每个新&rsquo;sourced&rsquo;进来的文件的&rdquo;#!&ldquo;行<br />
31 #+ 都解释成注释,而不会把它看成是一个新的脚本.<br />
32<br />
33 echo<br />
34<br />
35 exit 0 # 最终的效果就是从1数到100.<br />
36 # 让人印象深刻.<br />
37<br />
38 # 练习:<br />
39 # &mdash;&ndash;<br />
40 # 使用这个小技巧编写一些真正能干些事情的脚本.<br />
################################End
Script#########################################</p>

<p>exit<br />
绝对的停止一个脚本的运行.exit命令有可以随便找一个整数变量作为退出脚本返回shell<br />
时的退出码.使用exit 0对于退出一个简单脚本来说是种好习惯,表明成功运行.</p>

<p>注意: 如果不带参数的使用exit来退出,那么退出码将是脚本中最后一个命令的退出码.<br />
等价于exit $?.</p>

<p>exec<br />
这个shell内建命令将使用一个特定的命令来取代当前进程.一般的当shell遇到一个命令,<br />
它会fork off一个子进程来真正的运行命令.使用exec内建命令,shell就不会fork了,并<br />
且命令的执行将会替换掉当前shell.因此,当我们在脚本中使用它时,当命令实行完毕,<br />
它就会强制退出脚本.[3]<br />
Example 11-22 exec的效果<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 exec echo &ldquo;Exiting \&ldquo;$0\&ldquo;.&rdquo; # 脚本将在此退出.<br />
4<br />
5 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
6 # 下边的部分将执行不到.<br />
7<br />
8 echo &ldquo;This echo will never echo.&rdquo;<br />
9<br />
10 exit 99 # 脚本不会在这退出.<br />
11 # 脚本退出后检查一下退出码<br />
12 #+ 使用&rsquo;echo $?&lsquo;命令.<br />
13 # 肯定不是99.<br />
################################End
Script#########################################</p>

<p>Example 11-23 一个exec自身的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # self-exec.sh<br />
3<br />
4 echo<br />
5<br />
6 echo &ldquo;This line appears ONCE in the script, yet it keeps echoing.&rdquo;<br />
7 echo &ldquo;The PID of this instance of the script is still $$.&rdquo;<br />
8 # 上边这句用来根本没产生子进程.<br />
9<br />
10 echo &ldquo;==================== Hit Ctl-C to exit ====================&rdquo;<br />
11<br />
12 sleep 1<br />
13<br />
14 exec $0 # 产生了本脚本的另一个实例,<br />
15 #+ 并且这个实例代替了之前的那个.<br />
16<br />
17 echo &ldquo;This line will never echo!&rdquo; # 当然会这样.<br />
18<br />
19 exit 0<br />
################################End
Script#########################################<br />
exec命令还能用于重新分配文件描述符.比如: exec  stdin.</p>

<p>注意: find命令的 -exec选项与shell内建的exec命令是不同的.</p>

<p>shopt<br />
这个命令允许shell在空闲时修改shell选项(见Example 24-1和Example 24-2).它经常出<br />
现在启动脚本中,但是在一般脚本中也可用.需要Bash 2.0版本以上.<br />
1 shopt -s cdspell<br />
2 # Allows minor misspelling of directory names with &lsquo;cd&rsquo;<br />
2 # 使用&rsquo;cd&rsquo;命令时,允许产生少量的拼写错误.<br />
3<br />
4 cd /hpme # 噢! 应该是&rsquo;/home&rsquo;.<br />
5 pwd # /home<br />
6 # 拼写错误被纠正了.</p>

<p>caller<br />
将caller命令放到函数中,将会在stdout上打印出函数调用者的信息.<br />
1 #!/bin/bash<br />
2<br />
3 function1 ()<br />
4 {<br />
5 # 在 function1 () 内部.<br />
6 caller 0 # 显示调用者信息.<br />
7 }<br />
8<br />
9 function1 # 脚本的第9行.<br />
10<br />
11 # 9 main test.sh<br />
12 # ^ 函数调用者所在的行号.<br />
13 # ^^^^ 从脚本的&rdquo;main&rdquo;部分调用的.<br />
14 # ^^^^^^^ 调用脚本的名字<br />
15<br />
16 caller 0 # 没效果,因为这个命令不再函数中.</p>

<p>caller命令也可以返回在一个脚本中被source的另一个脚本的信息.象函数一样,这是一个<br />
&ldquo;子例程调用&rdquo;,你会发现这个命令在调试的时候特别有用.</p>

<p>命令类</p>

<p>ture<br />
一个返回成功(就是返回0)退出码的命令,但是除此之外什么事也不做.<br />
1 # 死循环<br />
2 while true # 这里的true可以用&rdquo;:&ldquo;替换<br />
3 do<br />
4 operation-1<br />
5 operation-2<br />
6 &hellip;<br />
7 operation-n<br />
8 # 需要一种手段从循环中跳出来,或者是让这个脚本挂起.<br />
9 done</p>

<p>flase<br />
一个返回失败(非0)退出码的命令,但是除此之外什么事也不做.<br />
1 # 测试 &ldquo;false&rdquo;<br />
2 if false<br />
3 then<br />
4 echo &ldquo;false evaluates \&ldquo;true\&ldquo;&rdquo;<br />
5 else<br />
6 echo &ldquo;false evaluates \&ldquo;false\&ldquo;&rdquo;<br />
7 fi<br />
8 # 失败会显示&rdquo;false&rdquo;<br />
9<br />
10<br />
11 # while &ldquo;false&rdquo; 循环 (空循环)<br />
12 while false<br />
13 do<br />
14 # 这里边的代码将不会走到.<br />
15 operation-1<br />
16 operation-2<br />
17 &hellip;<br />
18 operation-n<br />
19 # 什么事都没发生!<br />
20 done</p>

<p>type[cmd]<br />
与which扩展命令很相像,type cmd将给出&rdquo;cmd&rdquo;的完整路径.与which命令不同的是,type命<br />
令是Bash内建命令.一个很有用的选项是-a选项,使用这个选项可以鉴别所识别的参数是关<br />
键字还是内建命令,也可以定位同名的系统命令.<br />
bash$ type &lsquo;[&rsquo;<br />
[ is a shell builtin<br />
bash$ type -a &lsquo;[&rsquo;<br />
[ is a shell builtin<br />
[ is /usr/bin/[</p>

<p>hash[cmds]<br />
在shell的hash表中[4],记录指定命令的路径名,所以在shell或脚本中在调用这个命令的<br />
话,shell或脚本将不需要再在$PATH中重新搜索这个命令了.如果不带参数的调用hash命<br />
令,它将列出所有已经被hash的命令.-r选项会重新设置hash表.</p>

<p>bind<br />
bind内建命令用来显示或修改readline[5]的键绑定.</p>

<p>help<br />
获得shell内建命令的一个小的使用总结.这与whatis命令比较象,但是help是内建命令.<br />
bash$ help exit<br />
exit: exit [n]<br />
Exit the shell with a status of N. If N is omitted, the exit status<br />
is that of the last command executed.</p>

<p>11.1 作业控制命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
下边的作业控制命令需要一个&rdquo;作业标识符&rdquo;作为参数.见这章结尾的表.</p>

<p>jobs<br />
在后台列出所有正在运行的作业,给出作业号.</p>

<p>注意: 进程和作业的概念太容易混淆了.特定的内建命令,比如kill,disown和wait即可以<br />
接受一个作业号作为参数也可以接受一个作为参数.但是fg,bg和jobs命令只能接受<br />
作业号作为参数.<br />
bash$ sleep 100 &amp;<br />
[1] 1384</p>

<p>bash $ jobs<br />
[1]+ Running sleep 100 &amp;</p>

<p>注意: &ldquo;1&rdquo;是作业号(作业是被当前shell所维护的),而&rdquo;1384&rdquo;是进程号(进程是被系统<br />
维护的).为了kill掉作业/进程,或者使用 kill %1命令或者使用kill 1384命令,<br />
这两个命令都可以.</p>

<p>感谢,S.C.</p>

<p>disown<br />
从shell的当前作业表中,删除作业.</p>

<p>fg,bg<br />
fg命令可以把一个在后台运行的作业放到前台来运行.而bg命令将会重新启动一个挂起的<br />
作业,并且在后台运行它.如果使用fg或者bg命令的时候没指定作业号,那么默认将对当前<br />
正在运行的作业做操作.</p>

<p>wait<br />
停止脚本的运行,直到后台运行的所有作业都结束为止,或者直到指定作业号或进程号为选<br />
项的作业结束为止.</p>

<p>你可以使用wait命令来防止在后台作业没完成(这会产生一个孤儿进程)之前退出脚本.</p>

<p>Example 11-24 在继续处理之前,等待一个进程的结束<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 ROOT_UID=0 # 只有$UID 为0的用户才拥有root权限.<br />
4 E_NOTROOT=65<br />
5 E_NOPARAMS=66<br />
6<br />
7 if [ &ldquo;$UID&rdquo; -ne &ldquo;$ROOT_UID&rdquo; ]<br />
8 then<br />
9 echo &ldquo;Must be root to run this script.&rdquo;<br />
10 # &ldquo;Run along kid, it&rsquo;s past your bedtime.&rdquo;<br />
11 exit $E_NOTROOT<br />
12 fi<br />
13<br />
14 if [ -z &ldquo;$1&rdquo; ]<br />
15 then<br />
16 echo &ldquo;Usage: <code>basename $0</code> find-string&rdquo;<br />
17 exit $E_NOPARAMS<br />
18 fi<br />
19<br />
20<br />
21 echo &ldquo;Updating &lsquo;locate&rsquo; database&hellip;&rdquo;<br />
22 echo &ldquo;This may take a while.&rdquo;<br />
23 updatedb /usr &amp; # 必须使用root身份来运行.<br />
24<br />
25 wait<br />
26 # 将不会继续向下运行,除非 &lsquo;updatedb&rsquo;命令执行完成.<br />
27 # 你希望在查找文件名之前更新database.<br />
28<br />
29 locate $1<br />
30<br />
31 # 如果没有&rsquo;wait&rsquo;命令的话,而且在比较糟的情况下,<br />
32 #+ 脚本可能在&rsquo;updatedb&rsquo;命令还在运行的时候退出,<br />
33 #+ 这将会导致&rsquo;updatedb&rsquo;成为一个孤儿进程.<br />
34<br />
35 exit 0<br />
################################End
Script#########################################</p>

<p>当然,wait 也可以接受一个作业标识符作为参数,比如,wait %1或wait $PPID.见&rdquo;作业标识<br />
符表&rdquo;.</p>

<p>注意: 在一个脚本中,使用一个后台运行的命令(使用&amp;)可能会使这个脚本挂起,直到敲<br />
回车,挂起才会被恢复.看起来只有这个命令的结果需要输出到stdout的时候才会发<br />
生这种现象.这会是一个很烦人的现象.<br />
1 #!/bin/bash<br />
2 # test.sh<br />
3<br />
4 ls -l &amp;<br />
5 echo &ldquo;Done.&rdquo;</p>

<p>bash$ ./test.sh<br />
Done.<br />
[bozo@localhost test-scripts]$ total 1<br />
-rwxr-xr-x 1 bozo bozo 34 Oct 11 15:09 test.sh<br />
_</p>

<p>看起来在这个后台运行命令的后边放上一个wait命令可能会解决这个问题.<br />
1 #!/bin/bash<br />
2 # test.sh<br />
3<br />
4 ls -l &amp;<br />
5 echo &ldquo;Done.&rdquo;<br />
6 wait</p>

<p>bash$ ./test.sh<br />
Done.<br />
[bozo@localhost test-scripts]$ total 1<br />
-rwxr-xr-x 1 bozo bozo 34 Oct 11 15:09 test.sh</p>

<p>如果把这个后台运行命令的输出重定向到文件中或者重定向到/dev/null中,也能解决<br />
这个问题.</p>

<p>suspend<br />
这个命令的效果与Control-Z很相像,但是它挂起的是这个shell(这个shell的父进程应该<br />
在合适的时候重新恢复它).</p>

<p>logout<br />
退出一个登陆的shell,也可以指定一个退出码.</p>

<p>times<br />
给出执行命令所占的时间,使用如下形式输出:<br />
0m0.020s 0m0.020s<br />
这是一种很有限的能力,因为这不常出现于shell脚本中.</p>

<p>kill<br />
通过发送一个适当的结束信号,来强制结束一个进程(见Example 13-6).<br />
Example 11-25 一个结束自身的脚本.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # self-destruct.sh<br />
3<br />
4 kill $$ # 脚本将在此处结束自己的进程.<br />
5 # Recall that &ldquo;$$&rdquo; is the script&rsquo;s PID.<br />
5 # 回忆一下,&ldquo;$$&ldquo;就是脚本的PID.<br />
6<br />
7 echo &ldquo;This line will not echo.&rdquo;<br />
8 # 而且shell将会发送一个&rdquo;Terminated&rdquo;消息到stdout.<br />
9<br />
10 exit 0<br />
11<br />
12 # 在脚本结束自身进程之后,<br />
13 #+ 它返回的退出码是什么?<br />
14 #<br />
15 # sh self-destruct.sh<br />
16 # echo $?<br />
17 # 143<br />
18 #<br />
19 # 143 = 128 + 15<br />
20 # 结束信号<br />
################################End
Script#########################################<br />
注意: kill -l将列出所有信号. kill -9 是&rdquo;必杀&rdquo;命令,这个命令将会结束哪些顽固的<br />
不想被kill掉的进程.有时候kill -15也可以干这个活.一个僵尸进程不能被登陆的<br />
用户kill掉, &ndash; 因为你不能杀掉一些已经死了的东西 &ndash; ,但是init进程迟早会<br />
把它清除干净.僵尸进程就是子进程已经结束掉,而父进程却没kill掉这个子进程,<br />
那么这个子进程就成为僵尸进程.</p>

<p>command<br />
command命令会禁用别名和函数的查找.它只查找内部命令以及搜索路径中找到的脚本或可<br />
执行程序.(译者,只在要执行的命令与函数或别名同名时使用,因为函数的优先级比内建命<br />
令的优先级高)</p>

<p>(译者:注意一下bash执行命令的优先级:<br />
1.别名<br />
2.关键字<br />
3.函数<br />
4.内置命令<br />
5.脚本或可执行程序($PATH)<br />
)</p>

<p>注意: 当象运行的命令或函数与内建命令同名时,由于内建命令比外部命令的优先级高,而<br />
函数比内建命令优先级高,所以bash将总会执行优先级比较高的命令.这样你就没有选<br />
择的余地了.所以Bash提供了3个命令来让你有选择的机会.command命令就是这3个命<br />
令之一.<br />
另外两个是builtin和enable.</p>

<p>builtin<br />
在&rdquo;builtin&rdquo;后边的命令将只调用内建命令.暂时的禁用同名的函数或者是同名的扩展命令.</p>

<p>enable<br />
这个命令或者禁用内建命令或者恢复内建命令.如: enable -n kill将禁用kill内建命令,<br />
所以当我们调用kill时,使用的将是/bin/kill外部命令.</p>

<p>-a选项将会恢复相应的内建命令,如果不带参数的话,将会恢复所有的内建命令.<br />
选项-f filename将会从适当的编译过的目标文件[6]中以共享库(DLL)的形式来加载一个<br />
内建命令.</p>

<p>autoload<br />
这是从ksh的autoloader命令移植过来的.一个带有&rdquo;autoload&rdquo;声明的函数,在它第一次被<br />
调用的时候才会被加载.[7] 这样做会节省系统资源.</p>

<p>注意: autoload命令并不是Bash安装时候的核心命令的一部分.这个命令需要使用命令<br />
enable -f(见上边enable命令)来加载.</p>

<h1 id="table-11-1-作业标识符">Table 11-1 作业标识符</h1>

<h1 id="记法-含义">记法 | 含义</h1>

<h1 id="n-作业号-n">%N | 作业号[N]</h1>

<h1 id="s-以字符串s开头的被-命令行-调用的作业">%S | 以字符串S开头的被(命令行)调用的作业</h1>

<h1 id="s-包含字符串s的被-命令行-调用的作业">%?S | 包含字符串S的被(命令行)调用的作业</h1>

<h1 id="当前作业-前台最后结束的作业-或后台最后启动的作业">%% | 当前作业(前台最后结束的作业,或后台最后启动的作业)</h1>

<h1 id="当前作业-前台最后结束的作业-或后台最后启动的作业-1">%+ | 当前作业(前台最后结束的作业,或后台最后启动的作业)</h1>

<h1 id="最后的作业">%- | 最后的作业</h1>

<h1 id="最后的后台进程">$! | 最后的后台进程</h1>

<p>注意事项:<br />
[1] 一个例外就是time命令,Bash官方文档说这个命令是一个关键字.<br />
[2] 一个选项就是一个行为上比较象标志位的参数,可以用来打开或关闭脚本的某些行为.<br />
而和某个特定选项相关的参数就是用来控制这个选项功能是开启还是关闭的.<br />
[3] 除非exec被用来重新分配文件描述符.<br />
[4] hash是一种处理存储在表中数据的方法,这种方法就是为表中的数据建立查找键.<br />
而数据项本身是不规则的,这样就可以通过一个简单的数学算法来产生一个数字,<br />
这个数字被用来作为查找键.</p>

<p>使用hash的一个最有利的地方就是提高了速度.而缺点就是会产生&rdquo;冲撞&rdquo; &ndash; 也就是<br />
说,可能会有多个数据元素使用同一个主键.</p>

<p>关于hash的例子见 Example A-21 和 Example A-22.<br />
[5] 在一个交互的shell中,readline库就是Bash用来读取输入的.<br />
(译者: 比如默认的Emacs风格的输入,当然也可以改为vi风格的输入)<br />
[6] 一些可加载的内建命令的C源代码都放在/usr/share/doc/bash-?.??/functions下.<br />
注意: enable命令的-f选项并不是对所有系统都支持的(看移没移植上).<br />
[7] typeset -fu可以达到和autoload命令相同的作用.</p>

<h1 id="第12章-外部过滤器-程序和命令">第12章 外部过滤器,程序和命令</h1>

<p>标准的 UNIX 命令使得 shell 脚本更加灵活.通过简单的编程结构把shell指令和系统命令结<br />
合起来,这才是脚本能力的所在.</p>

<p>12.1 基本命令<br />
-&mdash;&mdash;&mdash;&mdash;<br />
新手必须要掌握的初级命令</p>

<p>ls<br />
基本的列出所有文件的命令.但是往往就是因为这个命令太简单,所以我们总是低估它.比如<br />
,用 -R 选项,这是递归选项,ls 将会以目录树的形式列出所有文件, 另一个很有用的选项<br />
是 -S ,将会按照文件尺寸列出所有文件, -t, 将会按照修改时间来列出文件,-i 选项会显<br />
示文件的inode(见 Example 12-4).</p>

<p>Example 12-1 使用ls命令来创建一个烧录CDR的内容列表<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # ex40.sh (burn-cd.sh)<br />
3 # 自动刻录CDR的脚本.<br />
4<br />
5<br />
6 SPEED=2 # 如果你的硬件支持的话,你可以选用更高的速度.<br />
7 IMAGEFILE=cdimage.iso<br />
8 CONTENTSFILE=contents<br />
9 DEVICE=cdrom<br />
10 # DEVICE=&ldquo;0,0&rdquo; 为了使用老版本的CDR<br />
11 DEFAULTDIR=/opt # 这是包含需要被刻录内容的目录.<br />
12 # 必须保证目录存在.<br />
13 # 小练习: 测试一下目录是否存在.<br />
14<br />
15 # Uses Joerg Schilling&rsquo;s &ldquo;cdrecord&rdquo; package:<br />
15 # 使用 Joerg Schilling 的 &ldquo;cdrecord&rdquo;包:<br />
16 # <a href="http://www.fokus.fhg.de/usr/schilling/cdrecord.html">http://www.fokus.fhg.de/usr/schilling/cdrecord.html</a><br />
17<br />
18 # 如果一般用户调用这个脚本的话,可能需要root身份<br />
19 #+ chmod u+s /usr/bin/cdrecord<br />
20 # 当然, 这会产生安全漏洞, 虽然这是一个比较小的安全漏洞.<br />
21<br />
22 if [ -z &ldquo;$1&rdquo; ]<br />
23 then<br />
24 IMAGE_DIRECTORY=$DEFAULTDIR<br />
25 # 如果命令行没指定的话, 那么这个就是默认目录.<br />
26 else<br />
27 IMAGE_DIRECTORY=$1<br />
28 fi<br />
29<br />
30 # 创建一个内容列表文件.<br />
31 ls -lRF $IMAGE_DIRECTORY &gt; $IMAGE_DIRECTORY/$CONTENTSFILE<br />
32 # &ldquo;l&rdquo; 选项将给出一个&rdquo;长&rdquo;文件列表.<br />
33 # &ldquo;R&rdquo; 选项将使这个列表递归.<br />
34 # &ldquo;F&rdquo; 选项将标记出文件类型 (比如: 目录是以 /结尾, 而可执行文件以 *结尾).<br />
35 echo &ldquo;Creating table of contents.&rdquo;<br />
36<br />
37 # 在烧录到CDR之前创建一个镜像文件.<br />
38 mkisofs -r -o $IMAGEFILE $IMAGE_DIRECTORY<br />
39 echo &ldquo;Creating ISO9660 file system image ($IMAGEFILE).&rdquo;<br />
40<br />
41 # 烧录CDR.<br />
42 echo &ldquo;Burning the disk.&rdquo;<br />
43 echo &ldquo;Please be patient, this will take a while.&rdquo;<br />
44 cdrecord -v -isosize speed=$SPEED dev=$DEVICE $IMAGEFILE<br />
45<br />
46 exit $?<br />
################################End
Script#########################################</p>

<p>cat, tac<br />
cat, 是单词 concatenate的缩写, 把文件的内容输出到stdout. 当与重定向操作符 (&gt; 或<br />
&gt;&gt;)结合使用时, 一般都是用来将多个文件连接起来.</p>

<p>1 # Uses of &lsquo;cat&rsquo;<br />
2 cat filename # 打印出文件内容.<br />
3<br />
4 cat file.1 file.2 file.3 &gt; file.123 # 把3个文件连接到一个文件中.</p>

<p>cat 命令的 -n 选项是为了在目标文件中的所有行前边插入行号. -b 选项 与 -n 选项一<br />
样, 区别是不对空行进行编号. -v 选项可以使用 ^ 标记法 来echo 出不可打印字符.-s选<br />
项可以把多个空行压缩成一个空行.<br />
见 Example 12-25 和 Example 12-21.</p>

<p>注意: 在一个 管道 中, 可能有一种把stdin 重定向 到一个文件中的更有效的办法, 这<br />
种方法比 cat文件的方法更有效率.</p>

<p>1 cat filename | tr a-z A-Z<br />
2<br />
3 tr a-z A-Z &lt; filename # 效果相同,但是处理更少,<br />
4 #+ 并且连管道都省掉了.</p>

<p>tac 命令, 就是 cat的反转, 将从文件的结尾列出文件.</p>

<p>rev<br />
把每一行中的内容反转, 并且输出到 stdout上. 这个命令与 tac命令的效果是不同的, 因<br />
为它并不反转行序, 而是把每行的内容反转.</p>

<p>bash$ cat file1.txt<br />
This is line 1.<br />
This is line 2.</p>

<p>bash$ tac file1.txt<br />
This is line 2.<br />
This is line 1.</p>

<p>bash$ rev file1.txt<br />
.1 enil si sihT<br />
.2 enil si sihT</p>

<p>cp<br />
这是文件拷贝命令. cp file1 file2 把 file1 拷贝到 file2, 如果存在 file2 的话,那<br />
file2 将被覆盖 (见 Example 12-6).</p>

<p>注意: 特别有用的选项就是 -a 归档 选项 (为了copy一个完整的目录树), -u 是更新选<br />
项, 和 -r 与 -R 递归选项.</p>

<p>1 cp -u source_dir/* dest_dir<br />
2 # &ldquo;Synchronize&rdquo; dest_dir to source_dir把源目录&rdquo;同步&rdquo;到目标目录上,<br />
3 #+ 也就是拷贝所有更新的文件和之前不存在的文件.</p>

<p>mv<br />
这是文件移动命令. 它等价于 cp 与 rm 命令的组合. 它可以把多个文件移动到目录中,甚<br />
至将目录重命名. 想查看 mv 在脚本中使用的例子, 见 Example 9-18 和 Example A-2.</p>

<p>注意: 当使用非交互脚本时,可以使用 mv 的-f (强制) 选项来避免用户的输入.</p>

<p>当一个目录被移动到一个已存在的目录时,那么它将成为目标目录的子目录.</p>

<p>bash$ mv source_directory target_directory</p>

<p>bash$ ls -lF target_directory<br />
total 1<br />
drwxrwxr-x 2 bozo bozo 1024 May 28 19:20 source_directory/</p>

<p>rm<br />
删除(清除)一个或多个文件. -f 选项将强制删除文件,即使这个文件是只读的.并且可以<br />
用来避免用户输入(在非交互脚本中使用).</p>

<p>注意: rm 将无法删除以破折号开头的文件.<br />
bash$ rm -badname<br />
rm: invalid option &ndash; b<br />
Try `rm &ndash;help&rsquo; for more information.</p>

<p>解决这个问题的一个方法就是在要删除的文件的前边加上&rdquo;./&ldquo;.<br />
bash$ rm ./-badname</p>

<p>另一种解决的方法是 在文件名前边加上 &ldquo; &ndash; &ldquo;.<br />
bash$ rm &ndash; -badname</p>

<p>注意: 当使用递归参数 -r时, rm 命令将会删除整个目录树. 如果不慎使用 rm -rf *那整<br />
个目录树就真的完了.</p>

<p>rmdir<br />
删除目录. 但是只有这个目录中没有文件 &ndash; 当然会包含不可见的 点文件 [1] &ndash; 的<br />
时候这个命令才会成功.</p>

<p>mkdir<br />
生成目录, 创建一个空目录. 比如, mkdir -p project/programs/December 将会创建出<br />
这个指定的目录, 即使project目录和programs目录都不存在. -p 选项将会自动产生必要<br />
的父目录, 这样也就同时创建了多个目录.</p>

<p>chmod<br />
修改一个现存文件的属性 (见 Example 11-12).<br />
1 chmod +x filename<br />
2 # 使得文件filename对所有用户都可执行.<br />
3<br />
4 chmod u+s filename<br />
5 # 设置&rdquo;filename&rdquo;文件的&rdquo;suid&rdquo;位.<br />
6 # 这样一般用户就可以执行&rdquo;filename&rdquo;, 他将拥有和文件宿主相同的权限.<br />
7 # (这并不适用于shell 脚本)</p>

<p>1 chmod 644 filename<br />
2 # Makes &ldquo;filename&rdquo; readable/writable to owner, readable to<br />
3 # 设置文件宿主的 r/w 权限,并对一般用户<br />
3 # 设置读权限.<br />
4 # (8进制模式).</p>

<p>1 chmod 1777 directory-name<br />
2 # 对这个目录设置r/w 和可执行权限, 并开放给所有人.<br />
3 # 同时设置 &ldquo;粘贴位&rdquo;.<br />
4 # 这意味着, 只有目录宿主,<br />
5 # 文件宿主, 当然, 还有root<br />
6 # 可以删除这个目录中的任何特定的文件.</p>

<p>chattr<br />
修改文件属性. 这个命令与上边的 chmod 命令相类似, 但是有不同的选项和不同的调用语<br />
法, 并且这个命令只能工作在ext2文件系统中.</p>

<p>chattr 命令的一个特别有趣的选项是i. chattr +i filename 将使得这个文件被标记为<br />
永远不变. 这个文件将不能被修改, 连接, 或删除, 即使是root也不行. 这个文件属性只<br />
能被root设置和删除. 类似的, a 选项将会把文件标记为只能追加数据.</p>

<p>root# chattr +i file1.txt</p>

<p>root# rm file1.txt</p>

<p>rm: remove write-protected regular file <code>file1.txt'? y  
rm: cannot remove</code>file1.txt&rsquo;: Operation not permitted</p>

<p>如果文件设置了s(安全)属性, 那么当这个文件被删除时,这个文件所在磁盘的块将全部被0<br />
填充.</p>

<p>如果文件设置了u(不可删除)属性, 那么当这个文件被删除后, 这个文件的内容还可以被恢<br />
复(不可删除).</p>

<p>如果文件设置了c(压缩)属性, 那么当这个文件在进行写操作时,它将自动被压缩,并且在<br />
读的时候, 自动解压.</p>

<p>注意: 使用命令chattr do设置的属性, 将不会显示在文件列表中(ls -l).</p>

<p>ln<br />
创建文件链接, 前提是这个文件是存在的. &ldquo;链接&rdquo; 就是一个文件的引用, 也就是这个文<br />
件的另一个名字. ln 命令允许对同一个文件引用多个链接,并且是避免混淆的一个很好的<br />
方法 (见 Example 4-6).</p>

<p>ln 对于文件来说只不过是创建了一个引用, 一个指针而已, 因为创建出来的连接文件只有<br />
几个字节.</p>

<p>绝大多数使用ln 命令时使用是 -s 选项, 可以称为符号链接, 或软链接.使用 -s 选项的<br />
一个优点是它可以穿越文件系统来链接目录.</p>

<p>关于使用这个命令的语法还是有点小技巧的. 比如: ln -s oldfile newfile 将对老文件<br />
产生一个新的文件链接.</p>

<p>注意: 如果之前就存在newfile的话, 那么将会产生一个错误消息.</p>

<p>使用链接中的哪种类型?<br />
就像 John Macdonald 解释的那样:</p>

<p>不论是那种类型的链接, 都提供了一种双向引用的手段 &ndash; 也就是说, 不管你用文件<br />
的那个名字对文件内容进行修改, 你修改的效果都即会反映到原始名字的文件, 也会<br />
反映到链接名字的文件.当你工作在更高层次的时候, 才会发生软硬链接的不同. 硬链<br />
接的优点是, 原始文件与链接文件之间是相互独立的 &ndash; 如果你删除或者重命名老文<br />
件, 那么这种操作将不会影响硬链接的文件, 硬链接的文件讲还是原来文件的内容.<br />
然而如果你使用软链接的, 当你把老文件删除或重命名后, 软链接将再也找不到原来<br />
文件的内容了. 而软链接的优点是它可以跨越文件系统(因为它只不过是文件名的一个<br />
引用, 而并不是真正的数据). 与硬链接的另一个不同是, 一个符号链接可以指向一个<br />
目录.</p>

<p>链接给出了一种可以用多个名字来调用脚本的能力(当然这也适用于任何可执行的类型),<br />
并且脚本的行为将依赖于脚本是如何被调用的.</p>

<p>Example 12-2 Hello or Good-bye<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # hello.sh: 显示&rdquo;hello&rdquo; 还是 &ldquo;goodbye&rdquo;<br />
3 #+ 依赖于脚本是如何被调用的.<br />
4<br />
5 # 在当前目录下($PWD)为这个脚本创建一个链接:<br />
6 # ln -s hello.sh goodbye<br />
7 # 现在, 通过如下两种方法来调用这个脚本:<br />
8 # ./hello.sh<br />
9 # ./goodbye<br />
10<br />
11<br />
12 HELLO_CALL=65<br />
13 GOODBYE_CALL=66<br />
14<br />
15 if [ $0 = &ldquo;./goodbye&rdquo; ]<br />
16 then<br />
17 echo &ldquo;Good-bye!&rdquo;<br />
18 # 当然, 在这里你也可以添加一些其他的 goodbye类型的命令.Some other goodbye-type commands, as
appropriate.<br />
19 exit $GOODBYE_CALL<br />
20 fi<br />
21<br />
22 echo &ldquo;Hello!&rdquo;<br />
23 # 当然, 在这里你也可以添加一些其他的 hello类型的命令.<br />
24 exit $HELLO_CALL<br />
################################End
Script#########################################</p>

<p>man, info<br />
These 这两个命令用来查看系统命令或安装工具的手册和信息.当两者都可用时, info 页<br />
一般比 man也会包含更多的细节描述.</p>

<p>注意事项:<br />
[1] Dotfiles 就是文件名以&rdquo;.&ldquo;开头的文件, 比如 ~/.Xdefaults. 这样的文件在一般的 l<br />
s 命令使用中将不会被显示出来 (当然 ls -a 将会显示它们), 并且它们也不会被一<br />
个意外的 rm -rf *删除. 在用户的home目录中,Dotfiles 一般被用来当作安装和配置<br />
文件.</p>

<p>12.2 复杂命令<br />
-&mdash;&mdash;&mdash;&mdash;<br />
更高级的用户命令</p>

<p>find<br />
-exec COMMAND \;</p>

<p>在每一个find 匹配到的文件执行 COMMAND 命令. 命令序列以 ; 结束( &ldquo;;&rdquo; 是 转义符 以<br />
保证 shell 传递到find命令中的字符不会被解释为其他的特殊字符).</p>

<p>bash$ find ~/ -name &lsquo;*.txt&rsquo;<br />
/home/bozo/.kde/share/apps/karm/karmdata.txt<br />
/home/bozo/misc/irmeyc.txt<br />
/home/bozo/test-scripts/1.txt</p>

<p>如果 COMMAND 中包含 {}, 那么 find 命令将会用所有匹配文件的路径名来替换 &ldquo;{}&rdquo; .</p>

<p>1 find ~/ -name &lsquo;core*&rsquo; -exec rm {} \;<br />
2 # 从用户的 home 目录中删除所有的 core dump文件.</p>

<p>1 find /home/bozo/projects -mtime 1<br />
2 # 列出最后一天被修改的<br />
3 #+ 在/home/bozo/projects目录树下的所有文件.<br />
4 #<br />
5 # mtime = last modification time of the target file<br />
6 # ctime = last status change time (via &lsquo;chmod&rsquo; or otherwise)<br />
7 # atime = last access time<br />
8<br />
9 DIR=/home/bozo/junk_files<br />
10 find &ldquo;$DIR&rdquo; -type f -atime +5 -exec rm {} \;<br />
11 # ^^<br />
12 # 大括号就是&rdquo;find&rdquo;命令用来替换目录的地方.<br />
13 #<br />
14 # 删除至少5天内没被存取过的<br />
15 #+ &ldquo;/home/bozo/junk_files&rdquo; 中的所有文件.<br />
16 #<br />
17 # &ldquo;-type filetype&rdquo;, where<br />
18 # f = regular file<br />
19 # d = directory, etc.<br />
20 # (&lsquo;find&rsquo; 命令的 man页有完整的选项列表.)</p>

<p>1 find /etc -exec grep &lsquo;[0-9][0-9]<em>[.][0-9][0-9]</em>[.][0-9][0-9]<em>[.][0-9][0-9]</em>&lsquo;
{} \;<br />
2<br />
3 # 在/etc 目录中的文件找到所所有包含 IP 地址(xxx.xxx.xxx.xxx) 的文件.<br />
4 # 可能会查找到一些多余的匹配. 我们如何去掉它们呢?<br />
5<br />
6 # 或许可以使用如下方法:<br />
7<br />
8 find /etc -type f -exec cat &lsquo;{}&rsquo; \; | tr -c &lsquo;.[:digit:]&rsquo; &lsquo;\n&rsquo; \<br />
9 | grep &lsquo;^[^.][^.]<em>\.[^.][^.]</em>\.[^.][^.]<em>\.[^.][^.]</em>$&rsquo;<br />
10 #<br />
11 # [:digit:] 是一种字符类.is one of the character classes<br />
12 #+ 关于字符类的介绍见 POSIX 1003.2 标准化文档.<br />
13<br />
14 # Thanks, Stéphane Chazelas.</p>

<p>注意: find 命令的 -exec 选项不应该与shell中的内建命令 exec 相混淆.</p>

<p>Example 12-3 删除当前目录下文件名中包含一些特殊字符(包括空白)的文件..<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # badname.sh<br />
3 # 删除当前目录下文件名中包含一些特殊字符的文件.<br />
4<br />
5 for filename in *<br />
6 do<br />
7 badname=<code>echo &quot;$filename&quot; | sed -n
/[\\+\\{\;\&quot;\\\\\=\?~\\(\\)\\\&amp;\\*\|\$]/p</code><br />
8 # badname=<code>echo &quot;$filename&quot; | sed -n '/[+{;&quot;\=?~()&lt;&gt;&amp;*|$]/p'</code> 这句也行.<br />
9 # 删除文件名包含这些字符的文件: + { ; &ldquo; \ = ? ~ ( ) &lt; &gt; &amp; * | $<br />
10 #<br />
11 rm $badname 2&gt;/dev/null<br />
12 # ^^^^^^^^^^^ 错误消息将被抛弃.<br />
13 done<br />
14<br />
15 # 现在, 处理文件名中以任何方式包含空白的文件.<br />
16 find . -name &ldquo;* <em>&rdquo; -exec rm -f {} \;<br />
17 # &ldquo;find&rdquo;命令匹配到的目录名将替换到{}的位置.<br />
18 # &lsquo;\&rsquo; 是为了保证 &lsquo;;&lsquo;被正确的转义, 并且放到命令的结尾.<br />
19<br />
20 exit 0<br />
21<br />
22 #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
23 # 这行下边的命令将不会运行, 因为 &ldquo;exit&rdquo; 命令.<br />
24<br />
25 # 这句是上边脚本的一个可选方法:<br />
26 find . -name &lsquo;</em>[+{;&rdquo;\\=?~()&lt;&gt;&amp;<em>|$ ]</em>&rsquo; -exec rm -f &lsquo;{}&rsquo; \;<br />
27 # (Thanks, S.C.)<br />
################################End
Script#########################################</p>

<p>Example 12-4 通过文件的 inode 号来删除文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # idelete.sh: 通过文件的inode号来删除文件.<br />
3<br />
4 # 当文件名以一个非法字符开头的时候, 这就非常有用了,<br />
5 #+ 比如 ? 或 -.<br />
6<br />
7 ARGCOUNT=1 # 文件名参数必须被传递到脚本中.<br />
8 E_WRONGARGS=70<br />
9 E_FILE_NOT_EXIST=71<br />
10 E_CHANGED_MIND=72<br />
11<br />
12 if [ $# -ne &ldquo;$ARGCOUNT&rdquo; ]<br />
13 then<br />
14 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
15 exit $E_WRONGARGS<br />
16 fi<br />
17<br />
18 if [ ! -e &ldquo;$1&rdquo; ]<br />
19 then<br />
20 echo &ldquo;File \&ldquo;&rdquo;$1&rdquo;\&rdquo; does not exist.&rdquo;<br />
21 exit $E_FILE_NOT_EXIST<br />
22 fi<br />
23<br />
24 inum=<code>ls -i | grep &quot;$1&quot; | awk '{print $1}'</code><br />
25 # inum = inode (索引节点) 号.<br />
26 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
27 # 每个文件都有一个inode号, 这个号用来记录文件物理地址信息.<br />
28 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
29<br />
30 echo; echo -n &ldquo;Are you absolutely sure you want to delete \&ldquo;$1\&rdquo; (y/n)? &ldquo;<br />
31 # &lsquo;rm&rsquo; 命令的 &lsquo;-v&rsquo; 选项也会问这句话.<br />
32 read answer<br />
33 case &ldquo;$answer&rdquo; in<br />
34 [nN]) echo &ldquo;Changed your mind, huh?&rdquo;<br />
35 exit $E_CHANGED_MIND<br />
36 ;;<br />
37 *) echo &ldquo;Deleting file \&ldquo;$1\&ldquo;.&rdquo;;;<br />
38 esac<br />
39<br />
40 find . -inum $inum -exec rm {} \;<br />
41 # ^^<br />
42 # 大括号就是&rdquo;find&rdquo;命令<br />
43 #+ 用来替换文本输出的地方.<br />
44 echo &ldquo;File &ldquo;\&ldquo;$1&rdquo;\&rdquo; deleted!&rdquo;<br />
45<br />
46 exit 0<br />
################################End
Script#########################################<br />
见 Example 12-27, Example 3-4, 和 Example 10-9 这些例子展示了使用 find 命令. 对<br />
于这个复杂而有强大的命令来说, 查看man页可以获得更多的细节.</p>

<p>xargs<br />
这是给命令传递参数的一个过滤器, 也是组合多个命令的一个工具.它把一个数据流分割为<br />
一些足够小的块, 以方便过滤器和命令进行处理. 由此这个命令也是后置引用的一个强有<br />
力的替换. 在一般使用过多参数的命令替换失败的时候,用xargs 来替换它一般都能成功.<br />
[1] 通常情况下, xargs 从管道或者stdin中读取数据, 但是它也能够从文件的输出中读取<br />
数据.</p>

<p>xargs的默认命令是 echo. 这意味着通过管道传递给xargs的输入将会包含换行和空白, 不<br />
过通过xargs的处理, 换行和空白将被空格取代.</p>

<p>bash$ ls -l<br />
total 0<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Jan 29 23:58 file1<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Jan 29 23:58 file2</p>

<p>bash$ ls -l | xargs<br />
total 0 -rw-rw-r&ndash; 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r&ndash; 1 bozo bozo 0
Jan 29 23:58 file2</p>

<p>bash$ find ~/mail -type f | xargs grep &ldquo;Linux&rdquo;<br />
./misc:User-Agent: slrn/0.9.8.1 (Linux)<br />
./sent-mail-jul-2005: hosted by the Linux Documentation Project.<br />
./sent-mail-jul-2005: (Linux Documentation Project Site, rtf version)<br />
./sent-mail-jul-2005: Subject: Criticism of Bozo&rsquo;s Windows/Linux article<br />
./sent-mail-jul-2005: while mentioning that the Linux ext2/ext3 filesystem<br />
&hellip;</p>

<p>ls | xargs -p -l gzip 使用gzips 压缩当前目录下的每个文件, 一次压缩一个, 并且在<br />
每次压缩前都提示用户.</p>

<p>注意: 一个有趣的 xargs 选项是 -n NN, NN 是限制每次传递进来参数的个数.<br />
ls | xargs -n 8 echo 以每行8列的形式列出当前目录下的所有文件.</p>

<p>注意: 另一个有用的选项是 -0, 使用 find -print0 或 grep -lZ 这两种组合方式. 这允<br />
许处理包含空白或引号的参数.</p>

<p>find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f</p>

<p>grep -rliwZ GUI / | xargs -0 rm -f</p>

<p>上边两行都可用来删除任何包含 &ldquo;GUI&rdquo; 的文件. (Thanks, S.C.)</p>

<p>Example 12-5 Logfile: 使用 xargs 来监控系统 log<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 从 /var/log/messagesGenerates 的尾部开始<br />
4 # 产生当前目录下的一个lof 文件.<br />
5<br />
6 # 注意: 如果这个脚本被一个一般用户调用的话,<br />
7 # /var/log/messages 必须是全部可读的.<br />
8 # #root chmod 644 /var/log/messages<br />
9<br />
10 LINES=5<br />
11<br />
12 ( date; uname -a ) &gt;&gt;logfile<br />
13 # 时间和机器名<br />
14 echo &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
&gt;&gt;logfile<br />
15 tail -$LINES /var/log/messages | xargs | fmt -s &gt;&gt;logfile<br />
16 echo &gt;&gt;logfile<br />
17 echo &gt;&gt;logfile<br />
18<br />
19 exit 0<br />
20<br />
21 # 注意:<br />
22 # &mdash;&ndash;<br />
23 # 像 Frank Wang 所指出,<br />
24 #+ 在原文件中的任何不匹配的引号(包括单引号和双引号)<br />
25 #+ 都会给xargs造成麻烦.<br />
26 #<br />
27 # 他建议使用下边的这行来替换上边的第15行:<br />
28 # tail -$LINES /var/log/messages | tr -d &ldquo;\&ldquo;&lsquo;&rdquo; | xargs | fmt -s &gt;&gt;logfile<br />
29<br />
30<br />
31<br />
32 # 练习:<br />
33 # &mdash;&ndash;<br />
34 # 修改这个脚本, 使得这个脚本每个20分钟<br />
35 #+ 就跟踪一下 /var/log/messages 的修改记录.<br />
36 # 提示: 使用 &ldquo;watch&rdquo; 命令.<br />
################################End
Script#########################################<br />
在find命令中, 一对大括号就一个文本替换的位置.<br />
Example 12-6 把当前目录下的文件拷贝到另一个文件中<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # copydir.sh<br />
3<br />
4 # 拷贝 (verbose) 当前目录($PWD)下的所有文件到<br />
5 #+ 命令行中指定的另一个目录下.<br />
6<br />
7 E_NOARGS=65<br />
8<br />
9 if [ -z &ldquo;$1&rdquo; ] # 如果没有参数传递进来那就退出.<br />
10 then<br />
11 echo &ldquo;Usage: <code>basename $0</code> directory-to-copy-to&rdquo;<br />
12 exit $E_NOARGS<br />
13 fi<br />
14<br />
15 ls . | xargs -i -t cp ./{} $1<br />
16 # ^^ ^^ ^^<br />
17 # -t 是 &ldquo;verbose&rdquo; (输出命令行到stderr) 选项.<br />
18 # -i 是&rdquo;替换字符串&rdquo;选项.<br />
19 # {} 是输出文本的替换点.<br />
20 # 这与在&rdquo;find&rdquo;命令中使用{}的情况很相像.<br />
21 #<br />
22 # 列出当前目录下的所有文件(ls .),<br />
23 #+ 将 &ldquo;ls&rdquo; 的输出作为参数传递到 &ldquo;xargs&rdquo;(-i -t 选项) 中,<br />
24 #+ 然后拷贝(cp)这些参数({})到一个新目录中($1).<br />
25 #<br />
26 # 最终的结果和下边的命令等价,<br />
27 #+ cp * $1<br />
28 #+ 除非有文件名中嵌入了&rdquo;空白&rdquo;字符.<br />
29<br />
30 exit 0<br />
################################End
Script#########################################</p>

<p>Example 12-7 通过名字Kill进程<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # kill-byname.sh: 通过名字kill进程.<br />
3 # 与脚本kill-process.sh相比较.<br />
4<br />
5 # 例如,<br />
6 #+ 试一下 &ldquo;./kill-byname.sh xterm&rdquo; &ndash;<br />
7 #+ 并且查看你系统上的所有xterm都将消失.<br />
8<br />
9 # 警告:<br />
10 # &mdash;&ndash;<br />
11 # 这是一个非常危险的脚本.<br />
12 # 运行它的时候一定要小心. (尤其是以root身份运行时)<br />
13 #+ 因为运行这个脚本可能会引起数据丢失或产生其他一些不好的效果.<br />
14<br />
15 E_BADARGS=66<br />
16<br />
17 if test -z &ldquo;$1&rdquo; # 没有参数传递进来?<br />
18 then<br />
19 echo &ldquo;Usage: <code>basename $0</code> Process(es)_to_kill&rdquo;<br />
20 exit $E_BADARGS<br />
21 fi<br />
22<br />
23<br />
24 PROCESS_NAME=&ldquo;$1&rdquo;<br />
25 ps ax | grep &ldquo;$PROCESS_NAME&rdquo; | awk &lsquo;{print $1}&rsquo; | xargs -i kill {}
2&amp;&gt;/dev/null<br />
26 # ^^ ^^<br />
27<br />
28 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
29 # 注意:<br />
30 # -i 参数是xargs命令的&rdquo;替换字符串&rdquo;选项.<br />
31 # 大括号对的地方就是替换点.<br />
32 # 2&amp;&gt;/dev/null 将会丢弃不需要的错误消息.<br />
33 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
34<br />
35 exit $?<br />
################################End
Script#########################################</p>

<p>Example 12-8 使用xargs分析单词出现的频率<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # wf2.sh: Crude word frequency analysis on a text file.<br />
3<br />
4 # 使用 &lsquo;xargs&rsquo; 将文本行分解为单词.<br />
5 # 于后边的 &ldquo;wf.sh&rdquo; 脚本相比较.<br />
6<br />
7<br />
8 # 检查命令行上输入的文件.<br />
9 ARGS=1<br />
10 E_BADARGS=65<br />
11 E_NOFILE=66<br />
12<br />
13 if [ $# -ne &ldquo;$ARGS&rdquo; ]<br />
14 # 纠正传递到脚本中的参数个数?<br />
15 then<br />
16 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
17 exit $E_BADARGS<br />
18 fi<br />
19<br />
20 if [ ! -f &ldquo;$1&rdquo; ] # 检查文件是否存在.<br />
21 then<br />
22 echo &ldquo;File \&ldquo;$1\&rdquo; does not exist.&rdquo;<br />
23 exit $E_NOFILE<br />
24 fi<br />
25<br />
26<br />
27<br />
28 #################################################################<br />
29 cat &ldquo;$1&rdquo; | xargs -n1 | \<br />
30 # 列出文件, 每行一个单词.<br />
31 tr A-Z a-z | \<br />
32 # 将字符转换为小写.<br />
33 sed -e &rsquo;s/\.//g&rsquo; -e &rsquo;s/\,//g&rsquo; -e &rsquo;s/ /\<br />
34 /g&rsquo; | \<br />
35 # 过滤掉句号和逗号,<br />
36 #+ 并且将单词间的空格修改为换行,<br />
37 sort | uniq -c | sort -nr<br />
38 # 最后统计出现次数,把数字显示在第一列,然后显示单词,并按数字排序.<br />
39 #################################################################<br />
40<br />
41 # 这个例子的作用与&rdquo;wf.sh&rdquo;的作用是一样的,<br />
42 #+ 但是这个例子比较臃肿, 并且运行起来更慢一些(为什么?).<br />
43<br />
44 exit 0<br />
################################End
Script#########################################</p>

<p>expr<br />
通用求值表达式: 通过给定的操作(参数必须以空格分开)连接参数,并对参数求值.可以使<br />
算术操作, 比较操作, 字符串操作或者是逻辑操作.</p>

<p>expr 3 + 5</p>

<p>返回 8<br />
expr 5 % 3</p>

<p>返回 2<br />
expr 1 / 0</p>

<p>返回错误消息, expr: division by zero</p>

<p>不允许非法的算术操作.<br />
expr 5 \* 3</p>

<p>返回 15</p>

<p>在算术表达式expr中使用乘法操作时, 乘法符号必须被转义.<br />
y=<code>expr $y + 1</code></p>

<p>增加变量的值, 与 let y=y+1 和 y=$(($y+1)) 的效果相同. 这是使用算术表达式的<br />
一个例子.<br />
z=<code>expr substr $string $position $length</code></p>

<p>在位置$position上提取$length长度的子串.</p>

<p>Example 12-9 使用 expr<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 展示一些 &lsquo;expr&rsquo;的使用<br />
4 # =====================<br />
5<br />
6 echo<br />
7<br />
8 # 算术 操作<br />
9 # &mdash;- &mdash;-<br />
10<br />
11 echo &ldquo;Arithmetic Operators&rdquo;<br />
12 echo<br />
13 a=<code>expr 5 + 3</code><br />
14 echo &ldquo;5 + 3 = $a&rdquo;<br />
15<br />
16 a=<code>expr $a + 1</code><br />
17 echo<br />
18 echo &ldquo;a + 1 = $a&rdquo;<br />
19 echo &ldquo;(incrementing a variable)&rdquo;<br />
20<br />
21 a=<code>expr 5 % 3</code><br />
22 # 取模操作<br />
23 echo<br />
24 echo &ldquo;5 mod 3 = $a&rdquo;<br />
25<br />
26 echo<br />
27 echo<br />
28<br />
29 # 逻辑 操作<br />
30 # &mdash;- &mdash;-<br />
31<br />
32 # true返回 1 ,false 返回 0 ,<br />
33 #+ 而Bash的使用惯例则相反.<br />
34<br />
35 echo &ldquo;Logical Operators&rdquo;<br />
36 echo<br />
37<br />
38 x=24<br />
39 y=25<br />
40 b=<code>expr $x = $y</code> # 测试相等.<br />
41 echo &ldquo;b = $b&rdquo; # 0 ( $x -ne $y )<br />
42 echo<br />
43<br />
44 a=3<br />
45 b=<code>expr $a \&gt; 10</code><br />
46 echo &lsquo;b=<code>expr $a \&gt; 10</code>, therefore&hellip;&rsquo;<br />
47 echo &ldquo;If a &gt; 10, b = 0 (false)&rdquo;<br />
48 echo &ldquo;b = $b&rdquo; # 0 ( 3 ! -gt 10 )<br />
49 echo<br />
50<br />
51 b=<code>expr $a \&lt; 10</code><br />
52 echo &ldquo;If a &lt; 10, b = 1 (true)&rdquo;<br />
53 echo &ldquo;b = $b&rdquo; # 1 ( 3 -lt 10 )<br />
54 echo<br />
55 # Note escaping of operators.<br />
56<br />
57 b=<code>expr $a \&lt;= 3</code><br />
58 echo &ldquo;If a &lt;= 3, b = 1 (true)&rdquo;<br />
59 echo &ldquo;b = $b&rdquo; # 1 ( 3 -le 3 )<br />
60 # 也有 &ldquo;&gt;=&rdquo; 操作 (大于等于).<br />
61<br />
62<br />
63 echo<br />
64 echo<br />
65<br />
66<br />
67<br />
68 # 字符串 操作<br />
69 # &mdash;&mdash; &mdash;-<br />
70<br />
71 echo &ldquo;String Operators&rdquo;<br />
72 echo<br />
73<br />
74 a=1234zipper43231<br />
75 echo &ldquo;The string being operated upon is \&ldquo;$a\&ldquo;.&rdquo;<br />
76<br />
77 # 长度: 字符串长度<br />
78 b=<code>expr length $a</code><br />
79 echo &ldquo;Length of \&ldquo;$a\&rdquo; is $b.&rdquo;<br />
80<br />
81 # 索引: 从字符串的开头查找匹配的子串,<br />
82 # 并取得第一个匹配子串的位置.<br />
83 b=<code>expr index $a 23</code><br />
84 echo &ldquo;Numerical position of first \&ldquo;2\&rdquo; in \&ldquo;$a\&rdquo; is \&ldquo;$b\&ldquo;.&rdquo;<br />
85<br />
86 # substr: 从指定位置提取指定长度的字串.<br />
87 b=<code>expr substr $a 2 6</code><br />
88 echo &ldquo;Substring of \&ldquo;$a\&ldquo;, starting at position 2,\<br />
89 and 6 chars long is \&ldquo;$b\&ldquo;.&rdquo;<br />
90<br />
91<br />
92 # &lsquo;match&rsquo; 操作的默认行为就是<br />
93 #+ 从字符串的开始进行搜索,并匹配第一个匹配的字符串.<br />
94 #<br />
95 # 使用正则表达式<br />
96 b=<code>expr match &quot;$a&quot; '[0-9]*'</code> # 数字的个数.<br />
97 echo Number of digits at the beginning of \&ldquo;$a\&rdquo; is $b.<br />
98 b=<code>expr match &quot;$a&quot; '\\([0-9]*\\)'</code> # 注意需要转义括号<br />
99 # == == + 这样才能触发子串的匹配.<br />
100 echo &ldquo;The digits at the beginning of \&ldquo;$a\&rdquo; are \&ldquo;$b\&ldquo;.&rdquo;<br />
101<br />
102 echo<br />
103<br />
104 exit 0<br />
################################End
Script#########################################<br />
注意: &ldquo;:&rdquo; 操作可以替换 match. 比如, b=<code>expr $a : [0-9]*</code>与上边所使用的 b=<code>expr  
match $a [0-9]*</code> 完全等价.</p>

<p>################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 echo<br />
4 echo &ldquo;String operations using \&ldquo;expr \$string : \&rdquo; construct&rdquo;<br />
5 echo &ldquo;===================================================&rdquo;<br />
6 echo<br />
7<br />
8 a=1234zipper5FLIPPER43231<br />
9<br />
10 echo &ldquo;The string being operated upon is \&rdquo;<code>expr &quot;$a&quot; : '\\(.*\\)'</code>\&ldquo;.&rdquo;<br />
11 # 转义括号对操作. == ==<br />
12<br />
13 # ***************************<br />
14 #+ 转移括号对<br />
15 #+ 用来匹配一个子串<br />
16 # ***************************<br />
17<br />
18<br />
19 # 如果不转义括号的话&hellip;<br />
20 #+ 那么 &lsquo;expr&rsquo; 将把string操作转换为一个整数.<br />
21<br />
22 echo &ldquo;Length of \&ldquo;$a\&rdquo; is <code>expr &quot;$a&quot; : '.*'</code>.&rdquo; # 字符串长度<br />
23<br />
24 echo &ldquo;Number of digits at the beginning of \&ldquo;$a\&rdquo; is <code>expr &quot;$a&quot; :
'[0-9]*'</code>.&rdquo;<br />
25<br />
26 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>27<br />
28 echo<br />
29<br />
30 echo &ldquo;The digits at the beginning of \&ldquo;$a\&rdquo; are <code>expr &quot;$a&quot; :
'\\([0-9]*\\)'</code>.&rdquo;<br />
31 # == ==<br />
32 echo &ldquo;The first 7 characters of \&ldquo;$a\&rdquo; are <code>expr &quot;$a&quot; : '\\(.......\\)'</code>.&rdquo;<br />
33 # ===== == ==<br />
34 # 再来一个, 转义括号对强制一个子串匹配.<br />
35 #<br />
36 echo &ldquo;The last 7 characters of \&ldquo;$a\&rdquo; are <code>expr &quot;$a&quot; : '.*\\(.......\\)'</code>.&rdquo;<br />
37 # ==== end of string operator ^^<br />
38 # (最后这个模式的意思是忽略前边的任何字符,直到最后7个字符,<br />
39 #+ 最后7个点就是需要匹配的任意7个字符的字串)<br />
40<br />
41 echo<br />
42<br />
43 exit 0<br />
################################End
Script#########################################</p>

<p>上边的脚本展示了expr是如何使用转义的括号对 &ndash; \( &hellip; \) &ndash; 和 正则表达式 一起来分<br />
析和匹配子串. 下边是另外一个例子, 这次的例子是真正的应用用例.</p>

<p>1 # 去掉字符串开头和结尾的空白.<br />
2 LRFDATE=<code>expr &quot;$LRFDATE&quot; : '[[:space:]]*\\(.*\\)[[:space:]]*$'</code><br />
3<br />
4 # 来自于 Peter Knowle的 &ldquo;booklistgen.sh&rdquo; 脚本<br />
5 #+ 用来将文件转换为Sony Librie格式.<br />
6 # (<a href="http://booklistgensh.peterknowles.com">http://booklistgensh.peterknowles.com</a>)</p>

<p>Perl, sed, 和 awk 是更强大的字符串分析工具. 在脚本中嵌入一段比较短的 sed 或 awk<br />
操作 (见 Section 33.2) 比使用 expr 更加有吸引力.</p>

<p>见 Section 9.2 将会有更多使用 expr 进行字符串操作的例子.</p>

<p>注意事项:</p>

<p>[1] 即使在不必非得强制使用 xargs 的时候, 使用 xargs 也可以明显地提高多文件批处<br />
理执行命令的速度.</p>

<p>12.3 时间/日期 命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
时间/日期 和计时</p>

<p>date<br />
直接调用, date 就会打印日期和时间到 stdout 上. 这个命令有趣的地方在于它的格式化<br />
和分析选项上.</p>

<p>Example 12-10 使用 date 命令<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 练习 &lsquo;date&rsquo; 命令<br />
3<br />
4 echo &ldquo;The number of days since the year&rsquo;s beginning is <code>date +%j</code>.&rdquo;<br />
5 # 需要在调用格式的前边加上一个 &lsquo;+&rsquo; 号.<br />
6 # %j 给出今天是本年度的第几天.<br />
7<br />
8 echo &ldquo;The number of seconds elapsed since 01/01/1970 is <code>date +%s</code>.&rdquo;<br />
9 # %s 将产生从 &ldquo;UNIX 元年&rdquo; 到现在为止的秒数,yields number of seconds since &ldquo;UNIX epoch&rdquo;
began,<br />
10 #+ 但是这东西有用么?<br />
11<br />
12 prefix=temp<br />
13 suffix=$(date +%s) # &lsquo;date&rsquo;命令的 &ldquo;+%s&rdquo; 选项是 GNU-特性.<br />
14 filename=$prefix.$suffix<br />
15 echo $filename<br />
16 # 这是一种非常好的产生 &ldquo;唯一&rdquo; 的临时文件的办法,<br />
17 #+ 甚至比使用 $$ 都强.<br />
18<br />
19 # 如果想了解 &lsquo;date&rsquo; 命令的更多选项, 请查阅这个命令的 man 页.<br />
20<br />
21 exit 0<br />
################################End
Script#########################################<br />
-u 选项将给出 UTC (译者: UTC 是协调世界时英文缩写) 时间(Universal Coordinated T<br />
ime).</p>

<p>bash$ date<br />
Fri Mar 29 21:07:39 MST 2002</p>

<p>bash$ date -u<br />
Sat Mar 30 04:07:42 UTC 2002</p>

<p>date 命令有许多的输出选项. 比如 %N 将以10亿分之一为单位表示当前时间. 这个选项的<br />
一个有趣的用法就是用来产生一个6位的随机数.</p>

<p>1 date +%N | sed -e &rsquo;s/000$//&rsquo; -e &rsquo;s/^0//&rsquo;<br />
2 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br />
3 # 去掉开头和结尾的0.</p>

<p>当然,还有许多其它的选项 (请查看 man date).</p>

<p>1 date +%j<br />
2 # 显示今天是本年度的第几天(从1月1日开始计算).<br />
3<br />
4 date +%k%M<br />
5 # 显示当前小时数和分钟数.<br />
6<br />
7<br />
8<br />
9 # &lsquo;TZ&rsquo; 参数允许改变当前的默认时区.<br />
10 date # Mon Mar 28 21:42:16 MST 2005<br />
11 TZ=EST date # Mon Mar 28 23:42:16 EST 2005<br />
12 # Thanks, Frank Kannemann and Pete Sjoberg, for the tip.<br />
13<br />
14<br />
15 SixDaysAgo=$(date &ndash;date=&lsquo;6 days ago&rsquo;)<br />
16 OneMonthAgo=$(date &ndash;date=&lsquo;1 month ago&rsquo;) # 4周前(不是一个月).<br />
17 OneYearAgo=$(date &ndash;date=&lsquo;1 year ago&rsquo;)</p>

<p>参见 Example 3-4.</p>

<p>zdump<br />
查看特定时区的当前时间.</p>

<p>bash$ zdump EST<br />
EST Tue Sep 18 22:09:22 2001 EST</p>

<p>time<br />
输出统计出来的命令执行的时间.<br />
time ls -l / 给出的输出大概是如下格式:</p>

<p>0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k<br />
0inputs+0outputs (149major+27minor)pagefaults 0swaps</p>

<p>参见前边章节所讲的一个类似的命令 times .</p>

<p>注意: 在Bash的 2.0版本 中, time 成为了shell的一个保留字, 并且在一个带有管道的<br />
命令行中,这个命令的行为有些小的变化.</p>

<p>touch<br />
这是一个用来更新文件被存取或修改的时间的工具,这个时间可以是当前系统的时间,也可<br />
以是指定的时间, 这个命令也用来产生一个新文件.命令 touch zzz 将产生一个以zzz为名<br />
字的0字节长度文件, 当然前提是zzz文件不存在. 为了存储时间信息, 就需要一个时间戳<br />
为空的文件, 比如当你想跟踪一个工程的修改时间的时候,这就非常有用了.</p>

<p>注意: touch 命令等价于 : &gt;&gt; newfile 或 &gt;&gt; newfile (对于一个普通文件).</p>

<p>at<br />
at 命令是一个作业控制命令, 用来在指定时间执行给定的命令集合.它有点像 cron 命令,<br />
然而, at 命令主要还是用来执行那种一次性执行的命令集合.</p>

<p>at 2pm January 15 将会提示让你输入需要在这个时间你要执行的命令序列. 这些命令应<br />
该是可以和shell脚本兼容的,因为, 实际上, 在一个可执行的脚本中, 用户每次只能敲一<br />
行. 输入以 Ctl-D 结束.</p>

<p>你可以使用-f选项或者使用 ( 集合. 这个文件其实就一个可执行的的脚本, 虽然它是一个不可交互的脚本. 在文件中包<br />
含一个 run-parts 命令, 对于执行一套不同的脚本来说是非常聪明的做法.</p>

<p>bash$ at 2:30 am Friday &lt; at-jobs.list<br />
job 2 at 2000-10-27 02:30</p>

<p>batch<br />
batch 作业控制命令与 at 命令的行为很相像, 但 batch 命令被用来在系统平均载量降到<br />
0.8 以下时执行一次性的任务. 与 at 命令相似的是, 它也可以使用 -f 选项来从文件中<br />
读取命令.</p>

<p>cal<br />
从stdout中输出一个格式比较整齐的日历. 也可以指定年和月来显示那个月的日历.</p>

<p>sleep<br />
这个命令与一个等待循环的效果一样. 你可以指定需要暂停的秒数, 这段时间将什么都不<br />
干.当一个后台运行的进程需要偶尔检测一个事件时,这个功能很有用. 也可用于计时. 参<br />
见 Example 29-6.</p>

<p>1 sleep 3 # Pauses 3 seconds.</p>

<p>注意: sleep 命令默认为秒, 但是你也可以指定天数, 小时数或分钟数.<br />
1 sleep 3 h # Pauses 3 hours!</p>

<p>注意: 如果你想每隔一段时间来运行一个命令的话, 那么 watch 命令将比 sleep 命令好<br />
得多.</p>

<p>usleep<br />
Microsleep 睡眠微秒( &ldquo;u&rdquo; 会被希腊人读成 &ldquo;mu&rdquo;, 或者是 micro- 前缀). 与上边的 sl<br />
eep 命令作用相同, 但这个命令是以百万分之一秒为单位的. 当需要精确计时, 或者需要<br />
非常频繁的监控一个正在运行的进程的时候, 这个命令非常有用.</p>

<p>1 usleep 30 # 暂停 30 microseconds.</p>

<p>这个命令是 Red Hat initscripts / rc-scripts 包的一部分.</p>

<p>注意: 事实上 usleep 命令并不能提供非常精确的计时, 所以如果你需要一个实时的任务<br />
的话, 这个命令并不适合.</p>

<p>hwclock, clock</p>

<p>hwclock 命令可以存取或调整硬件时钟. 这个命令的一些选项需要 root 权限. 在系统启<br />
动的时候, /etc/rc.d/rc.sysinit 这个启动文件,会使用 hwclock 来从硬件时钟中读取<br />
并设置系统时间.clock at bootup.</p>

<p>clock 命令与 hwclock命令完全相同.</p>

<p>12.4 文本处理命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
处理文本和文本文件的命令</p>

<p>sort<br />
文件排序, 通常用在管道中当过滤器来使用. 这个命令可以依据指定的关键字或指定的字<br />
符位置, 对文件行进行排序. 使用 -m 选项, 它将会合并预排序的输入文件. 想了解这个<br />
命令的全部参数请参考这个命令的 info 页. 见 Example 10-9, Example 10-10, 和<br />
Example A-8.</p>

<p>tsort<br />
拓扑排序 ,读取以空格分隔的有序对, 并且依靠输入模式进行排序.</p>

<p>uniq<br />
这个过滤器将会删除一个已排序文件中的重复行.这个命令经常出现在 sort命令的管道后<br />
边.</p>

<p>1 cat list-1 list-2 list-3 | sort | uniq &gt; final.list<br />
2 # 将3个文件连接起来,<br />
3 # 将它们排序,<br />
4 # 删除其中重复的行,<br />
5 # 最后将结果重定向到一个文件中.</p>

<p>-c选项的意思是在输出行前面加上每行在输入文件中出现的次数.</p>

<p>bash$ cat testfile<br />
This line occurs only once.<br />
This line occurs twice.<br />
This line occurs twice.<br />
This line occurs three times.<br />
This line occurs three times.<br />
This line occurs three times.</p>

<p>bash$ uniq -c testfile<br />
1 This line occurs only once.<br />
2 This line occurs twice.<br />
3 This line occurs three times.</p>

<p>bash$ sort testfile | uniq -c | sort -nr<br />
3 This line occurs three times.<br />
2 This line occurs twice.<br />
1 This line occurs only once.</p>

<p>sort INPUTFILE | uniq -c | sort -nr 命令 先对 INPUTFILE 排序, 然后统计 每行出<br />
现的次数, 最后的(-nr 选项将会产生一个数字的反转排序). 这种命令模版一般都用来分<br />
析 log 文件或者用来分析字典列表, 或者用在那些需要检查文本词汇结构的地方.</p>

<p>Example 12-11 分析单词出现的频率<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # wf.sh: 分析文本文件中自然词汇出现的频率.<br />
3 # &ldquo;wf2.sh&rdquo; 是一个效率更高的版本.<br />
4<br />
5<br />
6 # 从命令行中检查输入的文件.<br />
7 ARGS=1<br />
8 E_BADARGS=65<br />
9 E_NOFILE=66<br />
10<br />
11 if [ $# -ne &ldquo;$ARGS&rdquo; ] # 检验传递到脚本中参数的个数.<br />
12 then<br />
13 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
14 exit $E_BADARGS<br />
15 fi<br />
16<br />
17 if [ ! -f &ldquo;$1&rdquo; ] # 检查传入的文件参数是否存在.<br />
18 then<br />
19 echo &ldquo;File \&ldquo;$1\&rdquo; does not exist.&rdquo;<br />
20 exit $E_NOFILE<br />
21 fi<br />
22<br />
23<br />
24<br />
25 ########################################################<br />
26 # main ()<br />
27 sed -e &rsquo;s/\.//g&rsquo; -e &rsquo;s/\,//g&rsquo; -e &rsquo;s/ /\<br />
28 /g&rsquo; &ldquo;$1&rdquo; | tr &lsquo;A-Z&rsquo; &lsquo;a-z&rsquo; | sort | uniq -c | sort -nr<br />
29 # =========================<br />
30 # 检查单词出现的频率<br />
31<br />
32 # 过滤掉句号和逗号,<br />
33 #+ 并且把单词间的空格转化为换行,<br />
34 #+ 然后转化为小写,<br />
35 #+ 最后统计出现的频率并按频率排序.<br />
36<br />
37 # Arun Giridhar 建议将上边的代码修改为:<br />
38 # &hellip; | sort | uniq -c | sort +1 [-f] | sort +0 -nr<br />
39 # 这句添加了第2个排序主键, 所以<br />
40 #+ 这个与上边等价的例子将按照字母顺序进行排序.<br />
41 # 就像他所解释的:<br />
42 # &ldquo;这是一个有效的根排序, 首先对频率最少的<br />
43 #+ 列进行排序<br />
44 #+ (单词或者字符串, 忽略大小写)<br />
45 #+ 然后对频率最高的列进行排序.&rdquo;<br />
46 #<br />
47 # 像 Frank Wang 所解释的那样, 上边的代码等价于:<br />
48 #+ &hellip; | sort | uniq -c | sort +0 -nr<br />
49 #+ 用下边这行也行:<br />
50 #+ &hellip; | sort | uniq -c | sort -k1nr -k<br />
51 ########################################################<br />
52<br />
53 exit 0<br />
54<br />
55 # 练习:<br />
56 # &mdash;&ndash;<br />
57 # 1) 使用 &lsquo;sed&rsquo; 命令来过滤其他的标点符号,<br />
58 #+ 比如分号.<br />
59 # 2) 修改这个脚本, 添加能够过滤多个空格或者<br />
60 # 空白的能力.<br />
################################End
Script#########################################</p>

<p>bash$ cat testfile<br />
This line occurs only once.<br />
This line occurs twice.<br />
This line occurs twice.<br />
This line occurs three times.<br />
This line occurs three times.<br />
This line occurs three times.</p>

<p>bash$ ./wf.sh testfile<br />
6 this<br />
6 occurs<br />
6 line<br />
3 times<br />
3 three<br />
2 twice<br />
1 only<br />
1 once</p>

<p>expand, unexpand<br />
expand 将会把每个tab转化为一个空格.这个命令经常用在管道中.<br />
unexpand 将会把每个空格转化为一个tab.效果与 expand 相反.</p>

<p>cut<br />
一个从文件中提取特定域的工具. 这个命令与 awk 中使用的 print $N命令很相似, 但是<br />
更受限. 在脚本中使用cut命令会比使用 awk 命令来得容易一些. 最重要的选项就是 -d<br />
(字段定界符) 和 -f (域分隔符) 选项.</p>

<p>使用 cut 来获得所有mount上的文件系统的列表:<br />
1 cut -d &lsquo; &rsquo; -f1,2 /etc/mtab</p>

<p>使用 cut 命令列出 OS 和 kernel的版本:<br />
1 uname -a | cut -d&rdquo; &ldquo; -f1,3,11,12</p>

<p>使用 cut 命令从 e-mail 中提取消息头:<br />
bash$ grep &lsquo;^Subject:&rsquo; read-messages | cut -c10-80<br />
Re: Linux suitable for mission-critical apps?<br />
MAKE MILLIONS WORKING AT HOME!!!<br />
Spam complaint<br />
Re: Spam complaint</p>

<p>使用 cut 命令来分析一个文件:<br />
1 # 列出所有在/etc/passwd中的用户.<br />
2<br />
3 FILENAME=/etc/passwd<br />
4<br />
5 for user in $(cut -d: -f1 $FILENAME)<br />
6 do<br />
7 echo $user<br />
8 done<br />
9<br />
10 # Thanks, Oleg Philon for suggesting this.</p>

<p>cut -d &lsquo; &rsquo; -f2,3 filename 等价于 awk -F&rsquo;[ ]&rsquo; &lsquo;{ print $2, $3 }&rsquo; filename<br />
注意:<br />
你甚至可以指定换行符作为字段定界符. 这个小伎俩实际上就是在命令行上插入一个<br />
换行(RETURN).(译者: linux使用lf作为换行符的).</p>

<p>bash$ cut -d&rsquo;<br />
&rsquo; -f3,7,19 testfile<br />
This is line 3 of testfile.<br />
This is line 7 of testfile.<br />
This is line 19 of testfile.</p>

<p>Thank you, Jaka Kranjc, for pointing this out.</p>

<p>参见 Example 12-43.</p>

<p>paste<br />
将多个文件,以每个文件一列的形式合并到一个文件中, 合并后的文件没列就是原来的一个<br />
文件.对于创建系统log文件来说, 使用 cut 命令与 paste 命令相结合是非常有用的.</p>

<p>join<br />
这个命令与 paste 命令属于同类命令, 但是它能够完成某些特殊的目地. 这个强力工具能<br />
够以一种特殊的形式来合并2个文件, 这种特殊的形式本质上就是一个关联数据库的简单版<br />
本.</p>

<p>join 命令只能够操作2个文件, 它可以将那些具有特定标记域(通常是一个数字标签)的行<br />
合并起来, 并且将结果输出到stdout. 被加入的文件应该事先根据标记域进行排序以便于<br />
能够正确的匹配.</p>

<p>1 File: 1.data<br />
2<br />
3 100 Shoes<br />
4 200 Laces<br />
5 300 Socks</p>

<p>1 File: 2.data<br />
2<br />
3 100 $40.00<br />
4 200 $1.00<br />
5 300 $2.00</p>

<p>bash$ join 1.data 2.data<br />
File: 1.data 2.data</p>

<p>100 Shoes $40.00<br />
200 Laces $1.00<br />
300 Socks $2.00</p>

<p>注意: 在输出中标记域将只会出现一次.</p>

<p>head<br />
将一个文件的头打印到stdout上 ( 默认为10行, 可以自己修改 ). 这个命令也有一些有趣<br />
的选项.</p>

<p>Example 12-12 那个文件是脚本?<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # script-detector.sh: 在一个目录中检查所有的脚本文件.<br />
3<br />
4 TESTCHARS=2 # 测试前两个字节.<br />
5 SHABANG=&lsquo;#!&rsquo; # 脚本都是以 &ldquo;sha-bang.&rdquo; 开头的.<br />
6<br />
7 for file in * # 遍历当前目录下的所有文件.<br />
8 do<br />
9 if [[ <code>head -c$TESTCHARS &quot;$file&quot;</code> = &ldquo;$SHABANG&rdquo; ]]<br />
10 # head -c2 #!<br />
11 # &lsquo;-c&rsquo; 选项将从文件头输出指定个数的字符,<br />
12 #+ 而不是默认的行数.<br />
13 then<br />
14 echo &ldquo;File \&ldquo;$file\&rdquo; is a script.&rdquo;<br />
15 else<br />
16 echo &ldquo;File \&ldquo;$file\&rdquo; is <em>not</em> a script.&rdquo;<br />
17 fi<br />
18 done<br />
19<br />
20 exit 0<br />
21<br />
22 # 练习:<br />
23 # &mdash;&ndash;<br />
24 # 1) 将这个脚本修改为可以指定目录<br />
25 #+ 来扫描目录下的脚本.<br />
26 #+ (而不是只搜索当前目录).<br />
27 #<br />
28 # 2) 就目前看来, 这个脚本将不能正确识别出<br />
29 #+ Perl, awk, 和其他一些脚本语言的脚本文件.<br />
30 # 修正这个问题.<br />
################################End
Script#########################################</p>

<p>Example 12-13 产生10进制随机数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # rnd.sh: 输出一个10进制随机数<br />
3<br />
4 # Script by Stephane Chazelas.<br />
5<br />
6 head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &lsquo;1s/.* //p&rsquo;<br />
7<br />
8<br />
9 # =================================================================== #<br />
10<br />
11 # 分析<br />
12 # &mdash;-<br />
13<br />
14 # head:<br />
15 # -c4 选项将取得前4个字节.<br />
16<br />
17 # od:<br />
18 # -N4 选项将限制输出为4个字节.<br />
19 # -tu4 选项将使用无符号10进制格式来输出.<br />
20<br />
21 # sed:<br />
22 # -n 选项, 使用 &ldquo;s&rdquo; 命令与 &ldquo;p&rdquo; 标志组合的方式,<br />
23 # 将会只输出匹配的行.<br />
24<br />
25<br />
26<br />
27 # 本脚本作者解释 &lsquo;sed&rsquo; 命令的行为如下.<br />
28<br />
29 # head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &lsquo;1s/.* //p&rsquo;<br />
30 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&gt; |<br />
31<br />
32 # 假设一直处理到 &ldquo;sed&rdquo;命令时的输出&ndash;&gt; |<br />
33 # 为 0000000 1198195154\n<br />
34<br />
35 # sed 命令开始读取字串: 0000000 1198195154\n.<br />
36 # 这里它发现一个换行符,<br />
37 #+ 所以 sed 准备处理第一行 (0000000 1198195154).<br />
38 # sed命令开始匹配它的  和 . 第一个匹配的并且只有这一个匹配的:<br />
39<br />
40 # range action<br />
41 # 1 s/.* //p<br />
42<br />
43 # 因为行号在range中, 所以 sed 开始执行 action:<br />
44 #+ 替换掉以空格结束的最长的字符串, 在这行中这个字符串是<br />
45 # (&ldquo;0000000 &ldquo;) ,用空字符串(//)将这个匹配到的字串替换掉, 如果成功, 那就打印出结果<br />
46 # (&ldquo;p&rdquo; 在这里是 &ldquo;s&rdquo; 命令的标志, 这与单独的 &ldquo;p&rdquo; 命令是不同的).<br />
47<br />
48 # sed 命令现在开始继续读取输入. (注意在继续之前,<br />
49 #+ continuing, 如果没使用 -n 选项的话, sed 命令将再次<br />
50 #+ 将这行打印一遍).<br />
51<br />
52 # 现在, sed 命令读取剩余的字符串, 并且找到文件的结尾.<br />
53 # sed 命令开始处理第2行(这行也被标记为 &lsquo;$&rsquo;<br />
54 # 因为这已经是最后一行).<br />
55 # 所以这行没被匹配到  中, 这样sed命令就结束了.<br />
56<br />
57 # 这个 sed 命令的简短的解释是:<br />
58 # &ldquo;在第一行中删除第一个空格左边全部的字符,<br />
59 #+ 然后打印出来.&rdquo;<br />
60<br />
61 # 一个更好的来达到这个目的的方法是:<br />
62 # sed -e &rsquo;s/.* //;q&rsquo;<br />
63<br />
64 # 这里,  和  分别是 (也可以写成<br />
65 # sed -e &rsquo;s/.* //&rsquo; -e q):<br />
66<br />
67 # range action<br />
68 # nothing (matches line) s/.* //<br />
69 # nothing (matches line) q (quit)<br />
70<br />
71 # 这里, sed 命令只会读取第一行的输入.<br />
72 # 将会执行2个命令, 并且会在退出之前打印出(已经替换过的)这行(因为 &ldquo;q&rdquo; action),<br />
73 #+ 因为没使用 &ldquo;-n&rdquo; 选项.<br />
74<br />
75 # =================================================================== #<br />
76<br />
77 # 也可以使用如下一个更简单的语句来代替:<br />
78 # head -c4 /dev/urandom| od -An -tu4<br />
79<br />
80 exit 0<br />
################################End
Script#########################################<br />
参见 Example 12-35.</p>

<p>tail<br />
将一个文件的结尾输出到 stdout 中(默认为 10 行). 通常用来跟踪一个系统 logfile<br />
的修改状况, 使用 -f 选项的话, tail 命令将会继续显示添加到文件中的行.</p>

<p>Example 12-14 使用 tail 命令来监控系统log<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 filename=sys.log<br />
4<br />
5 cat /dev/null &gt; $filename; echo &ldquo;Creating / cleaning out file.&rdquo;<br />
6 # 如果文件不存在的话就创建文件,<br />
7 #+ 然后将这个文件清空.<br />
8 # : &gt; filename 和 &gt; filename 也可以完成这个工作.<br />
9<br />
10 tail /var/log/messages &gt; $filename<br />
11 # /var/log/messages 必须具有全局可读权限才行.<br />
12<br />
13 echo &ldquo;$filename contains tail end of system log.&rdquo;<br />
14<br />
15 exit 0<br />
################################End
Script#########################################</p>

<p>注意:<br />
为了列出一个文本文件中的指定行数, 可以将 head 命令的输出通过 管道 传递到<br />
tail -1 中 . 比如 head -8 database.txt | tail -1 将会列出 database.txt 文<br />
件的第8行.</p>

<p>下边是将一个文本文件中指定范围的所有行都保存到一个变量中:<br />
1 var=$(head -$m $filename | tail -$n)<br />
2<br />
3 # filename = 文件名<br />
4 # m = 从文件开头到想取得的指定范围的行数的最后一行<br />
5 # n = 取得指定范围的行数 (从块结尾开始截断)</p>

<p>参见 Example 12-5, Example 12-35 和 Example 29-6.</p>

<p>grep<br />
使用 正则表达式 的一个多用途文本搜索工具. 这个命令本来是 ed 行编辑器中的一个命<br />
令/过滤器: g/re/p &ndash; global - regular expression - print.</p>

<p>grep pattern [file&hellip;]<br />
在文件中搜索所有 pattern 出现的位置, pattern 既可以是要搜索的字符串,也可以是一<br />
个正则表达式.</p>

<p>bash$ grep &lsquo;[rst]ystem.$&rsquo; osinfo.txt<br />
The GPL governs the distribution of the Linux operating system.</p>

<p>如果没有指定文件参数, grep 通常用在管道中对 stdout 进行过滤.</p>

<p>bash$ ps ax | grep clock<br />
765 tty1 S 0:00 xclock<br />
901 pts/1 S 0:00 grep clock</p>

<p>-i 选项在搜索时忽略大小写.</p>

<p>-w 选项用来匹配整词.</p>

<p>-l 选项仅列出符合匹配的文件, 而不列出匹配行.</p>

<p>-r (递归) 选项不仅在当前工作目录下搜索匹配, 而且搜索子目录.</p>

<p>-n 选项列出所有匹配行, 并显示行号.<br />
bash$ grep -n Linux osinfo.txt<br />
2:This is a file containing information about Linux.<br />
6:The GPL governs the distribution of the Linux operating system.</p>

<p>-v (或者&ndash;invert-match) 选项将会显示所有不匹配的行.<br />
1 grep pattern1 <em>.txt | grep -v pattern2<br />
2<br />
3 # 匹配在&rdquo;</em>.txt&rdquo;中所有包含 &ldquo;pattern1&rdquo;的行,<br />
4 # 而不显示匹配包含 &ldquo;pattern2&rdquo;的行.</p>

<p>-c (&ndash;count) 选项将只会显示匹配到的行数的总数,而不会列出具体的匹配.<br />
1 grep -c txt <em>.sgml # (在 &ldquo;</em>.sgml&rdquo; 文件中, 匹配&rdquo;txt&rdquo;的行数的总数.)<br />
2<br />
3<br />
4 # grep -cz .<br />
5 # ^ 点<br />
6 # 意思是计数 (-c) 所有以空字符分割(-z) 的匹配 &ldquo;.&ldquo;的项<br />
7 # &ldquo;.&ldquo;是正则表达式的一个符号, 表达匹配任意一个非空字符(至少要包含一个字符).<br />
8 #<br />
9 printf &lsquo;a b\nc d\n\n\n\n\n\000\n\000e\000\000\nf&rsquo; | grep -cz . # 3<br />
10 printf &lsquo;a b\nc d\n\n\n\n\n\000\n\000e\000\000\nf&rsquo; | grep -cz &lsquo;$&rsquo; # 5<br />
11 printf &lsquo;a b\nc d\n\n\n\n\n\000\n\000e\000\000\nf&rsquo; | grep -cz &lsquo;^&rsquo; # 5<br />
12 #<br />
13 printf &lsquo;a b\nc d\n\n\n\n\n\000\n\000e\000\000\nf&rsquo; | grep -c &lsquo;$&rsquo; # 9<br />
14 # 默认情况下, 是使用换行符(\n)来分隔匹配项.<br />
15<br />
16 # 注意 -z 选项是 GNU &ldquo;grep&rdquo; 特定的选项.<br />
17<br />
18<br />
19 # Thanks, S.C.</p>

<p>当有多个文件参数的时候, grep 将会指出哪个文件中包含具体的匹配.</p>

<p>bash$ grep Linux osinfo.txt misc.txt<br />
osinfo.txt:This is a file containing information about Linux.<br />
osinfo.txt:The GPL governs the distribution of the Linux operating system.<br />
misc.txt:The Linux operating system is steadily gaining in popularity.</p>

<p>注意: 如果在 grep 命令只搜索一个文件的时候, 那么可以简单的把 /dev/null 作为第2<br />
个文件参数传给 grep .</p>

<p>bash$ grep Linux osinfo.txt /dev/null<br />
osinfo.txt:This is a file containing information about Linux.<br />
osinfo.txt:The GPL governs the distribution of the Linux operating system.</p>

<p>如果存在一个成功的匹配, 那么 grep 命令将会返回 0 作为 退出状态 ,这样就可以将<br />
grep 命令的结果放在脚本的条件测试中来使用, 尤其和 -q (禁止输出)选项组合时特别有<br />
用.<br />
1 SUCCESS=0 # 如果 grep 匹配成功<br />
2 word=Linux<br />
3 filename=data.file<br />
4<br />
5 grep -q &ldquo;$word&rdquo; &ldquo;$filename&rdquo; # &ldquo;-q&rdquo; 选项将使得什么都不输出到 stdout 上.<br />
6<br />
7 if [ $? -eq $SUCCESS ]<br />
8 # if grep -q &ldquo;$word&rdquo; &ldquo;$filename&rdquo; 这句话可以代替行 5 - 7.<br />
9 then<br />
10 echo &ldquo;$word found in $filename&rdquo;<br />
11 else<br />
12 echo &ldquo;$word not found in $filename&rdquo;<br />
13 fi</p>

<p>Example 29-6 展示了如何使用 grep 命令来在一个系统 logfile 中进行一个单词的模式<br />
匹配.</p>

<p>Example 12-15 在一个脚本中模仿 &ldquo;grep&rdquo; 的行为<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # grp.sh: 一个非常粗糙的 &lsquo;grep&rsquo; 的实现.<br />
3<br />
4 E_BADARGS=65<br />
5<br />
6 if [ -z &ldquo;$1&rdquo; ] # 检查传递给脚本的参数.<br />
7 then<br />
8 echo &ldquo;Usage: <code>basename $0</code> pattern&rdquo;<br />
9 exit $E_BADARGS<br />
10 fi<br />
11<br />
12 echo<br />
13<br />
14 for file in * # 遍历 $PWD 下的所有文件.<br />
15 do<br />
16 output=$(sed -n /&ldquo;$1&rdquo;/p $file) # 命令替换.<br />
17<br />
18 if [ ! -z &ldquo;$output&rdquo; ] # 如果&rdquo;$output&rdquo; 不加双引号将会发生什么?<br />
19 then<br />
20 echo -n &ldquo;$file: &ldquo;<br />
21 echo $output<br />
22 fi # sed -ne &ldquo;/$1/s|^|${file}: |p&rdquo; 这句与上边这段等价.<br />
23<br />
24 echo<br />
25 done<br />
26<br />
27 echo<br />
28<br />
29 exit 0<br />
30<br />
31 # 练习:<br />
32 # &mdash;&ndash;<br />
33 # 1) 在任何给定的文件中,如果有超过一个匹配的话, 在输出中添加新行.<br />
34 # 2) 添加一些特征.<br />
################################End
Script#########################################<br />
如何使用 grep 命令来搜索两个(或两个以上)独立的模式? 如果你想显示在一个或多个文<br />
件中既匹配&rdquo;pattern1&rdquo; 又匹配 &ldquo;pattern2&rdquo;的所有匹配行又该如何做呢?(译者: 这是取交<br />
集的情况, 如果取并集该怎么办呢?)</p>

<p>一个方法是通过 管道 来将 grep pattern1 的结果传递到 grep pattern2 中 .</p>

<p>例如, 给定如下文件:</p>

<p>1 # Filename: tstfile<br />
2<br />
3 This is a sample file.<br />
4 This is an ordinary text file.<br />
5 This file does not contain any unusual text.<br />
6 This file is not unusual.<br />
7 Here is some text.</p>

<p>现在, 让我们在这个文件中搜索既包含 &ldquo;file&rdquo; 又包含 &ldquo;text&rdquo; 的所有行<br />
bash$ grep file tstfile</p>

<h1 id="filename-tstfile">Filename: tstfile</h1>

<p>This is a sample file.<br />
This is an ordinary text file.<br />
This file does not contain any unusual text.<br />
This file is not unusual.</p>

<p>bash$ grep file tstfile | grep text<br />
This is an ordinary text file.<br />
This file does not contain any unusual text.</p>

<p>--</p>

<p>egrep - 扩展的 grep - 这个命令与 grep -E 等价. 这个命令用起来有些不同, 由于正<br />
则表达式扩展, 将会使得搜索更具灵活性.</p>

<p>fgrep - 快速的 grep - 这个命令与 grep -F 等价. 这是一种按照字符串字面意思进行<br />
的搜索(即不允许使用正则表达式), 这样有时候会使搜索变得容易一些.</p>

<p>注意: 在某些linux发行版中, egrep 和 fgrep 都是 grep 命令的符号连接或者是别名,<br />
只不过调用的时候分别使用 -E 和 -F 选项罢了.</p>

<p>Example 12-16 在1913年的韦氏词典中查找定义<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # dict-lookup.sh<br />
3<br />
4 # 这个脚本在1913年的韦氏词典中查找定义.<br />
5 # 这本公共词典可以通过不同的<br />
6 #+ 站点来下载,包括<br />
7 #+ Project Gutenberg (<a href="http://www.gutenberg.org/etext/247">http://www.gutenberg.org/etext/247</a>).<br />
8 #<br />
9 # 在通过本脚本使用之前,<br />
10 #+ 先要将这本字典由 DOS 格式转换为 UNIX格式(只以 LF 作为行结束符).<br />
11 # 将这个文件存储为纯文本形式, 并且保证是未压缩的 ASCII 格式.<br />
12 # 将DEFAULT_DICTFILE 变量以 path/filename 形式设置好.<br />
13<br />
14<br />
15 E_BADARGS=65<br />
16 MAXCONTEXTLINES=50 # 显示的最大行数.<br />
17 DEFAULT_DICTFILE=&ldquo;/usr/share/dict/webster1913-dict.txt&rdquo;<br />
18 # 默认的路径和文件名.<br />
19 # 在必要的时候可以进行修改.<br />
20 # 注意:<br />
21 # &mdash;&ndash;<br />
22 # 这个特定的1913年版的韦氏词典<br />
23 #+ 在每个入口都是以大写字母开头的<br />
24 #+ (剩余的字符都是小写).<br />
25 # 只有每部分的第一行是以这种形式开始的,<br />
26 #+ 这也就是为什么搜索算法是下边的这个样子.<br />
27<br />
28<br />
29<br />
30 if [[ -z $(echo &ldquo;$1&rdquo; | sed -n &lsquo;/<sup class="footnote-ref" id="fnref:A-Z"><a href="#fn:A-Z">1</a></sup>/p&rsquo;) ]]<br />
31 # 必须指定一个要查找的单词,<br />
32 #+ 并且这个单词必须以大写字母开头.<br />
33 then<br />
34 echo &ldquo;Usage: <code>basename $0</code> Word-to-define [dictionary-file]&rdquo;<br />
35 echo<br />
36 echo &ldquo;Note: Word to look up must start with capital letter,&rdquo;<br />
37 echo &ldquo;with the rest of the word in lowercase.&rdquo;<br />
38 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
39 echo &ldquo;Examples: Abandon, Dictionary, Marking, etc.&rdquo;<br />
40 exit $E_BADARGS<br />
41 fi<br />
42<br />
43<br />
44 if [ -z &ldquo;$2&rdquo; ] # 也可以指定不同的词典<br />
45 #+ 作为这个脚本的第2个参数传递进来.<br />
46 then<br />
47 dictfile=$DEFAULT_DICTFILE<br />
48 else<br />
49 dictfile=&ldquo;$2&rdquo;<br />
50 fi<br />
51<br />
52 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
53 Definition=$(fgrep -A $MAXCONTEXTLINES &ldquo;$1 \\&rdquo; &ldquo;$dictfile&rdquo;)<br />
54 # 以 &ldquo;Word \&hellip;&rdquo; 这种形式定义<br />
55 #<br />
56 # 当然, 即使搜索一个特别大的文本文件的时候<br />
57 #+ &ldquo;fgrep&rdquo; 也是足够快的.<br />
58<br />
59<br />
60 # 现在, 剪掉定义块.<br />
61<br />
62 echo &ldquo;$Definition&rdquo; |<br />
63 sed -n &lsquo;1,/<sup class="footnote-ref" id="fnref:A-Z"><a href="#fn:A-Z">2</a></sup>/p&rsquo; |<br />
64 # 从输出的第一行<br />
65 #+ 打印到下一部分的第一行.<br />
66 sed &lsquo;$d&rsquo; | sed &lsquo;$d&rsquo;<br />
67 # 删除输出的最后两行Delete last two lines of output<br />
68 #+ (空行和下一部分的第一行).<br />
69 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
70<br />
71 exit 0<br />
72<br />
73 # 练习:<br />
74 # &mdash;&ndash;<br />
75 # 1) 修改这个脚本, 让它具备能够处理任何字符形式的输入<br />
76 # + (大写, 小写, 或大小写混合), 然后将其转换为<br />
77 # + 能够处理的统一形式.<br />
78 #<br />
79 # 2) 将这个脚本转化为一个 GUI 应用,<br />
80 # + 使用一些比如像 &ldquo;gdialog&rdquo;的东西 &hellip;<br />
81 # 这样的话, 脚本将不再从命令行中<br />
82 # + 取得这些参数.<br />
83 #<br />
84 # 3) 修改这个脚本让它具备能够分析另外一个<br />
85 # + 公共词典的能力,比如 U.S. Census Bureau Gazetteer.<br />
################################End
Script#########################################<br />
agrep (近似 grep) 扩展了 grep 近似匹配的能力. 搜索的字符串可能会与最终匹配结果<br />
所找到字符串有些不同.这个工具并不是核心 Linux 发行版的一部分.</p>

<p>注意: 为了搜索压缩文件, 应使用 zgrep, zegrep, 或 zfgrep. 这些命令也可以对未压缩<br />
的文件进行搜索, 只不过会比一般的 grep, egrep, 和 fgrep 慢上一些. 当然, 在你<br />
要搜索的文件中如果混合了压缩和未压缩的文件的话, 那么使用这些命令是非常方便<br />
的.</p>

<p>如果要搜索 bzipped 类型的文件, 使用 bzgrep.</p>

<p>look<br />
命令 look 与命令 grep 很相似, 但是这个命令只能做字典查询, 也就是它所搜索的文件<br />
必须已经排过序的单词列表. 默认情况下, 如果没有指定搜索那个文件, 那就默认搜索<br />
/usr/dict/words文件(译者: 感觉好像应该是/usr/share/dict/words), 当然也可以指定<br />
其他目录下的文件进行搜索.</p>

<p>Example 12-17 检查列表中单词的正确性<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # lookup: 对指定数据文件中的每个单词都做一遍字典查询..<br />
3<br />
4 file=words.data # 指定的要搜索的数据文件.<br />
5<br />
6 echo<br />
7<br />
8 while [ &ldquo;$word&rdquo; != end ] # 数据文件中最后一个单词.<br />
9 do<br />
10 read word # 从数据文件中读, 因为在循环的后边重定向了.<br />
11 look $word &gt; /dev/null # 不想将字典文件中的行显示出来.<br />
12 lookup=$? # &lsquo;look&rsquo; 命令的退出状态.<br />
13<br />
14 if [ &ldquo;$lookup&rdquo; -eq 0 ]<br />
15 then<br />
16 echo &ldquo;\&ldquo;$word\&rdquo; is valid.&rdquo;<br />
17 else<br />
18 echo &ldquo;\&ldquo;$word\&rdquo; is invalid.&rdquo;<br />
19 fi<br />
20<br />
21 done 22<br />
23 echo<br />
24<br />
25 exit 0<br />
26<br />
27 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
28 # 下边的代码行将不会执行, 因为上边已经有 &ldquo;exit&rdquo;命令了.<br />
29<br />
30<br />
31 # Stephane Chazelas 建议使用下边更简洁的方法:<br />
32<br />
33 while read word &amp;&amp; [[ $word != end ]]<br />
34 do if look &ldquo;$word&rdquo; &gt; /dev/null<br />
35 then echo &ldquo;\&ldquo;$word\&rdquo; is valid.&rdquo;<br />
36 else echo &ldquo;\&ldquo;$word\&rdquo; is invalid.&rdquo;<br />
37 fi<br />
38 done 39<br />
40 exit 0<br />
################################End
Script#########################################</p>

<p>sed, awk<br />
这个两个命令都是独立的脚本语言, 尤其适合分析文本文件和命令输出. 既可以单独使用,<br />
也可以结合管道和在shell脚本中使用.</p>

<p>sed<br />
非交互式的 &ldquo;流编辑器&rdquo;, 在批量模式下, 允许使用许多 ex 命令.你会发现它在shell脚本<br />
中非常有用.</p>

<p>awk<br />
可编程的文件提取器和文件格式化工具, 在结构化的文本文件中,处理或提取特定域(特定<br />
列)具有非常好的表现.它的语法与 C 语言很类似.</p>

<p>wc<br />
wc 可以统计文件或 I/O 流中的单词数量.<br />
bash $ wc /usr/share/doc/sed-4.1.2/README<br />
13 70 447 README<br />
[13 lines 70 words 447 characters]</p>

<p>wc -w 统计单词数量.</p>

<p>wc -l 统计行数量.</p>

<p>wc -c 统计字节数量.</p>

<p>wc -m 统计字符数量.</p>

<p>wc -L 给出文件中最长行的长度.</p>

<p>使用 wc 命令来统计当前工作目录下有多少个 .txt 文件.<br />
1 $ ls *.txt | wc -l<br />
2 # 因为列出的文件名都是以换行符区分的,所以使用 -l 来统计.<br />
3<br />
4 # 另一种达到这个目的的方法:<br />
5 # find . -maxdepth 1 -name \*.txt -print0 | grep -cz .<br />
6 # (shopt -s nullglob; set &ndash; *.txt; echo $#)<br />
7<br />
8 # Thanks, S.C.</p>

<p>使用 wc 命令来统计所有以 d - h 开头的文件的大小.<br />
bash$ wc [d-h]* | grep total | awk &lsquo;{print $3}&rsquo;<br />
71832</p>

<p>使用 wc 命令来查看指定文件中包含 &ldquo;Linux&rdquo; 的行一共有多少.<br />
bash$ grep Linux abs-book.sgml | wc -l<br />
50</p>

<p>参见 Example 12-35 和 Example 16-8.</p>

<p>某些命令的某些选项其实已经包含了 wc 命令的部分功能.<br />
1 &hellip; | grep foo | wc -l<br />
2 # 这个命令使用得非常频繁, 但事实上它有更简便的写法.<br />
3<br />
4 &hellip; | grep -c foo<br />
5 # 只要使用 grep 命令的 &ldquo;-c&rdquo; (或 &ldquo;&ndash;count&rdquo;)选项就能达到同样的目的.<br />
6<br />
7 # Thanks, S.C.</p>

<p>tr<br />
字符转换过滤器.</p>

<p>注意: 必须使用引用或中括号, 这样做才是合理的. 引用可以阻止 shell 重新解释出现在<br />
tr 命令序列中的特殊字符.中括号应该被引用起来防止被shell扩展.</p>

<p>无论 tr &ldquo;A-Z&rdquo; &ldquo;*&rdquo;  写字符修改为星号(写到 stdout).但是在某些系统上可能就不能正常工作了, 而 tr A-Z &lsquo;<br />
[**]&rsquo; 在任何系统上都可以正常工作.</p>

<p>-d 选项删除指定范围的字符.<br />
1 echo &ldquo;abcdef&rdquo; # abcdef<br />
2 echo &ldquo;abcdef&rdquo; | tr -d b-d # aef<br />
3<br />
4<br />
5 tr -d 0-9  6 # 删除 &ldquo;filename&rdquo; 中所有的数字.</p>

<p>--squeeze-repeats (或 -s) 选项用来在重复字符序列中除去除第一个字符以外的所有字<br />
符. 这个选项在删除多余的whitespace 的时候非常有用.<br />
bash$ echo &ldquo;XXXXX&rdquo; | tr &ndash;squeeze-repeats &lsquo;X&rsquo;<br />
X</p>

<p>-c &ldquo;complement&rdquo; 选项将会 反转 匹配的字符集. 通过这个选项, tr 将只会对那些 不<br />
匹配的字符起作用.<br />
bash$ echo &ldquo;acfdeb123&rdquo; | tr -c b-d +<br />
+c+d+b++++</p>

<p>注意 tr 命令支持 POSIX 字符类. [1]<br />
bash$ echo &ldquo;abcd2ef1&rdquo; | tr &lsquo;[:alpha:]&rsquo; -<br />
-&mdash;2&ndash;1</p>

<p>Example 12-18 转换大写: 把一个文件的内容全部转换为大写.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 把一个文件的内容全部转换为大写.<br />
3<br />
4 E_BADARGS=65<br />
5<br />
6 if [ -z &ldquo;$1&rdquo; ] # 检查命令行参数.<br />
7 then<br />
8 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
9 exit $E_BADARGS<br />
10 fi<br />
11<br />
12 tr a-z A-Z 13<br />
14 # 与上边的作用相同, 但是使用了 POSIX 字符集标记方法:<br />
15 # tr &lsquo;[:lower:]&rsquo; &lsquo;[:upper:]&rsquo; 16 # Thanks, S.C.<br />
17<br />
18 exit 0<br />
19<br />
20 # 练习:<br />
21 # 重写这个脚本, 通过选项可以控制脚本或者<br />
22 #+ 转换为大写或者转换为小写.<br />
################################End
Script#########################################</p>

<p>Example 12-19 转换小写: 将当前目录下的所有文全部转换为小写.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 #<br />
3 # 将当前目录下的所有文全部转换为小写.<br />
4 #<br />
5 # 灵感来自于 John Dubois 的脚本,<br />
6 #+ 转换为 Bash 脚本,<br />
7 #+ 然后被本书作者精简了一下.<br />
8<br />
9<br />
10 for filename in * # 遍历当前目录下的所有文件.<br />
11 do<br />
12 fname=<code>basename $filename</code><br />
13 n=<code>echo $fname | tr A-Z a-z</code> # 将名字修改为小写.<br />
14 if [ &ldquo;$fname&rdquo; != &ldquo;$n&rdquo; ] # 只对那些文件名不是小写的文件进行重命名.<br />
15 then<br />
16 mv $fname $n<br />
17 fi<br />
18 done<br />
19<br />
20 exit $?<br />
21<br />
22<br />
23 # 下边的代码将不会被执行, 因为上边的 &ldquo;exit&rdquo;.<br />
24 #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-#<br />
25 # 删除上边的内容,来运行下边的内容.<br />
26<br />
27 # 对于那些文件名中包含空白和新行的文件, 上边的脚本就不能工作了.<br />
28 # Stephane Chazelas 因此建议使用下边的方法:<br />
29<br />
30<br />
31 for filename in * # 不必非得使用 basename 命令,<br />
32 # 因为 &ldquo;*&rdquo; 不会返回任何包含 &ldquo;/&rdquo; 的文件.<br />
33 do n=<code>echo &quot;$filename/&quot; | tr '[:upper:]' '[:lower:]'</code><br />
34 # POSIX 字符集标记法.<br />
35 # 添加的斜线是为了在文件名结尾换行不会被<br />
36 # 命令替换删掉.<br />
37 # 变量替换:<br />
38 n=${n%/} # 从文件名中将上边添加在结尾的斜线删除掉.<br />
39 [[ $filename == $n ]] || mv &ldquo;$filename&rdquo; &ldquo;$n&rdquo;<br />
40 # 检查文件名是否已经是小写.<br />
41 done<br />
42<br />
43 exit $?<br />
################################End
Script#########################################</p>

<p>Example 12-20 Du: DOS 到 UNIX 文本文件的转换.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # Du.sh: DOS 到 UNIX 文本文件的转换.<br />
3<br />
4 E_WRONGARGS=65<br />
5<br />
6 if [ -z &ldquo;$1&rdquo; ]<br />
7 then<br />
8 echo &ldquo;Usage: <code>basename $0</code> filename-to-convert&rdquo;<br />
9 exit $E_WRONGARGS<br />
10 fi<br />
11<br />
12 NEWFILENAME=$1.unx<br />
13<br />
14 CR=&rsquo;\015&rsquo; # 回车Carriage return.<br />
15 # 015 是 8 进制的 ASCII 码的回车.<br />
16 # DOS 中文本文件的行结束符是 CR-LF.<br />
17 # UNIX 中文本文件的行结束符只是 LF.<br />
18<br />
19 tr -d $CR &lt; $1 &gt; $NEWFILENAME<br />
20 # 删除回车并且写到新文件中.<br />
21<br />
22 echo &ldquo;Original DOS text file is \&ldquo;$1\&ldquo;.&rdquo;<br />
23 echo &ldquo;Converted UNIX text file is \&ldquo;$NEWFILENAME\&ldquo;.&rdquo;<br />
24<br />
25 exit 0<br />
26<br />
27 # 练习:<br />
28 # &mdash;&ndash;<br />
29 # 修改上边的脚本完成从UNIX 到 DOS 的转换.<br />
################################End
Script#########################################</p>

<p>Example 12-21 rot13: rot13, 弱智加密.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # rot13.sh: 典型的 rot13 算法,<br />
3 # 使用这种方法加密可能可以愚弄一下3岁小孩.<br />
4<br />
5 # 用法: ./rot13.sh filename<br />
6 # 或 ./rot13.sh  7 # 或 ./rot13.sh and supply keyboard input (stdin)<br />
8<br />
9 cat &ldquo;$@&rdquo; | tr &lsquo;a-zA-Z&rsquo; &lsquo;n-za-mN-ZA-M&rsquo; # &ldquo;a&rdquo; 变为 &ldquo;n&rdquo;, &ldquo;b&rdquo; 变为 &ldquo;o&rdquo;, 等等.<br />
10 # &lsquo;cat &ldquo;$@&rdquo;&rsquo; 结构<br />
11 #+ 允许从stdin或者从文件中获得输入.<br />
12<br />
13 exit 0<br />
################################End
Script#########################################</p>

<p>Example 12-22 Generating &ldquo;Crypto-Quote&rdquo; Puzzles<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # crypto-quote.sh: 加密<br />
3<br />
4 # 使用单码替换(单一字母替换法)来进行加密.<br />
5 # The result is similar to the &ldquo;Crypto Quote&rdquo; puzzles<br />
6 #+ seen in the Op Ed pages of the Sunday paper. (不太了解这句的内容, 应该是有特定的含义)<br />
7<br />
8<br />
9 key=ETAOINSHRDLUBCFGJMQPVWZYXK<br />
10 # &ldquo;key&rdquo; 不过是一个乱序的字母表.<br />
11 # 修改 &ldquo;key&rdquo; 就会修改加密的结果.<br />
12<br />
13 # The &lsquo;cat &ldquo;$@&rdquo;&rsquo; construction gets input either from stdin or from files.<br />
14 # 如果使用stdin, 那么要想结束输入就使用 Control-D.<br />
15 # 否则就要在命令行上指定文件名.<br />
16<br />
17 cat &ldquo;$@&rdquo; | tr &ldquo;a-z&rdquo; &ldquo;A-Z&rdquo; | tr &ldquo;A-Z&rdquo; &ldquo;$key&rdquo;<br />
18 # | 转化为大写 | 加密<br />
19 # 小写, 大写, 或混合大小写, 都可以正常工作.<br />
20 # 但是传递进来的非字母字符将不会起任何变化.<br />
21<br />
22<br />
23 # 用下边的语句试试这个脚本:<br />
24 # &ldquo;Nothing so needs reforming as other people&rsquo;s habits.&rdquo;<br />
25 # &ndash;Mark Twain<br />
26 #<br />
27 # 输出为:<br />
28 # &ldquo;CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI&rsquo;Q HETRPQ.&rdquo;<br />
29 # &ndash;BEML PZERC<br />
30<br />
31 # 解密:<br />
32 # cat &ldquo;$@&rdquo; | tr &ldquo;$key&rdquo; &ldquo;A-Z&rdquo;<br />
33<br />
34<br />
35 # 这个简单的密码可以轻易的被一个12岁的小孩<br />
36 #+ 用铅笔和纸破解.<br />
37<br />
38 exit 0<br />
39<br />
40 # 练习:<br />
41 # &mdash;&ndash;<br />
42 # 修改这个脚本, 让它可以用命令行参数<br />
43 #+ 来决定加密或解密.<br />
################################End
Script#########################################</p>

<p>注意: tr 的不同版本<br />
tr 工具在历史上有2个重要版本. BSD 版本不需要使用中括号 (tr a-z A-Z), 但是<br />
SysV 版本则需要中括号 (tr &lsquo;[a-z]&rsquo; &lsquo;[A-Z]&lsquo;). GNU 版本的 tr 命令与 BSD 版本比<br />
较相像, 所以使用中括号来引用字符范围是强制性的(译者: 感觉这句说反了, 读者可<br />
自行参照原文).</p>

<p>fold<br />
将输入按照指定宽度进行折行. 这里有一个非常有用的选项 -s ,这个选项可以使用空格进<br />
行断行.(译者: 事实上只有外文才需要使用空格断行, 中文是不需要的) (参见 Example<br />
12-23 和 Example A-1).</p>

<p>fmt<br />
一个简单的文件格式器, 通常用在管道中, 将一个比较长的文本行输出进行折行.</p>

<p>Example 12-23 格式化文件列表.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 WIDTH=40 # 设为 40 列宽.<br />
4<br />
5 b=<code>ls /usr/local/bin</code> # 取得文件列表&hellip;<br />
6<br />
7 echo $b | fmt -w $WIDTH<br />
8<br />
9 # 也可以使用如下方法,作用相同<br />
10 # echo $b | fold - -s -w $WIDTH<br />
11<br />
12 exit 0<br />
################################End
Script#########################################<br />
参见 Example 12-5.</p>

<p>注意: 如果想找到一个更强力的 fmt 工具可以选择 Kamil Toman 的 par 工具, 这个工<br />
具可以从后边的这个网址取得<a href="http://www.cs.berkeley.edu/~amc/Par/">http://www.cs.berkeley.edu/~amc/Par/</a>.</p>

<p>col<br />
这个命令用来滤除标准输入的反向换行符号. 这个工具还可以将空白用等价的 tab 来替<br />
换. col 工具最主要的应用还是从特定的文本处理工具中过滤输出, 比如 groff 和 tbl.<br />
(译者: 主要用来将man页转化为文本)</p>

<p>column<br />
列格式化工具. 这个过滤工具将会将列类型的文本转化为&rdquo;易于打印&rdquo;的表格式进行输出,<br />
通过在合适的位置插入tab.</p>

<p>Example 12-24 使用 column 来格式化目录列表<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 这是&rdquo;column&rdquo; man页中的一个例子, 作者对这个例子做了很小的修改.<br />
3<br />
4<br />
5 (printf &ldquo;PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n&rdquo; \<br />
6 ; ls -l | sed 1d) | column -t<br />
7<br />
8 # 管道中的 &ldquo;sed 1d&rdquo; 删除输出的第一行,<br />
9 #+ 第一行将是 &ldquo;total N&rdquo;,<br />
10 #+ 其中 &ldquo;N&rdquo; 是 &ldquo;ls -l&rdquo; 找到的文件总数.<br />
11<br />
12 # &ldquo;column&rdquo; 中的 -t 选项用来转化为易于打印的表形式.<br />
13<br />
14 exit 0<br />
################################End
Script#########################################</p>

<p>colrm<br />
列删除过滤器. 这个工具将会从文件中删除指定的列(列中的字符串)并且写到文件中, 如<br />
果指定的列不存在,那么就回到 stdout. colrm 2 4  每行删除第2到第4列之间的所有字符.</p>

<p>注意: 如果这个文件包含tab和不可打印字符, 那将会引起不可预期的行为. 在这种情况下<br />
, 应该通过管道的手段使用 expand 和 unexpand 命令来预处理 colrm.</p>

<p>nl<br />
计算行号过滤器. nl filename 将会在 stdout 中列出文件的所有内容, 但是会在每个非<br />
空行的前面加上连续的行号. 如果没有 filename 参数, 那么就操作 stdin.</p>

<p>nl 命令的输出与 cat -n 非常相似, 然而, 默认情况下 nl 不会列出空行.</p>

<p>Example 12-25 nl: 一个自己计算行号的脚本.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # line-number.sh<br />
3<br />
4 # 这个脚本将会 echo 自身两次, 并显示行号.<br />
5<br />
6 # &lsquo;nl&rsquo; 命令显示的时候你将会看到, 本行是第4行, 因为它不计空行.<br />
7 # &lsquo;cat -n&rsquo; 命令显示的时候你将会看到, 本行是第6行.<br />
8<br />
9 nl <code>basename $0</code><br />
10<br />
11 echo; echo # 下边, 让我们试试 &lsquo;cat -n&rsquo;<br />
12<br />
13 cat -n <code>basename $0</code><br />
14 # 区别就是 &lsquo;cat -n&rsquo; 对空行也进行计数.<br />
15 # 注意 &lsquo;nl -ba&rsquo; 也会这么做.<br />
16<br />
17 exit 0<br />
18 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
################################End
Script#########################################</p>

<p>pr<br />
格式化打印过滤器. 这个命令会将文件(或stdout)分页, 将它们分成合适的小块以便于硬<br />
拷贝打印或者在屏幕上浏览.使用这个命令的不同的参数可以完成好多任务, 比如对行和列<br />
的操作,加入行, 设置页边, 计算行号, 添加页眉, 合并文件等等. pr 命令集合了许多命<br />
令的功能, 比如 nl, paste, fold, column, 和 expand.</p>

<p>pr -o 5 &ndash;width=65 fileZZZ | more 这个命令对fileZZZ进行了比较好的分页,并且打印<br />
到屏幕上.文件的缩进被设置为5, 总宽度设置为65.</p>

<p>一个特定的使用选项 -d, 强制隔行打印 (与 sed -G 效果相同).</p>

<p>gettext<br />
GNU gettext 包是专门用来将程序的输出翻译或者本地化为不同国家语言的工具集.在最开<br />
始的时候仅仅支持C 语言, 现在已经支持了相当数量的其它程序语言和脚本语言.</p>

<p>要想查看 gettext 程序 如何在shell脚本中工作. 参见 info 页.</p>

<p>msgfmt<br />
一个产生2进制消息目录的程序. 这个命令主要用来 本地化.</p>

<p>iconv<br />
一个可以将文件转化为不同编码格式(字符集)的工具. 这个命令主要用来 本地化.<br />
1 # 将字符符串由 UTF-8 格式转换为 UTF-16 并且打印到 BookList 中<br />
2 function write_utf8_string {<br />
3 STRING=$1<br />
4 BOOKLIST=$2<br />
5 echo -n &ldquo;$STRING&rdquo; | iconv -f UTF8 -t UTF16 | cut -b 3- | tr -d \\n &gt;&gt;
&ldquo;$BOOKLIST&rdquo;<br />
6 }<br />
7<br />
8 # 来自于 Peter Knowles&rsquo; &ldquo;booklistgen.sh&rdquo; 脚本<br />
9 #+ 目的是把文件转换为 Sony Librie 格式.<br />
10 # (<a href="http://booklistgensh.peterknowles.com">http://booklistgensh.peterknowles.com</a>)</p>

<p>recode<br />
可以认为这个命令时上边 iconv 命令的一个空想家版本. 这个非常灵活的并可以把整个文<br />
件都转换为不同编码格式的工具并不是Linux 标准安装的一部分.</p>

<p>TeX, gs<br />
TeX 和 Postscript 都是文本标记语言, 用来对打印和格式化的视频显示进行预拷贝.</p>

<p>TeX 是 Donald Knuth 精心制作的排版系统. 通常情况下, 通过编写脚本的手段来把所有<br />
的选项和参数封装起来一起传到标记语言中是一件很方便的事情.</p>

<p>Ghostscript (gs) 是一个 遵循 GPL 的Postscript 解释器.</p>

<p>enscript<br />
将纯文本文件转换为 PostScript 的工具<br />
比如, enscript filename.txt -p filename.ps 产生一个 PostScript 输出文件<br />
filename.ps.</p>

<p>groff, tbl, eqn<br />
另一种文本标记和显示格式化语言是 groff. 这是一个对传统 UNIX roff/troff 显示和排<br />
版包的 GNU 增强版本.Man页 使用的就是 groff.</p>

<p>tbl 表处理工具可以认为是 groff 的一部分, 它的功能就是将表标记转化到 groff<br />
命令中.</p>

<p>eqn 等式处理工具也是 groff 的一部分, 它的功能是将等式标记转化到 groff 命令中.</p>

<p>Example 12-26 manview: 查看格式化的man页<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # manview.sh: 将man页源文件格式化以方便查看.<br />
3<br />
4 # 当你想阅读man页的时候, 这个脚本就有用了.<br />
5 # 它允许你在运行的时候查看<br />
6 #+ 中间结果.<br />
7<br />
8 E_WRONGARGS=65<br />
9<br />
10 if [ -z &ldquo;$1&rdquo; ]<br />
11 then<br />
12 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
13 exit $E_WRONGARGS<br />
14 fi<br />
15<br />
16 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
17 groff -Tascii -man $1 | less<br />
18 # 来自于 groff man页.<br />
19 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
20<br />
21 # 如果man业中包括表或者等式,<br />
22 #+ 那么上边的代码就够呛了.<br />
23 # 下边的这行代码可以解决上边的这个问题.<br />
24 #<br />
25 # gtbl &lt; &ldquo;$1&rdquo; | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man<br />
26 #<br />
27 # Thanks, S.C.<br />
28<br />
29 exit 0<br />
################################End
Script#########################################</p>

<p>lex, yacc<br />
lex 是用于模式匹配的词汇分析产生程序. 在Linux系统上这个命令已经被 flex 取代了.<br />
yacc 工具基于一系列的语法规范生成语法分析程序. 在Linux系统上这个命令已经被<br />
bison 取代了.</p>

<p>注意事项:<br />
[1] 对于 GNU 版本的 tr 命令来说这是唯一一处比那些商业 UNIX 系统上的一般版本合适<br />
的地方.</p>

<p>12.5 文件与归档命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
归档命令</p>

<p>tar<br />
标准的 UNIX 归档工具. [1] 起初这只是一个 磁带 归档 程序, 而现在这个工具已经被开<br />
发为通用打包程序, 它能够处理所有设备的所有类型的归档文件, 包括磁带设备, 正常文<br />
件, 甚至是 stdout (参见Example 3-4). GNU 的tar工具现在可以接受不同种类的压缩过<br />
滤器, 比如tar czvf archive_name.tar.gz *, 并且可以递归的处理归档文件, 还可以用<br />
gzip 压缩目录下的所有文件, 除了当前目录下($PWD)的 点文件 . [2]</p>

<p>一些有用的 tar 命令选项:</p>

<p>1. -c 创建 (一个新的归档文件)<br />
2. -x 解压文件 (从存在的归档文件中)<br />
3. &ndash;delete 删除文件 (从存在的归档文件中)<br />
注意: 这个选项不能用于磁带类型设备.<br />
4. -r 将文件添加到现存的归档文件的尾部<br />
5. -A 将 tar 文件添加到现存的归档文件的尾部<br />
6. -t 列出现存的归档文件中包含的内容<br />
7. -u 更新归档文件<br />
8. -d 使用指定的文件系统 比较归档文件<br />
9. -z 用 gzip 压缩归档文件<br />
(压缩还是解压, 依赖于是否组合了 -c 或 -x)选项<br />
10. -j 用 bzip2 压缩归档文件</p>

<p>注意: 如果想从损坏的用 gzip 压缩过的 tar 文件中取得数据, 那将是很困难的. 所有当<br />
我们归档重要的文件的时候, 一定要保留多个备份.</p>

<p>shar<br />
Shell 归档工具. 存在于 shell 归档文件中的所有文件都是未经压缩的, 并且本质上是一<br />
个shell 脚本,以 #!/bin/sh 开头, 并且包含所有必要的解档命令. Shar 归档文件 至今<br />
还在 Internet 新闻组中使用, 否则的话 shar早就被 tar/gzip 所取代了. unshar 命令<br />
用来解档 shar 归档文件.</p>

<p>ar<br />
创建和操作归档文件的工具, 主要在对2进制目标文件打包成库时才会用到.</p>

<p>rpm<br />
Red Hat 包管理器, 或者说 rpm 工具提供了一种对源文件或2进制文件进行打包的方法.<br />
除此之外, 它还包括安装命令, 并且还检查包的完整性.</p>

<p>一个简单的 rpm -i package_name.rpm 命令对于安装一个包来说就足够了, 虽然这个命<br />
令还有好多其它的选项.</p>

<p>注意: rpm -qf 列出一个文件属于那个包.<br />
bash$ rpm -qf /bin/ls<br />
coreutils-5.2.1-3</p>

<p>注意: rpm -qa 将会列出给定系统上所有安装了的 rpm 包. rpm -qa package_name 命令<br />
将会列出于给定名字匹配的包.<br />
bash$ rpm -qa<br />
redhat-logos-1.1.3-1<br />
glibc-2.2.4-13<br />
cracklib-2.7-12<br />
dosfstools-2.7-1<br />
gdbm-1.8.0-10<br />
ksymoops-2.4.1-1<br />
mktemp-1.5-11<br />
perl-5.6.0-17<br />
reiserfs-utils-3.x.0j-2<br />
&hellip;</p>

<p>bash$ rpm -qa docbook-utils<br />
docbook-utils-0.6.9-2</p>

<p>bash$ rpm -qa docbook | grep docbook<br />
docbook-dtd31-sgml-1.0-10<br />
docbook-style-dsssl-1.64-3<br />
docbook-dtd30-sgml-1.0-10<br />
docbook-dtd40-sgml-1.0-11<br />
docbook-utils-pdf-0.6.9-2<br />
docbook-dtd41-sgml-1.0-10<br />
docbook-utils-0.6.9-2</p>

<p>cpio<br />
这个特殊的归档拷贝命令(拷贝输入和输出)现在已经很少能见到了, 因为它已经被 tar/gz<br />
ip 所替代了.现在这个命令只在一些比较特殊的地方还在使用,比如拷贝一个目录树.</p>

<p>Example 12-27 使用 cpio 来拷贝一个目录树<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 使用 &lsquo;cpio&rsquo; 拷贝目录树.<br />
4<br />
5 # 使用 &lsquo;cpio&rsquo; 的优点:<br />
6 # 加速拷贝. 比通过管道使用 &lsquo;tar&rsquo; 命令快一些.<br />
7 # 很适合拷贝一些 &lsquo;cp&rsquo; 命令<br />
8 #+ 搞不定的的特殊文件(比如名字叫 pipes 的文件, 等等)<br />
9<br />
10 ARGS=2<br />
11 E_BADARGS=65<br />
12<br />
13 if [ $# -ne &ldquo;$ARGS&rdquo; ]<br />
14 then<br />
15 echo &ldquo;Usage: <code>basename $0</code> source destination&rdquo;<br />
16 exit $E_BADARGS<br />
17 fi<br />
18<br />
19 source=$1<br />
20 destination=$2<br />
21<br />
22 find &ldquo;$source&rdquo; -depth | cpio -admvp &ldquo;$destination&rdquo;<br />
23 # ^^^^^ ^^^^^<br />
24 # 阅读 &lsquo;find&rsquo; 和 &lsquo;cpio&rsquo; 的man 页来了解这些选项的意义.<br />
25<br />
26<br />
27 # 练习:<br />
28 # &mdash;&ndash;<br />
29<br />
30 # 添加一些代码来检查 &lsquo;find | cpio&rsquo; 管道命令的退出码($?)<br />
31 #+ 并且如果出现错误的时候输出合适的错误码.<br />
32<br />
33 exit 0<br />
################################End
Script#########################################</p>

<p>rpm2cpio<br />
这个命令可以从 rpm 归档文件中解出一个 cpio 归档文件.</p>

<p>Example 12-28 解包一个 rpm 归档文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # de-rpm.sh: 解包一个 &lsquo;rpm&rsquo; 归档文件<br />
3<br />
4 : ${1?&ldquo;Usage: <code>basename $0</code> target-file&rdquo;}<br />
5 # 必须指定 &lsquo;rpm&rsquo; 归档文件名作为参数.<br />
6<br />
7<br />
8 TEMPFILE=$$.cpio # Tempfile 必须是一个&rdquo;唯一&rdquo;的名字.<br />
9 # $$ 是这个脚本的进程 ID.<br />
10<br />
11 rpm2cpio &lt; $1 &gt; $TEMPFILE # 将 rpm 归档文件转换为 cpio 归档文件.<br />
12 cpio &ndash;make-directories -F $TEMPFILE -i # 解包 cpio 归档文件.<br />
13 rm -f $TEMPFILE # 删除 cpio 归档文件.<br />
14<br />
15 exit 0<br />
16<br />
17 # 练习:<br />
18 # 添加一些代码来检查 1) &ldquo;target-file&rdquo; 是否存在<br />
19 #+ 2) 这个文件是否是一个 rpm 归档文件.<br />
20 # 暗示: 分析 &lsquo;file&rsquo; 命令的输出.<br />
################################End
Script#########################################</p>

<p>压缩命令</p>

<p>gzip<br />
标准的 GNU/UNIX 压缩工具, 取代了比较差的 compress 命令. 相应的解压命令是gunzip,<br />
gzip -d 是等价的.</p>

<p>zcat 过滤器可以将一个 gzip 文件解压到 stdout, 所以尽可能的使用管道和重定向. 这<br />
个命令事实上就是一个可以工作于压缩文件(包括一些的使用老的 compress 工具压缩的文<br />
件)的 cat 命令. zcat 命令等价于 gzip -dc.</p>

<p>注意: 在某些商业的 UNIX 系统上, zcat 与 uncompress -c 等价, 并且不能工作于<br />
gzip 文件.</p>

<p>参见 Example 7-7.</p>

<p>bzip2<br />
用来压缩的一个可选的工具, 通常比 gzip 命令压缩率更高(所以更慢), 适用于比较大的<br />
文件. 相应的解压命令是 bunzip2.</p>

<p>注意: 新版本的 tar 命令已经直接支持 bzip2 了.</p>

<p>compress, uncompress<br />
这是一个老的, 私有的压缩工具, 一般的商业 UNIX 发行版都会有这个工具. 更有效率的<br />
gzip 工具早就把这个工具替换掉了. Linux 发行版一般也会包含一个兼容的 compress 命<br />
令, 虽然 gunzip 也可以加压用 compress 工具压缩的文件.</p>

<p>注意: znew 命令可以将 compress 压缩的文件转换为 gzip 压缩的文件.</p>

<p>sq<br />
另一种压缩工具, 一个只能工作于排过序的 ASCII 单词列表的过滤器.这个命令使用过滤<br />
器标准的调用语法, sq &lt; input-file &gt; output-file. 速度很快, 但是效率远不及<br />
gzip. 相应的解压命令为 unsq, 调用方法与 sq 相同.</p>

<p>注意: sq 的输出可以通过管道传递给 gzip 以便于进一步的压缩.</p>

<p>zip, unzip<br />
跨平台的文件归档和压缩工具, 与 DOS 下的 pkzip.exe 兼容. zip 归档文件看起来在互<br />
联网上比 tar 包更流行.</p>

<p>unarc, unarj, unrar<br />
这些 Linux 工具可以用来解档那些用 DOS 下的 arc.exe, arj.exe, 和 rar.exe 程序进<br />
行归档的文件.</p>

<p>文件信息<br />
file<br />
确定文件类型的工具. 命令 file file-name 将会用 ascii 文本或数据的形式返回<br />
file-name 文件的详细描述. 这个命令会使用 /usr/share/magic, /etc/magic, 或<br />
/usr/lib/magic 中定义的 魔法数字 来标识包含某种魔法数字的文件, 上边所举出的这<br />
3个文件需要依赖于具体的 Linux/UNIX 发行版.</p>

<p>-f 选项将会让 file 命令运行于批处理模式, 也就是说它会分析 -f 后边所指定的文件,<br />
从中读取需要处理的文件列表, 然后依次执行 file 命令. -z 选项, 当对压缩过的目标文<br />
件使用时, 将会强制分析压缩的文件类型.</p>

<p>bash$ file test.tar.gz<br />
test.tar.gz: gzip compressed data, deflated, last modified: Sun Sep 16
13:34:51 2001, os: Unix</p>

<p>bash file -z test.tar.gz<br />
test.tar.gz: GNU tar archive (gzip compressed data, deflated, last modified:
Sun Sep 16 13:34:51 2001, os: Unix)</p>

<p>1 # 在给定的目录中找出sh和Bash脚本文件:<br />
2<br />
3 DIRECTORY=/usr/local/bin<br />
4 KEYWORD=Bourne<br />
5 # Bourne 和 Bourne-Again shell 脚本<br />
6<br />
7 file $DIRECTORY/* | fgrep $KEYWORD<br />
8<br />
9 # 输出:<br />
10<br />
11 # /usr/local/bin/burn-cd: Bourne-Again shell script text executable<br />
12 # /usr/local/bin/burnit: Bourne-Again shell script text executable<br />
13 # /usr/local/bin/cassette.sh: Bourne shell script text executable<br />
14 # /usr/local/bin/copy-cd: Bourne-Again shell script text executable<br />
15 # &hellip;</p>

<p>Example 12-29 从 C 文件中去掉注释<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # strip-comment.sh: 去掉C 程序中的注释 (/* 注释 <em>/)<br />
3<br />
4 E_NOARGS=0<br />
5 E_ARGERROR=66<br />
6 E_WRONG_FILE_TYPE=67<br />
7<br />
8 if [ $# -eq &ldquo;$E_NOARGS&rdquo; ]<br />
9 then<br />
10 echo &ldquo;Usage: <code>basename $0</code> C-program-file&rdquo; &gt;&amp;2 # 将错误消息发到 stderr.<br />
11 exit $E_ARGERROR<br />
12 fi<br />
13<br />
14 # 检查文件类型是否正确.<br />
15 type=<code>file $1 | awk '{ print $2, $3, $4, $5 }'</code><br />
16 # &ldquo;file $1&rdquo; echoe 出文件类型 &hellip;<br />
17 # 然后 awk 会删掉第一个域, 就是文件名 &hellip;<br />
18 # 然后结果将会传递到变量 &ldquo;type&rdquo; 中.<br />
19 correct_type=&ldquo;ASCII C program text&rdquo;<br />
20<br />
21 if [ &ldquo;$type&rdquo; != &ldquo;$correct_type&rdquo; ]<br />
22 then<br />
23 echo<br />
24 echo &ldquo;This script works on C program files only.&rdquo;<br />
25 echo<br />
26 exit $E_WRONG_FILE_TYPE<br />
27 fi<br />
28<br />
29<br />
30 # 相当隐秘的 sed 脚本:<br />
31 #&mdash;&mdash;&ndash;<br />
32 sed &lsquo;<br />
33 /^\/\*/d<br />
34 /.</em>\<em>\//d<br />
35 &lsquo; $1<br />
36 #&mdash;&mdash;&ndash;<br />
37 # 如果你花上几个小时来学习 sed 语法的话, 上边这个命令还是很好理解的.<br />
38<br />
39<br />
40 # 如果注释和代码在同一行上, 上边的脚本就不行了.<br />
41 #+ 所以需要添加一些代码来处理这种情况.<br />
42 # 这是一个很重要的练习.<br />
43<br />
44 # 当然, 上边的代码也会删除带有 &ldquo;</em>/&rdquo; 的非注释行 &ndash;<br />
45 #+ 这也不是一个令人满意的结果.<br />
46<br />
47 exit 0<br />
48<br />
49<br />
50 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
51 # 下边的代码不会执行, 因为上边已经 &lsquo;exit 0&rsquo; 了.<br />
52<br />
53 # Stephane Chazelas 建议使用下边的方法:<br />
54<br />
55 usage() {<br />
56 echo &ldquo;Usage: <code>basename $0</code> C-program-file&rdquo; &gt;&amp;2<br />
57 exit 1<br />
58 }<br />
59<br />
60 WEIRD=<code>echo -n -e '\377'</code> # or WEIRD=$&rsquo;\377&rsquo;<br />
61 [[ $# -eq 1 ]] || usage<br />
62 case <code>file &quot;$1&quot;</code> in<br />
63 <em>&ldquo;C program text&rdquo;</em>) sed -e &ldquo;s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g&rdquo; &ldquo;$1&rdquo; \<br />
64 | tr &lsquo;\377\n&rsquo; &lsquo;\n\377&rsquo; \<br />
65 | sed -ne &lsquo;p;n&rsquo; \<br />
66 | tr -d &lsquo;\n&rsquo; | tr &lsquo;\377&rsquo; &lsquo;\n&rsquo;;;<br />
67 <em>) usage;;<br />
68 esac<br />
69<br />
70 # 如果是下列的这些情况, 还是很糟糕:<br />
71 # printf(&ldquo;/</em>&rdquo;);<br />
72 # or<br />
73 # /* /* buggy embedded comment */<br />
74 #<br />
75 # 为了处理上边所有这些特殊情况(字符串中的注释, 含有 \&ldquo;, \\&rdquo; &hellip;<br />
76 #+ 的字符串中的注释) 唯一的方法还是写一个 C 分析器<br />
77 #+ (或许可以使用lex 或者 yacc ?).<br />
78<br />
79 exit 0<br />
################################End
Script#########################################</p>

<p>which<br />
which command-xxx 将会给出 &ldquo;command-xxx&rdquo; 的完整路径. 当你想在系统中准确定位一个<br />
特定的命令或工具的时候, 这个命令就非常有用了.</p>

<p>$bash which rm<br />
/usr/bin/rm</p>

<p>whereis<br />
与上边的 which 很相似, whereis command-xxx 不只会给出 &ldquo;command-xxx&rdquo; 的完整路径,<br />
而且还会给出这个命令的 man页 的完整路径.</p>

<p>$bash whereis rm<br />
rm: /bin/rm /usr/share/man/man1/rm.1.bz2</p>

<p>whatis<br />
whatis filexxx 将会在 whatis 数据库中查询 &ldquo;filexxx&rdquo;. 当你想确认系统命令和重要的<br />
配置文件的时候, 这个命令就非常重要了. 可以把这个命令认为是一个简单的 man 命令.</p>

<p>$bash whatis whatis<br />
whatis (1) - search the whatis database for complete words</p>

<p>Example 12-30 Exploring /usr/X11R6/bin<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 在 /usr/X11R6/bin 中的所有神秘的2进制文件都是什么东西?<br />
4<br />
5 DIRECTORY=&ldquo;/usr/X11R6/bin&rdquo;<br />
6 # 也试试 &ldquo;/bin&rdquo;, &ldquo;/usr/bin&rdquo;, &ldquo;/usr/local/bin&rdquo;, 等等.<br />
7<br />
8 for file in $DIRECTORY/*<br />
9 do<br />
10 whatis <code>basename $file</code> # 将会 echo 出这个2进制文件的信息.<br />
11 done<br />
12<br />
13 exit 0<br />
14<br />
15 # 你可能希望将这个脚本的输出重定向, 像这样:<br />
16 # ./what.sh &gt;&gt;whatis.db<br />
17 # 或者一页一页的在 stdout 上查看,<br />
18 # ./what.sh | less<br />
################################End
Script#########################################<br />
参见 Example 10-3.</p>

<p>vdir<br />
显示详细的目录列表. 与 ls -l 的效果类似.<br />
这是一个 GNU fileutils.</p>

<p>bash$ vdir<br />
total 10<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 4034 Jul 18 22:04 data1.xrolo<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 4602 May 25 13:58 data1.xrolo.bak<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 877 Dec 17 2000 employment.xrolo</p>

<p>bash ls -l<br />
total 10<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 4034 Jul 18 22:04 data1.xrolo<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 4602 May 25 13:58 data1.xrolo.bak<br />
-rw-r&ndash;r&ndash; 1 bozo bozo 877 Dec 17 2000 employment.xrolo</p>

<p>locate, slocate<br />
locate 命令将会在预先建立好的档案数据库中查询文件. slocate 命令是 locate 的安全<br />
版本( locate 命令可能已经被关联到 slocate 命令上了).</p>

<p>$bash locate hickson<br />
/usr/lib/xephem/catalogs/hickson.edb</p>

<p>readlink<br />
显示符号连接所指向的文件.</p>

<p>bash$ readlink /usr/bin/awk<br />
../../bin/gawk</p>

<p>strings<br />
使用 strings 命令在二进制或数据文件中找出可打印字符. 它将在目标文件中列出所有找<br />
到的可打印字符的序列. 这个命令对于想进行快速查找一个 n 个字符的打印检查来说是很<br />
方便的,也可以用来检查一个未知格式的图片文件 (strings image-file | more 可能会搜<br />
索出像 JFIF 这样的字符串, 那么这就意味着这个文件是一个 jpeg 格式的图片文件).<br />
在脚本中, 你可能会使用 grep 或 sed 命令来分析 strings 命令的输出. 参见<br />
Example 10-7 和 Example 10-9.</p>

<p>Example 12-31 一个&rdquo;改进过&rdquo;的 strings 命令<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # wstrings.sh: &ldquo;word-strings&rdquo; (增强的 &ldquo;strings&rdquo; 命令)<br />
3 #<br />
4 # 这个脚本将会过滤 &ldquo;strings&rdquo; 命令的输出.<br />
5 #+ 通过排除标准单词列表的形式检查来过滤输出.<br />
6 # 这将有效的过滤掉无意义的字符,<br />
7 #+ 并且指挥输出可以识别的字符.<br />
8<br />
9 # ===========================================================<br />
10 # 脚本参数的标准检查<br />
11 ARGS=1<br />
12 E_BADARGS=65<br />
13 E_NOFILE=66<br />
14<br />
15 if [ $# -ne $ARGS ]<br />
16 then<br />
17 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
18 exit $E_BADARGS<br />
19 fi<br />
20<br />
21 if [ ! -f &ldquo;$1&rdquo; ] # 检查文件是否存在.<br />
22 then<br />
23 echo &ldquo;File \&ldquo;$1\&rdquo; does not exist.&rdquo;<br />
24 exit $E_NOFILE<br />
25 fi<br />
26 # ===========================================================<br />
27<br />
28<br />
29 MINSTRLEN=3 # 最小的字符串长度.<br />
30 WORDFILE=/usr/share/dict/linux.words # 字典文件.<br />
31 # 也可以指定一个不同的<br />
32 #+ 单词列表文件,<br />
33 #+ 但这种文件必须是以每个单词一行的方式进行保存.<br />
34<br />
35<br />
36 wlist=<code>strings &quot;$1&quot; | tr A-Z a-z | tr '[:space:]' Z | \  
37 tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '</code><br />
38<br />
39 # 将&rsquo;strings&rsquo; 命令的输出通过管道传递到多个 &lsquo;tr&rsquo; 命令中.<br />
40 # &ldquo;tr A-Z a-z&rdquo; 全部转换为小写字符.<br />
41 # &ldquo;tr &lsquo;[:space:]&lsquo;&rdquo; 转换空白字符为多个 Z.<br />
42 # &ldquo;tr -cs &lsquo;[:alpha:]&rsquo; Z&rdquo; 将非字母表字符转换为多个 Z,<br />
43 #+ 然后去除多个连续的 Z.<br />
44 # &ldquo;tr -s &lsquo;\173-\377&rsquo; Z&rdquo; 把所有z后边的字符都转换为 Z.<br />
45 #+ 并且去除多余重复的Z.(注意173(123 ascii &ldquo;{&rdquo;)和377(255 ascii 最后一个字符)都是8进制)<br />
46 #+ 这样处理之后, 我们所有之前需要处理的令我们头痛的字符<br />
47 #+ 就全都转换为字符 Z 了.<br />
48 # 最后&rdquo;tr Z &lsquo; &lsquo;&rdquo; 将把所有的 Z 都转换为空格,<br />
49 #+ 这样我们在下边循环中用到的变量 wlist 中的内容就全部以空格分隔了.<br />
50<br />
51 # ****************************************************************<br />
52 # 注意, 我们使用管道来将多个 &lsquo;tr&rsquo; 的输出传递到下一个 &lsquo;tr&rsquo; 时<br />
53 #+ 每次都使用了不同的参数.<br />
54 # ****************************************************************<br />
55<br />
56<br />
57 for word in $wlist # 重要:<br />
58 # $wlist 这里不能使用双引号.<br />
59 # &ldquo;$wlist&rdquo; 不能正常工作.<br />
60 # 为什么不行?<br />
61 do<br />
62<br />
63 strlen=${#word} # 字符串长度.<br />
64 if [ &ldquo;$strlen&rdquo; -lt &ldquo;$MINSTRLEN&rdquo; ] # 跳过短的字符串.<br />
65 then<br />
66 continue<br />
67 fi<br />
68<br />
69 grep -Fw $word &ldquo;$WORDFILE&rdquo; # 只匹配整个单词.<br />
70 # ^^^ # &ldquo;固定字符串&rdquo; 和<br />
71 #+ &ldquo;整个单词&rdquo; 选项.<br />
72<br />
73 done<br />
74<br />
75<br />
76 exit $?<br />
################################End
Script#########################################</p>

<p>比较命令</p>

<p>diff, patch<br />
diff: 一个非常灵活的文件比较工具. 这个工具将会以一行接一行的形式来比较目标文件.<br />
在某些应用中, 比如说比较单词词典, 在通过管道将结果传递给 diff 命令之前, 使用诸<br />
如 sort 和 uniq 命令来对文件进行过滤将是非常有用的.diff file-1 file-2 将会输出<br />
2个文件不同的行,并会通过符号标识出每个不同行所属的文件.</p>

<p>diff 命令的 &ndash;side-by-side 选项将会把2个比较中的文件全部输出, 按照左右分隔的形<br />
式, 并会把不同的行标记出来. -c 和 -u 选项也会使得 diff 命令的输出变得容易解释<br />
一些.</p>

<p>还有一些 diff 命令的变种, 比如 sdiff, wdiff, xdiff, 和 mgdiff.</p>

<p>注意: 如果比较的两个文件是完全一样的话, 那么 diff 命令会返回 0 作为退出码, 如果<br />
不同的话就返回 1 作为退出码. 这样 diff 命令就可以用在 shell 脚本的测试结构<br />
中了. (见下边)</p>

<p>diff 命令的一个重要用法就是产生区别文件, 这个文件将用作 patch 命令的 -e 选项的<br />
参数, -e 选项接受 ed 或 ex 脚本.</p>

<p>patch: 灵活的版本工具.给出一个用 diff 命令产生的区别文件, patch 命令可以将一个<br />
老版本的包更新为一个新版本的包. 因为你发布一个小的区别文件远比重新发布一个大的<br />
软件包来的容易得多.对于频繁更新的 Linux 内核来说, 使用补丁包的形式来发布将是一<br />
种很好的方法.</p>

<p>1 patch -p1  2 # 在&rsquo;patch-file&rsquo;中取得所有的修改列表<br />
3 # 然后把它们应用于其中索引到的文件上.<br />
4 # 那么这个包就被更新为新版本了.</p>

<p>更新 kernel:</p>

<p>1 cd /usr/src<br />
2 gzip -cd patchXX.gz | patch -p0<br />
3 # 使用&rsquo;patch&rsquo;来更新内核源文件.<br />
4 # 来自于匿名作者(Alan Cox?)的<br />
5 # Linux 内核文档 &ldquo;README&rdquo;.</p>

<p>注意: diff 命令也可以递归的比较目录下的所有文件(包含子目录).</p>

<p>bash$ diff -r ~/notes1 ~/notes2<br />
Only in /home/bozo/notes1: file02<br />
Only in /home/bozo/notes1: file03<br />
Only in /home/bozo/notes2: file04</p>

<p>注意: 使用 zdiff 来比较 gzip 文件.</p>

<p>diff3<br />
一个 diff 命令的扩展版本, 可以同时比较3个文件. 如果成功执行那么这个命令就返回0,<br />
但是不幸的是这个命令不给出比较结果的信息.</p>

<h1 id="bash-diff3-file-1-file-2-file-3">bash$ diff3 file-1 file-2 file-3</h1>

<p>1:1c<br />
This is line 1 of &ldquo;file-1&rdquo;.<br />
2:1c<br />
This is line 1 of &ldquo;file-2&rdquo;.<br />
3:1c<br />
This is line 1 of &ldquo;file-3&rdquo;</p>

<p>sdiff<br />
比较 和/或 编辑2个文件, 将它们合并到一个输出文件中. 因为这个命令的交互特性, 所<br />
以在脚本中很少使用这个命令.</p>

<p>cmp<br />
cmp 命令是上边 diff 命令的一个简单版本. diff 命令会报告两个文件的不同之处, 而<br />
cmp 命令仅仅指出那些位置有不同, 而不会显示不同的具体细节.</p>

<p>注意: 与 diff 一样,如果两个文件相同 cmp 返回0作为退出码, 如果不同返回1. 这样就<br />
可以用在 shell 脚本的测试结构中了.</p>

<p>Example 12-32 在一个脚本中使用 cmp 来比较2个文件.<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 ARGS=2 # 脚本需要2个参数.<br />
4 E_BADARGS=65<br />
5 E_UNREADABLE=66<br />
6<br />
7 if [ $# -ne &ldquo;$ARGS&rdquo; ]<br />
8 then<br />
9 echo &ldquo;Usage: <code>basename $0</code> file1 file2&rdquo;<br />
10 exit $E_BADARGS<br />
11 fi<br />
12<br />
13 if [[ ! -r &ldquo;$1&rdquo; || ! -r &ldquo;$2&rdquo; ]]<br />
14 then<br />
15 echo &ldquo;Both files to be compared must exist and be readable.&rdquo;<br />
16 exit $E_UNREADABLE<br />
17 fi<br />
18<br />
19 cmp $1 $2 &amp;&gt; /dev/null # /dev/null 将会禁止 &ldquo;cmp&rdquo; 命令的输出.<br />
20 # cmp -s $1 $2 与上边这句结果相同 (&ldquo;-s&rdquo; 选项是安静标志)<br />
21 # Thank you Anders Gustavsson for pointing this out.<br />
22 #<br />
23 # 用 &lsquo;diff&rsquo; 命令也可以, 比如, diff $1 $2 &amp;&gt; /dev/null<br />
24<br />
25 if [ $? -eq 0 ] # 测试 &ldquo;cmp&rdquo; 命令的退出码.<br />
26 then<br />
27 echo &ldquo;File \&ldquo;$1\&rdquo; is identical to file \&ldquo;$2\&ldquo;.&rdquo;<br />
28 else<br />
29 echo &ldquo;File \&ldquo;$1\&rdquo; differs from file \&ldquo;$2\&ldquo;.&rdquo;<br />
30 fi<br />
31<br />
32 exit 0<br />
################################End
Script#########################################<br />
注意: 用 zcmp 处理 gzip 文件.</p>

<p>comm<br />
多功能的文件比较工具. 使用这个命令之前必须先排序.</p>

<p>comm -options first-file second-file</p>

<p>comm file-1 file-2 将会输出3列:</p>

<ul>
<li>第 1 列 = 只在 file-1 中存在的行<br /></li>
<li>第 2 列 = 只在 file-2 中存在的行<br /></li>
<li>第 2 列 = 两边相同的行.</li>
</ul>

<p>下列选项可以禁止1列或多列的输出.</p>

<ul>
<li>-1 禁止显示第一栏 (译者: 在 File1 中的行)<br /></li>
<li>-2 禁止显示第二栏 (译者: 在 File2 中的行)<br /></li>
<li>-3 禁止显示第三栏 (译者: File1 和 File2 公共的行)<br /></li>
<li>-12 禁止第一列和第二列, (就是说选项可以组合).</li>
</ul>

<p>一般工具</p>

<p>basename<br />
从文件名中去掉路径信息, 只打印出文件名. 结构 basename $0 可以让脚本知道它自己的<br />
名字, 也就是, 它被调用的名字. 可以用来显示用法信息, 比如如果你调用脚本的时候缺<br />
少参数, 可以使用如下语句:<br />
1 echo &ldquo;Usage: <code>basename $0</code> arg1 arg2 &hellip; argn&rdquo;</p>

<p>dirname<br />
从带路径的文件名中去掉文件名, 只打印出路径信息.</p>

<p>注意: basename 和 dirname 可以操作任意字符串. 参数可以不是一个真正存在的文件,<br />
甚至可以不是一个文件名.(参见 Example A-7).</p>

<p>Example 12-33 basename 和 dirname<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 a=/home/bozo/daily-journal.txt<br />
4<br />
5 echo &ldquo;Basename of /home/bozo/daily-journal.txt = <code>basename $a</code>&rdquo;<br />
6 echo &ldquo;Dirname of /home/bozo/daily-journal.txt = <code>dirname $a</code>&rdquo;<br />
7 echo<br />
8 echo &ldquo;My own home is <code>basename ~/</code>.&rdquo; # <code>basename ~</code> also works.<br />
9 echo &ldquo;The home of my home is <code>dirname ~/</code>.&rdquo; # <code>dirname ~</code> also works.<br />
10<br />
11 exit 0<br />
################################End
Script#########################################</p>

<p>split, csplit<br />
将一个文件分割为几个小段的工具. 这些命令通常用来将大的文件分割, 并备份到软盘上,<br />
或者是为了切成合适的尺寸用 email 上传.</p>

<p>csplit 根据 上下文 来切割文件, 切割的位置将会发生在模式匹配的地方.</p>

<p>sum, cksum, md5sum, sha1sum<br />
这些都是用来产生 checksum 的工具. checksum 的目的是用来检验文件的完整性, 是对文<br />
件的内容进行数学计算而得到的. 出于安全目的一个脚本可能会有一个 checksum 列表,<br />
这样可以确保关键系统文件的内容不会被修改或损坏. 对于需要安全性的应用来说, 应该<br />
使用 md5sum (message digest 5 checksum) 命令, 或者更好的更新的 sha1sum<br />
(安全 Hash 算法).</p>

<p>bash$ cksum /boot/vmlinuz<br />
1670054224 804083 /boot/vmlinuz</p>

<p>bash$ echo -n &ldquo;Top Secret&rdquo; | cksum<br />
3391003827 10</p>

<p>bash$ md5sum /boot/vmlinuz<br />
0f43eccea8f09e0a0b2b5cf1dcf333ba /boot/vmlinuz</p>

<p>bash$ echo -n &ldquo;Top Secret&rdquo; | md5sum<br />
8babc97a6f62a4649716f4df8d61728f -</p>

<p>注意: cksum 命令将会显示目标的尺寸(字节), 目标可以使文件或 stdout.<br />
md5sum 和 sha1sum 命令在它们收到 stdout 的输入时候, 显示一个 dash .</p>

<p>Example 12-34 检查文件完整性<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # file-integrity.sh: 检查一个给定目录下的文件<br />
3 # 是否被改动了.<br />
4<br />
5 E_DIR_NOMATCH=70<br />
6 E_BAD_DBFILE=71<br />
7<br />
8 dbfile=File_record.md5<br />
9 # 存储记录的文件名 (数据库文件).<br />
10<br />
11<br />
12 set_up_database ()<br />
13 {<br />
14 echo &ldquo;&rdquo;$directory&rdquo;&rdquo; &gt; &ldquo;$dbfile&rdquo;<br />
15 # 把目录名写到文件的第一行.<br />
16 md5sum &ldquo;$directory&rdquo;/* &gt;&gt; &ldquo;$dbfile&rdquo;<br />
17 # 在文件中附上 md5 checksums 和 filenames.<br />
18 }<br />
19<br />
20 check_database ()<br />
21 {<br />
22 local n=0<br />
23 local filename<br />
24 local checksum<br />
25<br />
26 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- #<br />
27 # 这个文件检查其实是不必要的,<br />
28 #+ 但是能安全一些.<br />
29<br />
30 if [ ! -r &ldquo;$dbfile&rdquo; ]<br />
31 then<br />
32 echo &ldquo;Unable to read checksum database file!&rdquo;<br />
33 exit $E_BAD_DBFILE<br />
34 fi<br />
35 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- #<br />
36<br />
37 while read record[n]<br />
38 do<br />
39<br />
40 directory_checked=&ldquo;${record[0]}&rdquo;<br />
41 if [ &ldquo;$directory_checked&rdquo; != &ldquo;$directory&rdquo; ]<br />
42 then<br />
43 echo &ldquo;Directories do not match up!&rdquo;<br />
44 # 换个目录试一下.<br />
45 exit $E_DIR_NOMATCH<br />
46 fi<br />
47<br />
48 if [ &ldquo;$n&rdquo; -gt 0 ] # 不是目录名.<br />
49 then<br />
50 filename[n]=$( echo ${record[$n]} | awk &lsquo;{ print $2 }&rsquo; )<br />
51 # md5sum 向后写记录,<br />
52 #+ 先写 checksum, 然后写 filename.<br />
53 checksum[n]=$( md5sum &ldquo;${filename[n]}&rdquo; )<br />
54<br />
55<br />
56 if [ &ldquo;${record[n]}&rdquo; = &ldquo;${checksum[n]}&rdquo; ]<br />
57 then<br />
58 echo &ldquo;${filename[n]} unchanged.&rdquo;<br />
59<br />
60 elif [ &ldquo;<code>basename ${filename[n]}</code>&rdquo; != &ldquo;$dbfile&rdquo; ]<br />
61 # 跳过checksum 数据库文件,<br />
62 #+ 因为在每次调用脚本它都会被修改.<br />
63 # &mdash;<br />
64 # 这不幸的意味着当我们在 $PWD中运行这个脚本<br />
65 #+ 时, 修改这个 checksum 数<br />
66 #+ 据库文件将不会被检测出来.<br />
67 # 练习: 修复这个问题.<br />
68 then<br />
69 echo &ldquo;${filename[n]} : CHECKSUM ERROR!&rdquo;<br />
70 # 因为最后的检查, 文件已经被修改.<br />
71 fi<br />
72<br />
73 fi<br />
74<br />
75<br />
76<br />
77 let &ldquo;n+=1&rdquo;<br />
78 done 79<br />
80 }<br />
81<br />
82 # =================================================== #<br />
83 # main ()<br />
84<br />
85 if [ -z &ldquo;$1&rdquo; ]<br />
86 then<br />
87 directory=&ldquo;$PWD&rdquo; # 如果没制定参数,<br />
88 else #+ 那么就使用当前的工作目录.<br />
89 directory=&ldquo;$1&rdquo;<br />
90 fi<br />
91<br />
92 clear # 清屏.<br />
93 echo &ldquo; Running file integrity check on $directory&rdquo;<br />
94 echo<br />
95<br />
96 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; #<br />
97 if [ ! -r &ldquo;$dbfile&rdquo; ] # 是否需要建立数据库文件?<br />
98 then<br />
99 echo &ldquo;Setting up database file, \&ldquo;&rdquo;$directory&rdquo;/&ldquo;$dbfile&rdquo;\&ldquo;.&rdquo;; echo<br />
100 set_up_database<br />
101 fi<br />
102 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; #<br />
103<br />
104 check_database # 调用主要处理函数.<br />
105<br />
106 echo<br />
107<br />
108 # 你可能想把这个脚本的输出重定向到文件中,<br />
109 #+ 尤其在这个目录中有很多文件的时候.<br />
110<br />
111 exit 0<br />
112<br />
113 # 如果要对数量非常多的文件做完整性检查,<br />
114 #+ 可以考虑一下 &ldquo;Tripwire&rdquo; 包,<br />
115 #+ <a href="http://sourceforge.net/projects/tripwire/">http://sourceforge.net/projects/tripwire/</a>.<br />
116<br />
################################End
Script#########################################<br />
参见 Example A-19 和 Example 33-14 , 这两个例子展示了 md5sum 命令的用法.</p>

<p>注意: 已经有 128-bit md5sum 被破解的报告了,所以现在更安全的 160-bit sha1sum 是<br />
非常受欢迎的, 并且已经被加入到 checksum 工具包中.</p>

<p>一些安全顾问认为即使是 sha1sum 也是会被泄漏的. 所以, 下一个工具是什么呢?<br />
-- 512-bit 的 checksum 工具?</p>

<p>bash$ md5sum testfile<br />
e181e2c8720c60522c4c4c981108e367 testfile</p>

<p>bash$ sha1sum testfile<br />
5d7425a9c08a66c3177f1e31286fa40986ffc996 testfile</p>

<p>shred<br />
用随机字符填充文件, 使得文件无法恢复, 这样就可以保证文件安全的被删除. 这个命令<br />
的效果与 Example 12-55 一样, 但是使用这个命令是一种更优雅更彻底的方法.</p>

<p>这是一个 GNU fileutils.</p>

<p>注意: 即使使用了 shred 命令, 高级的(forensic)辩论技术还是能够恢复文件的内容.</p>

<p>编码和解码</p>

<p>uuencode<br />
这个工具用来把二进制文件编码成 ASCII 字符串,这个工具适用于编码e-mail消息体,或者<br />
新闻组消息.</p>

<p>uudecode<br />
这个工具用来把 uuencode 后的 ASCII 字符串恢复为二进制文件.</p>

<p>Example 12-35 Uudecod 编码后的文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 在当前目录下 uudecode 所有用 uuencode 编码的文件.<br />
3<br />
4 lines=35 # 允许读头部的 35 行(范围很宽).<br />
5<br />
6 for File in * # Test 所有 $PWD 下的文件.<br />
7 do<br />
8 search1=<code>head -$lines $File | grep begin | wc -w</code><br />
9 search2=<code>tail -$lines $File | grep end | wc -w</code><br />
10 # Uuencode 过的文件在文件开始的地方有个 &ldquo;begin&rdquo;,<br />
11 #+ 在文件结尾的地方有个 &ldquo;end&rdquo;.<br />
12 if [ &ldquo;$search1&rdquo; -gt 0 ]<br />
13 then<br />
14 if [ &ldquo;$search2&rdquo; -gt 0 ]<br />
15 then<br />
16 echo &ldquo;uudecoding - $File -&rdquo;<br />
17 uudecode $File<br />
18 fi<br />
19 fi<br />
20 done<br />
21<br />
22 # 小心不要让这个脚本运行自己,<br />
23 #+ 因为它也会把自身也认为是一个 uuencoded 文件,<br />
24 #+ 这都是因为这个脚本自身也包含 &ldquo;begin&rdquo; 和 &ldquo;end&rdquo;.<br />
25<br />
26 # 练习:<br />
27 # &mdash;&ndash;<br />
28 # 修改这个脚本, 让它可以检查一个新闻组的每个文件,<br />
29 #+ 并且如果下一个没找的话就跳过.<br />
30<br />
31 exit 0<br />
################################End
Script#########################################</p>

<p>注意: fold -s 命令在处理从 Usenet 新闻组下载下来的长的uudecode 文本消息的时候可<br />
能会有用(可能在管道中).</p>

<p>mimencode, mmencode<br />
mimencode 和 mmencode 命令处理多媒体编码的 email 附件. 虽然 mail 用户代理<br />
(比如 pine 或 kmail) 通常情况下都会自动处理, 但是这些特定的工具允许从命令行或<br />
shell脚本中来手动操作这些附件.</p>

<p>crypt<br />
这个工具曾经是标准的 UNIX 文件加密工具. [3] 政府由于政策上的动机规定禁止加密软<br />
件的输出, 这样导致了 crypt 命令从 UNIX 世界消失, 并且在大多数的 Linux 发行版中<br />
也没有这个命令. 幸运的是, 程序员们想出了一些替代它的方法, 在这些方法中有作者自<br />
己的 cruft (参见 Example A-4).</p>

<p>一些杂项工具</p>

<p>mktemp<br />
使用一个&rdquo;唯一&rdquo;的文件名来创建一个 临时文件 [4] . 如果不带参数的在命令行下调用<br />
这个命令时, 将会在 /tmp 目录下产生一个零长度的文件.</p>

<p>bash$ mktemp<br />
/tmp/tmp.zzsvql3154</p>

<p>1 PREFIX=filename<br />
2 tempfile=<code>mktemp $PREFIX.XXXXXX</code><br />
3 # ^^^^^^ 在这个临时的文件名中<br />
4 #+ 至少需要6个占位符.<br />
5 # 如果没有指定临时文件的文件名,<br />
6 #+ 那么默认就是 &ldquo;tmp.XXXXXXXXXX&rdquo;.<br />
7<br />
8 echo &ldquo;tempfile name = $tempfile&rdquo;<br />
9 # tempfile name = filename.QA2ZpY<br />
10 # 或者一些其他的相似的名字&hellip;<br />
11<br />
12 # 使用 600 为文件权限<br />
13 #+ 来在当前工作目录下创建一个这样的文件.<br />
14 # 这样就不需要 &ldquo;umask 177&rdquo; 了.<br />
15 # 但不管怎么说, 这也是一个好的编程风格.</p>

<p>make<br />
build 和 compile 二进制包的工具. 当源文件被增加或修改时就会触发一些操作, 这个工<br />
具用来控制这些操作.</p>

<p>make 命令将会检查 Makefile, makefile 是文件的依赖和操作列表.</p>

<p>install<br />
特殊目的的文件拷贝命令, 与 cp 命令相似, 但是具有设置拷贝文件的权限和属性的能力.<br />
这个命令看起来是为了安装软件包所定制的, 而且就其本身而言, 这个命令经常出现在<br />
Makefile 中(在 make install : 区中). 在安装脚本中也会看到这个命令的使用.</p>

<p>dos2unix<br />
这个工具是由 Benjamin Lin 和其同事编写的, 目的是将 DOS 格式的文本文件<br />
(以 CR-LF 为行结束符) 转换为 UNIX 格式 (以 LF 为行结束符), 反过来也一样.</p>

<p>ptx<br />
ptx [targetfile] 命令将会输出目标文件的序列改变的索引(交叉引用列表). 如果必要的<br />
话, 这个命令可以在管道中进行更深层次的过滤和格式化.</p>

<p>more, less<br />
分页显示文本文件或 stdout, 一次一屏.可以用来过滤 stdout 的输出 &hellip; 或一个脚本<br />
的输出.</p>

<p>more 命令的一个有趣的应用就是测试一个命令序列的执行, 来避免可能发生的糟糕的<br />
结果.</p>

<p>1 ls /home/bozo | awk &lsquo;{print &ldquo;rm -rf &rdquo; $1}&rsquo; | more<br />
2 # ^^^^<br />
3<br />
4 # 检测下边(灾难性的)命令行的效果:<br />
5 # ls /home/bozo | awk &lsquo;{print &ldquo;rm -rf &rdquo; $1}&rsquo; | sh<br />
6 # 推入 shell 中执行 &hellip;</p>

<p>注意事项:<br />
[1] 在这里所讨论的一个归档文件, 只不过是存储在一个单一位置上的一些相关文件的<br />
集合.<br />
[2] tar czvf archive_name.tar.gz * 可以 包含当前工作目录下的点文件. 这是一个<br />
未文档化的 GNU tar 的&rdquo;特征&rdquo;.<br />
[3] 这是一个对称的块密码, 过去曾在单系统或本地网络中用来加密文件, 用来对抗<br />
&ldquo;public key&rdquo; 密码类, pgp 就是一个众所周知的例子.<br />
[4] 使用 -d 选项可以创建一个临时的目录.</p>

<p>12.6 通讯命令<br />
-&mdash;&mdash;&mdash;&mdash;<br />
下边命令中的某几个命令你会在 &ldquo;追踪垃圾邮件&rdquo; 练习中找到其用法, 用来进行网络数<br />
据的转换和分析.</p>

<p>信息与统计</p>

<p>host<br />
通过名字或 IP 地址来搜索一个互联网主机的信息, 使用 DNS.</p>

<p>bash$ host surfacemail.com<br />
surfacemail.com. has address 202.92.42.236</p>

<p>ipcalc<br />
显示一个主机 IP 信息. 使用 -h 选项, ipcalc 将会做一个 DNS 的反向查询, 通过 IP<br />
地址找到主机(服务器)名.</p>

<p>bash$ ipcalc -h 202.92.42.236<br />
HOSTNAME=surfacemail.com</p>

<p>nslookup<br />
通过 IP 地址在一个主机上做一个互联网的 &ldquo;名字服务查询&rdquo;. 事实上这与 ipcalc -h 或<br />
dig -x 等价. 这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运<br />
行.</p>

<p>nslookup 命令据说已经慢慢被&rdquo;忽视&rdquo;了, 但是它还是有它的用处.</p>

<p>bash$ nslookup -sil 66.97.104.180<br />
nslookup kuhleersparnis.ch<br />
Server: 135.116.137.2<br />
Address: 135.116.137.2#53</p>

<p>Non-authoritative answer:<br />
Name: kuhleersparnis.ch</p>

<p>dig<br />
域信息查询. 与 nslookup 很相似, dig 在一个主机上做一个互联网的 &ldquo;名字服务查询&rdquo;.<br />
这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运行.</p>

<p>下边是一些 dig 命令有趣的选项, +time=N 选项用来设置查询超时为 N 秒, +nofail<br />
选项用来持续查询服务器直到收到一个响应, -x 选项会做反向地址查询.</p>

<p>比较下边这3个命令的输出, dig -x , ipcalc -h 和 nslookup.</p>

<p>bash$ dig -x 81.9.6.2<br />
;; Got answer:<br />
;; -&gt;&gt;HEADER&lt; ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1,
ADDITIONAL: 0</p>

<p>;; QUESTION SECTION:<br />
;2.6.9.81.in-addr.arpa. IN PTR</p>

<p>;; AUTHORITY SECTION:<br />
6.9.81.in-addr.arpa. 3600 IN SOA ns.eltel.net. noc.eltel.net.<br />
2002031705 900 600 86400 3600</p>

<p>;; Query time: 537 msec<br />
;; SERVER: 135.116.137.2#53(135.116.137.2)<br />
;; WHEN: Wed Jun 26 08:35:24 2002<br />
;; MSG SIZE rcvd: 91</p>

<p>Example 12-36 查找滥用的连接来报告垃圾邮件发送者<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # spam-lookup.sh: 查找滥用的连接来报告垃圾邮件发送者.<br />
3 # 感谢 Michael Zick.<br />
4<br />
5 # 检查命令行参数.<br />
6 ARGCOUNT=1<br />
7 E_WRONGARGS=65<br />
8 if [ $# -ne &ldquo;$ARGCOUNT&rdquo; ]<br />
9 then<br />
10 echo &ldquo;Usage: <code>basename $0</code> domain-name&rdquo;<br />
11 exit $E_WRONGARGS<br />
12 fi<br />
13<br />
14<br />
15 dig +short $1.contacts.abuse.net -c in -t txt<br />
16 # 也试试:<br />
17 # dig +nssearch $1<br />
18 # 尽量找到 &ldquo;可信赖的名字服务器&rdquo; 并且显示 SOA 记录.<br />
19<br />
20 # 下边这句也可以:<br />
21 # whois -h whois.abuse.net $1<br />
22 # ^^ ^^^^^^^^^^^^^^^ 指定主机.<br />
23 # 使用这个命令也可以查找多个垃圾邮件发送者, 比如:&rdquo;<br />
24 # whois -h whois.abuse.net $spamdomain1 $spamdomain2 &hellip;<br />
25<br />
26<br />
27 # 练习:<br />
28 # &mdash;&ndash;<br />
29 # 扩展这个脚本的功能,<br />
30 #+ 让它可以自动发送 e-mail 来通知<br />
31 #+ 需要对此负责的 ISP 的联系地址.<br />
32 # 暗示: 使用 &ldquo;mail&rdquo; 命令.<br />
33<br />
34 exit $?<br />
35<br />
36 # spam-lookup.sh chinatietong.com<br />
37 # 一个已知的垃圾邮件域.(译者: 中国铁通&hellip;)<br />
38<br />
39 # &ldquo;crnet_mgr@chinatietong.com&rdquo;<br />
40 # &ldquo;crnet_tec@chinatietong.com&rdquo;<br />
41 # &ldquo;postmaster@chinatietong.com&rdquo;<br />
42<br />
43<br />
44 # 如果想找到这个脚本的一个更详尽的版本,<br />
45 #+ 请访问 SpamViz 的主页, <a href="http://www.spamviz.net/index.html">http://www.spamviz.net/index.html</a>.<br />
################################End
Script#########################################</p>

<p>Example 12-37 分析一个垃圾邮件域<br />
################################Start
Script#######################################<br />
1 #! /bin/bash<br />
2 # is-spammer.sh: 鉴别一个垃圾邮件域<br />
3<br />
4 # $Id: is-spammer, v 1.4 2004/09/01 19:37:52 mszick Exp $<br />
5 # 上边这行是 RCS ID 信息.<br />
6 #<br />
7 # 这是附件中捐献脚本 is_spammer.bash<br />
8 #+ 的一个简单版本.<br />
9<br />
10 # is-spammer<br />
11<br />
12 # 使用外部程序: &lsquo;dig&rsquo;<br />
13 # 测试版本: 9.2.4rc5<br />
14<br />
15 # 使用函数.<br />
16 # 使用 IFS 来分析分配在数组中的字符串.<br />
17 # 检查 e-mail 黑名单.<br />
18<br />
19 # 使用来自文本体中的 domain.name:<br />
20 # <a href="http://www.good_stuff.spammer.biz/just_ignore_everything_else">http://www.good_stuff.spammer.biz/just_ignore_everything_else</a><br />
21 # ^^^^^^^^^^^<br />
22 # 或者使用来自任意 e-mail 地址的 domain.name:<br />
23 # Really_Good_Offer@spammer.biz<br />
24 #<br />
25 # 并将其作为这个脚本的唯一参数.<br />
26 #(另: 你的 Inet 连接应该保证连接)<br />
27 #<br />
28 # 这样, 在上边两个实例中调用这个脚本:<br />
29 # is-spammer.sh spammer.biz<br />
30<br />
31<br />
32 # Whitespace == :Space:Tab:Line Feed:Carriage Return:<br />
33 WSP_IFS=$&rsquo;\x20&rsquo;$&rsquo;\x09&rsquo;$&rsquo;\x0A&rsquo;$&rsquo;\x0D&rsquo;<br />
34<br />
35 # No Whitespace == Line Feed:Carriage Return<br />
36 No_WSP=$&rsquo;\x0A&rsquo;$&rsquo;\x0D&rsquo;<br />
37<br />
38 # 域分隔符为点分10进制 ip 地址<br />
39 ADR_IFS=${No_WSP}&lsquo;.&rsquo;<br />
40<br />
41 # 取得 dns 文本资源记录.<br />
42 # get_txt<br />
43 get_txt() {<br />
44<br />
45 # 分析在&rdquo;.&ldquo;中分配的 $1.<br />
46 local -a dns<br />
47 IFS=$ADR_IFS<br />
48 dns=( $1 )<br />
49 IFS=$WSP_IFS<br />
50 if [ &ldquo;${dns[0]}&rdquo; == &lsquo;127&rsquo; ]<br />
51 then<br />
52 # 查看此处是否有原因.<br />
53 echo $(dig +short $2 -t txt)<br />
54 fi<br />
55 }<br />
56<br />
57 # 取得 dns 地址资源记录.<br />
58 # chk_adr<br />
59 chk_adr() {<br />
60 local reply<br />
61 local server<br />
62 local reason<br />
63<br />
64 server=${1}${2}<br />
65 reply=$( dig +short ${server} )<br />
66<br />
67 # 假设应答可能是一个错误码 &hellip;<br />
68 if [ ${#reply} -gt 6 ]<br />
69 then<br />
70 reason=$(get_txt ${reply} ${server} )<br />
71 reason=${reason:-${reply}}<br />
72 fi<br />
73 echo ${reason:-&rsquo; not blacklisted.&lsquo;}<br />
74 }<br />
75<br />
76 # 需要从名字中取得 IP 地址.<br />
77 echo &lsquo;Get address of: &lsquo;$1<br />
78 ip_adr=$(dig +short $1)<br />
79 dns_reply=${ip_adr:-&rsquo; no answer &lsquo;}<br />
80 echo &lsquo; Found address: &lsquo;${dns_reply}<br />
81<br />
82 # 一个可用的应答至少是4个数字加上3个点.<br />
83 if [ ${#ip_adr} -gt 6 ]<br />
84 then<br />
85 echo<br />
86 declare query<br />
87<br />
88 # 分析点中的分配.<br />
89 declare -a dns<br />
90 IFS=$ADR_IFS<br />
91 dns=( ${ip_adr} )<br />
92 IFS=$WSP_IFS<br />
93<br />
94 # Reorder octets into dns query order.<br />
95 rev_dns=&ldquo;${dns[3]}&ldquo;&lsquo;.&rsquo;&rdquo;${dns[2]}&ldquo;&lsquo;.&rsquo;&rdquo;${dns[1]}&ldquo;&lsquo;.&rsquo;&rdquo;${dns[0]}&ldquo;&lsquo;.&rsquo;<br />
96<br />
97 # 参见: <a href="http://www.spamhaus.org">http://www.spamhaus.org</a> (Conservative, well maintained)<br />
98 echo -n &lsquo;spamhaus.org says: &lsquo;<br />
99 echo $(chk_adr ${rev_dns} &lsquo;sbl-xbl.spamhaus.org&rsquo;)<br />
100<br />
101 # 参见: <a href="http://ordb.org">http://ordb.org</a> (Open mail relays)<br />
102 echo -n &lsquo; ordb.org says: &lsquo;<br />
103 echo $(chk_adr ${rev_dns} &lsquo;relays.ordb.org&rsquo;)<br />
104<br />
105 # 参见: <a href="http://www.spamcop.net/">http://www.spamcop.net/</a> (你可以在这里报告 spammer)<br />
106 echo -n &lsquo; spamcop.net says: &lsquo;<br />
107 echo $(chk_adr ${rev_dns} &lsquo;bl.spamcop.net&rsquo;)<br />
108<br />
109 # # # 其他的黑名单操作 # # #<br />
110<br />
111 # 参见: <a href="http://cbl.abuseat.org">http://cbl.abuseat.org</a>.<br />
112 echo -n &lsquo; abuseat.org says: &lsquo;<br />
113 echo $(chk_adr ${rev_dns} &lsquo;cbl.abuseat.org&rsquo;)<br />
114<br />
115 # 参见: <a href="http://dsbl.org/usage">http://dsbl.org/usage</a> (Various mail relays)<br />
116 echo<br />
117 echo &lsquo;Distributed Server Listings&rsquo;<br />
118 echo -n &lsquo; list.dsbl.org says: &lsquo;<br />
119 echo $(chk_adr ${rev_dns} &lsquo;list.dsbl.org&rsquo;)<br />
120<br />
121 echo -n &lsquo; multihop.dsbl.org says: &lsquo;<br />
122 echo $(chk_adr ${rev_dns} &lsquo;multihop.dsbl.org&rsquo;)<br />
123<br />
124 echo -n &lsquo;unconfirmed.dsbl.org says: &lsquo;<br />
125 echo $(chk_adr ${rev_dns} &lsquo;unconfirmed.dsbl.org&rsquo;)<br />
126<br />
127 else<br />
128 echo<br />
129 echo &lsquo;Could not use that address.&rsquo;<br />
130 fi<br />
131<br />
132 exit 0<br />
133<br />
134 # 练习:<br />
135 # &mdash;&ndash;<br />
136<br />
137 # 1) 检查脚本的参数,<br />
138 # 并且如果必要的话使用合适的错误消息退出.<br />
139<br />
140 # 2) 检查调用这个脚本的时候是否在线,<br />
141 # 并且如果必要的话使用合适的错误消息退出.<br />
142<br />
143 # 3) Substitute generic variables for &ldquo;hard-coded&rdquo; BHL domains.<br />
144<br />
145 # 4) 通过对 &lsquo;dig&rsquo; 命令使用 &ldquo;+time=&rdquo; 选项<br />
146 来给这个脚本设置一个暂停.<br />
################################End
Script#########################################<br />
想获得比上边这个脚本更详细的版本, 参见 Example A-27.</p>

<p>traceroute<br />
跟踪包发送到远端主机过程中的路由信息. 这个命令在 LAN, WAN, 或者在 Internet 上都<br />
可以正常工作. 远端主机可以通过 IP 地址来指定. 这个命令的输出也可以通过管道中的<br />
grep 或 sed 命令来过滤.</p>

<p>bash$ traceroute 81.9.6.2<br />
traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets<br />
1 tc43.xjbnnbrb.com (136.30.178.8) 191.303 ms 179.400 ms 179.767 ms<br />
2 or0.xjbnnbrb.com (136.30.178.1) 179.536 ms 179.534 ms 169.685 ms<br />
3 192.168.11.101 (192.168.11.101) 189.471 ms 189.556 ms *<br />
&hellip;</p>

<p>ping<br />
广播一个 &ldquo;ICMP ECHO_REQUEST&rdquo; 包到其他主机上, 既可以是本地网络也可以使远端网络.<br />
这是一个测试网络连接的诊断工具, 应该小心使用.</p>

<p>一个成功的 ping 返回的 退出码 为 0. 可以用在脚本的测试语句中.</p>

<p>bash$ ping localhost<br />
PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.<br />
64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709
usec<br />
64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286
usec</p>

<p>-&ndash; localhost.localdomain ping statistics &mdash;<br />
2 packets transmitted, 2 packets received, 0% packet loss<br />
round-trip min/avg/max/mdev = 0.<sup>286</sup>&frasl;<sub>0</sub>.<sup>497</sup>&frasl;<sub>0</sub>.<sup>709</sup>&frasl;<sub>0</sub>.212 ms</p>

<p>whois<br />
执行DNS (域名系统) 查询lookup. -h 选项允许指定需要查询的特定的 whois 服务器.<br />
参见 Example 4-6 和 Example 12-36.</p>

<p>finger<br />
取得网络上的用户信息. 另外这个命令可以显示一个用户的~/.plan, ~/.project, 和<br />
~/.forward 文件, 如果存在的话.</p>

<p>bash$ finger<br />
Login Name Tty Idle Login Time Office Office Phone<br />
bozo Bozo Bozeman tty1 8 Jun 25 16:59<br />
bozo Bozo Bozeman ttyp0 Jun 25 16:59<br />
bozo Bozo Bozeman ttyp1 Jun 25 17:07</p>

<p>bash$ finger bozo<br />
Login: bozo Name: Bozo Bozeman<br />
Directory: /home/bozo Shell: /bin/bash<br />
Office: 2355 Clown St., 543-1234<br />
On since Fri Aug 31 20:13 (MST) on tty1 1 hour 38 minutes idle<br />
On since Fri Aug 31 20:13 (MST) on pts/0 12 seconds idle<br />
On since Fri Aug 31 20:13 (MST) on pts/1<br />
On since Fri Aug 31 20:31 (MST) on pts/2 1 hour 16 minutes idle<br />
No mail.<br />
No Plan.</p>

<p>处于安全上的考虑, 许多网络都禁用了 finger 以及和它相关的幽灵进程. [1]</p>

<p>chfn<br />
修改 finger 命令所显示出来的用户信息.</p>

<p>vrfy<br />
验证一个互联网的 e-mail 地址.</p>

<p>远端主机接入</p>

<p>sx, rx<br />
sx 和 rx 命令使用 xmodem 协议, 设置服务来向远端主机传输文件和接收文件. 这些都<br />
是通讯安装包的一般部分, 比如 minicom.</p>

<p>sz, rz<br />
sz 和 rz 命令使用 zmodem 协议, 设置服务来向远端主机传输文件和接收文件. zmodem<br />
协议在某些方面比 xmodem强, 比如使用更快的的传输波特率, 并且可以对中断的文件进<br />
行续传.与 sx 一样 rx, 这些都是通讯安装包的一般部分.</p>

<p>ftp<br />
向远端服务器上传或下载的工具和协议. 一个ftp会话可以写到脚本中自动运行. (见<br />
Example 17-6, Example A-4, 和 Example A-13).</p>

<p>uucp, uux, cu<br />
uucp: UNIX 到 UNIX 拷贝. 这是一个通讯安装包, 目的是为了在 UNIX 服务器之间传输<br />
文件. 使用 shell 脚本来处理 uucp 命令序列是一种有效的方法.</p>

<p>因为互联网和电子邮件的出现, uucp 现在看起来已经很落伍了, 但是这个命令在互联网<br />
连接不可用或者不适合使用的地方, 这个命令还是可以完美的运行. uucp 的优点就是它<br />
的容错性, 即使有一个服务将拷贝操作中断了, 那么当连接恢复的时候, 这个命令还是<br />
可以在中断的地方续传.</p>

<p>-&ndash;</p>

<p>uux: UNIX 到 UNIX 执行. 在远端系统上执行一个命令.这个命令是 uucp 包的一部分.</p>

<p>-&ndash;</p>

<p>cu: Call Up 一个远端系统并且作为一个简单终端进行连接. 这是一个 telnet 的缩减<br />
版本. 这个命令是 uucp 包的一部分.</p>

<p>telnet<br />
连接远端主机的工具和协议.</p>

<p>注意:telnet 协议本身包含安全漏洞, 因此我们应该适当的避免使用.</p>

<p>wget<br />
wget 工具使用非交互的形式从 web 或 ftp 站点上取得或下载文件. 在脚本中使用正好.</p>

<p>1 wget -p <a href="http://www.xyz23.com/file01.html">http://www.xyz23.com/file01.html</a><br />
2 # The -p or &ndash;page-requisite 选项将会使得 wget 取得显示指定页时<br />
3 #+ 所需要的所有文件.(译者: 比如内嵌图片和样式表等).<br />
4<br />
5 wget -r <a href="ftp://ftp.xyz24.net/~bozo/project_files/">ftp://ftp.xyz24.net/~bozo/project_files/</a> -O $SAVEFILE<br />
6 # -r 选项将会递归的从指定站点<br />
7 #+ 上下载所有连接.</p>

<p>Example 12-38 获得一份股票报价<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # quote-fetch.sh: 下载一份股票报价.<br />
3<br />
4<br />
5 E_NOPARAMS=66<br />
6<br />
7 if [ -z &ldquo;$1&rdquo; ] # 必须指定需要获取的股票(代号).<br />
8 then echo &ldquo;Usage: <code>basename $0</code> stock-symbol&rdquo;<br />
9 exit $E_NOPARAMS<br />
10 fi<br />
11<br />
12 stock_symbol=$1<br />
13<br />
14 file_suffix=.html<br />
15 # 获得一个 HTML 文件, 所以要正确命名它.<br />
16 URL=&lsquo;<a href="http://finance.yahoo.com/q?s='">http://finance.yahoo.com/q?s='</a><br />
17 # Yahoo 金融板块, 后缀是股票查询.<br />
18<br />
19 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
20 wget -O ${stock_symbol}${file_suffix} &ldquo;${URL}${stock_symbol}&rdquo;<br />
21 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
22<br />
23<br />
24 # 在 <a href="http://search.yahoo.com">http://search.yahoo.com</a> 上查询相关材料:<br />
25 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
26 # URL=&ldquo;<a href="http://search.yahoo.com/search?fr=ush-news&amp;p=${query}&quot;">http://search.yahoo.com/search?fr=ush-news&amp;p=${query}&quot;</a><br />
27 # wget -O &ldquo;$savefilename&rdquo; &ldquo;${URL}&rdquo;<br />
28 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
29 # 保存相关 URL 的列表.<br />
30<br />
31 exit $?<br />
32<br />
33 # 练习:<br />
34 # &mdash;&ndash;<br />
35 #<br />
36 # 1) 添加一个测试来验证用户正在线.<br />
37 # (暗示: 对 &ldquo;ppp&rdquo; 或 &ldquo;connect&rdquo; 来分析 &lsquo;ps -ax&rsquo; 的输出.<br />
38 #<br />
39 # 2) 修改这个脚本, 让这个脚本具有获得本地天气预报的能力,<br />
40 #+ 将用户的 zip code 作为参数.<br />
################################End
Script#########################################<br />
参见 Example A-29 和 Example A-30.</p>

<p>lynx<br />
lynx 是一个网页浏览器, 也是一个文件浏览器. 它可以(通过使用 -dump 选项)在脚本中<br />
使用. 它的作用是可以从 Web 或 ftp 站点上非交互的获得文件.</p>

<p>1 lynx -dump <a href="http://www.xyz23.com/file01.html">http://www.xyz23.com/file01.html</a> &gt;$SAVEFILE</p>

<p>使用 -traversal 选项, lynx 将从参数中指定的 HTTP URL 开始, 遍历指定服务器上的<br />
所有链接. 如果与 -crawl 选项一起用的话, 将会把每个输出的页面文本都放到一个 log<br />
文件中.</p>

<p>rlogin<br />
远端登陆, 在远端的主机上开启一个会话. 这个命令存在安全隐患, 所以要使用 ssh 来<br />
代替.</p>

<p>rsh<br />
远端 shell, 在远端的主机上执行命令. 这个命令存在安全隐患, 所以要使用 ssh 来代<br />
替.</p>

<p>rcp<br />
远端拷贝, 在网络上的不同主机间拷贝文件.</p>

<p>rsync<br />
远端同步, 在网络上的不同主机间(同步)更新文件.</p>

<p>bash$ rsync -a ~/sourcedir/*txt /node1/subdirectory/</p>

<p>Example 12-39 更新 Fedora 4<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # fc4upd.sh<br />
3<br />
4 # 脚本作者: Frank Wang.<br />
5 # 本书作者作了少量修改.<br />
6 # 授权在本书中使用.<br />
7<br />
8<br />
9 # 使用 rsync 命令从镜像站点上下载 Fedora 4 的更新.<br />
10 # 为了节省空间, 如果有多个版本存在的话,<br />
11 #+ 只下载最新的包.<br />
12<br />
13 URL=rsync://distro.ibiblio.org/fedora-linux-core/updates/<br />
14 # URL=rsync://ftp.kddilabs.jp/fedora/core/updates/<br />
15 # URL=rsync://rsync.planetmirror.com/fedora-linux-core/updates/<br />
16<br />
17 DEST=${1:-/var/www/html/fedora/updates/}<br />
18 LOG=/tmp/repo-update-$(/bin/date +%Y-%m-%d).txt<br />
19 PID_FILE=/var/run/${0##<em>/}.pid<br />
20<br />
21 E_RETURN=65 # 某些意想不到的错误.<br />
22<br />
23<br />
24 # 一搬 rsync 选项<br />
25 # -r: 递归下载<br />
26 # -t: 保存时间<br />
27 # -v: verbose<br />
28<br />
29 OPTS=&ldquo;-rtv &ndash;delete-excluded &ndash;delete-after &ndash;partial&rdquo;<br />
30<br />
31 # rsync include 模式<br />
32 # Leading slash causes absolute path name match.<br />
33 INCLUDE=(<br />
34 &ldquo;/4/i386/kde-i18n-Chinese</em>&rdquo;<br />
35 # ^ ^<br />
36 # 双引号是必须的, 用来防止file globbing.<br />
37 )<br />
38<br />
39<br />
40 # rsync exclude 模式<br />
41 # 使用 &ldquo;#&rdquo; 临时注释掉一些不需要的包.<br />
42 EXCLUDE=(<br />
43 /1<br />
44 /2<br />
45 /3<br />
46 /testing<br />
47 /4/SRPMS<br />
48 /4/ppc<br />
49 /4/x86_64<br />
50 /4/i386/debug<br />
51 &ldquo;/4/i386/kde-i18n-<em>&rdquo;<br />
52 &ldquo;/4/i386/openoffice.org-langpack-</em>&rdquo;<br />
53 &ldquo;/4/i386/<em>i586.rpm&rdquo;<br />
54 &ldquo;/4/i386/GFS-</em>&rdquo;<br />
55 &ldquo;/4/i386/cman-<em>&rdquo;<br />
56 &ldquo;/4/i386/dlm-</em>&rdquo;<br />
57 &ldquo;/4/i386/gnbd-<em>&rdquo;<br />
58 &ldquo;/4/i386/kernel-smp</em>&rdquo;<br />
59 # &ldquo;/4/i386/kernel-xen<em>&rdquo;<br />
60 # &ldquo;/4/i386/xen-</em>&rdquo;<br />
61 )<br />
62<br />
63<br />
64 init () {<br />
65 # 让管道命令返回可能的 rsync 错误, 比如, 网络延时(stalled network).<br />
66 set -o pipefail<br />
67<br />
68 TMP=${TMPDIR:-/tmp}/${0##<em>/}.$$ # 保存精炼的下载列表.<br />
69 trap &ldquo;{<br />
70 rm -f $TMP 2&gt;/dev/null<br />
71 }&rdquo; EXIT # 删除存在的临时文件.<br />
72 }<br />
73<br />
74<br />
75 check_pid () {<br />
76 # 检查进程是否存在.<br />
77 if [ -s &ldquo;$PID_FILE&rdquo; ]; then<br />
78 echo &ldquo;PID file exists. Checking &hellip;&rdquo;<br />
79 PID=$(/bin/egrep -o &ldquo;<sup class="footnote-ref" id="fnref:digit"><a href="#fn:digit">3</a></sup>+&rdquo; $PID_FILE)<br />
80 if /bin/ps &ndash;pid $PID &amp;&gt;/dev/null; then<br />
81 echo &ldquo;Process $PID found. ${0##</em>/} seems to be running!&rdquo;<br />
82 /usr/bin/logger -t ${0##<em>/} \<br />
83 &ldquo;Process $PID found. ${0##</em>/} seems to be running!&rdquo;<br />
84 exit $E_RETURN<br />
85 fi<br />
86 echo &ldquo;Process $PID not found. Start new process &hellip;&rdquo;<br />
87 fi<br />
88 }<br />
89<br />
90<br />
91 # 根据上边的模式,<br />
92 #+ 设置整个文件的更新范围, 从 root 或 $URL 开始.<br />
93 set_range () {<br />
94 include=<br />
95 exclude=<br />
96 for p in &ldquo;${INCLUDE[@]}&ldquo;; do<br />
97 include=&ldquo;$include &ndash;include \&ldquo;$p\&ldquo;&rdquo;<br />
98 done<br />
99<br />
100 for p in &ldquo;${EXCLUDE[@]}&ldquo;; do<br />
101 exclude=&ldquo;$exclude &ndash;exclude \&ldquo;$p\&ldquo;&rdquo;<br />
102 done<br />
103 }<br />
104<br />
105<br />
106 # 获得并提炼 rsync 更新列表.<br />
107 get_list () {<br />
108 echo $$ &gt; $PID_FILE || {<br />
109 echo &ldquo;Can&rsquo;t write to pid file $PID_FILE&rdquo;<br />
110 exit $E_RETURN<br />
111 }<br />
112<br />
113 echo -n &ldquo;Retrieving and refining update list &hellip;&rdquo;<br />
114<br />
115 # 获得列表 &ndash; 为了作为单个命令来运行 rsync 需要 &lsquo;eval&rsquo;.<br />
116 # $3 和 $4 是文件创建的日期和时间.<br />
117 # $5 是完整的包名字.<br />
118 previous=<br />
119 pre_file=<br />
120 pre_date=0<br />
121 eval /bin/nice /usr/bin/rsync \<br />
122 -r $include $exclude $URL | \<br />
123 egrep &lsquo;^dr.x|^-r&rsquo; | \<br />
124 awk &lsquo;{print $3, $4, $5}&rsquo; | \<br />
125 sort -k3 | \<br />
126 { while read line; do<br />
127 # 获得这段运行的秒数, 过滤掉不用的包.<br />
128 cur_date=$(date -d &ldquo;$(echo $line | awk &lsquo;{print $1, $2}&rsquo;)&rdquo; +%s)<br />
129 # echo $cur_date<br />
130<br />
131 # 取得文件名.<br />
132 cur_file=$(echo $line | awk &lsquo;{print $3}&rsquo;)<br />
133 # echo $cur_file<br />
134<br />
135 # 如果可能的话, 从文件名中取得 rpm 的包名字.<br />
136 if [[ $cur_file == <em>rpm ]]; then<br />
137 pkg_name=$(echo $cur<em>file | sed -r -e \<br />
138 &rsquo;s/(^([^</em>-]+[_-])+)[[:digit:]]+\..</em>[_-].<em>$/\1/&lsquo;)<br />
139 else<br />
140 pkg_name=<br />
141 fi<br />
142 # echo $pkg_name<br />
143<br />
144 if [ -z &ldquo;$pkg_name&rdquo; ]; then # 如果不是一个 rpm 文件,<br />
145 echo $cur_file &gt;&gt; $TMP #+ 然后添加到下载列表里.<br />
146 elif [ &ldquo;$pkg_name&rdquo; != &ldquo;$previous&rdquo; ]; then # 发现一个新包.<br />
147 echo $pre_file &gt;&gt; $TMP # 输出最新的文件.<br />
148 previous=$pkg_name # 保存当前状态.<br />
149 pre_date=$cur_date<br />
150 pre_file=$cur_file<br />
151 elif [ &ldquo;$cur_date&rdquo; -gt &ldquo;$pre_date&rdquo; ]; then # 如果是相同的包, 但是更新一些,<br />
152 pre_date=$cur_date #+ 那么就更新最新的.<br />
153 pre_file=$cur_file<br />
154 fi<br />
155 done<br />
156 echo $pre_file &gt;&gt; $TMP # TMP 现在包含所有<br />
157 #+ 提炼过的列表.<br />
158 # echo &ldquo;subshell=$BASH_SUBSHELL&rdquo;<br />
159<br />
160 } # 这里的打括号是为了让最后这句&rdquo;echo $pre_file &gt;&gt; $TMP&rdquo;<br />
161 # 也能与整个循环一起放到同一个子 shell ( 1 )中.<br />
162<br />
163 RET=$? # 取得管道命令的返回码.<br />
164<br />
165 [ &ldquo;$RET&rdquo; -ne 0 ] &amp;&amp; {<br />
166 echo &ldquo;List retrieving failed with code $RET&rdquo;<br />
167 exit $E_RETURN<br />
168 }<br />
169<br />
170 echo &ldquo;done&rdquo;; echo<br />
171 }<br />
172<br />
173 # 真正的 rsync 的下载部分.<br />
174 get_file () {<br />
175<br />
176 echo &ldquo;Downloading&hellip;&rdquo;<br />
177 /bin/nice /usr/bin/rsync \<br />
178 $OPTS \<br />
179 &ndash;filter &ldquo;merge,+/ $TMP&rdquo; \<br />
180 &ndash;exclude &lsquo;</em>&rsquo; \<br />
181 $URL $DEST \<br />
182 | /usr/bin/tee $LOG<br />
183<br />
184 RET=$?<br />
185<br />
186 # &ndash;filter merge,+/ is crucial for the intention.<br />
187 # + modifier means include and / means absolute path.<br />
188 # Then sorted list in $TMP will contain ascending dir name and<br />
189 #+ prevent the following &ndash;exclude &lsquo;<em>&rsquo; from &ldquo;shortcutting the circuit.&rdquo;<br />
190<br />
191 echo &ldquo;Done&rdquo;<br />
192<br />
193 rm -f $PID_FILE 2&gt;/dev/null<br />
194<br />
195 return $RET<br />
196 }<br />
197<br />
198 # &mdash;&mdash;-<br />
199 # Main<br />
200 init<br />
201 check_pid<br />
202 set_range<br />
203 get_list<br />
204 get_file<br />
205 RET=$?<br />
206 # &mdash;&mdash;-<br />
207<br />
208 if [ &ldquo;$RET&rdquo; -eq 0 ]; then<br />
209 /usr/bin/logger -t ${0##</em>/} &ldquo;Fedora update mirrored successfully.&rdquo;<br />
210 else<br />
211 /usr/bin/logger -t ${0##*/} &ldquo;Fedora update mirrored with failure code:
$RET&rdquo;<br />
212 fi<br />
213<br />
214 exit $RET<br />
################################End
Script#########################################<br />
使用 rcp, rsync, 和其他一些有安全问题的类似工具, 并将这些工具用在 shell 脚本中<br />
是不明智的. 应该考虑使用 ssh, scp, 或者一个 expect 脚本来代替这些不安全的工具.</p>

<p>ssh<br />
安全 shell, 登陆远端主机并在其上运行命令. 这个工具具有身份认证和加密的功能, 可<br />
以安全的替换 telnet, rlogin, rcp, 和 rsh 等工具. 参见 man页 来获取详细信息.</p>

<p>Example 12-40 使用 ssh<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # remote.bash: 使用 ssh.<br />
3<br />
4 # 这个例子是 Michael Zick 编写的.<br />
5 # 授权使用.<br />
6<br />
7<br />
8 # 假设:<br />
9 # &mdash;&ndash;<br />
10 # fd-2(文件描述符2) 并没有被抛弃 ( &lsquo;2&gt;/dev/null&rsquo; ).<br />
11 # ssh/sshd 假设 stderr (&lsquo;2&rsquo;) 将会被显示给用户.<br />
12 #<br />
13 # sshd 正运行在你的机器上.<br />
14 # 对于大多数 &lsquo;标准&rsquo; 的发行版, 是应该有的,<br />
15 #+ 并且没有一些稀奇古怪的 ssh-keygen.<br />
16<br />
17 # 在你的机器上从命令行中试一下 ssh:<br />
18 #<br />
19 # $ ssh $HOSTNAME<br />
20 # 不同特殊的准备, 你将被要求输入你的密码.<br />
21 # 输入密码<br />
22 # 完成后, $ exit<br />
23 #<br />
24 # 好使了么? 如果好使了, 你可以做好准备来获取更多的乐趣了.<br />
25<br />
26 # 在你的机器上用 &lsquo;root&rsquo;身份来试试 ssh:<br />
27 #<br />
28 # $ ssh -l root $HOSTNAME<br />
29 # 当询问密码时, 输入 root 的密码, 别输入你的密码.<br />
30 # Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain<br />
31 # 完成后键入 &lsquo;exit&rsquo;.<br />
32<br />
33 # 上边的动作将会给你一个交互的shell.<br />
34 # 在 &lsquo;single command&rsquo; 模式下建立 sshd 是可能的,<br />
35 #+ 不过这已经超出本例的范围了.<br />
36 # 唯一需要注意的事情是下面都可以工作在<br />
37 #+ &lsquo;single command&rsquo; 模式.<br />
38<br />
39<br />
40 # 一个基本的写输出(本地)命令.<br />
41<br />
42 ls -l<br />
43<br />
44 # 现在在远端机器上使用同样的基本命令.<br />
45 # 使用一套不同的 &lsquo;USERNAME&rsquo; 和 &lsquo;HOSTNAME&rsquo; :<br />
46 USER=${USERNAME:-$(whoami)}<br />
47 HOST=${HOSTNAME:-$(hostname)}<br />
48<br />
49 # 现在在远端主机上运行上边的命令行命令,<br />
50 #+ 当然, 所有的传输都被加密了.<br />
51<br />
52 ssh -l ${USER} ${HOST} &ldquo; ls -l &rdquo;<br />
53<br />
54 # 期望的结果就是在远端主机上列出你的<br />
55 #+ username 主目录的所有文件.<br />
56 # 如果想看点不一样的, 那就<br />
57 #+ 在别的地方运行这个脚本, 别再你的主目录上运行这个脚本.<br />
58<br />
59 # 换句话说, Bash 命令已经作为一个引用行<br />
60 #+ 被传递到远端的shell 中了,这样就可以在远端的机器上运行它了.<br />
61 # 在这种情况下, sshd 代表你运行了 &lsquo; bash -c &ldquo;ls -l&rdquo; &lsquo;.<br />
62<br />
63 # 对于每个命令行如果想不输入密码的话,<br />
64 #+ 对于这种类似的议题, 可以参阅<br />
65 #+ man ssh<br />
66 #+ man ssh-keygen<br />
67 #+ man sshd_config.<br />
68<br />
69 exit 0<br />
################################End
Script#########################################</p>

<p>注意: 在循环中, ssh 可能会引起意想不到的异常行为. 根据comp.unix 上的shell文档<br />
Usenet post , ssh 继承了循环的标准输入.为了解决这个问题, 使用 ssh 的 -n<br />
或者 -f 选项.</p>

<p>感谢 Jason Bechtel, 指出这点.</p>

<p>scp<br />
安全拷贝, 在功能上与 rcp 很相似, 就是在2个不同的网络主机之间拷贝文件, 但是要通<br />
过鉴权的方式, 并且使用与 ssh 类似的安全层.</p>

<p>Local Network</p>

<p>write<br />
这是一个端到端通讯的工具. 这个工具可以从你的终端上(console 或者 xterm)发送整行<br />
到另一个用户的终端上. mesg 命令当然也可以用来对于一个终端的写权限</p>

<p>因为 write 是需要交互的, 所以这个命令通常不使用在脚本中.</p>

<p>netconfig<br />
用来配置网络适配器(使用 DHCP)的命令行工具. 这个命令对于红帽发行版来说是内置的.</p>

<p>Mail</p>

<p>mail<br />
发送或读取 e-mail 消息.</p>

<p>如果把这个命令行的 mail 客户端当成一个脚本中的命令来使用的话, 效果非常好.</p>

<p>Example 12-41 一个可以mail自己的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/sh<br />
2 # self-mailer.sh: mail自己的脚本<br />
3<br />
4 adr=${1:-<code>whoami</code>} # 如果不指定的话, 默认是当前用户.<br />
5 # 键入 &lsquo;self-mailer.sh wiseguy@superdupergenius.com&rsquo;<br />
6 #+ 发送这个脚本到这个地址.<br />
7 # 如果只键入 &lsquo;self-mailer.sh&rsquo; (不给参数) 的话, 那么这脚本就会被发送给<br />
8 #+ 调用者, 比如 bozo@localhost.localdomain.<br />
9 #<br />
10 # 如果想了解 ${parameter:-default} 结构的更多细节,<br />
11 #+ 请参见第9章 变量重游中的<br />
12 #+ 第3节 参数替换.<br />
13</p>

<h1 id="14">14 #</h1>

<p>15 cat $0 | mail -s &ldquo;Script \&rdquo;<code>basename $0</code>\&rdquo; has mailed itself to you.&rdquo;
&ldquo;$adr&rdquo;</p>

<h1 id="16">16 #</h1>

<p>17<br />
18 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
19 # 来自 self-mailing 脚本的一份祝福.<br />
20 # 一个喜欢恶搞的家伙运行了这个脚本,<br />
21 #+ 这导致了他自己收到了这份mail.<br />
22 # 显然的, 有些人确实没什么事好做,<br />
23 #+ 就只能浪费他们自己的时间玩了.<br />
24 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
25<br />
26 echo &ldquo;At <code>date</code>, script \&rdquo;<code>basename $0</code>\&rdquo; mailed to &ldquo;$adr&rdquo;.&rdquo;<br />
27<br />
28 exit 0<br />
################################End
Script#########################################</p>

<p>mailto<br />
与 mail 命令很相似, mailto 命令可以使用命令行或在脚本中发送 e-mail 消息. 然而,<br />
mailto 命令也允许发送 MIME (多媒体) 消息.</p>

<p>vacation<br />
这个工具可以自动回复 e-mail 给发送者, 表示邮件的接受者正在度假暂时无法收到邮件.<br />
这个工具与 sendmail 一起运行于网络上, 并且这个工具不支持拨号的 POPmail 帐号.</p>

<p>注意事项:<br />
[1] 一个幽灵进程指的是并未附加在终端会话中的后台进程. 幽灵进程 在指定的时间执<br />
行指定的服务, 或者由特定的事件出发来执行指定的服务.</p>

<p>12.7 终端控制命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
影响控制台或终端的命令</p>

<p>tput<br />
初始化终端或者从 terminfo data 中取得终端信息. 不同的选项允许特定的终端操作.<br />
tput clear 与下边的 clear 等价. tput reset 与下边的 reset 等价. tput sgr0 也可<br />
以重置终端, 但是并不清除屏幕.</p>

<p>bash$ tput longname<br />
xterm terminal emulator (XFree86 4.0 Window System)</p>

<p>使用 tput cup X Y 将会把光标移动到当前终端的(X,Y)坐标上. 使用这个命令之前一边<br />
都要先使用一下 clear 命令, 把屏幕清除一下.</p>

<p>注意: stty 提供了一个更强力的命令专门用来设置如何控制终端.</p>

<p>infocmp<br />
这个命令会打印出大量的当前终端的信息. 事实上它是引用了 terminfo 数据库.</p>

<p>bash$ infocmp</p>

<h1 id="通过来自于文件的-infocmp-显示出来">通过来自于文件的 infocmp 显示出来:</h1>

<p>/usr/share/terminfo/r/rxvt<br />
rxvt|rxvt terminal emulator (X Window System),<br />
am, bce, eo, km, mir, msgr, xenl, xon,<br />
colors#8, cols#80, it#8, lines#24, pairs#64,<br />
acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,<br />
bel=^G, blink=\E[5m, bold=\E[1m,<br />
civis=\E[?25l,<br />
clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M,<br />
&hellip;</p>

<p>reset<br />
重置终端参数并且清除屏幕. 与 clear 命令一样, 光标和提示符将会重新出现在终端的<br />
左上角.</p>

<p>clear<br />
clear 命令只不过是简单的清除控制台或者 xterm 的屏幕. 光标和提示符将会重新出现<br />
在屏幕或者 xterm window 的左上角. 这个命令既可以用在命令行中也可以用在脚本中.<br />
参见 Example 10-25.</p>

<p>script<br />
这个工具将会记录(保存到一个文件中)所有的用户在控制台下的或在 xterm window下的<br />
按键信息. 这其实就是创建了一个会话记录.</p>

<p>12.8 数学计算命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
&ldquo;Doing the numbers&rdquo;</p>

<p>factor<br />
将一个正数分解为多个素数.</p>

<p>bash$ factor 27417<br />
27417: 3 13 19 37</p>

<p>bc<br />
Bash 不能处理浮点运算, 并且缺乏特定的一些操作,这些操作都是一些重要的计算功能.<br />
幸运的是, bc 可以解决这个问题.</p>

<p>bc 不仅仅是个多功能灵活的精确的工具, 而且它还提供许多编程语言才具备的一些方便<br />
的功能.</p>

<p>bc 比较类似于 C 语言的语法.</p>

<p>因为它是一个完整的 UNIX 工具, 所以它可以用在管道中, bc 在脚本中也是很常用的.</p>

<p>这里有一个简单的使用 bc 命令的模版可以用来在计算脚本中的变量. 用在命令替换中.</p>

<p>variable=$(echo &ldquo;OPTIONS; OPERATIONS&rdquo; | bc)</p>

<p>Example 12-42 按月偿还贷款<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # monthlypmt.sh: 计算按月偿还贷款的数量.<br />
3<br />
4<br />
5 # 这份代码是一份修改版本, 原始版本在 &ldquo;mcalc&rdquo; (贷款计算)包中,<br />
6 #+ 这个包的作者是 Jeff Schmidt 和 Mendel Cooper (本书作者).<br />
7 # <a href="http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz">http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz</a> [15k]<br />
8<br />
9 echo<br />
10 echo &ldquo;Given the principal, interest rate, and term of a mortgage,&rdquo;<br />
11 echo &ldquo;calculate the monthly payment.&rdquo;<br />
12<br />
13 bottom=1.0<br />
14<br />
15 echo<br />
16 echo -n &ldquo;Enter principal (no commas) &rdquo;<br />
17 read principal<br />
18 echo -n &ldquo;Enter interest rate (percent) &rdquo; # 如果是 12%, 那就键入 &ldquo;12&rdquo;, 别输入 &ldquo;.12&rdquo;.<br />
19 read interest_r<br />
20 echo -n &ldquo;Enter term (months) &rdquo;<br />
21 read term<br />
22<br />
23<br />
24 interest_r=$(echo &ldquo;scale=9; $interest_r/100.0&rdquo; | bc) # 转换成小数.<br />
25 # &ldquo;scale&rdquo; 指定了有效数字的个数.<br />
26<br />
27<br />
28 interest_rate=$(echo &ldquo;scale=9; $interest_r/12 + 1.0&rdquo; | bc)<br />
29<br />
30<br />
31 top=$(echo &ldquo;scale=9; $principal*$interest_rate^$term&rdquo; | bc)<br />
32<br />
33 echo; echo &ldquo;Please be patient. This may take a while.&rdquo;<br />
34<br />
35 let &ldquo;months = $term - 1&rdquo;<br />
36 # ====================================================================<br />
37 for ((x=$months; x &gt; 0; x&ndash;))<br />
38 do<br />
39 bot=$(echo &ldquo;scale=9; $interest_rate^$x&rdquo; | bc)<br />
40 bottom=$(echo &ldquo;scale=9; $bottom+$bot&rdquo; | bc)<br />
41 # bottom = $(($bottom + $bot&rdquo;))<br />
42 done<br />
43 # ====================================================================<br />
44<br />
45 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
46 # Rick Boivie 给出了一个对上边循环的修改,<br />
47 #+ 这个修改更加有效率, 将会节省大概 <sup>2</sup>&frasl;<sub>3</sub> 的时间.<br />
48<br />
49 # for ((x=1; x &lt;= $months; x++))<br />
50 # do<br />
51 # bottom=$(echo &ldquo;scale=9; $bottom * $interest_rate + 1&rdquo; | bc)<br />
52 # done<br />
53<br />
54<br />
55 # 然后他又想出了一个更加有效率的版本,<br />
56 #+ 将会节省 95% 的时间!<br />
57<br />
58 # bottom=<code>{  
59 # echo &quot;scale=9; bottom=$bottom; interest_rate=$interest_rate&quot;  
60 # for ((x=1; x &lt;= $months; x++))  
61 # do  
62 # echo 'bottom = bottom * interest_rate + 1'  
63 # done  
64 # echo 'bottom'  
65 # } | bc</code> # 在命令替换中嵌入一个 &lsquo;for 循环&rsquo;.</p>

<h2 id="66">66 #</h2>

<p>67 # On the other hand, Frank Wang suggests:<br />
68 # bottom=$(echo &ldquo;scale=9; ($interest_rate^$term-1)/($interest_rate-1)&rdquo; |
bc)<br />
69<br />
70 # 因为 &hellip;<br />
71 # 在循环后边的算法<br />
72 #+ 事实上是一个等比数列的求和公式.<br />
73 # 求和公式是 e0(1-q^n)/(1-q),<br />
74 #+ e0 是第一个元素 并且 q=e(n+1)/e(n)<br />
75 #+ 和 n 是元素的数量.</p>

<h2 id="76">76 #</h2>

<p>77<br />
78<br />
79 # let &ldquo;payment = $top/$bottom&rdquo;<br />
80 payment=$(echo &ldquo;scale=2; $top/$bottom&rdquo; | bc)<br />
81 # 使用2位有效数字来表示美元和美分.<br />
82<br />
83 echo<br />
84 echo &ldquo;monthly payment = \$$payment&rdquo; # 在总和的前边显示美元符号.<br />
85 echo<br />
86<br />
87<br />
88 exit 0<br />
89<br />
90<br />
91 # 练习:<br />
92 # 1) 处理输入允许本金总数中的逗号.<br />
93 # 2) 处理输入允许按照百分号和小数点的形式输入利率.<br />
94 # 3) 如果你真正想好好编写这个脚本,<br />
95 # 那么就扩展这个脚本让它能够打印出完整的分期付款表.<br />
################################End
Script#########################################</p>

<p>Example 12-43 数制转换<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 ##########################################################################<br />
3 # 脚本 : base.sh - 用不同的数值来打印数字 (Bourne Shell)<br />
4 # 作者 : Heiner Steven (heiner.steven@odn.de)<br />
5 # 日期 : 07-03-95<br />
6 # 类型 : 桌面<br />
7 # $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $<br />
8 # ==&gt; 上边这行是 RCS ID 信息.<br />
9 ##########################################################################<br />
10 # 描述<br />
11 #<br />
12 # Changes<br />
13 # 21-03-95 stv fixed error occuring with 0xb as input (0.2)<br />
14 ##########################################################################<br />
15<br />
16 # ==&gt; 在本书中使用这个脚本通过了作者的授权.<br />
17 # ==&gt; 注释是本书作者添加的.<br />
18<br />
19 NOARGS=65<br />
20 PN=<code>basename &quot;$0&quot;</code> # 程序名<br />
21 VER=<code>echo '$Revision: 1.2 $' | cut -d' ' -f2</code> # ==&gt; VER=1.2<br />
22<br />
23 Usage () {<br />
24 echo &ldquo;$PN - print number to different bases, $VER (stv &lsquo;95)<br />
25 usage: $PN [number &hellip;]<br />
26<br />
27 If no number is given, the numbers are read from standard input.<br />
28 A number may be<br />
29 binary (base 2) starting with 0b (i.e. 0b1100)<br />
30 octal (base 8) starting with 0 (i.e. 014)<br />
31 hexadecimal (base 16) starting with 0x (i.e. 0xc)<br />
32 decimal otherwise (i.e. 12)&rdquo; &gt;&amp;2<br />
33 exit $NOARGS<br />
34 } # ==&gt; 打印出用法信息的函数.<br />
35<br />
36 Msg () {<br />
37 for i # ==&gt; 省略 [list] .<br />
38 do echo &ldquo;$PN: $i&rdquo; &gt;&amp;2<br />
39 done<br />
40 }<br />
41<br />
42 Fatal () { Msg &ldquo;$@&rdquo;; exit 66; }<br />
43<br />
44 PrintBases () {<br />
45 # 决定数值的数制<br />
46 for i # ==&gt; 省略 [list]&hellip;<br />
47 do # ==&gt; 所以是对命令行参数进行操作.<br />
48 case &ldquo;$i&rdquo; in<br />
49 0b<em>) ibase=2;; # 2进制<br />
50 0x</em>|[a-f]<em>|[A-F]</em>) ibase=16;; # 16进制<br />
51 0<em>) ibase=8;; # 8进制<br />
52 [1-9]</em>) ibase=10;; # 10进制<br />
53 <em>)<br />
54 Msg &ldquo;illegal number $i - ignored&rdquo;<br />
55 continue;;<br />
56 esac<br />
57<br />
58 # 去掉前缀, 将16进制数字转换为大写(bc需要大写)<br />
59 number=<code>echo &quot;$i&quot; | sed -e 's:^0[bBxX]::' | tr '[a-f]' '[A-F]'</code><br />
60 # ==&gt;使用&rdquo;:&rdquo; 作为sed分隔符, 而不使用&rdquo;/&ldquo;.<br />
61<br />
62 # 将数字转换为10进制<br />
63 dec=<code>echo &quot;ibase=$ibase; $number&quot; | bc</code> # ==&gt; &lsquo;bc&rsquo; 是个计算工具.<br />
64 case &ldquo;$dec&rdquo; in<br />
65 [0-9]</em>) ;; # 数字没问题<br />
66 <em>) continue;; # 错误: 忽略<br />
67 esac<br />
68<br />
69 # 在一行上打印所有的转换后的数字.<br />
70 # ==&gt; &lsquo;here document&rsquo; 提供命令列表给&rsquo;bc&rsquo;.<br />
71 echo <code>bc &lt; 72 obase=16; &quot;hex=&quot;; $dec  
73 obase=10; &quot;dec=&quot;; $dec  
74 obase=8; &quot;oct=&quot;; $dec  
75 obase=2; &quot;bin=&quot;; $dec  
76 !  
77</code> | sed -e &rsquo;s: : :g&rsquo;<br />
78<br />
79 done<br />
80 }<br />
81<br />
82 while [ $# -gt 0 ]<br />
83 # ==&gt; 这里必须使用一个 &ldquo;while 循环&rdquo;,<br />
84 # ==&gt;+ 因为所有的 case 都可能退出循环或者<br />
85 # ==&gt;+ 结束脚本.<br />
86 # ==&gt; (感谢, Paulo Marcel Coelho Aragao.)<br />
87 do<br />
88 case &ldquo;$1&rdquo; in<br />
89 &ndash;) shift; break;;<br />
90 -h) Usage;; # ==&gt; 帮助信息.<br />
91 -</em>) Usage;;<br />
92 *) break;; # 第一个数字<br />
93 esac # ==&gt; 对于非法输入更严格检查是非常有用的.<br />
94 shift<br />
95 done<br />
96<br />
97 if [ $# -gt 0 ]<br />
98 then<br />
99 PrintBases &ldquo;$@&rdquo;<br />
100 else # 从标准输入中读取<br />
101 while read line<br />
102 do<br />
103 PrintBases $line<br />
104 done<br />
105 fi<br />
106<br />
107<br />
108 exit 0<br />
################################End
Script#########################################<br />
调用 bc 的另一种可选的方法就是使用 here document ,并把它嵌入到 命令替换 块中.<br />
当一个脚本需要将一个选项列表和多个命令传递到 bc 中时, 这种方法就显得非常合适.</p>

<p>1 variable=<code>bc &lt;&lt; LIMIT_STRING  
2 options  
3 statements  
4 operations  
5 LIMIT_STRING  
6</code><br />
7<br />
8 &hellip;or&hellip;<br />
9<br />
10<br />
11 variable=$(bc &lt;&lt; LIMIT_STRING<br />
12 options<br />
13 statements<br />
14 operations<br />
15 LIMIT_STRING<br />
16 )</p>

<p>Example 12-44 使用 &ldquo;here document&rdquo; 来调用 bc<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 使用命令替换来调用 &lsquo;bc&rsquo;<br />
3 # 并与 &lsquo;here document&rsquo; 相结合.<br />
4<br />
5<br />
6 var1=<code>bc &lt;&lt; EOF  
7 18.33 * 19.78  
8 EOF  
9</code><br />
10 echo $var1 # 362.56<br />
11<br />
12<br />
13 # $( &hellip; ) 这种标记法也可以.<br />
14 v1=23.53<br />
15 v2=17.881<br />
16 v3=83.501<br />
17 v4=171.63<br />
18<br />
19 var2=$(bc &lt;&lt; EOF<br />
20 scale = 4<br />
21 a = ( $v1 + $v2 )<br />
22 b = ( $v3 * $v4 )<br />
23 a * b + 15.35<br />
24 EOF<br />
25 )<br />
26 echo $var2 # 593487.8452<br />
27<br />
28<br />
29 var3=$(bc -l &lt;&lt; EOF<br />
30 scale = 9<br />
31 s ( 1.7 )<br />
32 EOF<br />
33 )<br />
34 # 返回弧度为1.7的正弦.<br />
35 # &ldquo;-l&rdquo; 选项将会调用 &lsquo;bc&rsquo; 算数库.<br />
36 echo $var3 # .991664810<br />
37<br />
38<br />
39 # 现在, 在函数中试一下&hellip;<br />
40 hyp= # 声明全局变量.<br />
41 hypotenuse () # 计算直角三角形的斜边.<br />
42 {<br />
43 hyp=$(bc -l &lt;&lt; EOF<br />
44 scale = 9<br />
45 sqrt ( $1 * $1 + $2 * $2 )<br />
46 EOF<br />
47 )<br />
48 # 不幸的是, 不能从bash 函数中返回浮点值.<br />
49 }<br />
50<br />
51 hypotenuse 3.68 7.31<br />
52 echo &ldquo;hypotenuse = $hyp&rdquo; # 8.184039344<br />
53<br />
54<br />
55 exit 0<br />
################################End
Script#########################################</p>

<p>Example 12-45 计算圆周率<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # cannon.sh: 通过开炮来取得近似的圆周率值.<br />
3<br />
4 # 这事实上是一个&rdquo;Monte Carlo&rdquo;蒙特卡洛模拟的非常简单的实例:<br />
5 #+ 蒙特卡洛模拟是一种由现实事件抽象出来的数学模型,<br />
6 #+ 由于要使用随机抽样统计来估算数学函数, 所以使用伪随机数来模拟真正的随机.<br />
7<br />
8 # 想象有一个完美的正方形土地, 边长为10000个单位.<br />
9 # 在这块土地的中间有一个完美的圆形湖,<br />
10 #+ 这个湖的直径是10000个单位.<br />
11 # 这块土地的绝大多数面积都是水, 当然只有4个角上有一些土地.<br />
12 # (可以把这个湖想象成为使这个正方形的内接圆.)<br />
13 #<br />
14 # 我们将使用老式的大炮和铁炮弹<br />
15 #+ 向这块正方形的土地上开炮.<br />
16 # 所有的炮弹都会击中这块正方形土地的某个地方.<br />
17 #+ 或者是打到湖上, 或者是打到4个角的土地上.<br />
18 # 因为这个湖占据了这个区域大部分地方,<br />
19 #+ 所以大部分的炮弹都会&rdquo;扑通&rdquo;一声落到水里.<br />
20 # 而只有很少的炮弹会&rdquo;砰&rdquo;的一声落到4个<br />
21 #+ 角的土地上.<br />
22 #<br />
23 # 如果我们发出的炮弹足够随机的落到这块正方形区域中的话,<br />
24 #+ 那么落到水里的炮弹与打出炮弹的总数的比率,<br />
25 #+ 大概非常接近于 PI/4.<br />
26 #<br />
27 # 原因是所有的炮弹事实上都<br />
28 #+ 打在了这个土地的右上角,<br />
29 #+ 也就是, 笛卡尔坐标系的第一象限.<br />
30 # (之前的解释只是一个简化.)<br />
31 #<br />
32 # 理论上来说, 如果打出的炮弹越多, 就越接近这个数字.<br />
33 # 然而, 对于shell 脚本来说一定会作些让步的,<br />
34 #+ 因为它肯定不能和那些内建就支持浮点运算的编译语言相比.<br />
35 # 当然就会降低精度.<br />
36<br />
37<br />
38 DIMENSION=10000 # 这块土地的边长.<br />
39 # 这也是所产生的随机整数的上限.<br />
40<br />
41 MAXSHOTS=1000 # 开炮次数.<br />
42 # 10000 或更多次的话, 效果应该更好, 但有点太浪费时间了.<br />
43 PMULTIPLIER=4.0 # 接近于 PI 的比例因子.<br />
44<br />
45 get_random ()<br />
46 {<br />
47 SEED=$(head -1 /dev/urandom | od -N 1 | awk &lsquo;{ print $2 }&rsquo;)<br />
48 RANDOM=$SEED # 来自于 &ldquo;seeding-random.sh&rdquo;<br />
49 #+ 的例子脚本.<br />
50 let &ldquo;rnum = $RANDOM % $DIMENSION&rdquo; # 范围小于 10000.<br />
51 echo $rnum<br />
52 }<br />
53<br />
54 distance= # 声明全局变量.<br />
55 hypotenuse () # 从 &ldquo;alt-bc.sh&rdquo; 例子来的,<br />
56 { # 计算直角三角形的斜边的函数.<br />
57 distance=$(bc -l &lt;&lt; EOF<br />
58 scale = 0<br />
59 sqrt ( $1 * $1 + $2 * $2 )<br />
60 EOF<br />
61 )<br />
62 # 设置 &ldquo;scale&rdquo; 为 0 , 好让结果四舍五入为整数值,<br />
63 #+ 这是这个脚本中必须折中的一个地方.<br />
64 # 不幸的是, 这将降低模拟的精度.<br />
65 }<br />
66<br />
67<br />
68 # main() {<br />
69<br />
70 # 初始化变量.<br />
71 shots=0<br />
72 splashes=0<br />
73 thuds=0<br />
74 Pi=0<br />
75<br />
76 while [ &ldquo;$shots&rdquo; -lt &ldquo;$MAXSHOTS&rdquo; ] # 主循环.<br />
77 do<br />
78<br />
79 xCoord=$(get_random) # 取得随机的 X 与 Y 坐标.<br />
80 yCoord=$(get_random)<br />
81 hypotenuse $xCoord $yCoord # 直角三角形斜边 =<br />
82 #+ distance.<br />
83 ((shots++))<br />
84<br />
85 printf &ldquo;#%4d &rdquo; $shots<br />
86 printf &ldquo;Xc = %4d &rdquo; $xCoord<br />
87 printf &ldquo;Yc = %4d &rdquo; $yCoord<br />
88 printf &ldquo;Distance = %5d &rdquo; $distance # 到湖中心的<br />
89 #+ 距离 &ndash;<br />
90 # 起始坐标点 &ndash;<br />
91 #+ (0,0).<br />
92<br />
93 if [ &ldquo;$distance&rdquo; -le &ldquo;$DIMENSION&rdquo; ]<br />
94 then<br />
95 echo -n &ldquo;SPLASH! &rdquo;<br />
96 ((splashes++))<br />
97 else<br />
98 echo -n &ldquo;THUD! &rdquo;<br />
99 ((thuds++))<br />
100 fi<br />
101<br />
102 Pi=$(echo &ldquo;scale=9; $PMULTIPLIER*$splashes/$shots&rdquo; | bc)<br />
103 # 将比例乘以 4.0.<br />
104 echo -n &ldquo;PI ~ $Pi&rdquo;<br />
105 echo<br />
106<br />
107 done<br />
108<br />
109 echo<br />
110 echo &ldquo;After $shots shots, PI looks like approximately $Pi.&rdquo;<br />
111 # 如果不太准的话, 那么就提高一下运行的次数&hellip;<br />
112 # 可能是由于运行错误和随机数随机程度不高造成的.<br />
113 echo<br />
114<br />
115 # }<br />
116<br />
117 exit 0<br />
118<br />
119 # 要想知道一个shell脚本到底适不适合作为<br />
120 #+ 一种需要对复杂和精度都有要求的计算应用的模拟的话.<br />
121 #<br />
122 # 一般至少需要两个判断条件.<br />
123 # 1) 作为一种概念的验证: 来显示它可以做到.<br />
124 # 2) 在使用真正的编译语言来实现一个算法之前,<br />
125 #+ 使用脚本来测试和验证这个算法.<br />
################################End
Script#########################################</p>

<p>dc<br />
dc (桌面计算器desk calculator) 工具是面向栈的并且使用 RPN (逆波兰表达式<br />
&ldquo;Reverse Polish Notation&rdquo; 又叫&rdquo;后缀表达式&rdquo;). 与 bc 命令很相像 , 但是这个工具<br />
具备好多只有编程语言才具备的能力.</p>

<p>(译者注: 正常表达式 逆波兰表达式<br />
a+b a,b,+<br />
a+(b-c) a,b,c,-,+<br />
a+(b-c)<em>d a,d,b,c,-,</em>,+<br />
)</p>

<p>绝大多数人都避免使用这个工具, 因为它需要非直觉的 RPN 输入. 但是, 它却有特定的<br />
用途.</p>

<p>Example 12-46 将10进制数字转换为16进制数字<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # hexconvert.sh: 将10进制数字转换为16进制数字<br />
3<br />
4 E_NOARGS=65 # 缺命令行参数错误.<br />
5 BASE=16 # 16进制.<br />
6<br />
7 if [ -z &ldquo;$1&rdquo; ]<br />
8 then<br />
9 echo &ldquo;Usage: $0 number&rdquo;<br />
10 exit $E_NOARGS<br />
11 # 需要一个命令行参数.<br />
12 fi<br />
13 # 练习: 添加命令行参数检查.<br />
14<br />
15<br />
16 hexcvt ()<br />
17 {<br />
18 if [ -z &ldquo;$1&rdquo; ]<br />
19 then<br />
20 echo 0<br />
21 return # 如果没有参数传递到这个函数中就 &ldquo;return&rdquo; 0.<br />
22 fi<br />
23<br />
24 echo &ldquo;&rdquo;$1&rdquo; &ldquo;$BASE&rdquo; o p&rdquo; | dc<br />
25 # &ldquo;o&rdquo; 设置输出的基数(数制).<br />
26 # &ldquo;p&rdquo; 打印栈顶.<br />
27 # 察看 dc 的 man 页来了解其他的选项.<br />
28 return<br />
29 }<br />
30<br />
31 hexcvt &ldquo;$1&rdquo;<br />
32<br />
33 exit 0<br />
################################End
Script#########################################<br />
通过仔细学习 dc 命令的 info 页, 可以更深入的理解这个复杂的命令. 但是, 有一些<br />
精通 dc巫术 的小组经常会炫耀他们使用这个强大而又晦涩难懂的工具时的一些技巧,<br />
并以此为乐.</p>

<p>bash$ echo &ldquo;16i[q]sa[ln0=aln100%Pln100/snlbx]sbA0D68736142snlbxq&rdquo; | dc&rdquo;<br />
Bash</p>

<p>Example 12-47 因子分解<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # factr.sh: 分解约数<br />
3<br />
4 MIN=2 # 如果比这个数小就不行了.<br />
5 E_NOARGS=65<br />
6 E_TOOSMALL=66<br />
7<br />
8 if [ -z $1 ]<br />
9 then<br />
10 echo &ldquo;Usage: $0 number&rdquo;<br />
11 exit $E_NOARGS<br />
12 fi<br />
13<br />
14 if [ &ldquo;$1&rdquo; -lt &ldquo;$MIN&rdquo; ]<br />
15 then<br />
16 echo &ldquo;Number to factor must be $MIN or greater.&rdquo;<br />
17 exit $E_TOOSMALL<br />
18 fi<br />
19<br />
20 # 练习: 添加类型检查 (防止非整型的参数).<br />
21<br />
22 echo &ldquo;Factors of $1:&rdquo;</p>

<h2 id="23">23 #</h2>

<p>24 echo
&ldquo;$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=1lrli2+dsi!&gt;.]ds.xd1&lt;2&rdquo; | dc</p>

<h2 id="25">25 #</h2>

<p>26 # 上边这行代码是 Michel Charpentier 编写的.<br />
27 # 在此使用经过授权 (thanks).<br />
28<br />
29 exit 0<br />
################################End
Script#########################################</p>

<p>awk<br />
在脚本中使用浮点运算的另一种方法是使用 awk 内建的数学运算函数, 可以用在shell<br />
wrapper中.</p>

<p>Example 12-48 计算直角三角形的斜边<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # hypotenuse.sh: 返回直角三角形的斜边.<br />
3 # ( 直角边长的平方和,然后对和取平方根)<br />
4<br />
5 ARGS=2 # 需要将2个直角边作为参数传递进来.<br />
6 E_BADARGS=65 # 错误的参数值.<br />
7<br />
8 if [ $# -ne &ldquo;$ARGS&rdquo; ] # 测试传递到脚本中的参数值.<br />
9 then<br />
10 echo &ldquo;Usage: <code>basename $0</code> side_1 side_2&rdquo;<br />
11 exit $E_BADARGS<br />
12 fi<br />
13<br />
14<br />
15 AWKSCRIPT=&rsquo; { printf( &ldquo;%3.7f\n&rdquo;, sqrt($1<em>$1 + $2</em>$2) ) } &lsquo;<br />
16 # 命令 / 传递给awk的参数<br />
17<br />
18<br />
19 # 现在, 将参数通过管道传递给awk.<br />
20 echo -n &ldquo;Hypotenuse of $1 and $2 = &rdquo;<br />
21 echo $1 $2 | awk &ldquo;$AWKSCRIPT&rdquo;<br />
22<br />
23 exit 0<br />
################################End
Script#########################################</p>

<p>12.9 混杂命令<br />
-&mdash;&mdash;&mdash;&mdash;<br />
一些不好归类的命令</p>

<p>jot, seq<br />
这些工具通过用户指定的范围和增量来产生一系列的整数.<br />
每个产生出来的整数一般都占一行, 但是可以使用 -s 选项来改变这种设置.</p>

<p>bash$ seq 5<br />
1<br />
2<br />
3<br />
4<br />
5</p>

<p>bash$ seq -s : 5<br />
1:2:3:4:5</p>

<p>jot 和 seq 命令都经常用在 for 循环中.</p>

<p>Example 12-49 使用 seq 来产生循环参数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 使用 &ldquo;seq&rdquo;<br />
3<br />
4 echo<br />
5<br />
6 for a in <code>seq 80</code> # 或者 for a in $( seq 80 )<br />
7 # 与 &ldquo; for a in 1 2 3 4 5 &hellip; 80 &ldquo;相同 (少敲了好多字!).<br />
8 # 也可以使用 &lsquo;jot&rsquo; (如果系统上有的话).<br />
9 do<br />
10 echo -n &ldquo;$a &rdquo;<br />
11 done # 1 2 3 4 5 &hellip; 80<br />
12 # 这也是一个通过使用命令的输出<br />
13 # 来产生 &ldquo;for&rdquo;循环中 [list] 列表的例子.<br />
14<br />
15 echo; echo<br />
16<br />
17<br />
18 COUNT=80 # 当然, &lsquo;seq&rsquo; 也可以使用一个可替换的参数.<br />
19<br />
20 for a in <code>seq $COUNT</code> # 或者 for a in $( seq $COUNT )<br />
21 do<br />
22 echo -n &ldquo;$a &rdquo;<br />
23 done # 1 2 3 4 5 &hellip; 80<br />
24<br />
25 echo; echo<br />
26<br />
27 BEGIN=75<br />
28 END=80<br />
29<br />
30 for a in <code>seq $BEGIN $END</code><br />
31 # 传给 &ldquo;seq&rdquo; 两个参数, 从第一个参数开始增长,<br />
32 #+ 一直增长到第二个参数为止.<br />
33 do<br />
34 echo -n &ldquo;$a &rdquo;<br />
35 done # 75 76 77 78 79 80<br />
36<br />
37 echo; echo<br />
38<br />
39 BEGIN=45<br />
40 INTERVAL=5<br />
41 END=80<br />
42<br />
43 for a in <code>seq $BEGIN $INTERVAL $END</code><br />
44 # 传给 &ldquo;seq&rdquo; 三个参数从第一个参数开始增长,<br />
45 #+ 并以第二个参数作为增量,<br />
46 #+ 一直增长到第三个参数为止.<br />
47 do<br />
48 echo -n &ldquo;$a &rdquo;<br />
49 done # 45 50 55 60 65 70 75 80<br />
50<br />
51 echo; echo<br />
52<br />
53 exit 0<br />
################################End
Script#########################################</p>

<p>一个简单些的例子:<br />
1 # 产生10个连续扩展名的文件,<br />
2 #+ 名字分别是 file.1, file.2 &hellip; file.10.<br />
3 COUNT=10<br />
4 PREFIX=file<br />
5<br />
6 for filename in <code>seq $COUNT</code><br />
7 do<br />
8 touch $PREFIX.$filename<br />
9 # 或者, 你可以做一些其他的操作,<br />
10 #+ 比如 rm, grep, 等等.<br />
11 done</p>

<p>Example 12-50 字母统计<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # letter-count.sh: 统计一个文本文件中字母出现的次数.<br />
3 # 由 Stefano Palmeri 编写.<br />
4 # 经过授权使用在本书中.<br />
5 # 本书作者做了少许修改.<br />
6<br />
7 MINARGS=2 # 本脚本至少需要2个参数.<br />
8 E_BADARGS=65<br />
9 FILE=$1<br />
10<br />
11 let LETTERS=$#-1 # 制定了多少个字母 (作为命令行参数).<br />
12 # (从命令行参数的个数中减1.)<br />
13<br />
14<br />
15 show_help(){<br />
16 echo<br />
17 echo Usage: <code>basename $0</code> file letters<br />
18 echo Note: <code>basename $0</code> arguments are case sensitive.<br />
19 echo Example: <code>basename $0</code> foobar.txt G n U L i N U x.<br />
20 echo<br />
21 }<br />
22<br />
23 # 检查参数个数.<br />
24 if [ $# -lt $MINARGS ]; then<br />
25 echo<br />
26 echo &ldquo;Not enough arguments.&rdquo;<br />
27 echo<br />
28 show_help<br />
29 exit $E_BADARGS<br />
30 fi<br />
31<br />
32<br />
33 # 检查文件是否存在.<br />
34 if [ ! -f $FILE ]; then<br />
35 echo &ldquo;File \&ldquo;$FILE\&rdquo; does not exist.&rdquo;<br />
36 exit $E_BADARGS<br />
37 fi<br />
38<br />
39<br />
40<br />
41 # 统计字母出现的次数.<br />
42 for n in <code>seq $LETTERS</code>; do<br />
43 shift<br />
44 if [[ <code>echo -n &quot;$1&quot; | wc -c</code> -eq 1 ]]; then # 检查参数.<br />
45 echo &ldquo;$1&rdquo; -&gt; <code>cat $FILE | tr -cd &quot;$1&quot; | wc -c</code> # 统计.<br />
46 else<br />
47 echo &ldquo;$1 is not a single char.&rdquo;<br />
48 fi<br />
49 done<br />
50<br />
51 exit $?<br />
52<br />
53 # 这个脚本在功能上与 letter-count2.sh 完全相同,<br />
54 #+ 但是运行得更快.<br />
55 # 为什么?<br />
################################End
Script#########################################</p>

<p>getopt<br />
getopt 命令将会分析以破折号开头的命令行选项. 这个外部命令与Bash的内建命令<br />
getopts 作用相同. 通过使用 -l 标志, getopt 可以处理长(多字符)选项, 并且也允许参<br />
数重置.</p>

<p>Example 12-51 使用getopt来分析命令行选项<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 使用 getopt.<br />
3<br />
4 # 尝试使用下边的不同的方法来调用这脚本:<br />
5 # sh ex33a.sh -a<br />
6 # sh ex33a.sh -abc<br />
7 # sh ex33a.sh -a -b -c<br />
8 # sh ex33a.sh -d<br />
9 # sh ex33a.sh -dXYZ<br />
10 # sh ex33a.sh -d XYZ<br />
11 # sh ex33a.sh -abcd<br />
12 # sh ex33a.sh -abcdZ<br />
13 # sh ex33a.sh -z<br />
14 # sh ex33a.sh a<br />
15 # 解释上面每一次调用的结果.<br />
16<br />
17 E_OPTERR=65<br />
18<br />
19 if [ &ldquo;$#&rdquo; -eq 0 ]<br />
20 then # 脚本需要至少一个命令行参数.<br />
21 echo &ldquo;Usage $0 -[options a,b,c]&rdquo;<br />
22 exit $E_OPTERR<br />
23 fi<br />
24<br />
25 set &ndash; <code>getopt &quot;abcd:&quot; &quot;$@&quot;</code><br />
26 # 为命令行参数设置位置参数.<br />
27 # 如果使用 &ldquo;$*&rdquo; 来代替 &ldquo;$@&rdquo; 的话会发生什么?<br />
28<br />
29 while [ ! -z &ldquo;$1&rdquo; ]<br />
30 do<br />
31 case &ldquo;$1&rdquo; in<br />
32 -a) echo &ldquo;Option \&ldquo;a\&ldquo;&rdquo;;;<br />
33 -b) echo &ldquo;Option \&ldquo;b\&ldquo;&rdquo;;;<br />
34 -c) echo &ldquo;Option \&ldquo;c\&ldquo;&rdquo;;;<br />
35 -d) echo &ldquo;Option \&ldquo;d\&rdquo; $2&rdquo;;;<br />
36 *) break;;<br />
37 esac<br />
38<br />
39 shift<br />
40 done<br />
41<br />
42 # 通常来说在脚本中使用内建的 &lsquo;getopts&rsquo; 命令,<br />
43 #+ 会比使用 &lsquo;getopt&rsquo; 好一些.<br />
44 # 参见 &ldquo;ex33.sh&rdquo;.<br />
45<br />
46 exit 0<br />
################################End
Script#########################################<br />
参见 Example 9-12 , 这是对 getopt 命令的一个简单模拟.</p>

<p>run-parts<br />
run-parts 命令 [1] 将会执行目标目录中所有的脚本, 这些将本会以 ASCII 的循序进行<br />
排列. 当然, 这些脚本都需要具有可执行权限.</p>

<p>cron 幽灵进程 会调用 run-parts 来运行 /etc/cron.* 下的所有脚本.</p>

<p>yes<br />
yes 命令的默认行为是向 stdout 中连续不断的输出字符 y,每个y占一行.使用control-c<br />
来结束运行. 如果想换一个输出字符的话, 可以使用 yes 其他的字符串, 这样就会连续<br />
不同的输出你指定的字符串. 那么这样的命令究竟能做什么呢? 在命令行或者脚本中,<br />
yes的输出可以通过重定向或管道来传递给一些需要用户输入进行交互的命令. 事实上,<br />
这个命令可以说是 expect 命令(译者注: 这个命令本书未介绍, 一个自动实现交互的命<br />
令)的一个简化版本.</p>

<p>yes | fsck /dev/hda1 将会以非交互的形式运行fsck(因为需要用户输入的 y 全由yes<br />
命令搞定了)(小心使用!).</p>

<p>yes | rm -r dirname 与 rm -rf dirname 效果相同(小心使用!).</p>

<p>注意: 当用 yes 的管道形式来使用一些可能具有潜在危险的系统命令的时候一定要深思<br />
熟虑, 比如 fsck 或 fdisk. 可能会产生一些意外的副作用.</p>

<p>banner<br />
将会把字符串用一个 ASCII 字符(默认是 &lsquo;#&rsquo;)来画出来(就是将多个&rsquo;#&lsquo;拼出一副字符的<br />
图形).可以作为硬拷贝重定向到打印机上(译者注: 可以使用-w 选项设置宽度).</p>

<p>printenv<br />
对于某个特定的用户, 显示出所有的 环境变量.</p>

<p>bash$ printenv | grep HOME<br />
HOME=/home/bozo</p>

<p>lp<br />
lp 和 lpr 命令将会把文件发送到打印队列中, 并且作为硬拷贝来打印. [2] 这些命令<br />
会纪录它们名字的起始位置并传递到行打印机的另一个位置.</p>

<p>bash$ lp file1.txt 或者 bash lp</p>

<p>通常情况下都是将pr的格式化的输出传递到 lp.</p>

<p>bash$ pr -options file1.txt | lp</p>

<p>格式化的包, 比如 groff 和 Ghostscript 就可以将它们的输出直接发送给 lp.</p>

<p>bash$ groff -Tascii file.tr | lp</p>

<p>bash$ gs -options | lp file.ps</p>

<p>还有一些相关的命令, 比如 lpq, 可以查看打印队列, lprm, 可以用来从打印队列中删<br />
除作业.</p>

<p>tee<br />
[UNIX 从管道行业借来的主意.]</p>

<p>这是一个重定向操作, 但是有些不同. 就像管道中的&rdquo;三通&rdquo;一样, 这个命令可以将命令或<br />
者管道命令的输出抽出到一个文件中,而且并不影响结果. 当你想将一个正在运行的进程<br />
的输出保存到文件中时, 或者为了debug而保存输出记录的时候, 这个命令就非常有用了.</p>

<p>(重定向)<br />
|&mdash;-&gt; to file<br />
|<br />
==========================|====================</p>

<h1 id="command-command-tee-command-output-of-pipe">command &mdash;&gt; command &mdash;&gt; |tee &mdash;&gt; command &mdash;&gt; -&ndash;&gt; output of pipe</h1>

<p>1 cat listfile* | sort | tee check.file | uniq &gt; result.file<br />
(在对排序的结果进行 uniq (去掉重复行) 之前,文件 check.file 中保存了排过序的<br />
&ldquo;listfiles&rdquo;.)</p>

<p>mkfifo<br />
这个不大引人注意的命令可以创建一个命名管道, 并产生一个临时的先进先出的buffer<br />
用来在两个进程间传输数据. [3] 典型的使用是一个进程向FIFO中写数据, 另一个进程读<br />
出来. 参见 Example A-15.</p>

<p>pathchk<br />
这个命令用来检查文件名的有效性. 如果文件名超过了最大允许长度(255 个字符), 或者<br />
它所在的一个或多个路径搜索不到, 那么就会产生一个错误结果.</p>

<p>不幸的是,并不能够返回一个可识别的错误码, 因此它在脚本中几乎没有什么用. 一般都<br />
使用文件测试操作.</p>

<p>dd<br />
这也是一个不太出名的工具, 但却是一个令人恐惧的 &ldquo;数据复制&rdquo; 命令. 最开始, 这个命<br />
令是被用来在UNIX 微机和IBM大型机之间通过磁带来交换数据, 这个命令现在仍然有它的<br />
用途. dd 命令只不过是简单的拷贝一个文件 (或者 stdin/stdout), 但是它会做一些转<br />
换. 下边是一些可能的转换, 比如 ASCII/EBCDIC, [4] 大写/小写, 在输入和输出之间<br />
的字节对的交换, 还有对输入文件做一些截头去尾的工作. dd &ndash;help 列出了所有转换,<br />
还有这个强力工具的一些其他选项.</p>

<p>1 # 将一个文件转换为大写:<br />
2<br />
3 dd if=$filename conv=ucase &gt; $filename.uppercase<br />
4 # lcase # 转换为小写</p>

<p>Example 12-52 一个拷贝自身的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # self-copy.sh<br />
3<br />
4 # 这个脚本将会拷贝自身.<br />
5<br />
6 file_subscript=copy<br />
7<br />
8 dd if=$0 of=$0.$file_subscript 2&gt;/dev/null<br />
9 # 阻止dd产生的消息: ^^^^^^^^^^^<br />
10<br />
11 exit $?<br />
################################End
Script#########################################</p>

<p>Example 12-53 练习dd<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # exercising-dd.sh<br />
3<br />
4 # 由Stephane Chazelas编写.<br />
5 # 本文作者做了少量修改.<br />
6<br />
7 input_file=$0 # 脚本本身.<br />
8 output_file=log.txt<br />
9 n=3<br />
10 p=5<br />
11<br />
12 dd if=$input_file of=$output_file bs=1 skip=$((n-1)) count=$((p-n+1)) 2&gt;
/dev/null<br />
13 # 从脚本中把位置n到p的字符提取出来.<br />
14<br />
15 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
16<br />
17 echo -n &ldquo;hello world&rdquo; | dd cbs=1 conv=unblock 2&gt; /dev/null<br />
18 # 垂直的 echo &ldquo;hello world&rdquo; .<br />
19<br />
20 exit 0<br />
################################End
Script#########################################<br />
为了展示dd的多种用途, 让我们使用它来记录按键.</p>

<p>Example 12-54 记录按键<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # dd-keypress.sh: 记录按键, 不需要按回车.<br />
3<br />
4<br />
5 keypresses=4 # 记录按键的个数.<br />
6<br />
7<br />
8 old_tty_setting=$(stty -g) # 保存老的终端设置.<br />
9<br />
10 echo &ldquo;Press $keypresses keys.&rdquo;<br />
11 stty -icanon -echo # 禁用标准模式.<br />
12 # 禁用本地 echo.<br />
13 keys=$(dd bs=1 count=$keypresses 2&gt; /dev/null)<br />
14 # 如果不指定输入文件的话, &lsquo;dd&rsquo; 使用标准输入.<br />
15<br />
16 stty &ldquo;$old_tty_setting&rdquo; # 恢复老的终端设置.<br />
17<br />
18 echo &ldquo;You pressed the \&ldquo;$keys\&rdquo; keys.&rdquo;<br />
19<br />
20 # 感谢 Stephane Chazelas, 演示了这种方法.<br />
21 exit 0<br />
################################End
Script#########################################<br />
dd 命令可以在数据流上做随即存取.</p>

<p>1 echo -n . | dd bs=1 seek=4 of=file conv=notrunc<br />
2 # &ldquo;conv=notrunc&rdquo; 选项意味着输出文件不能被截短.<br />
3<br />
4 # Thanks, S.C.</p>

<p>dd 命令可以将数据或磁盘镜像拷贝到设备中, 也可以从设备中拷贝数据或磁盘镜像, 比<br />
如说磁盘或磁带设备都可以 (Example A-5). 通常用来创建启动盘.</p>

<p>dd if=kernel-image of=/dev/fd0H1440</p>

<p>同样的, dd 可以拷贝软盘的整个内容(甚至是其他操作系统的磁盘格式) 到硬盘驱动器上<br />
(以镜像文件的形式).</p>

<p>dd if=/dev/fd0 of=/home/bozo/projects/floppy.img</p>

<p>dd 命令还有一些其他用途, 包括可以初始化临时交换文件 (Example 28-2) 和 ramdisks<br />
(内存虚拟硬盘) (Example 28-3). 它甚至可以做一些对整个硬盘分区的底层拷贝, 虽然<br />
不建议这么做.</p>

<p>一些(可能是比较无聊的)人总会想一些关于 dd 命令的有趣的应用.</p>

<p>Example 12-55 安全的删除一个文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # blot-out.sh: 删除一个文件所有的记录.<br />
3<br />
4 # 这个脚本会使用随即字节交替的覆盖<br />
5 #+ 目标文件, 并且在最终删除这个文件之前清零.<br />
6 # 这么做之后, 即使你通过传统手段来检查磁盘扇区<br />
7 #+ 也不能把文件原始数据重新恢复.<br />
8<br />
9 PASSES=7 # 破坏文件的次数.<br />
10 # 提高这个数字会减慢脚本运行的速度,<br />
11 #+ 尤其是对尺寸比较大的目标文件进行操作的时候.<br />
12 BLOCKSIZE=1 # 带有 /dev/urandom 的 I/O 需要单位块尺寸,<br />
13 #+ 否则你可能会获得奇怪的结果.<br />
14 E_BADARGS=70 # 不同的错误退出码.<br />
15 E_NOT_FOUND=71<br />
16 E_CHANGED_MIND=72<br />
17<br />
18 if [ -z &ldquo;$1&rdquo; ] # 没指定文件名.<br />
19 then<br />
20 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
21 exit $E_BADARGS<br />
22 fi<br />
23<br />
24 file=$1<br />
25<br />
26 if [ ! -e &ldquo;$file&rdquo; ]<br />
27 then<br />
28 echo &ldquo;File \&ldquo;$file\&rdquo; not found.&rdquo;<br />
29 exit $E_NOT_FOUND<br />
30 fi<br />
31<br />
32 echo; echo -n &ldquo;Are you absolutely sure you want to blot out \&ldquo;$file\&rdquo;
(y/n)? &ldquo;<br />
33 read answer<br />
34 case &ldquo;$answer&rdquo; in<br />
35 [nN]) echo &ldquo;Changed your mind, huh?&rdquo;<br />
36 exit $E_CHANGED_MIND<br />
37 ;;<br />
38 *) echo &ldquo;Blotting out file \&ldquo;$file\&ldquo;.&rdquo;;;<br />
39 esac<br />
40<br />
41<br />
42 flength=$(ls -l &ldquo;$file&rdquo; | awk &lsquo;{print $5}&rsquo;) # 5 是文件长度.<br />
43 pass_count=1<br />
44<br />
45 chmod u+w &ldquo;$file&rdquo; # Allow overwriting/deleting the file.<br />
46<br />
47 echo<br />
48<br />
49 while [ &ldquo;$pass_count&rdquo; -le &ldquo;$PASSES&rdquo; ]<br />
50 do<br />
51 echo &ldquo;Pass #$pass_count&rdquo;<br />
52 sync # 刷新buffer.<br />
53 dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength<br />
54 # 使用随机字节进行填充.<br />
55 sync # 再刷新buffer.<br />
56 dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength<br />
57 # 用0填充.<br />
58 sync # 再刷新buffer.<br />
59 let &ldquo;pass_count += 1&rdquo;<br />
60 echo<br />
61 done<br />
62<br />
63<br />
64 rm -f $file # 最后, 删除这个已经被破坏得不成样子的文件.<br />
65 sync # 最后一次刷新buffer.<br />
66<br />
67 echo &ldquo;File \&ldquo;$file\&rdquo; blotted out and deleted.&ldquo;; echo<br />
68<br />
69<br />
70 exit 0<br />
71<br />
72 # 这是一种真正安全的删除文件的办法,<br />
73 #+ 但是效率比较低, 运行比较慢.<br />
74 # GNU 的文件工具包中的 &ldquo;shred&rdquo; 命令,<br />
75 #+ 也可以完成相同的工作, 不过更有效率.<br />
76<br />
77 # 使用普通的方法是不可能重新恢复这个文件了.<br />
78 # 然而 &hellip;<br />
79 #+ 这个简单的例子是不能够抵抗<br />
80 #+ 那些经验丰富并且正规的分析.<br />
81<br />
82 # 这个脚本可能不会很好的运行在日志文件系统上.(译者注: JFS)<br />
83 # 练习 (很难): 像它做的那样修正这个问题.<br />
84<br />
85<br />
86<br />
87 # Tom Vier的文件删除包可以更加彻底<br />
88 #+ 的删除文件, 比这个简单的例子厉害得多.<br />
89 # <a href="http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2">http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2</a><br />
90<br />
91 # 如果想对安全删除文件这一论题进行深度的分析,<br />
92 #+ 可以参见Peter Gutmann的页面,<br />
93 #+ &ldquo;Secure Deletion of Data From Magnetic and Solid-State Memory&rdquo;.<br />
94 # <a href="http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html">http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html</a><br />
################################End
Script#########################################</p>

<p>od<br />
od(octal dump)过滤器, 将会把输入(或文件)转换为8进制或者其他进制. 在你需要查看<br />
或处理一些二进制数据文件或者一个不可读的系统设备文件的时候, 这个命令非常有用,<br />
比如/dev/urandom,或者是一个二进制数据过滤器. 参见 Example 9-28 和<br />
Example 12-13.</p>

<p>hexdump<br />
对二进制文件进行 16进制, 8进制, 10进制, 或者 ASCII 码的查阅动作. 这个命令大体<br />
上与上边的od命令作用相同, 但是远不及 od 命令有用.</p>

<p>objdump<br />
显示编译后的2进制文件或2进制可执行文件的信息, 以16进制的形式显示, 或者显示反汇<br />
编列表(使用-d选项).</p>

<p>bash$ objdump -d /bin/ls<br />
/bin/ls: file format elf32-i386</p>

<p>Disassembly of section .init:</p>

<p>080490bc &lt;.init&gt;:<br />
80490bc: 55 push %ebp<br />
80490bd: 89 e5 mov %esp,%ebp<br />
&hellip;</p>

<p>mcookie<br />
这个命令会产生一个&rdquo;magic cookie&rdquo;, 这是一个128-bit (32-字符) 的伪随机16进制数字,<br />
这个数字一般都用来作为X server的鉴权&rdquo;签名&rdquo;. 这个命令还可以用来在脚本中作为一<br />
种生成随机数的手段, 当然这是一种&rdquo;小吃店&rdquo;(虽然不太正统, 但是很方便)的风格.</p>

<p>1 random000=$(mcookie)</p>

<p>当然, 完成同样的目的还可以使用 md5 命令.<br />
1 # 产生关于脚本本身的 md5 checksum.<br />
2 random001=<code>md5sum $0 | awk '{print $1}'</code><br />
3 # 使用 &lsquo;awk&rsquo; 来去掉文件名.</p>

<p>mcookie 还给出了产生&rdquo;唯一&rdquo;文件名的另一种方法.</p>

<p>Example 12-56 文件名产生器<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # tempfile-name.sh: 临时文件名产生器<br />
3<br />
4 BASE_STR=<code>mcookie</code> # 32-字符的 magic cookie.<br />
5 POS=11 # 字符串中随便的一个位置.<br />
6 LEN=5 # 取得 $LEN 长度连续的字符串.<br />
7<br />
8 prefix=temp # 最终的一个临时文件.<br />
9 # 如果想让这个文件更加唯一,<br />
10 #+ 可以对这个前缀也使用下边的方法来生成.<br />
11<br />
12 suffix=${BASE_STR:POS:LEN}<br />
13 # 提取从第11个字符之后的长度为5的字符串.<br />
14<br />
15 temp_filename=$prefix.$suffix<br />
16 # 构造文件名.<br />
17<br />
18 echo &ldquo;Temp filename = &ldquo;$temp_filename&rdquo;&rdquo;<br />
19<br />
20 # sh tempfile-name.sh<br />
21 # Temp filename = temp.e19ea<br />
22<br />
23 # 与使用 &lsquo;date&rsquo; 命令(参考 ex51.sh)来创建唯一文件名<br />
24 #+ 的方法相比较.<br />
25<br />
26 exit 0<br />
################################End
Script#########################################</p>

<p>units<br />
这个工具用来在不同的计量单位之间互相转换. 当你在交互模式下正常调用时, 会发现在<br />
脚本中 units 也很有用.</p>

<p>Example 12-57 将米转换为英里<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # unit-conversion.sh<br />
3<br />
4<br />
5 convert_units () # 通过参数取得需要转换的单位.<br />
6 {<br />
7 cf=$(units &ldquo;$1&rdquo; &ldquo;$2&rdquo; | sed &ndash;silent -e &lsquo;1p&rsquo; | awk &lsquo;{print $2}&rsquo;)<br />
8 # 除了真正需要转换的部分保留下来外,其他的部分都去掉.<br />
9 echo &ldquo;$cf&rdquo;<br />
10 }<br />
11<br />
12 Unit1=miles<br />
13 Unit2=meters<br />
14 cfactor=<code>convert_units $Unit1 $Unit2</code><br />
15 quantity=3.73<br />
16<br />
17 result=$(echo $quantity*$cfactor | bc)<br />
18<br />
19 echo &ldquo;There are $result $Unit2 in $quantity $Unit1.&rdquo;<br />
20<br />
21 # 如果你传递了两个不匹配的单位会发生什么?<br />
22 #+ 比如分别传入英亩和英里?<br />
23<br />
24 exit 0<br />
################################End
Script#########################################</p>

<p>m4<br />
一个隐藏的财宝, m4 是一个强力的宏处理过滤器, [5] 差不多可以说是一种语言了. 虽<br />
然最开始这个工具是用来作为 RatFor 的预处理器而编写的, 但是后来证明 m4 作为独<br />
立的工具也是非常有用的. 事实上, m4 结合了许多工具的功能, 比如 eval, tr, 和 awk,<br />
除此之外, 它还使得宏扩展变得容易.</p>

<p>在 2004年4月的 Linux Journal 的问题列表中有一篇关于 m4 命令用法得非常好的文章.</p>

<p>Example 12-58 使用 m4<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # m4.sh: 使用 m4 宏处理器<br />
3<br />
4 # 字符操作<br />
5 string=abcdA01<br />
6 echo &ldquo;len($string)&rdquo; | m4 # 7<br />
7 echo &ldquo;substr($string,4)&rdquo; | m4 # A01<br />
8 echo &ldquo;regexp($string,[0-1][0-1],&amp;Z)&rdquo; | m4 # 01Z<br />
9<br />
10 # 算术操作<br />
11 echo &ldquo;incr(22)&rdquo; | m4 # 23<br />
12 echo &ldquo;eval(99 / 3)&rdquo; | m4 # 33<br />
13<br />
14 exit 0<br />
################################End
Script#########################################</p>

<p>doexec<br />
doexec 命令允许将一个随便的参数列表传递到一个二进制可执行文件中. 特别的, 甚至<br />
可以传递 arg<a href="相当于脚本中的 $0">0</a>, 这样可以使用不同的名字来调用这个可执行<br />
文件, 并且通过不同的调用的名字, 可以让这个可执行文件执行不同的动作. 这也可以<br />
说是一种将参数传递到可执行文件中的比较绕圈子的做法.</p>

<p>比如, /usr/local/bin 目录可能包含一个 &ldquo;aaa&rdquo; 的二进制文件. 使用<br />
doexec /usr/local/bin/aaa list 可以 列出 当前工作目录下所有以 &ldquo;a&rdquo; 开头的的文<br />
件, 而使用 doexec /usr/local/bin/aaa delete 将会删除这些文件.</p>

<p>注意: 可执行文件的不同行为必须定义在可执行文件自身的代码中, 可以使用如下的<br />
shell脚本作类比:<br />
1 case <code>basename $0</code> in<br />
2 &ldquo;name1&rdquo; ) do_something;;<br />
3 &ldquo;name2&rdquo; ) do_something_else;;<br />
4 &ldquo;name3&rdquo; ) do_yet_another_thing;;<br />
5 * ) bail_out;;<br />
6 esac</p>

<p>dialog<br />
dialog 工具集提供了一种从脚本中调用交互对话框的方法. dialog 的更好的变种版本是<br />
-- gdialog, Xdialog, 和 kdialog &ndash; 事实上是调用的 X-Windows 的界面工具集. 参<br />
见 Example 33-19.</p>

<p>sox<br />
sox 命令, &ldquo;sound exchange&rdquo; (声音转换)命令, 可以进行声音文件的转换. 事实上,可执<br />
行文件 /usr/bin/play (现在不建议使用) 只不过是 sox 的一个 shell 包装器而已.</p>

<p>举个例子, sox soundfile.wav soundfile.au 将会把一个 WAV 声音文件转换成一个<br />
(Sun 音频格式) AU 声音文件.</p>

<p>Shell 脚本非常适合于使用 sox 的声音操作来批处理声音文件. 比如, 参见<br />
Linux Radio Timeshift HOWTO 和 MP3do Project.</p>

<p>注意事项:<br />
[1] 这个工具事实上是从 Debian Linux 发行版中的一个脚本借鉴过来的.<br />
[2] 打印队列 就是&rdquo;在线等待&rdquo;打印的作业组.<br />
[3] 对于本话题的一个完美的介绍, 请参见 Andy Vaught 的文章, 命名管道的介绍,<br />
(<a href="http://www2.linuxjournal.com/lj-issues/issue41/2156.html">http://www2.linuxjournal.com/lj-issues/issue41/2156.html</a>), 这是<br />
Linux Journal (<a href="http://www.linuxjournal.com/)1997年9月的一个问题">http://www.linuxjournal.com/)1997年9月的一个问题</a>.<br />
[4] EBCDIC (发音是 &ldquo;ebb-sid-ick&rdquo;) 是单词 (Extended Binary Coded Decimal<br />
Interchange Code) 的首字母缩写. 这是 IBM 的数据格式, 现在已经不常见了.<br />
dd 命令的 conv=ebcdic 选项的一个比较奇异的使用方法是对一个文件进行快速而<br />
且容易但不太安全的编码.<br />
1 cat $file | dd conv=swab,ebcdic &gt; $file_encrypted<br />
2 # 编码 (看起来好像没什么用).<br />
3 # 应该交换字节(swab), 有点晦涩.<br />
4<br />
5 cat $file_encrypted | dd conv=swab,ascii &gt; $file_plaintext<br />
6 # 解码.<br />
[5] 宏 是一个符号常量, 将会被扩展成一个命令字符串或者一系列的参数操作.</p>

<h1 id="第13章-系统与管理命令">第13章 系统与管理命令</h1>

<p>在/etc/rc.d目录中的启动和关机脚本中包含了好多有用的(和没用的)这些系统管理命令. 这些<br />
命令通常总是被root用户使用, 用与系统维护或者是紧急文件系统修复.一定要小心使用这些工<br />
具, 因为如果滥用的话, 它们会损坏你的系统.</p>

<p>Users 和 Groups 类命令</p>

<p>users<br />
显示所有的登录的用户. 这个命令与 who -q 基本一致.</p>

<p>groups<br />
列出当前用户和他所属于的组. 这相当于 $GROUPS 内部变量, 但是这个命令将会给出组名<br />
字, 而不是数字.</p>

<p>bash$ groups<br />
bozita cdrom cdwriter audio xgrp</p>

<p>bash$ echo $GROUPS<br />
501</p>

<p>chown, chgrp<br />
chown 命令将会修改一个或多个文件的所有权. 对于root来说这是一种非常好的将文件的<br />
所有权从一个用户换到另一个用户的方法. 一个普通用户不能修改文件的所有权, 即使他<br />
是文件的宿主也不行. [1]</p>

<p>root# chown bozo *.txt</p>

<p>chgrp 将会修改一个或个文件党组所有权. 你必须是这些文件的宿主, 并且是目的组的成<br />
员(或者root), 这样才能使用这个操作.</p>

<p>1 chgrp &ndash;recursive dunderheads <em>.data<br />
2 # &ldquo;dunderheads&rdquo;(译者: 晕,蠢才&hellip;) 组现在拥有了所有的&rdquo;</em>.data&rdquo;文件.<br />
3 #+ 包括所有$PWD目录下的子目录中的文件(&ndash;recursive的作用就是包含子目录).</p>

<p>useradd, userdel<br />
useradd 管理命令将会在系统上添加一个用户帐号, 并且如果指定的话, 还会为特定的用<br />
户创建home目录. 相应的userdel 命令将会从系统上删除一个用户帐号, [2] 并且删除相<br />
应的文件.</p>

<p>注意: adduser命令与useradd是相同的, adduser通常都是一个符号链接.</p>

<p>usermod<br />
修改用户帐号. 可以修改密码, 组身份, 截止日期, 或者给定用户帐号的其他的属性. 使<br />
用这个命令, 用户的密码可能会被锁定, 因为密码会影响到帐号的有效性.</p>

<p>groupmod<br />
修改指定组. 组名字或者ID号都可以使用这个命令来修改.</p>

<p>id<br />
id 将会列出当前进程的真实和有效用户ID, 还有用户的组ID. 这与Bash的内部变量<br />
$UID, $EUID, 和 $GROUPS 很相像.</p>

<p>bash$ id<br />
uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</p>

<p>bash$ echo $UID<br />
501</p>

<p>注意: id 命令只有在有效ID与真实ID不符时才会显示有效id.<br />
参见 Example 9-5.</p>

<p>who<br />
显示系统上所有已经登录的用户.</p>

<p>bash$ who<br />
bozo tty1 Apr 27 17:45<br />
bozo pts/0 Apr 27 17:46<br />
bozo pts/1 Apr 27 17:47<br />
bozo pts/2 Apr 27 17:49</p>

<p>-m 选项将会只给出当前用户的详细信息. 将任意两个参数传递到who中 都等价于who -m,<br />
就像 who am i 或者 who The Man.</p>

<p>bash$ who -m<br />
localhost.localdomain!bozo pts/2 Apr 27 17:49</p>

<p>whoami 与who -m 很相似, 但是只列出用户名.</p>

<p>bash$ whoami<br />
bozo</p>

<p>w<br />
显示所有的登录的用户和属于它们的进程. 这是一个who的扩展版本. w的输出可以通过管<br />
道传递到grep中, 这样就可以查找指定的用户或进程.</p>

<p>bash$ w | grep startx<br />
bozo tty1 - 4:22pm 6:41 4.47s 0.45s startx</p>

<p>logname<br />
显示当前用户的登录名(可以在/var/run/utmp中找到). 这与上边的whoami很相近.</p>

<p>bash$ logname<br />
bozo</p>

<p>bash$ whoami<br />
bozo</p>

<p>然而&hellip;</p>

<p>bash$ su<br />
Password: &hellip;&hellip;</p>

<p>bash# whoami<br />
root<br />
bash# logname<br />
bozo</p>

<p>注意: logname只会打印出登录的用户名, 而whoami 将会给出附着到当前进程的用户名.<br />
就像我们上边看到的那样, 这两个名字有时会不同.</p>

<p>su<br />
使用一个代替的用户来运行一个程序或脚本. su rjones 将会以 rjones 来启动一个<br />
shell. 一个不加参数的su默认就是root. 参见 Example A-15.</p>

<p>sudo<br />
以root(或其他用户)的身份来运行一个命令. 这个命令可以运行在脚本中, 这样就允许以<br />
正规的用户身份来运行脚本.</p>

<p>1 #!/bin/bash<br />
2<br />
3 # 一些命令.<br />
4 sudo cp /root/secretfile /home/bozo/secret<br />
5 # 一些命令.</p>

<p>文件 /etc/sudoers 持有允许调用sudo的用户名.</p>

<p>passwd<br />
设置, 修改, 或者管理用户的密码.<br />
passwd 命令可以用在脚本中, 但可能你不想这么用.</p>

<p>Example 13-1 设置一个新密码<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # setnew-password.sh: 只用于说明目的.<br />
3 # 如果真正运行这个脚本并不是一个好主意.<br />
4 # 这个脚本必须以root身份运行.<br />
5<br />
6 ROOT_UID=0 # Root 的 $UID 0.<br />
7 E_WRONG_USER=65 # 不是 root?<br />
8<br />
9 E_NOSUCHUSER=70<br />
10 SUCCESS=0<br />
11<br />
12<br />
13 if [ &ldquo;$UID&rdquo; -ne &ldquo;$ROOT_UID&rdquo; ]<br />
14 then<br />
15 echo; echo &ldquo;Only root can run this script.&rdquo;; echo<br />
16 exit $E_WRONG_USER<br />
17 else<br />
18 echo<br />
19 echo &ldquo;You should know better than to run this script, root.&rdquo;<br />
20 echo &ldquo;Even root users get the blues&hellip; &rdquo;<br />
21 echo<br />
22 fi<br />
23<br />
24<br />
25 username=bozo<br />
26 NEWPASSWORD=security_violation<br />
27<br />
28 # 检查bozo是否在这里.<br />
29 grep -q &ldquo;$username&rdquo; /etc/passwd<br />
30 if [ $? -ne $SUCCESS ]<br />
31 then<br />
32 echo &ldquo;User $username does not exist.&rdquo;<br />
33 echo &ldquo;No password changed.&rdquo;<br />
34 exit $E_NOSUCHUSER<br />
35 fi<br />
36<br />
37 echo &ldquo;$NEWPASSWORD&rdquo; | passwd &ndash;stdin &ldquo;$username&rdquo;<br />
38 # &lsquo;passwd&rsquo;命令 &lsquo;&ndash;stdin&rsquo; 选项允许<br />
39 #+ 从stdin(或者管道)中获得一个新的密码.<br />
40<br />
41 echo; echo &ldquo;User $username&rsquo;s password changed!&rdquo;<br />
42<br />
43 # 在脚本中使用&rsquo;passwd&rsquo;命令是很危险的.<br />
44<br />
45 exit 0<br />
################################End
Script#########################################<br />
passwd 命令的 -l, -u, 和 -d 选项允许锁定, 解锁,和删除一个用户的密码. 只有root<br />
用户可以使用这些选项.</p>

<p>ac<br />
显示用户登录的连接时间, 就像从 /var/log/wtmp 中读取一样. 这是GNU的一个统计工具.</p>

<p>bash$ ac<br />
total 68.08</p>

<p>last<br />
用户最后登录的信息, 就像从/var/log/wtmp中读出来一样. 这个命令也可以用来显示远<br />
端登录.<br />
比如, 显示最后几次系统的重启信息:</p>

<p>bash$ last reboot<br />
reboot system boot 2.6.9-1.667 Fri Feb 4 18:18 (00:02)<br />
reboot system boot 2.6.9-1.667 Fri Feb 4 15:20 (01:27)<br />
reboot system boot 2.6.9-1.667 Fri Feb 4 12:56 (00:49)<br />
reboot system boot 2.6.9-1.667 Thu Feb 3 21:08 (02:17)<br />
&hellip;</p>

<p>wtmp begins Tue Feb 1 12:50:09 2005</p>

<p>newgrp<br />
不用登出就可以修改用户的组ID. 并且允许存取新组的文件. 因为用户可能同时属于多个<br />
组, 这个命令很少被使用.</p>

<p>终端类命令</p>

<p>tty<br />
显示当前用户终端的名字. 注意每一个单独的xterm窗口都被算作一个不同的终端.</p>

<p>bash$ tty<br />
/dev/pts/1</p>

<p>stty<br />
显示并(或)修改终端设置. 这个复杂命令可以用在脚本中, 并可以用来控制终端的行为和<br />
其显示输出的方法. 参见这个命令的info页, 并仔细学习它.</p>

<p>Example 13-2 设置一个擦除字符<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # erase.sh: 在读取输入时使用&rdquo;stty&rdquo;来设置一个擦除字符.<br />
3<br />
4 echo -n &ldquo;What is your name? &rdquo;<br />
5 read name # 试试退格键<br />
6 #+ 来删除输入的字符.<br />
7 # 有什么问题?<br />
8 echo &ldquo;Your name is $name.&rdquo;<br />
9<br />
10 stty erase &lsquo;#&rsquo; # 将 &ldquo;hashmark&rdquo; (#) 设置为退格字符.<br />
11 echo -n &ldquo;What is your name? &rdquo;<br />
12 read name # 使用#来删除最后键入的字符.<br />
13 echo &ldquo;Your name is $name.&rdquo;<br />
14<br />
15 # 警告: 即使在脚本退出后, 新的键值还是保持设置.(译者: 使用stty erase &lsquo;^?&rsquo; 恢复)<br />
16<br />
17 exit 0<br />
################################End
Script#########################################</p>

<p>Example 13-3 关掉终端对于密码的echo<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # secret-pw.sh: 保护密码不被显示<br />
3<br />
4 echo<br />
5 echo -n &ldquo;Enter password &rdquo;<br />
6 read passwd<br />
7 echo &ldquo;password is $passwd&rdquo;<br />
8 echo -n &ldquo;If someone had been looking over your shoulder, &rdquo;<br />
9 echo &ldquo;your password would have been compromised.&rdquo;<br />
10<br />
11 echo &amp;&amp; echo # 在一个&rdquo;与列表&rdquo;中产生2个换行.<br />
12<br />
13<br />
14 stty -echo # 关闭屏幕的echo.<br />
15<br />
16 echo -n &ldquo;Enter password again &rdquo;<br />
17 read passwd<br />
18 echo<br />
19 echo &ldquo;password is $passwd&rdquo;<br />
20 echo<br />
21<br />
22 stty echo # 恢复屏幕的echo.<br />
23<br />
24 exit 0<br />
25<br />
26 # 详细的阅读stty命令的info页, 以便于更好的掌握这个有用并且狡猾的工具.<br />
################################End
Script#########################################</p>

<p>一个具有创造性的stty命令的用法, 检测用户所按的键(不用敲回车).</p>

<p>Example 13-4 按键检测<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # keypress.sh: 检测用户按键 (&ldquo;hot keys&rdquo;).<br />
3<br />
4 echo<br />
5<br />
6 old_tty_settings=$(stty -g) # 保存老的设置(为什么?).<br />
7 stty -icanon<br />
8 Keypress=$(head -c1) # 或者 $(dd bs=1 count=1 2&gt; /dev/null)<br />
9 # 在非GNU的系统上<br />
10<br />
11 echo<br />
12 echo &ldquo;Key pressed was \&ldquo;&rdquo;$Keypress&rdquo;\&ldquo;.&rdquo;<br />
13 echo<br />
14<br />
15 stty &ldquo;$old_tty_settings&rdquo; # 恢复老的设置.<br />
16<br />
17 # 感谢, Stephane Chazelas.<br />
18<br />
19 exit 0<br />
################################End
Script#########################################<br />
参见 Example 9-3.</p>

<p>注意: 终端与模式terminals and modes<br />
一般情况下, 一个终端都是工作在canonical(标准)模式下. 当用户按键后, 事实上所<br />
产生的字符并没有马上传递到运行在当前终端上的程序. 终端上的一个本地的缓存保<br />
存了这些按键. 当用按下ENTER键的时候, 才会将所有保存的按键信息传递到运行的程<br />
序中. 这就意味着在终端内部存在一个基本的行编辑器.</p>

<p>bash$ stty -a<br />
speed 9600 baud; rows 36; columns 96; line = 0;<br />
intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = ; eol2 = ;<br />
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush =
^O;<br />
&hellip;<br />
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</p>

<p>在使用canonical模式的时候, 可以对本地终端行编辑器所定义的特殊按键进行重新定<br />
义.</p>

<p>bash$ cat &gt; filexxx<br />
whaIfoo barhello world</p>

<p>bash$ cat filexxx<br />
hello world<br />
bash$ wc -c &lt; filexxx<br />
12</p>

<p>控制终端的进程只保存了12个字符(11个字母加上一个换行), 虽然用户敲了26个按键.</p>

<p>在 non-canonical (&ldquo;raw&rdquo;) 模式, 每次按键(包括特殊定义的按键, 比如 ctl-H)将会<br />
立即发送一个字符到控制进程.</p>

<p>Bash提示符禁用了icanon和echo, 因为它用自己的更好的行编辑器代替了终端的基本<br />
行编辑器. 比如, 当你在Bash提示符下敲ctl-A的时候, 终端将不会显示 ^A, 但是<br />
Bash将会获得\1字符, 然后解释这个字符, 这样光标就移动到行首了.</p>

<p>Stéphane Chazelas</p>

<p>setterm<br />
设置特定的终端属性. 这个命令将向它的终端的stdout写一个字符串, 这个字符串将修改<br />
终端的行为.</p>

<p>bash$ setterm -cursor off<br />
bash$</p>

<p>setterm 命令可以被用在脚本中来修改写到stdout的文本的外观, 虽然如果你仅仅只想完<br />
成这个目的, 还有特定的更好的工具可以用.</p>

<p>1 setterm -bold on<br />
2 echo bold hello<br />
3<br />
4 setterm -bold off<br />
5 echo normal hello</p>

<p>tset<br />
显示或初始化终端设置. 可以说这是stty的功能比较弱的版本.</p>

<p>bash$ tset -r<br />
Terminal type is xterm-xfree86.<br />
Kill is control-U (^U).<br />
Interrupt is control-C (^C).</p>

<p>setserial<br />
设置或者显示串口参数. 这个脚本只能被root用户来运行, 并且通常都在系统安装脚本<br />
中使用.</p>

<p>1 # 来自于 /etc/pcmcia/serial 脚本:<br />
2<br />
3 IRQ=<code>setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'</code><br />
4 setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ</p>

<p>getty, agetty<br />
一个终端的初始化过程通常都是使用getty或agetty来建立, 这样才能让用户登录. 这些<br />
命令并不用在用户的shell脚本中. 它们的行为与stty很相似.</p>

<p>mesg<br />
使能或禁用当前用户终端的存取权限. 禁用存取权限将会阻止网络上的另一用户向这个终<br />
端写消息.</p>

<p>注意: 当你正在编写文本文件的时候, 在文本中间突然来了一个莫名其妙的消息, 这对你<br />
来说是非常烦人的. 在多用户的网络环境下, 当你不想被打断的时候, 你可能因此希<br />
望禁用对你终端的写权限.</p>

<p>wall<br />
这是一个缩写单词 &ldquo;write all&rdquo;, 也就是, 向登录到网络上的任何终端的所有用户都发送<br />
一个消息. 最早这是一个管理员的工具, 很有用, 比如, 当系统有问题的时候, 管理可以<br />
警告系统上的所有人暂时离开 (参见 Example 17-1).</p>

<p>bash$ wall System going down for maintenance in 5 minutes!<br />
Broadcast message from bozo (pts/1) Sun Jul 8 13:53:27 2001&hellip;</p>

<p>System going down for maintenance in 5 minutes!</p>

<p>注意: 如果某个特定终端使用mesg来禁止了写权限, 那么wall将不会给它发消息.</p>

<p>信息与统计类<br />
uname<br />
输出系统的说明(OS, 内核版本, 等等.)到stdout. 使用 -a 选项, 将会给出详细的信息<br />
(参见 Example 12-5). 使用-s选项只会输出OS类型.</p>

<p>bash$ uname -a<br />
Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i686
unknown</p>

<p>bash$ uname -s<br />
Linux</p>

<p>arch<br />
显示系统的硬件体系结构. 等价于 uname -m. 参见 Example 10-26.</p>

<p>bash$ arch<br />
i686</p>

<p>bash$ uname -m<br />
i686</p>

<p>lastcomm<br />
给出前一个命令的信息, 存储在/var/account/pacct文件中. 命令名字与用户名字都可以<br />
使用选项来指定. 这是GNU的一个统计工具.</p>

<p>lastlog<br />
列出系统上所有用户最后登录的时间. 存在/var/log/lastlog文件中.</p>

<p>bash$ lastlog<br />
root tty1 Fri Dec 7 18:43:21 -0700 2001<br />
bin <strong>Never logged in</strong><br />
daemon <strong>Never logged in</strong><br />
&hellip;<br />
bozo tty1 Sat Dec 8 21:14:29 -0700 2001</p>

<p>bash$ lastlog | grep root<br />
root tty1 Fri Dec 7 18:43:21 -0700 2001</p>

<p>注意: 如果用户对于/var/log/lastlog文件没有读权限的话, 那么调用这个命令就会失败.</p>

<p>lsof<br />
列出打开的文件. 这个命令将会把所有当前打开的文件列出一份详细的表格, 包括文件的<br />
所有者信息, 尺寸, 与它们相关的信息等等. 当然, lsof也可以管道输出到 grep 和(或)<br />
awk来分析它的结果.</p>

<p>bash$ lsof<br />
COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME<br />
init 1 root mem REG 3,5 30748 30303 /sbin/init<br />
init 1 root mem REG 3,5 73120 8069 /lib/ld-2.1.3.so<br />
init 1 root mem REG 3,5 931668 8075 /lib/libc-2.1.3.so<br />
cardmgr 213 root mem REG 3,5 36956 30357 /sbin/cardmgr<br />
&hellip;</p>

<p>strace<br />
为了跟踪系统和信号的诊断和调试工具. 调用它最简单的方法就是strace COMMAND.</p>

<p>bash$ strace df<br />
execve(&ldquo;/bin/df&rdquo;, [&ldquo;df&rdquo;], [/* 45 vars */]) = 0<br />
uname({sys=&ldquo;Linux&rdquo;, node=&ldquo;bozo.localdomain&rdquo;, &hellip;}) = 0<br />
brk(0) = 0x804f5e4<br />
&hellip;</p>

<p>这是 Solaris truss命令的Linux的等价工具.</p>

<p>nmap<br />
网络端口扫描器. 这个命令将会扫描一个服务器来定位打开的端口, 并且定位这些端口相<br />
关的服务. 这是一个防止网络被黑客入侵的一个重要的安全工具.</p>

<p>1 #!/bin/bash<br />
2<br />
3 SERVER=$HOST # localhost.localdomain (127.0.0.1).<br />
4 PORT_NUMBER=25 # SMTP 端口.<br />
5<br />
6 nmap $SERVER | grep -w &ldquo;$PORT_NUMBER&rdquo; # 这个指定端口打开了么?<br />
7 # grep -w 匹配整个单词,<br />
8 #+ 这样就不会匹配类似于1025这种含有25的端口了.<br />
9<br />
10 exit 0<br />
11<br />
12 # 25/tcp open smtp</p>

<p>nc<br />
nc(netcat)工具是一个完整的工具包, 可以使用它来连接和监听TCP和UDP端口. 它可以用<br />
来作为诊断和测试工具, 也可以用来作为基于脚本的HTTP客户端和服务器的组件.</p>

<p>bash$ nc localhost.localdomain 25<br />
220 localhost.localdomain ESMTP Sendmail 8.13.<sup>1</sup>&frasl;<sub>8</sub>.13.1; Thu, 31 Mar 2005
15:41:35 -0700</p>

<p>Example 13-5 Checking a remote server for identd<br />
################################Start
Script#######################################<br />
1 #! /bin/sh<br />
2 ## Duplicate DaveG&rsquo;s ident-scan thingie using netcat. Oooh, he&rsquo;ll be p*ssed.<br />
3 ## Args: target port [port port port &hellip;]<br />
4 ## Hose stdout <em>and</em> stderr together.<br />
5 ##<br />
6 ## 优点: runs slower than ident-scan, giving remote inetd less cause<br />
7 ##+ for alarm, and only hits the few known daemon ports you specify.<br />
8 ## 缺点: requires numeric-only port args, the output sleazitude,<br />
9 ##+ and won&rsquo;t work for r-services when coming from high source ports.<br />
10 # 脚本作者: Hobbit<br />
11 # 授权使用在本书中.<br />
12<br />
13 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
14 E_BADARGS=65 # 至少需要两个参数.<br />
15 TWO_WINKS=2 # 需要睡多长时间.<br />
16 THREE_WINKS=3<br />
17 IDPORT=113 # Authentication &ldquo;tap ident&rdquo; port.<br />
18 RAND1=999<br />
19 RAND2=31337<br />
20 TIMEOUT0=9<br />
21 TIMEOUT1=8<br />
22 TIMEOUT2=4<br />
23 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
24<br />
25 case &ldquo;${2}&rdquo; in<br />
26 &ldquo;&rdquo; ) echo &ldquo;Need HOST and at least one PORT.&rdquo; ; exit $E_BADARGS ;;<br />
27 esac<br />
28<br />
29 # Ping &lsquo;em once and see if they <em>are</em> running identd.<br />
30 nc -z -w $TIMEOUT0 &ldquo;$1&rdquo; $IDPORT || { echo &ldquo;Oops, $1 isn&rsquo;t running identd.&rdquo;
; exit 0 ; }<br />
31 # -z scans for listening daemons.<br />
32 # -w $TIMEOUT = How long to try to connect.<br />
33<br />
34 # Generate a randomish base port.<br />
35 RP=<code>expr $$ % $RAND1 + $RAND2</code><br />
36<br />
37 TRG=&ldquo;$1&rdquo;<br />
38 shift<br />
39<br />
40 while test &ldquo;$1&rdquo; ; do<br />
41 nc -v -w $TIMEOUT1 -p ${RP} &ldquo;$TRG&rdquo; ${1} &lt; /dev/null &gt; /dev/null &amp;<br />
42 PROC=$!<br />
43 sleep $THREE_WINKS<br />
44 echo &ldquo;${1},${RP}&rdquo; | nc -w $TIMEOUT2 -r &ldquo;$TRG&rdquo; $IDPORT 2&gt;&amp;1<br />
45 sleep $TWO_WINKS<br />
46<br />
47 # 这个脚本看起来是不是一个瘸腿脚本, 或者其它更差的什么东西?<br />
48 # ABS Guide 作者注释: &ldquo;并不是真的那么差,<br />
49 #+ 事实上相当清楚.&rdquo;<br />
50<br />
51 kill -HUP $PROC<br />
52 RP=<code>expr ${RP} + 1</code><br />
53 shift<br />
54 done<br />
55<br />
56 exit $?<br />
57<br />
58 # 注意事项:<br />
59 # &mdash;&mdash;&mdash;<br />
60<br />
61 # 尝试注释一下第30行的程序, 并且使用&rdquo;localhost.localdomain 25&rdquo;<br />
62 #+ 作为参数来运行这个脚本.<br />
63<br />
64 # For more of Hobbit&rsquo;s &lsquo;nc&rsquo; example scripts,<br />
65 #+ look in the documentation:<br />
66 #+ the /usr/share/doc/nc-X.XX/scripts directory.<br />
################################End
Script#########################################<br />
并且, 当然, 这里还有Dr. Andrew Tridgell在BistKeeper事件中臭名卓著的一行脚本:<br />
1 echo clone | nc thunk.org 5000 &gt; e2fsprogs.dat</p>

<p>free<br />
使用表格形式来显示内存和缓存的使用情况. 这个命令的输出非常适合于使用 grep, awk<br />
或者Perl来分析. procinfo命令将会显示free命令所能显示的所有信息, 而且更多.</p>

<p>bash$ free<br />
total used free shared buffers cached<br />
Mem: 30504 28624 1880 15820 1608 16376<br />
-/+ buffers/cache: 10640 19864<br />
Swap: 68540 3128 65412</p>

<p>显示未使用的RAM内存:</p>

<p>bash$ free | grep Mem | awk &lsquo;{ print $4 }&rsquo;<br />
1880</p>

<p>procinfo<br />
从/proc pseudo-filesystem中提取和显示所有信息和统计资料. 这个命令将给出更详细<br />
的信息.</p>

<p>bash$ procinfo | grep Bootup<br />
Bootup: Wed Mar 21 15:15:50 2001 Load average: 0.04 0.21 0.34 <sup>3</sup>&frasl;<sub>47</sub> 6829</p>

<p>lsdev<br />
显示设备, 也就是显示安装的硬件.</p>

<p>bash$ lsdev<br />
Device DMA IRQ I/O Ports<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
cascade 4 2<br />
dma 0080-008f<br />
dma1 0000-001f<br />
dma2 00c0-00df<br />
fpu 00f0-00ff<br />
ide0 14 01f0-01f7 03f6-03f6<br />
&hellip;</p>

<p>du<br />
递归的显示(磁盘)文件的使用状况. 除非指定, 默认是当前工作目录.</p>

<p>bash$ du -ach<br />
1.0k ./wi.sh<br />
1.0k ./tst.sh<br />
1.0k ./random.file<br />
6.0k .<br />
6.0k total</p>

<p>df<br />
使用列表的形式显示文件系统的使用状况.</p>

<p>bash$ df<br />
Filesystem 1k-blocks Used Available Use% Mounted on<br />
/dev/hda5 273262 92607 166547 36% /<br />
/dev/hda8 222525 123951 87085 59% /home<br />
/dev/hda7 1408796 1075744 261488 80% /usr</p>

<p>dmesg<br />
将所有的系统启动消息输出到stdout上. 方便出错,并且可以查出安装了哪些设备驱动和<br />
察看使用了哪些系统中断. dmesg命令的输出当然也可以在脚本中使用 grep, sed, 或<br />
awk 来进行分析.</p>

<p>bash$ dmesg | grep hda<br />
Kernel command line: ro root=/dev/hda2<br />
hda: IBM-DLGA-23080, ATA DISK drive<br />
hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63<br />
hda: hda1 hda2 hda3 &lt; hda5 hda6 hda7 &gt; hda4</p>

<p>stat<br />
显示一个或多个给定文件(也可以是目录文件或设备文件)的详细的统计信息.</p>

<p>bash$ stat test.cru<br />
File: &ldquo;test.cru&rdquo;<br />
Size: 49970 Allocated Blocks: 100 Filetype: Regular File<br />
Mode: (0664/-rw-rw-r&ndash;) Uid: ( 501/ bozo) Gid: ( 501/ bozo)<br />
Device: 3,8 Inode: 18185 Links: 1<br />
Access: Sat Jun 2 16:40:24 2001<br />
Modify: Sat Jun 2 16:40:24 2001<br />
Change: Sat Jun 2 16:40:24 2001</p>

<p>如果目标文件不存在, stat 将会返回一个错误信息.</p>

<p>bash$ stat nonexistent-file<br />
nonexistent-file: No such file or directory</p>

<p>vmstat<br />
显示虚拟内存的统计信息.</p>

<p>bash$ vmstat<br />
procs memory swap io system cpu<br />
r b w swpd free buff cache si so bi bo in cs us sy id<br />
0 0 0 0 11040 2636 38952 0 0 33 7 271 88 8 3 89</p>

<p>netstat<br />
显示当前网络的统计和信息, 比如路由表和激活的连接. 这个工具存取/proc/net(第27章)<br />
中的信息. 参见 Example 27-3.<br />
netstat -r 等价于 route 命令.</p>

<p>bash$ netstat<br />
Active Internet connections (w/o servers)<br />
Proto Recv-Q Send-Q Local Address Foreign Address State<br />
Active UNIX domain sockets (w/o servers)<br />
Proto RefCnt Flags Type State I-Node Path<br />
unix 11 [ ] DGRAM 906 /dev/log<br />
unix 3 [ ] STREAM CONNECTED 4514 /tmp/.X11-unix/X0<br />
unix 3 [ ] STREAM CONNECTED 4513<br />
&hellip;</p>

<p>uptime<br />
显示系统运行的时间, 还有其他一些统计信息.</p>

<p>bash$ uptime<br />
10:28pm up 1:57, 3 users, load average: 0.17, 0.34, 0.27</p>

<p>注意: load average 如果小于或等于1, 那么就意味着系统会马上处理. 如果<br />
load average大于1, 那么就意味着进程需要排队. 如果load average大于3,<br />
那么就意味着, 系统性能已经显著下降了.</p>

<p>hostname<br />
显示系统的主机名字. 这个命令在 /etc/rc.d 安装脚本(/etc/rc.d/rc.sysinit<br />
或类似的)中设置主机名. 等价于uname -n, 并且与$HOSTNAME内部变量很相像.</p>

<p>bash$ hostname<br />
localhost.localdomain</p>

<p>bash$ echo $HOSTNAME<br />
localhost.localdomain</p>

<p>与 hostname 命令很相像的命令还有 domainname, dnsdomainname, nisdomainname, 和<br />
ypdomainname 命令. 使用这些来显示或设置系统DNS 或者 NIS/YP 域名. 对于hostname<br />
命令来说使用不同的选项一样可以达到上边这些命令的目的.</p>

<p>hostid<br />
显示主机的32位的16进制ID.</p>

<p>bash$ hostid<br />
7f0100</p>

<p>注意: 这个命令据说对于特定系统可以获得一个&rdquo;唯一&rdquo;的序号. 某些产品的注册过程可能<br />
会需要这个序号来作为用户的许可证. 不幸的是, hostid 只会使用字节转换的方法<br />
来用16进制显示机器的网络地址.</p>

<p>一个没有网络的Linux机器的典型的网络地址设置在/ect/hosts中.</p>

<p>bash$ cat /etc/hosts<br />
127.0.0.1 localhost.localdomain localhost</p>

<p>碰巧, 通过对127.0.0.1进行字节转换, 我们获得了 0.127.1.0, 用16进制表示就是<br />
007f0100, 这就是上边hostid返回的结果. 这样几乎所有的无网络的Linux机器都会<br />
得到这个hostid.</p>

<p>sar<br />
sar (System Activity Reporter系统活动报告) 命令将会给出系统统计的一个非常详细的<br />
概要. Santa Cruz Operation(&ldquo;老&rdquo; SCO)公司在1999年4月份以开源软件的形式发布了sar.</p>

<p>这个命令并不是基本Linux发行版的一部分, 但是你可以从Sebastien Godard 写的<br />
sysstat utilities 包中获得这个工具.</p>

<p>bash$ sar<br />
Linux 2.4.9 (brooks.seringas.fr) 09/26/03</p>

<p>10:30:00 CPU %user %nice %system %iowait %idle<br />
10:40:00 all 2.21 10.90 65.48 0.00 21.41<br />
10:50:00 all 3.36 0.00 72.36 0.00 24.28<br />
11:00:00 all 1.12 0.00 80.77 0.00 18.11<br />
Average: all 2.23 3.63 72.87 0.00 21.27</p>

<p>14:32:30 LINUX RESTART</p>

<p>15:00:00 CPU %user %nice %system %iowait %idle<br />
15:10:00 all 8.59 2.40 17.47 0.00 71.54<br />
15:20:00 all 4.07 1.00 11.95 0.00 82.98<br />
15:30:00 all 0.79 2.94 7.56 0.00 88.71<br />
Average: all 6.33 1.70 14.71 0.00 77.26</p>

<p>readelf<br />
显示指定的 elf 格式的2进制文件的统计信息. 这个工具是binutils工具包的一部分.</p>

<p>bash$ readelf -h /bin/bash<br />
ELF Header:<br />
Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00<br />
Class: ELF32<br />
Data: 2&rsquo;s complement, little endian<br />
Version: 1 (current)<br />
OS/ABI: UNIX - System V<br />
ABI Version: 0<br />
Type: EXEC (Executable file)<br />
&hellip;</p>

<p>size<br />
size [/path/to/binary] 命令可以显示2进制可执行文件或归档文件每部分的尺寸. 这个<br />
工具主要是程序员使用.</p>

<p>bash$ size /bin/bash<br />
text data bss dec hex filename<br />
495971 22496 17392 535859 82d33 /bin/bash</p>

<p>系统日志类<br />
logger<br />
附加一个用户产生的消息到系统日之中 (/var/log/messages). 不是root用户也可以调用<br />
logger.</p>

<p>1 logger Experiencing instability in network connection at 23:10, 05/21.<br />
2 # 现在, 运行 &lsquo;tail /var/log/messages&rsquo;.</p>

<p>通过在脚本中调用一个logger命令, 就可以将调试信息写到/var/log/messages中.</p>

<p>1 logger -t $0 -i Logging at line &ldquo;$LINENO&rdquo;.<br />
2 # &ldquo;-t&rdquo; 选项可以为长的入口指定标签.<br />
3 # &ldquo;-i&rdquo; 选项记录进程ID.<br />
4<br />
5 # tail /var/log/message<br />
6 # &hellip;<br />
7 # Jul 7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.</p>

<p>logrotate<br />
这个工具用来管理系统的log文件, 可以在合适的时候轮换, 压缩, 删除, 和(或)e-mail<br />
它们. 这个工具将从老的log文件中取得一些杂乱的记录保存在/var/log中. 通常使用<br />
cron 来每天运行logrotate.</p>

<p>在/etc/logrotate.conf中添加合适的入口就可以管理自己的log文件了, 就像管理系统<br />
log文件一样.</p>

<p>注意: Stefano Falsetto 创造了rottlog, 他认为这是logrotate的改进版本.</p>

<p>作业控制<br />
ps<br />
进程统计: 通过进程所有者和PID(进程ID)来列出当前执行的进程. 通常都是使用ax选项<br />
来调用这个命令, 并且结果可以通过管道传递到 grep 或 sed 中来搜索特定的进程<br />
(参见 Example 11-12 和 Example 27-2).</p>

<p>bash$ ps ax | grep sendmail<br />
295 ? S 0:00 sendmail: accepting connections on port 25</p>

<p>如果想使用&rdquo;树&rdquo;的形式来显示系统进程: ps afjx 或者 ps ax &ndash;forest.</p>

<p>pgrep, pkill<br />
ps 命令与grep或kill结合使用.</p>

<p>bash$ ps a | grep mingetty<br />
2212 tty2 Ss+ 0:00 /sbin/mingetty tty2<br />
2213 tty3 Ss+ 0:00 /sbin/mingetty tty3<br />
2214 tty4 Ss+ 0:00 /sbin/mingetty tty4<br />
2215 tty5 Ss+ 0:00 /sbin/mingetty tty5<br />
2216 tty6 Ss+ 0:00 /sbin/mingetty tty6<br />
4849 pts/2 S+ 0:00 grep mingetty</p>

<p>bash$ pgrep mingetty<br />
2212 mingetty<br />
2213 mingetty<br />
2214 mingetty<br />
2215 mingetty<br />
2216 mingetty</p>

<p>pstree<br />
使用&rdquo;树&rdquo;形式列出当前执行的进程. -p选项显示PID,和进程名字.</p>

<p>top<br />
连续不断的显示cpu使用率最高的进程. -b 选项将会以文本方式显示, 以便于可以在脚本<br />
中分析或存取.</p>

<p>bash$ top -b<br />
8:30pm up 3 min, 3 users, load average: 0.49, 0.32, 0.13<br />
45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped<br />
CPU states: 13.6% user, 7.3% system, 0.0% nice, 78.9% idle<br />
Mem: 78396K av, 65468K used, 12928K free, 0K shrd, 2352K buff<br />
Swap: 157208K av, 0K used, 157208K free 37244K cached</p>

<p>PID USER PRI NI SIZE RSS SHARE STAT %CPU %MEM TIME COMMAND<br />
848 bozo 17 0 996 996 800 R 5.6 1.2 0:00 top<br />
1 root 8 0 512 512 444 S 0.0 0.6 0:04 init<br />
2 root 9 0 0 0 0 SW 0.0 0.0 0:00 keventd<br />
&hellip;</p>

<p>nice<br />
使用修改后的优先级来运行一个后台作业. 优先级从19(最低)到-20(最高). 只有root用<br />
户可以设置负的(比较高的)优先级. 相关的命令是renice, snice, 和skill.</p>

<p>nohup<br />
保持一个命令的运行, 即使用户登出系统. 这个命令做为前台进程来运行, 除非前边加 &amp;.<br />
如果你在脚本中使用nohup命令, 最好和wait 命令一起使用, 这样可以避免创建一个<br />
孤儿进程或僵尸进程.</p>

<p>pidof<br />
取得一个正在运行的作业的进程ID(PID). 因为一些作业控制命令, 比如kill和renice只<br />
能使用进程的PID(而不是它的名字), 所以有时候必须的取得PID. pidof命令与$PPID内部<br />
变量非常相似.</p>

<p>bash$ pidof xclock<br />
880</p>

<p>Example 13-6 pidof 帮助杀掉一个进程<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # kill-process.sh<br />
3<br />
4 NOPROCESS=2<br />
5<br />
6 process=xxxyyyzzz # 使用不存在的进程.<br />
7 # 只不过是为了演示&hellip;<br />
8 # &hellip; 并不想在这个脚本中杀掉任何真正的进程.<br />
9 #<br />
10 # 如果, 举个例子, 你想使用这个脚本来断线Internet,<br />
11 # process=pppd<br />
12<br />
13 t=<code>pidof $process</code> # 取得$process的pid(进程id).<br />
14 # &lsquo;kill&rsquo;必须使用pid(不能用程序名).<br />
15<br />
16 if [ -z &ldquo;$t&rdquo; ] # 如果没这个进程, &lsquo;pidof&rsquo; 返回空.<br />
17 then<br />
18 echo &ldquo;Process $process was not running.&rdquo;<br />
19 echo &ldquo;Nothing killed.&rdquo;<br />
20 exit $NOPROCESS<br />
21 fi<br />
22<br />
23 kill $t # 对于顽固的进程可能需要&rsquo;kill -9&rsquo;.<br />
24<br />
25 # 这里需要做一个检查, 看看进程是否允许自身被kill.<br />
26 # 或许另一个 &ldquo; t=<code>pidof $process</code> &ldquo; 或者 &hellip;<br />
27<br />
28<br />
29 # 整个脚本都可以使用下边这句来替换:<br />
30 # kill $(pidof -x process_name)<br />
31 # 但是这就没有教育意义了.<br />
32<br />
33 exit 0<br />
################################End
Script#########################################</p>

<p>fuser<br />
取得一个正在存取某个或某些文件(或目录)的进程ID. 使用-k选项将会杀掉这些进程. 对<br />
于系统安全来说, 尤其是在脚本中想阻止未被授权的用户存取系统服务的时候, 这个命令<br />
就显得很有用了.</p>

<p>bash$ fuser -u /usr/bin/vim<br />
/usr/bin/vim: 3207e(bozo)</p>

<p>bash$ fuser -u /dev/null<br />
/dev/null: 3009(bozo) 3010(bozo) 3197(bozo) 3199(bozo)</p>

<p>当正常的插入或删除保存的媒体, 比如CD ROM或者USB闪存设备的时候, fuser的应用也显<br />
得特别重要. 有时候当你想umount一个设备失败的时候(出现设备忙的错误消息), 这意味<br />
着某些用户或进程正在存取这个设备. 使用fuser -um /dev/device_name可以搞定这些,<br />
这样你就可以杀掉所有相关的进程.</p>

<p>bash$ umount /mnt/usbdrive<br />
umount: /mnt/usbdrive: device is busy</p>

<p>bash$ fuser -um /dev/usbdrive<br />
/mnt/usbdrive: 1772c(bozo)</p>

<p>bash$ kill -9 1772<br />
bash$ umount /mnt/usbdrive</p>

<p>fuser 的-n选项可以获得正在存取某一端口的进程. 当和nmap命令组合使用的时候尤其<br />
有用.</p>

<p>root# nmap localhost.localdomain<br />
PORT STATE SERVICE<br />
25/tcp open smtp</p>

<p>root# fuser -un tcp 25<br />
25/tcp: 2095(root)</p>

<p>root# ps ax | grep 2095 | grep -v grep<br />
2095 ? Ss 0:00 sendmail: accepting connections</p>

<p>cron<br />
管理程序调度器, 执行一些日常任务, 比如清除和删除系统log文件, 或者更新slocate命<br />
令的数据库. 这是at命令的超级用户版本(虽然每个用户都可以有自己的crontab文件, 并<br />
且这个文件可以使用crontab命令来修改). 它以幽灵进程T的身份来运行, 并且从<br />
/ect/crontab中获得执行的调度入口.</p>

<p>注意: 一些Linux的风格都使用crond, Matthew Dillon的cron.</p>

<p>进程控制和启动类<br />
init<br />
init 命令是所有进程的父进程. 在系统启动的最后一步调用, init 将会依据<br />
/etc/inittab来决定系统的运行级别. 只能使用root身份来运行它的别名telinit.</p>

<p>telinit<br />
init命令的符号链接, 这是一种修改系统运行级别的一个手段, 通常在系统维护或者紧急<br />
的文件系统修复的时候才用. 只能使用root身份调用. 调用这个命令是非常危险的 - 在<br />
你使用之前确定你已经很好地了解它.</p>

<p>runlevel<br />
显示当前和最后的运行级别, 也就是, 确定你的系统是否终止(runlevel 为0), 还是运行<br />
在单用户模式(1), 多用户模式(2), 或者是运行在X Windows(5), 还是正在重启(6). 这<br />
个命令将会存取/var/run/utmp文件.</p>

<p>halt, shutdown, reboot<br />
设置系统关机的命令, 通常比电源关机的优先级高.</p>

<p>service<br />
开启或停止一个系统服务. 启动脚本在/etc/init.d中, 并且/etc/rc.d在系统启动的时候<br />
使用这个命令来启动服务.</p>

<p>root# /sbin/service iptables stop<br />
Flushing firewall rules: [ OK ]<br />
Setting chains to policy ACCEPT: filter [ OK ]<br />
Unloading iptables modules: [ OK ]</p>

<p>网络类</p>

<p>ifconfig<br />
网络的接口配置和调试工具.</p>

<p>bash$ ifconfig -a<br />
lo Link encap:Local Loopback<br />
inet addr:127.0.0.1 Mask:255.0.0.0<br />
UP LOOPBACK RUNNING MTU:16436 Metric:1<br />
RX packets:10 errors:0 dropped:0 overruns:0 frame:0<br />
TX packets:10 errors:0 dropped:0 overruns:0 carrier:0<br />
collisions:0 txqueuelen:0<br />
RX bytes:700 (700.0 b) TX bytes:700 (700.0 b)</p>

<p>ifconfig 命令绝大多数情况都是在启动时候设置接口, 或者在重启的时候关闭它们.</p>

<p>1 # 来自于 /etc/rc.d/init.d/network 的代码片段<br />
2<br />
3 # &hellip;<br />
4<br />
5 # 检查网络是否启动.<br />
6 [ ${NETWORKING} = &ldquo;no&rdquo; ] &amp;&amp; exit 0<br />
7<br />
8 [ -x /sbin/ifconfig ] || exit 0<br />
9<br />
10 # &hellip;<br />
11<br />
12 for i in $interfaces ; do<br />
13 if ifconfig $i 2&gt;/dev/null | grep -q &ldquo;UP&rdquo; &gt;/dev/null 2&gt;&amp;1 ; then<br />
14 action &ldquo;Shutting down interface $i: &ldquo; ./ifdown $i boot<br />
15 fi<br />
16 # grep命令的GNU指定的 &ldquo;-q&rdquo; 的意思是&rdquo;安静&rdquo;, 也就是不产生输出.<br />
17 # 这样, 后边重定向到/dev/null的操作就有点重复了.<br />
18<br />
19 # &hellip;<br />
20<br />
21 echo &ldquo;Currently active devices:&rdquo;<br />
22 echo <code>/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'</code><br />
23 # ^^^^^ 应该被引用防止globbing.<br />
24 # 下边这段也能工作.<br />
25 # echo $(/sbin/ifconfig | awk &lsquo;/<sup class="footnote-ref" id="fnref:a-z"><a href="#fn:a-z">4</a></sup>/ { print $1 })&rsquo;<br />
26 # echo $(/sbin/ifconfig | sed -e &rsquo;s/ .*//&lsquo;)<br />
27 # Thanks, S.C.做了额外的注释.</p>

<p>参见 Example 29-6.</p>

<p>iwconfig<br />
这是为了配置无线网络的命令集合. 可以说是上边的ifconfig的无线版本.</p>

<p>route<br />
显示内核路由表信息, 或者查看内核路由表的修改.</p>

<p>bash$ route<br />
Destination Gateway Genmask Flags MSS Window irtt Iface<br />
pm3-67.bozosisp * 255.255.255.255 UH 40 0 0 ppp0<br />
127.0.0.0 * 255.0.0.0 U 40 0 0 lo<br />
default pm3-67.bozosisp 0.0.0.0 UG 40 0 0 ppp0</p>

<p>chkconfig<br />
检查网络配置. 这个命令负责显示和管理在启动过程中所开启的网络服务(这些服务都是<br />
从/etc/rc?.d目录中开启的).</p>

<p>最开始是从IRIX到Red Hat Linux的一个接口, chkconfig在某些Linux发行版中并不是核<br />
心安装的一部分.</p>

<p>bash$ chkconfig &ndash;list<br />
atd 0:off 1:off 2:off 3:on 4:on 5:on 6:off<br />
rwhod 0:off 1:off 2:off 3:off 4:off 5:off 6:off<br />
&hellip;</p>

<p>tcpdump<br />
网络包的&rdquo;嗅探器&rdquo;. 这是一个用来分析和调试网络上传输情况的工具, 它所使用的手段是<br />
把匹配指定规则的包头都显示出来.</p>

<p>显示主机bozoville和主机caduceus之间所有传输的ip包.</p>

<p>bash$ tcpdump ip host bozoville and caduceus</p>

<p>当然,tcpdump的输出可以被分析, 可以用我们之前讨论的文本处理工具来分析结果.</p>

<p>文件系统类</p>

<p>mount<br />
加载一个文件系统, 通常都用来安装外部设备, 比如软盘或CDROM. 文件/etc/fstab 将会<br />
提供一个方便的列表, 这个列表列出了所有可用的文件系统, 分区和设备, 另外还包括某<br />
些选项, 比如是否可以自动或者手动的mount. 文件/etc/mtab 显示了当前已经mount的文<br />
件系统和分区(包括虚拟的, 比如/proc).</p>

<p>mount -a 将会mount所有列在/ect/fstab中的文件系统和分区, 除了那些标记有非自动选<br />
项的. 在启动的时候, 在/etc/rc.d中的一个启动脚本(rc.sysinit或者一些相似的脚本)<br />
将会这么调用, mount所有可用的文件系统和分区.</p>

<p>1 mount -t iso9660 /dev/cdrom /mnt/cdrom<br />
2 # 加载 CDROM<br />
3 mount /mnt/cdrom<br />
4 # 方便的方法, 如果 /mnt/cdrom 包含在 /etc/fstab 中</p>

<p>这个多功能的命令甚至可以将一个普通文件mount到块设备中, 并且这个文件就好像一个<br />
文件系统一样. mount可以将文件与一个loopback设备相关联来达到这个目的.<br />
ccomplishes that by associating the file with a loopback device. 这种应用通常<br />
都是用来mount和检查一个ISO9660镜像,在这个镜像被烧录到CDR之前. [3]</p>

<p>Example 13-7 检查一个CD镜像<br />
################################Start
Script#######################################<br />
1 # 以root身份&hellip;<br />
2<br />
3 mkdir /mnt/cdtest # 如果没有的话,准备一个mount点.<br />
4<br />
5 mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest # mount这个镜像.<br />
6 # &ldquo;-o loop&rdquo; option equivalent to &ldquo;losetup /dev/loop0&rdquo;<br />
7 cd /mnt/cdtest # 现在检查这个镜像.<br />
8 ls -alR # 列出目录树中的文件.<br />
9 # 等等.<br />
################################End
Script#########################################</p>

<p>umount<br />
卸除一个当前已经mount的文件系统. 在正常删除之前已经mount的软盘和CDROM之前, 这<br />
个设备必须被unmount, 否则文件系统将会损坏.</p>

<p>1 umount /mnt/cdrom<br />
2 # 现在你可以按下退出按钮(指的是cdrom或软盘驱动器上的退出钮), 并安全的退出光盘.</p>

<p>sync<br />
强制写入所有需要更新的buffer上的数据到硬盘上(同步带有buffer的驱动器). 如果不是<br />
严格必要的话,一个sync就可以保证系统管理员或者用户刚刚修改的数据会安全的在突然<br />
的断点中幸存下来. 在比较早以前, 在系统重启前都是使用 sync; sync (两次, 这样保<br />
证绝对可靠), 这是一种很有用的小心的方法.</p>

<p>有时候, 比如当你想安全删除一个文件的时候(参见 Example 12-55), 或者当磁盘灯开始<br />
闪烁的时候, 你可能需要强制马上进行buffer刷新.</p>

<p>losetup<br />
建立和配置loopback设备.</p>

<p>Example 13-8 在一个文件中创建文件系统<br />
################################Start
Script#######################################<br />
1 SIZE=1000000 # 1M<br />
2<br />
3 head -c $SIZE &lt; /dev/zero &gt; file # 建立指定尺寸的文件.<br />
4 losetup /dev/loop0 file # 作为loopback设备来建立.<br />
5 mke2fs /dev/loop0 # 创建文件系统.<br />
6 mount -o loop /dev/loop0 /mnt # Mount它.<br />
7<br />
8 # Thanks, S.C.<br />
################################End
Script#########################################</p>

<p>mkswap<br />
创建一个交换分区或文件. 交换区域随后必须马上使用swapon来使能.</p>

<p>swapon, swapoff<br />
使能/禁用 交换分区或文件. 这两个命令通常在启动和关机的时候才有效.</p>

<p>mke2fs<br />
创建Linux ext2 文件系统. 这个命令必须以root身份调用.</p>

<p>Example 13-9 添加一个新的硬盘驱动器<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 在系统上添加第二块硬盘驱动器.<br />
4 # 软件配置. 假设硬件已经安装了.<br />
5 # 来自于本书作者的一篇文章.<br />
6 # 在&rdquo;Linux Gazette&rdquo;的问题#38上, <a href="http://www.linuxgazette.com">http://www.linuxgazette.com</a>.<br />
7<br />
8 ROOT_UID=0 # 这个脚本必须以root身份运行.<br />
9 E_NOTROOT=67 # 非root用户将会产生这个错误.<br />
10<br />
11 if [ &ldquo;$UID&rdquo; -ne &ldquo;$ROOT_UID&rdquo; ]<br />
12 then<br />
13 echo &ldquo;Must be root to run this script.&rdquo;<br />
14 exit $E_NOTROOT<br />
15 fi<br />
16<br />
17 # 要非常谨慎的小心使用!<br />
18 # 如果某步错了, 可能会彻底摧毁你当前的文件系统.<br />
19<br />
20<br />
21 NEWDISK=/dev/hdb # 假设/dev/hdb空白. 检查一下!<br />
22 MOUNTPOINT=/mnt/newdisk # 或者选择另外的mount点.<br />
23<br />
24<br />
25 fdisk $NEWDISK<br />
26 mke2fs -cv $NEWDISK1 # 检查坏块, 详细输出.<br />
27 # 注意: /dev/hdb1, <em>不是</em> /dev/hdb!<br />
28 mkdir $MOUNTPOINT<br />
29 chmod 777 $MOUNTPOINT # 让所有用户都具有全部权限.<br />
30<br />
31<br />
32 # 现在, 测试一下&hellip;<br />
33 # mount -t ext2 /dev/hdb1 /mnt/newdisk<br />
34 # 尝试创建一个目录.<br />
35 # 如果工作起来了, umount它, 然后继续.<br />
36<br />
37 # 最后一步:<br />
38 # 将下边这行添加到/etc/fstab.<br />
39 # /dev/hdb1 /mnt/newdisk ext2 defaults 1 1<br />
40<br />
41 exit 0<br />
################################End
Script#########################################<br />
参见 Example 13-8 和 Example 28-3.</p>

<p>tune2fs<br />
调整ext2文件系统. 可以用来修改文件系统参数, 比如mount的最大数量. 必须以root身<br />
份调用.</p>

<p>注意: 这是一个非常危险的命令. 如果坏了, 你需要自己负责, 因为它可能会破坏你的文<br />
件系统.</p>

<p>dumpe2fs<br />
打印(输出到stdout上)非常详细的文件系统信息. 必须以root身份调用.</p>

<p>root# dumpe2fs /dev/hda7 | grep &lsquo;ount count&rsquo;<br />
dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09<br />
Mount count: 6<br />
Maximum mount count: 20</p>

<p>hdparm<br />
列出或修改硬盘参数. 这个命令必须以root身份调用, 如果滥用的话会有危险.</p>

<p>fdisk<br />
在存储设备上(通常都是硬盘)创建和修改一个分区表. 必须以root身份使用.</p>

<p>注意: 谨慎使用这个命令. 如果出错, 会破坏你现存的文件系统.</p>

<p>fsck, e2fsck, debugfs</p>

<p>文件系统的检查, 修复, 和除错命令集合.</p>

<p>fsck: 检查UNIX文件系统的前端工具(也可以调用其它的工具). 文件系统的类型一般都是<br />
默认的ext2.</p>

<p>e2fsck: ext2文件系统检查器.</p>

<p>debugfs: ext2文件系统除错器. 这个多功能但是危险的工具的用处之一就是(尝试)恢复<br />
删除的文件. 只有高级用户才能用.</p>

<p>上边的这几个命令都必须以root身份调用, 这些命令都很危险, 如果滥用的话会破坏文件<br />
系统.</p>

<p>badblocks<br />
检查存储设备的坏块(物理损坏). 这个命令在格式化新安装的硬盘时或者测试备份的完整<br />
性的时候会被用到. [4] 举个例子, badblocks /dev/fd0 测试一个软盘.</p>

<p>badblocks可能会引起比较糟糕的结果(覆盖所有数据), 在只读模式下就不会发生这种情<br />
况.如果root用户拥有需要测试的设备(通常都是这种情况), 那么root用户必须调用这个<br />
命令.</p>

<p>lsusb, usbmodules<br />
lsusb 命令会列出所有USB(Universal Serial Bus通用串行总线)总线和使用USB的设备.</p>

<p>usbmodules 命令会输出连接USB设备的驱动模块的信息.</p>

<p>root# lsusb<br />
Bus 001 Device 001: ID 0000:0000<br />
Device Descriptor:<br />
bLength 18<br />
bDescriptorType 1<br />
bcdUSB 1.00<br />
bDeviceClass 9 Hub<br />
bDeviceSubClass 0<br />
bDeviceProtocol 0<br />
bMaxPacketSize0 8<br />
idVendor 0x0000<br />
idProduct 0x0000<br />
&hellip;</p>

<p>mkbootdisk<br />
创建启动软盘, 启动盘可以唤醒系统, 比如当MBR(master boot record主启动记录)坏掉<br />
的时候. mkbootdisk 命令其实是一个Bash脚本, 由Erik Troan所编写, 放在/sbin目录中.</p>

<p>chroot<br />
修改ROOT目录. 一般的命令都是从$PATH中获得的, 相对的默认的根目录是 /. 这个命令<br />
将会把根目录修改为另一个目录(并且也将把工作目录修改到那). 出于安全目的, 这个命<br />
令时非常有用的, 举个例子, 当系统管理员希望限制一些特定的用户, 比如telnet上来的<br />
用户, 将他们限定到文件系统上一个安全的地方(这有时候被称为将一个guest用户限制在<br />
&ldquo;chroot 监牢&rdquo;中). 注意, 在使用chroot之后, 系统的二进制可执行文件的目录将不再<br />
可用了.</p>

<p>chroot /opt 将会使得原来的/usr/bin目录变为/opt/usr/bin. 同样,<br />
chroot /aaa/bbb /bin/ls 将会使得ls命令以/aaa/bbb作为根目录, 而不是以前的/.<br />
如果使用alias XX &lsquo;chroot /aaa/bbb ls&rsquo;, 并把这句放到用户的~/.bashrc文件中的话,<br />
这将可以有效地限制运行命令&rdquo;XX&rdquo;时, 命令&rdquo;XX&rdquo;可以使用文件系统的范围.</p>

<p>当从启动盘恢复的时候(chroot 到 /dev/fd0), 或者当系统从死机状态恢复过来并作为进<br />
入lilo的选择手段的时候, chroot命令都是非常方便的. 其它的应用还包括从不同的文件<br />
系统进行安装(一个rpm选项)或者从CDROM上运行一个只读文件系统. 只能以root身份调用,<br />
小心使用.</p>

<p>注意: 由于正常的$PATH将不再被关联了, 所以可能需要将一些特定的系统文件拷贝到<br />
chrooted目录中.</p>

<p>lockfile<br />
这个工具是procmail包的一部分(www.procmail.org). 它可以创建一个锁定文件, 锁定文<br />
件是一种用来控制存取文件, 设备或资源的标记文件. 锁定文件就像一个标记一样被使用,<br />
如果特定的文件, 设备, 或资源正在被一个特定的进程所使用(&ldquo;busy&rdquo;), 那么对于其它进<br />
程来说, 就只能受限进行存取(或者不能存取).</p>

<p>1 lockfile /home/bozo/lockfiles/$0.lock<br />
2 # 创建一个以脚本名字为前缀的写保护锁定文件.</p>

<p>锁定文件用在一些特定的场合, 比如说保护系统的mail目录以防止多个用户同时修改, 或<br />
者提示一个modem端口正在被存取, 或者显示Netscape的一个实例正在使用它的缓存. 脚本<br />
可以做一些检查工作, 比如说一个特定的进程可以创建一个锁定文件, 那么只要检查这个<br />
特定的进程是否在运行, 就可以判断出锁定文件是否存在了. 注意如果脚本尝试创建一个<br />
已经存在的锁定文件的话, 那么脚本很可能被挂起.</p>

<p>一般情况下, 应用创建或检查锁定文件都放在/var/lock目录中. [5] 脚本可以使用下面<br />
的方法来检测锁定文件是否存在.</p>

<p>1 appname=xyzip<br />
2 # 应用 &ldquo;xyzip&rdquo; 创建锁定文件 &ldquo;/var/lock/xyzip.lock&rdquo;.<br />
3<br />
4 if [ -e &ldquo;/var/lock/$appname.lock&rdquo; ]<br />
5 then<br />
6 &hellip;</p>

<p>flock<br />
flock命令比lockfile命令用得少得多.Much less useful than the lockfile command<br />
is flock. It sets an &ldquo;advisory&rdquo; lock on a file and then executes a command<br />
while the lock is on. This is to prevent any other process from setting a lock<br />
on that file until completion of the specified command.</p>

<p>1 flock $0 cat $0 &gt; lockfile__$0<br />
2 # Set a lock on the script the above line appears in,<br />
3 #+ while listing the script to stdout.</p>

<p>注意: 与lockfile不同, flock不会自动创建一个锁定文件.</p>

<p>mknod<br />
创建块或者字符设备文件(当在系统上安装新硬盘时可能是必要的). MAKEDEV工具事实上<br />
具有nknod的全部功能, 而且更容易使用.</p>

<p>MAKEDEV<br />
创建设备文件的工具. 必须在/dev目录下, 并且以root身份使用.</p>

<p>root# ./MAKEDEV<br />
这是mknod的高级版本.</p>

<p>tmpwatch<br />
自动删除在指定时间内未被存取过的文件. 通常都是被cron调用, 用来删掉老的log文件.</p>

<p>备份类<br />
dump, restore<br />
dump 命令是一个精巧的文件系统备份工具, 通常都用在比较大的安装和网络上. [6] 它<br />
读取原始的磁盘分区并且以二进制形式来写备份文件. 需要备份的文件可以保存到各种各<br />
样的存储设备上, 包括磁盘和磁带. restore命令用来恢复dump所产生的备份.</p>

<p>fdformat<br />
对软盘进行低级格式化.</p>

<p>系统资源类</p>

<p>ulimit<br />
设置使用系统资源的上限. 通常情况下都是使用-f选项来调用, -f用来设置文件尺寸的限<br />
制(ulimit -f 1000就是将文件大小限制为1M). -c(译者注: 这里应该是作者笔误, 作者<br />
写的是-t)选项来限制coredump(译者注: 核心转储, 程序崩溃时的内存状态写入文件)<br />
尺寸(ulimit -c 0 就是不要coredumps). 一般情况下, ulimit的值应该设置在<br />
/etc/profile 和(或)~/.bash_profile中(参见 Appendix G).</p>

<p>注意: Judicious 使用ulimit 可以保护系统免受可怕的fork炸弹的迫害.</p>

<p>1 #!/bin/bash<br />
2 # 这个脚本只是为了展示用.<br />
3 # 你要自己为运行这个脚本的后果负责 &ndash; 它*将*凝固你的系统.<br />
4<br />
5 while true # 死循环.<br />
6 do<br />
7 $0 &amp; # 这个脚本调用自身 &hellip;<br />
8 #+ fork无限次 &hellip;<br />
9 #+ 直道系统完全不动, 因为所有的资源都耗尽了.<br />
10 done # 这就是臭名卓著的 &ldquo;sorcerer&rsquo;s appentice&rdquo; 剧情.(译者注:巫师的厢房?没看懂)<br />
11<br />
12 exit 0 # 这里不会真正的推出, 因为这个脚本不会终止.</p>

<p>当这个脚本超过预先设置的限制时, 在/etc/profile中的 ulimit -Hu XX (XX 就是需<br />
要限制的用户进程) 可以终止这个脚本的运行.</p>

<p>quota<br />
显示用户或组的磁盘配额.</p>

<p>setquota<br />
从命令行中设置用户或组的磁盘配额.</p>

<p>umask<br />
设定用户创建文件时权限的缺省mask(掩码). 也可以用来限制特定用户的默认文件属性.<br />
所有用户创建的文件属性都是由umask所指定的. The (octal) 传递给umask的8进制的值定<br />
义了文件的权限. 比如, umask 022将会使得新文件的权限最多为755(777 与非 022) [7]<br />
当然, 用户可以随后使用chmod来修改指定文件的属性. 用户一般都是将umask设置值的地<br />
方放在/etc/profile 和(或) ~/.bash_profile中 (参见 Appendix G).</p>

<p>Example 13-10 使用umask来将输出文件隐藏起来<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # rot13a.sh: 与&rdquo;rot13.sh&rdquo;脚本相同, 但是会将输出写道&rdquo;安全&rdquo;文件中.<br />
3<br />
4 # 用法: ./rot13a.sh filename<br />
5 # 或 ./rot13a.sh  6 # 或 ./rot13a.sh 同时提供键盘输入(stdin)<br />
7<br />
8 umask 177 # 文件创建掩码.<br />
9 # 被这个脚本所创建的文件<br />
10 #+ 将具有600权限.<br />
11<br />
12 OUTFILE=decrypted.txt # 结果保存在&rdquo;decrypted.txt&rdquo;中<br />
13 #+ 这个文件只能够被<br />
14 # 这个脚本的调用者(or root)所读写.<br />
15<br />
16 cat &ldquo;$@&rdquo; | tr &lsquo;a-zA-Z&rsquo; &lsquo;n-za-mN-ZA-M&rsquo; &gt; $OUTFILE<br />
17 # ^^ 从stdin 或文件中输入. ^^^^^^^^^^ 输出重定向到文件中.<br />
18<br />
19 exit 0<br />
################################End
Script#########################################</p>

<p>rdev<br />
取得root device, swap space, 或 video mode的相关信息, 或者对它们进行修改. 通常<br />
说来rdev都是被lilo所使用, 但是在建立一个ram disk的时候, 这个命令也很有用. 小心<br />
使用, 这是一个危险的命令.</p>

<p>模块类</p>

<p>lsmod<br />
列出所有安装的内核模块.</p>

<p>bash$ lsmod<br />
Module Size Used by<br />
autofs 9456 2 (autoclean)<br />
opl3 11376 0<br />
serial_cs 5456 0 (unused)<br />
sb 34752 0<br />
uart401 6384 0 [sb]<br />
sound 58368 0 [opl3 sb uart401]<br />
soundlow 464 0 [sound]<br />
soundcore 2800 6 [sb sound]<br />
ds 6448 2 [serial_cs]<br />
i82365 22928 2<br />
pcmcia_core 45984 0 [serial_cs ds i82365]</p>

<p>注意: 使用cat /proc/modules可以得到同样的结果.</p>

<p>insmod<br />
强制一个内核模块的安装(如果可能的话, 使用modprobe来代替) 必须以root身份调用.</p>

<p>rmmod<br />
强制卸载一个内核模块. 必须以root身份调用.</p>

<p>modprobe<br />
模块装载器, 一般情况下都是在启动脚本中自动调用. 必须以root身份调用.</p>

<p>depmod<br />
创建模块依赖文件, 一般都是在启动脚本中调用.</p>

<p>modinfo<br />
输出一个可装载模块的信息.</p>

<p>bash$ modinfo hid<br />
filename: /lib/modules/2.4.20-6/kernel/drivers/usb/hid.o<br />
description: &ldquo;USB HID support drivers&rdquo;<br />
author: &ldquo;Andreas Gal, Vojtech Pavlik &rdquo;<br />
license: &ldquo;GPL&rdquo;</p>

<p>杂项类</p>

<p>env<br />
使用设置过的或修改过(并不是修改整个系统环境)的环境变量来运行一个程序或脚本. 使<br />
用 [varname=xxx] 形式可以在脚本中修改环境变量. 如果没有指定参数, 那么这个命令<br />
将会列出所有设置的环境变量.</p>

<p>注意: 在Bash和其它的Bourne shell 衍生物中, 是可以在单一命令行上设置多个变量的.</p>

<p>1 var1=value1 var2=value2 commandXXX<br />
2 # $var1 和 $var2 只设置在&rsquo;commandXXX&rsquo;的环境中.</p>

<p>注意: 当不知道shell或解释器的路径的时候, 脚本的第一行(#!行)可以使用env.</p>

<p>1 #! /usr/bin/env perl<br />
2<br />
3 print &ldquo;This Perl script will run,\n&rdquo;;<br />
4 print &ldquo;even when I don&rsquo;t know where to find Perl.\n&rdquo;;<br />
5<br />
6 # 便于跨平台移植,<br />
7 # Perl程序可能没在期望的地方.<br />
8 # Thanks, S.C.</p>

<p>ldd<br />
显示一个可执行文件的共享库的依赖关系.</p>

<p>bash$ ldd /bin/ls<br />
libc.so.6 =&gt; /lib/libc.so.6 (0x4000c000)<br />
/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x80000000)</p>

<p>watch</p>

<p>以指定的时间间隔来重复运行一个命令.</p>

<p>默认的时间间隔是2秒, 但时刻以使用-n选项来修改.</p>

<p>1 watch -n 5 tail /var/log/messages<br />
2 # 每隔5秒钟显示系统log文件的结尾, /var/log/messages.</p>

<p>strip<br />
从可执行文件中去掉调试符号引用. 这样做可以减小尺寸, 但是就不能调试了.</p>

<p>这个命令一般都用在Makefile中, 但是很少用在shell脚本中.</p>

<p>nm<br />
列出未strip过的编译后的2进制文件的符号.</p>

<p>rdist<br />
远程文件分布客户机程序: 在远端服务器上同步, 克隆, 或者备份一个文件系统.</p>

<p>13.1 分析一个系统脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
利用我们所学到的关于管理命令的知识, 让我们一起来练习分析一个系统脚本. 最简单并<br />
且最短的系统脚本之一是killall, 这个脚本被用来在系统关机时挂起运行的脚本.</p>

<p>Example 13-11 killall, 来自于 /etc/rc.d/init.d<br />
################################Start
Script#######################################<br />
1 #!/bin/sh<br />
2<br />
3 # &ndash;&gt; 本书作者所作的注释全部以&rdquo;# &ndash;&gt;&ldquo;开头.<br />
4<br />
5 # &ndash;&gt; 这是由Miquel van Smoorenburg所编写的<br />
6 # &ndash;&gt; &lsquo;rc&rsquo;脚本包的一部分, .<br />
7<br />
8 # &ndash;&gt; 这个特殊的脚本看起来是是为Red Hat / FC所特定的,<br />
9 # &ndash;&gt; (在其它的发行版中可能不会出现).<br />
10<br />
11 # 停止所有正在运行的不必要的服务<br />
12 #+ (there shouldn&rsquo;t be any, so this is just a sanity check)<br />
13<br />
14 for i in /var/lock/subsys/*; do<br />
15 # &ndash;&gt; 标准的for/in循环, 但是由于&rdquo;do&rdquo;在同一行上,<br />
16 # &ndash;&gt; 所以必须添加&rdquo;;&ldquo;.<br />
17 # 检查脚本是否在那.<br />
18 [ ! -f $i ] &amp;&amp; continue<br />
19 # &ndash;&gt; 这是一种使用&rdquo;与列表&rdquo;的聪明的方法, 等价于:<br />
20 # &ndash;&gt; if [ ! -f &ldquo;$i&rdquo; ]; then continue<br />
21<br />
22 # 取得子系统的名字.<br />
23 subsys=${i#/var/lock/subsys/}<br />
24 # &ndash;&gt; 匹配变量名, 在这里就是文件名.<br />
25 # &ndash;&gt; 与subsys=<code>basename $i</code>完全等价.<br />
26<br />
27 # &ndash;&gt; 从锁定文件名中获得<br />
28 # &ndash;&gt;+ (如果那里有锁定文件的话,<br />
29 # &ndash;&gt;+ 那就证明进程正在运行).<br />
30 # &ndash;&gt; 参考一下上边所讲的&rdquo;锁定文件&rdquo;的内容.<br />
31<br />
32<br />
33 # 终止子系统.<br />
34 if [ -f /etc/rc.d/init.d/$subsys.init ]; then<br />
35 /etc/rc.d/init.d/$subsys.init stop<br />
36 else<br />
37 /etc/rc.d/init.d/$subsys stop<br />
38 # &ndash;&gt; 挂起运行的作业和幽灵进程.<br />
39 # &ndash;&gt; 注意&rdquo;stop&rdquo;只是一个位置参数,<br />
40 # &ndash;&gt;+ 并不是shell内建命令.<br />
41 fi<br />
42 done<br />
################################End
Script#########################################</p>

<p>这个没有那么糟. 除了在变量匹配的地方玩了一点花样, 其它也没有别的材料了.</p>

<p>练习 1. 在/etc/rc.d/init.d中, 分析halt脚本. 比脚本killall长一些, 但是概念上很相近.<br />
对这个脚本做一个拷贝, 放到你的home目录下并且用它练习一下(不要以root身份运<br />
行它). 使用-vn标志来模拟运行一下(sh -vn scriptname). 添加详细的注释. 将<br />
&ldquo;action&rdquo;命令修改为&rdquo;echos&rdquo;.</p>

<p>练习 2. 察看/etc/rc.d/init.d下的更多更复杂的脚本. 看看你是不是能够理解其中的一些脚<br />
本. 使用上边的过程来分析这些脚本. 为了更详细的理解, 你可能也需要分析在<br />
usr/share/doc/initscripts-?.??目录下的文件sysvinitfile, 这些都是<br />
&ldquo;initscript&rdquo;文件的一部分.</p>

<p>注意事项:<br />
[1] 这是在Linux机器上或者在带有磁盘配额的UNIX系统上的真实情况.<br />
[2] 如果正在被删除的特定的用户已经登录了主机, 那么 userdel 命令将会失败.<br />
[3] 对于烧录CDR的更多的细节, 可以参见Alex Withers的文章, 创建CD, 在<br />
Linux Journal 的1999年的10月文章列表中.<br />
[4] mke2fs的-c选项也会进行坏块检查.<br />
[5] 因为只有root用户才具有对/var/lock目录的写权限, 一般的用户脚本是不能在那里<br />
设置一个锁定文件的.<br />
[6] 单用户的Linux系统的操作更倾向于使用简单的备份工具, 比如tar.<br />
[7] NAND(与非)是一种逻辑操作. 这种操作的效果和减法很相像.</p>

<h1 id="第14章-命令替换">第14章 命令替换</h1>

<p>命令替换将会重新分配一个命令[1]甚至是多个命令的输出; 它会将命令的输出如实地添加到<br />
另一个上下文中. [2]<br />
使用命令替换的典型形式是使用后置引用(<code>...</code>). 后置引用形式的命令(就是被反引号括起来)<br />
将会产生命令行文本.</p>

<p>1 script_name=<code>basename $0</code><br />
2 echo &ldquo;The name of this script is $script_name.&rdquo;</p>

<p>这样的话, 命令的输出可以被当成传递到另一个命令的参数, 或者保存到变量中, 甚至可以用<br />
来产生for循环的参数列表.</p>

<p>1 rm <code>cat filename</code> # &ldquo;filename&rdquo; 包含了需要被删除的文件列表.<br />
2 #<br />
3 # S. C. 指出使用这种形式, 可能会产生&rdquo;参数列表太长&rdquo;的错误.<br />
4 # 更好的方法是 xargs rm &ndash; &lt; filename<br />
5 # ( &ndash; 同时覆盖了那些以&rdquo;-&ldquo;开头的文件所产生的特殊情况 )<br />
6<br />
7 textfile_listing=<code>ls *.txt</code><br />
8 # 变量中包含了当前工作目录下所有的*.txt文件.<br />
9 echo $textfile_listing<br />
10<br />
11 textfile_listing2=$(ls *.txt) # 这是命令替换的另一种形式.<br />
12 echo $textfile_listing2<br />
13 # 同样的结果.<br />
14<br />
15 # 将文件列表放入到一个字符串中的一个可能的问题就是<br />
16 # 可能会混进一个新行.<br />
17 #<br />
18 # 一个安全的将文件列表传递到参数中的方法就是使用数组.<br />
19 # shopt -s nullglob # 如果不匹配, 那就不进行文件名扩展.<br />
20 # textfile_listing=( *.txt )<br />
21 #<br />
22 # Thanks, S.C.</p>

<p>注意: 命令替换将会调用一个subshell.</p>

<p>注意: 命令替换可能会引起word splitting.<br />
1 COMMAND <code>echo a b</code> # 2个参数: a and b<br />
2<br />
3 COMMAND &ldquo;<code>echo a b</code>&rdquo; # 1个参数: &ldquo;a b&rdquo;<br />
4<br />
5 COMMAND <code>echo</code> # 无参数<br />
6<br />
7 COMMAND &ldquo;<code>echo</code>&rdquo; # 一个空的参数<br />
8<br />
9<br />
10 # Thanks, S.C.</p>

<p>即使没有引起word splitting, 命令替换也会去掉多余的新行.</p>

<p>1 # cd &ldquo;<code>pwd</code>&rdquo; # 这句总会正常的工作.<br />
2 # 然而&hellip;<br />
3<br />
4 mkdir &lsquo;dir with trailing newline<br />
5 &lsquo;<br />
6<br />
7 cd &lsquo;dir with trailing newline<br />
8 &lsquo;<br />
9<br />
10 cd &ldquo;<code>pwd</code>&rdquo; # 错误消息:<br />
11 # bash: cd: /tmp/file with trailing newline: No such file or directory<br />
12<br />
13 cd &ldquo;$PWD&rdquo; # 运行良好.<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19 old_tty_setting=$(stty -g) # 保存老的终端设置.<br />
20 echo &ldquo;Hit a key &rdquo;<br />
21 stty -icanon -echo # 对终端禁用&rdquo;canonical&rdquo;模式.<br />
22 # 这样的话, 也会禁用了*本地*的echo.<br />
23 key=$(dd bs=1 count=1 2&gt; /dev/null) # 使用&rsquo;dd&rsquo;命令来取得一个按键.<br />
24 stty &ldquo;$old_tty_setting&rdquo; # 保存老的设置.<br />
25 echo &ldquo;You hit ${#key} key.&rdquo; # ${#variable} = number of characters in
$variable<br />
26 #<br />
27 # 按键任何键除了回车, 那么输出就是&rdquo;You hit 1 key.&rdquo;<br />
28 # 按下回车, 那么输出就是&rdquo;You hit 0 key.&rdquo;<br />
29 # 新行已经被命令替换吃掉了.<br />
30<br />
31 Thanks, S.C.</p>

<p>注意: 当一个变量是使用命令替换的结果做为值的时候, 然后使用echo命令来输出这个变量<br />
(并且不引用这个变量, 就是不用引号括起来), 那么命令替换将会从最终的输出中删掉换<br />
行符. 这可能会引起一些异常情况.</p>

<p>1 dir_listing=<code>ls -l</code><br />
2 echo $dir_listing # 未引用, 就是没用引号括起来<br />
3<br />
4 # 想打出来一个有序的目录列表.Expecting a nicely ordered directory listing.<br />
5<br />
6 # 可惜, 下边将是我们所获得的:<br />
7 # total 3 -rw-rw-r&ndash; 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r&ndash; 1 bozo<br />
8 # bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh<br />
9<br />
10 # 新行消失了.<br />
11<br />
12<br />
13 echo &ldquo;$dir_listing&rdquo; # 用引号括起来<br />
14 # -rw-rw-r&ndash; 1 bozo 30 May 13 17:15 1.txt<br />
15 # -rw-rw-r&ndash; 1 bozo 51 May 15 20:57 t2.sh<br />
16 # -rwxr-xr-x 1 bozo 217 Mar 5 21:13 wi.sh</p>

<p>命令替换甚至允许将整个文件的内容放到变量中, 可以使用重定向或者cat命令.<br />
1 variable1=<code>2 variable2=</code>cat file2` # 将&rdquo;file2&rdquo;的内容放到&rdquo;variable2&rdquo;中.<br />
3 # 但是这行将会fork一个新进程, This, however, forks a new process,<br />
4 #+ 所以这行代码将会比第一行代码执行得慢.<br />
5<br />
6 # 注意:<br />
7 # 变量中是可以包含空白的,<br />
8 #+ 甚至是 (厌恶至极的), 控制字符.</p>

<p>1 # 摘录自系统文件, /etc/rc.d/rc.sysinit<br />
2 #+ (这是红帽安装中使用的)<br />
3<br />
4<br />
5 if [ -f /fsckoptions ]; then<br />
6 fsckoptions=<code>cat /fsckoptions</code><br />
7 &hellip;<br />
8 fi<br />
9 #<br />
10 #<br />
11 if [ -e &ldquo;/proc/ide/${disk[$device]}/media&rdquo; ] ; then<br />
12 hdmedia=<code>cat /proc/ide/${disk[$device]}/media</code><br />
13 &hellip;<br />
14 fi<br />
15 #<br />
16 #<br />
17 if [ ! -n &ldquo;<code>uname -r | grep -- &quot;-&quot;</code>&rdquo; ]; then<br />
18 ktag=&rdquo;<code>cat /proc/version</code>&rdquo;<br />
19 &hellip;<br />
20 fi<br />
21 #<br />
22 #<br />
23 if [ $usb = &ldquo;1&rdquo; ]; then<br />
24 sleep 5<br />
25 mouseoutput=<code>cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E
&quot;^I.*Cls=03.*Prot=02&quot;</code><br />
26 kbdoutput=<code>cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E
&quot;^I.*Cls=03.*Prot=01&quot;</code><br />
27 &hellip;<br />
28 fi</p>

<p>注意: 不要将一个非常长的文本文件的内容设置到一个变量中, 除非你有一个非常好的原因非<br />
要这么做不可. 不要将2进制文件的内容保存到变量中.</p>

<p>Example 14-1 愚蠢的脚本策略<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # stupid-script-tricks.sh: 朋友, 别在家这么做.<br />
3 # 来自于&rdquo;Stupid Script Tricks,&rdquo; 卷I.<br />
4<br />
5<br />
6 dangerous_variable=<code>cat /boot/vmlinuz</code> # 这是压缩过的Linux内核本身.<br />
7<br />
8 echo &ldquo;string-length of \$dangerous_variable = ${#dangerous_variable}&rdquo;<br />
9 # 这个字符串变量的长度是 $dangerous_variable = 794151<br />
10 # (不要使用&rsquo;wc -c /boot/vmlinuz&rsquo;来计算长度.)<br />
11<br />
12 # echo &ldquo;$dangerous_variable&rdquo;<br />
13 # 千万别尝试这么做! 这样将挂起这个脚本.<br />
14<br />
15<br />
16 # 文档作者已经意识到将二进制文件设置到<br />
17 #+ 变量中是一个没用的应用.<br />
18<br />
19 exit 0<br />
################################End
Script#########################################<br />
注意, 在这里是不会发生缓冲区溢出错误. 因为这是一个解释型语言的实例, Bash就是一<br />
种解释型语言, 解释型语言会比编译型语言提供更多的对程序错误的保护措施.</p>

<p>变量替换允许将一个循环的输出放入到一个变量中.这么做的关键就是将循环中echo命令的输<br />
出全部截取.</p>

<p>Example 14-2 从循环的输出中产生一个变量<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # csubloop.sh: 从循环的输出中产生一个变量.<br />
3<br />
4 variable1=<code>for i in 1 2 3 4 5  
5 do  
6 echo -n &quot;$i&quot; # 对于这里的命令替换来说  
7 done</code> #+ 这个&rsquo;echo&rsquo;命令是非常关键的.<br />
8<br />
9 echo &ldquo;variable1 = $variable1&rdquo; # variable1 = 12345<br />
10<br />
11<br />
12 i=0<br />
13 variable2=<code>while [ &quot;$i&quot; -lt 10 ]  
14 do  
15 echo -n &quot;$i&quot; # 再来一个, 'echo'是必须的.  
16 let &quot;i += 1&quot; # 递增.  
17 done</code><br />
18<br />
19 echo &ldquo;variable2 = $variable2&rdquo; # variable2 = 0123456789<br />
20<br />
21 # 这就证明了在一个变量声明中<br />
22 #+ 嵌入一个循环是可行的.<br />
23<br />
24 exit 0<br />
################################End
Script#########################################</p>

<p>注意: 命令替换使得扩展有效的Bash工具集变为可能. 这样, 写一段小程序或者一段脚本就可<br />
以达到目的, 因为程序或脚本的输出会传到stdout上(就像一个标准的工具所做的那样),<br />
然后重新将这些输出保存到变量中.(译者: 作者的意思就是在这种情况下写脚本和写程序<br />
作用是一样的.)</p>

<p>1 #include<br />
2<br />
3 /* &ldquo;Hello, world.&rdquo; C program */<br />
4<br />
5 int main()<br />
6 {<br />
7 printf( &ldquo;Hello, world.&rdquo; );<br />
8 return (0);<br />
9 }</p>

<p>bash$ gcc -o hello hello.c</p>

<p>1 #!/bin/bash<br />
2 # hello.sh<br />
3<br />
4 greeting=<code>./hello</code><br />
5 echo $greeting</p>

<p>bash$ sh hello.sh<br />
Hello, world.</p>

<p>注意: 对于命令替换来说,$(COMMAND) 形式已经取代了反引号&rdquo;`&ldquo;.</p>

<p>1 output=$(sed -n /&ldquo;$1&rdquo;/p $file) # 来自于 &ldquo;grp.sh&rdquo;例子.<br />
2<br />
3 # 将一个文本的内容保存到变量中.<br />
4 File_contents1=$(cat $file1)<br />
5 File_contents2=$(</p>

<p>$(&hellip;) 形式的命令替换在处理双反斜线(\\)时与<code>...</code>形式不同.</p>

<p>bash$ echo <code>echo \\\\</code></p>

<p>bash$ echo $(echo \\)<br />
</p>

<p>$(&hellip;) 形式的命令替换是允许嵌套的. [3]</p>

<p>1 word_count=$( wc -w $(ls -l | awk &lsquo;{print $9}&rsquo;) )</p>

<p>或者, 可以更加灵活&hellip;</p>

<p>Example 14-3 找anagram(回文构词法, 可以将一个有意义的单词, 变换为1个或多个有意义的单词, 但是还是原来的子母集合)<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # agram2.sh<br />
3 # 关于命令替换嵌套的例子.<br />
4<br />
5 # 使用&rdquo;anagram&rdquo;工具<br />
6 #+ 这是作者的&rdquo;yawl&rdquo;文字表包中的一部分.<br />
7 # <a href="http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz">http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz</a><br />
8 # <a href="http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz">http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz</a><br />
9<br />
10 E_NOARGS=66<br />
11 E_BADARG=67<br />
12 MINLEN=7<br />
13<br />
14 if [ -z &ldquo;$1&rdquo; ]<br />
15 then<br />
16 echo &ldquo;Usage $0 LETTERSET&rdquo;<br />
17 exit $E_NOARGS # 脚本需要一个命令行参数.<br />
18 elif [ ${#1} -lt $MINLEN ]<br />
19 then<br />
20 echo &ldquo;Argument must have at least $MINLEN letters.&rdquo;<br />
21 exit $E_BADARG<br />
22 fi<br />
23<br />
24<br />
25<br />
26 FILTER=&lsquo;&hellip;&hellip;.&rsquo; # 必须至少有7个字符.<br />
27 # 1234567<br />
28 Anagrams=( $(echo $(anagram $1 | grep $FILTER) ) )<br />
29 # | | 嵌套的命令替换 | |<br />
30 # ( 数组分配 )<br />
31<br />
32 echo<br />
33 echo &ldquo;${#Anagrams[<em>]} 7+ letter anagrams found&rdquo;<br />
34 echo<br />
35 echo ${Anagrams[0]} # 第一个anagram.<br />
36 echo ${Anagrams[1]} # 第二个anagram.<br />
37 # 等等.<br />
38<br />
39 # echo &ldquo;${Anagrams[</em>]}&rdquo; # 在一行上列出所有的anagram &hellip;<br />
40<br />
41 # 考虑到后边还有&rdquo;数组&rdquo;作为单独的一章进行讲解,<br />
42 #+ 这里就不深入了.<br />
43<br />
44 # 可以参阅agram.sh脚本, 这也是一个找出anagram的例子.<br />
45<br />
46 exit $?<br />
################################End
Script#########################################</p>

<p>命令替换在脚本中使用的例子:</p>

<p>1. Example 10-7<br />
2. Example 10-26<br />
3. Example 9-28<br />
4. Example 12-3<br />
5. Example 12-19<br />
6. Example 12-15<br />
7. Example 12-49<br />
8. Example 10-13<br />
9. Example 10-10<br />
10. Example 12-29<br />
11. Example 16-8<br />
12. Example A-17<br />
13. Example 27-2<br />
14. Example 12-42<br />
15. Example 12-43<br />
16. Example 12-44</p>

<p>注意事项:<br />
[1] 对于命令替换来说, 这个命令可以是外部的系统命令, 也可以是内部脚本的内建<br />
命令, 甚至是一个脚本函数.<br />
[2] 从技术的角度来讲, 命令替换将会抽取出一个命令的输出, 然后使用=操作赋值到<br />
一个变量中.<br />
[3] 事实上, 对于反引号的嵌套是可行的, 但是只能将内部的反引号转义才行, 就像<br />
John默认指出的那样.<br />
1 word_count=<code>wc -w \\</code>ls -l | awk &lsquo;{print $9}&rsquo;\</p>

<h1 id="第15章-算术扩展">第15章 算术扩展</h1>

<p>算术扩展提供了一种强力的工具, 可以在脚本中执行(整型)算法操作. 可以使用backticks,<br />
double parentheses, 或 let来将字符串转换为数字表达式.</p>

<p>一些变化</p>

<p>使用反引号的算术扩展(通常都是和expr一起使用)</p>

<p>1 z=<code>expr $z + 3</code> # &lsquo;expr&rsquo;命令将会执行这个扩展.</p>

<p>使用双括号, 和let形式的算术扩展</p>

<p>反引号形式的算术扩展已经被双括号形式所替代了 &ndash; ((&hellip;)) 和 $((&hellip;)) &ndash; 当然也可以<br />
使用非常方便的let形式.</p>

<p>1 z=$(($z+3))<br />
2 z=$((z+3)) # 也正确.<br />
3 # 使用双括号的形式,<br />
4 #+ 参数解引用<br />
5 #+ 是可选的.<br />
6<br />
7 # $((EXPRESSION)) is arithmetic expansion. # 不要与命令<br />
8 #+ 替换相混淆.<br />
9<br />
10<br />
11<br />
12 # 使用双括号的形式也可以不用给变量赋值.<br />
13<br />
14 n=0<br />
15 echo &ldquo;n = $n&rdquo; # n = 0<br />
16<br />
17 (( n += 1 )) # 递增.<br />
18 # (( $n += 1 )) is incorrect!<br />
19 echo &ldquo;n = $n&rdquo; # n = 1<br />
20<br />
21<br />
22 let z=z+3<br />
23 let &ldquo;z += 3&rdquo; # 使用引用的形式, 允许在变量赋值的时候存在空格.<br />
24 # &lsquo;let&rsquo;操作事实上执行得的是算术赋值,<br />
25 #+ 而不是算术扩展.</p>

<p>下边是一些在脚本中使用算术扩展的例子:</p>

<p>1. Example 12-9<br />
2. Example 10-14<br />
3. Example 26-1<br />
4. Example 26-11<br />
5. Example A-17</p>

<h1 id="第16章-i-o-重定向">第16章 I/O 重定向</h1>

<p>默认情况下始终有3个&rdquo;文件&rdquo;处于打开状态, stdin (键盘), stdout (屏幕), and stderr<br />
(错误消息输出到屏幕上). 这3个文件和其他打开的文件都可以被重定向. 对于重定向简单的<br />
解释就是捕捉一个文件, 命令, 程序, 脚本, 或者甚至是脚本中的代码块(参见 Example 3-1<br />
和 Example 3-2)的输出, 然后将这些输出作为输入发送到另一个文件, 命令, 程序, 或脚本<br />
中.<br />
每个打开的文件都会被分配一个文件描述符.[1]stdin, stdout, 和stderr的文件描述符分别<br />
是0, 1, 和 2. 对于正在打开的额外文件, 保留了描述符3到9. 在某些时候将这些格外的文件<br />
描述符分配给stdin, stdout, 或者是stderr作为临时的副本链接是非常有用的. [2] 在经过<br />
复杂的重定向和刷新之后需要把它们恢复成正常的样子 (参见 Example 16-1).</p>

<p>1 COMMAND_OUTPUT &gt;<br />
2 # 重定向stdout到一个文件.<br />
3 # 如果没有这个文件就创建, 否则就覆盖.<br />
4<br />
5 ls -lR &gt; dir-tree.list<br />
6 # 创建一个包含目录树列表的文件.<br />
7<br />
8 : &gt; filename<br />
9 # &gt; 会把文件&rdquo;filename&rdquo;截断为0长度.<br />
10 # 如果文件不存在, 那么就创建一个0长度的文件(与&rsquo;touch&rsquo;的效果相同).<br />
11 # : 是一个占位符, 不产生任何输出.<br />
12<br />
13 &gt; filename<br />
14 # &gt; 会把文件&rdquo;filename&rdquo;截断为0长度.<br />
15 # 如果文件不存在, 那么就创建一个0长度的文件(与&rsquo;touch&rsquo;的效果相同).<br />
16 # (与上边的&rdquo;: &gt;&ldquo;效果相同, 但是在某些shell下可能不能工作.)<br />
17<br />
18 COMMAND_OUTPUT &gt;&gt;<br />
19 # 重定向stdout到一个文件.<br />
20 # 如果文件不存在, 那么就创建它, 如果存在, 那么就追加到文件后边.<br />
21<br />
22<br />
23 # 单行重定向命令(只会影响它们所在的行):<br />
24 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
25<br />
26 1&gt;filename<br />
27 # 重定向stdout到文件&rdquo;filename&rdquo;.<br />
28 1&gt;&gt;filename<br />
29 # 重定向并追加stdout到文件&rdquo;filename&rdquo;.<br />
30 2&gt;filename<br />
31 # 重定向stderr到文件&rdquo;filename&rdquo;.<br />
32 2&gt;&gt;filename<br />
33 # 重定向并追加stderr到文件&rdquo;filename&rdquo;.<br />
34 &amp;&gt;filename<br />
35 # 将stdout和stderr都重定向到文件&rdquo;filename&rdquo;.<br />
36<br />
37
#==============================================================================<br />
38 # 重定向stdout, 一次一行.<br />
39 LOGFILE=script.log<br />
40<br />
41 echo &ldquo;This statement is sent to the log file, \&ldquo;$LOGFILE\&ldquo;.&rdquo; 1&gt;$LOGFILE<br />
42 echo &ldquo;This statement is appended to \&ldquo;$LOGFILE\&ldquo;.&rdquo; 1&gt;&gt;$LOGFILE<br />
43 echo &ldquo;This statement is also appended to \&ldquo;$LOGFILE\&ldquo;.&rdquo; 1&gt;&gt;$LOGFILE<br />
44 echo &ldquo;This statement is echoed to stdout, and will not appear in
\&ldquo;$LOGFILE\&ldquo;.&rdquo;<br />
45 # 每行过后, 这些重定向命令会自动&rdquo;reset&rdquo;.<br />
46<br />
47<br />
48<br />
49 # 重定向stderr, 一次一行.<br />
50 ERRORFILE=script.errors<br />
51<br />
52 bad_command1 2&gt;$ERRORFILE # 错误消息发到$ERRORFILE中.<br />
53 bad_command2 2&gt;&gt;$ERRORFILE # 错误消息添加到$ERRORFILE中.<br />
54 bad_command3 # 错误消息echo到stderr,<br />
55 #+ 并且不出现在$ERRORFILE中.<br />
56 # 每行过后, 这些重定向命令也会自动&rdquo;reset&rdquo;.<br />
57
#==============================================================================<br />
58<br />
59<br />
60<br />
61 2&gt;&amp;1<br />
62 # 重定向stderr到stdout.<br />
63 # 得到的错误消息与stdout一样, 发送到一个地方.<br />
64<br />
65 i&gt;&amp;j<br />
66 # 重定向文件描述符i 到 j.<br />
67 # 指向i文件的所有输出都发送到j中去.<br />
68<br />
69 &gt;&amp;j<br />
70 # 默认的, 重定向文件描述符1(stdout)到 j.<br />
71 # 所有传递到stdout的输出都送到j中去.<br />
72<br />
73 0&lt; FILENAME<br />
74 &lt; FILENAME<br />
75 # 从文件中接受输入.<br />
76 # 与&rdquo;&gt;&ldquo;是成对命令, 并且通常都是结合使用.<br />
77 #<br />
78 # grep search-word  79<br />
80<br />
81 [j]&lt;&gt;filename<br />
82 # 为了读写&rdquo;filename&rdquo;, 把文件&rdquo;filename&rdquo;打开, 并且分配文件描述符&rdquo;j&rdquo;给它.<br />
83 # 如果文件&rdquo;filename&rdquo;不存在, 那么就创建它.<br />
84 # 如果文件描述符&rdquo;j&rdquo;没指定, 那默认是fd 0, stdin.<br />
85 #<br />
86 # 这种应用通常是为了写到一个文件中指定的地方.<br />
87 echo 1234567890 &gt; File # 写字符串到&rdquo;File&rdquo;.<br />
88 exec 3&lt;&gt; File # 打开&rdquo;File&rdquo;并且给它分配fd 3.<br />
89 read -n 4 90 echo -n . &gt;&amp;3 # 写一个小数点.<br />
91 exec 3&gt;&amp;- # 关闭fd 3.<br />
92 cat File # ==&gt; 1234.67890<br />
93 # 随机存储.<br />
94<br />
95<br />
96<br />
97 |<br />
98 # 管道.<br />
99 # 通用目的的处理和命令链工具.<br />
100 # 与&rdquo;&gt;&ldquo;很相似, 但是实际上更通用.<br />
101 # 对于想将命令, 脚本, 文件和程序串连起来的时候很有用.<br />
102 cat *.txt | sort | uniq &gt; result-file<br />
103 # 对所有的.txt文件的输出进行排序, 并且删除重复行,<br />
104 # 最后将结果保存到&rdquo;result-file&rdquo;中.</p>

<p>可以将输入输出重定向和(或)管道的多个实例结合到一起写在一行上.</p>

<p>1 command &lt; input-file &gt; output-file<br />
2<br />
3 command1 | command2 | command3 &gt; output-file<br />
参见 Example 12-28 和 Example A-15.</p>

<p>可以将多个输出流重定向到一个文件上.</p>

<p>1 ls -yz &gt;&gt; command.log 2&gt;&amp;1<br />
2 # 将错误选项&rdquo;yz&rdquo;的结果放到文件&rdquo;command.log&rdquo;中.<br />
3 # 因为stderr被重定向到这个文件中,<br />
4 #+ 所有的错误消息也就都指向那里了.<br />
5<br />
6 # 注意, 下边这个例子就不会给出相同的结果.<br />
7 ls -yz 2&gt;&amp;1 &gt;&gt; command.log<br />
8 # 输出一个错误消息, 但是并不写到文件中.<br />
9<br />
10 # 如果将stdout和stderr都重定向,<br />
11 #+ 命令的顺序会有些不同.</p>

<p>关闭文件描述符</p>

<p>n 0 n&gt;&amp;- 关闭输出文件描述符n.<br />
1&gt;&amp;-, &gt;&amp;- 关闭stdout.</p>

<p>子进程继承了打开的文件描述符. 这就是为什么管道可以工作. 如果想阻止fd被继承, 那么可<br />
以关掉它.</p>

<p>1 # 只重定向stderr到一个管道.<br />
2<br />
3 exec 3&gt;&amp;1 # 保存当前stdout的&rdquo;值&rdquo;.<br />
4 ls -l 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | grep bad 3&gt;&amp;- # 对&rsquo;grep&rsquo;关闭fd 3(但不关闭&rsquo;ls&rsquo;).<br />
5 # ^^^^ ^^^^<br />
6 exec 3&gt;&amp;- # 现在对于剩余的脚本关闭它.<br />
7<br />
8 # Thanks, S.C.</p>

<p>如果想了解关于I/O重定向更多的细节参见 附录 E.</p>

<p>16.1. 使用exec<br />
-&mdash;&mdash;&mdash;&mdash;-<br />
exec  件了, 而不是标准输入了(通常都是键盘输入). 这样就提供了一种按行读取文件的方法, 并且<br />
可以使用sed 和/或 awk来对每一行进行分析.</p>

<p>Example 16-1 使用exec重定向标准输入<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 使用&rsquo;exec&rsquo;重定向标准输入.<br />
3<br />
4<br />
5 exec 6 6 # 保存了stdin.<br />
7<br />
8 exec &lt; data-file # stdin被文件&rdquo;data-file&rdquo;所代替.<br />
9<br />
10 read a1 # 读取文件&rdquo;data-file&rdquo;的第一行.<br />
11 read a2 # 读取文件&rdquo;data-file&rdquo;的第二行.<br />
12<br />
13 echo<br />
14 echo &ldquo;Following lines read from file.&rdquo;<br />
15 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
16 echo $a1<br />
17 echo $a2<br />
18<br />
19 echo; echo; echo<br />
20<br />
21 exec 0 22 # 现在将stdin从fd #6中恢复, 因为刚才我们把stdin重定向到#6了,<br />
23 #+ 然后关闭fd #6 ( 6 24 #<br />
25 # 26<br />
27 echo -n &ldquo;Enter data &rdquo;<br />
28 read b1 # 现在&rdquo;read&rdquo;已经恢复正常了, 就是从stdin中读取.<br />
29 echo &ldquo;Input read from stdin.&rdquo;<br />
30 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
31 echo &ldquo;b1 = $b1&rdquo;<br />
32<br />
33 echo<br />
34<br />
35 exit 0<br />
################################End
Script#########################################</p>

<p>同样的, exec &gt;filename 命令将会把stdout重定向到一个指定的文件中. 这样所有的命令输<br />
出就都会发向那个指定的文件, 而不是stdout.</p>

<p>Example 16-2 使用exec来重定向stdout<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # reassign-stdout.sh<br />
3<br />
4 LOGFILE=logfile.txt<br />
5<br />
6 exec 6&gt;&amp;1 # 将fd #6与stdout相连接.<br />
7 # 保存stdout.<br />
8<br />
9 exec &gt; $LOGFILE # stdout就被文件&rdquo;logfile.txt&rdquo;所代替了.<br />
10<br />
11 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; #<br />
12 # 在这块中所有命令的输出就都发向文件 $LOGFILE.<br />
13<br />
14 echo -n &ldquo;Logfile: &ldquo;<br />
15 date<br />
16 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
17 echo<br />
18<br />
19 echo &ldquo;Output of \&ldquo;ls -al\&rdquo; command&rdquo;<br />
20 echo<br />
21 ls -al<br />
22 echo; echo<br />
23 echo &ldquo;Output of \&ldquo;df\&rdquo; command&rdquo;<br />
24 echo<br />
25 df<br />
26<br />
27 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; #<br />
28<br />
29 exec 1&gt;&amp;6 6&gt;&amp;- # 恢复stdout, 然后关闭文件描述符#6.<br />
30<br />
31 echo<br />
32 echo &ldquo;== stdout now restored to default == &rdquo;<br />
33 echo<br />
34 ls -al<br />
35 echo<br />
36<br />
37 exit 0<br />
################################End
Script#########################################</p>

<p>Example 16-3 使用exec在同一脚本中重定向stdin和stdout<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # upperconv.sh<br />
3 # 将一个指定的输入文件转换为大写.<br />
4<br />
5 E_FILE_ACCESS=70<br />
6 E_WRONG_ARGS=71<br />
7<br />
8 if [ ! -r &ldquo;$1&rdquo; ] # 判断指定的输入文件是否可读?<br />
9 then<br />
10 echo &ldquo;Can&rsquo;t read from input file!&rdquo;<br />
11 echo &ldquo;Usage: $0 input-file output-file&rdquo;<br />
12 exit $E_FILE_ACCESS<br />
13 fi # 即使输入文件($1)没被指定<br />
14 #+ 也还是会以相同的错误退出(为什么?).<br />
15<br />
16 if [ -z &ldquo;$2&rdquo; ]<br />
17 then<br />
18 echo &ldquo;Need to specify output file.&rdquo;<br />
19 echo &ldquo;Usage: $0 input-file output-file&rdquo;<br />
20 exit $E_WRONG_ARGS<br />
21 fi<br />
22<br />
23<br />
24 exec 4 25 exec &lt; $1 # 将会从输入文件中读取.<br />
26<br />
27 exec 7&gt;&amp;1<br />
28 exec &gt; $2 # 将写到输出文件中.<br />
29 # 假设输出文件是可写的(添加检查?).<br />
30<br />
31 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
32 cat - | tr a-z A-Z # 转换为大写.<br />
33 # ^^^^^ # 从stdin中读取.Reads from stdin.<br />
34 # ^^^^^^^^^^ # 写到stdout上.<br />
35 # 然而, stdin和stdout都被重定向了.<br />
36 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
37<br />
38 exec 1&gt;&amp;7 7&gt;&amp;- # 恢复 stout.<br />
39 exec 0 40<br />
41 # 恢复之后, 下边这行代码将会如期望的一样打印到stdout上.<br />
42 echo &ldquo;File \&ldquo;$1\&rdquo; written to \&ldquo;$2\&rdquo; as uppercase conversion.&rdquo;<br />
43<br />
44 exit 0<br />
################################End
Script#########################################</p>

<p>I/O重定向是一种避免可怕的子shell中不可存取变量问题的方法.</p>

<p>Example 16-4 避免子shell<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # avoid-subshell.sh<br />
3 # Matthew Walker提出的建议.<br />
4<br />
5 Lines=0<br />
6<br />
7 echo<br />
8<br />
9 cat myfile.txt | while read line; # (译者注: 管道会产生子shell)<br />
10 do {<br />
11 echo $line<br />
12 (( Lines++ )); # 增加这个变量的值<br />
13 #+ 但是外部循环却不能存取.<br />
14 # 子shell问题.<br />
15 }<br />
16 done<br />
17<br />
18 echo &ldquo;Number of lines read = $Lines&rdquo; # 0<br />
19 # 错误!<br />
20<br />
21 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
22<br />
23<br />
24 exec 3&lt;&gt; myfile.txt<br />
25 while read line 26 do {<br />
27 echo &ldquo;$line&rdquo;<br />
28 (( Lines++ )); # 增加这个变量的值<br />
29 #+ 现在外部循环就可以存取了.<br />
30 # 没有子shell, 现在就没问题了.<br />
31 }<br />
32 done<br />
33 exec 3&gt;&amp;-<br />
34<br />
35 echo &ldquo;Number of lines read = $Lines&rdquo; # 8<br />
36<br />
37 echo<br />
38<br />
39 exit 0<br />
40<br />
41 # 下边这些行是脚本的结果, 脚本是不会走到这里的.<br />
42<br />
43 $ cat myfile.txt<br />
44<br />
45 Line 1.<br />
46 Line 2.<br />
47 Line 3.<br />
48 Line 4.<br />
49 Line 5.<br />
50 Line 6.<br />
51 Line 7.<br />
52 Line 8.<br />
################################End
Script#########################################</p>

<p>注意事项:<br />
[1] 一个文件描述符说白了就是文件系统为了跟踪这个打开的文件而分配给它的一个数字.<br />
也可以的将其理解为文件指针的一个简单版本. 与C中的文件句柄的概念相似.<br />
[2] 使用文件描述符5可能会引起问题. 当Bash使用exec创建一个子进程的时候, 子进程<br />
会继承fd5(参见Chet Ramey的归档e-mail, SUBJECT: RE: File descriptor 5 is<br />
held open). 最好还是不要去招惹这个特定的fd.</p>

<h1 id="第17章-here-documents">第17章 Here Documents</h1>

<p>here document 就是一段特殊目的的代码块. 他使用I/O 重定向的形式来将一个命令序列传递<br />
到一个交互程序或者命令中, 比如ftp, cat, 或者ex文本编辑器.</p>

<p>1 COMMAND &lt; 2 &hellip;<br />
3 InputComesFromHERE</p>

<p>limit string 用来划定命令序列的范围(译者注: 两个相同的limit string之间就是命令序列)<br />
. 特殊符号 &lt;&lt; 用来表识limit string. 这个符号具有重定向文件的输出到程序或命令的输入<br />
的作用. 与 interactive-program &lt; command-file 很相象, command-file包含:</p>

<p>1 command #1<br />
2 command #2<br />
3 &hellip;</p>

<p>而here document 的形式看上去是如下的样子:</p>

<p>1 #!/bin/bash<br />
2 interactive-program &lt; 3 command #1<br />
4 command #2<br />
5 &hellip;<br />
6 LimitString</p>

<p>选择一个名字非常诡异的limit string将会避免命令列表和limit string重名的问题.</p>

<p>注意,某些时候here document 用在非交互工具和命令上的时候也会有好的效果, 比如, wall.</p>

<p>Example 17-1 广播: 发送消息给每个登录上的用户<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 wall &lt; 4 E-mail your noontime orders for pizza to the system administrator.<br />
5 (Add an extra dollar for anchovy or mushroom topping.)<br />
6 # 额外的消息文本写在这里.<br />
7 # 注意: &lsquo;wall&rsquo; 会打印注释行.<br />
8 zzz23EndOfMessagezzz23<br />
9<br />
10 # 可以使用更有效率的做法<br />
11 # wall  12 # 然而将消息模版嵌入到脚本中<br />
13 #+ 是一种&rdquo;小吃店&rdquo;(快速但是比较脏)的只能使用一次的解决办法.<br />
14<br />
15 exit 0<br />
################################End
Script#########################################</p>

<p>即使是某些不大可能的工具, 如vi也可以使用here document.</p>

<p>Example 17-2 仿造文件: 创建一个两行的仿造文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 用非交互的方式来使用&rsquo;vi&rsquo;编辑一个文件.<br />
4 # 模仿&rsquo;sed&rsquo;.<br />
5<br />
6 E_BADARGS=65<br />
7<br />
8 if [ -z &ldquo;$1&rdquo; ]<br />
9 then<br />
10 echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
11 exit $E_BADARGS<br />
12 fi<br />
13<br />
14 TARGETFILE=$1<br />
15<br />
16 # 在文件中插入两行, 然后保存.<br />
17 #&mdash;&mdash;&ndash;Begin here document&mdash;&mdash;&mdash;&ndash;#<br />
18 vi $TARGETFILE &lt; 19 i<br />
20 This is line 1 of the example file.<br />
21 This is line 2 of the example file.<br />
22 ^[<br />
23 ZZ<br />
24 x23LimitStringx23<br />
25 #&mdash;&mdash;&mdash;-End here document&mdash;&mdash;&mdash;&ndash;#<br />
26<br />
27 # 注意上边^[是一个转义符,键入Ctrl+v 就行,<br />
28 #+ 事实上它是键.<br />
29<br />
30 # Bram Moolenaar指出这种方法不能正常地用在&rsquo;vim&rsquo;上, (译者注: Bram Moolenaar是vim作者)<br />
31 #+ 因为可能会有终端的相互影响问题.<br />
32<br />
33 exit 0<br />
################################End
Script#########################################</p>

<p>上边的脚本也可以不用vi而用ex来实现. Here document 包含ex命令列表的做法足够形成自己<br />
的类别了, 叫ex scripts.</p>

<p>1 #!/bin/bash<br />
2 # 把所有后缀为&rdquo;.txt&rdquo;文件<br />
3 #+ 中的&rdquo;Smith&rdquo;都替换成&rdquo;Jones&rdquo;.<br />
4<br />
5 ORIGINAL=Smith<br />
6 REPLACEMENT=Jones<br />
7<br />
8 for word in $(fgrep -l $ORIGINAL *.txt)<br />
9 do<br />
10 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
11 ex $word &lt; 12 :%s/$ORIGINAL/$REPLACEMENT/g<br />
13 :wq<br />
14 EOF<br />
15 # :%s 是&rdquo;ex&rdquo;的替换命令.<br />
16 # :wq 是保存并退出的意思.<br />
17 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
18 done</p>

<p>与&rdquo;ex scripts&rdquo;相似的是cat scripts.</p>

<p>Example 17-3 使用cat的多行消息<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # &lsquo;echo&rsquo; 对于打印单行消息是非常好的,<br />
4 #+ 但是在打印消息块时可能就有点问题了.<br />
5 # &lsquo;cat&rsquo; here document可以解决这个限制.<br />
6<br />
7 cat &lt; 8 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
9 This is line 1 of the message.<br />
10 This is line 2 of the message.<br />
11 This is line 3 of the message.<br />
12 This is line 4 of the message.<br />
13 This is the last line of the message.<br />
14 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
15 End-of-message<br />
16<br />
17 # 用下边这行代替上边的第7行<br />
18 #+ cat &gt; $Newfile &lt; 19 #+ ^^^^^^^^^^<br />
20 #+ 那么就会把输出写到文件$Newfile中, 而不是stdout.<br />
21<br />
22 exit 0<br />
23<br />
24<br />
25 #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
26 # 下边的代码不会运行, 因为上边的&rdquo;exit 0&rdquo;.<br />
27<br />
28 # S.C. 指出下边代码也可以运行.<br />
29 echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
30 This is line 1 of the message.<br />
31 This is line 2 of the message.<br />
32 This is line 3 of the message.<br />
33 This is line 4 of the message.<br />
34 This is the last line of the message.<br />
35 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
36 # 然而, 文本可能不包含双引号, 除非它们被转义.<br />
################################End
Script#########################################</p>

<p>- 选项用来标记here document的limit string (&lt; (不是空格). 这可以增加一个脚本的可读性.</p>

<p>Example 17-4 带有抑制tab功能的多行消息<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 与之前的例子相同, 但是&hellip;<br />
3<br />
4 # - 选项对于here docutment来说,&lt; 5 #+ 可以抑制文档体前边的tab,<br />
6 #+ 而*不*是空格 <em>not</em> spaces.<br />
7<br />
8 cat &lt; 9 This is line 1 of the message.<br />
10 This is line 2 of the message.<br />
11 This is line 3 of the message.<br />
12 This is line 4 of the message.<br />
13 This is the last line of the message.<br />
14 ENDOFMESSAGE<br />
15 # 脚本在输出的时候左边将被刷掉.<br />
16 # 就是说每行前边的tab将不会显示.<br />
17<br />
18 # 上边5行&rdquo;消息&rdquo;的前边都是tab, 不是空格.<br />
19 # 空格是不受&lt; 20<br />
21 # 注意, 这个选项对于*嵌在*中间的tab没作用.<br />
22<br />
23 exit 0<br />
################################End
Script#########################################</p>

<p>here document 支持参数和命令替换. 所以也可以给here document的消息体传递不同的参数,<br />
这样相应的也会修改输出.</p>

<p>Example 17-5 使用参数替换的here document<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 一个使用&rsquo;cat&rsquo;命令的here document, 使用了参数替换<br />
3<br />
4 # 不传命令行参数给它, ./scriptname<br />
5 # 传一个命令行参数给它, ./scriptname Mortimer<br />
6 # 传一个2个单词(用引号括起来)的命令行参数给它,<br />
7 # ./scriptname &ldquo;Mortimer Jones&rdquo;<br />
8<br />
9 CMDLINEPARAM=1 # 所期望的最少的命令行参数的个数.<br />
10<br />
11 if [ $# -ge $CMDLINEPARAM ]<br />
12 then<br />
13 NAME=$1 # 如果命令行参数超过1个,<br />
14 #+ 那么就只取第一个参数.<br />
15 else<br />
16 NAME=&ldquo;John Doe&rdquo; # 默认情况下, 如果没有命令行参数的话.<br />
17 fi<br />
18<br />
19 RESPONDENT=&ldquo;the author of this fine script&rdquo;<br />
20<br />
21<br />
22 cat &lt; 23<br />
24 Hello, there, $NAME.<br />
25 Greetings to you, $NAME, from $RESPONDENT.<br />
26<br />
27 # This comment shows up in the output (why?).<br />
28<br />
29 Endofmessage<br />
30<br />
31 # 注意上边的空行也打印到输出,<br />
32 # 而上边那行&rdquo;注释&rdquo;当然也会打印到输出.<br />
33 # (译者注: 这就是为什么不翻译那行注释的原因, 尽量保持原代码的原样)<br />
34 exit 0<br />
################################End
Script#########################################</p>

<p>这是一个包含参数替换的here document的有用的脚本.</p>

<p>Example 17-6 上传一个文件对到&rdquo;Sunsite&rdquo;的incoming目录<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # upload.sh<br />
3<br />
4 # 上传文件对(Filename.lsm, Filename.tar.gz)<br />
5 #+ 到Sunsite/UNC (ibiblio.org)的incoming目录.<br />
6 # Filename.tar.gz是自身的tar包.<br />
7 # Filename.lsm是描述文件.<br />
8 # Sunsite需要&rdquo;lsm&rdquo;文件, 否则就拒绝贡献.<br />
9<br />
10<br />
11 E_ARGERROR=65<br />
12<br />
13 if [ -z &ldquo;$1&rdquo; ]<br />
14 then<br />
15 echo &ldquo;Usage: <code>basename $0</code> Filename-to-upload&rdquo;<br />
16 exit $E_ARGERROR<br />
17 fi<br />
18<br />
19<br />
20 Filename=<code>basename $1</code> # 从文件名中去掉目录字符串.<br />
21<br />
22 Server=&ldquo;ibiblio.org&rdquo;<br />
23 Directory=&ldquo;/incoming/Linux&rdquo;<br />
24 # 在这里也不一定非得将上边的参数写死在这个脚本中,<br />
25 #+ 可以使用命令行参数的方法来替换.<br />
26<br />
27 Password=&ldquo;your.e-mail.address&rdquo; # 可以修改成相匹配的密码.<br />
28<br />
29 ftp -n $Server &lt; 30 # -n 选项禁用自动登录.<br />
31<br />
32 user anonymous &ldquo;$Password&rdquo;<br />
33 binary<br />
34 bell # 在每个文件传输后, 响铃.<br />
35 cd $Directory<br />
36 put &ldquo;$Filename.lsm&rdquo;<br />
37 put &ldquo;$Filename.tar.gz&rdquo;<br />
38 bye<br />
39 End-Of-Session<br />
40<br />
41 exit 0<br />
################################End
Script#########################################</p>

<p>在here document的开头引用或转义&rdquo;limit string&rdquo;会使得here document的消息体中的参数替<br />
换被禁用.</p>

<p>Example 17-7 关闭参数替换<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 一个使用&rsquo;cat&rsquo;的here document, 但是禁用了参数替换.<br />
3<br />
4 NAME=&ldquo;John Doe&rdquo;<br />
5 RESPONDENT=&ldquo;the author of this fine script&rdquo;<br />
6<br />
7 cat &lt; 8<br />
9 Hello, there, $NAME.<br />
10 Greetings to you, $NAME, from $RESPONDENT.<br />
11<br />
12 Endofmessage<br />
13<br />
14 # 当&rdquo;limit string&rdquo;被引用或转义那么就禁用了参数替换.<br />
15 # 下边的两种方式具有相同的效果.<br />
16 # cat &lt; 17 # cat &lt; 18<br />
19 exit 0<br />
################################End
Script#########################################</p>

<p>禁用了参数替换后, 将允许输出文本本身(译者注: 就是未转义的原文). 产生脚本甚至是程序<br />
代码就是这种用法的用途之一.</p>

<p>Example 17-8 一个产生另外一个脚本的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # generate-script.sh<br />
3 # 基于Albert Reiner的一个主意.<br />
4<br />
5 OUTFILE=generated.sh # 所产生文件的名字.<br />
6<br />
7<br />
8 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
9 # &lsquo;Here document包含了需要产生的脚本的代码.<br />
10 (<br />
11 cat &lt; 12 #!/bin/bash<br />
13<br />
14 echo &ldquo;This is a generated shell script.&rdquo;<br />
15 # Note that since we are inside a subshell,<br />
16 #+ we can&rsquo;t access variables in the &ldquo;outside&rdquo; script.<br />
17<br />
18 echo &ldquo;Generated file will be named: $OUTFILE&rdquo;<br />
19 # Above line will not work as normally expected<br />
20 #+ because parameter expansion has been disabled.<br />
21 # Instead, the result is literal output.<br />
22<br />
23 a=7<br />
24 b=3<br />
25<br />
26 let &ldquo;c = $a * $b&rdquo;<br />
27 echo &ldquo;c = $c&rdquo;<br />
28<br />
29 exit 0<br />
30 EOF<br />
31 ) &gt; $OUTFILE<br />
32 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
33<br />
34 # 将&rsquo;limit string&rsquo;引用起来将会阻止上边<br />
35 #+ here document的消息体中的变量扩展.<br />
36 # 这会使得输出文件中的内容保持here document消息体中的原文.<br />
37<br />
38 if [ -f &ldquo;$OUTFILE&rdquo; ]<br />
39 then<br />
40 chmod 755 $OUTFILE<br />
41 # 让所产生的文件具有可执行权限.<br />
42 else<br />
43 echo &ldquo;Problem in creating file: \&ldquo;$OUTFILE\&ldquo;&rdquo;<br />
44 fi<br />
45<br />
46 # 这个方法也用来产生<br />
47 #+ C程序代码, Perl程序代码, Python程序代码, makefile,<br />
48 #+ 和其他的一些类似的代码.<br />
49 # (译者注: 中间一段没译的注释将会被here document打印出来)<br />
50 exit 0<br />
################################End
Script#########################################</p>

<p>也可以将here document的输出保存到变量中.</p>

<p>1 variable=$(cat &lt; 2 This variable<br />
3 runs over multiple lines.<br />
4 SETVAR)<br />
5<br />
6 echo &ldquo;$variable&rdquo;</p>

<p>同一脚本中的函数也可以接受here document的输出作为自身的参数.</p>

<p>Example 17-9 Here documents与函数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # here-function.sh<br />
3<br />
4 GetPersonalData ()<br />
5 {<br />
6 read firstname<br />
7 read lastname<br />
8 read address<br />
9 read city<br />
10 read state<br />
11 read zipcode<br />
12 } # 这个函数无疑的看起来就一个交互函数, 但是&hellip;<br />
13<br />
14<br />
15 # 给上边的函数提供输入.<br />
16 GetPersonalData &lt; 17 Bozo<br />
18 Bozeman<br />
19 2726 Nondescript Dr.<br />
20 Baltimore<br />
21 MD<br />
22 21226<br />
23 RECORD001<br />
24<br />
25<br />
26 echo<br />
27 echo &ldquo;$firstname $lastname&rdquo;<br />
28 echo &ldquo;$address&rdquo;<br />
29 echo &ldquo;$city, $state $zipcode&rdquo;<br />
30 echo<br />
31<br />
32 exit 0<br />
################################End
Script#########################################</p>

<p>也可以这么使用: 做一个假命令来从一个here document中接收输出. 这么做事实上就是创建了<br />
一个&rdquo;匿名&rdquo;的here document.</p>

<p>Example 17-10 &ldquo;匿名&rdquo; here Document<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 : &lt; 4 ${HOSTNAME?}${USER?}${MAIL?} # 如果其中一个变量没被设置, 那么就打印错误信息.<br />
5 TESTVARIABLES<br />
6<br />
7 exit 0<br />
################################End
Script#########################################</p>

<p>注意: 上边所示技术的一种变化可以用来&rdquo;注释&rdquo;掉代码块.</p>

<p>Example 17-11 注释掉一段代码块<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # commentblock.sh<br />
3<br />
4 : &lt; 5 echo &ldquo;This line will not echo.&rdquo;<br />
6 This is a comment line missing the &ldquo;#&rdquo; prefix.<br />
7 This is another comment line missing the &ldquo;#&rdquo; prefix.<br />
8<br />
9 &amp;*@!!++=<br />
10 The above line will cause no error message,<br />
11 because the Bash interpreter will ignore it.<br />
12 COMMENTBLOCK<br />
13<br />
14 echo &ldquo;Exit value of above \&ldquo;COMMENTBLOCK\&rdquo; is $?.&rdquo; # 0<br />
15 # 这里将不会显示任何错误.<br />
16<br />
17<br />
18 # 上边的这种技术当然也可以用来注释掉<br />
19 #+ 一段正在使用的代码, 如果你有某些特定调试要求的话.<br />
20 # 这将比对每行都敲入&rdquo;#&ldquo;来得方便的多,<br />
21 #+ 而且如果你想恢复的话, 还得将添加上的&rdquo;#&ldquo;删除掉.<br />
22<br />
23 : &lt; 24 for file in *<br />
25 do<br />
26 cat &ldquo;$file&rdquo;<br />
27 done<br />
28 DEBUGXXX<br />
29<br />
30 exit 0<br />
################################End
Script#########################################</p>

<p>注意: 关于这种小技巧的另一个应用就是能够产生自文档化(self-documenting)的脚本.</p>

<p>Example 17-12 一个自文档化(self-documenting)的脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # self-document.sh: 自文档化(self-documenting)的脚本<br />
3 # Modification of &ldquo;colm.sh&rdquo;.<br />
4<br />
5 DOC_REQUEST=70<br />
6<br />
7 if [ &ldquo;$1&rdquo; = &ldquo;-h&rdquo; -o &ldquo;$1&rdquo; = &ldquo;&ndash;help&rdquo; ] # 请求帮助.<br />
8 then<br />
9 echo; echo &ldquo;Usage: $0 [directory-name]&ldquo;; echo<br />
10 sed &ndash;silent -e &lsquo;/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p&rsquo; &ldquo;$0&rdquo; |<br />
11 sed -e &lsquo;/DOCUMENTATIONXX$/d&rsquo;; exit $DOC_REQUEST; fi<br />
12<br />
13<br />
14 : &lt; 15 List the statistics of a specified directory in tabular format.<br />
16 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
17 The command line parameter gives the directory to be listed.<br />
18 If no directory specified or directory specified cannot be read,<br />
19 then list the current working directory.<br />
20<br />
21 DOCUMENTATIONXX<br />
22<br />
23 if [ -z &ldquo;$1&rdquo; -o ! -r &ldquo;$1&rdquo; ]<br />
24 then<br />
25 directory=.<br />
26 else<br />
27 directory=&ldquo;$1&rdquo;<br />
28 fi<br />
29<br />
30 echo &ldquo;Listing of &ldquo;$directory&rdquo;:&ldquo;; echo<br />
31 (printf &ldquo;PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n&rdquo; \<br />
32 ; ls -l &ldquo;$directory&rdquo; | sed 1d) | column -t<br />
33<br />
34 exit 0<br />
################################End
Script#########################################</p>

<p>使用cat 脚本 也能够完成相同的目的.</p>

<p>1 DOC_REQUEST=70<br />
2<br />
3 if [ &ldquo;$1&rdquo; = &ldquo;-h&rdquo; -o &ldquo;$1&rdquo; = &ldquo;&ndash;help&rdquo; ] # 请求帮助.<br />
4 then # 使用&rdquo;cat 脚本&rdquo; &hellip;<br />
5 cat &lt; 6 List the statistics of a specified directory in tabular format.<br />
7 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
8 The command line parameter gives the directory to be listed.<br />
9 If no directory specified or directory specified cannot be read,<br />
10 then list the current working directory.<br />
11<br />
12 DOCUMENTATIONXX<br />
13 exit $DOC_REQUEST<br />
14 fi</p>

<p>参见 Example A-27 可以了解更多关于自文档化脚本的好例子.</p>

<p>注意: Here document创建临时文件, 但是这些文件将在打开后被删除, 并且不能够被任何其<br />
他进程所存取.</p>

<p>bash$ bash -c &lsquo;lsof -a -p $$ -d0&rsquo; &lt;&lt; EOF<br />
&gt; EOF<br />
lsof 1213 bozo 0r REG 3,5 0 30386 /tmp/t1213-0-sh (deleted)</p>

<p>注意: 某些工具是不能工作在here document中的.<br />
警告: 结束的limit string, 就是here document最后一行的limit string, 必须开始于第一<br />
个字符位置. 它的前面不能够有任何前置的空白. 而在这个limit string后边的空白也会<br />
引起异常问题. 空白将会阻止limit string的识别.(译者注: 下边这个脚本由于结束<br />
limit string的问题, 造成脚本无法结束, 所有内容全部被打印出来, 所以注释就不译了,<br />
保持例子脚本的原样.)</p>

<p>1 #!/bin/bash<br />
2<br />
3 echo
&ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
4<br />
5 cat &lt; 6 echo &ldquo;This is line 1 of the message inside the here document.&rdquo;<br />
7 echo &ldquo;This is line 2 of the message inside the here document.&rdquo;<br />
8 echo &ldquo;This is the final line of the message inside the here document.&rdquo;<br />
9 LimitString<br />
10 #^^^^Indented limit string. Error! This script will not behave as expected.<br />
11<br />
12 echo
&ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
13<br />
14 # These comments are outside the &lsquo;here document&rsquo;,<br />
15 #+ and should not echo.<br />
16<br />
17 echo &ldquo;Outside the here document.&rdquo;<br />
18<br />
19 exit 0<br />
20<br />
21 echo &ldquo;This line had better not echo.&rdquo; # Follows an &lsquo;exit&rsquo; command.</p>

<p>对于那些使用&rdquo;here document&rdquo;得非常复杂的任务, 最好考虑使用expect脚本语言, 这种语言<br />
就是为了达到向交互程序添加输入的目的而量身定做的.</p>

<p>17.1. Here Strings<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
here string 可以被认为是here document的一种定制形式. 除了COMMAND &lt;&lt; 没有了,
$WORD将被扩展并且被送入COMMAND的stdin中.</p>

<p>Example 17-13 在一个文件的开头添加文本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # prepend.sh: 在文件的开头添加文本.<br />
3 #<br />
4 # Kenny Stauffer所捐助的脚本例子,<br />
5 #+ 被本文作者作了少量的修改.<br />
6<br />
7<br />
8 E_NOSUCHFILE=65<br />
9<br />
10 read -p &ldquo;File: &ldquo; file # &lsquo;read&rsquo;命令的 -p 参数显示提示符.<br />
11 if [ ! -e &ldquo;$file&rdquo; ]<br />
12 then # 如果没有这个文件那就进来.<br />
13 echo &ldquo;File $file not found.&rdquo;<br />
14 exit $E_NOSUCHFILE<br />
15 fi<br />
16<br />
17 read -p &ldquo;Title: &ldquo; title<br />
18 cat - $file &lt;&lt; $file.new<br />
19<br />
20 echo &ldquo;Modified file is $file.new&rdquo;<br />
21<br />
22 exit 0<br />
23<br />
24 # 下边是&rsquo;man bash&rsquo;中的一段:<br />
25 # Here Strings<br />
26 # here document的一种变形,形式如下:<br />
27 #<br />
28 # &lt;&lt; 29 #<br />
30 # word被扩展并且提供到command的标准输入中.<br />
################################End
Script#########################################</p>

<p>练习: 找出here string的其他用法.</p>

<h1 id="第18章-休息时间">第18章 休息时间</h1>

<p>这个神奇的暂停可以给读者一个休息的机会, 可能读者到了这里也会会心一笑吧.</p>

<p>Linux同志们, 向你们致敬! 你正在阅读的这些东西, 将会给你们带来好运. 把这份文档发给你<br />
的10个朋友. 在拷贝这份文档之前, 在信的结尾写上一个100行的Bash脚本发送给列表上的第一<br />
个人. 然后在信的底部删除它们的名字并添加你自己的名字.</p>

<p>不要打断这个链条! 并且在48小时之内完成它.</p>

<p>Brooklyn的Wilfred?P.没有成功的发送他的10个拷贝, 当他第2天早上醒来发现他的工作变成了<br />
&ldquo;COBOL 程序员&rdquo;. Newport?News的Howard?L.在一个月内才发出了他的10个拷贝, 这个时间足够<br />
建立一个100个节点的Beowulf cluster来玩Tuxracer了. Chicago的Amelia?V.对这封信付之一<br />
笑并且打断了这个链条, 不久之后, 她的终端爆炸了, 她现在花了好多天时间为MS Windows写<br />
文档.</p>

<p>千万不要打断这个链条! 今天就把10个拷贝发出去!</p>

<p>第四部分 高级<br />
++++++++++++++++<br />
到了这儿,我们将要准备深入脚本编程中一些难的,不寻常的话题.随着话题的展开,我们会<br />
以多种方法和检测边界条件的方式来“打开信封”,看个明白.(当我们涉足未知领域时会发<br />
生什么?).</p>

<p>目录<br />
19. Regular Expressions正则表达式<br />
20. 子shell(Subshells)<br />
21. 受限shell(Restricted Shells)<br />
22. 进程替换<br />
23. 函数<br />
24. 别名(Aliases)<br />
25. 列表结构<br />
26. 数组<br />
27. /dev和/proc<br />
28. 关于Zeros和Nulls<br />
29. 调试<br />
30. 选项<br />
31. 检查遗漏(Gotchas)<br />
32. 脚本编程风格<br />
33. 杂项<br />
34. Bash,版本2和3</p>

<h1 id="第19章-正则表达式">第19章 正则表达式</h1>

<p>为了充分发挥shell编程的威力, 你需要精通正则表达式. 一些命令和软件包普遍在脚本编程中<br />
使用正则表达式,例如grep, expr, sed和awk.</p>

<p>19.1 一个简要的正则表达式介绍<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
一个正式表达式是一个字符串.字符串里的字符被称为元字符,它们可能表示了比它们字面上看<br />
起来的意思更丰富的含义.例如,一个引用符号可能表示引用一个人演讲中的话,或者表示下<br />
面将要讲到的引申表示的意思.正则表达式是一个字符或/和元字符组合成的字符集,它们匹配<br />
(或指定)一个模式.</p>

<p>一个正则表达式包含下面一个或多个项:</p>

<p>1. 一个字符集.<br />
这里的字符集里的字符表示的就是它们字面上的意思.正则表达式最简单的情况就是仅<br />
仅由字符集组成,而没有其他的元字符.</p>

<p>2. 锚.<br />
一个锚指明了正则表达式在一行文本中要匹配的位置,例如^和$就是锚.</p>

<p>3. 修饰符<br />
它们用于展开或缩小(即是修改了)正则表达式匹配文本行的范围.修饰符包括了星号.<br />
括号和反斜杠符号.</p>

<p>正则表达是的主要作用是用来文本搜索和字串操作.一个正则表达式匹配一个字符或是一串字<br />
符&ndash;完整的一串字符或是另外一个字符串的子串.</p>

<p>星号 &ndash; * &ndash; 匹配前一个字符的任意多次(包括零次).<br />
&ldquo;1133*&ldquo;匹配11 + 一个或更多的3 + 可能的其他字符: 113, 1133, 111312, 等等.</p>

<p>点 &ndash; . &ndash; 匹配除了新行符之外的任意一个字符. [1]<br />
&ldquo;13.&rdquo; 匹配13 + 至少一个任意字符(包括空格): 1133, 11333, 但不匹配 13<br />
(因为少了附加的至少一个任意字符).</p>

<p>脱字符 &ndash; ^ &ndash; 匹配一行的开头,但依赖于上下文环境,可能在正则表达式中表示否定<br />
一个字符集的意思.</p>

<p>美元符 &ndash; $ &ndash; 在正则表达式中匹配行尾.<br />
&rdquo;^$&rdquo; 匹配空行.</p>

<p>方括号 &ndash; [&hellip;] &ndash; 在正则表达式中表示匹配括号中的一个字符.<br />
&ldquo;[xyz]&rdquo; 匹配字符x, y, 或z.</p>

<p>&ldquo;[c-n]&rdquo; 匹配从字符c到n之间的任意一个字符.</p>

<p>&ldquo;[B-Pk-y]&rdquo; 匹配从B到P 或从k到y的任意一个字符.</p>

<p>&ldquo;[a-z0-9]&rdquo; 匹配任意小写字母或数字.</p>

<p>&ldquo;[^b-d]&rdquo; 匹配除了从b到d范围内所有的字符. 这是正则表达式中反转意思或取否<br />
的一 个例子.(就好像在别的情形中!字符所扮演的角色).</p>

<p>多个方括号字符集组合使用可以匹配一般的单词和数字模式.&rdquo;[Yy][Ee][Ss]&rdquo; 匹<br />
配yes, Yes, YES, yEs, 等等.<br />
&ldquo;[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]&ldquo;匹配社会安全码<br />
(Social Security number).</p>

<p>反斜杠字符 &ndash; \ &ndash; 转义(escapes) 一个特殊的字符,使这个字符表示原来字面上的意思.<br />
&ldquo;\$&ldquo;表示了原来的字面意思&rdquo;$&ldquo;,而不是在正则表达式中表达的匹配行尾的意思.<br />
同样,&rdquo;\\&ldquo;也被解释成了字面上的意思&rdquo;\&ldquo;.</p>

<p>转义(escape)&ldquo;尖角号&rdquo; &ndash; &lt;&hellip;&gt; &ndash; 用于表示单词的边界.<br />
尖角号必须被转义,因为不这样做的话它们就表示单纯的字面意思<br />
而已.</p>

<p>&ldquo;\&rdquo; 匹配单词&rdquo;the&rdquo;,但不匹配&rdquo;them&rdquo;, &ldquo;there&rdquo;, &ldquo;other&rdquo;,<br />
等等.</p>

<p>bash$ cat textfile<br />
This is line 1, of which there is only one instance.<br />
This is the only instance of line 2.<br />
This is line 3, another line.<br />
This is line 4.</p>

<p>bash$ grep &lsquo;the&rsquo; textfile<br />
This is line 1, of which there is only one instance.<br />
This is the only instance of line 2.<br />
This is line 3, another line.</p>

<p>bash$ grep &lsquo;\&rsquo; textfile<br />
This is the only instance of line 2.</p>

<p>确定正则表达式能否工作的唯一办法是测试它.</p>

<p>1 TEST FILE: tstfile # 不匹配.<br />
2 # 不匹配.<br />
3 Run grep &ldquo;1133*&rdquo; on this file. # 匹配.<br />
4 # 不匹配.<br />
5 # 不匹配.<br />
6 This line contains the number 113. # 匹配.<br />
7 This line contains the number 13. # 不匹配.<br />
8 This line contains the number 133. # 不匹配.<br />
9 This line contains the number 1133. # 匹配.<br />
10 This line contains the number 113312. # 匹配.<br />
11 This line contains the number 1112. # 不匹配.<br />
12 This line contains the number 113312312. # 匹配.<br />
13 This line contains no numbers at all. # 不匹配.</p>

<p>bash$ grep &ldquo;1133<em>&rdquo; tstfile<br />
Run grep &ldquo;1133</em>&rdquo; on this file. # 匹配.<br />
This line contains the number 113. # 匹配.<br />
This line contains the number 1133. # 匹配.<br />
This line contains the number 113312. # 匹配.<br />
This line contains the number 113312312. # 匹配.</p>

<p>扩展的正则表达式. 增加了一些元字符到上面提到的基本的元字符集合里. 它们在egrep,<br />
awk,和Perl中使用.</p>

<p>问号 &ndash; ? &ndash; 匹配零或一个前面的字符. 它一般用于匹配单个字符.</p>

<p>加号 &ndash; + &ndash; 匹配一个或多个前面的字符.它的作用和*很相似,但唯一的区别是它不<br />
匹配零个字符的情况.</p>

<p>1 # GNU 版本的 sed 和 awk 可以使用&rdquo;+&ldquo;,<br />
2 # 但它应该转义一下.<br />
3<br />
4 echo a111b | sed -ne &lsquo;/a1\+b/p&rsquo;<br />
5 echo a111b | grep &lsquo;a1\+b&rsquo;<br />
6 echo a111b | gawk &lsquo;/a1+b/&rsquo;<br />
7 # 上面三句都是等价的效果.<br />
8<br />
9 # 多谢, S.C.</p>

<p>转义&rdquo;大括号&rdquo; &ndash; \{ \} &ndash; 指示前面正则表达式匹配的次数.<br />
要转义是因为不转义的话大括号只是表示他们字面上的意思.这个用法只是<br />
技巧上的而不是基本正则表达式的内容.</p>

<p>&ldquo;[0-9]\{5\}&rdquo; 精确匹配5个数字 (从 0 到 9的数字).</p>

<p>注意: 大括号不能在“经典”(不是POSIX兼容)的正则表达式版本的awk中<br />
使用. 然而, gawk 有一个选项&ndash;re-interval来允许使用大括号<br />
(不必转义).</p>

<p>bash$ echo 2222 | gawk &ndash;re-interval &lsquo;/2{3}/&rsquo;<br />
2222</p>

<p>Perl和一些egrep版本不要求转义大括号.</p>

<p>圆括号 &ndash; ( ) &ndash; 括起一组正则表达式. 它和下面要讲的&rdquo;|&ldquo;操作符或在用expr进行子字<br />
符串提取(substring extraction)一起使用很有用.</p>

<p>竖线 &ndash; | &ndash; &ldquo;或&rdquo;正则操作符用于匹配一组可选的字符.</p>

<p>bash$ egrep &rsquo;re(a|e)d&rsquo; misc.txt<br />
People who read seem to be better informed than those who do not.<br />
The clarinet produces sound by the vibration of its reed.</p>

<p>注意: 一些sed, ed, 和ex的版本像GNU的软件版本一样支持上面描述的扩展正<br />
则表达式的版本.</p>

<p>POSIX字符类. [:class:]<br />
这是另外一个可选的用于指定匹配字符范围的方法.</p>

<p>[:alnum:] 匹配字母和数字.等同于A-Za-z0-9.</p>

<p>[:alpha:] 匹配字母. 等同于A-Za-z.</p>

<p>[:blank:] 匹配一个空格或是一个制表符(tab).</p>

<p>[:cntrl:] 匹配控制字符.</p>

<p>[:digit:] 匹配(十进制)数字. 等同于0-9.</p>

<p><a href="可打印的图形字符">:graph:</a>. 匹配 ASCII 码值的33 - 126之间的字符. 这和下面提到的<br />
[:print:]一样,但是不包括空格字符.</p>

<p>[:lower:] 匹配小写字母. 等同于a-z.</p>

<p><a href="可打印字符">:print:</a>. 匹配 ASCII码值 32 - 126之间的字符. 这和上面提到的一样<br />
[:graph:],但是增多一个空格字符.</p>

<p>[:space:] 匹配空白字符 (空格符和水平制表符).</p>

<p>[:upper:] 匹配大写字母. 等同于A-Z.</p>

<p>[:xdigit:] 匹配十六进制数字. 等同于0-9A-Fa-f.</p>

<p>注意: POSIX字符类一般都要求用引号或是双方括号double brackets ([[ ]])引起来.<br />
bash$ grep [[:digit:]] test.file<br />
abc=723</p>

<p>这些字符类在一个受限的范围内甚至可能用在能用在通配(globbing)中.<br />
bash$ ls -l ?[[:digit:]][[:digit:]]?<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 21 14:47 a33b</p>

<p>为了理解POSIX字符类在脚本中的使用,请参考例子 12-18 和 例子 12-19.</p>

<p>Sed, awk, 和Perl在脚本中被用作过滤器, &ldquo;过滤&rdquo;或转换文件/IO流的时候以正则表达式作为参<br />
数.参考例子 A-12和例子 A-17 来理解这种用法.</p>

<p>在正则表达式这个复杂主题的标准参考是Friedl的Mastering Regular Expressions.由<br />
Dougherty和Robbins写的 Sed &amp; Awk也给出了一个清晰的正则表达式论述. 查看参考书目找<br />
到这个主题更多的信息.</p>

<p>注意事项:<br />
[1] 因为sed, awk, 和 grep 通常处理单行,而不能匹配一个新行符. 在要处理多行的一<br />
个输入时,可以使用点操作符,它可以匹配新行符.<br />
1 #!/bin/bash<br />
2<br />
3 sed -e &lsquo;N;s/.*/[&amp;]/&rsquo; &lt;&lt; EOF # Here Document<br />
4 line1<br />
5 line2<br />
6 EOF<br />
7 # 输出:<br />
8 # [line1<br />
9 # line2]<br />
10<br />
11<br />
12<br />
13 echo<br />
14<br />
15 awk &lsquo;{ $0=$1 &ldquo;\n&rdquo; $2; if (/line.1/) {print}}&rsquo; &lt;&lt; EOF<br />
16 line 1<br />
17 line 2<br />
18 EOF<br />
19 # 输出:<br />
20 # line<br />
21 # 1<br />
22<br />
23<br />
24 # 多谢, S.C.<br />
25<br />
26 exit 0</p>

<p>19.1 通配<br />
-&mdash;&mdash;&mdash;&ndash;<br />
Bash本身没有正则表达式的功能.在脚本里,使用正则表达式的是命令和软件包 &ndash; 例如sed和<br />
awk &ndash; 它们可以解释正则表达式.</p>

<p>Bash所做的是展开文件名扩展 [1] &ndash; 这就是所谓的通配(globbing) &ndash; 但它不是使用标准的<br />
正则表达式. 而是使用通配符. 通配解释标准的通配符：*和?, 方括号括起来的字符,还有其他<br />
的一些特殊的字符(比如说^用来表示取反匹配).然而通配机制的通配符有很大的局限性. 包含<br />
有*号的字符串将不会匹配以点开头的文件,例如.bashrc. [2] 另外,通配机制的? 字符和正则<br />
表达式中表示的意思不一样.</p>

<p>bash$ ls -l<br />
total 2<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 a.1<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 b.1<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 c.1<br />
-rw-rw-r&ndash; 1 bozo bozo 466 Aug 6 17:48 t2.sh<br />
-rw-rw-r&ndash; 1 bozo bozo 758 Jul 30 09:02 test1.txt</p>

<p>bash$ ls -l t?.sh<br />
-rw-rw-r&ndash; 1 bozo bozo 466 Aug 6 17:48 t2.sh</p>

<p>bash$ ls -l [ab]*<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 a.1<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 b.1</p>

<p>bash$ ls -l [a-c]*<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 a.1<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 b.1<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 c.1</p>

<p>bash$ ls -l [^ab]*<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 c.1<br />
-rw-rw-r&ndash; 1 bozo bozo 466 Aug 6 17:48 t2.sh<br />
-rw-rw-r&ndash; 1 bozo bozo 758 Jul 30 09:02 test1.txt</p>

<p>bash$ ls -l {b<em>,c</em>,<em>est</em>}<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 b.1<br />
-rw-rw-r&ndash; 1 bozo bozo 0 Aug 6 18:42 c.1<br />
-rw-rw-r&ndash; 1 bozo bozo 758 Jul 30 09:02 test1.txt</p>

<p>Bash会对命令行中没有引号引起来的字符尝试文件名扩展. echo 命令可以印证这一点.</p>

<p>bash$ echo *<br />
a.1 b.1 c.1 t2.sh test1.txt</p>

<p>bash$ echo t*<br />
t2.sh test1.txt</p>

<p>注意: 可以改变Bash对通配字符进行解释的行为. set -f 命令可以禁止通配机制, 并且<br />
shopt的选项nocaseglob和nullglob 能改变通配的行为.</p>

<p>参考例子 10-4.</p>

<p>注意事项:<br />
[1] 文件名扩展意思是扩展包含有特殊字符的文件名模式和模板. 例如,example.???可能<br />
扩展成example.001和/或example.txt.<br />
[2] 文件名扩展能匹配点开头的文件,但仅在模式字串明确地包含字面意思的点(.)时才<br />
扩展.<br />
1 ~/[.]bashrc # 不会扩展成 ~/.bashrc<br />
2 ~/?bashrc # 也不会扩展.<br />
3 # 通配机制中的通配符和元字符不会扩展点文件<br />
4 #<br />
5<br />
6 ~/.[b]ashrc # 会扩展成 ~/.bashrc<br />
7 ~/.ba?hrc # 也会.<br />
8 ~/.bashr* # 也会.<br />
9<br />
10 # 可以使用&rdquo;dotglob&rdquo;选项把这个特性禁用.<br />
11<br />
12 # 多谢, S.C.</p>

<h1 id="第20章-子shell-subshells">第20章 子shell(Subshells)</h1>

<p>运行一个shell脚本时会启动另一个命令解释器. 就好像你的命令是在命令行提示下被解释的一<br />
样, 类似于批处理文件里的一系列命令.每个shell脚本有效地运行在父shell(parent shell)的<br />
一个子进程里.这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.</p>

<p>shell脚本也能启动他自已的子进程. 这些子shell(即子进程)使脚本因为效率而同时进行多个<br />
子任务执行时能做串行处理.</p>

<p>一般来说,脚本里的一个外部命令(external command)能生成(forks)出一个子进程,然而<br />
Bash内建(builtin)的命令却不这样做,因此,内建命令比起外部的等价命令执行起来更快.</p>

<p>圆括号里的命令列表</p>

<p>( 命令1; 命令2; 命令3; &hellip; )<br />
嵌在圆括号里的一列命令在一个子shell里运行.</p>

<p>注意: 在子shell里的变量不能被这段子shell代码块之外外面的脚本访问.这些变量是不能被<br />
产生这个子shell的父进程(parent process)存取的,实际上它们是局部变量<br />
(local variables).</p>

<p>Example 20-1 子shell中的变量作用域<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # subshell.sh<br />
3<br />
4 echo<br />
5<br />
6 echo &ldquo;Subshell level OUTSIDE subshell = $BASH_SUBSHELL&rdquo;<br />
7 # Bash, 版本 3, 增加了新的 $BASH_SUBSHELL 变量.<br />
8 echo<br />
9<br />
10 outer_variable=Outer<br />
11<br />
12 (<br />
13 echo &ldquo;Subshell level INSIDE subshell = $BASH_SUBSHELL&rdquo;<br />
14 inner_variable=Inner<br />
15<br />
16 echo &ldquo;From subshell, \&ldquo;inner_variable\&rdquo; = $inner_variable&rdquo;<br />
17 echo &ldquo;From subshell, \&ldquo;outer\&rdquo; = $outer_variable&rdquo;<br />
18 )<br />
19<br />
20 echo<br />
21 echo &ldquo;Subshell level OUTSIDE subshell = $BASH_SUBSHELL&rdquo;<br />
22 echo<br />
23<br />
24 if [ -z &ldquo;$inner_variable&rdquo; ]<br />
25 then<br />
26 echo &ldquo;inner_variable undefined in main body of shell&rdquo;<br />
27 else<br />
28 echo &ldquo;inner_variable defined in main body of shell&rdquo;<br />
29 fi<br />
30<br />
31 echo &ldquo;From main body of shell, \&ldquo;inner_variable\&rdquo; = $inner_variable&rdquo;<br />
32 # $inner_variable 会以没有初始化的变量来打印<br />
33 #+ 因为变量是在子shell里定义的&rdquo;局部变量&rdquo;.<br />
34 # 这个有办法补救的吗?<br />
35<br />
36 echo<br />
37<br />
38 exit 0<br />
################################End
Script#########################################<br />
参考例子 31-2.<br />
+<br />
在子shell中的目录更改不会影响到父shell.</p>

<p>Example 20-2 列出用户的配置文件<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # allprofs.sh: 打印所有用户的配置文件<br />
3<br />
4 # 由 Heiner Steven编写, 并由本书作者修改.<br />
5<br />
6 FILE=.bashrc # 在一般的脚本里,包含用户配置的文件是&rdquo;.profile&rdquo;.<br />
7 #<br />
8<br />
9 for home in <code>awk -F: '{print $6}' /etc/passwd</code><br />
10 do<br />
11 [ -d &ldquo;$home&rdquo; ] || continue # 如果没有家目录,跳过此次循环.<br />
12 [ -r &ldquo;$home&rdquo; ] || continue # 如果目录没有读权限,跳过此次循环.<br />
13 (cd $home; [ -e $FILE ] &amp;&amp; less $FILE)<br />
14 done<br />
15<br />
16 # 当脚本终止时,不必用&rsquo;cd&rsquo;命令返回原来的目录,<br />
17 #+ 因为&rsquo;cd $home&rsquo;是在子shell中发生的,不影响父shell.<br />
18<br />
19 exit 0<br />
################################End
Script#########################################</p>

<p>子shell可用于为一组命令设定临时的环境变量.</p>

<p>1 COMMAND1<br />
2 COMMAND2<br />
3 COMMAND3<br />
4 (<br />
5 IFS=:<br />
6 PATH=/bin<br />
7 unset TERMINFO<br />
8 set -C<br />
9 shift 5<br />
10 COMMAND4<br />
11 COMMAND5<br />
12 exit 3 # 只是从子shell退出.<br />
13 )<br />
14 # 父shell不受影响,变量值没有更改.<br />
15 COMMAND6<br />
16 COMMAND7</p>

<p>它的一个应用是测试是否一个变量被定义了.</p>

<p>1 if (set -u; : $variable) 2&gt; /dev/null<br />
2 then<br />
3 echo &ldquo;Variable is set.&rdquo;<br />
4 fi # 变量已经在当前脚本中被设置,<br />
5 #+ 或是Bash的一个内部变量,<br />
6 #+ 或是可见环境变量(指已经被导出的环境变量).<br />
7<br />
8 # 也可以写成 [[ ${variable-x} != x || ${variable-y} != y ]]<br />
9 # 或 [[ ${variable-x} != x$variable ]]<br />
10 # 或 [[ ${variable+x} = x ]]<br />
11 # 或 [[ ${variable-x} != x ]]</p>

<p>另一个应用是检查一个加锁的文件:</p>

<p>1 if (set -C; : &gt; lock_file) 2&gt; /dev/null<br />
2 then<br />
3 : # lock_file 不存在,还没有用户运行这个脚本<br />
4 else<br />
5 echo &ldquo;Another user is already running that script.&rdquo;<br />
6 exit 65<br />
7 fi<br />
8<br />
9 # 由St閜hane Chazelas编程<br />
10 #+ 由Paulo Marcel Coelho Aragao修改.</p>

<p>进程在不同的子shell中可以串行地执行.这样就允许把一个复杂的任务分成几个小的子问题来<br />
同时地处理.</p>

<p>Example 20-3 在子shell里进行串行处理<br />
################################Start
Script#######################################<br />
1 (cat list1 list2 list3 | sort | uniq &gt; list123) &amp;<br />
2 (cat list4 list5 list6 | sort | uniq &gt; list456) &amp;<br />
3 #列表的合并和排序同时进.<br />
4 #放到后台运行可以确保能够串行执行.<br />
5 #<br />
6 #和下面的有相同的作用：<br />
7 # cat list1 list2 list3 | sort | uniq &gt; list123 &amp;<br />
8 # cat list4 list5 list6 | sort | uniq &gt; list456 &amp;<br />
9<br />
10 wait #在所有的子shell执行完成前不再执行后面的命令.<br />
11<br />
12 diff list123 list456<br />
################################End
Script#########################################</p>

<p>用&rdquo;|&ldquo;管道操作把I/O流重定向到子shell,例如ls -al | (command).</p>

<p>注意: 在一个花括号内的代码块不会运行一个子shell.<br />
{ command1; command2; command3; &hellip; }</p>

<h1 id="第21章-受限shell-restricted-shells">第21章 受限shell(Restricted Shells)</h1>

<p>在受限shell中禁用的命令</p>

<p>在受限shell中运行的脚本或脚本的个代码断会禁用一些正常shell中可以执行的命令.这是<br />
限制脚本用户的权限和最小化运行脚本导致的破坏的安全措施.</p>

<p>使用cd 命令更改工作目录.</p>

<p>更改环境变量$PATH, $SHELL, $BASH_ENV,或$ENV 的值.</p>

<p>读或更改shell环境选项变量$SHELLOPTS的值.</p>

<p>输出重定向.</p>

<p>调用的命令路径中包括有一个或更多个/字符.</p>

<p>调用exec来把当前的受限shell替换成另外一个不同的进程.</p>

<p>脚本中许多其他无意中能破坏或捣乱的命令.</p>

<p>在脚本中企图脱离受限shell模式的操作.</p>

<p>Example 21-1 在受限的情况下运行脚本<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 脚本开头以&rdquo;#!/bin/bash -r&rdquo;来调用<br />
4 #+ 会使整个脚本在受限模式下运行.<br />
5<br />
6 echo<br />
7<br />
8 echo &ldquo;Changing directory.&rdquo;<br />
9 cd /usr/local<br />
10 echo &ldquo;Now in <code>pwd</code>&rdquo;<br />
11 echo &ldquo;Coming back home.&rdquo;<br />
12 cd<br />
13 echo &ldquo;Now in <code>pwd</code>&rdquo;<br />
14 echo<br />
15<br />
16 # 不受限的模式下,所有操作都能正常成功.<br />
17<br />
18 set -r<br />
19 # set &ndash;restricted 也能起相同的作用.<br />
20 echo &ldquo;==&gt; Now in restricted mode. &lt;==&rdquo;<br />
21<br />
22 echo<br />
23 echo<br />
24<br />
25 echo &ldquo;Attempting directory change in restricted mode.&rdquo;<br />
26 cd ..<br />
27 echo &ldquo;Still in <code>pwd</code>&rdquo;<br />
28<br />
29 echo<br />
30 echo<br />
31<br />
32 echo &ldquo;\$SHELL = $SHELL&rdquo;<br />
33 echo &ldquo;Attempting to change shell in restricted mode.&rdquo;<br />
34 SHELL=&ldquo;/bin/ash&rdquo;<br />
35 echo<br />
36 echo &ldquo;\$SHELL= $SHELL&rdquo;<br />
37<br />
38 echo<br />
39 echo<br />
40<br />
41 echo &ldquo;Attempting to redirect output in restricted mode.&rdquo;<br />
42 ls -l /usr/bin &gt; bin.files<br />
43 ls -l bin.files # Try to list attempted file creation effort.<br />
44<br />
45 echo<br />
46<br />
47 exit 0<br />
################################End
Script#########################################</p>

<h1 id="第22章-进程替换">第22章 进程替换</h1>

<p>进程替换与命令替换(command substitution)很相似. 命令替换把一个命令的结果赋给一个<br />
变量,例如 dir_contents=<code>ls -al</code>或xref=$( grep word datafile). 进程替换则是把一个进<br />
程的输出回馈给另一个进程 (换句话说,它把一个命令的结果发送给另一个命令).</p>

<p>命令替换的一般形式</p>

<p>由圆括号括起的命令</p>

<blockquote>
<p>(command)</p>
</blockquote>

<p>启动进程替换. 它是用/dev/fd/文件把在圆括号内的进程的处理结果发送给另外一个进<br />
程. <a href="译者注：实际上现代的UNIX类操作系统提供的/dev/fd/n文件是与文件描述相关  
的,整数n指的就是在进程运行时对应数字的文件描述符">1</a></p>

<p>注意: 在&rdquo;&rdquo; 与圆括号之间是没有空格的. 如果加了空格将会引起错误信息.</p>

<p>bash$ echo &gt;(true)<br />
/dev/fd/63</p>

<p>bash$ echo /dev/fd/63</p>

<p>Bash在两个文件描述符(file descriptors)之间创建了一个管道, &ndash;fIn 和 fOut&ndash;. true<br />
命令的标准输入被连接到fOut(dup2(fOut, 0)), 然后Bash把/dev/fd/fIn作为参数传给echo.<br />
如果系统的/dev/fd/文件不够时,Bash会使用临时文件. (Thanks, S.C.)</p>

<p>进程替换能比较两个不同命令之间的输出,或者甚至相同命令不同选项的输出.</p>

<p>bash$ comm total 12<br />
-rw-rw-r&ndash; 1 bozo bozo 78 Mar 10 12:58 File0<br />
-rw-rw-r&ndash; 1 bozo bozo 42 Mar 10 12:58 File2<br />
-rw-rw-r&ndash; 1 bozo bozo 103 Mar 10 12:58 t2.sh<br />
total 20<br />
drwxrwxrwx 2 bozo bozo 4096 Mar 10 18:10 .<br />
drwx&mdash;&mdash; 72 bozo bozo 4096 Mar 10 17:58 ..<br />
-rw-rw-r&ndash; 1 bozo bozo 78 Mar 10 12:58 File0<br />
-rw-rw-r&ndash; 1 bozo bozo 42 Mar 10 12:58 File2<br />
-rw-rw-r&ndash; 1 bozo bozo 103 Mar 10 12:58 t2.sh</p>

<p>用进程替换来比较两个不同目录的内容 (考察哪些文件名是相同的,哪些是不同的):<br />
1 diff</p>

<p>其他一些进程替换的用法和技巧:</p>

<p>1 cat 2 # 等同于 ls -l | cat<br />
3<br />
4 sort -k 9 5 # 列出系统中3个主要的&rsquo;bin&rsquo;目录的所有文件,并且按文件名排序.<br />
6 # 注意是三个明显不同的命令输出回馈给&rsquo;sort&rsquo;.<br />
7<br />
8<br />
9 diff 10<br />
11 tar cf &gt;(bzip2 -c &gt; file.tar.bz2) $directory_name<br />
12 # 调用&rdquo;tar cf /dev/fd/?? $directory_name&rdquo;,和&rdquo;bzip2 -c &gt; file.tar.bz2&rdquo;.<br />
13 #<br />
14 # 因为/dev/fd/的系统属性,<br />
15 # 所以两个命令之间的管道不必是命名的.<br />
16 #<br />
17 # 这种效果可以模仿出来.<br />
18 #<br />
19 bzip2 -c &lt; pipe &gt; file.tar.bz2&amp;<br />
20 tar cf pipe $directory_name<br />
21 rm pipe<br />
22 # 或者<br />
23 exec 3&gt;&amp;1<br />
24 tar cf /dev/fd/4 $directory_name 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | bzip2 -c &gt; file.tar.bz2
3&gt;&amp;-<br />
25 exec 3&gt;&amp;-<br />
26<br />
27<br />
28 # Thanks, St`phane Chazelas</p>

<p>有个读者给我发来下面关于进程替换的有趣例子A.</p>

<p>1 # 摘自SuSE发行版中的代码片断:<br />
2<br />
3 while read des what mask iface; do<br />
4 # 这里省略了一些命令 &hellip;<br />
5 done &lt; 6<br />
7<br />
8 # 为了测试它,我们来做些动作.<br />
9 while read des what mask iface; do<br />
10 echo $des $what $mask $iface<br />
11 done &lt; 12<br />
13 # 输出:<br />
14 # Kernel IP routing table<br />
15 # Destination Gateway Genmask Flags Metric Ref Use Iface<br />
16 # 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo<br />
17<br />
18<br />
19<br />
20 # 由 St閜hane Chazelas给出的,一个更容易理解的等价代码是:<br />
21 route -n |<br />
22 while read des what mask iface; do # 管道的输出被赋给了变量.<br />
23 echo $des $what $mask $iface<br />
24 done # 这样就取回了和上面一样的输出.<br />
25 # 但是, Ulrich Gayer指出 &hellip;<br />
26 #+ 这个简单版本的等价代码在while循环中使用了一个子shell,<br />
27 #+ 因此当管道结束后变量会被毁掉.<br />
28<br />
29<br />
30<br />
31 # 更进一步, Filip Moritz解释了上面两个例子之间有一个细微的不同之处<br />
32 #+ 如下所示.<br />
33<br />
34 (<br />
35 route -n | while read x; do ((y++)); done<br />
36 echo $y # $y 仍然没有被声明或设置<br />
37<br />
38 while read x; do ((y++)); done &lt; 39 echo $y # $y的值为 route -n 输出的行数<br />
40 )<br />
41<br />
42 # 一般来说<br />
43 (<br />
44 : | x=x<br />
45 # 看上去是启动了一个子shell<br />
46 : | ( x=x )<br />
47 # 但<br />
48 x=x &lt; 49 # 实际上不是<br />
50 )<br />
51<br />
52 # 当解析csv或类似的东西时非常有用.<br />
53 # 事实上,这就是SuSE原本的代码片断所要实现的功能.</p>

<p>注意事项:<br />
[1] 这与命名管道(named pipe)(临时文件)有相同的作用, 事实上命名管道同样在进程<br />
替换中被使用.</p>

<h1 id="第23章-函数">第23章 函数</h1>

<p>和&rdquo;真正的&rdquo;编程语言一样, Bash也有函数,虽然在某些实现方面稍有些限制. 一个函数是一个<br />
子程序,用于实现一串操作的代码块(code block),它是完成特定任务的&rdquo;黑盒子&rdquo;. 当有重复<br />
代码, 当一个任务只需要很少的修改就被重复几次执行时, 这时你应考虑使用函数.</p>

<p>function function_name {<br />
command&hellip;<br />
}</p>

<p>或</p>

<p>function_name () {<br />
command&hellip;<br />
}</p>

<p>第二种格式的写法更深得C程序员的喜欢(并且也是更可移植的).</p>

<p>因为在C中,函数的左花括号也可以写在下一行中.</p>

<p>function_name ()<br />
{<br />
command&hellip;<br />
}</p>

<p>函数被调用或被触发, 只需要简单地用函数名调用.</p>

<p>Example 23-1 简单函数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 JUST_A_SECOND=1<br />
4<br />
5 funky ()<br />
6 { # 这是一个最简单的函数.<br />
7 echo &ldquo;This is a funky function.&rdquo;<br />
8 echo &ldquo;Now exiting funky function.&rdquo;<br />
9 } # 函数必须在调用前声明.<br />
10<br />
11<br />
12 fun ()<br />
13 { # 一个稍复杂的函数.<br />
14 i=0<br />
15 REPEATS=30<br />
16<br />
17 echo<br />
18 echo &ldquo;And now the fun really begins.&rdquo;<br />
19 echo<br />
20<br />
21 sleep $JUST_A_SECOND # 嘿, 暂停一秒!<br />
22 while [ $i -lt $REPEATS ]<br />
23 do<br />
24 echo &ldquo;&mdash;&mdash;&mdash;-FUNCTIONS&mdash;&mdash;&mdash;-&gt;&rdquo;<br />
25 echo &ldquo; 26 echo &ldquo;&rdquo;<br />
27 echo<br />
28 let &ldquo;i+=1&rdquo;<br />
29 done<br />
30 }<br />
31<br />
32 # 现在,调用两个函数.<br />
33<br />
34 funky<br />
35 fun<br />
36<br />
37 exit 0<br />
################################End
Script#########################################</p>

<p>函数定义必须在第一次调用函数前完成.没有像C中的函数“声明”方法.</p>

<p>1 f1<br />
2 # 因为函数&rdquo;f1&rdquo;还没有定义,这会引起错误信息.<br />
3<br />
4 declare -f f1 # 这样也没用.<br />
5 f1 # 仍然会引起错误.<br />
6<br />
7 # 然而&hellip;<br />
8<br />
9<br />
10 f1 ()<br />
11 {<br />
12 echo &ldquo;Calling function \&ldquo;f2\&rdquo; from within function \&ldquo;f1\&ldquo;.&rdquo;<br />
13 f2<br />
14 }<br />
15<br />
16 f2 ()<br />
17 {<br />
18 echo &ldquo;Function \&ldquo;f2\&ldquo;.&rdquo;<br />
19 }<br />
20<br />
21 f1 # 虽然在它定义前被引用过,<br />
22 #+ 函数&rdquo;f2&rdquo;实际到这儿才被调用.<br />
23 # 这样是允许的.<br />
24<br />
25 # Thanks, S.C.</p>

<p>在一个函数内嵌套另一个函数也是可以的,但是不常用.</p>

<p>1 f1 ()<br />
2 {<br />
3<br />
4 f2 () # nested<br />
5 {<br />
6 echo &ldquo;Function \&ldquo;f2\&ldquo;, inside \&ldquo;f1\&ldquo;.&rdquo;<br />
7 }<br />
8<br />
9 }<br />
10<br />
11 f2 # 引起错误.<br />
12 # 就是你先&rdquo;declare -f f2&rdquo;了也没用.<br />
13<br />
14 echo<br />
15<br />
16 f1 # 什么也不做,因为调用&rdquo;f1&rdquo;不会自动调用&rdquo;f2&rdquo;.<br />
17 f2 # 现在,可以正确的调用&rdquo;f2&rdquo;了,<br />
18 #+ 因为之前调用&rdquo;f1&rdquo;使&rdquo;f2&rdquo;在脚本中变得可见了.<br />
19<br />
20 # Thanks, S.C.</p>

<p>函数声明可以出现在看上去不可能出现的地方,那些不可能的地方本该由一个命令出现的地方.</p>

<p>1 ls -l | foo() { echo &ldquo;foo&rdquo;; } # 允许,但没什么用.<br />
2<br />
3<br />
4<br />
5 if [ &ldquo;$USER&rdquo; = bozo ]<br />
6 then<br />
7 bozo_greet () # 在if/then结构中定义了函数.<br />
8 {<br />
9 echo &ldquo;Hello, Bozo.&rdquo;<br />
10 }<br />
11 fi<br />
12<br />
13 bozo_greet # 只能由Bozo运行, 其他用户会引起错误.<br />
14<br />
15<br />
16<br />
17 # 在某些上下文,像这样可能会有用.<br />
18 NO_EXIT=1 # 将会打开下面的函数定义.<br />
19<br />
20 [[ $NO_EXIT -eq 1 ]] &amp;&amp; exit() { true; } # 在&rdquo;and-list&rdquo;(and列表)中定义函数.<br />
21 # 如果 $NO_EXIT 是 1,声明函数&rdquo;exit ()&ldquo;.<br />
22 # 把&rdquo;exit&rdquo;取别名为&rdquo;true&rdquo;将会禁用内建的&rdquo;exit&rdquo;.<br />
23<br />
24 exit # 调用&rdquo;exit ()&ldquo;函数, 而不是内建的&rdquo;exit&rdquo;.<br />
25<br />
26 # Thanks, S.C.</p>

<p>23.1. 复杂函数和函数复杂性<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
函数可以处理传递给它的参数并且能返回它的退出状态码(exit status)给脚本后续使用.</p>

<p>1 function_name $arg1 $arg2</p>

<p>函数以位置来引用传递过来的参数(就好像他们是位置参数(positional parameters)), 例如<br />
$1, $2,以此类推.</p>

<p>Example 23-2 带着参数的函数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # 函数和参数<br />
3<br />
4 DEFAULT=default # 默认的参数值.<br />
5<br />
6 func2 () {<br />
7 if [ -z &ldquo;$1&rdquo; ] # 第一个参数是否长度为零?<br />
8 then<br />
9 echo &ldquo;-Parameter #1 is zero length.-&rdquo; # 则没有参数传递进来.<br />
10 else<br />
11 echo &ldquo;-Param #1 is \&ldquo;$1\&ldquo;.-&rdquo;<br />
12 fi<br />
13<br />
14 variable=${1-$DEFAULT} #<br />
15 echo &ldquo;variable = $variable&rdquo; # 参数替换会表现出什么?<br />
16 # &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
17 # 它用于分辨没有参数和一个只有NULL值的参数.<br />
18 #<br />
19<br />
20 if [ &ldquo;$2&rdquo; ]<br />
21 then<br />
22 echo &ldquo;-Parameter #2 is \&ldquo;$2\&ldquo;.-&rdquo;<br />
23 fi<br />
24<br />
25 return 0<br />
26 }<br />
27<br />
28 echo<br />
29<br />
30 echo &ldquo;Nothing passed.&rdquo;<br />
31 func2 # 没有参数来调用<br />
32 echo<br />
33<br />
34<br />
35 echo &ldquo;Zero-length parameter passed.&rdquo;<br />
36 func2 &ldquo;&rdquo; # 以一个长度为零的参数调用<br />
37 echo<br />
38<br />
39 echo &ldquo;Null parameter passed.&rdquo;<br />
40 func2 &ldquo;$uninitialized_param&rdquo; # 以未初始化的参数来调用<br />
41 echo<br />
42<br />
43 echo &ldquo;One parameter passed.&rdquo;<br />
44 func2 first # 用一个参数来调用<br />
45 echo<br />
46<br />
47 echo &ldquo;Two parameters passed.&rdquo;<br />
48 func2 first second # 以二个参数来调用<br />
49 echo<br />
50<br />
51 echo &ldquo;\&rdquo;\&rdquo; \&ldquo;second\&rdquo; passed.&rdquo;<br />
52 func2 &ldquo;&rdquo; second # 以第一个参数为零长度,而第二个参数是一个ASCII码组成的字符串来调用.<br />
53 echo #<br />
54<br />
55 exit 0<br />
################################End
Script#########################################<br />
注意: shift命令可以工作在传递给函数的参数 (参考例子 33-15).</p>

<p>但是,传给脚本的命令行参数怎么办?在函数内部可以看到它们吗?好,让我们来弄清楚.</p>

<p>Example 23-3 函数和被传给脚本的命令行参数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # func-cmdlinearg.sh<br />
3 # 以一个命令行参数来调用这个脚本,<br />
4 #+ 类似 $0 arg1来调用.<br />
5<br />
6<br />
7 func ()<br />
8<br />
9 {<br />
10 echo &ldquo;$1&rdquo;<br />
11 }<br />
12<br />
13 echo &ldquo;First call to function: no arg passed.&rdquo;<br />
14 echo &ldquo;See if command-line arg is seen.&rdquo;<br />
15 func<br />
16 # 不!命令行参数看不到.<br />
17<br />
18 echo &ldquo;============================================================&rdquo;<br />
19 echo<br />
20 echo &ldquo;Second call to function: command-line arg passed explicitly.&rdquo;<br />
21 func $1<br />
22 # 现在可以看到了!<br />
23<br />
24 exit 0<br />
################################End
Script#########################################<br />
与别的编程语言相比,shell脚本一般只传递值给函数,变量名(实现上是指针)如果作为参数传递给函数会被看成是字面上字符串的意思.函数解释参数是以字面上的意思来解释的.</p>

<p>间接变量引用(Indirect variable references) (参考例子 34-2)提供了传递变量指针给函数的一个笨拙的机制.</p>

<p>Example 23-4 传递间接引用给函数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # ind-func.sh: 传递间接引用给函数.<br />
3<br />
4 echo_var ()<br />
5 {<br />
6 echo &ldquo;$1&rdquo;<br />
7 }<br />
8<br />
9 message=Hello<br />
10 Hello=Goodbye<br />
11<br />
12 echo_var &ldquo;$message&rdquo; # Hello<br />
13 # 现在,让我们传递一个间接引用给函数.<br />
14 echo_var &ldquo;${!message}&rdquo; # Goodbye<br />
15<br />
16 echo &ldquo;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
17<br />
18 # 如果我们改变&rdquo;hello&rdquo;变量的值会发生什么?<br />
19 Hello=&ldquo;Hello, again!&rdquo;<br />
20 echo_var &ldquo;$message&rdquo; # Hello<br />
21 echo_var &ldquo;${!message}&rdquo; # Hello, again!<br />
22<br />
23 exit 0<br />
################################End
Script#########################################<br />
下一个逻辑问题是：在传递参数给函数之后是否能解除参数的引用.</p>

<p>Example 23-5 解除传递给函数的参数引用<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # dereference.sh<br />
3 # 给函数传递不同的参数.<br />
4 # Bruce W. Clare编写.<br />
5<br />
6 dereference ()<br />
7 {<br />
8 y=\$&ldquo;$1&rdquo; # 变量名.<br />
9 echo $y # $Junk<br />
10<br />
11 x=<code>eval &quot;expr \&quot;$y\&quot; &quot;</code><br />
12 echo $1=$x<br />
13 eval &ldquo;$1=\&ldquo;Some Different Text \&ldquo;&rdquo; # 赋新值.<br />
14 }<br />
15<br />
16 Junk=&ldquo;Some Text&rdquo;<br />
17 echo $Junk &ldquo;before&rdquo; # Some Text before<br />
18<br />
19 dereference Junk<br />
20 echo $Junk &ldquo;after&rdquo; # Some Different Text after<br />
21<br />
22 exit 0<br />
################################End
Script#########################################</p>

<p>Example 23-6 再次尝试解除传递给函数的参数引用<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # ref-params.sh: 解除传递给函数的参数引用.<br />
3 # (复杂例子)<br />
4<br />
5 ITERATIONS=3 # 取得输入的次数.<br />
6 icount=1<br />
7<br />
8 my_read () {<br />
9 # 用my_read varname来调用,<br />
10 #+ 输出用括号括起的先前的值作为默认值,<br />
11 #+ 然后要求输入一个新值.<br />
12<br />
13 local local_var<br />
14<br />
15 echo -n &ldquo;Enter a value &rdquo;<br />
16 eval &lsquo;echo -n &ldquo;[$&lsquo;$1&rsquo;] &ldquo;&rsquo; # 先前的值.<br />
17 # eval echo -n &ldquo;[\$$1] &ldquo; # 更好理解,<br />
18 #+ 但会丢失用户输入在尾部的空格.<br />
19 read local_var<br />
20 [ -n &ldquo;$local_var&rdquo; ] &amp;&amp; eval $1=\$local_var<br />
21<br />
22 # &ldquo;and列表(And-list)&rdquo;: 如果变量&rdquo;local_var&rdquo;测试成功则把变量&rdquo;$1&rdquo;的值赋给它.<br />
23 }<br />
24<br />
25 echo<br />
26<br />
27 while [ &ldquo;$icount&rdquo; -le &ldquo;$ITERATIONS&rdquo; ]<br />
28 do<br />
29 my_read var<br />
30 echo &ldquo;Entry #$icount = $var&rdquo;<br />
31 let &ldquo;icount += 1&rdquo;<br />
32 echo<br />
33 done<br />
34<br />
35<br />
36 # 多谢Stephane Chazelas提供的示范例子.<br />
37<br />
38 exit 0<br />
################################End
Script#########################################</p>

<p>退出和返回</p>

<p>退出状态(exit status)</p>

<p>函数返回一个被称为退出状态的值. 退出状态可以由return来指定statement, 否则函数的<br />
退出状态是函数最后一个执行命令的退出状态(0表示成功,非0表示出错代码). 退出状态<br />
(exit status)可以在脚本中由$? 引用. 这个机制使脚本函数也可以像C函数一样有一个&rdquo;<br />
返回值&rdquo;.</p>

<p>return</p>

<p>终止一个函数.return 命令[1]可选地带一个整数参数,这个整数作为函数的&rdquo;返回值&rdquo;返回<br />
给调用此函数的脚本,并且这个值也被赋给变量$?.</p>

<p>Example 23-7 两个数中的最大者<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # max.sh: 两个整数中的最大者.<br />
3<br />
4 E_PARAM_ERR=-198 # 如果传给函数的参数少于2个时的返回值.<br />
5 EQUAL=-199 # 如果两个整数值相等的返回值.<br />
6 # 任一个传给函数的参数值溢出<br />
7 #<br />
8<br />
9 max2 () # 返回两个整数的较大值.<br />
10 { # 注意: 参与比较的数必须小于257.<br />
11 if [ -z &ldquo;$2&rdquo; ]<br />
12 then<br />
13 return $E_PARAM_ERR<br />
14 fi<br />
15<br />
16 if [ &ldquo;$1&rdquo; -eq &ldquo;$2&rdquo; ]<br />
17 then<br />
18 return $EQUAL<br />
19 else<br />
20 if [ &ldquo;$1&rdquo; -gt &ldquo;$2&rdquo; ]<br />
21 then<br />
22 return $1<br />
23 else<br />
24 return $2<br />
25 fi<br />
26 fi<br />
27 }<br />
28<br />
29 max2 33 34<br />
30 return_val=$?<br />
31<br />
32 if [ &ldquo;$return_val&rdquo; -eq $E_PARAM_ERR ]<br />
33 then<br />
34 echo &ldquo;Need to pass two parameters to the function.&rdquo;<br />
35 elif [ &ldquo;$return_val&rdquo; -eq $EQUAL ]<br />
36 then<br />
37 echo &ldquo;The two numbers are equal.&rdquo;<br />
38 else<br />
39 echo &ldquo;The larger of the two numbers is $return_val.&rdquo;<br />
40 fi<br />
41<br />
42<br />
43 exit 0<br />
44<br />
45 # 练习 (容易):<br />
46 # &mdash;&mdash;&mdash;&mdash;&mdash;<br />
47 # 把这个脚本转化成交互式的脚本,<br />
48 #+ 也就是说,让脚本可以要求调用者输入两个整数.<br />
################################End
Script#########################################</p>

<p>注意: 为了函数可以返回字符串或是数组,用一个可在函数外可见的变量.</p>

<p>1 count_lines_in_etc_passwd()<br />
2 {<br />
3 [[ -r /etc/passwd ]] &amp;&amp; REPLY=$(echo $(wc -l &lt; /etc/passwd))<br />
4 # 如果/etc/passwd可读,则把REPLY设置成文件的行数.<br />
5 # 返回一个参数值和状态信息.<br />
6 # &lsquo;echo&rsquo;好像没有必要,但 &hellip;<br />
7 #+ 它的作用是删除输出中的多余空白字符.<br />
8 }<br />
9<br />
10 if count_lines_in_etc_passwd<br />
11 then<br />
12 echo &ldquo;There are $REPLY lines in /etc/passwd.&rdquo;<br />
13 else<br />
14 echo &ldquo;Cannot count lines in /etc/passwd.&rdquo;<br />
15 fi<br />
16<br />
17 # Thanks, S.C.</p>

<p>Example 23-8 把数字转化成罗马数字<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2<br />
3 # 阿拉伯数字转化为罗马数字<br />
4 # 转化范围: 0 - 200<br />
5 # 这是比较粗糙的,但可以工作.<br />
6<br />
7 # 扩展可接受的范围来作为脚本功能的扩充,这个作为练习完成.<br />
8<br />
9 # 用法: roman number-to-convert<br />
10<br />
11 LIMIT=200<br />
12 E_ARG_ERR=65<br />
13 E_OUT_OF_RANGE=66<br />
14<br />
15 if [ -z &ldquo;$1&rdquo; ]<br />
16 then<br />
17 echo &ldquo;Usage: <code>basename $0</code> number-to-convert&rdquo;<br />
18 exit $E_ARG_ERR<br />
19 fi<br />
20<br />
21 num=$1<br />
22 if [ &ldquo;$num&rdquo; -gt $LIMIT ]<br />
23 then<br />
24 echo &ldquo;Out of range!&rdquo;<br />
25 exit $E_OUT_OF_RANGE<br />
26 fi<br />
27<br />
28 to_roman () # 在第一次调用函数前必须先定义.<br />
29 {<br />
30 number=$1<br />
31 factor=$2<br />
32 rchar=$3<br />
33 let &ldquo;remainder = number - factor&rdquo;<br />
34 while [ &ldquo;$remainder&rdquo; -ge 0 ]<br />
35 do<br />
36 echo -n $rchar<br />
37 let &ldquo;number -= factor&rdquo;<br />
38 let &ldquo;remainder = number - factor&rdquo;<br />
39 done<br />
40<br />
41 return $number<br />
42 # 练习:<br />
43 # &mdash;&mdash;&ndash;<br />
44 # 解释这个函数是怎么工作的.<br />
45 # 提示: 靠不断地除来分割数字.<br />
46 }<br />
47<br />
48<br />
49 to_roman $num 100 C<br />
50 num=$?<br />
51 to_roman $num 90 LXXXX<br />
52 num=$?<br />
53 to_roman $num 50 L<br />
54 num=$?<br />
55 to_roman $num 40 XL<br />
56 num=$?<br />
57 to_roman $num 10 X<br />
58 num=$?<br />
59 to_roman $num 9 IX<br />
60 num=$?<br />
61 to_roman $num 5 V<br />
62 num=$?<br />
63 to_roman $num 4 IV<br />
64 num=$?<br />
65 to_roman $num 1 I<br />
66<br />
67 echo<br />
68<br />
69 exit 0<br />
################################End
Script#########################################<br />
请参考例子 10-28.</p>

<p>注意: 函数最大可返回的正整数为255. return 命令与退出状态(exit status)的概念联<br />
系很紧密,而退出状态的值受此限制.幸运地是有多种(工作区workarounds)来对<br />
付这种要求函数返回大整数的情况.</p>

<p>Example 23-9 测试函数最大的返回值<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # return-test.sh<br />
3<br />
4 # 一个函数最大可能返回的值是255.<br />
5<br />
6 return_test () # 无论传给函数什么都返回它.<br />
7 {<br />
8 return $1<br />
9 }<br />
10<br />
11 return_test 27 # o.k.<br />
12 echo $? # 返回 27.<br />
13<br />
14 return_test 255 # 仍然 o.k.<br />
15 echo $? # 返回 255.<br />
16<br />
17 return_test 257 # 错误!<br />
18 echo $? # 返回 1 (返回代码指示错误).<br />
19<br />
20 # ======================================================<br />
21 return_test -151896 # 能够返回这个非常大的负数么?<br />
22 echo $? # 会返回-151896?<br />
23 # 不! 它将返回168.<br />
24 # 2.05b版本之前的Bash是允许<br />
25 #+ 超大负整数作为返回值的.<br />
26 # 但是比它更新一点的版本修正了这个漏洞.<br />
27 # 这将破坏比较老的脚本.<br />
28 # 慎用!<br />
29 # ======================================================<br />
30<br />
31 exit 0<br />
################################End
Script#########################################<br />
如果你非常想使用超大整数作为&rdquo;返回值&rdquo;的话, 那么只能通过将你想返回的返回值直接的<br />
传递到一个全局变量中的手段来达到目的.</p>

<p>1 Return_Val= # 全局变量, 用来保存函数中需要返回的超大整数.<br />
2<br />
3 alt_return_test ()<br />
4 {<br />
5 fvar=$1<br />
6 Return_Val=$fvar<br />
7 return # Returns 0 (success).<br />
8 }<br />
9<br />
10 alt_return_test 1<br />
11 echo $? # 0<br />
12 echo &ldquo;return value = $Return_Val&rdquo; # 1<br />
13<br />
14 alt_return_test 256<br />
15 echo &ldquo;return value = $Return_Val&rdquo; # 256<br />
16<br />
17 alt_return_test 257<br />
18 echo &ldquo;return value = $Return_Val&rdquo; # 257<br />
19<br />
20 alt_return_test 25701<br />
21 echo &ldquo;return value = $Return_Val&rdquo; #25701</p>

<p>一种更优雅的方法是让函数echo出它的返回值, 输出到stdout上, 然后再通过&rdquo;命令替换&rdquo;<br />
的手段来捕获它. 参考Section 33.7关于这个问题的讨论.</p>

<p>Example 23-10 比较两个大整数<br />
################################Start
Script#######################################<br />
1 #!/bin/bash<br />
2 # max2.sh: 取两个超大整数中最大的.<br />
3<br />
4 # 这个脚本与前面的&rdquo;max.sh&rdquo;例子作用相同,<br />
5 #+ 经过修改可以适用于比较超大整数.<br />
6<br />
7 EQUAL=0 # 如果两个参数相同的返回值.<br />
8 E_PARAM_ERR=-99999 # 没有足够的参数传递到函数中.<br />
9 # ^^^^^^ 也可能是传递到函数中的某个参数超出范围了.<br />
10<br />
11 max2 () # 从这两个数中&rdquo;返回&rdquo;更大一些的.<br />
12 {<br />
13 if [ -z &ldquo;$2&rdquo; ]<br />
14 then<br />
15 echo $E_PARAM_ERR<br />
16 return<br />
17 fi<br />
18<br />
19 if [ &ldquo;$1&rdquo; -eq &ldquo;$2&rdquo; ]<br />
20 then<br />
21 echo $EQUAL<br />
22 return<br />
23 else<br />
24 if [ &ldquo;$1&rdquo; -gt &ldquo;$2&rdquo; ]<br />
25 then<br />
26 retval=$1<br />
27 else<br />
28 retval=$2<br />
29 fi<br />
30 fi<br />
31<br />
32 echo $retval # echo(到stdout), 而不是使用返回值.<br />
33 # 为什么?<br />
34 }<br />
35<br />
36<br />
37 return_val=$(max2 33001 33997)<br />
38 # ^^^^ 函数名<br />
39 # ^^^^^ ^^^^^ 这是传递进来的参数<br />
40 # 这事实上是一个命令替换的形式:<br />
41 #+ 会把这个函数当作一个命令来处理,<br />
42 #+ 并且分配这个函数的stdout到变量&rdquo;return_val&rdquo;中.<br />
43<br />
44<br />
45 # ========================= OUTPUT ========================<br />
46 if [ &ldquo;$return_val&rdquo; -eq &ldquo;$E_PARAM_ERR&rdquo; ]<br />
47 then<br />
48 echo &ldquo;Error in parameters passed to comparison function!&rdquo;<br />
49 elif [ &ldquo;$return_val&rdquo; -eq &ldquo;$EQUAL&rdquo; ]<br />
50 then<br />
51 echo &ldquo;The two numbers are equal.&rdquo;<br />
52 else<br />
53 echo &ldquo;The larger of the two numbers is $return_val.&rdquo;<br />
54 fi<br />
55 # =========================================================<br />
56<br />
57 exit 0<br />
58<br />
59 # 练习:<br />
60 # &mdash;&ndash;<br />
61 # 1) 找出一种更优雅的方法来测试<br />
62 #+ 传递到函数中的参数.<br />
63 # 2) 在&rdquo;OUTPUT&rdquo;的时候简化if/then结构.<br />
64 # 3) 重写这个脚本使其能够从命令行参数中来获取输入.<br />
################################End
Script#########################################</p>

<p>下边是获得一个函数的&rdquo;返回值&rdquo;的另一个例子. 想要了解这个例子需要一些awk的知识.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:A-Z">A-Z <a class="footnote-return" href="#fnref:A-Z"><sup>[return]</sup></a></li>
<li id="fn:A-Z">A-Z <a class="footnote-return" href="#fnref:A-Z"><sup>[return]</sup></a></li>
<li id="fn:digit">[:digit:] <a class="footnote-return" href="#fnref:digit"><sup>[return]</sup></a></li>
<li id="fn:a-z">a-z <a class="footnote-return" href="#fnref:a-z"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>