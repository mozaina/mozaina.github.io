<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>330picsshellscriptsfifth | 开发者问答集锦</title>
    <meta property="og:title" content="330picsshellscriptsfifth - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="330picsshellscriptsfifth">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/330picsshellscriptsfifth/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">330picsshellscriptsfifth</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><strong><em>@@@life.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="life-sh-life-in-the-slow-lane">life.sh: &ldquo;Life in the Slow Lane&rdquo;</h1>

<h1 id="version-2-patched-by-daniel-albers">Version 2: Patched by Daniel Albers</h1>

<p>#+ to allow non-square grids as input.</p>

<h1 id="toc_2">##################################################################### #</h1>

<h1 id="this-is-the-bash-script-version-of-john-conway-s-game-of-life">This is the Bash script version of John Conway&rsquo;s &ldquo;Game of Life&rdquo;. #</h1>

<h1 id="life-is-a-simple-implementation-of-cellular-automata">&ldquo;Life&rdquo; is a simple implementation of cellular automata. #</h1>

<h1 id="toc_5">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; #</h1>

<h1 id="on-a-rectangular-grid-let-each-cell-be-either-living-or-dead">On a rectangular grid, let each &ldquo;cell&rdquo; be either &ldquo;living&rdquo; or &ldquo;dead&rdquo;. #</h1>

<h1 id="designate-a-living-cell-with-a-dot-and-a-dead-one-with-a-blank-space">Designate a living cell with a dot, and a dead one with a blank space.#</h1>

<h1 id="begin-with-an-arbitrarily-drawn-dot-and-blank-grid">Begin with an arbitrarily drawn dot-and-blank grid, #</h1>

<p>#+ and let this be the starting generation, &ldquo;generation 0&rdquo;. #</p>

<h1 id="determine-each-successive-generation-by-the-following-rules">Determine each successive generation by the following rules: #</h1>

<h1 id="1-each-cell-has-8-neighbors-the-adjoining-cells">1) Each cell has 8 neighbors, the adjoining cells #</h1>

<p>#+ left, right, top, bottom, and the 4 diagonals. #</p>

<h1 id="123">123 #</h1>

<h1 id="4-5">4*5 #</h1>

<h1 id="678">678 #</h1>

<h1 id="toc_14">#</h1>

<h1 id="2-a-living-cell-with-either-2-or-3-living-neighbors-remains-alive">2) A living cell with either 2 or 3 living neighbors remains alive. #</h1>

<h1 id="3-a-dead-cell-with-3-living-neighbors-becomes-alive-a-birth">3) A dead cell with 3 living neighbors becomes alive (a &ldquo;birth&rdquo;). #</h1>

<p>SURVIVE=2 #<br />
BIRTH=3 #</p>

<h1 id="4-all-other-cases-result-in-a-dead-cell-for-the-next-generation">4) All other cases result in a dead cell for the next generation. #</h1>

<h1 id="toc_18">#####################################################################</h1>

<p>startfile=gen0 # Read the starting generation from the file &ldquo;gen0&rdquo;.</p>

<h1 id="default-if-no-other-file-specified-when-invoking-script">Default, if no other file specified when invoking script.</h1>

<p>if [ -n &ldquo;$1&rdquo; ] # Specify another &ldquo;generation 0&rdquo; file.<br />
then<br />
startfile=&ldquo;$1&rdquo;<br />
fi</p>

<p>############################################</p>

<h1 id="abort-script-if-startfile-not-specified">Abort script if &ldquo;startfile&rdquo; not specified</h1>

<p>#+ AND<br />
#+ &ldquo;gen0&rdquo; not present.</p>

<p>E_NOSTARTFILE=68</p>

<p>if [ ! -e &ldquo;$startfile&rdquo; ]<br />
then<br />
echo &ldquo;Startfile /&rdquo;&ldquo;$startfile&rdquo;/&rdquo; missing!&rdquo;<br />
exit $E_NOSTARTFILE<br />
fi<br />
############################################</p>

<p>ALIVE1=.<br />
DEAD1=_</p>

<h1 id="represent-living-and-dead-cells-in-the-start-up-file">Represent living and &ldquo;dead&rdquo; cells in the start-up file.</h1>

<h1 id="toc_22">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- #</h1>

<h1 id="this-script-uses-a-10-x-10-grid-may-be-increased">This script uses a 10 x 10 grid (may be increased,</h1>

<p>#+ but a large grid will will cause very slow execution).<br />
ROWS=10<br />
COLS=10</p>

<h1 id="change-above-two-variables-to-match-grid-size-if-necessary">Change above two variables to match grid size, if necessary.</h1>

<h1 id="toc_25">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</h1>

<p>GENERATIONS=10 # How many generations to cycle through.</p>

<h1 id="adjust-this-upwards">Adjust this upwards,</h1>

<p>#+ if you have time on your hands.</p>

<p>NONE_ALIVE=80 # Exit status on premature bailout,<br />
#+ if no cells left alive.<br />
TRUE=0<br />
FALSE=1<br />
ALIVE=0<br />
DEAD=1</p>

<p>avar= # Global; holds current generation.<br />
generation=0 # Initialize generation count.</p>

<h1 id="toc_27">=================================================================</h1>

<p>let &ldquo;cells = $ROWS * $COLS&rdquo;</p>

<h1 id="how-many-cells">How many cells.</h1>

<p>declare -a initial # Arrays containing &ldquo;cells&rdquo;.<br />
declare -a current</p>

<p>display ()<br />
{</p>

<p>alive=0 # How many cells &ldquo;alive&rdquo; at any given time.</p>

<h1 id="initially-zero">Initially zero.</h1>

<p>declare -a arr<br />
arr=( <code>echo &quot;$1&quot;</code> ) # Convert passed arg to array.</p>

<p>element_count=${#arr[*]}</p>

<p>local i<br />
local rowcheck</p>

<p>for ((i=0; ido</p>

<h1 id="insert-newline-at-end-of-each-row">Insert newline at end of each row.</h1>

<p>let &ldquo;rowcheck = $i % COLS&rdquo;<br />
if [ &ldquo;$rowcheck&rdquo; -eq 0 ]<br />
then<br />
echo # Newline.<br />
echo -n &ldquo; &rdquo; # Indent.<br />
fi</p>

<p>cell=${arr[i]}</p>

<p>if [ &ldquo;$cell&rdquo; = . ]<br />
then<br />
let &ldquo;alive += 1&rdquo;<br />
fi</p>

<p>echo -n &ldquo;$cell&rdquo; | sed -e &rsquo;s/_/ /g&rsquo;</p>

<h1 id="print-out-array-and-change-underscores-to-spaces">Print out array and change underscores to spaces.</h1>

<p>done</p>

<p>return</p>

<p>}</p>

<p>IsValid () # Test whether cell coordinate valid.<br />
{</p>

<p>if [ -z &ldquo;$1&rdquo; -o -z &ldquo;$2&rdquo; ] # Mandatory arguments missing?<br />
then<br />
return $FALSE<br />
fi</p>

<p>local row<br />
local lower_limit=0 # Disallow negative coordinate.<br />
local upper_limit<br />
local left<br />
local right</p>

<p>let &ldquo;upper_limit = $ROWS * $COLS - 1&rdquo; # Total number of cells.</p>

<p>if [ &ldquo;$1&rdquo; -lt &ldquo;$lower_limit&rdquo; -o &ldquo;$1&rdquo; -gt &ldquo;$upper_limit&rdquo; ]<br />
then<br />
return $FALSE # Out of array bounds.<br />
fi</p>

<p>row=$2<br />
let &ldquo;left = $row * $COLS&rdquo; # Left limit.<br />
let &ldquo;right = $left + $COLS - 1&rdquo; # Right limit.</p>

<p>if [ &ldquo;$1&rdquo; -lt &ldquo;$left&rdquo; -o &ldquo;$1&rdquo; -gt &ldquo;$right&rdquo; ]<br />
then<br />
return $FALSE # Beyond row boundary.<br />
fi</p>

<p>return $TRUE # Valid coordinate.</p>

<p>}</p>

<p>IsAlive () # Test whether cell is alive.</p>

<h1 id="takes-array-cell-number-state-of-cell-as-arguments">Takes array, cell number, state of cell as arguments.</h1>

<p>{<br />
GetCount &ldquo;$1&rdquo; $2 # Get alive cell count in neighborhood.<br />
local nhbd=$?</p>

<p>if [ &ldquo;$nhbd&rdquo; -eq &ldquo;$BIRTH&rdquo; ] # Alive in any case.<br />
then<br />
return $ALIVE<br />
fi</p>

<p>if [ &ldquo;$3&rdquo; = &ldquo;.&rdquo; -a &ldquo;$nhbd&rdquo; -eq &ldquo;$SURVIVE&rdquo; ]<br />
then # Alive only if previously alive.<br />
return $ALIVE<br />
fi</p>

<p>return $DEAD # Default.</p>

<p>}</p>

<p>GetCount () # Count live cells in passed cell&rsquo;s neighborhood.</p>

<h1 id="two-arguments-needed">Two arguments needed:</h1>

<h1 id="1-variable-holding-array">$1) variable holding array</h1>

<h1 id="2-cell-number">$2) cell number</h1>

<p>{<br />
local cell_number=$2<br />
local array<br />
local top<br />
local center<br />
local bottom<br />
local r<br />
local row<br />
local i<br />
local t_top<br />
local t_cen<br />
local t_bot<br />
local count=0<br />
local ROW_NHBD=3</p>

<p>array=( <code>echo &quot;$1&quot;</code> )</p>

<p>let &ldquo;top = $cell_number - $COLS - 1&rdquo; # Set up cell neighborhood.<br />
let &ldquo;center = $cell_number - 1&rdquo;<br />
let &ldquo;bottom = $cell_number + $COLS - 1&rdquo;<br />
let &ldquo;r = $cell_number / $COLS&rdquo;</p>

<p>for ((i=0; i do<br />
let &ldquo;t_top = $top + $i&rdquo;<br />
let &ldquo;t_cen = $center + $i&rdquo;<br />
let &ldquo;t_bot = $bottom + $i&rdquo;</p>

<p>let &ldquo;row = $r&rdquo; # Count center row of neighborhood.<br />
IsValid $t_cen $row # Valid cell position?<br />
if [ $? -eq &ldquo;$TRUE&rdquo; ]<br />
then<br />
if [ ${array[$t_cen]} = &ldquo;$ALIVE1&rdquo; ] # Is it alive?<br />
then # Yes?<br />
let &ldquo;count += 1&rdquo; # Increment count.<br />
fi<br />
fi</p>

<p>let &ldquo;row = $r - 1&rdquo; # Count top row.<br />
IsValid $t_top $row<br />
if [ $? -eq &ldquo;$TRUE&rdquo; ]<br />
then<br />
if [ ${array[$t_top]} = &ldquo;$ALIVE1&rdquo; ]<br />
then<br />
let &ldquo;count += 1&rdquo;<br />
fi<br />
fi</p>

<p>let &ldquo;row = $r + 1&rdquo; # Count bottom row.<br />
IsValid $t_bot $row<br />
if [ $? -eq &ldquo;$TRUE&rdquo; ]<br />
then<br />
if [ ${array[$t_bot]} = &ldquo;$ALIVE1&rdquo; ]<br />
then<br />
let &ldquo;count += 1&rdquo;<br />
fi<br />
fi</p>

<p>done</p>

<p>if [ ${array[$cell_number]} = &ldquo;$ALIVE1&rdquo; ]<br />
then<br />
let &ldquo;count -= 1&rdquo; # Make sure value of tested cell itself<br />
fi #+ is not counted.</p>

<p>return $count</p>

<p>}</p>

<p>next_gen () # Update generation array.<br />
{</p>

<p>local array<br />
local i=0</p>

<p>array=( <code>echo &quot;$1&quot;</code> ) # Convert passed arg to array.</p>

<p>while [ &ldquo;$i&rdquo; -lt &ldquo;$cells&rdquo; ]<br />
do<br />
IsAlive &ldquo;$1&rdquo; $i ${array[$i]} # Is cell alive?<br />
if [ $? -eq &ldquo;$ALIVE&rdquo; ]<br />
then # If alive, then<br />
array[$i]=. #+ represent the cell as a period.<br />
else<br />
array[$i]=&rdquo;_&rdquo; # Otherwise underscore<br />
fi #+ (which will later be converted to space).<br />
let &ldquo;i += 1&rdquo;<br />
done</p>

<h1 id="let-generation-1-increment-generation-count">let &ldquo;generation += 1&rdquo; # Increment generation count.</h1>

<h1 id="why-was-the-above-line-commented-out">Why was the above line commented out?</h1>

<h1 id="set-variable-to-pass-as-parameter-to-display-function">Set variable to pass as parameter to &ldquo;display&rdquo; function.</h1>

<p>avar=<code>echo ${array[@]}</code> # Convert array back to string variable.<br />
display &ldquo;$avar&rdquo; # Display it.<br />
echo; echo<br />
echo &ldquo;Generation $generation - $alive alive&rdquo;</p>

<p>if [ &ldquo;$alive&rdquo; -eq 0 ]<br />
then<br />
echo<br />
echo &ldquo;Premature exit: no more cells alive!&rdquo;<br />
exit $NONE_ALIVE # No point in continuing<br />
fi #+ if no live cells.</p>

<p>}</p>

<h1 id="toc_39">=========================================================</h1>

<h1 id="main">main ()</h1>

<h1 id="load-initial-array-with-contents-of-startup-file">Load initial array with contents of startup file.</h1>

<p>initial=( <code>cat &quot;$startfile&quot; | sed -e '/#/d' | tr -d '/n' |/  
sed -e 's//.//. /g' -e 's/_/_ /g'</code> )</p>

<h1 id="delete-lines-containing-comment-character">Delete lines containing &lsquo;#&rsquo; comment character.</h1>

<h1 id="remove-linefeeds-and-insert-space-between-elements">Remove linefeeds and insert space between elements.</h1>

<p>clear # Clear screen.</p>

<p>echo # Title<br />
echo &ldquo;=======================&rdquo;<br />
echo &ldquo; $GENERATIONS generations&rdquo;<br />
echo &ldquo; of&rdquo;<br />
echo &ldquo;/&ldquo;Life in the Slow Lane/&rdquo;&rdquo;<br />
echo &ldquo;=======================&rdquo;</p>

<h1 id="display-first-generation">&mdash;&mdash;&ndash; Display first generation. &mdash;&mdash;&ndash;</h1>

<p>Gen0=<code>echo ${initial[@]}</code><br />
display &ldquo;$Gen0&rdquo; # Display only.<br />
echo; echo<br />
echo &ldquo;Generation $generation - $alive alive&rdquo;</p>

<h1 id="toc_45">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</h1>

<p>let &ldquo;generation += 1&rdquo; # Increment generation count.<br />
echo</p>

<h1 id="display-second-generation">&mdash;&mdash;- Display second generation. &mdash;&mdash;-</h1>

<p>Cur=<code>echo ${initial[@]}</code><br />
next_gen &ldquo;$Cur&rdquo; # Update &amp; display.</p>

<h1 id="toc_47">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<p>let &ldquo;generation += 1&rdquo; # Increment generation count.</p>

<h1 id="main-loop-for-displaying-subsequent-generations">&mdash;&mdash; Main loop for displaying subsequent generations &mdash;&mdash;</h1>

<p>while [ &ldquo;$generation&rdquo; -le &ldquo;$GENERATIONS&rdquo; ]<br />
do<br />
Cur=&ldquo;$avar&rdquo;<br />
next_gen &ldquo;$Cur&rdquo;<br />
let &ldquo;generation += 1&rdquo;<br />
done</p>

<h1 id="toc_49">==============================================================</h1>

<p>echo</p>

<p>exit 0 # END</p>

<h1 id="the-grid-in-this-script-has-a-boundary-problem">The grid in this script has a &ldquo;boundary problem.&rdquo;</h1>

<h1 id="the-the-top-bottom-and-sides-border-on-a-void-of-dead-cells">The the top, bottom, and sides border on a void of dead cells.</h1>

<h1 id="exercise-change-the-script-to-have-the-grid-wrap-around">Exercise: Change the script to have the grid wrap around,</h1>

<h1 id="so-that-the-left-and-right-sides-will-touch">+ so that the left and right sides will &ldquo;touch,&rdquo;</h1>

<h1 id="as-will-the-top-and-bottom">+ as will the top and bottom.</h1>

<h1 id="exercise-create-a-new-gen0-file-to-seed-this-script">Exercise: Create a new &ldquo;gen0&rdquo; file to seed this script.</h1>

<h1 id="use-a-12-x-16-grid-instead-of-the-original-10-x-10-one">Use a 12 x 16 grid, instead of the original 10 x 10 one.</h1>

<h1 id="make-the-necessary-changes-to-the-script">Make the necessary changes to the script,</h1>

<p>#+ so it will run with the altered file.</p>

<h1 id="exercise-modify-this-script-so-that-it-can-determine-the-grid-size">Exercise: Modify this script so that it can determine the grid size</h1>

<p>#+ from the &ldquo;gen0&rdquo; file, and set any variables necessary<br />
#+ for the script to run.</p>

<h1 id="this-would-make-unnecessary-any-changes-to-variables">This would make unnecessary any changes to variables</h1>

<p>#+ in the script for an altered grid size.<br />
%%%&amp;&amp;&amp;life.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@line-
number.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="line-number-sh">line-number.sh</h1>

<h1 id="这个脚本将会echo自身两次-并显示行号">这个脚本将会echo自身两次, 并显示行号.</h1>

<h1 id="nl-命令显示的时候你将会看到-本行是第4行-因为它不计空行">&lsquo;nl&rsquo;命令显示的时候你将会看到, 本行是第4行, 因为它不计空行.</h1>

<h1 id="cat-n-命令显示的时候你将会看到-本行是第6行">&lsquo;cat -n&rsquo;命令显示的时候你将会看到, 本行是第6行.</h1>

<p>nl <code>basename $0</code></p>

<p>echo; echo # 下边, 让我们试试 &lsquo;cat -n&rsquo;</p>

<p>cat -n <code>basename $0</code></p>

<h1 id="区别就是-cat-n-对空行也进行计数">区别就是&rsquo;cat -n&rsquo;对空行也进行计数.</h1>

<h1 id="注意-nl-ba-也会这么做">注意&rsquo;nl -ba&rsquo;也会这么做.</h1>

<p>exit 0</p>

<h1 id="toc_66">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<p>%%%&amp;&amp;&amp;line-
number.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@list-
glob.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="list-glob-sh-使用-globbing-在for循环中产生-list">list-glob.sh: 使用&rdquo;globbing&rdquo;, 在for循环中产生[list]</h1>

<p>echo</p>

<p>for file in *</p>

<h1 id="在表达式中识别文件名匹配时">^ 在表达式中识别文件名匹配时,</h1>

<p>#+ Bash将执行文件名扩展.<br />
do<br />
ls -l &ldquo;$file&rdquo; # 列出在$PWD(当前目录)中的所有文件.</p>

<h1 id="回想一下-通配符-能够匹配所有文件">回想一下,通配符&rdquo;*&ldquo;能够匹配所有文件,</h1>

<p>#+ 然而,在&rdquo;globbing&rdquo;中,是不能比配&rdquo;.&ldquo;文件的.</p>

<h1 id="如果没匹配到任何文件-那它将扩展成自己">如果没匹配到任何文件,那它将扩展成自己.</h1>

<h1 id="为了不让这种情况发生-那就设置nullglob选项">为了不让这种情况发生,那就设置nullglob选项</h1>

<p>#+ (shopt -s nullglob).</p>

<h1 id="感谢-s-c">感谢, S.C.</h1>

<p>done</p>

<p>echo; echo</p>

<p>for file in [jx]*<br />
do<br />
rm -f $file # 只删除当前目录下以&rdquo;j&rdquo;或&rdquo;x&rdquo;开头的文件.<br />
echo &ldquo;Removed file /&rdquo;$file/&ldquo;&rdquo;.<br />
done</p>

<p>echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;list-
glob.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@logevents.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="logevents-sh-由stephane-chazelas所编写">logevents.sh, 由Stephane Chazelas所编写.</h1>

<h1 id="把事件记录在一个文件中">把事件记录在一个文件中.</h1>

<h1 id="必须以root身份运行-这样才有权限访问-var-log">必须以root身份运行 (这样才有权限访问/var/log).</h1>

<p>ROOT_UID=0 # 只有$UID值为0的用户才具有root权限.<br />
E_NOTROOT=67 # 非root用户的退出错误.</p>

<p>if [ &ldquo;$UID&rdquo; -ne &ldquo;$ROOT_UID&rdquo; ]<br />
then<br />
echo &ldquo;Must be root to run this script.&rdquo;<br />
exit $E_NOTROOT<br />
fi</p>

<p>FD_DEBUG1=3<br />
FD_DEBUG2=4<br />
FD_DEBUG3=5</p>

<h1 id="去掉下边两行注释中的一行-来激活脚本">去掉下边两行注释中的一行, 来激活脚本.</h1>

<h1 id="log-events-1">LOG_EVENTS=1</h1>

<h1 id="log-vars-1">LOG_VARS=1</h1>

<p>log() # 把时间和日期写入日志文件.<br />
{<br />
echo &ldquo;$(date) $*&rdquo; &gt;&amp;7 # 这会把日期*附加*到文件中.</p>

<h1 id="参考下边的代码">参考下边的代码.</h1>

<p>}</p>

<p>case $LOG_LEVEL in<br />
1) exec 3&gt;&amp;2 4&gt; /dev/null 5&gt; /dev/null;;<br />
2) exec 3&gt;&amp;2 4&gt;&amp;2 5&gt; /dev/null;;<br />
3) exec 3&gt;&amp;2 4&gt;&amp;2 5&gt;&2;;<br />
*) exec 3&gt; /dev/null 4&gt; /dev/null 5&gt; /dev/null;;<br />
esac</p>

<p>FD_LOGVARS=6<br />
if [[ $LOG_VARS ]]<br />
then exec 6&gt;&gt; /var/log/vars.log<br />
else exec 6&gt; /dev/null # 丢弃输出.<br />
fi</p>

<p>FD_LOGEVENTS=7<br />
if [[ $LOG_EVENTS ]]<br />
then</p>

<h1 id="then-exec-7-exec-gawk-print-strftime-0-var-log-event-log">then exec 7 &gt;(exec gawk &lsquo;{print strftime(), $0}&rsquo; &gt;&gt; /var/log/event.log)</h1>

<h1 id="上面这行不能在2-04版本的bash上运行">上面这行不能在2.04版本的Bash上运行.</h1>

<p>exec 7&gt;&gt; /var/log/event.log # 附加到&rdquo;event.log&rdquo;.<br />
log # 记录日期与时间.<br />
else exec 7&gt; /dev/null # 丢弃输出.<br />
fi</p>

<p>echo &ldquo;DEBUG3: beginning&rdquo; &gt;&amp;${FD_DEBUG3}</p>

<p>ls -l &gt;&amp;5 2&gt;&amp;4 # command1 &gt;&amp;5 2&gt;&amp;4</p>

<p>echo &ldquo;Done&rdquo; # command2</p>

<p>echo &ldquo;sending mail&rdquo; &gt;&amp;${FD_LOGEVENTS} # 将字符串&rdquo;sending mail&rdquo;写到文件描述符#7.</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;logevents.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@logging-
wrapper.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="通用的shell包装">通用的shell包装,</h1>

<p>#+ 执行一个操作, 然后把所作的操作写入到日志文件中.</p>

<h1 id="需要设置如下两个变量">需要设置如下两个变量.</h1>

<p>OPERATION=</p>

<h1 id="可以是一个复杂的命令链">可以是一个复杂的命令链,</h1>

<p>#+ 比如awk脚本或者一个管道 &hellip;<br />
LOGFILE=</p>

<h1 id="命令行参数-不管怎么样-操作一般都需要参数-译者注-这行解释的是下面的options变量-不是logfile">命令行参数, 不管怎么样, 操作一般都需要参数. (译者注: 这行解释的是下面的OPTIONS变量, 不是LOGFILE.)</h1>

<p>OPTIONS=&ldquo;$@&rdquo;</p>

<h1 id="记录下来">记录下来.</h1>

<p>echo &ldquo;<code>date</code> + <code>whoami</code> + $OPERATION &ldquo;$@&rdquo;&rdquo; &gt;&gt; $LOGFILE</p>

<h1 id="现在-执行操作">现在, 执行操作.</h1>

<p>exec $OPERATION &ldquo;$@&rdquo;</p>

<h1 id="必须在操作执行之前-记录到日志文件中">必须在操作执行之前, 记录到日志文件中.</h1>

<h1 id="为什么">为什么?</h1>

<p>%%%&amp;&amp;&amp;logging-
wrapper.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@lookup.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="lookup-对指定数据文件中的每个单词都做一遍字典查询">lookup: 对指定数据文件中的每个单词都做一遍字典查询.</h1>

<p>file=words.data # 指定的要搜索的数据文件.</p>

<p>echo</p>

<p>while [ &ldquo;$word&rdquo; != end ] # 数据文件中最后一个单词.<br />
do<br />
read word # 从数据文件中读, 因为在循环的后边重定向了.<br />
look $word &gt; /dev/null # 不想将字典文件中的行显示出来.<br />
lookup=$? # &lsquo;look&rsquo;命令的退出状态.</p>

<p>if [ &ldquo;$lookup&rdquo; -eq 0 ]<br />
then<br />
echo &ldquo;/&rdquo;$word/&rdquo; is valid.&rdquo;<br />
else<br />
echo &ldquo;/&rdquo;$word/&rdquo; is invalid.&rdquo;<br />
fi</p>

<p>done</p>

<p>echo</p>

<p>exit 0</p>

<h1 id="toc_91">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</h1>

<h1 id="下边的代码行将不会执行-因为上边已经有-exit-命令了">下边的代码行将不会执行, 因为上边已经有&rdquo;exit&rdquo;命令了.</h1>

<h1 id="stephane-chazelas建议使用下边更简洁的方法">Stephane Chazelas建议使用下边更简洁的方法:</h1>

<p>while read word &amp;&amp; [[ $word != end ]]<br />
do if look &ldquo;$word&rdquo; &gt; /dev/null<br />
then echo &ldquo;/&rdquo;$word/&rdquo; is valid.&rdquo;<br />
else echo &ldquo;/&rdquo;$word/&rdquo; is invalid.&rdquo;<br />
fi<br />
done</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;lookup.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@lowercase.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="将当前目录下的所有文全部转换为小写">将当前目录下的所有文全部转换为小写.</h1>

<h1 id="灵感来自于john-dubois的脚本">灵感来自于John Dubois的脚本,</h1>

<p>#+ Chet Ramey将其转换为Bash脚本,<br />
#+ 然后被本书作者精简了一下.</p>

<p>for filename in * # 遍历当前目录下的所有文件.<br />
do<br />
fname=<code>basename $filename</code><br />
n=<code>echo $fname | tr A-Z a-z</code> # 将名字修改为小写.<br />
if [ &ldquo;$fname&rdquo; != &ldquo;$n&rdquo; ] # 只对那些文件名不是小写的文件进行重命名.<br />
then<br />
mv $fname $n<br />
fi<br />
done</p>

<p>exit $?</p>

<h1 id="下边的代码将不会被执行-因为上边的-exit">下边的代码将不会被执行, 因为上边的&rdquo;exit&rdquo;.</h1>

<p>#&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-#</p>

<h1 id="删除上边的内容-来运行下边的内容">删除上边的内容, 来运行下边的内容.</h1>

<h1 id="对于那些文件名中包含空白和新行的文件-上边的脚本就不能工作了">对于那些文件名中包含空白和新行的文件, 上边的脚本就不能工作了.</h1>

<h1 id="stephane-chazelas因此建议使用下边的方法">Stephane Chazelas因此建议使用下边的方法:</h1>

<p>for filename in * # 不必非得使用basename命令,</p>

<h1 id="因为-不会返回任何包含-的文件">因为&rdquo;*&ldquo;不会返回任何包含&rdquo;/&ldquo;的文件.</h1>

<p>do n=<code>echo &quot;$filename/&quot; | tr '[:upper:]' '[:lower:]'</code></p>

<h1 id="posix-字符集标记法">POSIX 字符集标记法.</h1>

<h1 id="添加的斜线是为了在文件名结尾换行不会被">添加的斜线是为了在文件名结尾换行不会被</h1>

<h1 id="命令替换删掉">命令替换删掉.</h1>

<h1 id="变量替换">变量替换:</h1>

<p>n=${n%/} # 从文件名中将上边添加在结尾的斜线删除掉.<br />
[[ $filename == $n ]] || mv &ldquo;$filename&rdquo; &ldquo;$n&rdquo;</p>

<h1 id="检查文件名是否已经是小写">检查文件名是否已经是小写.</h1>

<p>done</p>

<p>exit $?<br />
%%%&amp;&amp;&amp;lowercase.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@m4.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="m4-sh-使用m4宏处理器">m4.sh: 使用m4宏处理器</h1>

<h1 id="字符串操作">字符串操作</h1>

<p>string=abcdA01<br />
echo &ldquo;len($string)&rdquo; | m4 # 7<br />
echo &ldquo;substr($string,4)&rdquo; | m4 # A01<br />
echo &ldquo;regexp($string,[0-1][0-1],/&amp;Z)&rdquo; | m4 # 01Z</p>

<h1 id="算术操作">算术操作</h1>

<p>echo &ldquo;incr(22)&rdquo; | m4 # 23<br />
echo &ldquo;eval(99 / 3)&rdquo; | m4 # 33</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;m4.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@mailbox_grep.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="由francisco-lobo所提供的脚本">由Francisco Lobo所提供的脚本,</h1>

<p>#+ 本文作者进行了少量修改和注释.</p>

<h1 id="并且经过授权-可以使用在本书中-感谢你">并且经过授权, 可以使用在本书中.(感谢你!)</h1>

<h1 id="这个脚本不能运行于比bash-version-3-0更低的版本中">这个脚本不能运行于比Bash version 3.0更低的版本中.</h1>

<p>E_MISSING_ARG=67<br />
if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
echo &ldquo;Usage: $0 mailbox-file&rdquo;<br />
exit $E_MISSING_ARG<br />
fi</p>

<p>mbox_grep() # 分析邮箱文件.<br />
{<br />
declare -i body=0 match=0<br />
declare -a date sender<br />
declare mail header value</p>

<p>while IFS= read -r mail</p>

<h1 id="重新设置-ifs">^^^^ 重新设置$IFS.</h1>

<h1 id="否则-read-会从它的输入中截去开头和结尾的空格">否则&rdquo;read&rdquo;会从它的输入中截去开头和结尾的空格.</h1>

<p>do<br />
if [[ $mail =~ &ldquo;^From &rdquo; ]] # 匹配消息中的&rdquo;From&rdquo;域.<br />
then<br />
(( body = 0 )) # 取消(&ldquo;Zero out&rdquo;俚语)变量.<br />
(( match = 0 ))<br />
unset date</p>

<p>elif (( body ))<br />
then<br />
(( match ))</p>

<h1 id="echo-mail">echo &ldquo;$mail&rdquo;</h1>

<h1 id="如果你想显示整个消息体的话-那么就打开上面的注释行">如果你想显示整个消息体的话, 那么就打开上面的注释行.</h1>

<p>elif [[ $mail ]]; then<br />
IFS=: read -r header value &lt;&lt;&lt; &ldquo;$mail&rdquo;</p>

<h1 id="here-string">^^^ &ldquo;here string&rdquo;</h1>

<p>case &ldquo;$header&rdquo; in<br />
[Ff][Rr][Oo][Mm] ) [[ $value =~ &ldquo;$2&rdquo; ]] &amp;&amp; (( match++ )) ;;</p>

<h1 id="匹配-from-行">匹配&rdquo;From&rdquo;行.</h1>

<p>[Dd][Aa][Tt][Ee] ) read -r -a date &lt;&lt;&lt; &ldquo;$value&rdquo; ;;</p>

<h1 id="toc_118">^^^</h1>

<h1 id="匹配-date-行">匹配&rdquo;Date&rdquo;行.</h1>

<p>[Rr][Ee][Cc][Ee][Ii][Vv][Ee][Dd] ) read -r -a sender &lt;&lt;&lt; &ldquo;$value&rdquo; ;;</p>

<h1 id="toc_120">^^^</h1>

<h1 id="匹配ip地址-可能被欺骗">匹配IP地址(可能被欺骗).</h1>

<p>esac</p>

<p>else<br />
(( body++ ))<br />
(( match )) &amp;&amp;<br />
echo &ldquo;MESSAGE ${date:+of: ${date[*]} }&rdquo;</p>

<h1 id="整个-date数组">整个$date数组 ^</h1>

<p>echo &ldquo;IP address of sender: ${sender[1]}&rdquo;</p>

<h1 id="received-行的第二个域">&ldquo;Received&rdquo;行的第二个域 ^</h1>

<p>fi</p>

<p>done &lt; &ldquo;$1&rdquo; # 将文件的stdout重定向到循环中.<br />
}</p>

<p>mbox_grep &ldquo;$1&rdquo; # 将邮箱文件发送到函数中.</p>

<p>exit $?</p>

<h1 id="练习">练习:</h1>

<h1 id="toc_125">&mdash;&ndash;</h1>

<h1 id="1-拆开上面的这个函数-把它分成多个函数">1) 拆开上面的这个函数, 把它分成多个函数,</h1>

<p>#+ 这样可以提高代码的可读性.</p>

<h1 id="2-对这个脚本添加额外的分析-可以分析不同的关键字">2) 对这个脚本添加额外的分析, 可以分析不同的关键字.</h1>

<p>$ mailbox_grep.sh scam_mail<br />
--&gt; MESSAGE of Thu, 5 Jan 2006 08:00:56 -0500 (EST)<br />
--&gt; IP address of sender: 196.3.62.4<br />
%%%&amp;&amp;&amp;mailbox_grep.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@mail-
format.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="mail-format-sh-ver-1-1-format-e-mail-messages">mail-format.sh (ver. 1.1): Format e-mail messages.</h1>

<h1 id="gets-rid-of-carets-tabs-and-also-folds-excessively-long-lines">Gets rid of carets, tabs, and also folds excessively long lines.</h1>

<h1 id="toc_130">=================================================================</h1>

<h1 id="standard-check-for-script-argument-s">Standard Check for Script Argument(s)</h1>

<p>ARGS=1<br />
E_BADARGS=65<br />
E_NOFILE=66</p>

<p>if [ $# -ne $ARGS ] # Correct number of arguments passed to script?<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
exit $E_BADARGS<br />
fi</p>

<p>if [ -f &ldquo;$1&rdquo; ] # Check if file exists.<br />
then<br />
file_name=$1<br />
else<br />
echo &ldquo;File /&rdquo;$1/&rdquo; does not exist.&rdquo;<br />
exit $E_NOFILE<br />
fi</p>

<h1 id="toc_132">=================================================================</h1>

<p>MAXWIDTH=70 # Width to fold excessively long lines to.</p>

<h1 id="toc_133">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<h1 id="a-variable-can-hold-a-sed-script">A variable can hold a sed script.</h1>

<p>sedscript=&rsquo;s/^&gt;//<br />
s/^ *&gt;//<br />
s/^ *//<br />
s/ *//&rsquo;</p>

<h1 id="toc_135">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<h1 id="delete-carets-and-tabs-at-beginning-of-lines">Delete carets and tabs at beginning of lines,</h1>

<p>#+ then fold lines to $MAXWIDTH characters.<br />
sed &ldquo;$sedscript&rdquo; $1 | fold -s &ndash;width=$MAXWIDTH</p>

<h1 id="s-option-to-fold">-s option to &ldquo;fold&rdquo;</h1>

<p>#+ breaks lines at whitespace, if possible.</p>

<h1 id="this-script-was-inspired-by-an-article-in-a-well-known-trade-journal">This script was inspired by an article in a well-known trade journal</h1>

<p>#+ extolling a 164K MS Windows utility with similar functionality.</p>

<h1 id="an-nice-set-of-text-processing-utilities-and-an-efficient">An nice set of text processing utilities and an efficient</h1>

<p>#+ scripting language provide an alternative to bloated executables.</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;mail-
format.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@makedict.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="makedict-sh-make-dictionary">makedict.sh [make dictionary]</h1>

<h1 id="modification-of-usr-sbin-mkdict-script">Modification of /usr/sbin/mkdict script.</h1>

<h1 id="original-script-copyright-1993-by-alec-muffett">Original script copyright 1993, by Alec Muffett.</h1>

<h1 id="this-modified-script-included-in-this-document-in-a-manner">This modified script included in this document in a manner</h1>

<p>#+ consistent with the &ldquo;LICENSE&rdquo; document of the &ldquo;Crack&rdquo; package<br />
#+ that the original script is a part of.</p>

<h1 id="this-script-processes-text-files-to-produce-a-sorted-list">This script processes text files to produce a sorted list</h1>

<p>#+ of words found in the files.</p>

<h1 id="this-may-be-useful-for-compiling-dictionaries">This may be useful for compiling dictionaries</h1>

<p>#+ and for lexicographic research.</p>

<p>E_BADARGS=65</p>

<p>if [ ! -r &ldquo;$1&rdquo; ] # Need at least one<br />
then #+ valid file argument.<br />
echo &ldquo;Usage: $0 files-to-process&rdquo;<br />
exit $E_BADARGS<br />
fi</p>

<h1 id="sort-sort-no-longer-necessary-to-define-options">SORT=&ldquo;sort&rdquo; # No longer necessary to define options</h1>

<p>#+ to sort. Changed from original script.</p>

<p>cat $* | # Contents of specified files to stdout.<br />
tr A-Z a-z | # Convert to lowercase.<br />
tr &lsquo; &rsquo; &lsquo;/012&rsquo; | # New: change spaces to newlines.</p>

<h1 id="tr-cd-012-a-z-0-9-get-rid-of-everything-non-alphanumeric">tr -cd &lsquo;/012[a-z][0-9]&rsquo; | # Get rid of everything non-alphanumeric</h1>

<p>#+ (original script).<br />
tr -c &lsquo;/012a-z&rsquo; &lsquo;/012&rsquo; | # Rather than deleting<br />
#+ now change non-alpha to newlines.<br />
sort | # $SORT options unnecessary now.<br />
uniq | # Remove duplicates.<br />
grep -v &lsquo;^#&rsquo; | # Delete lines beginning with a hashmark.<br />
grep -v &lsquo;^$&rsquo; # Delete blank lines.</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;makedict.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@manview.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="manview-sh-将man页源文件格式化以方便查看">manview.sh: 将man页源文件格式化以方便查看.</h1>

<h1 id="当你想阅读man页的时候-这个脚本就有用了">当你想阅读man页的时候, 这个脚本就有用了.</h1>

<h1 id="它允许你在运行的时候查看">它允许你在运行的时候查看</h1>

<p>#+ 中间结果.</p>

<p>E_WRONGARGS=65</p>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> filename&rdquo;<br />
exit $E_WRONGARGS<br />
fi</p>

<h1 id="toc_151">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<p>groff -Tascii -man $1 | less</p>

<h1 id="来自于groff的man页">来自于groff的man页.</h1>

<h1 id="toc_153">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<h1 id="如果man页中包括表或者等式">如果man页中包括表或者等式,</h1>

<p>#+ 那么上边的代码就够呛了.</p>

<h1 id="下边的这行代码可以解决上边的这个问题">下边的这行代码可以解决上边的这个问题.</h1>

<h1 id="gtbl-1-geqn-tlatin1-groff-tlatin1-mtty-char-man">gtbl &lt; &ldquo;$1&rdquo; | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man</h1>

<h1 id="感谢-s-c-1">感谢, S.C.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;manview.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@match-
string.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="match-string-sh-简单的字符串匹配">match-string.sh: 简单的字符串匹配</h1>

<p>match_string ()<br />
{<br />
MATCH=0<br />
NOMATCH=90<br />
PARAMS=2 # 此函数需要2个参数.<br />
BAD_PARAMS=91</p>

<p>[ $# -eq $PARAMS ] || return $BAD_PARAMS</p>

<p>case &ldquo;$1&rdquo; in<br />
&rdquo;$2&rdquo;) return $MATCH;;<br />
* ) return $NOMATCH;;<br />
esac</p>

<p>}</p>

<p>a=one<br />
b=two<br />
c=three<br />
d=two</p>

<p>match_string $a # 参数个数错误.<br />
echo $? # 91</p>

<p>match_string $a $b # 不匹配<br />
echo $? # 90</p>

<p>match_string $b $d # 匹配<br />
echo $? # 0</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;match-
string.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@max2.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="max2-sh-取两个大整数中的最大值">max2.sh: 取两个大整数中的最大值.</h1>

<h1 id="这是前一个例子-max-sh-的修改版">这是前一个例子&rdquo;max.sh&rdquo;的修改版,</h1>

<p>#+ 这个版本可以比较两个大整数.</p>

<p>EQUAL=0 # 如果两个值相等, 那就返回这个值.<br />
E_PARAM_ERR=-99999 # 没有足够多的参数传递给函数.</p>

<h1 id="任意超出范围的参数都可以传递进来">^^^^^^ 任意超出范围的参数都可以传递进来.</h1>

<p>max2 () # &ldquo;返回&rdquo;两个整数中最大的那个.<br />
{<br />
if [ -z &ldquo;$2&rdquo; ]<br />
then<br />
echo $E_PARAM_ERR<br />
return<br />
fi</p>

<p>if [ &ldquo;$1&rdquo; -eq &ldquo;$2&rdquo; ]<br />
then<br />
echo $EQUAL<br />
return<br />
else<br />
if [ &ldquo;$1&rdquo; -gt &ldquo;$2&rdquo; ]<br />
then<br />
retval=$1<br />
else<br />
retval=$2<br />
fi<br />
fi</p>

<p>echo $retval # 输出(到stdout), 而没有用返回值.</p>

<h1 id="为什么-1">为什么?</h1>

<p>}</p>

<p>return_val=$(max2 33001 33997)</p>

<h1 id="函数名">^^^^ 函数名</h1>

<h1 id="传递进来的参数">^^^^^ ^^^^^ 传递进来的参数</h1>

<h1 id="这其实是命令替换的一种形式">这其实是命令替换的一种形式:</h1>

<p>#+ 可以把函数看作为一个命令,<br />
#+ 然后把函数的stdout赋值给变量&rdquo;return_val.&rdquo;</p>

<h1 id="output">========================= OUTPUT ========================</h1>

<p>if [ &ldquo;$return_val&rdquo; -eq &ldquo;$E_PARAM_ERR&rdquo; ]<br />
then<br />
echo &ldquo;Error in parameters passed to comparison function!&rdquo;<br />
elif [ &ldquo;$return_val&rdquo; -eq &ldquo;$EQUAL&rdquo; ]<br />
then<br />
echo &ldquo;The two numbers are equal.&rdquo;<br />
else<br />
echo &ldquo;The larger of the two numbers is $return_val.&rdquo;<br />
fi</p>

<h1 id="toc_167">=========================================================</h1>

<p>exit 0</p>

<h1 id="练习-1">练习:</h1>

<h1 id="toc_169">&mdash;&ndash;</h1>

<h1 id="1-找到一种更优雅的方法">1) 找到一种更优雅的方法,</h1>

<p>#+ 来测试传递给函数的参数.</p>

<h1 id="2-简化-输出-段的if-then结构">2) 简化&rdquo;输出&rdquo;段的if/then结构.</h1>

<h1 id="3-重写这个脚本-使其能够从命令行参数中获得输入">3) 重写这个脚本, 使其能够从命令行参数中获得输入.</h1>

<p>%%%&amp;&amp;&amp;max2.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@max.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="max-sh-取两个整数中的最大值">max.sh: 取两个整数中的最大值.</h1>

<p>E_PARAM_ERR=-198 # 如果传给函数的参数少于2个时, 就返回这个值.<br />
EQUAL=-199 # 如果两个整数相等时, 返回这个值.</p>

<h1 id="任意超出范围的">任意超出范围的</h1>

<p>#+ 参数值都可能传递到函数中.</p>

<p>max2 () # 返回两个整数中的最大值.<br />
{ # 注意: 参与比较的数必须小于257.<br />
if [ -z &ldquo;$2&rdquo; ]<br />
then<br />
return $E_PARAM_ERR<br />
fi</p>

<p>if [ &ldquo;$1&rdquo; -eq &ldquo;$2&rdquo; ]<br />
then<br />
return $EQUAL<br />
else<br />
if [ &ldquo;$1&rdquo; -gt &ldquo;$2&rdquo; ]<br />
then<br />
return $1<br />
else<br />
return $2<br />
fi<br />
fi<br />
}</p>

<p>max2 33 34<br />
return_val=$?</p>

<p>if [ &ldquo;$return_val&rdquo; -eq $E_PARAM_ERR ]<br />
then<br />
echo &ldquo;Need to pass two parameters to the function.&rdquo;<br />
elif [ &ldquo;$return_val&rdquo; -eq $EQUAL ]<br />
then<br />
echo &ldquo;The two numbers are equal.&rdquo;<br />
else<br />
echo &ldquo;The larger of the two numbers is $return_val.&rdquo;<br />
fi</p>

<p>exit 0</p>

<h1 id="练习-简单">练习(简单):</h1>

<h1 id="toc_176">&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="把这个脚本转化为交互式脚本">把这个脚本转化为交互式脚本,</h1>

<p>#+ 也就是, 修改这个脚本, 让其要求调用者输入2个数.<br />
%%%&amp;&amp;&amp;max.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@missing-
keyword.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="missing-keyword-sh-这个脚本会产生什么错误">missing-keyword.sh: 这个脚本会产生什么错误?</h1>

<p>for a in 1 2 3<br />
do<br />
echo &ldquo;$a&rdquo;</p>

<h1 id="done-第7行上的关键字done-被注释掉了">done # 第7行上的关键字done&rsquo;被注释掉了.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;missing-
keyword.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@monthlypmt.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="monthlypmt-sh-计算按月偿还贷款的数量">monthlypmt.sh: 计算按月偿还贷款的数量.</h1>

<h1 id="这份代码是一份修改版本-原始版本在-mcalc-贷款计算-包中">这份代码是一份修改版本, 原始版本在&rdquo;mcalc&rdquo;(贷款计算)包中,</h1>

<p>#+ 这个包的作者是Jeff Schmidt和Mendel Cooper(本书作者).</p>

<h1 id="http-www-ibiblio-org-pub-linux-apps-financial-mcalc-1-6-tar-gz-15k"><a href="http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz">http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz</a> [15k]</h1>

<p>echo<br />
echo &ldquo;Given the principal, interest rate, and term of a mortgage,&rdquo;<br />
echo &ldquo;calculate the monthly payment.&rdquo;</p>

<p>bottom=1.0</p>

<p>echo<br />
echo -n &ldquo;Enter principal (no commas) &rdquo;<br />
read principal<br />
echo -n &ldquo;Enter interest rate (percent) &rdquo; # 如果是12%, 那就键入&rdquo;12&rdquo;, 而不是&rdquo;.12&rdquo;.<br />
read interest_r<br />
echo -n &ldquo;Enter term (months) &rdquo;<br />
read term</p>

<p>interest_r=$(echo &ldquo;scale=9; $interest_r/100.0&rdquo; | bc) # 转换成小数.</p>

<h1 id="scale-指定了有效数字的个数">&ldquo;scale&rdquo;指定了有效数字的个数.</h1>

<p>interest_rate=$(echo &ldquo;scale=9; $interest_r/12 + 1.0&rdquo; | bc)</p>

<p>top=$(echo &ldquo;scale=9; $principal*$interest_rate^$term&rdquo; | bc)</p>

<p>echo; echo &ldquo;Please be patient. This may take a while.&rdquo;</p>

<p>let &ldquo;months = $term - 1&rdquo;</p>

<h1 id="toc_184">====================================================================</h1>

<p>for ((x=$months; x &gt; 0; x&ndash;))<br />
do<br />
bot=$(echo &ldquo;scale=9; $interest_rate^$x&rdquo; | bc)<br />
bottom=$(echo &ldquo;scale=9; $bottom+$bot&rdquo; | bc)</p>

<h1 id="bottom-bottom-bot">bottom = $(($bottom + $bot&rdquo;))</h1>

<p>done</p>

<h1 id="toc_186">====================================================================</h1>

<h1 id="toc_187">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="rick-boivie给出了一个对上边循环的修改方案">Rick Boivie给出了一个对上边循环的修改方案,</h1>

<p>#+ 这个修改更加有效率, 将会节省大概2/3的时间.</p>

<h1 id="for-x-1-x-months-x">for ((x=1; x &lt;= $months; x++))</h1>

<h1 id="do">do</h1>

<h1 id="bottom-echo-scale-9-bottom-interest-rate-1-bc">bottom=$(echo &ldquo;scale=9; $bottom * $interest_rate + 1&rdquo; | bc)</h1>

<h1 id="done">done</h1>

<h1 id="然后他又想出了一个更加有效率的版本">然后他又想出了一个更加有效率的版本,</h1>

<p>#+ 将会节省95%的时间!</p>

<h1 id="bottom">bottom=`{</h1>

<h1 id="echo-scale-9-bottom-bottom-interest-rate-interest-rate">echo &ldquo;scale=9; bottom=$bottom; interest_rate=$interest_rate&rdquo;</h1>

<h1 id="for-x-1-x-months-x-1">for ((x=1; x &lt;= $months; x++))</h1>

<h1 id="do-1">do</h1>

<h1 id="echo-bottom-bottom-interest-rate-1">echo &lsquo;bottom = bottom * interest_rate + 1&rsquo;</h1>

<h1 id="done-1">done</h1>

<h1 id="echo-bottom">echo &lsquo;bottom&rsquo;</h1>

<h1 id="bc-在命令替换中嵌入一个-for循环">} | bc` # 在命令替换中嵌入一个&rsquo;for循环&rsquo;.</h1>

<h1 id="toc_202">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="另一方面-frank-wang建议">另一方面, Frank Wang建议:</h1>

<h1 id="bottom-echo-scale-9-interest-rate-term-1-interest-rate-1-bc">bottom=$(echo &ldquo;scale=9; ($interest_rate^$term-1)/($interest_rate-1)&rdquo; | bc)</h1>

<h1 id="因为">因为 &hellip;</h1>

<h1 id="在循环后边的算法">在循环后边的算法</h1>

<p>#+ 事实上是一个等比数列的求和公式.</p>

<h1 id="求和公式是-e0-1-q-n-1-q">求和公式是 e0(1-q^n)/(1-q),</h1>

<p>#+ e0是第一个元素, q=e(n+1)/e(n),<br />
#+ n是元素数量.</p>

<h1 id="toc_208">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="let-payment-top-bottom">let &ldquo;payment = $top/$bottom&rdquo;</h1>

<p>payment=$(echo &ldquo;scale=2; $top/$bottom&rdquo; | bc)</p>

<h1 id="使用2位有效数字来表示美元和美分">使用2位有效数字来表示美元和美分.</h1>

<p>echo<br />
echo &ldquo;monthly payment = /$$payment&rdquo; # 在总和的前边显示美元符号.<br />
echo</p>

<p>exit 0</p>

<h1 id="练习-2">练习:</h1>

<h1 id="1-处理输入允许本金总数中的逗号">1) 处理输入允许本金总数中的逗号.</h1>

<h1 id="2-处理输入允许按照百分号和小数点的形式输入利率">2) 处理输入允许按照百分号和小数点的形式输入利率.</h1>

<h1 id="3-如果你真正想好好编写这个脚本">3) 如果你真正想好好编写这个脚本,</h1>

<h1 id="那么就扩展这个脚本让它能够打印出完整的分期付款表">那么就扩展这个脚本让它能够打印出完整的分期付款表.</h1>

<p>%%%&amp;&amp;&amp;monthlypmt.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@multiple-
processes.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="parent-sh">parent.sh</h1>

<h1 id="在多处理器-smp-box-的机器里运行多进程">在多处理器(SMP box)的机器里运行多进程.</h1>

<h1 id="作者-tedman-eng">作者: Tedman Eng</h1>

<h1 id="我们下面要介绍两个脚本-这是第一个">我们下面要介绍两个脚本, 这是第一个,</h1>

<p>#+ 这两个脚本都要放到当前工作目录下.</p>

<p>LIMIT=$1 # 想要启动的进程总数<br />
NUMPROC=4 # 并发的线程数量(forks?)<br />
PROCID=1 # 启动的进程ID<br />
echo &ldquo;My PID is $$&rdquo;</p>

<p>function start_thread() {<br />
if [ $PROCID -le $LIMIT ] ; then<br />
./child.sh $PROCID&amp;<br />
let &ldquo;PROCID++&rdquo;<br />
else<br />
echo &ldquo;Limit reached.&rdquo;<br />
wait<br />
exit<br />
fi<br />
}</p>

<p>while [ &ldquo;$NUMPROC&rdquo; -gt 0 ]; do<br />
start_thread;<br />
let &ldquo;NUMPROC&ndash;&rdquo;<br />
done</p>

<p>while true<br />
do</p>

<p>trap &ldquo;start_thread&rdquo; SIGRTMIN</p>

<p>done</p>

<p>exit 0</p>

<h1 id="下面是第二个脚本">======== 下面是第二个脚本 ========</h1>

<p>#!/bin/bash</p>

<h1 id="child-sh">child.sh</h1>

<h1 id="在smp-box上运行多进程">在SMP box上运行多进程.</h1>

<h1 id="这个脚本会被parent-sh调用">这个脚本会被parent.sh调用.</h1>

<h1 id="作者-tedman-eng-1">作者: Tedman Eng</h1>

<p>temp=$RANDOM<br />
index=$1<br />
shift<br />
let &ldquo;temp %= 5&rdquo;<br />
let &ldquo;temp += 4&rdquo;<br />
echo &ldquo;Starting $index Time:$temp&rdquo; &ldquo;$@&rdquo;<br />
sleep ${temp}<br />
echo &ldquo;Ending $index&rdquo;<br />
kill -s SIGRTMIN $PPID</p>

<p>exit 0</p>

<h1 id="脚本作者注">======================= 脚本作者注 ======================= #</h1>

<h1 id="这个脚本并不是一点bug都没有">这个脚本并不是一点bug都没有.</h1>

<h1 id="我使用limit-500来运行这个脚本-但是在过了开头的一两百个循环后">我使用limit = 500来运行这个脚本, 但是在过了开头的一两百个循环后,</h1>

<p>#+ 有些并发线程消失了!</p>

<h1 id="还不能确定这是否是由捕捉信号的冲突引起的-或者是其他什么原因">还不能确定这是否是由捕捉信号的冲突引起的, 或者是其他什么原因.</h1>

<h1 id="一旦接收到捕捉的信号-那么在下一次捕捉到来之前">一旦接收到捕捉的信号, 那么在下一次捕捉到来之前,</h1>

<p>#+ 会有一段短暂的时间来执行信号处理程序,<br />
#+ 在信号处理程序处理的过程中, 很有可能会丢失一个想要捕捉的信号, 因此失去一个产生子进程的机会.</p>

<h1 id="毫无疑问的-肯定有人能够找出产生这个bug的原因">毫无疑问的, 肯定有人能够找出产生这个bug的原因,</h1>

<p>#+ 并且在将来的某个时候&hellip; 修正它.</p>

<h1 id="toc_231">=====================================================================</h1>

<h1 id="toc_232">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</h1>

<p>#################################################################</p>

<h1 id="下面的脚本是由vernia-damiano原创">下面的脚本是由Vernia Damiano原创.</h1>

<h1 id="不幸的是-它并不能正常工作">不幸的是, 它并不能正常工作.</h1>

<p>#################################################################</p>

<p>#!/bin/bash</p>

<h1 id="要想调用这个脚本-至少需要一个整形参数">要想调用这个脚本, 至少需要一个整形参数</h1>

<p>#+ (并发的进程数).</p>

<h1 id="所有的其他参数都传递给要启动的进程">所有的其他参数都传递给要启动的进程.</h1>

<p>INDICE=8 # 想要启动的进程数目<br />
TEMPO=5 # 每个进程最大的睡眠时间<br />
E_BADARGS=65 # 如果没有参数传到脚本中, 那么就返回这个错误码.</p>

<p>if [ $# -eq 0 ] # 检查一下, 至少要传递一个参数给脚本.<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> number_of_processes [passed params]&rdquo;<br />
exit $E_BADARGS<br />
fi</p>

<p>NUMPROC=$1 # 并发进程数<br />
shift<br />
PARAMETRI=( &ldquo;$@&rdquo; ) # 每个进程的参数</p>

<p>function avvia() {<br />
local temp<br />
local index<br />
temp=$RANDOM<br />
index=$1<br />
shift<br />
let &ldquo;temp %= $TEMPO&rdquo;<br />
let &ldquo;temp += 1&rdquo;<br />
echo &ldquo;Starting $index Time:$temp&rdquo; &ldquo;$@&rdquo;<br />
sleep ${temp}<br />
echo &ldquo;Ending $index&rdquo;<br />
kill -s SIGRTMIN $$<br />
}</p>

<p>function parti() {<br />
if [ $INDICE -gt 0 ] ; then<br />
avvia $INDICE &ldquo;${PARAMETRI[@]}&rdquo; &amp;<br />
let &ldquo;INDICE&ndash;&rdquo;<br />
else<br />
trap : SIGRTMIN<br />
fi<br />
}</p>

<p>trap parti SIGRTMIN</p>

<p>while [ &ldquo;$NUMPROC&rdquo; -gt 0 ]; do<br />
parti;<br />
let &ldquo;NUMPROC&ndash;&rdquo;<br />
done</p>

<p>wait<br />
trap - SIGRTMIN</p>

<dl>
<dt>exit $?</dt>
<dd><p>&lt;&lt;SCRIPT_AUTHOR_COMMENTS<br />
我需要使用指定的选项来运行一个程序,<br />
并且能够接受不同的文件, 而且要运行在一个多处理器(SMP)的机器上.<br />
所以我想(我也会)运行指定数目个进程,<br />
并且每个进程终止之后, 都要启动一个新进程.</p></dd>
</dl>

<p>&ldquo;wait&rdquo;命令并没有提供什么帮助, 因为它需要等待一个指定的后台进程,<br />
或者等待*全部*的后台进程. 所以我编写了[这个]bash脚本程序来完成这个工作,<br />
并且使用了&rdquo;trap&rdquo;指令.<br />
--Vernia Damiano<br />
SCRIPT_AUTHOR_COMMENTS<br />
%%%&amp;&amp;&amp;multiple-
processes.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@multiplication.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="multiplication-sh">multiplication.sh</h1>

<p>multiply () # 将乘数作为参数传递进来.<br />
{ # 可以接受多个参数.</p>

<p>local product=1</p>

<p>until [ -z &ldquo;$1&rdquo; ] # 直到处理完所有的参数&hellip;<br />
do<br />
let &ldquo;product *= $1&rdquo;<br />
shift<br />
done</p>

<p>echo $product # 不会echo到stdout,<br />
} #+ 因为要把它赋值给一个变量.</p>

<p>mult1=15383; mult2=25211<br />
val1=<code>multiply $mult1 $mult2</code><br />
echo &ldquo;$mult1 X $mult2 = $val1&rdquo;</p>

<h1 id="387820813">387820813</h1>

<p>mult1=25; mult2=5; mult3=20<br />
val2=<code>multiply $mult1 $mult2 $mult3</code><br />
echo &ldquo;$mult1 X $mult2 X $mult3 = $val2&rdquo;</p>

<h1 id="2500">2500</h1>

<p>mult1=188; mult2=37; mult3=25; mult4=47<br />
val3=<code>multiply $mult1 $mult2 $mult3 $mult4</code><br />
echo &ldquo;$mult1 X $mult2 X $mult3 X $mult4 = $val3&rdquo;</p>

<h1 id="8173300">8173300</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;multiplication.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@nested-
loop.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="nested-loop-sh-嵌套的-for-循环">nested-loop.sh: 嵌套的&rdquo;for&rdquo;循环.</h1>

<p>outer=1 # 设置外部循环计数.</p>

<h1 id="开始外部循环">开始外部循环.</h1>

<p>for a in 1 2 3 4 5<br />
do<br />
echo &ldquo;Pass $outer in outer loop.&rdquo;<br />
echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
inner=1 # 重置内部循环计数.</p>

<h1 id="toc_243">===============================================</h1>

<h1 id="开始内部循环">开始内部循环.</h1>

<p>for b in 1 2 3 4 5<br />
do<br />
echo &ldquo;Pass $inner in inner loop.&rdquo;<br />
let &ldquo;inner+=1&rdquo; # 增加内部循环计数.<br />
done</p>

<h1 id="内部循环结束">内部循环结束.</h1>

<h1 id="toc_246">===============================================</h1>

<p>let &ldquo;outer+=1&rdquo; # 增加外部循环的计数.<br />
echo # 每次外部循环之间的间隔.<br />
done</p>

<h1 id="外部循环结束">外部循环结束.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;nested-
loop.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@numbers.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="numbers-sh-几种不同数制的数字表示法">numbers.sh: 几种不同数制的数字表示法.</h1>

<h1 id="10进制-默认情况">10进制: 默认情况</h1>

<p>let &ldquo;dec = 32&rdquo;<br />
echo &ldquo;decimal number = $dec&rdquo; # 32</p>

<h1 id="这没什么特别的">这没什么特别的.</h1>

<h1 id="8进制-以-0-零-开头">8进制: 以&rsquo;0&rsquo;(零)开头</h1>

<p>let &ldquo;oct = 032&rdquo;<br />
echo &ldquo;octal number = $oct&rdquo; # 26</p>

<h1 id="表达式结果是用10进制表示的">表达式结果是用10进制表示的.</h1>

<h1 id="toc_253">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<h1 id="16进制-以-0x-或者-0x-开头的数字">16进制: 以&rsquo;0x&rsquo;或者&rsquo;0X&rsquo;开头的数字</h1>

<p>let &ldquo;hex = 0x32&rdquo;<br />
echo &ldquo;hexadecimal number = $hex&rdquo; # 50</p>

<h1 id="表达式结果是用10进制表示的-1">表达式结果是用10进制表示的.</h1>

<h1 id="其他进制-base-number">其他进制: BASE#NUMBER</h1>

<h1 id="base的范围在2到64之间">BASE的范围在2到64之间.</h1>

<h1 id="number的值必须使用base范围内的符号来表示-具体看下边的示例">NUMBER的值必须使用BASE范围内的符号来表示, 具体看下边的示例.</h1>

<p>let &ldquo;bin = 2#111100111001101&rdquo;<br />
echo &ldquo;binary number = $bin&rdquo; # 31181</p>

<p>let &ldquo;b32 = 32#77&rdquo;<br />
echo &ldquo;base-32 number = $b32&rdquo; # 231</p>

<p>let &ldquo;b64 = 64#@_&rdquo;<br />
echo &ldquo;base-64 number = $b64&rdquo; # 4031</p>

<h1 id="这个表示法只能工作于受限的ascii字符范围-2-64">这个表示法只能工作于受限的ASCII字符范围(2 - 64).</h1>

<h1 id="10个数字-26个小写字母-26个大写字符">10个数字 + 26个小写字母 + 26个大写字符 + @ + _</h1>

<p>echo</p>

<p>echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))</p>

<h1 id="1295-170-44822-3375">1295 170 44822 3375</h1>

<h1 id="重要的注意事项">重要的注意事项:</h1>

<h1 id="toc_263">&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<h1 id="使用一个超出给定进制的数字的话">使用一个超出给定进制的数字的话,</h1>

<p>#+ 将会引起一个错误.</p>

<p>let &ldquo;bad_oct = 081&rdquo;</p>

<h1 id="部分的-错误消息输出">(部分的) 错误消息输出:</h1>

<h1 id="bad-oct-081-value-too-great-for-base-error-token-is-081">bad_oct = 081: value too great for base (error token is &ldquo;081&rdquo;)</h1>

<h1 id="octal-numbers-use-only-digits-in-the-range-0-7">Octal numbers use only digits in the range 0 - 7.</h1>

<p>exit 0 # 感谢, Rich Bartell 和 Stephane Chazelas的指正.<br />
%%%&amp;&amp;&amp;numbers.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@obj-
oriented.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="obj-oriented-sh-object-oriented-programming-in-a-shell-script">obj-oriented.sh: Object-oriented programming in a shell script.</h1>

<h1 id="script-by-stephane-chazelas">Script by Stephane Chazelas.</h1>

<h1 id="important-note">Important Note:</h1>

<h1 id="toc_271">&mdash;&mdash;&mdash; &mdash;-</h1>

<h1 id="if-running-this-script-under-version-3-or-later-of-bash">If running this script under version 3 or later of Bash,</h1>

<p>#+ replace all periods in function names with a &ldquo;legal&rdquo; character,<br />
#+ for example, an underscore.</p>

<p>person.new() # Looks almost like a class declaration in C++.<br />
{<br />
local obj_name=$1 name=$2 firstname=$3 birthdate=$4</p>

<p>eval &ldquo;$obj_name.set_name() {<br />
eval /&ldquo;$obj_name.get_name() {<br />
echo /$1<br />
}/&rdquo;<br />
}&rdquo;</p>

<p>eval &ldquo;$obj_name.set_firstname() {<br />
eval /&ldquo;$obj_name.get_firstname() {<br />
echo /$1<br />
}/&rdquo;<br />
}&rdquo;</p>

<p>eval &ldquo;$obj_name.set_birthdate() {<br />
eval /&ldquo;$obj_name.get_birthdate() {<br />
echo /$1<br />
}/&rdquo;<br />
eval /&ldquo;$obj_name.show_birthdate() {<br />
echo /$(date -d /&ldquo;1/1/1970 0:0:/$1 GMT/&ldquo;)<br />
}/&rdquo;<br />
eval /&ldquo;$obj_name.get_age() {<br />
echo /$(( (/$(date +%s) - /$1) / 3600 / 24 / 365 ))<br />
}/&rdquo;<br />
}&rdquo;</p>

<p>$obj_name.set_name $name<br />
$obj_name.set_firstname $firstname<br />
$obj_name.set_birthdate $birthdate<br />
}</p>

<p>echo</p>

<p>person.new self Bozeman Bozo 101272413</p>

<h1 id="create-an-instance-of-person-new-actually-passing-args-to-the-function">Create an instance of &ldquo;person.new&rdquo; (actually passing args to the function).</h1>

<p>self.get_firstname # Bozo<br />
self.get_name # Bozeman<br />
self.get_age # 28<br />
self.get_birthdate # 101272413<br />
self.show_birthdate # Sat Mar 17 20:13:33 MST 1973</p>

<p>echo</p>

<h1 id="typeset-f">typeset -f</h1>

<p>#+ to see the created functions (careful, it scrolls off the page).</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;obj-
oriented.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@online.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="logon-sh-一个检查你是否在线的脚本-这个脚本实现的很简陋">logon.sh: 一个检查你是否在线的脚本, 这个脚本实现的很简陋.</h1>

<p>umask 177 # 确保temp文件并不是所有用户都有权限访问.</p>

<p>TRUE=1<br />
LOGFILE=/var/log/messages</p>

<h1 id="注意-logfile必须是可读的">注意: $LOGFILE必须是可读的</h1>

<p>#+ (使用root身份来执行, chmod 644 /var/log/messages).<br />
TEMPFILE=temp.$$</p>

<h1 id="使用脚本的进程id-来创建一个-唯一-的临时文件名">使用脚本的进程ID, 来创建一个&rdquo;唯一&rdquo;的临时文件名.</h1>

<h1 id="也可以使用-mktemp">也可以使用&rsquo;mktemp&rsquo;.</h1>

<h1 id="比如">比如:</h1>

<h1 id="tempfile-mktemp-temp-xxxxxx">TEMPFILE=<code>mktemp temp.XXXXXX</code></h1>

<p>KEYWORD=address</p>

<h1 id="登陆时-把-remote-ip-address-xxx-xxx-xxx-xxx">登陆时, 把&rdquo;remote IP address xxx.xxx.xxx.xxx&rdquo;</h1>

<h1 id="添加到-var-log-messages中">添加到/var/log/messages中.</h1>

<p>ONLINE=22<br />
USER_INTERRUPT=13<br />
CHECK_LINES=100</p>

<h1 id="日志文件有多少行需要检查">日志文件有多少行需要检查.</h1>

<p>trap &lsquo;rm -f $TEMPFILE; exit $USER_INTERRUPT&rsquo; TERM INT</p>

<h1 id="如果脚本被control-c中途中断的话-那么就清除掉临时文件">如果脚本被control-c中途中断的话, 那么就清除掉临时文件.</h1>

<p>echo</p>

<p>while [ $TRUE ] #死循环.<br />
do<br />
tail -$CHECK_LINES $LOGFILE&gt; $TEMPFILE</p>

<h1 id="将系统日志文件的最后100行保存到临时文件中">将系统日志文件的最后100行保存到临时文件中.</h1>

<h1 id="这么做很有必要-因为新版本的内核在登陆的时候-会产生许多登陆信息">这么做很有必要, 因为新版本的内核在登陆的时候, 会产生许多登陆信息.</h1>

<p>search=<code>grep $KEYWORD $TEMPFILE</code></p>

<h1 id="检查是否存在-ip-address-片断">检查是否存在&rdquo;IP address&rdquo;片断,</h1>

<p>#+ 它用来提示, 这是一次成功的网络登陆.</p>

<p>if [ ! -z &ldquo;$search&rdquo; ] # 必须使用引号, 因为变量可能会包含一些空白符.<br />
then<br />
echo &ldquo;On-line&rdquo;<br />
rm -f $TEMPFILE # 清除临时文件.<br />
exit $ONLINE<br />
else<br />
echo -n &ldquo;.&rdquo; # echo的-n选项不会产生换行符.<br />
#+ 这样你就可以在一行上连续打印.<br />
fi</p>

<p>sleep 1<br />
done</p>

<h1 id="注意-如果你将变量keyword的值改为-exit">注意: 如果你将变量KEYWORD的值改为&rdquo;Exit&rdquo;,</h1>

<p>#+ 当在线时, 这个脚本就可以被用来检查<br />
#+ 意外的掉线情况.</p>

<h1 id="练习-按照上面-注意-中所说的那样来修改这个脚本">练习: 按照上面&rdquo;注意&rdquo;中所说的那样来修改这个脚本,</h1>

<h1 id="让它表现的更好">让它表现的更好.</h1>

<p>exit 0</p>

<h1 id="nick-drage建议使用另一种方法">Nick Drage建议使用另一种方法:</h1>

<p>while true<br />
do ifconfig ppp0 | grep UP 1&gt; /dev/null &amp;&amp; echo &ldquo;connected&rdquo; &amp;&amp; exit 0<br />
echo -n &ldquo;.&rdquo; # 不停的打印(&hellip;..), 用来提示用户等待, 直到连接上位置.<br />
sleep 2<br />
done</p>

<h1 id="问题-使用control-c来终止这个进程可能是不够的">问题: 使用Control-C来终止这个进程可能是不够的.</h1>

<p>#+ (可能还会继续打印&rdquo;&hellip;&ldquo;)</p>

<h1 id="练习-修复这个问题">练习: 修复这个问题.</h1>

<h1 id="stephane-chazelas提出了另一种方法">Stephane Chazelas提出了另一种方法:</h1>

<p>CHECK_INTERVAL=1</p>

<p>while ! tail -1 &ldquo;$LOGFILE&rdquo; | grep -q &ldquo;$KEYWORD&rdquo;<br />
do echo -n .<br />
sleep $CHECK_INTERVAL<br />
done<br />
echo &ldquo;On-line&rdquo;</p>

<h1 id="练习-讨论一下这几种不同方法">练习: 讨论一下这几种不同方法</h1>

<h1 id="各自的优缺点">各自的优缺点.</h1>

<p>%%%&amp;&amp;&amp;online.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@paragraph-
space.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="paragraph-space-sh">paragraph-space.sh</h1>

<h1 id="在一个单倍行距的文本文件中插入空行">在一个单倍行距的文本文件中插入空行.</h1>

<h1 id="usage-0-filename">Usage: $0 &lt;FILENAME</h1>

<p>MINLEN=45 # 可能需要修改这个值.</p>

<h1 id="假定行的长度小于-minlen所指定的长度的时候">假定行的长度小于$MINLEN所指定的长度的时候</h1>

<p>#+ 才认为此段结束.</p>

<p>while read line # 提供和输入文件一样多的行&hellip;<br />
do<br />
echo &ldquo;$line&rdquo; # 输入所读入的行本身.</p>

<p>len=${#line}<br />
if [ &ldquo;$len&rdquo; -lt &ldquo;$MINLEN&rdquo; ]<br />
then echo # 在短行(译者注: 也就是小于$MINLEN个字符的行)后面添加一个空行.<br />
fi<br />
done</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;paragraph-
space.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@param-
sub.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="param-sub-sh">param-sub.sh</h1>

<h1 id="一个变量是否被声明或设置">一个变量是否被声明或设置,</h1>

<p>#+ 将会影响这个变量是否使用默认值,<br />
#+ 即使这个变量值为空(null).</p>

<p>username0=<br />
echo &ldquo;username0 has been declared, but is set to null.&rdquo;<br />
echo &ldquo;username0 = ${username0-<code>whoami</code>}&rdquo;</p>

<h1 id="不会有输出">不会有输出.</h1>

<p>echo</p>

<p>echo username1 has not been declared.<br />
echo &ldquo;username1 = ${username1-<code>whoami</code>}&rdquo;</p>

<h1 id="将会输出默认值">将会输出默认值.</h1>

<p>username2=<br />
echo &ldquo;username2 has been declared, but is set to null.&rdquo;<br />
echo &ldquo;username2 = ${username2:-<code>whoami</code>}&rdquo;</p>

<h1 id="toc_305">^</h1>

<h1 id="会输出-因为-会比-多一个条件测试">会输出, 因为:-会比-多一个条件测试.</h1>

<h1 id="可以与上边的例子比较一下">可以与上边的例子比较一下.</h1>

<p>#</p>

<h1 id="再来一个">再来一个:</h1>

<p>variable=</p>

<h1 id="变量已经被声明-但是设为空值">变量已经被声明, 但是设为空值.</h1>

<p>echo &ldquo;${variable-0}&rdquo; # (没有输出)<br />
echo &ldquo;${variable:-1}&rdquo; # 1</p>

<h1 id="toc_310">^</h1>

<p>unset variable</p>

<p>echo &ldquo;${variable-2}&rdquo; # 2<br />
echo &ldquo;${variable:-3}&rdquo; # 3</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;param-
sub.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@patt-
matching.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="patt-matching-sh">patt-matching.sh</h1>

<h1 id="使用-来进行参数替换操作的模式匹配-parameter-substitution-operators">使用# ## % %%来进行参数替换操作的模式匹配. parameter substitution operators.</h1>

<p>var1=abcd12345abc6789<br />
pattern1=a*c # *(通配符)匹配a - c之间的任意字符.</p>

<p>echo<br />
echo &ldquo;var1 = $var1&rdquo; # abcd12345abc6789<br />
echo &ldquo;var1 = ${var1}&rdquo; # abcd12345abc6789</p>

<h1 id="另一种形式">(另一种形式)</h1>

<p>echo &ldquo;Number of characters in ${var1} = ${#var1}&rdquo;<br />
echo</p>

<p>echo &ldquo;pattern1 = $pattern1&rdquo; # a*c (匹配&rsquo;a&rsquo;到&rsquo;c&rsquo;之间的任意字符)<br />
echo &ldquo;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
echo &lsquo;${var1#$pattern1} =&rsquo; &ldquo;${var1#$pattern1}&rdquo; # d12345abc6789</p>

<h1 id="最短的可能匹配-去掉abcd12345abc6789的前3个字符">最短的可能匹配, 去掉abcd12345abc6789的前3个字符.</h1>

<h1 id="toc_315">|-| ^^^^^</h1>

<p>echo &lsquo;${var1##$pattern1} =&rsquo; &ldquo;${var1##$pattern1}&rdquo; # 6789</p>

<h1 id="最长的可能匹配-去掉abcd12345abc6789的前12个字符">最长的可能匹配, 去掉abcd12345abc6789的前12个字符</h1>

<h1 id="toc_317">|&mdash;&mdash;&mdash;-| ^^^^^^</h1>

<p>echo; echo; echo</p>

<p>pattern2=b*9 # 匹配&rsquo;b&rsquo;到&rsquo;9&rsquo;之间的任意字符<br />
echo &ldquo;var1 = $var1&rdquo; # 还是abcd12345abc6789<br />
echo<br />
echo &ldquo;pattern2 = $pattern2&rdquo;<br />
echo &ldquo;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;<br />
echo &lsquo;${var1%pattern2} =&rsquo; &ldquo;${var1%$pattern2}&rdquo; # abcd12345a</p>

<h1 id="最短的可能匹配-去掉abcd12345abc6789的最后6个字符">最短的可能匹配, 去掉abcd12345abc6789的最后6个字符</h1>

<h1 id="toc_319">|&mdash;-| ^^^^^^^</h1>

<p>echo &lsquo;${var1%%pattern2} =&rsquo; &ldquo;${var1%%$pattern2}&rdquo; # a</p>

<h1 id="最长的可能匹配-去掉abcd12345abc6789的最后12个字符">最长的可能匹配, 去掉abcd12345abc6789的最后12个字符</h1>

<h1 id="toc_321">|&mdash;&mdash;&mdash;&mdash;-| ^^^^^^^^</h1>

<h1 id="牢记-和-是从字符串左边开始-并且去掉左边的字符串">牢记, #和##是从字符串左边开始, 并且去掉左边的字符串,</h1>

<h1 id="和-从字符串的右边开始-并且去掉右边的字符串">%和%%从字符串的右边开始, 并且去掉右边的字符串.</h1>

<h1 id="译者注-有个好记的方法-那就是察看键盘顺序-记住-在-的左边">(译者注: 有个好记的方法, 那就是察看键盘顺序, 记住#在%的左边. ^_^)</h1>

<p>echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;patt-
matching.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@pb.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="pb-sh-电话本">pb.sh: 电话本</h1>

<h1 id="由rick-boivie编写-已经得到作者授权-可以在本书中使用">由Rick Boivie编写, 已经得到作者授权, 可以在本书中使用.</h1>

<h1 id="本书作者做了一些修改">本书作者做了一些修改.</h1>

<p>MINARGS=1 # 脚本至少需要一个参数.<br />
DATAFILE=./phonebook</p>

<h1 id="当前目录下">当前目录下,</h1>

<p>#+ 必须有一个名字为&rdquo;phonebook&rdquo;的数据文件.<br />
PROGNAME=$0<br />
E_NOARGS=70 # 未传递参数错误.</p>

<p>if [ $# -lt $MINARGS ]; then<br />
echo &ldquo;Usage: &ldquo;$PROGNAME&rdquo; data&rdquo;<br />
exit $E_NOARGS<br />
fi</p>

<p>if [ $# -eq $MINARGS ]; then<br />
grep $1 &ldquo;$DATAFILE&rdquo;</p>

<h1 id="如果文件-datafile不存在-grep-就会打印一个错误信息">如果文件$DATAFILE不存在, &lsquo;grep&rsquo;就会打印一个错误信息.</h1>

<p>else<br />
( shift; &ldquo;$PROGNAME&rdquo; $* ) | grep $1</p>

<h1 id="脚本递归调用自身">脚本递归调用自身.</h1>

<p>fi</p>

<p>exit 0 # 脚本在此退出.</p>

<h1 id="因此-在这句之后">因此, 在这句之后,</h1>

<p>#+ 即使不加&rdquo;#&ldquo;号, 也可以添加注释和数据.</p>

<h1 id="toc_332">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<p>&ldquo;phonebook&rdquo;数据文件的例子:</p>

<p>John Doe 1555 Main St., Baltimore, MD 21228 (410) 222-3333<br />
Mary Moe 9899 Jones Blvd., Warren, NH 03787 (603) 898-3232<br />
Richard Roe 856 E. 7th St., New York, NY 10009 (212) 333-4567<br />
Sam Roe 956 E. 8th St., New York, NY 10009 (212) 444-5678<br />
Zoe Zenobia 4481 N. Baker St., San Francisco, SF 94338 (415) 501-1631</p>

<h1 id="toc_333">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<p>$bash pb.sh Roe<br />
Richard Roe 856 E. 7th St., New York, NY 10009 (212) 333-4567<br />
Sam Roe 956 E. 8th St., New York, NY 10009 (212) 444-5678</p>

<p>$bash pb.sh Roe Sam<br />
Sam Roe 956 E. 8th St., New York, NY 10009 (212) 444-5678</p>

<h1 id="如果给脚本传递的参数超过了一个">如果给脚本传递的参数超过了一个,</h1>

<p>#+ 那这个脚本就*只*会打印包含所有参数的行.<br />
%%%&amp;&amp;&amp;pb.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@pick-
card.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="pick-card-sh">pick-card.sh</h1>

<h1 id="这是一个从数组中取出随机元素的一个例子">这是一个从数组中取出随机元素的一个例子.</h1>

<h1 id="抽取一张牌-任何一张">抽取一张牌, 任何一张.</h1>

<p>Suites=&ldquo;Clubs<br />
Diamonds<br />
Hearts<br />
Spades&rdquo;</p>

<p>Denominations=&ldquo;2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
Jack<br />
Queen<br />
King<br />
Ace&rdquo;</p>

<h1 id="注意变量的多行展开">注意变量的多行展开.</h1>

<p>suite=($Suites) # 读入一个数组.<br />
denomination=($Denominations)</p>

<p>num_suites=${#suite[<em>]} # 计算有多少个数组元素.<br />
num_denominations=${#denomination[</em>]}</p>

<p>echo -n &ldquo;${denomination[$((RANDOM%num_denominations))]} of &ldquo;<br />
echo ${suite[$((RANDOM%num_suites))]}</p>

<h1 id="bozo-sh-pick-cards-sh">$bozo sh pick-cards.sh</h1>

<h1 id="jack-of-clubs">Jack of Clubs</h1>

<h1 id="感谢-jipe-指出-random的这个用法">感谢, &ldquo;jipe,&rdquo; 指出$RANDOM的这个用法.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;pick-
card.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@pid-
identifier.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="pid-identifier-sh-给出与指定pid相关联进程的完整路径名">pid-identifier.sh: 给出与指定pid相关联进程的完整路径名.</h1>

<p>ARGNO=1 # 期望的参数个数.<br />
E_WRONGARGS=65<br />
E_BADPID=66<br />
E_NOSUCHPROCESS=67<br />
E_NOPERMISSION=68<br />
PROCFILE=exe</p>

<p>if [ $# -ne $ARGNO ]<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> PID-number&rdquo; &gt;&amp;2 # Error message
&gt;stderr(错误信息重定向到标准错误).<br />
exit $E_WRONGARGS<br />
fi</p>

<p>pidno=$( ps ax | grep $1 | awk &lsquo;{ print $1 }&rsquo; | grep $1 )</p>

<h1 id="从-ps-命令的输出中搜索带有pid的行-pid位置在第一列-1-由awk过滤出来">从&rdquo;ps&rdquo;命令的输出中搜索带有pid的行, pid位置在第一列#1, 由awk过滤出来.</h1>

<h1 id="然后再次确认这就是我们所要找的进程-而不是由这个脚本调用所产生的进程">然后再次确认这就是我们所要找的进程, 而不是由这个脚本调用所产生的进程.</h1>

<h1 id="最后的-grep-1-就是用来过滤掉这种可能性">最后的&rdquo;grep $1&rdquo;就是用来过滤掉这种可能性.</h1>

<h1 id="pidno-ps-ax-awk-print-1-grep-1">pidno=$( ps ax | awk &lsquo;{ print $1 }&rsquo; | grep $1 )</h1>

<h1 id="这么写就可以了-这一点由teemu-huovila指出">这么写就可以了, 这一点由Teemu Huovila指出.</h1>

<p>if [ -z &ldquo;$pidno&rdquo; ] # 如果经过所有的过滤之后, 得到的结果是一个长度为0的字符串,<br />
then # 那就说明这个pid没有相应的进程在运行.<br />
echo &ldquo;No such process running.&rdquo;<br />
exit $E_NOSUCHPROCESS<br />
fi</p>

<h1 id="也可以这么写">也可以这么写:</h1>

<h1 id="if-ps-1-dev-null-2-1">if ! ps $1 &gt; /dev/null 2&gt;&amp;1</h1>

<h1 id="then-没有与给定pid相匹配的进程在运行">then # 没有与给定pid相匹配的进程在运行.</h1>

<h1 id="echo-no-such-process-running">echo &ldquo;No such process running.&rdquo;</h1>

<h1 id="exit-e-nosuchprocess">exit $E_NOSUCHPROCESS</h1>

<h1 id="fi">fi</h1>

<h1 id="为了简化整个过程-可以使用-pidof">为了简化整个过程, 可以使用&rdquo;pidof&rdquo;.</h1>

<p>if [ ! -r &ldquo;/proc/$1/$PROCFILE&rdquo; ] # 检查读权限.<br />
then<br />
echo &ldquo;Process $1 running, but&hellip;&rdquo;<br />
echo &ldquo;Can&rsquo;t get read permission on /proc/$1/$PROCFILE.&rdquo;<br />
exit $E_NOPERMISSION # 一般用户不能访问/proc目录下的某些文件.<br />
fi</p>

<h1 id="最后两个测试可以使用下面的语句来代替">最后两个测试可以使用下面的语句来代替:</h1>

<h1 id="if-kill-0-1-dev-null-2-1-0-不是一个信号-but">if ! kill -0 $1 &gt; /dev/null 2&gt;&amp;1 # &lsquo;0&rsquo;不是一个信号, but</h1>

<h1 id="但是这么做-可以测试一下是否">但是这么做, 可以测试一下是否</h1>

<h1 id="可以向该进程发送信号">可以向该进程发送信号.</h1>

<h1 id="then-echo-pid-doesn-t-exist-or-you-re-not-its-owner-2">then echo &ldquo;PID doesn&rsquo;t exist or you&rsquo;re not its owner&rdquo; &gt;&amp;2</h1>

<h1 id="exit-e-badpid">exit $E_BADPID</h1>

<h1 id="fi-1">fi</h1>

<p>exe_file=$( ls -l /proc/$1 | grep &ldquo;exe&rdquo; | awk &lsquo;{ print $11 }&rsquo; )</p>

<h1 id="或-exe-file-ls-l-proc-1-exe-awk-print-11">或 exe_file=$( ls -l /proc/$1/exe | awk &lsquo;{print $11}&rsquo; )</h1>

<h1 id="proc-pid-number-exe是一个符号链接">/proc/pid-number/exe是一个符号链接,</h1>

<h1 id="指向这个调用进程的完整路径名">指向这个调用进程的完整路径名.</h1>

<p>if [ -e &ldquo;$exe_file&rdquo; ] # 如果/proc/pid-number/exe存在&hellip;<br />
then # 那么相应的进程就存在.<br />
echo &ldquo;Process #$1 invoked by $exe_file.&rdquo;<br />
else<br />
echo &ldquo;No such process running.&rdquo;<br />
fi</p>

<h1 id="这个精心制作的脚本-几乎-能够被下边这一行所替代">这个精心制作的脚本, *几乎*能够被下边这一行所替代:</h1>

<h1 id="ps-ax-grep-1-awk-print-5">ps ax | grep $1 | awk &lsquo;{ print $5 }&rsquo;</h1>

<h1 id="但是-这样并不会工作">但是, 这样并不会工作&hellip;</h1>

<h1 id="因为-ps-输出的第5列是进程的argv-0-译者注-这是命令行第一个参数-即调用时程序用的程序路径本身">因为&rsquo;ps&rsquo;输出的第5列是进程的argv<a href="译者注: 这是命令行第一个参数, 即调用时程序用的程序路径本身.">0</a></h1>

<h1 id="而不是可执行文件的路径">而不是可执行文件的路径.</h1>

<h1 id="然而-下边这两种方法都能正确地完成这个任务">然而, 下边这两种方法都能正确地完成这个任务.</h1>

<h1 id="find-proc-1-exe-printf-l-n">find /proc/$1/exe -printf &lsquo;%l/n&rsquo;</h1>

<h1 id="lsof-afn-p-1-d-txt-sed-ne-s-n-p">lsof -aFn -p $1 -d txt | sed -ne &rsquo;s/^n//p&rsquo;</h1>

<h1 id="附加注释-是stephane-chazelas添加的">附加注释, 是Stephane Chazelas添加的.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;pid-
identifier.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@poem.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="poem-sh-将本书作者非常喜欢的一首诗-漂亮的打印出来">poem.sh: 将本书作者非常喜欢的一首诗, 漂亮的打印出来.</h1>

<h1 id="诗的行数-单节">诗的行数(单节).</h1>

<p>Line[1]=&ldquo;I do not know which to prefer,&rdquo;<br />
Line[2]=&ldquo;The beauty of inflections&rdquo;<br />
Line[3]=&ldquo;Or the beauty of innuendoes,&rdquo;<br />
Line[4]=&ldquo;The blackbird whistling&rdquo;<br />
Line[5]=&ldquo;Or just after.&rdquo;</p>

<h1 id="出处">出处.</h1>

<p>Attrib[1]=&rdquo; Wallace Stevens&rdquo;<br />
Attrib[2]=&ldquo;/&ldquo;Thirteen Ways of Looking at a Blackbird/&rdquo;&rdquo;</p>

<h1 id="这首诗已经是公共版权了-版权已经过期了">这首诗已经是公共版权了(版权已经过期了).</h1>

<p>echo</p>

<p>for index in 1 2 3 4 5 # 5行.<br />
do<br />
printf &ldquo; %s/n&rdquo; &ldquo;${Line[index]}&rdquo;<br />
done</p>

<p>for index in 1 2 # 出处为2行.<br />
do<br />
printf &ldquo; %s/n&rdquo; &ldquo;${Attrib[index]}&rdquo;<br />
done</p>

<p>echo</p>

<p>exit 0</p>

<h1 id="练习-3">练习:</h1>

<h1 id="toc_379">&mdash;&ndash;</h1>

<h1 id="修改这个脚本-使其能够从一个文本数据文件中提取出一首诗的内容-然后将其漂亮的打印出来">修改这个脚本, 使其能够从一个文本数据文件中提取出一首诗的内容, 然后将其漂亮的打印出来.</h1>

<p>%%%&amp;&amp;&amp;poem.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@pr-
asc.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="pr-ascii-sh-打印ascii码的字符表">pr-ascii.sh: 打印ASCII码的字符表.</h1>

<p>START=33 # 可打印的ASCII字符的范围(十进制).<br />
END=125</p>

<p>echo &ldquo; Decimal Hex Character&rdquo; # 表头.<br />
echo &ldquo; &mdash;&mdash;- &mdash; &mdash;&mdash;&mdash;&rdquo;</p>

<p>for ((i=START; i&lt;=END; i++))<br />
do<br />
echo $i | awk &lsquo;{printf(&rdquo; %3d %2x %c/n&rdquo;, $1, $1, $1)}&rsquo;</p>

<h1 id="在这种上下文中-不会运行bash内建的printf命令">在这种上下文中, 不会运行Bash内建的printf命令:</h1>

<h1 id="printf-c-i">printf &ldquo;%c&rdquo; &ldquo;$i&rdquo;</h1>

<p>done</p>

<p>exit 0</p>

<h1 id="十进制-16进制-字符">十进制 16进制 字符</h1>

<h1 id="toc_385">&mdash;&mdash;- &mdash;&mdash; &mdash;&mdash;&mdash;</h1>

<h1 id="33-21">33 21 !</h1>

<h1 id="34-22">34 22 &ldquo;</h1>

<h1 id="35-23">35 23 #</h1>

<h1 id="36-24">36 24 $</h1>

<h1 id="toc_390">&hellip;</h1>

<h1 id="122-7a-z">122 7a z</h1>

<h1 id="123-7b">123 7b {</h1>

<h1 id="124-7c">124 7c |</h1>

<h1 id="125-7d">125 7d }</h1>

<h1 id="将脚本的输出重定向到一个文件中">将脚本的输出重定向到一个文件中,</h1>

<p>#+ 或者通过管道传递给&rdquo;more&rdquo;: sh pr-asc.sh | more<br />
%%%&amp;&amp;&amp;pr-
asc.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@prepend.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="prepend-sh-在文件的开头添加文本">prepend.sh: 在文件的开头添加文本.</h1>

<h1 id="kenny-stauffer所捐助的脚本例子">Kenny Stauffer所捐助的脚本例子,</h1>

<p>#+ 本文作者对这个脚本进行了少量修改.</p>

<p>E_NOSUCHFILE=65</p>

<p>read -p &ldquo;File: &ldquo; file # &lsquo;read&rsquo;命令的-p参数用来显示提示符.<br />
if [ ! -e &ldquo;$file&rdquo; ]<br />
then # 如果这个文件不存在, 那就进来.<br />
echo &ldquo;File $file not found.&rdquo;<br />
exit $E_NOSUCHFILE<br />
fi</p>

<p>read -p &ldquo;Title: &ldquo; title<br />
cat - $file &lt;&lt;&lt;$title &gt; $file.new</p>

<p>echo &ldquo;Modified file is $file.new&rdquo;</p>

<p>exit 0</p>

<h1 id="下边是-man-bash-中的一段">下边是&rsquo;man bash&rsquo;中的一段:</h1>

<h1 id="here-string-1">Here String</h1>

<h1 id="here-document的一种变形-形式如下">here document的一种变形，形式如下:</h1>

<h1 id="word">&lt;&lt;&lt;word</h1>

<h1 id="word被扩展并且被提供到command的标准输入中">word被扩展并且被提供到command的标准输入中.</h1>

<p>%%%&amp;&amp;&amp;prepend.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@primes.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="primes-sh-generate-prime-numbers-without-using-arrays">primes.sh: Generate prime numbers, without using arrays.</h1>

<h1 id="script-contributed-by-stephane-chazelas">Script contributed by Stephane Chazelas.</h1>

<h1 id="this-does-not-use-the-classic-sieve-of-eratosthenes-algorithm">This does <em>not</em> use the classic &ldquo;Sieve of Eratosthenes&rdquo; algorithm,</h1>

<p>#+ but instead uses the more intuitive method of testing each candidate number<br />
#+ for factors (divisors), using the &ldquo;%&rdquo; modulo operator.</p>

<p>LIMIT=1000 # Primes 2 - 1000</p>

<p>Primes()<br />
{<br />
(( n = $1 + 1 )) # Bump to next integer.<br />
shift # Next parameter in list.</p>

<h1 id="echo-n-n-i-i">echo &ldquo;<em>n=$n i=$i</em>&ldquo;</h1>

<p>if (( n == LIMIT ))<br />
then echo $*<br />
return<br />
fi</p>

<p>for i; do # &ldquo;i&rdquo; gets set to &ldquo;@&rdquo;, previous values of $n.</p>

<h1 id="echo-n-n-i-i-1">echo &ldquo;-n=$n i=$i-&rdquo;</h1>

<p>(( i * i &gt; n )) &amp;&amp; break # Optimization.<br />
(( n % i )) &amp;&amp; continue # Sift out non-primes using modulo operator.<br />
Primes $n $@ # Recursion inside loop.<br />
return<br />
done</p>

<p>Primes $n $@ $n # Recursion outside loop.</p>

<h1 id="successively-accumulate-positional-parameters">Successively accumulate positional parameters.</h1>

<h1 id="is-the-accumulating-list-of-primes">&rdquo;$@&rdquo; is the accumulating list of primes.</h1>

<p>}</p>

<p>Primes 1</p>

<p>exit 0</p>

<h1 id="uncomment-lines-16-and-24-to-help-figure-out-what-is-going-on">Uncomment lines 16 and 24 to help figure out what is going on.</h1>

<h1 id="compare-the-speed-of-this-algorithm-for-generating-primes">Compare the speed of this algorithm for generating primes</h1>

<p>#+ with the Sieve of Eratosthenes (ex68.sh).</p>

<h1 id="exercise-rewrite-this-script-without-recursion-for-faster-execution">Exercise: Rewrite this script without recursion, for faster execution.</h1>

<p>%%%&amp;&amp;&amp;primes.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@protect_literal.sh@@@!!!</em></strong>*********************************************************************************<br />
#! /bin/bash</p>

<h1 id="protect-literal-sh">protect_literal.sh</h1>

<h1 id="set-vx">set -vx</h1>

<p>:&lt;</p>

<p>Copyright &copy; Michael S. Zick, 2003; All Rights Reserved<br />
License: Unrestricted reuse in any form, for any purpose.<br />
Warranty: None<br />
Revision: $ID$</p>

<p>Documentation redirected to the Bash no-operation.<br />
Bash will &lsquo;/dev/null&rsquo; this block when the script is first read.<br />
(Uncomment the above set command to see this action.)</p>

<p>Remove the first (Sha-Bang) line when sourcing this as a library<br />
procedure. Also comment out the example use code in the two<br />
places where shown.</p>

<p>Usage:<br />
_protect_literal_str &lsquo;Whatever string meets your ${fancy}&rsquo;<br />
Just echos the argument to standard out, hard quotes<br />
restored.</p>

<p>$(_protect_literal_str &lsquo;Whatever string meets your ${fancy}&rsquo;)<br />
as the right-hand-side of an assignment statement.</p>

<p>Does:<br />
As the right-hand-side of an assignment, preserves the<br />
hard quotes protecting the contents of the literal during<br />
assignment.</p>

<p>Notes:<br />
The strange names (_*) are used to avoid trampling on<br />
the user&rsquo;s chosen names when this is sourced as a<br />
library.</p>

<p>_Protect_Literal_String_Doc</p>

<h1 id="the-for-illustration-function-form">The &lsquo;for illustration&rsquo; function form</h1>

<p>_protect_literal_str() {</p>

<h1 id="pick-an-un-used-non-printing-character-as-local-ifs">Pick an un-used, non-printing character as local IFS.</h1>

<h1 id="not-required-but-shows-that-we-are-ignoring-it">Not required, but shows that we are ignoring it.</h1>

<p>local IFS=$&lsquo;/x1B&rsquo; # /ESC character</p>

<h1 id="enclose-the-all-elements-of-in-hard-quotes-during-assignment">Enclose the All-Elements-Of in hard quotes during assignment.</h1>

<p>local tmp=$&lsquo;/x27&rsquo;$@$&lsquo;/x27&rsquo;</p>

<h1 id="local-tmp-even-uglier">local tmp=$&lsquo;/&ldquo;$@$&rsquo;/&rdquo; # Even uglier.</h1>

<p>local len=${#tmp} # Info only.<br />
echo $tmp is $len long. # Output AND information.<br />
}</p>

<h1 id="this-is-the-short-named-version">This is the short-named version.</h1>

<p>_pls() {<br />
local IFS=$&lsquo;x1B&rsquo; # /ESC character (not required)<br />
echo $&lsquo;/x27&rsquo;$@$&lsquo;/x27&rsquo; # Hard quoted parameter glob<br />
}</p>

<h1 id="remove-the-above-to-disable-this-code">:&lt;# # # Remove the above &ldquo;# &rdquo; to disable this code. # #</h1>

<h1 id="see-how-that-looks-when-printed">See how that looks when printed.</h1>

<p>echo<br />
echo &ldquo;- - Test One - -&rdquo;<br />
_protect_literal_str &lsquo;Hello $user&rsquo;<br />
_protect_literal_str &lsquo;Hello &ldquo;${username}&rdquo;&rsquo;<br />
echo</p>

<h1 id="which-yields">Which yields:</h1>

<h1 id="test-one">- - Test One - -</h1>

<h1 id="hello-user-is-13-long">&lsquo;Hello $user&rsquo; is 13 long.</h1>

<h1 id="hello-username-is-21-long">&lsquo;Hello &ldquo;${username}&rdquo;&rsquo; is 21 long.</h1>

<h1 id="looks-as-expected-but-why-all-of-the-trouble">Looks as expected, but why all of the trouble?</h1>

<h1 id="the-difference-is-hidden-inside-the-bash-internal-order">The difference is hidden inside the Bash internal order</h1>

<p>#+ of operations.</p>

<h1 id="which-shows-when-you-use-it-on-the-rhs-of-an-assignment">Which shows when you use it on the RHS of an assignment.</h1>

<h1 id="declare-an-array-for-test-values">Declare an array for test values.</h1>

<p>declare -a arrayZ</p>

<h1 id="assign-elements-with-various-types-of-quotes-and-escapes">Assign elements with various types of quotes and escapes.</h1>

<p>arrayZ=( zero &ldquo;$(_pls &lsquo;Hello ${Me}&rsquo;)&rdquo; &lsquo;Hello ${You}&rsquo; &ldquo;/&lsquo;Pass: ${pw}/&lsquo;&rdquo; )</p>

<h1 id="now-list-that-array-and-see-what-is-there">Now list that array and see what is there.</h1>

<p>echo &ldquo;- - Test Two - -&rdquo;<br />
for (( i=0 ; ido<br />
echo Element $i: ${arrayZ[$i]} is: ${#arrayZ[$i]} long.<br />
done<br />
echo</p>

<h1 id="which-yields-1">Which yields:</h1>

<h1 id="test-two">- - Test Two - -</h1>

<h1 id="element-0-zero-is-4-long-our-marker-element">Element 0: zero is: 4 long. # Our marker element</h1>

<h1 id="element-1-hello-me-is-13-long-our-pls">Element 1: &lsquo;Hello ${Me}&rsquo; is: 13 long. # Our &ldquo;$(_pls &lsquo;&hellip;&rsquo; )&rdquo;</h1>

<h1 id="element-2-hello-you-is-12-long-quotes-are-missing">Element 2: Hello ${You} is: 12 long. # Quotes are missing</h1>

<h1 id="element-3-pass-is-10-long-pw-expanded-to-nothing">Element 3: /&lsquo;Pass: /&rsquo; is: 10 long. # ${pw} expanded to nothing</h1>

<h1 id="now-make-an-assignment-with-that-result">Now make an assignment with that result.</h1>

<p>declare -a array2=( ${arrayZ[@]} )</p>

<h1 id="and-print-what-happened">And print what happened.</h1>

<p>echo &ldquo;- - Test Three - -&rdquo;<br />
for (( i=0 ; ido<br />
echo Element $i: ${array2[$i]} is: ${#array2[$i]} long.<br />
done<br />
echo</p>

<h1 id="which-yields-2">Which yields:</h1>

<h1 id="test-three">- - Test Three - -</h1>

<h1 id="element-0-zero-is-4-long-our-marker-element-1">Element 0: zero is: 4 long. # Our marker element.</h1>

<h1 id="element-1-hello-me-is-11-long-intended-result">Element 1: Hello ${Me} is: 11 long. # Intended result.</h1>

<h1 id="element-2-hello-is-5-long-you-expanded-to-nothing">Element 2: Hello is: 5 long. # ${You} expanded to nothing.</h1>

<h1 id="element-3-pass-is-6-long-split-on-the-whitespace">Element 3: &lsquo;Pass: is: 6 long. # Split on the whitespace.</h1>

<h1 id="element-4-is-1-long-the-end-quote-is-here-now">Element 4: &lsquo; is: 1 long. # The end quote is here now.</h1>

<h1 id="our-element-1-has-had-its-leading-and-trailing-hard-quotes-stripped">Our Element 1 has had its leading and trailing hard quotes stripped.</h1>

<h1 id="although-not-shown-leading-and-trailing-whitespace-is-also-stripped">Although not shown, leading and trailing whitespace is also stripped.</h1>

<h1 id="now-that-the-string-contents-are-set-bash-will-always-internally">Now that the string contents are set, Bash will always, internally,</h1>

<p>#+ hard quote the contents as required during its operations.</p>

<h1 id="why">Why?</h1>

<h1 id="considering-our-pls-hello-me-construction">Considering our &ldquo;$(_pls &lsquo;Hello ${Me}&rsquo;)&rdquo; construction:</h1>

<h1 id="expansion-required-strip-the-quotes">&rdquo; &hellip; &ldquo; -&gt; Expansion required, strip the quotes.</h1>

<h1 id="replace-with-the-result-of-strip-this">$( &hellip; ) -&gt; Replace with the result of&hellip;, strip this.</h1>

<h1 id="pls-called-with-literal-arguments-strip-the-quotes">_pls &lsquo; &hellip; &rsquo; -&gt; called with literal arguments, strip the quotes.</h1>

<h1 id="the-result-returned-includes-hard-quotes-but-the-above-processing">The result returned includes hard quotes; BUT the above processing</h1>

<p>#+ has already been done, so they become part of the value assigned.</p>

<h1 id="similarly-during-further-usage-of-the-string-variable-the-me">Similarly, during further usage of the string variable, the ${Me}</h1>

<p>#+ is part of the contents (result) and survives any operations</p>

<h1 id="until-explicitly-told-to-evaluate-the-string">(Until explicitly told to evaluate the string).</h1>

<h1 id="hint-see-what-happens-when-the-hard-quotes-x27-are-replaced">Hint: See what happens when the hard quotes ($&lsquo;/x27&rsquo;) are replaced</h1>

<p>#+ with soft quotes ($&lsquo;/x22&rsquo;) in the above procedures.</p>

<h1 id="interesting-also-is-to-remove-the-addition-of-any-quoting">Interesting also is to remove the addition of any quoting.</h1>

<h1 id="protect-literal-string-test">_Protect_Literal_String_Test</h1>

<h1 id="remove-the-above-to-disable-this-code-1"># # Remove the above &ldquo;# &rdquo; to disable this code. # #</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;protect_literal.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@pw.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="may-need-to-be-invoked-with-bin-bash2-on-older-machines">May need to be invoked with #!/bin/bash2 on older machines.</h1>

<h1 id="random-password-generator-for-bash-2-x-by-antek-sawicki-tenox-tenox-tc">Random password generator for Bash 2.x by Antek Sawicki <a href="mailto:tenox@tenox.tc">tenox@tenox.tc</a>,</h1>

<h1 id="who-generously-gave-permission-to-the-document-author-to-use-it-here">who generously gave permission to the document author to use it here.</h1>

<h1 id="comments-added-by-document-author">==&gt; Comments added by document author ==&gt;</h1>

<p>MATRIX=&ldquo;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&rdquo;</p>

<h1 id="password-will-consist-of-alphanumeric-characters">==&gt; Password will consist of alphanumeric characters.</h1>

<p>LENGTH=&ldquo;8&rdquo;</p>

<h1 id="may-change-length-for-longer-password">==&gt; May change &lsquo;LENGTH&rsquo; for longer password.</h1>

<p>while [ &ldquo;${n:=1}&rdquo; -le &ldquo;$LENGTH&rdquo; ]</p>

<h1 id="recall-that-is-default-substitution-operator">==&gt; Recall that := is &ldquo;default substitution&rdquo; operator.</h1>

<h1 id="so-if-n-has-not-been-initialized-set-it-to-1">==&gt; So, if &lsquo;n&rsquo; has not been initialized, set it to 1.</h1>

<p>do<br />
PASS=&ldquo;$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}&rdquo;</p>

<h1 id="very-clever-but-tricky">==&gt; Very clever, but tricky.</h1>

<h1 id="starting-from-the-innermost-nesting">==&gt; Starting from the innermost nesting&hellip;</h1>

<h1 id="MATRIX">==&gt; $</h1>

<p>returns length of array MATRIX.</p>

<h1 id="MATRIX-1">==&gt; $RANDOM%$</h1>

<p>returns random number between 1</p>

<h1 id="and-length-of-matrix-1">==&gt; and [length of MATRIX] - 1.</h1>

<h1 id="MATRIX-2">==&gt; ${MATRIX:$(($RANDOM%$</h1>

<p>)):1}</p>

<h1 id="returns-expansion-of-matrix-at-random-position-by-length-1">==&gt; returns expansion of MATRIX at random position, by length 1.</h1>

<h1 id="see-var-pos-len-parameter-substitution-in-chapter-9">==&gt; See {var:pos:len} parameter substitution in Chapter 9.</h1>

<h1 id="and-the-associated-examples">==&gt; and the associated examples.</h1>

<h1 id="pass-simply-pastes-this-result-onto-previous-pass-concatenation">==&gt; PASS=&hellip; simply pastes this result onto previous PASS (concatenation).</h1>

<h1 id="to-visualize-this-more-clearly-uncomment-the-following-line">==&gt; To visualize this more clearly, uncomment the following line</h1>

<h1 id="echo-pass">echo &ldquo;$PASS&rdquo;</h1>

<h1 id="to-see-pass-being-built-up">==&gt; to see PASS being built up,</h1>

<h1 id="one-character-at-a-time-each-iteration-of-the-loop">==&gt; one character at a time, each iteration of the loop.</h1>

<p>let n+=1</p>

<h1 id="increment-n-for-next-pass">==&gt; Increment &lsquo;n&rsquo; for next pass.</h1>

<p>done</p>

<p>echo &ldquo;$PASS&rdquo; # ==&gt; Or, redirect to a file, as desired.</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;pw.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@q-function.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="douglas-hofstadter的声名狼藉的序列-q-series">Douglas Hofstadter的声名狼藉的序列&rdquo;Q-series&rdquo;:</h1>

<h1 id="q-1-q-2-1">Q(1) = Q(2) = 1</h1>

<h1 id="q-n-q-n-q-n-1-q-n-q-n-2-当n-2时">Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), 当n&gt;2时</h1>

<h1 id="这是一个令人感到陌生的-没有规律的-乱序-整数序列">这是一个令人感到陌生的, 没有规律的&rdquo;乱序&rdquo;整数序列.</h1>

<h1 id="序列的头20项-如下所示">序列的头20项, 如下所示:</h1>

<h1 id="1-1-2-3-3-4-5-5-6-6-6-8-8-8-10-9-10-11-11-12">1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12</h1>

<h1 id="请参考相关书籍-hofstadter的-goedel-escher-bach-an-eternal-golden-braid">请参考相关书籍, Hofstadter的, &ldquo;<em>Goedel, Escher, Bach: An Eternal Golden Braid</em>&rdquo;,</h1>

<p>#+ 第137页.</p>

<p>LIMIT=100 # 需要计算的数列长度.<br />
LINEWIDTH=20 # 每行打印的个数.</p>

<p>Q[1]=1 # 数列的头两项都为1.<br />
Q[2]=1</p>

<p>echo<br />
echo &ldquo;Q-series [$LIMIT terms]:&rdquo;<br />
echo -n &ldquo;${Q[1]} &ldquo; # 输出数列头两项.<br />
echo -n &ldquo;${Q[2]} &ldquo;</p>

<p>for ((n=3; n &lt;= $LIMIT; n++)) # C风格的循环条件.<br />
do # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]] 当n&gt;2时</p>

<h1 id="需要将表达式拆开-分步计算">需要将表达式拆开, 分步计算,</h1>

<p>#+ 因为Bash不能够很好的处理复杂数组的算术运算.</p>

<p>let &ldquo;n1 = $n - 1&rdquo; # n-1<br />
let &ldquo;n2 = $n - 2&rdquo; # n-2</p>

<p>t0=<code>expr $n - ${Q[n1]}</code> # n - Q[n-1]<br />
t1=<code>expr $n - ${Q[n2]}</code> # n - Q[n-2]</p>

<p>T0=${Q[t0]} # Q[n - Q[n-1]]<br />
T1=${Q[t1]} # Q[n - Q[n-2]]</p>

<p>Q[n]=<code>expr $T0 + $T1</code> # Q[n - Q[n-1]] + Q[n - Q[n-2]]<br />
echo -n &ldquo;${Q[n]} &ldquo;</p>

<p>if [ <code>expr $n % $LINEWIDTH</code> -eq 0 ] # 格式化输出.<br />
then # ^ 取模操作<br />
echo # 把每行都拆为20个数字的小块.<br />
fi</p>

<p>done</p>

<p>echo</p>

<p>exit 0</p>

<h1 id="这是q-series的一个迭代实现">这是Q-series的一个迭代实现.</h1>

<h1 id="更直接明了的实现是使用递归-请读者作为练习完成">更直接明了的实现是使用递归, 请读者作为练习完成.</h1>

<h1 id="警告-使用递归的方法来计算这个数列的话-会花费非常长的时间">警告: 使用递归的方法来计算这个数列的话, 会花费非常长的时间.</h1>

<p>%%%&amp;&amp;&amp;q-function.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@quote-
fetch.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="quote-fetch-sh-下载一份股票报价">quote-fetch.sh: 下载一份股票报价.</h1>

<p>E_NOPARAMS=66</p>

<p>if [ -z &ldquo;$1&rdquo; ] #必须指定需要获取的股票(代号).<br />
then echo &ldquo;Usage: <code>basename $0</code> stock-symbol&rdquo;<br />
exit $E_NOPARAMS<br />
fi</p>

<p>stock_symbol=$1</p>

<p>file_suffix=.html</p>

<h1 id="获得一个html文件-所以要正确命名它">获得一个HTML文件, 所以要正确命名它.</h1>

<p>URL=&lsquo;<a href="http://finance.yahoo.com/q?s='">http://finance.yahoo.com/q?s='</a></p>

<h1 id="yahoo金融板块-后缀是股票查询">Yahoo金融板块, 后缀是股票查询.</h1>

<h1 id="toc_500">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<p>wget -O ${stock_symbol}${file_suffix} &ldquo;${URL}${stock_symbol}&rdquo;</p>

<h1 id="toc_501">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="在http-search-yahoo-com上查询相关材料">在<a href="http://search.yahoo.com上查询相关材料:">http://search.yahoo.com上查询相关材料:</a></h1>

<h1 id="toc_503">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="url-http-search-yahoo-com-search-fr-ush-news-p-query">URL=&ldquo;<a href="http://search.yahoo.com/search?fr=ush-news&amp;p=${query}&quot;">http://search.yahoo.com/search?fr=ush-news&amp;p=${query}&quot;</a></h1>

<h1 id="wget-o-savefilename-url">wget -O &ldquo;$savefilename&rdquo; &ldquo;${URL}&rdquo;</h1>

<h1 id="toc_506">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="保存相关url的列表">保存相关URL的列表.</h1>

<p>exit $?</p>

<h1 id="练习-4">练习:</h1>

<h1 id="toc_509">&mdash;&ndash;</h1>

<h1 id="1-添加一个测试来验证用户是否在线">1) 添加一个测试来验证用户是否在线.</h1>

<h1 id="暗示-对-ppp-或-connect-来分析-ps-ax-的输出">(暗示: 对&rdquo;ppp&rdquo;或&rdquo;connect&rdquo;来分析&rsquo;ps -ax&rsquo;的输出.</h1>

<h1 id="2-修改这个脚本-让这个脚本具有获得本地天气预报的能力">2) 修改这个脚本, 让这个脚本具有获得本地天气预报的能力,</h1>

<p>#+ 将用户的zip code作为参数.<br />
%%%&amp;&amp;&amp;quote-
fetch.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@ra2ogg.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="ra2ogg-sh-将音频流文件-ra-转换为ogg格式的文件">ra2ogg.sh: 将音频流文件(*.ra)转换为ogg格式的文件.</h1>

<h1 id="使用-mplayer-媒体播放器程序">使用&rdquo;mplayer&rdquo;媒体播放器程序:</h1>

<h1 id="http-www-mplayerhq-hu-homepage"><a href="http://www.mplayerhq.hu/homepage">http://www.mplayerhq.hu/homepage</a></h1>

<h1 id="可能需要安装合适的编解码程序-codec-才能够正常的运行这个脚本">可能需要安装合适的编解码程序(codec)才能够正常的运行这个脚本.</h1>

<h1 id="需要使用-ogg-库和-oggenc">需要使用&rdquo;ogg&rdquo;库和&rdquo;oggenc&rdquo;:</h1>

<h1 id="http-www-xiph-org"><a href="http://www.xiph.org/">http://www.xiph.org/</a></h1>

<p>OFILEPREF=${1%%ra} # 去掉&rdquo;ra&rdquo;后缀.<br />
OFILESUFF=wav # wav文件的后缀.<br />
OUTFILE=&ldquo;$OFILEPREF&rdquo;&ldquo;$OFILESUFF&rdquo;<br />
E_NOARGS=65</p>

<p>if [ -z &ldquo;$1&rdquo; ] # 必须要指定一个需要转换的文件名.<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> [filename]&rdquo;<br />
exit $E_NOARGS<br />
fi</p>

<p>##########################################################################<br />
mplayer &ldquo;$1&rdquo; -ao pcm:file=$OUTFILE<br />
oggenc &ldquo;$OUTFILE&rdquo; # oggenc编码后会自动加上正确的文件扩展名.<br />
##########################################################################</p>

<p>rm &ldquo;$OUTFILE&rdquo; # 删除中介的*.wav文件.</p>

<h1 id="如果你想保留这个文件的话-可以把上边这行注释掉">如果你想保留这个文件的话, 可以把上边这行注释掉.</h1>

<p>exit $?</p>

<h1 id="注意">注意:</h1>

<h1 id="toc_521">&mdash;-</h1>

<h1 id="在网站上-简单的在-ram流音频文件上单击的话">在网站上, 简单的在*.ram流音频文件上单击的话,</h1>

<p>#+ 一般都只会下载真正音频流文件(就是*.ra文件)的URL.</p>

<h1 id="你可以使用-wget-或者一些类似的工具">你可以使用&rdquo;wget&rdquo;或者一些类似的工具</h1>

<p>#+ 来下载*.ra文件本身.</p>

<h1 id="练习-5">练习:</h1>

<h1 id="toc_525">&mdash;&ndash;</h1>

<h1 id="像上面所看到的-这个脚本只能够转换-ra文件">像上面所看到的, 这个脚本只能够转换*.ra文件.</h1>

<h1 id="给这个脚本添加一些灵活性-让它能够转换-ram-and-other-filenames">给这个脚本添加一些灵活性, 让它能够转换*.ram and other filenames.</h1>

<h1 id="如果你觉得这还不过瘾-那么你可以扩展这个脚本">如果你觉得这还不过瘾, 那么你可以扩展这个脚本,</h1>

<p>#+ 让它自动下载并转换音频流文件.</p>

<h1 id="给出一个url-使用-wget-批处理下载音频流文件">给出一个URL, (使用&rdquo;wget&rdquo;)批处理下载音频流文件,</h1>

<p>#+ 然后转换它们.<br />
%%%&amp;&amp;&amp;ra2ogg.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@ramdisk.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="ramdisk-sh">ramdisk.sh</h1>

<h1 id="一个-ramdisk-就是系统ram内存中的一部分">一个&rdquo;ramdisk&rdquo;就是系统RAM内存中的一部分,</h1>

<p>#+ 只不过它被当作文件系统来操作.</p>

<h1 id="它的优点是访问速度非常快-读-写时间快">它的优点是访问速度非常快(读/写时间快).</h1>

<h1 id="缺点-易失性-当机器重启或关机时-会丢失数组">缺点: 易失性, 当机器重启或关机时, 会丢失数组.</h1>

<p>#+ 而且会减少系统可用的RAM.</p>

<h1 id="那么ramdisk有什么用呢">那么ramdisk有什么用呢?</h1>

<h1 id="保存一个大数据集-比如保存表格或字典">保存一个大数据集, 比如保存表格或字典.</h1>

<p>#+ 这样的话, 可以增加查询速度, 因为访问内存比访问硬盘快得多.</p>

<p>E_NON_ROOT_USER=70 # 必须以root身份来运行.<br />
ROOTUSER_NAME=root</p>

<p>MOUNTPT=/mnt/ramdisk<br />
SIZE=2000 # 2K个块(可以进行适当的修改)<br />
BLOCKSIZE=1024 # 每块的大小为1K(1024字节)<br />
DEVICE=/dev/ram0 # 第一个ram设备</p>

<p>username=<code>id -nu</code><br />
if [ &ldquo;$username&rdquo; != &ldquo;$ROOTUSER_NAME&rdquo; ]<br />
then<br />
echo &ldquo;Must be root to run /&rdquo;<code>basename $0</code>/&ldquo;.&rdquo;<br />
exit $E_NON_ROOT_USER<br />
fi</p>

<p>if [ ! -d &ldquo;$MOUNTPT&rdquo; ] # 测试挂载点是否已经存在,<br />
then #+ 如果做了这个判断的话, 当脚本运行多次的时候,<br />
mkdir $MOUNTPT #+ 就不会报错了. (译者注: 主要是为了避免多次创建目录.)<br />
fi</p>

<p>dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE # 把RAM设备的内容用0填充.</p>

<h1 id="为什么必须这么做">为什么必须这么做?</h1>

<p>mke2fs $DEVICE # 在RAM上创建一个ext2文件系统.<br />
mount $DEVICE $MOUNTPT # 挂载上.<br />
chmod 777 $MOUNTPT # 使一般用户也可以访问这个ramdisk.</p>

<h1 id="然而-只能使用root身份来卸载它">然而, 只能使用root身份来卸载它.</h1>

<p>echo &ldquo;/&rdquo;$MOUNTPT/&rdquo; now available for use.&rdquo;</p>

<h1 id="现在ramdisk就可以访问了-即使是普通用户也可以访问">现在ramdisk就可以访问了, 即使是普通用户也可以访问.</h1>

<h1 id="小心-ramdisk存在易失性">小心, ramdisk存在易失性,</h1>

<p>#+ 如果重启或关机的话, 保存的内容就会消失.</p>

<h1 id="所以-还是要将你想保存的文件-保存到常规磁盘目录下">所以, 还是要将你想保存的文件, 保存到常规磁盘目录下.</h1>

<h1 id="重启之后-运行这个脚本-将会再次建立一个ramdisk">重启之后, 运行这个脚本, 将会再次建立一个ramdisk.</h1>

<h1 id="如果你仅仅重新加载-mnt-ramdisk-而没有运行其他步骤的话-那就不会正常工作">如果你仅仅重新加载/mnt/ramdisk, 而没有运行其他步骤的话, 那就不会正常工作.</h1>

<h1 id="如果对这个脚本进行适当的改进-就可以将其放入-etc-rc-d-rc-local中">如果对这个脚本进行适当的改进, 就可以将其放入/etc/rc.d/rc.local中,</h1>

<p>#+ 这样, 在系统启动的时候就会自动建立一个ramdisk.</p>

<h1 id="这么做非常适合于那些对速度要求很高的数据库服务器">这么做非常适合于那些对速度要求很高的数据库服务器.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;ramdisk.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@random2.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="random2-sh-产生一个范围在-0-1-之间的伪随机数">random2.sh: 产生一个范围在 0 - 1 之间的伪随机数.</h1>

<h1 id="使用了awk的rand-函数">使用了awk的rand()函数.</h1>

<p>AWKSCRIPT=&rsquo; { srand(); print rand() } &lsquo;</p>

<h1 id="command-s-传递到awk中的参数">Command(s) / 传递到awk中的参数</h1>

<h1 id="注意-srand-是awk中用来产生伪随机数种子的函数">注意, srand()是awk中用来产生伪随机数种子的函数.</h1>

<p>echo -n &ldquo;Random number between 0 and 1 = &ldquo;</p>

<p>echo | awk &ldquo;$AWKSCRIPT&rdquo;</p>

<h1 id="如果你省去-echo-会怎样">如果你省去&rsquo;echo&rsquo;, 会怎样?</h1>

<p>exit 0</p>

<h1 id="练习-6">练习:</h1>

<h1 id="toc_551">&mdash;&ndash;</h1>

<h1 id="1-使用循环结构-打印出10个不同的随机数">1) 使用循环结构, 打印出10个不同的随机数.</h1>

<h1 id="提示-在每次循环过程中-你必须使用-srand-函数来生成不同的种子">(提示: 在每次循环过程中, 你必须使用&rdquo;srand()&ldquo;函数来生成不同的种子,</h1>

<p>#+ 如果你不这么做会怎样?)</p>

<h1 id="2-使用整数乘法作为一个比例因子-在10到100的范围之间">2) 使用整数乘法作为一个比例因子, 在10到100的范围之间,</h1>

<p>#+ 来产生随机数.</p>

<h1 id="3-同上边的练习-2-但是这次产生随机整数">3) 同上边的练习#2, 但是这次产生随机整数.</h1>

<p>%%%&amp;&amp;&amp;random2.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@random-
between.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="random-between-sh">random-between.sh</h1>

<h1 id="产生两个指定值之间的随机数">产生两个指定值之间的随机数.</h1>

<h1 id="由bill-gradwohl编写-本书作者做了一些修改">由Bill Gradwohl编写, 本书作者做了一些修改.</h1>

<h1 id="脚本作者允许在这里使用">脚本作者允许在这里使用.</h1>

<p>randomBetween() {</p>

<h1 id="在-min和-max之间">在$min和$max之间,</h1>

<p>#+ 产生一个正的或负的随机数.<br />
#+ 并且可以被$divisibleBy所整除.</p>

<h1 id="给出一个合理的随机分配的返回值">给出一个合理的随机分配的返回值.</h1>

<h1 id="bill-gradwohl-oct-1-2003">Bill Gradwohl - Oct 1, 2003</h1>

<p>syntax() {</p>

<h1 id="在函数中内嵌函数">在函数中内嵌函数</h1>

<p>echo<br />
echo &ldquo;Syntax: randomBetween [min] [max] [multiple]&rdquo;<br />
echo<br />
echo &ldquo;Expects up to 3 passed parameters, but all are completely optional.&rdquo;<br />
echo &ldquo;min is the minimum value&rdquo;<br />
echo &ldquo;max is the maximum value&rdquo;<br />
echo &ldquo;multiple specifies that the answer must be a multiple of this value.&rdquo;<br />
echo &ldquo; i.e. answer must be evenly divisible by this number.&rdquo;<br />
echo<br />
echo &ldquo;If any value is missing, defaults area supplied as: 0 32767 1&rdquo;<br />
echo &ldquo;Successful completion returns 0, unsuccessful completion returns&rdquo;<br />
echo &ldquo;function syntax and 1.&rdquo;<br />
echo &ldquo;The answer is returned in the global variable randomBetweenAnswer&rdquo;<br />
echo &ldquo;Negative values for any passed parameter are handled correctly.&rdquo;<br />
}</p>

<p>local min=${1:-0}<br />
local max=${2:-32767}<br />
local divisibleBy=${3:-1}</p>

<h1 id="默认值分配-用来处理没有参数传递进来的情况">默认值分配, 用来处理没有参数传递进来的情况.</h1>

<p>local x<br />
local spread</p>

<h1 id="确认divisibleby是正值">确认divisibleBy是正值.</h1>

<p>[ ${divisibleBy} -lt 0 ] &amp;&amp; divisibleBy=$((0-divisibleBy))</p>

<h1 id="完整性检查">完整性检查.</h1>

<p>if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o ${min} -eq ${max} ]; then<br />
syntax<br />
return 1<br />
fi</p>

<h1 id="查看min和max是否颠倒了">查看min和max是否颠倒了.</h1>

<p>if [ ${min} -gt ${max} ]; then</p>

<h1 id="交换它们">交换它们.</h1>

<p>x=${min}<br />
min=${max}<br />
max=${x}<br />
fi</p>

<h1 id="如果min自己并不能够被-divisibleby所整除">如果min自己并不能够被$divisibleBy所整除,</h1>

<p>#+ 那么就调整max的值, 使其能够被$divisibleBy所整除, 前提是不能放大范围.<br />
if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then<br />
if [ ${min} -lt 0 ]; then<br />
min=$((min/divisibleBy*divisibleBy))<br />
else<br />
min=$((((min/divisibleBy)+1)*divisibleBy))<br />
fi<br />
fi</p>

<h1 id="如果min自己并不能够被-divisibleby所整除-1">如果min自己并不能够被$divisibleBy所整除,</h1>

<p>#+ 那么就调整max的值, 使其能够被$divisibleBy所整除, 前提是不能放大范围.<br />
if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then<br />
if [ ${max} -lt 0 ]; then<br />
max=$((((max/divisibleBy)-1)*divisibleBy))<br />
else<br />
max=$((max/divisibleBy*divisibleBy))<br />
fi<br />
fi</p>

<h1 id="toc_571">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<h1 id="现在-来做点真正的工作">现在, 来做点真正的工作.</h1>

<h1 id="注意-为了得到对于端点来说合适的分配">注意, 为了得到对于端点来说合适的分配,</h1>

<p>#+ 随机值的范围不得不落在<br />
#+ 0 和 abs(max-min)+divisibleBy 之间, 而不是 abs(max-min)+1.</p>

<h1 id="对于端点来说">对于端点来说,</h1>

<p>#+ 这个少量的增加将会产生合适的分配.</p>

<h1 id="如果修改这个公式-使用-abs-max-min-1-来代替-abs-max-min-divisibleby的话">如果修改这个公式, 使用 abs(max-min)+1 来代替 abs(max-min)+divisibleBy的话,</h1>

<p>#+ 也能够得到正确的答案, 但是在这种情况下所生成的随机值对于正好为端点倍数<br />
#+ 的这种情况来说将是不完美的, 因为正好为端点倍数情况下的随机率比较低,<br />
#+ 因为你才加1而已, 这比正常的公式下所产生的几率要小的多(正常为加divisibleBy).</p>

<h1 id="toc_576">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<p>spread=$((max-min))<br />
[ ${spread} -lt 0 ] &amp;&amp; spread=$((0-spread))<br />
let spread+=divisibleBy<br />
randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))</p>

<p>return 0</p>

<h1 id="然而-paulo-marcel-coelho-aragao-指出">然而, Paulo Marcel Coelho Aragao 指出</h1>

<p>#+ 当 $max 和 $min 不能够被$divisibleBy所整除时,<br />
#+ 这个公式将会失败.</p>

<h1 id="他建议使用如下公式">他建议使用如下公式:</h1>

<h1 id="rnumber-random-max-min-1-min-divisibleby-divisibleby">rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))</h1>

<p>}</p>

<h1 id="让我们测试一下这个函数">让我们测试一下这个函数.</h1>

<p>min=-14<br />
max=20<br />
divisibleBy=3</p>

<h1 id="产生一个所期望的数组answers-数组下标用来表示在范围内可能出现的值">产生一个所期望的数组answers, 数组下标用来表示在范围内可能出现的值,</h1>

<p>#+ 而元素内容记录的是这个值所出现的次数, 如果我们循环足够多次, 那么我们一定会得到至少一次出现机会.</p>

<p>declare -a answer<br />
minimum=${min}<br />
maximum=${max}<br />
if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then<br />
if [ ${minimum} -lt 0 ]; then<br />
minimum=$((minimum/divisibleBy*divisibleBy))<br />
else<br />
minimum=$((((minimum/divisibleBy)+1)*divisibleBy))<br />
fi<br />
fi</p>

<p>132 # 如果max本身并不能够被$divisibleBy整除,<br />
133 #+ 那么就调整max的值, 使其能够被$divisibleBy整除, 前提是不能放大范围.</p>

<p>if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then<br />
if [ ${maximum} -lt 0 ]; then<br />
maximum=$((((maximum/divisibleBy)-1)*divisibleBy))<br />
else<br />
maximum=$((maximum/divisibleBy*divisibleBy))<br />
fi<br />
fi</p>

<h1 id="我们需要产生一个下标全部为正的数组">我们需要产生一个下标全部为正的数组.</h1>

<p>#+ 所以我们需要一个displacement,<br />
#+ 这样就可以保证结果都为正.</p>

<p>displacement=$((0-minimum))<br />
for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do<br />
answer[i+displacement]=0<br />
done</p>

<h1 id="现在-让我们循环足够多的次数-来得到我们想要的答案">现在, 让我们循环足够多的次数, 来得到我们想要的答案.</h1>

<p>loopIt=1000 # 脚本作者建议循环 100000 次,<br />
#+ 但是这需要的时间太长了.</p>

<p>for ((i=0; i</p>

<h1 id="注意-我们在这里调用randombetweenanswer函数时-估计将min和max颠倒顺序">注意, 我们在这里调用randomBetweenAnswer函数时, 估计将min和max颠倒顺序.</h1>

<p>#+ 这是为了测试在这种情况下, 此函数是否还能正确的运行.</p>

<p>randomBetween ${max} ${min} ${divisibleBy}</p>

<h1 id="如果答案不是我们所期望的-就报错">如果答案不是我们所期望的, 就报错.</h1>

<p>[ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] &amp;&amp;
echo MIN or MAX error - ${randomBetweenAnswer}!<br />
[ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] &amp;&amp; echo DIVISIBLE BY error -
${randomBetweenAnswer}!</p>

<h1 id="将统计值保存到answer中">将统计值保存到answer中.</h1>

<p>answer[randomBetweenAnswer+displacement]=$((answer[randomBetweenAnswer+displacement]+1))<br />
done</p>

<h1 id="让我们来察看一下结果">让我们来察看一下结果.</h1>

<p>for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do<br />
[ ${answer[i+displacement]} -eq 0 ] &amp;&amp; echo &ldquo;We never got an answer of $i.&rdquo; ||
echo &ldquo;${i} occurred ${answer[i+displacement]} times.&rdquo;<br />
done</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;random-
between.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@random-
test.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="random到底有多随机">RANDOM到底有多随机?</h1>

<p>RANDOM=$$ # 使用脚本的进程ID来作为随机数的种子.</p>

<p>PIPS=6 # 一个骰子有6个面.<br />
MAXTHROWS=600 # 如果你没别的事做, 可以增加这个数值.<br />
throw=0 # 抛骰子的次数.</p>

<p>ones=0 # 必须把所有的count都初始化为0,<br />
twos=0 #+ 因为未初始化的变量为null, 不是0.<br />
threes=0<br />
fours=0<br />
fives=0<br />
sixes=0</p>

<p>print_result ()<br />
{<br />
echo<br />
echo &ldquo;ones = $ones&rdquo;<br />
echo &ldquo;twos = $twos&rdquo;<br />
echo &ldquo;threes = $threes&rdquo;<br />
echo &ldquo;fours = $fours&rdquo;<br />
echo &ldquo;fives = $fives&rdquo;<br />
echo &ldquo;sixes = $sixes&rdquo;<br />
echo<br />
}</p>

<p>update_count()<br />
{<br />
case &ldquo;$1&rdquo; in<br />
0) let &ldquo;ones += 1&rdquo;;; # 因为骰子没有&rdquo;零&rdquo;, 所以给1.<br />
1) let &ldquo;twos += 1&rdquo;;; # 把这个设为2, 后边也一样.<br />
2) let &ldquo;threes += 1&rdquo;;;<br />
3) let &ldquo;fours += 1&rdquo;;;<br />
4) let &ldquo;fives += 1&rdquo;;;<br />
5) let &ldquo;sixes += 1&rdquo;;;<br />
esac<br />
}</p>

<p>echo</p>

<p>while [ &ldquo;$throw&rdquo; -lt &ldquo;$MAXTHROWS&rdquo; ]<br />
do<br />
let &ldquo;die1 = RANDOM % $PIPS&rdquo;<br />
update_count $die1<br />
let &ldquo;throw += 1&rdquo;<br />
done</p>

<p>print_result</p>

<p>exit 0</p>

<h1 id="如果random是真正的随机-那么摇出来结果应该是平均的">如果RANDOM是真正的随机, 那么摇出来结果应该是平均的.</h1>

<h1 id="把-maxthrows设为600-那么每个面应该是100-上下的出入不应该超过20">把$MAXTHROWS设为600, 那么每个面应该是100, 上下的出入不应该超过20.</h1>

<h1 id="记住random毕竟是一个伪随机数">记住RANDOM毕竟是一个伪随机数,</h1>

<p>#+ 并且不是十分完美.</p>

<h1 id="随机数的生成是一个十分深奥并复杂的问题">随机数的生成是一个十分深奥并复杂的问题.</h1>

<h1 id="足够长的随机序列-不但会展现其杂乱无章的一面">足够长的随机序列, 不但会展现其杂乱无章的一面,</h1>

<p>#+ 同样也会展现其机会均等的一面.</p>

<h1 id="练习-很简单">练习 (很简单):</h1>

<h1 id="toc_595">&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1 id="重写这个脚本-做成抛1000次硬币的形式">重写这个脚本, 做成抛1000次硬币的形式.</h1>

<h1 id="分为-头-和-字-两面">分为&rdquo;头&rdquo;和&rdquo;字&rdquo;两面.</h1>

<p>%%%&amp;&amp;&amp;random-
test.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@read-
novar.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="read-novar-sh">read-novar.sh</h1>

<p>echo</p>

<h1 id="toc_599">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; #</h1>

<p>echo -n &ldquo;Enter a value: &ldquo;<br />
read var<br />
echo &ldquo;/&ldquo;var/&rdquo; = &ldquo;$var&rdquo;&rdquo;</p>

<h1 id="到这里为止-都与期望的一样">到这里为止, 都与期望的一样.</h1>

<h1 id="toc_601">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<p>echo</p>

<h1 id="toc_602">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- #</h1>

<p>echo -n &ldquo;Enter another value: &ldquo;<br />
read # 没有变量分配给&rsquo;read&rsquo;命令, 所以&hellip;<br />
#+ 输入将分配给默认变量, $REPLY.<br />
var=&ldquo;$REPLY&rdquo;<br />
echo &ldquo;/&ldquo;var/&rdquo; = &ldquo;$var&rdquo;&rdquo;</p>

<h1 id="这部分代码和上边的代码等价">这部分代码和上边的代码等价.</h1>

<h1 id="toc_604">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</h1>

<p>echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;read-
novar.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@readpipe.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/sh</p>

<h1 id="readpipe-sh">readpipe.sh</h1>

<h1 id="这个例子是由bjon-eriksson所编写的">这个例子是由Bjon Eriksson所编写的.</h1>

<p>last=&ldquo;(null)&rdquo;<br />
cat $0 |<br />
while read line<br />
do<br />
echo &ldquo;{$line}&rdquo;<br />
last=$line<br />
done<br />
printf &ldquo;/nAll done, last:$last/n&rdquo;</p>

<p>exit 0 # 代码结束.</p>

<h1 id="下边是脚本的-部分-输出">下边是脚本的(部分)输出.</h1>

<h1 id="echo-出了多余的大括号">&lsquo;echo&rsquo;出了多余的大括号.</h1>

<p>#############################################</p>

<p>./readpipe.sh</p>

<p>{#!/bin/sh}<br />
{last=&ldquo;(null)&rdquo;}<br />
{cat $0 |}<br />
{while read line}<br />
{do}<br />
{echo &ldquo;{$line}&rdquo;}<br />
{last=$line}<br />
{done}<br />
{printf &ldquo;nAll done, last:$lastn&rdquo;}</p>

<p>All done, last:(null)</p>

<p>变量(last)被设置在子shell中, 并没有被设置在外边.<br />
%%%&amp;&amp;&amp;readpipe.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@read-
redir.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<p>read var1 &lt;data-file<br />
echo &ldquo;var1 = $var1&rdquo;</p>

<h1 id="var1将会把-data-file-的第一行的全部内容都为它的值">var1将会把&rdquo;data-file&rdquo;的第一行的全部内容都为它的值.</h1>

<p>read var2 var3 &lt;data-file<br />
echo &ldquo;var2 = $var2 var3 = $var3&rdquo;</p>

<h1 id="注意-这里的-read-命令将会产生一种不直观的行为">注意, 这里的&rdquo;read&rdquo;命令将会产生一种不直观的行为.</h1>

<h1 id="1-重新从文件的开头开始读入变量">1) 重新从文件的开头开始读入变量.</h1>

<h1 id="2-每个变量都设置成了以空白分割的字符串">2) 每个变量都设置成了以空白分割的字符串.</h1>

<h1 id="而不是之前的以整行的内容作为变量的值">而不是之前的以整行的内容作为变量的值.</h1>

<h1 id="3-而最后一个变量将会取得第一行剩余的全部部分-译者注-不管是否以空白分割">3) 而最后一个变量将会取得第一行剩余的全部部分(译者注: 不管是否以空白分割).</h1>

<h1 id="4-如果需要赋值的变量个数比文件中第一行以空白分割的字符串个数还多的话">4) 如果需要赋值的变量个数比文件中第一行以空白分割的字符串个数还多的话,</h1>

<h1 id="那么这些变量将会被赋空值">那么这些变量将会被赋空值.</h1>

<p>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;</p>

<h1 id="如何用循环来解决上边所提到的问题">如何用循环来解决上边所提到的问题:</h1>

<p>while read line<br />
do<br />
echo &ldquo;$line&rdquo;<br />
done &lt;data-file</p>

<h1 id="感谢-heiner-steven-指出了这点">感谢, Heiner Steven 指出了这点.</h1>

<p>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;</p>

<h1 id="使用-ifs-内部域分隔变量-来将每行的输入单独的放到-read-中">使用$IFS(内部域分隔变量)来将每行的输入单独的放到&rdquo;read&rdquo;中,</h1>

<h1 id="前提是如果你不想使用默认空白的话">前提是如果你不想使用默认空白的话.</h1>

<p>echo &ldquo;List of all users:&rdquo;<br />
OIFS=$IFS; IFS=: # /etc/passwd 使用 &ldquo;:&rdquo; 作为域分隔符.<br />
while read name passwd uid gid fullname ignore<br />
do<br />
echo &ldquo;$name ($fullname)&rdquo;<br />
done &lt;/etc/passwd # I/O 重定向.<br />
IFS=$OIFS # 恢复原始的$IFS.</p>

<h1 id="这段代码也是heiner-steven编写的">这段代码也是Heiner Steven编写的.</h1>

<h1 id="在循环内部设置-ifs变量">在循环内部设置$IFS变量,</h1>

<p>#+ 而不用把原始的$IFS<br />
#+ 保存到临时变量中.</p>

<h1 id="感谢-dim-segebart-指出了这点">感谢, Dim Segebart, 指出了这点.</h1>

<p>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />
echo &ldquo;List of all users:&rdquo;</p>

<p>while IFS=: read name passwd uid gid fullname ignore<br />
do<br />
echo &ldquo;$name ($fullname)&rdquo;<br />
done &lt;/etc/passwd # I/O 重定向.</p>

<p>echo<br />
echo &ldquo;/$IFS still $IFS&rdquo;</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;read-
redir.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@read-r.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<p>echo</p>

<p>echo &ldquo;Enter a string terminated by a //, then press <ENTER>.&rdquo;<br />
echo &ldquo;Then, enter a second string, and again press <ENTER>.&rdquo;<br />
read var1 # 当 read $var1 时, &ldquo;/&rdquo; 将会阻止产生新行.</p>

<h1 id="first-line">first line /</h1>

<h1 id="second-line">second line</h1>

<p>echo &ldquo;var1 = $var1&rdquo;</p>

<h1 id="var1-first-line-second-line">var1 = first line second line</h1>

<h1 id="对于每个以-结尾的行">对于每个以 &ldquo;/&rdquo; 结尾的行,</h1>

<p>#+ 你都会看到一个下一行的提示符, 让你继续向var1输入内容.</p>

<p>echo; echo</p>

<p>echo &ldquo;Enter another string terminated by a // , then press <ENTER>.&rdquo;<br />
read -r var2 # -r 选项会让 &ldquo;/&rdquo; 转义.</p>

<h1 id="first-line-1">first line /</h1>

<p>echo &ldquo;var2 = $var2&rdquo;</p>

<h1 id="var2-first-line">var2 = first line /</h1>

<h1 id="第一个-enter-就会结束var2变量的录入">第一个 <ENTER> 就会结束var2变量的录入.</h1>

<p>echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;read-r.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@realname.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="realname-sh">realname.sh</h1>

<h1 id="依靠username-从-etc-passwd中获得-真名">依靠username, 从/etc/passwd中获得&rdquo;真名&rdquo;.</h1>

<p>ARGCOUNT=1 # 需要一个参数.<br />
E_WRONGARGS=65</p>

<p>file=/etc/passwd<br />
pattern=$1</p>

<p>if [ $# -ne &ldquo;$ARGCOUNT&rdquo; ]<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> USERNAME&rdquo;<br />
exit $E_WRONGARGS<br />
fi</p>

<p>file_excerpt () # 按照要求的模式来扫描文件, 然后打印文件相关的部分.<br />
{<br />
while read line # &ldquo;while&rdquo;并不一定非得有&rdquo;[ condition ]&ldquo;不可.<br />
do<br />
echo &ldquo;$line&rdquo; | grep $1 | awk -F&rdquo;:&rdquo; &lsquo;{ print $5 }&rsquo; # awk用&rdquo;:&ldquo;作为界定符.<br />
done<br />
} &lt;$file # 重定向到函数的stdin.</p>

<p>file_excerpt $pattern</p>

<h1 id="是的-整个脚本其实可以被缩减为">是的, 整个脚本其实可以被缩减为</h1>

<h1 id="grep-pattern-etc-passwd-awk-f-print-5">grep PATTERN /etc/passwd | awk -F&rdquo;:&rdquo; &lsquo;{ print $5 }&rsquo;</h1>

<h1 id="或">或</h1>

<h1 id="awk-f-pattern-print-5">awk -F: &lsquo;/PATTERN/ {print $5}&rsquo;</h1>

<h1 id="或-1">或</h1>

<h1 id="awk-f-1-username-print-5-从username中获得真名">awk -F: &lsquo;($1 == &ldquo;username&rdquo;) { print $5 }&rsquo; # 从username中获得真名.</h1>

<h1 id="但是-这些起不到示例的作用">但是, 这些起不到示例的作用.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;realname.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@reassign-
stdout.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="reassign-stdout-sh">reassign-stdout.sh</h1>

<p>LOGFILE=logfile.txt</p>

<p>exec 6&gt;&amp;1 # 将fd #6与stdout链接起来.</p>

<h1 id="保存stdout">保存stdout.</h1>

<p>exec &gt; $LOGFILE # stdout就被文件&rdquo;logfile.txt&rdquo;所代替了.</p>

<h1 id="toc_642">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; #</h1>

<h1 id="在这块中所有命令的输出都会发送到文件-logfile中">在这块中所有命令的输出都会发送到文件$LOGFILE中.</h1>

<p>echo -n &ldquo;Logfile: &ldquo;<br />
date<br />
echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
echo</p>

<p>echo &ldquo;Output of /&ldquo;ls -al/&rdquo; command&rdquo;<br />
echo<br />
ls -al<br />
echo; echo<br />
echo &ldquo;Output of /&ldquo;df/&rdquo; command&rdquo;<br />
echo<br />
df</p>

<h1 id="toc_644">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<p>exec 1&gt;&amp;6 6&gt;&amp;- # 恢复stdout, 然后关闭文件描述符#6.</p>

<p>echo<br />
echo &ldquo;== stdout now restored to default == &rdquo;<br />
echo<br />
ls -al<br />
echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;reassign-
stdout.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@recurse.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="recurse-sh">recurse.sh</h1>

<h1 id="脚本能否递归地调用自己">脚本能否递归地调用自己?</h1>

<h1 id="是的-但这有什么实际的用处吗">是的, 但这有什么实际的用处吗?</h1>

<h1 id="看下面的">(看下面的.)</h1>

<p>RANGE=10<br />
MAXVAL=9</p>

<p>i=$RANDOM<br />
let &ldquo;i %= $RANGE&rdquo; # 在0到$RANGE - 1之间, 产生一个随机数.</p>

<p>if [ &ldquo;$i&rdquo; -lt &ldquo;$MAXVAL&rdquo; ]<br />
then<br />
echo &ldquo;i = $i&rdquo;<br />
./$0 # 脚本递归地产生自己的一个新实例, 并调用.<br />
fi # 每个子脚本都做同样的事情, until<br />
#+ 直到产生的变量$i等于$MAXVAL为止.</p>

<h1 id="如果使用-while-循环来代替-if-then-测试结构的话-会产生问题">如果使用&rdquo;while&rdquo;循环来代替&rdquo;if/then&rdquo;测试结构的话, 会产生问题.</h1>

<h1 id="解释一下为什么">解释一下为什么.</h1>

<p>exit 0</p>

<h1 id="注意-1">注意:</h1>

<h1 id="toc_652">&mdash;&ndash;</h1>

<h1 id="脚本想要正常的工作-就必须具备可执行权限">脚本想要正常的工作, 就必须具备可执行权限.</h1>

<h1 id="即使使用-sh-命令来调用它-但是没有设置正确的权限一样会导致问题">即使使用&rdquo;sh&rdquo;命令来调用它, 但是没有设置正确的权限一样会导致问题.</h1>

<h1 id="解释一下原因">解释一下原因.</h1>

<p>%%%&amp;&amp;&amp;recurse.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@redir1.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="使用-exec-重定向stdin">使用&rsquo;exec&rsquo;重定向stdin.</h1>

<p>exec 6 # 保存stdin.</p>

<p>exec &lt; data-file # stdin被文件&rdquo;data-file&rdquo;所代替.</p>

<p>read a1 # 读取文件&rdquo;data-file&rdquo;的第一行.<br />
read a2 # 读取文件&rdquo;data-file&rdquo;的第二行.</p>

<p>echo<br />
echo &ldquo;Following lines read from file.&rdquo;<br />
echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
echo $a1<br />
echo $a2</p>

<p>echo; echo; echo</p>

<p>exec 0# 现在将stdin从fd #6中恢复, 因为刚才我们把stdin重定向到#6了,<br />
#+ 然后关闭fd #6 ( 6#<br />
#</p>

<p>echo -n &ldquo;Enter data &rdquo;<br />
read b1 # 现在&rdquo;read&rdquo;已经恢复正常了, 就是能够正常的从stdin中读取.<br />
echo &ldquo;Input read from stdin.&rdquo;<br />
echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
echo &ldquo;b1 = $b1&rdquo;</p>

<p>echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;redir1.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@redir2a.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="这是上个脚本的另一个版本">这是上个脚本的另一个版本.</h1>

<h1 id="heiner-steven建议">Heiner Steven建议,</h1>

<p>#+ 为了避免重定向循环运行在子shell中(老版本的shell会这么做), 最好让重定向循环运行在当前工作区内,<br />
#+ 这样的话, 需要提前进行文件描述符重定向,<br />
#+ 因为变量如果在(子shell上运行的)循环中被修改的话, 循环结束后并不会保存修改后的值.</p>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
Filename=names.data # 如果没有指定文件名则使用默认值.<br />
else<br />
Filename=$1<br />
fi</p>

<p>exec 3exec 0</p>

<p>count=0<br />
echo</p>

<p>while [ &ldquo;$name&rdquo; != Smith ]<br />
do<br />
read name # 从stdin(现在已经是$Filename了)中读取.<br />
echo $name<br />
let &ldquo;count += 1&rdquo;<br />
done # 从文件$Filename中循环读取<br />
#+ 因为文件(译者注：指默认文件, 在本节最后)有20行.</p>

<h1 id="这个脚本原先在-while-循环的结尾还有一句">这个脚本原先在&rdquo;while&rdquo;循环的结尾还有一句:</h1>

<p>#+ done # 练习:</p>

<h1 id="为什么不需要这句了">为什么不需要这句了?</h1>

<p>exec 0exec 3</p>

<p>echo; echo &ldquo;$count names read&rdquo;; echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;redir2a.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@redir2.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="redir2-sh">redir2.sh</h1>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
Filename=names.data # 如果没有指定文件名, 则使用这个默认值.<br />
else<br />
Filename=$1<br />
fi<br />
#+ Filename=${1:-names.data}</p>

<h1 id="这句可代替上面的测试-参数替换">这句可代替上面的测试(参数替换).</h1>

<p>count=0</p>

<p>echo</p>

<p>while [ &ldquo;$name&rdquo; != Smith ] # 为什么变量$name要用引号?<br />
do<br />
read name # 从$Filename文件中读取输入, 而不是在stdin中读取输入.<br />
echo $name<br />
let &ldquo;count += 1&rdquo;<br />
done # ^^^^^^^^^^^^</p>

<p>echo; echo &ldquo;$count names read&rdquo;; echo</p>

<p>exit 0</p>

<h1 id="注意在一些比较老的shell脚本编程语言中">注意在一些比较老的shell脚本编程语言中,</h1>

<p>#+ 重定向的循环是放在子shell里运行的.</p>

<h1 id="因此-count-值返回后会是-0-此值是在循环开始前的初始值">因此, $count 值返回后会是 0, 此值是在循环开始前的初始值.</h1>

<h1 id="如果可能的话-尽量避免在bash或ksh中使用子shell"><em>如果可能的话</em>, 尽量避免在Bash或ksh中使用子shell,</h1>

<p>#+ 所以这个脚本能够正确的运行.</p>

<h1 id="多谢heiner-steven指出这个问题">(多谢Heiner Steven指出这个问题.)</h1>

<h1 id="然而">然而 &hellip;</h1>

<h1 id="bash有时还是-会-在一个使用管道的-while-read-循环中启动一个子shell">Bash有时还是*会*在一个使用管道的&rdquo;while-read&rdquo;循环中启动一个子shell,</h1>

<p>#+ 与重定向的&rdquo;while&rdquo;循环还是有区别的.</p>

<p>abc=hi<br />
echo -e &ldquo;1/n2/n3&rdquo; | while read l<br />
do abc=&ldquo;$l&rdquo;<br />
echo $abc<br />
done<br />
echo $abc</p>

<h1 id="感谢-bruno-de-oliveira-schneider">感谢, Bruno de Oliveira Schneider</h1>

<p>#+ 给出上面的代码片段来演示此问题.</p>

<h1 id="同时-感谢-brian-onn-修正了一个注释错误">同时, 感谢, Brian Onn, 修正了一个注释错误.</h1>

<p>%%%&amp;&amp;&amp;redir2.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@redir3.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="和前面的例子相同-但使用的是-until-循环">和前面的例子相同, 但使用的是&rdquo;until&rdquo;循环.</h1>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
Filename=names.data # 如果没有指定文件名那就使用默认值.<br />
else<br />
Filename=$1<br />
fi</p>

<h1 id="while-name-smith">while [ &ldquo;$name&rdquo; != Smith ]</h1>

<p>until [ &ldquo;$name&rdquo; = Smith ] # 把!=改为=.<br />
do<br />
read name # 从$Filename中读取, 而不是从stdin中读取.<br />
echo $name<br />
done # ^^^^^^^^^^^^</p>

<h1 id="结果和前面例子的-while-循环相同">结果和前面例子的&rdquo;while&rdquo;循环相同.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;redir3.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@redir4a.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
Filename=names.data # 如果没有指定文件名, 则使用默认值.<br />
else<br />
Filename=$1<br />
fi</p>

<p>Savefile=$Filename.new # 保存最终结果的文件名.<br />
FinalName=Jonah # 终止&rdquo;read&rdquo;时的名称.</p>

<p>line_count=<code>wc $Filename | awk '{ print $1 }'</code> # 目标文件的行数.</p>

<p>for name in <code>seq $line_count</code><br />
do<br />
read name<br />
echo &ldquo;$name&rdquo;<br />
if [ &ldquo;$name&rdquo; = &ldquo;$FinalName&rdquo; ]<br />
then<br />
break<br />
fi<br />
done &lt; &ldquo;$Filename&rdquo; &gt; &ldquo;$Savefile&rdquo; # 重定向stdin到文件$Filename,</p>

<h1 id="并且将它保存到备份文件中">^^^^^^^^^^^^^^^^^^^^^^^^^^^ 并且将它保存到备份文件中.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;redir4a.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@redir4.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
Filename=names.data # 如果没有指定文件名就使用默认值.<br />
else<br />
Filename=$1<br />
fi</p>

<p>line_count=<code>wc $Filename | awk '{ print $1 }'</code></p>

<h1 id="目标文件的行数">目标文件的行数.</h1>

<h1 id="此处的代码太过做作-并且写得很难看">此处的代码太过做作, 并且写得很难看,</h1>

<p>#+ 但至少展示了&rdquo;for&rdquo;循环的stdin可以重定向&hellip;<br />
#+ 当然, 你得足够聪明, 才能看得出来.</p>

<h1 id="更简洁的写法是-line-count-wc-l-filename">更简洁的写法是 line_count=$(wc -l &lt; &ldquo;$Filename&rdquo;)</h1>

<p>for name in <code>seq $line_count</code> # &ldquo;seq&rdquo;打印出数字序列.</p>

<h1 id="while-name-smith-比-while-循环更复杂">while [ &ldquo;$name&rdquo; != Smith ] &ndash; 比&rdquo;while&rdquo;循环更复杂 &ndash;</h1>

<p>do<br />
read name # 从$Filename中, 而非从stdin中读取.<br />
echo $name<br />
if [ &ldquo;$name&rdquo; = Smith ] # 因为用for循环, 所以需要这个多余测试.<br />
then<br />
break<br />
fi<br />
done # ^^^^^^^^^^^^</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;redir4.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@redir5.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
Filename=names.data # 如果文件名没有指定, 使用默认值.<br />
else<br />
Filename=$1<br />
fi</p>

<p>TRUE=1</p>

<p>if [ &ldquo;$TRUE&rdquo; ] # if true 和 if : 都可以.<br />
then<br />
read name<br />
echo $name<br />
fi # ^^^^^^^^^^^^</p>

<h1 id="只读取了文件的第一行">只读取了文件的第一行.</h1>

<h1 id="an-if-then-测试结构不能自动地反复地执行-除非把它们嵌到循环里">An &ldquo;if/then&rdquo;测试结构不能自动地反复地执行, 除非把它们嵌到循环里.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;redir5.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@ref-
params.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="ref-params-sh-解除传递给函数的参数引用">ref-params.sh: 解除传递给函数的参数引用.</h1>

<h1 id="复杂的例子">(复杂的例子)</h1>

<p>ITERATIONS=3 # 取得输入的次数.<br />
icount=1</p>

<p>my_read () {</p>

<h1 id="用my-read-varname这种形式来调用">用my_read varname这种形式来调用,</h1>

<p>#+ 将之前用括号括起的值作为默认值输出,<br />
#+ 然后要求输入一个新值.</p>

<p>local local_var</p>

<p>echo -n &ldquo;Enter a value &rdquo;<br />
eval &lsquo;echo -n &ldquo;[$&lsquo;$1&rsquo;] &ldquo;&rsquo; # 之前的值.</p>

<h1 id="eval-echo-n-1-更容易理解">eval echo -n &ldquo;[/$$1] &ldquo; # 更容易理解,</h1>

<p>#+ 但会丢失用户在尾部输入的空格.<br />
read local_var<br />
[ -n &ldquo;$local_var&rdquo; ] &amp;&amp; eval $1=/$local_var</p>

<h1 id="与列表-如果-local-var-的测试结果为true-则把变量-1-的值赋给它">&ldquo;与列表&rdquo;: 如果&rdquo;local_var&rdquo;的测试结果为true, 则把变量&rdquo;$1&rdquo;的值赋给它.</h1>

<p>}</p>

<p>echo</p>

<p>while [ &ldquo;$icount&rdquo; -le &ldquo;$ITERATIONS&rdquo; ]<br />
do<br />
my_read var<br />
echo &ldquo;Entry #$icount = $var&rdquo;<br />
let &ldquo;icount += 1&rdquo;<br />
echo<br />
done</p>

<h1 id="感谢stephane-chazelas提供这个例子">感谢Stephane Chazelas提供这个例子.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;ref-
params.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@remote.bash@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="remote-bash-使用ssh">remote.bash: 使用ssh.</h1>

<h1 id="这个例子是michael-zick编写的">这个例子是Michael Zick编写的.</h1>

<h1 id="授权在本书中使用">授权在本书中使用.</h1>

<h1 id="假设的一些前提">假设的一些前提:</h1>

<h1 id="toc_691">&mdash;&mdash;&mdash;&mdash;&mdash;</h1>

<h1 id="fd-2-文件描述符2-的内容并没有被丢弃-2-dev-null">fd-2(文件描述符2)的内容并没有被丢弃( &lsquo;2&gt;/dev/null&rsquo; ).</h1>

<h1 id="ssh-sshd假设stderr-2-将会显示给用户">ssh/sshd假设stderr (&lsquo;2&rsquo;)将会显示给用户.</h1>

<h1 id="假设sshd正运行在你的机器上">假设sshd正运行在你的机器上.</h1>

<h1 id="对于绝大多数-标准-的发行版-都是有sshd的">对于绝大多数&rsquo;标准&rsquo;的发行版, 都是有sshd的,</h1>

<p>#+ 并且没有稀奇古怪的ssh-keygen.</p>

<h1 id="在你的机器上从命令行中试着运行一下ssh">在你的机器上从命令行中试着运行一下ssh:</h1>

<h1 id="ssh-hostname">$ ssh $HOSTNAME</h1>

<h1 id="不需要特别的设置-也会要求你输入密码">不需要特别的设置, 也会要求你输入密码.</h1>

<h1 id="接下来输入密码">接下来输入密码,</h1>

<h1 id="完成后-exit">完成后, $ exit</h1>

<h1 id="能够正常运行么-如果正常的话-接下来你可以获得更多的乐趣了">能够正常运行么? 如果正常的话, 接下来你可以获得更多的乐趣了.</h1>

<h1 id="尝试在你的机器上以-root-身份来运行ssh">尝试在你的机器上以&rsquo;root&rsquo;身份来运行ssh:</h1>

<h1 id="ssh-l-root-hostname">$ ssh -l root $HOSTNAME</h1>

<h1 id="当要求询问密码时-输入root的密码-注意别输入你的用户密码">当要求询问密码时, 输入root的密码, 注意别输入你的用户密码.</h1>

<h1 id="last-login-tue-aug-10-20-25-49-2004-from-localhost-localdomain">Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain</h1>

<h1 id="完成后键入-exit">完成后键入&rsquo;exit&rsquo;.</h1>

<h1 id="上边的动作将会带给你一个交互的shell">上边的动作将会带给你一个交互的shell.</h1>

<h1 id="也可以在-single-command-模式下建立sshd">也可以在&rsquo;single command&rsquo;模式下建立sshd,</h1>

<p>#+ 但是这已经超出本例所讲解的范围了.</p>

<h1 id="唯一需要注意的是-下面的命令都可以运行在">唯一需要注意的是, 下面的命令都可以运行在</h1>

<p>#+ &lsquo;single command&rsquo;模式下.</p>

<h1 id="基本的-写stdout-本地-命令">基本的, 写stdout(本地)命令.</h1>

<p>ls -l</p>

<h1 id="这样远端机器上就会执行相同的命令">这样远端机器上就会执行相同的命令.</h1>

<h1 id="如果你想的话-可以传递不同的-username-和-hostname">如果你想的话, 可以传递不同的&rsquo;USERNAME&rsquo;和&rsquo;HOSTNAME&rsquo;:</h1>

<p>USER=${USERNAME:-$(whoami)}<br />
HOST=${HOSTNAME:-$(hostname)}</p>

<h1 id="现在-在远端主机上执行上边的命令">现在, 在远端主机上执行上边的命令,</h1>

<p>#+ 当然, 所有的传输都会被加密.</p>

<p>ssh -l ${USER} ${HOST} &ldquo; ls -l &ldquo;</p>

<h1 id="期望的结果就是在远端主机上列出">期望的结果就是在远端主机上列出</h1>

<p>#+ 你的用户名所拥有的主目录下的所有文件.</p>

<h1 id="如果想看点不一样的东西">如果想看点不一样的东西,</h1>

<p>#+ 那就在别的地方运行这个脚本, 别在你自己的主目录下运行这个脚本.</p>

<h1 id="换句话说-bash命令已经作为一个引用行">换句话说, Bash命令已经作为一个引用行</h1>

<p>#+ 被传递到了远端shell中, 这样远端机器就会运行它.</p>

<h1 id="在这种情况下-sshd代表你运行了-bash-c-ls-l">在这种情况下, sshd代表你运行了&rsquo; bash -c &ldquo;ls -l&rdquo; &lsquo;.</h1>

<h1 id="如果你想不输入密码">如果你想不输入密码,</h1>

<p>#+ 或者想更详细的了解相关的问题, 请参考:<br />
#+ man ssh<br />
#+ man ssh-keygen<br />
#+ man sshd_config.</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;remote.bash&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@reply.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="reply-sh">reply.sh</h1>

<h1 id="reply是提供给-read-命令的默认变量">REPLY是提供给&rsquo;read&rsquo;命令的默认变量.</h1>

<p>echo<br />
echo -n &ldquo;What is your favorite vegetable? &rdquo;<br />
read</p>

<p>echo &ldquo;Your favorite vegetable is $REPLY.&rdquo;</p>

<h1 id="当且仅当没有变量提供给-read-命令时">当且仅当没有变量提供给&rdquo;read&rdquo;命令时,</h1>

<p>#+ REPLY才保存最后一个&rdquo;read&rdquo;命令读入的值.</p>

<p>echo<br />
echo -n &ldquo;What is your favorite fruit? &rdquo;<br />
read fruit<br />
echo &ldquo;Your favorite fruit is $fruit.&rdquo;<br />
echo &ldquo;but&hellip;&rdquo;<br />
echo &ldquo;Value of /$REPLY is still $REPLY.&rdquo;</p>

<h1 id="reply还是保存着上一个read命令的值">$REPLY还是保存着上一个read命令的值,</h1>

<p>#+ 因为变量$fruit被传入到了这个新的&rdquo;read&rdquo;命令中.</p>

<p>echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;reply.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@resistor-
inventory.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="resistor-inventory-sh">resistor-inventory.sh</h1>

<h1 id="使用间接变量引用的简单数据库应用">使用间接变量引用的简单数据库应用.</h1>

<h1 id="toc_725">============================================================== #</h1>

<h1 id="数据">数据</h1>

<p>B1723_value=470 # 欧姆<br />
B1723_powerdissip=.25 # 瓦特<br />
B1723_colorcode=&ldquo;yellow-violet-brown&rdquo; # 颜色<br />
B1723_loc=173 # 位置<br />
B1723_inventory=78 # 数量</p>

<p>B1724_value=1000<br />
B1724_powerdissip=.25<br />
B1724_colorcode=&ldquo;brown-black-red&rdquo;<br />
B1724_loc=24N<br />
B1724_inventory=243</p>

<p>B1725_value=10000<br />
B1725_powerdissip=.25<br />
B1725_colorcode=&ldquo;brown-black-orange&rdquo;<br />
B1725_loc=24N<br />
B1725_inventory=89</p>

<h1 id="toc_727">==============================================================</h1>

<p>echo</p>

<p>PS3=&lsquo;Enter catalog number: &lsquo;</p>

<p>echo</p>

<p>select catalog_number in &ldquo;B1723&rdquo; &ldquo;B1724&rdquo; &ldquo;B1725&rdquo;<br />
do<br />
Inv=${catalog_number}_inventory<br />
Val=${catalog_number}_value<br />
Pdissip=${catalog_number}_powerdissip<br />
Loc=${catalog_number}_loc<br />
Ccode=${catalog_number}_colorcode</p>

<p>echo<br />
echo &ldquo;Catalog number $catalog_number:&rdquo;<br />
echo &ldquo;There are ${!Inv} of [${!Val} ohm / ${!Pdissip} watt] resistors in
stock.&rdquo;<br />
echo &ldquo;These are located in bin # ${!Loc}.&rdquo;<br />
echo &ldquo;Their color code is /&rdquo;${!Ccode}/&ldquo;.&rdquo;</p>

<p>break<br />
done</p>

<p>echo; echo</p>

<h1 id="练习-7">练习:</h1>

<h1 id="toc_729">&mdash;&ndash;</h1>

<h1 id="1-重写脚本-使其从外部文件读取数据">1) 重写脚本, 使其从外部文件读取数据.</h1>

<h1 id="2-重写脚本">2) 重写脚本,</h1>

<p>#+ 用数组来代替间接变量引用,</p>

<h1 id="因为使用数组更简单-更易懂">因为使用数组更简单, 更易懂.</h1>

<h1 id="注">注:</h1>

<h1 id="toc_734">&mdash;</h1>

<h1 id="除了最简单的数据库应用-事实上-shell脚本本身并不适合于数据库应用">除了最简单的数据库应用, 事实上, Shell脚本本身并不适合于数据库应用.</h1>

<p>#+ 因为它太依赖于工作环境和机器的运算能力.</p>

<h1 id="更好的办法还是使用支持数据结构的本地语言">更好的办法还是使用支持数据结构的本地语言,</h1>

<p>#+ 比如C++或者Java(或者甚至可以是Perl).</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;resistor-
inventory.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@restricted.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="脚本开头以-bin-bash-r-来调用">脚本开头以&rdquo;#!/bin/bash -r&rdquo;来调用,</h1>

<p>#+ 会使整个脚本在受限模式下运行.</p>

<p>echo</p>

<p>echo &ldquo;Changing directory.&rdquo;<br />
cd /usr/local<br />
echo &ldquo;Now in <code>pwd</code>&rdquo;<br />
echo &ldquo;Coming back home.&rdquo;<br />
cd<br />
echo &ldquo;Now in <code>pwd</code>&rdquo;<br />
echo</p>

<h1 id="非受限的模式下-所有操作都正常">非受限的模式下，所有操作都正常.</h1>

<p>set -r</p>

<h1 id="set-restricted-也具有相同的效果">set &ndash;restricted 也具有相同的效果.</h1>

<p>echo &ldquo;==&gt; Now in restricted mode. &lt;==&rdquo;</p>

<p>echo<br />
echo</p>

<p>echo &ldquo;Attempting directory change in restricted mode.&rdquo;<br />
cd ..<br />
echo &ldquo;Still in <code>pwd</code>&ldquo;</p>

<p>echo<br />
echo</p>

<p>echo &ldquo;/$SHELL = $SHELL&rdquo;<br />
echo &ldquo;Attempting to change shell in restricted mode.&rdquo;<br />
SHELL=&ldquo;/bin/ash&rdquo;<br />
echo<br />
echo &ldquo;/$SHELL= $SHELL&rdquo;</p>

<p>echo<br />
echo</p>

<p>echo &ldquo;Attempting to redirect output in restricted mode.&rdquo;<br />
ls -l /usr/bin &gt; bin.files<br />
ls -l bin.files # 尝试列出刚才创建的文件.</p>

<p>echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;restricted.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@return-
test.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="return-test-sh">return-test.sh</h1>

<h1 id="函数所能返回的最大正整数为255">函数所能返回的最大正整数为255.</h1>

<p>return_test () # 传给函数什么值, 就返回什么值.<br />
{<br />
return $1<br />
}</p>

<p>return_test 27 # o.k.<br />
echo $? # 返回27.</p>

<p>return_test 255 # 依然是o.k.<br />
echo $? # 返回255.</p>

<p>return_test 257 # 错误!<br />
echo $? # 返回1 (对应各种错误的返回码).</p>

<h1 id="toc_742">======================================================</h1>

<p>return_test -151896 # 能返回一个大负数么?<br />
echo $? # 能否返回-151896?</p>

<h1 id="显然不行-只返回了168">显然不行! 只返回了168.</h1>

<h1 id="bash-2-05b以前的版本">Bash 2.05b以前的版本</h1>

<p>#+ 允许返回大负数.</p>

<h1 id="bash的新版本-2-05b之后-修正了这个漏洞">Bash的新版本(2.05b之后)修正了这个漏洞.</h1>

<h1 id="这可能会影响以前所编写的脚本">这可能会影响以前所编写的脚本.</h1>

<h1 id="一定要小心">一定要小心!</h1>

<h1 id="toc_748">======================================================</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;return-
test.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@revposparams.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="revposparams-sh-反转位置参数">revposparams.sh: 反转位置参数.</h1>

<h1 id="本脚本由dan-jacobson所编写-本书作者做了一些格式上的修正">本脚本由Dan Jacobson所编写, 本书作者做了一些格式上的修正.</h1>

<p>set a/ b c d/ e;</p>

<h1 id="转义的空格">^ ^ 转义的空格</h1>

<h1 id="未转义的空格">^ ^ 未转义的空格</h1>

<p>OIFS=$IFS; IFS=:;</p>

<h1 id="保存旧的ifs-然后设置新的ifs">^ 保存旧的IFS, 然后设置新的IFS.</h1>

<p>echo</p>

<p>until [ $# -eq 0 ]<br />
do # 步进位置参数.<br />
echo &ldquo;### k0 = &ldquo;$k&rdquo;&rdquo; # 步进之前<br />
k=$1:$k; # 将每个位置参数都附加在循环变量的后边.</p>

<h1 id="toc_754">^</h1>

<p>echo &ldquo;### k = &ldquo;$k&rdquo;&rdquo; # 步进之后<br />
echo<br />
shift;<br />
done</p>

<p>set $k # 设置一个新的位置参数.<br />
echo -<br />
echo $# # 察看位置参数的个数.<br />
echo -<br />
echo</p>

<p>for i # 省略 &ldquo;in list&rdquo; 结构,<br />
#+ 为位置参数设置变量 &ndash; i &ndash;.<br />
do<br />
echo $i # 显示新的位置参数.<br />
done</p>

<p>IFS=$OIFS # 恢复 IFS.</p>

<h1 id="问题">问题:</h1>

<h1 id="是否有必要设置新的ifs-内部域分隔符">是否有必要设置新的IFS, 内部域分隔符,</h1>

<p>#+ 才能够让这个脚本正常运行? (译者注: 当然有必要.)</p>

<h1 id="如果你没设置新的ifs-会发生什么-试一下">如果你没设置新的IFS, 会发生什么? 试一下.</h1>

<h1 id="并且-在第17行-为什么新的ifs要使用-一个冒号">并且, 在第17行, 为什么新的IFS要使用 &ndash; 一个冒号 &ndash; ,</h1>

<p>#+ 来将位置参数附加到循环变量中?</p>

<h1 id="这么做的目的是什么">这么做的目的是什么?</h1>

<p>exit 0</p>

<p>$ ./revposparams.sh</p>

<h3 id="k0">k0 =</h3>

<h3 id="k-a-b">k = a b</h3>

<h3 id="k0-a-b">k0 = a b</h3>

<h3 id="k-c-a-b">k = c a b</h3>

<h3 id="k0-c-a-b">k0 = c a b</h3>

<h3 id="k-d-e-c-a-b">k = d e c a b</h3>

<ul>
<li>
3<br />
-</li>
</ul>

<p>d e<br />
c<br />
a b<br />
%%%&amp;&amp;&amp;revposparams.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@rfe.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="rfe-sh-修改文件扩展名">rfe.sh: 修改文件扩展名.</h1>

<h1 id="用法-rfe-old-extension-new-extension">用法: rfe old_extension new_extension</h1>

<h1 id="示例">示例:</h1>

<h1 id="将指定目录中所有的-gif文件都重命名为-jpg">将指定目录中所有的<em>.gif文件都重命名为</em>.jpg,</h1>

<h1 id="用法-rfe-gif-jpg">用法: rfe gif jpg</h1>

<p>E_BADARGS=65</p>

<p>case $# in<br />
0|1) # 竖线&rdquo;|&ldquo;在这里表示&rdquo;或&rdquo;操作.<br />
echo &ldquo;Usage: <code>basename $0</code> old_file_suffix new_file_suffix&rdquo;<br />
exit $E_BADARGS # 如果只有0个或1个参数的话, 那么就退出脚本.<br />
;;<br />
esac</p>

<p>for filename in *.$1</p>

<h1 id="以第一个参数为扩展名的全部文件的列表">以第一个参数为扩展名的全部文件的列表.</h1>

<p>do<br />
mv $filename ${filename%$1}$2</p>

<h1 id="把筛选出来的文件的扩展名去掉-因为筛选出来的文件的扩展名都是第一个参数">把筛选出来的文件的扩展名去掉, 因为筛选出来的文件的扩展名都是第一个参数,</h1>

<p>#+ 然后把第2个参数作为扩展名, 附加到这些文件的后边.<br />
done</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;rfe.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@rnd.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="rnd-sh-输出一个10进制随机数">rnd.sh: 输出一个10进制随机数</h1>

<h1 id="由stephane-chazelas所编写的这个脚本">由Stephane Chazelas所编写的这个脚本.</h1>

<p>head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &lsquo;1s/.* //p&rsquo;</p>

<h1 id="toc_775">===================================================================</h1>

<h1 id="分析">分析</h1>

<h1 id="toc_777">&mdash;-</h1>

<h1 id="head">head:</h1>

<h1 id="c4-选项将取得前4个字节">-c4 选项将取得前4个字节.</h1>

<h1 id="od">od:</h1>

<h1 id="n4-选项将限制输出为4个字节">-N4 选项将限制输出为4个字节.</h1>

<h1 id="tu4-选项将使用无符号10进制格式来输出">-tu4 选项将使用无符号10进制格式来输出.</h1>

<h1 id="sed">sed:</h1>

<h1 id="n-选项-使用-s-命令与-p-标志组合的方式">-n 选项, 使用&rdquo;s&rdquo;命令与&rdquo;p&rdquo;标志组合的方式,</h1>

<h1 id="将会只输出匹配的行">将会只输出匹配的行.</h1>

<h1 id="本脚本作者解释-sed-命令的行为如下">本脚本作者解释&rsquo;sed&rsquo;命令的行为如下.</h1>

<h1 id="head-c4-dev-urandom-od-n4-tu4-sed-ne-1s-p">head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &lsquo;1s/.* //p&rsquo;</h1>

<h1 id="toc_788">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&gt; |</h1>

<h1 id="假设一直处理到-sed-命令时的输出">假设一直处理到&rdquo;sed&rdquo;命令时的输出&ndash;&gt; |</h1>

<h1 id="为-0000000-1198195154-n">为 0000000 1198195154/n</h1>

<h1 id="sed命令开始读取字串-0000000-1198195154-n">sed命令开始读取字串: 0000000 1198195154/n.</h1>

<h1 id="这里它发现一个换行符">这里它发现一个换行符,</h1>

<p>#+ 所以sed准备处理第一行 (0000000 1198195154).</p>

<h1 id="sed命令开始匹配它的-range-和-action-第一个匹配的并且只有这一个匹配的">sed命令开始匹配它的<range>和<action>. 第一个匹配的并且只有这一个匹配的:</h1>

<h1 id="range-action">range action</h1>

<h1 id="1-s-p">1 s/.* //p</h1>

<h1 id="因为行号在range中-所以sed开始执行action">因为行号在range中, 所以sed开始执行action:</h1>

<p>#+ 替换掉以空格结束的最长的字符串, 在这行中这个字符串是</p>

<h1 id="0000000-用空字符串-将这个匹配到的字串替换掉-如果成功-那就打印出结果">(&ldquo;0000000 &ldquo;), 用空字符串(//)将这个匹配到的字串替换掉, 如果成功, 那就打印出结果</h1>

<h1 id="p-在这里是-s-命令的标志-这与单独的-p-命令是不同的">(&ldquo;p&rdquo;在这里是&rdquo;s&rdquo;命令的标志, 这与单独的&rdquo;p&rdquo;命令是不同的).</h1>

<h1 id="sed命令现在开始继续读取输入-注意在继续之前">sed命令现在开始继续读取输入. (注意在继续之前,</h1>

<p>#+ continuing, 如果没使用-n选项的话, sed命令将再次<br />
#+ 将这行打印一遍).</p>

<h1 id="现在-sed命令读取剩余的字符串-并且找到文件的结尾">现在, sed命令读取剩余的字符串, 并且找到文件的结尾.</h1>

<h1 id="sed命令开始处理第2行-这行也被标记为">sed命令开始处理第2行(这行也被标记为&rsquo;$&rsquo;</h1>

<h1 id="因为这已经是最后一行">因为这已经是最后一行).</h1>

<h1 id="所以这行没被匹配到-range-中-这样sed命令就结束了">所以这行没被匹配到<range>中, 这样sed命令就结束了.</h1>

<h1 id="这个sed命令的简短的解释是">这个sed命令的简短的解释是:</h1>

<h1 id="在第一行中删除第一个空格左边全部的字符">&ldquo;在第一行中删除第一个空格左边全部的字符,</h1>

<p>#+ 然后打印出来.&rdquo;</p>

<h1 id="一个更好的来达到这个目的的方法是">一个更好的来达到这个目的的方法是:</h1>

<h1 id="sed-e-s-q">sed -e &rsquo;s/.* //;q&rsquo;</h1>

<h1 id="这里-range-和-action-分别是-也可以写成">这里, <range>和<action>分别是(也可以写成</h1>

<h1 id="sed-e-s-e-q">sed -e &rsquo;s/.* //&rsquo; -e q):</h1>

<h1 id="range-action-1">range action</h1>

<h1 id="nothing-matches-line-s">nothing (matches line) s/.* //</h1>

<h1 id="nothing-matches-line-q-quit">nothing (matches line) q (quit)</h1>

<h1 id="这里-sed命令只会读取第一行的输入">这里, sed命令只会读取第一行的输入.</h1>

<h1 id="将会执行2个命令-并且会在退出之前打印出-已经替换过的-这行-因为-q-action">将会执行2个命令, 并且会在退出之前打印出(已经替换过的)这行(因为&rdquo;q&rdquo; action),</h1>

<p>#+ 因为没使用&rdquo;-n&rdquo;选项.</p>

<h1 id="toc_815">=================================================================== #</h1>

<h1 id="也可以使用如下一个更简单的语句来代替">也可以使用如下一个更简单的语句来代替:</h1>

<h1 id="head-c4-dev-urandom-od-an-tu4">head -c4 /dev/urandom| od -An -tu4</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;rnd.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@rn.sh@@@!!!</em></strong>*********************************************************************************<br />
#! /bin/bash</p>

<h1 id="very-simpleminded-filename-rename-utility-based-on-lowercase-sh">Very simpleminded filename &ldquo;rename&rdquo; utility (based on &ldquo;lowercase.sh&rdquo;).</h1>

<h1 id="the-ren-utility-by-vladimir-lanin-lanin-csd2-nyu-edu">The &ldquo;ren&rdquo; utility, by Vladimir Lanin (lanin@csd2.nyu.edu),</h1>

<p>#+ does a much better job of this.</p>

<p>ARGS=2<br />
E_BADARGS=65<br />
ONE=1 # For getting singular/plural right (see below).</p>

<p>if [ $# -ne &ldquo;$ARGS&rdquo; ]<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> old-pattern new-pattern&rdquo;</p>

<h1 id="as-in-rn-gif-jpg-which-renames-all-gif-files-in-working-directory-to-jpg">As in &ldquo;rn gif jpg&rdquo;, which renames all gif files in working directory to jpg.</h1>

<p>exit $E_BADARGS<br />
fi</p>

<p>number=0 # Keeps track of how many files actually renamed.</p>

<p>for filename in <em>$1</em> #Traverse all matching files in directory.<br />
do<br />
if [ -f &ldquo;$filename&rdquo; ] # If finds match&hellip;<br />
then<br />
fname=<code>basename $filename</code> # Strip off path.<br />
n=<code>echo $fname | sed -e &quot;s/$1/$2/&quot;</code> # Substitute new for old in filename.<br />
mv $fname $n # Rename.<br />
let &ldquo;number += 1&rdquo;<br />
fi<br />
done</p>

<p>if [ &ldquo;$number&rdquo; -eq &ldquo;$ONE&rdquo; ] # For correct grammar.<br />
then<br />
echo &ldquo;$number file renamed.&rdquo;<br />
else<br />
echo &ldquo;$number files renamed.&rdquo;<br />
fi</p>

<p>exit 0</p>

<h1 id="exercises">Exercises:</h1>

<h1 id="toc_822">&mdash;&mdash;&mdash;</h1>

<h1 id="what-type-of-files-will-this-not-work-on">What type of files will this not work on?</h1>

<h1 id="how-can-this-be-fixed">How can this be fixed?</h1>

<h1 id="rewrite-this-script-to-process-all-the-files-in-a-directory">Rewrite this script to process all the files in a directory</h1>

<p>#+ containing spaces in their names, and to rename them,<br />
#+ substituting an underscore for each space.<br />
%%%&amp;&amp;&amp;rn.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@rot13a.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="rot13a-sh-与-rot13-sh-脚本相同-但是会将输出写到-安全-文件中">rot13a.sh: 与&rdquo;rot13.sh&rdquo;脚本相同, 但是会将输出写到&rdquo;安全&rdquo;文件中.</h1>

<h1 id="用法-rot13a-sh-filename">用法: ./rot13a.sh filename</h1>

<h1 id="或-rot13a-sh-filename">或 ./rot13a.sh &lt;filename</h1>

<h1 id="或-rot13a-sh同时提供键盘输入-stdin">或 ./rot13a.sh同时提供键盘输入(stdin)</h1>

<p>umask 177 # 文件创建掩码.</p>

<h1 id="被这个脚本所创建的文件">被这个脚本所创建的文件</h1>

<p>#+ 将具有600权限.</p>

<p>OUTFILE=decrypted.txt # 结果保存在&rdquo;decrypted.txt&rdquo;中<br />
#+ 这个文件只能够被</p>

<h1 id="这个脚本的调用者-或者root-所读写">这个脚本的调用者(或者root)所读写.</h1>

<p>cat &ldquo;$@&rdquo; | tr &lsquo;a-zA-Z&rsquo; &lsquo;n-za-mN-ZA-M&rsquo; &gt; $OUTFILE</p>

<h1 id="从stdin-或文件中输入-输出重定向到文件中">^^ 从stdin 或文件中输入. ^^^^^^^^^^ 输出重定向到文件中.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;rot13a.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@rot13.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="rot13-sh-典型的rot13算法">rot13.sh: 典型的rot13算法,</h1>

<h1 id="使用这种方法加密至少可以愚弄一下3岁小孩">使用这种方法加密至少可以愚弄一下3岁小孩.</h1>

<h1 id="用法-rot13-sh-filename">用法: ./rot13.sh filename</h1>

<h1 id="或-rot13-sh-filename">或 ./rot13.sh &lt;filename</h1>

<h1 id="或-rot13-sh-and-supply-keyboard-input-stdin">或 ./rot13.sh and supply keyboard input (stdin)</h1>

<p>cat &ldquo;$@&rdquo; | tr &lsquo;a-zA-Z&rsquo; &lsquo;n-za-mN-ZA-M&rsquo; # &ldquo;a&rdquo;变为&rdquo;n&rdquo;, &ldquo;b&rdquo;变为&rdquo;o&rdquo;, 等等.</p>

<h1 id="cat-结构">&lsquo;cat &ldquo;$@&rdquo;&lsquo;结构</h1>

<p>#+ 允许从stdin或者从文件中获得输入.</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;rot13.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@rot14.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="使用-eval-的一个-rot13-的版本-译者-rot13就是把26个字母-从中间分为2半-各13个">使用&rsquo;eval&rsquo;的一个&rdquo;rot13&rdquo;的版本,(译者:rot13就是把26个字母,从中间分为2半,各13个).</h1>

<h1 id="与脚本-rot13-sh-比较一下">与脚本&rdquo;rot13.sh&rdquo; 比较一下.</h1>

<p>setvar_rot_13() # &ldquo;rot13&rdquo; 函数<br />
{<br />
local varname=$1 varvalue=$2<br />
eval $varname=&lsquo;$(echo &ldquo;$varvalue&rdquo; | tr a-z n-za-m)&rsquo;<br />
}</p>

<p>setvar_rot_13 var &ldquo;foobar&rdquo; # 将 &ldquo;foobar&rdquo; 传递到 rot13函数中.<br />
echo $var # sbbone</p>

<p>setvar_rot_13 var &ldquo;$var&rdquo; # 传递 &ldquo;sbbone&rdquo; 到rot13函数中.</p>

<h1 id="又变成了原始值">又变成了原始值.</h1>

<p>echo $var # foobar</p>

<h1 id="这个例子是segebart-chazelas编写的">这个例子是Segebart Chazelas编写的.</h1>

<h1 id="作者又修改了一下">作者又修改了一下.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;rot14.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@rpm-
check.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="rpm-check-sh">rpm-check.sh</h1>

<h1 id="这个脚本的目的是为了描述-列表-和确定是否可以安装一个rpm包">这个脚本的目的是为了描述, 列表, 和确定是否可以安装一个rpm包.</h1>

<h1 id="在一个文件中保存输出">在一个文件中保存输出.</h1>

<h1 id="这个脚本使用一个代码块来展示">这个脚本使用一个代码块来展示.</h1>

<p>SUCCESS=0<br />
E_NOARGS=65</p>

<p>if [ -z &ldquo;$1&rdquo; ]<br />
then<br />
echo &ldquo;Usage: <code>basename $0</code> rpm-file&rdquo;<br />
exit $E_NOARGS<br />
fi</p>

<p>{<br />
echo<br />
echo &ldquo;Archive Description:&rdquo;<br />
rpm -qpi $1 # 查询说明.<br />
echo<br />
echo &ldquo;Archive Listing:&rdquo;<br />
rpm -qpl $1 # 查询列表.<br />
echo<br />
rpm -i &ndash;test $1 # 查询rpm包是否可以被安装.<br />
if [ &ldquo;$?&rdquo; -eq $SUCCESS ]<br />
then<br />
echo &ldquo;$1 can be installed.&rdquo;<br />
else<br />
echo &ldquo;$1 cannot be installed.&rdquo;<br />
fi<br />
echo<br />
} &gt; &ldquo;$1.test&rdquo; # 把代码块中的所有输出都重定向到文件中.</p>

<p>echo &ldquo;Results of rpm test in file $1.test&rdquo;</p>

<h1 id="查看rpm的man页来查看rpm的选项">查看rpm的man页来查看rpm的选项.</h1>

<p>exit 0<br />
%%%&amp;&amp;&amp;rpm-
check.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@script-
array.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="script-array-sh-将这个脚本的内容赋值给数组">script-array.sh: 将这个脚本的内容赋值给数组.</h1>

<h1 id="这个脚本的灵感来自于chris-martin的e-mail-感谢">这个脚本的灵感来自于Chris Martin的e-mail(感谢!).</h1>

<p>script_contents=( $(cat &ldquo;$0&rdquo;) ) # 将这个脚本的内容($0)<br />
#+ 赋值给数组.</p>

<p>for element in $(seq 0 $((${#script_contents[@]} - 1)))<br />
do # ${#script_contents[@]}<br />
#+ 表示数组元素的个数.</p>

<h1 id="一个小问题">一个小问题:</h1>

<h1 id="为什么必须使用seq-0">为什么必须使用seq 0?</h1>

<h1 id="用seq-1来试一下">用seq 1来试一下.</h1>

<p>echo -n &ldquo;${script_contents[$element]}&rdquo;</p>

<h1 id="在同一行上显示脚本中每个域的内容">在同一行上显示脚本中每个域的内容.</h1>

<p>echo -n &ldquo; &ndash; &rdquo; # 使用 &ldquo; &ndash; &rdquo; 作为域分割符.<br />
done</p>

<p>echo</p>

<p>exit 0</p>

<h1 id="练习-8">练习:</h1>

<h1 id="toc_856">&mdash;&ndash;</h1>

<h1 id="修改这个脚本">修改这个脚本,</h1>

<p>#+ 让这个脚本能够按照它原本的格式输出,<br />
#+ 连同空白, 换行, 等等.<br />
%%%&amp;&amp;&amp;script-
array.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@script-
detector.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="script-detector-sh-在一个目录中检查所有的脚本文件">script-detector.sh: 在一个目录中检查所有的脚本文件.</h1>

<p>TESTCHARS=2 # 测试前两个字符.<br />
SHABANG=&lsquo;#!&rsquo; # 脚本都是以&rdquo;#!&ldquo;开头的.</p>

<p>for file in * # 遍历当前目录下的所有文件.<br />
do<br />
if [[ <code>head -c$TESTCHARS &quot;$file&quot;</code> = &ldquo;$SHABANG&rdquo; ]]</p>

<h1 id="head-c2">head -c2 #!</h1>

<h1 id="c-选项将从文件头输出指定个数的字符">&rsquo;-c&rsquo; 选项将从文件头输出指定个数的字符,</h1>

<p>#+ 而不是默认的行数.<br />
then<br />
echo &ldquo;File /&rdquo;$file/&rdquo; is a script.&rdquo;<br />
else<br />
echo &ldquo;File /&rdquo;$file/&rdquo; is <em>not</em> a script.&rdquo;<br />
fi<br />
done</p>

<p>exit 0</p>

<h1 id="练习-9">练习:</h1>

<h1 id="toc_862">&mdash;&ndash;</h1>

<h1 id="1-修改这个脚本">1) 修改这个脚本,</h1>

<p>#+ 让它可以指定扫描的路径.<br />
#+ (而不是只搜索当前目录).</p>

<h1 id="2-以这个脚本目前的状况-它不能正确识别出">2) 以这个脚本目前的状况, 它不能正确识别出</h1>

<p>#+ Perl, awk, 和其他一些脚本语言的脚本文件.</p>

<h1 id="修正这个问题">修正这个问题.</h1>

<p>%%%&amp;&amp;&amp;script-
detector.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@seconds.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<p>TIME_LIMIT=10<br />
INTERVAL=1</p>

<p>echo<br />
echo &ldquo;Hit Control-C to exit before $TIME_LIMIT seconds.&rdquo;<br />
echo</p>

<p>while [ &ldquo;$SECONDS&rdquo; -le &ldquo;$TIME_LIMIT&rdquo; ]<br />
do<br />
if [ &ldquo;$SECONDS&rdquo; -eq 1 ]<br />
then<br />
units=second<br />
else<br />
units=seconds<br />
fi</p>

<p>echo &ldquo;This script has been running $SECONDS $units.&rdquo;</p>

<h1 id="在一台比较慢或者是附载过大的机器上">在一台比较慢或者是附载过大的机器上,</h1>

<p>#+ 在单次循环中, 脚本可能会忽略计数.<br />
sleep $INTERVAL<br />
done</p>

<p>echo -e &ldquo;/a&rdquo; # Beep!(哔哔声!)</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;seconds.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@secret-
pw.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="secret-pw-sh-保护密码不被显示">secret-pw.sh: 保护密码不被显示</h1>

<p>echo<br />
echo -n &ldquo;Enter password &rdquo;<br />
read passwd<br />
echo &ldquo;password is $passwd&rdquo;<br />
echo -n &ldquo;If someone had been looking over your shoulder, &rdquo;<br />
echo &ldquo;your password would have been compromised.&rdquo;</p>

<p>echo &amp;&amp; echo # 在一个&rdquo;与列表&rdquo;中产生两个换行.</p>

<p>stty -echo # 关闭屏幕的echo.</p>

<p>echo -n &ldquo;Enter password again &rdquo;<br />
read passwd<br />
echo<br />
echo &ldquo;password is $passwd&rdquo;<br />
echo</p>

<p>stty echo # 恢复屏幕的echo.</p>

<p>exit 0</p>

<h1 id="详细的阅读stty命令的info页-以便于更好的掌握这个有用并且狡猾的工具">详细的阅读stty命令的info页, 以便于更好的掌握这个有用并且狡猾的工具.</h1>

<p>%%%&amp;&amp;&amp;secret-
pw.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

<p><strong><em>@@@seeding-
random.sh@@@!!!</em></strong>*********************************************************************************<br />
#!/bin/bash</p>

<h1 id="seeding-random-sh-设置random变量作为种子">seeding-random.sh: 设置RANDOM变量作为种子.</h1>

<p>MAXCOUNT=25 # 决定产生多少个随机数.</p>

<p>random_numbers ()<br />
{<br />
count=0<br />
while [ &ldquo;$count&rdquo; -lt &ldquo;$MAXCOUNT&rdquo; ]<br />
do<br />
number=$RANDOM<br />
echo -n &ldquo;$number &rdquo;<br />
let &ldquo;count += 1&rdquo;<br />
done<br />
}</p>

<p>echo; echo</p>

<p>RANDOM=1 # 为随机数的产生来设置RANDOM种子.<br />
random_numbers</p>

<p>echo; echo</p>

<p>RANDOM=1 # 设置同样的种子&hellip;<br />
random_numbers # &hellip;将会和上边产生的随机序列相同.</p>

<h1 id="复制一个相同的-随机-序列在什么情况下有用呢">复制一个相同的&rdquo;随机&rdquo;序列在什么情况下有用呢?</h1>

<p>echo; echo</p>

<p>RANDOM=2 # 在试一次, 但是这次使用不同的种子&hellip;<br />
random_numbers # 这次将得到一个不同的随机序列.</p>

<p>echo; echo</p>

<h1 id="random-使用脚本的进程id来作为产生随机数的种子">RANDOM=$$ 使用脚本的进程ID来作为产生随机数的种子.</h1>

<h1 id="从-time-或-date-命令中取得random作为种子也是常用的做法">从 &lsquo;time&rsquo; 或 &lsquo;date&rsquo; 命令中取得RANDOM作为种子也是常用的做法.</h1>

<h1 id="一个很有想象力的方法">一个很有想象力的方法&hellip;</h1>

<p>SEED=$(head -1 /dev/urandom | od -N 1 | awk &lsquo;{ print $2 }&rsquo;)</p>

<h1 id="首先从-dev-urandom-系统伪随机设备文件-中取出一行">首先从/dev/urandom(系统伪随机设备文件)中取出一行,</h1>

<p>#+ 然后将这个可打印行转换为8进制数, 使用&rdquo;od&rdquo;命令来转换.<br />
#+ 最后使用&rdquo;awk&rdquo;来获得一个数,<br />
#+ 这个数将作为产生随机数的种子.<br />
RANDOM=$SEED<br />
random_numbers</p>

<p>echo; echo</p>

<p>exit 0<br />
%%%&amp;&amp;&amp;seeding-
random.sh&amp;&amp;&amp;%%%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>