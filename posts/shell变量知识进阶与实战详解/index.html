<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell变量知识进阶与实战详解 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell变量知识进阶与实战详解 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell变量知识进阶与实战详解">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E5%8F%98%E9%87%8F%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell变量知识进阶与实战详解</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="shell中特殊位置且重要的变量"><strong>Shell中特殊位置且重要的变量</strong></h1>

<p>###</p>

<hr />

<p><strong>在shell中存在一些特殊且重要的变量，例如：$0/$1/$#,我们称之为特殊位置参数变量。要从命令行、函数或脚本执行等处传递参数</strong></p>

<p><strong>时，就需要在shell脚本中使用位置参数变量。</strong></p>

<p><strong>以下 表格为常用的特殊位置参数变量的说明：</strong></p>

<hr />

<table>
<thead>
<tr>
<th>位置变量</th>
<th>作用说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>$0</strong></td>
<td><strong>获取当前执行的shell脚本的文件名，如果执行脚本包含了路径，那么就包括脚本路径</strong></td>
</tr>
</tbody>
</table>

<p><strong>$n</strong> |
<strong>获取当前执行的shell脚本的第n个参数值，n=1..9，当n为0时表示脚本的文件名；如果n大于9，则用大括号括起来，例如${10}，接的参数以空格隔开</strong><br />
<strong>$#</strong> | <strong>获取当前执行的shell脚本后面接的参数的总个数</strong><br />
<strong>$</strong>* |
<strong>获取当前shell脚本所有传参的参数，不加引号和$@相同；如果给$<em>加上双引号，例如：&rdquo;$</em>&ldquo;，则表示将所有的参数视为单个字符串，相当于&rdquo;$1,$2,$3&rdquo;</strong><br />
<strong>$@</strong> |
<strong>获取当前shell脚本所有传参的参数，不加引号和$<em>相同；如果给$@加上双引号，例如：&rdquo;$@&ldquo;，则表示将所有的参数视为不同的独立字符串，相当于&rdquo;$1&rdquo;
&ldquo;$2&rdquo; &ldquo;$3&rdquo; &ldquo;&hellip;&rdquo;
。这是将多参数传递给其他程序的最佳方式，因为它会保留所有的内嵌在每个参数里的任何空白。当&rdquo;$@&ldquo;和&rdquo;$</em>&ldquo;都加双引号时，两者是有区别的；都不加双引号时，两者无区别</strong></p>

<h3 id="1-1-2-9-10-11-特殊变量实践"><strong>1.$1 $2&hellip;$9 ${10}${11}..特殊变量实践</strong></h3>

<hr />

<p><strong>编写如下的a.sh脚本，输入内容为&rdquo;echo $1&rdquo;,并执行测试</strong></p>

<pre><code>[root@kang ~]# cat a.sh 
#!/bin/bash
echo $1
[root@kang ~]# sh a.sh blxh
blxh
[root@kang ~]# sh a.sh blxh girl
blxh
[root@kang ~]# sh a.sh &quot;blxh girl&quot;
blxh girl
[root@kang ~]#
</code></pre>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# cat a.sh 
#!/bin/bash
echo $1 #&lt;==脚本功能是打印脚本传递的第一个参数的值
[root@kang ~]# sh a.sh blxh #&lt;==传入一个blxh字符串参数，赋值给脚本中的$1.
blxh &lt;==把传入的blxh参数赋值给脚本中的$1并输出，因此输出结果为blxh。
[root@kang ~]# sh a.sh blxh girl &lt;==传入两个字符串参数，但脚本不会接收第二个参数，参数默认是以空格分隔。
blxh &lt;==只输出了blxh，因为脚本里没有加入$2，因此，无法接收第二个参数girl字符串。
[root@kang ~]# sh a.sh &quot;blxh girl&quot; &lt;==加双引号括起来的内容传参，会作为一个字符串参数。
blxh girl &lt;==虽然打印了，但是这些内容是作为一个参数传递给$1的。
[root@kang ~]# 
</code></pre>

<p><strong>在脚本中同时加入$1和$2，并进行测试。</strong></p>

<p><a href="https://img.it610.com/image/info8/bfaf578993bb4236bbd719e5f1ea33dd.jpg"><img src="https://img.it610.com/image/info8/bfaf578993bb4236bbd719e5f1ea33dd.jpg" alt="" /></a></p>

<pre><code>[root@kang ~]# sh a.sh chenglong bingbing #
</code></pre>

<p><a href="https://img.it610.com/image/info8/6f8dd866b25d4543a0db379d6f793e26.jpg"><img src="https://img.it610.com/image/info8/6f8dd866b25d4543a0db379d6f793e26.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第1张图片" /></a></p>

<hr />

<p><strong>设置15个位置参数（$1~$15），用于接收命令行传递的15个参数。</strong></p>

<p><a href="https://img.it610.com/image/info8/dd63302b104b4006aefffe1aa34eed9e.jpg"><img src="https://img.it610.com/image/info8/dd63302b104b4006aefffe1aa34eed9e.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo \${1..15} &lt;==利用大括号输出15个位置参数，学会了该命令就不用手敲代码了
$1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15
[root@kang ~]# echo \${1..15} &gt;n.sh &lt;==利用大括号输出15个位置参数并定向到文件n.sh里面
[root@kang ~]# cat n.sh 
$1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 #&lt;==增加echo命令打印所有参数，这是最终的测试代码，前面的都是为了写代码，读者也可以用vim编辑录入
[root@kang ~]# echo  {a..z} #&lt;==测试打印26个字母a~z并以空格分隔
a b c d e f g h i j k l m n o p q r s t u v w x y z
</code></pre>

<p><strong>以下是有关$1,$2,$3&hellip;.这些位置参数的系统生产场景案例。对此，读者可以多参考rpcbind、NFS两个软件启动脚本，这两个服务的启动脚本简单、规范。若是最下化安装的系统，则表示没有安装rpcbind、NFS，可以通过执行以下命令去安装：</strong></p>

<pre><code>[root@kang ~]# yum -y install nfs-utils rpcbind
</code></pre>

<p><strong>在生产场景中，执行如下命令后</strong></p>

<pre><code>/etc/init.d/rpcbind
</code></pre>

<p><strong>rpcbind脚本后携带的start参数会传给脚本里的$1进行判断，脚本中传递参数的关键case语句节选如下：</strong></p>

<pre><code>case &quot;$1&quot; in #&lt;==这里的$1用于接收执行此脚本命令行的第一个参数，规范用法是用双引号引起来。
   start) #&lt;==如果$1接收的值匹配start，则执行下文的start函数及内部的指令。
       start #&lt;==调用脚本中的start函数
       RETEVAL=$? #&lt;==这里是记录start函数执行的返回值，$?也是重要的变量，暂时可以忽略，后面有介绍。
     ;;
   stop) #&lt;==如果$1接收的值匹配stop,则执行下文的stop函数及内部的指令
      stop
      RETEVAL=$?
     ;;
   status)#&lt;==如果$1接收的值匹配status，则执行下文的status函数及内部的指令。
      status $prog
      RETEVAL=$?
     ;;
   ...省略部分内容
</code></pre>

<hr />

<h3 id="2-0特殊变量的作用及变量的实践"><strong>2.$0特殊变量的作用及变量的实践</strong></h3>

<hr />

<p><strong>$0的作用为取出执行脚本的名称（包括路径），下面是该功能的实践</strong></p>

<p><strong>获取脚本的名称及路径：</strong></p>

<p><a href="https://img.it610.com/image/info8/1f920c98ae064d33829ed79853bea864.jpg"><img src="https://img.it610.com/image/info8/1f920c98ae064d33829ed79853bea864.jpg" alt="" /></a></p>

<p><strong>如上图所示，若不带路径执行脚本，那么输出结果就是脚本的名字，如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/0203460d13ba43e59a8d573fd0bfdded.jpg"><img src="https://img.it610.com/image/info8/0203460d13ba43e59a8d573fd0bfdded.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# sh a.sh 
a.sh #&lt;==$0获取的值就是脚本的名字，因此这里输出了a.sh
[root@kang ~]#
</code></pre>

<p><strong>若使用全路径执行脚本，那么输出结果就是全路径加上脚本的名字，如下图所示：</strong></p>

<p><a href="https://img.it610.com/image/info8/a8d7c0c620c14eff8717667bab30c909.jpg"><img src="https://img.it610.com/image/info8/a8d7c0c620c14eff8717667bab30c909.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# sh /root/a.sh 
/root/a.sh #&lt;==如果执行的脚本中带有路径，那么$0获取的值就是脚本的名字加路径
[root@kang ~]# 
</code></pre>

<p><strong>当要执行的脚本为全路径时，$0也会带着路径。此时如果希望单独获取名称或路径，则可用以下示例：</strong></p>

<p><a href="https://img.it610.com/image/info8/a85e9b1c8f0a469da813fc645ae38f8a.jpg"><img src="https://img.it610.com/image/info8/a85e9b1c8f0a469da813fc645ae38f8a.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第2张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# dirname  /root/a.sh 
/root #&lt;==dirname命令的作用是获取脚本的路径
[root@kang ~]# basename /root/a.sh 
a.sh  #&lt;==basename命令的作用是获取脚本的名字
[root@kang ~]# 
</code></pre>

<blockquote>
<p><strong>提示：读者可以根据需求，用不同的命令获取对应的结果。</strong></p>
</blockquote>

<hr />

<p><strong>利用$0和上述命令（dirname、basename）分别取出脚本名称和脚本路径</strong></p>

<p><a href="https://img.it610.com/image/info8/407b182d60e14daeb45f93e4151860db.jpg"><img src="https://img.it610.com/image/info8/407b182d60e14daeb45f93e4151860db.jpg" alt="" /></a><a href="https://img.it610.com/image/info8/8f46d76ea5db4dfeade07803c3aaeab0.jpg"><img src="https://img.it610.com/image/info8/8f46d76ea5db4dfeade07803c3aaeab0.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# sh /root/a.sh 
/root #&lt;==这就是dirname $0的输出结果
a.sh  #&lt;==这就是basename $0的输出结果
[root@kang ~]# 
</code></pre>

<p><strong>有关$0这个位置参数的系统生产场景案例如下，其中采用的是network系统脚本。</strong></p>

<p><a href="https://img.it610.com/image/info8/591b2ba1ce704430a0e50903d9f05594.jpg"><img src="https://img.it610.com/image/info8/591b2ba1ce704430a0e50903d9f05594.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第3张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# tail -6 /etc/init.d/network 
*)
    echo $&quot;Usage: $0 {start|stop|status|restart|force-reload}&quot; #&lt;==$0的基本生产场景就是，当用户输入不符合脚本的要求时，就打印脚本的名字及使用帮助
    exit 2
esac

exit $rc
[root@kang ~]# /etc/init.d/network #&lt;==不带任何参数执行network脚本
Usage: /etc/init.d/network {start|stop|status|restart|force-reload} #&lt;==/etc/init.d/network就是$0从脚本命令行获取的值，当用户输入不符合脚本设定的要求时，打印脚本名字及预期的使用帮助
[root@kang ~]# 
</code></pre>

<h3 id="3-特殊变量获取脚本传参个数的实践"><strong>3.$#特殊变量获取脚本传参个数的实践</strong></h3>

<hr />

<p><strong>通过$#获取脚本传参的个数</strong></p>

<p><a href="https://img.it610.com/image/info8/310edac977e44f458a4bb4957a834ca0.jpg"><img src="https://img.it610.com/image/info8/310edac977e44f458a4bb4957a834ca0.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/30341f1bfb6c43c8885da4add8043b02.jpg"><img src="https://img.it610.com/image/info8/30341f1bfb6c43c8885da4add8043b02.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第4张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# cat a.sh 
#!/bin/bash
echo $1 $2 $3 $4 $5 $6 $7 $8 $9 
echo $# #&lt;==此行是打印脚本命令行传参的个数
[root@kang ~]# sh a.sh  {a..z} #&lt;==传入26个字符作为26个参数
a b c d e f g h i  #&lt;==只接收了9个变量，所以打印9个字符
26 #&lt;==传入26个字符作为26个参数，因此这里的数字为26，说明传入了26个参数
[root@kang ~]#
</code></pre>

<p><strong>根据用户在命令行的传参个数判断用户的输入，不合要求的给予提示并退出。</strong></p>

<p><strong>这是一个针对$0、$1、$#等多位置参数的综合型企业案例。</strong></p>

<p><strong>首先来看看条件表达式判断语句的写法，如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/d17cba23f8e24c86a22922571abd9e8a.jpg"><img src="https://img.it610.com/image/info8/d17cba23f8e24c86a22922571abd9e8a.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第5张图片" /></a></p>

<p><strong>执行结果：</strong></p>

<p><a href="https://img.it610.com/image/info8/28e1fd670d4049dc97a1fd6168c28e91.jpg"><img src="https://img.it610.com/image/info8/28e1fd670d4049dc97a1fd6168c28e91.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第6张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# sh a.sh arg1 
muse two args #&lt;==如果传入的参数不够，即不符合要求，则直接给出提示
[root@kang ~]# sh a.sh arg1 arg2
blxh  #&lt;==当参数满足要求后，打印blxh的字符串
[root@kang ~]# 
</code></pre>

<p><strong>然后是if判断语句的写法，如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/13b026108597405cae9b2f8214ac7f20.jpg"><img src="https://img.it610.com/image/info8/13b026108597405cae9b2f8214ac7f20.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第7张图片" /></a></p>

<p><strong>实现效果如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/706baf87480842f389c774056df8218d.jpg"><img src="https://img.it610.com/image/info8/706baf87480842f389c774056df8218d.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# sh a.sh arg1 #&lt;==若传参的个数不够两位，则直接给出提示。
USAGE:/bin/sh a.sh arg1 arg2 #&lt;==a.sh就是脚本中$0获取的值
[root@kang ~]# sh a.sh arg1 arg2
arg1 arg2  #&lt;==若参数满足要求，则打印$1和$2获取的字符串，即arg1和arg2
[root@kang ~]# 
</code></pre>

<p><strong>4.$*和$@特别变量功能及区别说明</strong></p>

<p><strong>上面的表格已经列举出了$*和$@的区别以及作用，再来看看示例如下：</strong></p>

<p><strong>利用set设置位置参数（同命令行脚本的传参）</strong></p>

<p><a href="https://img.it610.com/image/info8/239c01b382ff424c8c40ea1578039439.jpg"><img src="https://img.it610.com/image/info8/239c01b382ff424c8c40ea1578039439.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第8张图片" /></a></p>

<p><strong>测试$*和$@,注意，此时不带双引号：</strong></p>

<p><a href="https://img.it610.com/image/info8/e513f9518ef1415db9be5ef66f623dd5.jpg"><img src="https://img.it610.com/image/info8/e513f9518ef1415db9be5ef66f623dd5.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第9张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo $*
I am handsome blxh.
[root@kang ~]# echo $@
I am handsome blxh.
[root@kang ~]# for i in $*;do echo $i;done
I
am
handsome
blxh.
[root@kang ~]# for i in $@;do echo $i;done #&lt;==使用for循环输出$*测试。
I #&lt;==($*)不加双引号，因此会输出所有参数，然后第一个参数&quot;I am&quot;也拆开输出了
am
handsome
blxh.
[root@kang ~]#
</code></pre>

<p><strong>测试&rdquo;$*&ldquo;和&rdquo;$@&ldquo;，注意，此时带有双引号：</strong></p>

<p><a href="https://img.it610.com/image/info8/c97ed70e491f4a9c9bc79b4b74869d69.jpg"><img src="https://img.it610.com/image/info8/c97ed70e491f4a9c9bc79b4b74869d69.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第10张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo &quot;$*&quot;
I am handsome blxh.
[root@kang ~]# echo &quot;$@&quot;
I am handsome blxh.
[root@kang ~]# for i in &quot;$*&quot;;do echo $i;done #&lt;==在有双引号的情况下&quot;$*&quot;,参数里引号中的内容当作一个参数输出了！
I am handsome blxh.
[root@kang ~]# for i in &quot;$@&quot;;do echo $i;done #&lt;==在有双引号的情况下，每个参数均以独立的内容输出。
I am #&lt;==有双引号算一个参数
handsome
blxh. #&lt;==这才真正符合我们传入的参数需求，set -- &quot;I am&quot; handsome blxh.
[root@kang ~]# for i;do echo $i;done  #&lt;==去掉in 变量列表，相当于有引号的in &quot;$@&quot;。
I am
handsome
blxh.  #&lt;==这才真正符合我们传入的参数需求，set -- &quot;I am&quot; handsome blxh.
[root@kang ~]# for i in $*;do echo $i;done #&lt;==($*)不加双引号，因此会输出所有参数，然后第一个参数&quot;I am&quot;也拆开输出了。
am
handsome
blxh. 
[root@kang ~]# shift #&lt;==用shift将位置参数移位（左移）
[root@kang ~]# echo $#
2
[root@kang ~]# echo $1 #&lt;==这里就打印原来$2的值了
handsome
[root@kang ~]# echo $2 #&lt;==这里就打印原来$3的值了
blxh.
</code></pre>

<blockquote>
<p><strong>提示：有关set和eval的使用可以查看man帮助手册</strong></p>
</blockquote>

<h1 id="shell进程中的特殊状态变量"><strong>shell进程中的特殊状态变量</strong></h1>

<hr />

<table>
<thead>
<tr>
<th>位置变量</th>
<th>作用说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>$?</strong></td>
<td><strong>获取执行上一个指令的执行状态返回值（0为成功，非零为失败），这个变量最常用</strong></td>
</tr>

<tr>
<td><strong>$$</strong></td>
<td><strong>获取当前执行的shell脚本的进程号（PID），这个变量不常用，了解即可</strong></td>
</tr>

<tr>
<td><strong>$!</strong></td>
<td><strong>获取上一个在后台工作的进程号（PID），这个变量不常用，了解即可</strong></td>
</tr>

<tr>
<td><strong>$_</strong></td>
<td><strong>获取在此之前执行的命令或脚本的最后一个参数，这个变量不常用，了解即可</strong></td>
</tr>
</tbody>
</table>

<blockquote>
<p><strong>提示：查找上述知识的方法为使用man bash命令，然后搜索关键字“Special Parameters”。</strong></p>
</blockquote>

<hr />

<h3 id="1-特殊变量功能实践"><strong>1.$?特殊变量功能实践</strong></h3>

<p><strong>执行命令后获取返回值（切换到kangshuo用户进行测试）。</strong></p>

<p><a href="https://img.it610.com/image/info8/69aa36357d2a445cbb7805445d2e76c4.jpg"><img src="https://img.it610.com/image/info8/69aa36357d2a445cbb7805445d2e76c4.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第11张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# pwd #&lt;==执行pwd命令，然后用echo $?查看执行命令的状态返回值。
/root
[root@kang ~]# echo $? 
0 #&lt;==返回0，表示上一个命令的执行是成功的
[root@kang ~]# su kangshuo
[kangshuo@kang root]$ ls /root #&lt;==列表root目录的内容
ls: 无法打开目录/root: 权限不够  
[kangshuo@kang root]$ echo $?
2 #&lt;==返回值为非0，表示上一个命令(ls /root)执行错误。注意：对于不同的错误，返回值是不同的。
[kangshuo@kang root]$ rm -rf /root #&lt;==删除/root目录及其子目录
rm: 无法删除&quot;/root&quot;: 权限不够
[kangshuo@kang root]$ echo $?
1 #&lt;==返回值为1(非0)。
[kangshuo@kang root]$ blxh  #&lt;==执行一个不存在的命令
bash: blxh: 未找到命令...
[kangshuo@kang root]$ echo $?
127 #&lt;==返回值为127(非0)。
[kangshuo@kang root]$ 
</code></pre>

<p><strong>不同命令的执行结果中，$?的返回值不尽相同，但在工作场景中，常用的就是0和非0两种状态，0表示成功运行，非0表示运行失败。</strong></p>

<p><strong>根据返回值来判断软件的安装是否成功。例如简单安装Apache服务如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/a119a0bff3034ea7a027a13db5a64f3f.jpg"><img src="https://img.it610.com/image/info8/a119a0bff3034ea7a027a13db5a64f3f.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第12张图片" /></a></p>

<p><strong>在企业场景下，$?返回值的用法如下：</strong></p>

<p><strong>判断命令、脚本或函数等程序是否执行成功。</strong></p>

<p><strong>若在脚本中调用执行exit数字，则会返回这个数字给$?变量</strong></p>

<p><strong>如果是在函数里，则通过return数字把这个数字以函数返回值的形式传给$?</strong></p>

<hr />

<h3 id="2-特殊变量功能及实践"><strong>2.$$特殊变量功能及实践</strong></h3>

<p><strong>获取脚本执行的进程号（PID）</strong></p>

<p><a href="https://img.it610.com/image/info8/9cfa43d295ad4204845c525eb30ae019.jpg"><img src="https://img.it610.com/image/info8/9cfa43d295ad4204845c525eb30ae019.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/53ac4d1bdbc8437ebaef929aecd3c3b4.jpg"><img src="https://img.it610.com/image/info8/53ac4d1bdbc8437ebaef929aecd3c3b4.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第13张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# cat a.sh #&lt;==编写一个简单的脚本
#!/bin/bash
echo $$ &gt;/tmp/a.pid  #&lt;==获取$$的值，并重定向到/tmp/a.pid里。
sleep 300 #&lt;==休息300秒，模拟守护进程不退出
[root@kang ~]# ps -ef | grep a.sh | grep -v grep
[root@kang ~]# sh a.sh &amp;  #&lt;==在后台运行脚本，&amp;符号表示在后台运行。
[1] 9139 #&lt;==这是脚本的进程号。
[root@kang ~]# ps -ef | grep a.sh | grep -v grep
root       9139   8777  0 14:30 pts/0    00:00:00 sh a.sh #&lt;==这是脚本的进程号
[root@kang ~]# cat /tmp/a.pid 
9139  #&lt;==这是$$对应的值。
[root@kang ~]#
</code></pre>

<blockquote>
<p><strong>提示：到这里大家应该明白了吧，$$就是获取当前执行的Shell脚本的进程号。</strong></p>
</blockquote>

<p><strong>实现系统中多次执行某一个脚本后的进程只有一个（此为$$的企业级应用）</strong></p>

<p><strong>说明：有时执行定时任务脚本的频率比较快，并不知道上一个脚本是否真的执行完毕，但是，业务要求同一时刻只能有一个同样的脚本在运行，此时就可以利用$$获取上一次运行的脚本进程号，当程序重新运行时，根据获得的进程号，清理掉上一次的进程，运行新的脚本命令，脚本如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/c8ce48d772fd4f98850dcf89e6c9a459.jpg"><img src="https://img.it610.com/image/info8/c8ce48d772fd4f98850dcf89e6c9a459.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第14张图片" /></a></p>

<p><strong>执行结果如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/5e438b4f4a5f4a8bb9e75b4defc8f972.jpg"><img src="https://img.it610.com/image/info8/5e438b4f4a5f4a8bb9e75b4defc8f972.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第15张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# ps -ef | grep pid.sh | grep -v grep
[root@kang ~]# sh pid.sh &amp; #&lt;==后台运行脚本
[1] 9400
[root@kang ~]# ps -ef | grep pid.sh | grep -v grep #&lt;==查看启动的脚本进程
root       9400   8777  0 14:50 pts/0    00:00:00 sh pid.sh #&lt;==只有一个进程
[root@kang ~]# sh pid.sh &amp; #&lt;==多次运行脚本，每次都会将上一次运行的杀掉
[2] 9415
[root@kang ~]# sh pid.sh &amp; #&lt;==多次运行脚本，每次都会将上一次运行的杀掉
[3] 9419
[1]   已终止               sh pid.sh
[root@kang ~]# sh pid.sh &amp;
[4] 9423
[2]   已终止               sh pid.sh
[root@kang ~]# ps -ef | grep pid.sh | grep -v grep
root       9423   8777  0 14:51 pts/0    00:00:00 sh pid.sh  #&lt;==发现无论运行多少次脚本，都只有一个进程。
[3]-  已终止               sh pid.sh
[root@kang ~]# 
</code></pre>

<hr />

<blockquote>
<p><strong>提示：这是一个生产案例的简单模拟，脚本用于执行启动或定时任务时，相同的脚本中只能有一个在运行，当新脚本运行时，必须关闭未运行完或未退出的上一次的同名脚本进程。</strong></p>
</blockquote>

<h3 id="3-特殊变量功能说明及实践"><strong>3.$_特殊变量功能说明及实践</strong></h3>

<p><strong>$_的作用是获得上一条命令的最后一个参数值，此功能用得不多，了解即可。</strong></p>

<p><a href="https://img.it610.com/image/info8/9e73ca44a3884e23a9a535e6824ad3fe.jpg"><img src="https://img.it610.com/image/info8/9e73ca44a3884e23a9a535e6824ad3fe.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# /etc/init.d/network start blxh
Starting network (via systemctl):                          [  确定  ]
[root@kang ~]# echo $_  #&lt;==打印上一条命令的最后一个参数值，即blxh
blxh
[root@kang ~]# 
</code></pre>

<h3 id="4-特殊变量功能说明及实践"><strong>4.$!特殊变量功能说明及实践</strong></h3>

<p><strong>$!的功能类似于$$,只不过作用是获取上一次执行脚本的pid，对此，了解即可。</strong></p>

<p><a href="https://img.it610.com/image/info8/d9f353edef074b5bbd63e92a75375e76.jpg"><img src="https://img.it610.com/image/info8/d9f353edef074b5bbd63e92a75375e76.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第16张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# ps -ef | grep pid.sh | grep -v grep
[root@kang ~]# sh pid.sh &amp;  #&lt;==后台运行pid.sh脚本
[1] 13716
[root@kang ~]# echo $! #&lt;==获取前一次执行脚本pid.sh的进程号
13716
[root@kang ~]# ps -ef | grep pid.sh | grep -v grep
root      13716  13572  0 21:26 pts/1    00:00:00 sh pid.sh
[root@kang ~]#
</code></pre>

<hr />

<h1 id="bash-shell内置变量命令"><strong>bash Shell内置变量命令</strong></h1>

<p><strong>bash shell
包含一些内置命令。这些内置命令在目录列表里是看不见的，它们由shell本身提供。常用的内部命令有：echo、eval、exec、export、read、shift，下面简单介绍几个最常用的内置命令的格式和功能。</strong></p>

<hr />

<h3 id="1-echo在屏幕上输出信息"><strong>（1.）echo在屏幕上输出信息</strong></h3>

<blockquote>
<p><strong>命令格式：echo args # &lt;==可以是字符串和变量的组合</strong></p>

<p><strong>功能说明：将echo命令后面args指定的字符串及变量等显示到标准输出</strong></p>
</blockquote>

<table>
<thead>
<tr>
<th><strong>echo参数选项</strong></th>
<th><strong>说 明</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>-n</strong></td>
<td><strong>不换行输出内容</strong></td>
</tr>

<tr>
<td><strong>-e</strong></td>
<td><strong>解析转义字符（见下面的字符）</strong></td>
</tr>

<tr>
<td><strong>转义字符：</strong></td>
<td></td>
</tr>

<tr>
<td><strong>\n</strong></td>
<td></td>
</tr>
</tbody>
</table>

<p><strong>换行</strong></p>

<p><strong>\r</strong> | <strong>回车</strong><br />
<strong>\t</strong> | <strong>制表符（tab）</strong><br />
<strong>\b</strong> | <strong>退格</strong><br />
<strong>\v</strong> | <strong>纵向制表符</strong></p>

<hr />

<p><strong>echo示例如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/e93551a9d282426cace35e2b8498aad9.jpg"><img src="https://img.it610.com/image/info8/e93551a9d282426cace35e2b8498aad9.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第17张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo -e
&quot;blxh\tchenglong\tzhangmanyu\nlinqingxia\twangzuxian\tqiushuzhen\t&quot; #&lt;==加上-e解析以\开头的字符。
blxh    chenglong       zhangmanyu
linqingxia      wangzuxian      qiushuzhen
[root@kang ~]# echo blxh;echo girl
blxh
girl
[root@kang ~]# echo -n blxh;echo girl #&lt;==不换行输出
blxhgirl
[root@kang ~]# echo &quot;blxh\tzhouxingchi\ngirl\tzhangxueyou&quot;
blxh\tzhouxingchi\ngirl\tzhangxueyou
[root@kang ~]# printf &quot;blxh\tgirl\nblxh\tgirl\n&quot; #&lt;==printf的转义字符能力与echo类似。
blxh    girl
blxh    girl
[root@kang ~]# echo -e &quot;1\b23&quot; #&lt;==加上-e解析以\开头的字符，\b退格。
23
[root@kang ~]# printf &quot;1\b23\n&quot; #&lt;==printf的转义字符功能与echo类似。
23
[root@kang ~]# 
</code></pre>

<blockquote>
<p><strong>提示：printf与echo的功能类似，但是printf更强大，当需要特殊复杂的格式时才考虑使用printf。</strong></p>
</blockquote>

<hr />

<h3 id="2-eval"><strong>（2.）eval</strong></h3>

<blockquote>
<p><strong>命令格式：eval args</strong></p>

<p><strong>功能：当shell程序执行到eval语句时，shell读入参数args，并将它们组合成一个新的命令，然后执行。</strong></p>
</blockquote>

<p><strong>set和eval命令的使用 （含特殊位置变量用法）方法。</strong></p>

<p><a href="https://img.it610.com/image/info8/3e348ea814ef4e508b3b6879f15f6152.jpg"><img src="https://img.it610.com/image/info8/3e348ea814ef4e508b3b6879f15f6152.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/1db468c6afac4235ba05fefd49706f04.jpg"><img src="https://img.it610.com/image/info8/1db468c6afac4235ba05fefd49706f04.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/3051361e24414c8b91dc3a3e15edddba.jpg"><img src="https://img.it610.com/image/info8/3051361e24414c8b91dc3a3e15edddba.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第18张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# cat noeval.sh 
echo \$$# #&lt;==$#表示传参的个数。

[root@kang ~]# sh noeval.sh arg1 arg2 #&lt;==传入两个参数。
$2 #&lt;==传入两个参数，因此$#为2，于是echo \$$#就变成了echo $2,最后输出$2，并没有打印arg2.
[root@kang ~]# cat eval.sh 
#!/bin/bash
eval &quot;echo \$$# &quot;  #&lt;==加上eval命令，使得打印的特殊位置参数，重新解析输出，而不是输出$2本身。
[root@kang ~]# sh eval.sh arg1 arg2
arg2 #&lt;==输出了$2.
[root@kang ~]# 
</code></pre>

<h3 id="3-exec"><strong>（3.）exec</strong></h3>

<blockquote>
<p><strong>命令格式：exec命令参数</strong></p>

<p><strong>功能：exec命令能够在不创建新的子进程的前提下，转去执行指定的命令，当指定的命令执行完毕后，该进程（也就是最初的Shell）就终止了。</strong></p>
</blockquote>

<p><strong>示例如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/a173ad18e27c491c9922af7fc2a46c1b.jpg"><img src="https://img.it610.com/image/info8/a173ad18e27c491c9922af7fc2a46c1b.jpg" alt="" /></a></p>

<p><strong>当使用exec打开文件后，read命令每次都会将文件指针移动到文件的下一行进行读取，直到文件末尾，利用这个可以实现处理文件内容。</strong></p>

<p><strong>exec的功能示例如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/47a254f2c4844371a22534d783db02d5.jpg"><img src="https://img.it610.com/image/info8/47a254f2c4844371a22534d783db02d5.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第19张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/cfaf6c4d6cb34c64b2626f8e631775c4.jpg"><img src="https://img.it610.com/image/info8/cfaf6c4d6cb34c64b2626f8e631775c4.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第20张图片" /></a></p>

<p><strong>执行结果如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/10db8601ba27469f86138271ea25c5d6.jpg"><img src="https://img.it610.com/image/info8/10db8601ba27469f86138271ea25c5d6.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第21张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# seq 5 &gt;/tmp/tmp.log 
[root@kang ~]# cat exe.sh 
#!/bin/bash
exec &lt; /tmp/tmp.log #&lt;==读取log内容
while read line     #&lt;==利用read一行行读取处理
do
  echo $line        #&lt;==打印输出
done
echo ok
</code></pre>

<hr />

<h3 id="4-read"><strong>（4.）read</strong></h3>

<blockquote>
<p><strong>命令格式：read 变量名表</strong></p>

<p><strong>功能：从标准输入读取字符串等信息，传给Shell程序内部定义的变量。</strong></p>
</blockquote>

<p><strong>例如：</strong></p>

<p><a href="https://img.it610.com/image/info8/a7ba2debf7eb4bb6bc6c972243abcb2e.jpg"><img src="https://img.it610.com/image/info8/a7ba2debf7eb4bb6bc6c972243abcb2e.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第22张图片" /></a></p>

<h3 id="5-shift"><strong>（5.）shift</strong></h3>

<blockquote>
<p><strong>命令格式：shift-Shift positional parameters</strong></p>

<p><strong>功能：shift语句会按如下方式重新命名所有的位置参数变量，即$2成为$1、$3成为$2等，以此类推，在程序中每使用一次shift语句，都会使所有的位置参数依次向左移动一个位置，并使位置参数$#减1，直到减到0为止。</strong></p>
</blockquote>

<p><strong>shift命令的使用示例如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/850e1a6621ac4dd6802c5ca6e7136e20.jpg"><img src="https://img.it610.com/image/info8/850e1a6621ac4dd6802c5ca6e7136e20.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第23张图片" /></a></p>

<p><strong>执行效果如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/40d14a2fd3d34f058a495d222b0db632.jpg"><img src="https://img.it610.com/image/info8/40d14a2fd3d34f058a495d222b0db632.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# cat n.sh 
#!/bin/bash
echo $1 $2
if [ $# -eq 2 ];then
   shift 
   echo $1
fi

[root@kang ~]# sh n.sh  1 2
1 2  #&lt;==这是echo $1 $2 的结果。
2    #&lt;==这里是echo $1的结果，但是输出的是传参时$2的值。
</code></pre>

<p><strong>当我们写Shell希望像命令行的命令通过参数控制不同的功能时，就会先传一个类似-c的参数，然后再接内容。</strong></p>

<p><a href="https://img.it610.com/image/info8/6923016cae3e48098c68ad52300485b0.jpg"><img src="https://img.it610.com/image/info8/6923016cae3e48098c68ad52300485b0.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# sh n.sh -c blxh
-c blxh  #&lt;==对应$1 $2 的输出。
blxh   #&lt;==对应$1的输出，因为执行了shift，因此第二个参数$2的内容，就变成了$1,所以输出了blxh。
[root@kang ~]# 
</code></pre>

<h3 id="6-exit"><strong>（6.）exit</strong></h3>

<blockquote>
<p><strong>命令格式：exit-Exit the shell</strong></p>

<p><strong>功能：退出shell程序。在exit之后可以有选择地指定一个数位作为返回状态。</strong></p>
</blockquote>

<hr />

<h1 id="shell变量子串知识及实践"><strong>Shell变量子串知识及实践</strong></h1>

<hr />

<p><strong>Shell变量子串的常用操作如下表：</strong></p>

<table>
<thead>
<tr>
<th>ID</th>
<th><strong>表达式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td><strong>${parameter}</strong></td>
<td><strong>返回变量$parameter的内容</strong></td>
</tr>

<tr>
<td>2</td>
<td><strong>${#parameter}</strong></td>
<td><strong>返回变量$parameter内容的长度(按字符)，也适用于特殊变量</strong></td>
</tr>

<tr>
<td>3</td>
<td><strong>${parameter:offset}</strong></td>
<td><strong>在变量${parameter}中，从位置offset之后开始提前子串到结尾</strong></td>
</tr>

<tr>
<td>4</td>
<td><strong>${parameter:offset:length}</strong></td>
<td></td>
</tr>
</tbody>
</table>

<p><strong>在变量${parameter}中，从位置offset之后开始提取长度为length的子串</strong><br />
5 | <strong>${parameter#word}</strong> | <strong>从变量${parameter}开头开始删除最短匹配的Word子串</strong><br />
6 | <strong>${parameter##word}</strong> | <strong>从变量${parameter}开头开始删除最长匹配的Word子串</strong><br />
7 | <strong>${parameter%word}</strong> | <strong>从变量${parameter}结尾开始删除最短匹配的Word子串</strong><br />
8 | <strong>${parameter%%word}</strong> | <strong>从变量${parameter}结尾开始删除最长匹配的Word子串</strong><br />
9 | <strong>${parameter/pattern/string}</strong> | <strong>使用string代替第一个匹配的pattern</strong><br />
10 | <strong>${parameter//pattern/string}</strong> |</p>

<p><strong>使用string代替所有匹配的pattern</strong></p>

<hr />

<p><strong>定义BLXH的变量，赋值内容为“I am blxh”，操作代码如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/23e82ce5acb44fd18274f4db100f6cd5.jpg"><img src="https://img.it610.com/image/info8/23e82ce5acb44fd18274f4db100f6cd5.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# BLXH=&quot;I am blxh&quot; #&lt;==这里的BLXH变量，就是上表中parameter变量的具体示例
[root@kang ~]# echo ${BLXH}  #&lt;==带大括号打印变量BLXH
I am blxh
[root@kang ~]# echo $BLXH   #&lt;==直接打印变量BLXH
I am blxh
[root@kang ~]# 
</code></pre>

<p><strong>返回BLXH变量值的长度</strong></p>

<p><strong>通过在变量名前加#，就可以打印变量值的长度：</strong></p>

<p><a href="https://img.it610.com/image/info8/7708c4f9b6e74e6ca90a3c7f54b6099d.jpg"><img src="https://img.it610.com/image/info8/7708c4f9b6e74e6ca90a3c7f54b6099d.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo ${#BLXH}
9  #&lt;==I am blxh.这些字符加起来正好是9
[root@kang ~]#
</code></pre>

<p><strong>Shell的其他打印变量长度的方法，代码如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/3249628372b7497bb1d3d3af783509ba.jpg"><img src="https://img.it610.com/image/info8/3249628372b7497bb1d3d3af783509ba.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第24张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo $BLXH | wc -L #&lt;==输出变量值，然后通过管道交给wc计算长度。
9
[root@kang ~]# expr length &quot;$BLXH&quot;  #&lt;==利用expr的length函数计算变量长度。
9
[root@kang ~]# echo &quot;$BLXH&quot; | awk '{print length($0)}' #&lt;==利用awk的length函数计算变量长度，也可无“($0)”这几个字符。
9
[root@kang ~]# 
</code></pre>

<blockquote>
<p><strong>提示：上述计算变量长度的方法中，变量的字符串方式是最快的，即${#BLXH}的方式。</strong></p>
</blockquote>

<p><strong>利用 time命令及for循环对几种获取字符串长度的方法进行性能比较。</strong></p>

<h3 id="char">**（1.）变量自带的获取长度的方法（echo $</h3>

<p>）**</p>

<p><a href="https://img.it610.com/image/info8/75635068bcdc410ca18ad62004eddf4e.jpg"><img src="https://img.it610.com/image/info8/75635068bcdc410ca18ad62004eddf4e.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第25张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# time for n in {1..10000};do char=`seq -s &quot;blxh&quot; 100`;echo ${#char} &amp;&gt;/dev/null;done

real    0m17.025s #&lt;==变量自带的获取长度的方法用时最少，效率最高。
user    0m9.333s
sys     0m7.589s
[root@kang ~]# 
</code></pre>

<h3 id="2-利用管道加wc的方法-echo-char-wc-l"><strong>（2.）利用管道加wc的方法（echo${char}|wc -L）</strong></h3>

<p><a href="https://img.it610.com/image/info8/ea74f75bff8346608840cab8ec9bff56.jpg"><img src="https://img.it610.com/image/info8/ea74f75bff8346608840cab8ec9bff56.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# time for n in {1..10000};do char=`seq -s &quot;blxh&quot; 100`;echo ${char}|wc -L &amp;&gt;/dev/null;done

real    0m57.814s #&lt;==使用了管道加wc -L计算，结果倒数第二，仅次于管道加awk统计的。
user    0m31.108s
sys     0m26.424s
[root@kang ~]# 
</code></pre>

<h3 id="3-利用expr自带的length方法-expr-length-char"><strong>（3.）利用expr自带的length方法（expr length &ldquo;${char}&ldquo;）</strong></h3>

<p><a href="https://img.it610.com/image/info8/2568cca92a88484abb3582a3b2d18895.jpg"><img src="https://img.it610.com/image/info8/2568cca92a88484abb3582a3b2d18895.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# time for n in {1..10000};do char=`seq -s &quot;blxh&quot; 100`;expr length &quot;${char}&quot; &amp;&gt;/dev/null;done   
real    0m35.742s  #&lt;==好于使用管道和wc的计算方法，但是比变量自带的获取长度方法要差一些。
user    0m12.893s
sys     0m22.637s
[root@kang ~]# 
</code></pre>

<h3 id="4-利用awk自带的length函数方法"><strong>（4.）利用awk自带的length函数方法</strong></h3>

<p><a href="https://img.it610.com/image/info8/eb050c8f39b74f40bcce46dcd682c498.jpg"><img src="https://img.it610.com/image/info8/eb050c8f39b74f40bcce46dcd682c498.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第26张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# time for n in {1..10000};do char=`seq -s &quot;blxh&quot; 100`;echo $char | awk '{print length($0)}' &amp;&gt;/dev/null;done

real    1m4.938s  #&lt;==使用了管道还有awk的函数计算，结果最差。
user    0m27.496s
sys     0m37.082s
[root@kang ~]#
</code></pre>

<p><strong>可以看到，这几种方法的速度相差几十到上百倍，一般情况下调用外部命令来处理的方式与使用内置操作的速度相差较大。在shell编程中，应尽量使用内置操作或函数来完成。</strong></p>

<hr />

<p><strong>截取BLXH变量的内容，从第2个字符之后开始截取，默认截取后面字符的全部，第2个字符不包含在内，也可以理解为删除前面的多个字符。</strong></p>

<p><a href="https://img.it610.com/image/info8/6e8ae3281cb34adc807d422f3f067461.jpg"><img src="https://img.it610.com/image/info8/6e8ae3281cb34adc807d422f3f067461.jpg" alt="" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo ${BLXH}
I am blxh
[root@kang ~]# echo ${BLXH:2}
am blxh #&lt;==相当于从I后面的空格开始计算，截取到了结尾。
[root@kang ~]# 
</code></pre>

<p><strong>截取BLXH变量的内容，从第2个字符之后开始截取，截取2个字符。</strong></p>

<p><a href="https://img.it610.com/image/info8/e6e06dde0fab4a42bc5f253e5fef0dae.jpg"><img src="https://img.it610.com/image/info8/e6e06dde0fab4a42bc5f253e5fef0dae.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第27张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo ${BLXH:2:2}
am
提示：这个功能类似于cut命令-c参数的功能
[root@kang ~]# echo ${BLXH}|cut -c 3-4 #&lt;==输出变量的内容，管道交给cut截取第3~4个位置的字符。
am
[root@kang ~]# 
</code></pre>

<p><strong>从变量$BLXH内容的开头开始删除最短匹配“a*C”及“a*c”的子串。</strong></p>

<p><a href="https://img.it610.com/image/info8/e7dfe3cdaad148feba768ad2f2d5927a.jpg"><img src="https://img.it610.com/image/info8/e7dfe3cdaad148feba768ad2f2d5927a.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第28张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# BLXH=abcABC123ABCabc
[root@kang ~]# echo $BLXH
abcABC123ABCabc 
[root@kang ~]# echo ${BLXH#a*C} #&lt;==从开头开始删除最短匹配“a*C”的子串
123ABCabc  #&lt;==从开头开始删除了abcABC
[root@kang ~]# echo ${BLXH#a*c}  #&lt;==从开头开始删除最短匹配“a*c”的子串
ABC123ABCabc #&lt;==从开头开始删除了abc
[root@kang ~]# 
</code></pre>

<p><strong>从变量$BLXH开头开始删除最长匹配“a*C”及“a*c”的子串。</strong></p>

<p><a href="https://img.it610.com/image/info8/7b09399f84304058a82e4508eea258ca.jpg"><img src="https://img.it610.com/image/info8/7b09399f84304058a82e4508eea258ca.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第29张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# BLXH=abcABC123ABCabc
[root@kang ~]# echo $BLXH          
abcABC123ABCabc
[root@kang ~]# echo ${BLXH##a*c} #&lt;==从开头开始删除最长匹配“a*c”的子串
                    #&lt;==结果为空了，说明都匹配了，全部删除了。
[root@kang ~]# echo ${BLXH##a*C} #&lt;==从开头开始删除最长匹配“a*C”的子串
abc   #&lt;==结果为abc，说明匹配了ABCABC123ABC并删除了这些字符。
[root@kang ~]# 
</code></pre>

<p><strong>从变量$BLXH结尾开始删除最短匹配“a*C”及“a*c”的子串</strong></p>

<p><a href="https://img.it610.com/image/info8/134fc83f1357433b8341b5b90628affc.jpg"><img src="https://img.it610.com/image/info8/134fc83f1357433b8341b5b90628affc.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第30张图片" /></a></p>

<p>解释：</p>

<pre><code>[root@kang ~]# BLXH=abcABC123ABCabc
[root@kang ~]# echo $BLXH          
abcABC123ABCabc
[root@kang ~]# echo ${BLXH%a*C} #&lt;==从结尾开始删除最短匹配“a*C”的子串。
abcABC123ABCabc #&lt;==原样输出，因为从结尾开始a*C没有匹配上任何子串，因此，没有删除任何字符。
[root@kang ~]# echo ${BLXH%a*c} #&lt;==从结尾开始删除最短匹配“a*c”的子串。
abcABC123ABC  #&lt;==从结尾开始删除最短匹配“a*c”，即删除了结尾的abc三个字符。
[root@kang ~]# 
</code></pre>

<p><strong>从变量$BLXH结尾开始删除最长匹配“a*C”及“a*c”的子串。</strong></p>

<p><a href="https://img.it610.com/image/info8/7a5cb66034ec48ebb3decf2ac297248a.jpg"><img src="https://img.it610.com/image/info8/7a5cb66034ec48ebb3decf2ac297248a.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第31张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# BLXH=abcABC123ABCabc
[root@kang ~]# echo $BLXH
abcABC123ABCabc
[root@kang ~]# echo ${BLXH%%a*C} #&lt;==从结尾开始删除最长匹配“a*C”的子串。
abcABC123ABCabc #&lt;==原样输出，因为从结尾开始“a*C”没有匹配上任何子串，因此，没有删除任何字符。
[root@kang ~]# echo ${BLXH%%a*c} #&lt;==从结尾开始删除最长匹配“a*c”的子串。
              #&lt;==从结尾开始删除最长匹配“a*c”的字符串，即删除全部字符。
[root@kang ~]# 
</code></pre>

<blockquote>
<ul>
<li><strong>有关上述匹配删除的小结：</strong></li>
<li><strong>#：表示从开头删除匹配最短</strong></li>
<li><strong>##：表示从开头删除匹配最长</strong></li>
<li><strong>%：表示从结尾删除匹配最短</strong></li>
<li><strong>%%：表示从结尾删除匹配最长</strong></li>
<li>*<strong>：表示匹配所有</strong></li>
</ul>
</blockquote>

<hr />

<p><strong>使用girl字符串代替变量$BLXH匹配的blxh字符串。</strong></p>

<p><a href="https://img.it610.com/image/info8/00458a1bfe704418b8580f7b63498eeb.jpg"><img src="https://img.it610.com/image/info8/00458a1bfe704418b8580f7b63498eeb.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第32张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# BLXH=&quot;I am blxh,yes,blxh&quot;
[root@kang ~]# echo $BLXH
I am blxh,yes,blxh
[root@kang ~]# echo ${BLXH/blxh/girl} #&lt;==替换匹配的第一个字符串。
I am girl,yes,blxh #&lt;==真的只替换了第一个。
[root@kang ~]# echo ${BLXH//blxh/girl} #&lt;==替换匹配的所有字符串。
I am girl,yes,girl  #&lt;==真的替换了所有匹配blxh的字符串。
[root@kang ~]# 
</code></pre>

<blockquote>
<p><strong>提示：</strong></p>

<p><strong>一个“/“表示替换匹配的第一个字符串。</strong></p>

<p><strong>两个“/”表示替换匹配的所有字符串。</strong></p>
</blockquote>

<hr />

<h3 id="变量子串的生产场景应用案例"><strong>变量子串的生产场景应用案例：</strong></h3>

<p><strong>去掉下面所有文件的文件名中的 “_finished”字符串。</strong></p>

<p><a href="https://img.it610.com/image/info8/82294f7ea44a46d09e1aa5e3cb3ce0ad.jpg"><img src="https://img.it610.com/image/info8/82294f7ea44a46d09e1aa5e3cb3ce0ad.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第33张图片" /></a></p>

<p><strong>要想批量改名，首先得知道单个的文件应如何改名。单个文件的改名命令为：</strong></p>

<pre><code>[root@kang ~]# mv stu_102999_1_finished.jpg stu_102999_1.jpg
</code></pre>

<p><strong>下面利用 变量赋值和替换的方式实现上述mv命令的改名要求。</strong></p>

<p><a href="https://img.it610.com/image/info8/17dc63880d454ef782ed0a87f8bbf78d.jpg"><img src="https://img.it610.com/image/info8/17dc63880d454ef782ed0a87f8bbf78d.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第34张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# f=stu_102999_1_finished.jpg #&lt;==取一个文件名赋值给变量f，这个就是要修改的源文件
[root@kang ~]# echo ${f//_finished/} #&lt;==利用变量的子串替换功能把变量f里的_finished替换为空。
stu_102999_1.jpg
[root@kang ~]# mv $f `echo ${f//_finished/}` #&lt;==使用mv命令执行修改操作，注意目标命令要用反引号括起来。
[root@kang ~]# ls -l *.jpg
-rw-------. 1 root root 51 3月  17 12:06 stu_102999_1.jpg  #&lt;==改过后的结果
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_2_finished.jpg
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_3_finished.jpg
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_4_finished.jpg
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_5_finished.jpg
[root@kang ~]# 
</code></pre>

<p><strong>学会处理了一个，就可以进行批量处理了，批量处理就是利用循环而已。</strong></p>

<pre><code>[root@kang ~]# for f in `ls *fin*.jpg`;do mv $f `echo ${f//_finished/}`;done
</code></pre>

<p><a href="https://img.it610.com/image/info8/4df4413d8f484ad489e7ed1816312515.jpg"><img src="https://img.it610.com/image/info8/4df4413d8f484ad489e7ed1816312515.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第35张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# for f in `ls *fin*.jpg`;do mv $f `echo ${f//_finished/}`;done  
#&lt;==其实就是使用for循环，循环上面是进行单个处理的mv命令。mv $f `echo ${f//_finished/}`
[root@kang ~]# ls -l *.jpg
-rw-------. 1 root root 51 3月  17 12:06 stu_102999_1.jpg
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_2.jpg
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_3.jpg
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_4.jpg
-rw-------. 1 root root 51 4月  10 10:01 stu_102999_5.jpg
[root@kang ~]# 
</code></pre>

<hr />

<h1 id="shell特殊扩展变量的知识与实践"><strong>Shell特殊扩展变量的知识与实践</strong></h1>

<hr />

<p><strong>shell的特殊扩展变量说明见下表，读者可执行man bash命令，然后搜索“Parameter Expansion”查找相关的帮助内容。</strong></p>

<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>${parameter:-word}</strong></td>
<td></td>
</tr>
</tbody>
</table>

<p><strong>如果parameter的变量值为空或未赋值，则会返回Word字符串并替代变量的值。用途：如果变量未定义，则返回备用的值，防止变量为空值或因未定义而导致异常</strong></p>

<p><strong>${parameter:=word}</strong> |
<strong>如果parameter的变量值为空或未赋值，则设置这个变量值为Word，并返回其值。位置变量和特殊变量不适用。用途：用于捕捉由于变量未定义而导致的错误，并退出程序。</strong><br />
<strong>${parameter:?word}</strong> |</p>

<p><strong>如果parameter变量值为空或未赋值，那么Word字符串将被作为标准错误输出，否则输出变量的值。</strong></p>

<p><strong>用途：用于捕捉由于变量未定义而导致的错误，并退出程序。</strong></p>

<p><strong>${parameter:+Word}</strong> | <strong>如果parameter变量值为空或未赋值，则什么都不做，否则Word字符串将替代变量的值</strong></p>

<hr />

<blockquote>
<p><strong>提示：每个表达式内的冒号都是可选的，如果省略了表达式中的冒号，则将每个定义中的“为空或未赋值”部分改为“未赋值”，也就是说，运算符仅用于测试变量是否未赋值。更多内容，请执行man
bash命令查看帮助。</strong></p>
</blockquote>

<hr />

<h1 id="shell特殊扩展变量的实践"><strong>Shell特殊扩展变量的实践</strong></h1>

<hr />

<h3 id="1-parameter-word-功能实践"><strong>1.${parameter:-word}功能实践</strong></h3>

<blockquote>
<p><strong>提示：${parameter:-word}的作用是如果parameter变量值为空或未赋值，则会返回Word字符串替代变量的值。</strong></p>
</blockquote>

<p><strong>${parameter:-word}用法功能示例：</strong></p>

<p><a href="https://img.it610.com/image/info8/0bac2950842c497d8c52e4de412c967e.jpg"><img src="https://img.it610.com/image/info8/0bac2950842c497d8c52e4de412c967e.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第36张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# echo $test #&lt;==变量未设置，所以输出时为空。

[root@kang ~]# result=${test:-UNSET} #&lt;==若test没值，则返回UNSET
[root@kang ~]# echo $result #&lt;==打印result变量，返回UNSET，因为test没有赋值。
UNSET
[root@kang ~]# echo ${test} #&lt;==注意，此时打印test变量还是为空

[root@kang ~]# 
</code></pre>

<blockquote>
<p><strong>结论：对于${test:-UNSET}，当test变量没值时，就返回变量结尾设置的UNSET字符串。</strong></p>
</blockquote>

<p><a href="https://img.it610.com/image/info8/42a4151b3cd54dceb6acbef6c0747867.jpg"><img src="https://img.it610.com/image/info8/42a4151b3cd54dceb6acbef6c0747867.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第37张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# test=blxh #&lt;==给test变量赋值blxh字符串
[root@kang ~]# echo $test
blxh
[root@kang ~]# result=${test:-UNSET}  #&lt;==重新定义result
[root@kang ~]# echo $result
blxh  #&lt;==因为test已经赋值，因此，打印result就输出了test的值blxh，而不是原来的UNSET
提示：这个变量的功能可以用来判断变量是否已定义
[root@kang ~]# result=${test-UNSET} #&lt;==定义时忽略了冒号
[root@kang ~]# echo $result
blxh #&lt;==打印结果和带冒号时没有变化
[root@kang ~]# 
</code></pre>

<blockquote>
<p><strong>结论：当test变量有值时，就打印result变量，返回test变量的内容。</strong></p>
</blockquote>

<h3 id="2-parameter-word-功能实践"><strong>2.${parameter:=word}功能实践</strong></h3>

<blockquote>
<p><strong>${parameter:=word}的作用是：如果parameter变量值为空或未赋值，就设置这个变量值为Word，并返回其值。位置变量和特殊变量不适用。</strong></p>
</blockquote>

<p><strong>${parameter:=word}用法功能示例</strong></p>

<p><a href="https://img.it610.com/image/info8/8c713b9626354bdc9eb924e62df2cb4f.jpg"><img src="https://img.it610.com/image/info8/8c713b9626354bdc9eb924e62df2cb4f.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第38张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# unset result #&lt;==撤销result变量定义
[root@kang ~]# echo $result

[root@kang ~]# unset test  #&lt;==撤销test变量定义
[root@kang ~]# echo $test

[root@kang ~]# result=${test:=UNSET} #&lt;==重新对变量result进行定义
[root@kang ~]# echo $result
UNSET
[root@kang ~]# echo $test  #&lt;==注意，这里的test原来是没有定义的，现在已经被赋值UNSET了，这是和“:-”表达式的区别。
UNSET
[root@kang ~]# result=${test=UNSET} #&lt;==定义时忽略了冒号
[root@kang ~]# echo $result
UNSET  #&lt;==打印结果和带冒号时没有变化
[root@kang ~]# echo $test
UNSET  #&lt;==打印结果和带冒号时没有变化
[root@kang ~]# 
</code></pre>

<p><strong>当变量（result）值里的变量（test）值没有定义时，会给变量（result）赋值“:=”后面的内容（UNSET），同时会把“:=”后面</strong></p>

<p><strong>的内容（UNSET）赋值给变量（result）值里没有定义的变量（test）。</strong></p>

<p><strong>这个变量的功能可以解决变量定义的问题，并确保没有定义的变量始终有值。</strong></p>

<hr />

<h3 id="3-parameter-word-功能实践"><strong>3.${parameter:?word}功能实践</strong></h3>

<blockquote>
<p><strong>${parameter:?word}的作用是：如果parameter变量值为空或未赋值，那么Word字符串将被作为标准错误输出，否则输出变量的值。</strong></p>
</blockquote>

<p><strong>${parameter:?word}用法功能示例</strong></p>

<p><a href="https://img.it610.com/image/info8/9a06ebebb50848b88a34a2b2feedbdaa.jpg"><img src="https://img.it610.com/image/info8/9a06ebebb50848b88a34a2b2feedbdaa.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第39张图片" /></a></p>

<p>解释：</p>

<pre><code>[root@kang ~]# echo ${key:?not defined} #&lt;==key变量没有定义，因此把“not defined”作为标准错误输出。
-bash: key: not defined #&lt;==错误提示，只不过是事先定义好的错误输出。
[root@kang ~]# echo ${key?not defined}  #&lt;==去掉冒号定义，并输出，结果一致。
-bash: key: not defined
[root@kang ~]# key=1 #&lt;==给变量赋值1. 
[root@kang ~]# echo ${key:?not defined} #&lt;==因为key有值了，所以，打印key的值1.
1
[root@kang ~]# echo ${key?not defined} #&lt;==去掉冒号定义，并输出，结果一致。
1
[root@kang ~]# unset key #&lt;==取消key的定义。
[root@kang ~]# echo ${key:?not defined}
-bash: key: not defined #&lt;==又打印错误提示了。
[root@kang ~]# 
</code></pre>

<p><strong>这个功能可以用于设定由于变量未定义而报错的具体内容，如：“not defined”。</strong></p>

<h3 id="4-parameter-word-功能实践"><strong>4.${parameter:+word}功能实践</strong></h3>

<blockquote>
<p><strong>${parameter:+word}的作用是：如果parameter变量值为空或未赋值，则什么都不做，否则Word字符串将替代变量的值。</strong></p>
</blockquote>

<p><strong>${parameter:+word}用法功能示例</strong></p>

<p><a href="https://img.it610.com/image/info8/cd26b522b74d45ef8aee39680150a95f.jpg"><img src="https://img.it610.com/image/info8/cd26b522b74d45ef8aee39680150a95f.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第40张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# blxh=${girl:+word} #&lt;==girl变量未定义
[root@kang ~]# echo $blxh #&lt;==因为girl变量未定义，所以打印blxh变量为空

[root@kang ~]# girl=19 #&lt;==girl变量赋值为19
[root@kang ~]# blxh=${girl:+word} #&lt;==注意，这里一定要重新定义blxh
[root@kang ~]# echo $blxh 
word #&lt;==因为girl变量有值，所以打印blxh变量输出为“:+”后面的内容。
[root@kang ~]# 
</code></pre>

<p><strong>这个功能可用于测试变量（girl的位置）是否存在，如果blxh的值为Word，则证明blxh变量有值。</strong></p>

<hr />

<h1 id="shell特殊扩展变量的生产场景应用案例"><strong>Shell特殊扩展变量的生产场景应用案例</strong></h1>

<hr />

<p><strong>实现Apache服务启动脚本/etc/init.d/httpd(请重点看标记部分)</strong></p>

<p><a href="https://img.it610.com/image/info8/c293cba2d14d4aecad8920a53bc39249.jpg"><img src="https://img.it610.com/image/info8/c293cba2d14d4aecad8920a53bc39249.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第41张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>#       8 - configuration syntax error
#
# When multiple arguments are given, only the error from the _last_
# one is reported.  Run &quot;apachectl help&quot; for usage info
#
ACMD=&quot;$1&quot;
ARGV=&quot;$@&quot;
#
# |||||||||||||||||||| START CONFIGURATION SECTION  ||||||||||||||||||||
# --------------------                              --------------------
# 
# the path to your httpd binary, including options if necessary
HTTPD='/usr/sbin/httpd'
HTTPD_LANG=${HTTPD_LANG-&quot;C&quot;} #&lt;==如果HTTPD_LANG变量没有定义或为空，则打印HTTPD_LANG变量返回C值。
#&lt;==这一步定义方法的目的是防止变量值为空或未定义。使用的是(${parameter-word}用法，此处省略了冒号)。
#
#
# a command that outputs a formatted text version of the HTML at the
# url given on the command line.  Designed for lynx, however other
# programs may work.  
if [ -x &quot;/usr/bin/links&quot; ]; then
  LYNX=&quot;/usr/bin/links -dump&quot;
else
  LYNX=none
fi
#
httpd=${HTTPD-/usr/sbin/httpd} 
#&lt;==如果HTTPD变量没有定义或为空，则打印HTTPD_LANG变量返回/usr/sbin/httpd的值。
#&lt;==此步定义方法的目的是防止变量值为空或未定义。使用的是(${parameter-Word}用法，冒号省略了)。
# the URL to your server's mod_status status page.  If you do not
# have one, then status and fullstatus will not work.
STATUSURL=&quot;http://localhost:80/server-status&quot;

# Source /etc/sysconfig/httpd for $HTTPD setting, etc.
if [ -r /etc/sysconfig/httpd ]; then
   . /etc/sysconfig/httpd
fi

#
</code></pre>

<blockquote>
<p><strong>提示：通过执行yum -y install httpd后可以查看/etc/init.d/httpd文件。</strong></p>
</blockquote>

<p><strong>在企业中，针对目录路径等的处理就可以采用上述变量不存在（即赋值指定）的方式，防止因目录路径不存在而导致的异常。</strong></p>

<p><strong>例如：变量如果为NULL或没有定义，则赋予一个备用的值，特别是针对变量的删除操作，这种方式会很有用，否则删除的变量</strong></p>

<p><strong>如果不存在，则可能导致未知的危险。</strong></p>

<hr />

<p><strong>删除7天前的过期数据备份</strong></p>

<p><strong>如果忘记了定义path变量，又不希望path值为空值，就可以定义/tmp替代path空值的返回值，如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/c098bf9686134071b85a2be9da4456ff.jpg"><img src="https://img.it610.com/image/info8/c098bf9686134071b85a2be9da4456ff.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/ceea36f791ab46bbb35dbfdf67237f59.jpg"><img src="https://img.it610.com/image/info8/ceea36f791ab46bbb35dbfdf67237f59.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第42张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# cat del.sh 
#!/bin/bash
find ${path-/tmp} -name &quot;*.tar.gz&quot; -type f -mtime +7 | xargs rm -rf 
[root@kang ~]# sh -x del.sh 
+ find /tmp -name '*.tar.gz' -type f -mtime +7 #&lt;==执行时，系统会自动删除/tmp下的文件。
+ xargs rm -rf
[root@kang ~]# 
</code></pre>

<p><strong>如果忘记定义了path变量，并且还未做特殊变量定义，那么命令就会出现意外，如下：</strong></p>

<p><a href="https://img.it610.com/image/info8/f95e3cfef88540c1b48c2d117e8ca6fe.jpg"><img src="https://img.it610.com/image/info8/f95e3cfef88540c1b48c2d117e8ca6fe.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/e60f99d16409478b824910a76f0dd7ed.jpg"><img src="https://img.it610.com/image/info8/e60f99d16409478b824910a76f0dd7ed.jpg" alt="Shell | 变量知识进阶与实战
【详解】_第43张图片" /></a></p>

<p><strong>解释：</strong></p>

<pre><code>[root@kang ~]# cat del.sh 
#!/bin/bash
find ${path} -name &quot;*.tar.gz&quot; -type f -mtime +7 | xargs rm -rf 
[root@kang ~]# sh -x del.sh 
+ find -name '*.tar.gz' -type f -mtime +7 #&lt;==这条命令明显没有指定路径，因此将会导致异常。
+ xargs rm -rf
[root@kang ~]# 
</code></pre>

<p><strong>好了，关于shell变量的知识就先演示到这里，这些都是必不可少的基本知识，如果不理解，建议反复去看，去练，最后希望对你</strong></p>

<p><strong>有所帮助！！！！</strong></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>