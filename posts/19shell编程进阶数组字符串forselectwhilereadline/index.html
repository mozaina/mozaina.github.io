<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>19Shell编程进阶数组字符串forselectwhilereadline | 开发者问答集锦</title>
    <meta property="og:title" content="19Shell编程进阶数组字符串forselectwhilereadline - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="19Shell编程进阶数组字符串forselectwhilereadline">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/19shell%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2forselectwhilereadline/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">19Shell编程进阶数组字符串forselectwhilereadline</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="for循环">for循环</h3>

<p>for 变量名 in 列表;do<br />
循环体<br />
done</p>

<ul>
<li>执行机制：<br />
依次将列表中的元素赋值给“变量名” ; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束</li>
</ul>

<h4 id="列表生成方式">列表生成方式：</h4>

<p>列表生成方式有多重，详情可查看其他博客所总结。</p>

<ol>
<li>直接给出列表</li>

<li><p>整数列表：<br />
(a) {start..end}<br />
(b) $(seq [start [step]] end)</p></li>

<li><p>返回列表的命令<br />
$(COMMAND)</p></li>

<li><p>使用glob通配符，如：*.sh</p></li>

<li><p>变量引用<br />
$@, $*</p></li>
</ol>

<h3 id="for特殊格式">for特殊格式</h3>

<p>双小括号方法，即((…))格式，也可以用于算术运算<br />
双小括号方法也可以使bash Shell实现C语言风格的变量操作<br />
I=10<br />
((I++))</p>

<ul>
<li><p>for循环的特殊格式：<br />
for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))<br />
do<br />
循环体<br />
done</p></li>

<li><p>控制变量初始化：仅在运行到循环代码段时执行一次</p></li>

<li><p>控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做条件判断</p></li>
</ul>

<h4 id="这种写法双小括号内的判断是按照c语言风格-而不是-eq-这类shell中test风格的">这种写法双小括号内的判断是按照C语言风格，而不是-eq 这类shell中test风格的</h4>

<h3 id="while循环">while循环</h3>

<p>while CONDITION; do<br />
循环体<br />
done</p>

<ul>
<li>CONDITION：循环控制条件； <strong>进入循环之前</strong> ，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环</li>
<li>因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正</li>
</ul>

<p>进入条件：CONDITION为true<br />
退出条件：CONDITION为false</p>

<h3 id="until循环">until循环</h3>

<p>until CONDITION; do<br />
循环体<br />
done</p>

<ul>
<li>进入条件： CONDITION 为false</li>
<li>退出条件： CONDITION 为true</li>
</ul>

<h2 id="循环控制语句">循环控制语句</h2>

<h3 id="continue">continue</h3>

<p>用于循环体中<br />
continue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层</p>

<p>while CONDTIITON1; do<br />
CMD1<br />
&hellip;<br />
if CONDITION2; then<br />
continue<br />
fi<br />
CMDn<br />
&hellip;<br />
done</p>

<h3 id="break">break</h3>

<p>用于循环体中<br />
break [N]：提前结束第N层循环，最内层为第1层<br />
while CONDTIITON1; do<br />
CMD1<br />
&hellip;<br />
if CONDITION2; then<br />
break<br />
fi<br />
CMDn<br />
&hellip;<br />
done</p>

<h3 id="注意点">注意点：</h3>

<ol>
<li>continue只是结束 <strong>此这一次</strong> 循环（默认最内层），然后继续下一次循环。它仍然在此循环内，只是continue下面的语句在此次循环中不再执行了。如果后面加上数字，就是跳到数字所在的循环层数内继续执行数字所在层的后面所剩的循环次数（根据判断条件判断的），而比数字小的循环则不再执行（相当于break掉了比数字小的循环）</li>
<li>break相当于此循环直接停止并跳出（默认最内层），后面加上数字就代表了它直接跳出数字所在层的循环（跳到数字所在层的更外一层，然后执行更外一层的命令，而continue是跳到数字所在层继续执行数字所在层的剩下的循环）。</li>
<li>注意break只是循环退出了，并是不exit脚本退出。</li>
<li>还有一点就是假如有2层或者多层循环，break 退出当前层循环之后它是继续执行外层循环中在当前循环后面的命令，而contine 2则跳到外层循环之后直接从外层循环的开头重新进行下一轮循环了。</li>
</ol>

<h3 id="shift命令">shift命令</h3>

<p>shift [n]<br />
用于将参量列表 list 左移指定次数，缺省为左移一次。<br />
参量列表 list 一旦被移动，最左端的那个参数就从列表中删除。 while 循环遍历位置参量列表时，常用到 shift<br />
例如：<br />
./doit.sh a b c d e f g h<br />
./shfit.sh a b c d e f g h</p>

<pre><code>示例：doit.sh
#!/bin/bash
# Name: doit.sh
# Purpose: shift through command line arguments
# Usage: doit.sh [args]
while [ $# -gt 0 ] # or while (( $# &gt; 0 ))
do
echo $*
shift
done

示例：shift.sh
#!/bin/bash
#step through all the positional parameters
until [ -z &quot;$1&quot; ]
do
echo &quot;$1&quot;
shift
done
echo
</code></pre>

<h4 id="创建无限循环">创建无限循环</h4>

<p>while true; do<br />
循环体<br />
done</p>

<p>until false; do<br />
循环体<br />
Done</p>

<h2 id="特殊用法-很实用">特殊用法（很实用）</h2>

<p>遍历文件每一行这个写法很实用，参考自己写的创建用户的脚本读入每一行的命令就知道为何实用了（因为它只把换行符当做分隔符，而不把空格当做分隔符，每一行当做一个长字符串存入变量中）</p>

<h3 id="while循环的特殊用法-遍历文件的每一行">while循环的特殊用法（遍历文件的每一行）</h3>

<p>while read line; do<br />
循环体<br />
done &lt; /PATH/FROM/SOMEFILE</p>

<ul>
<li>依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line</li>
</ul>

<h3 id="select循环与菜单">select循环与菜单</h3>

<p>PS3=&ldquo;Please input a number:&rdquo;<br />
select variable in list<br />
do<br />
循环体命令<br />
done</p>

<ul>
<li>select 循环主要用于创建菜单，按数字顺序排列的菜单项将显示在标准错误上，并显示 PS3 提示符，等待用户输入</li>
<li>用户输入菜单列表中的某个数字，执行相应的命令</li>
<li>用户输入被保存在内置变量 REPLY 中（和read的一样）</li>
<li>select 是个无限循环，因此要记住用 break 命令退出循环，或用 exit 命令终止脚本。也可以按 ctrl+c 退出循环</li>

<li><p>select 经常和 case 联合使用<br />
注意 ：与 for 循环类似，可以省略 in list，此时使用位置参量</p>

<p>PS3=&ldquo;please input a number:&rdquo;
select menu in backup clean config start stop status restart quit;do
        case $menu in
        *)
                echo $REPLY
                echo $menu;;
        esac
done</p></li>
</ul>

<h2 id="函数介绍">函数介绍</h2>

<ol>
<li>函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程</li>
<li>它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分</li>
</ol>

<h3 id="函数和shell程序比较相似-区别在于">函数和shell程序比较相似，区别在于</h3>

<ol>
<li>Shell程序在子Shell中运行</li>
<li>而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改</li>
</ol>

<h3 id="定义函数">定义函数</h3>

<p>函数由两部分组成：函数名和函数体<br />
help function<br />
语法一：<br />
f_name （）{<br />
&hellip;函数体&hellip;<br />
}<br />
语法二：<br />
function f_name {<br />
&hellip;函数体&hellip;<br />
}<br />
语法三：<br />
function f_name （） {<br />
&hellip;函数体&hellip;<br />
}</p>

<h3 id="函数使用">函数使用</h3>

<ol>
<li><p>函数的定义和使用：<br />
可在交互式环境下定义函数<br />
可将函数放在脚本文件中作为它的一部分<br />
可放在只包含函数的单独文件中</p></li>

<li><p>调用：函数只有被调用才会执行<br />
调用：给定函数名<br />
函数名出现的地方，会被自动替换为函数代码</p></li>

<li><p>函数的生命周期：被调用时创建，返回时终止</p></li>
</ol>

<h3 id="函数返回值">函数返回值</h3>

<h4 id="函数有两种返回值">函数有两种返回值：</h4>

<ol>
<li><p>函数的执行结果返回值：<br />
(1) 使用echo等命令进行输出<br />
(2) 函数体中调用命令的输出结果</p></li>

<li><p>函数的退出状态码：<br />
(1) 默认取决于函数中执行的最后一条命令的退出状态码<br />
(2) 自定义退出状态码，其格式为：<br />
return 从函数中返回，用最后状态命令决定返回值<br />
return 0 无错误返回<br />
return 1-255 有错误返回</p></li>
</ol>

<h3 id="环境函数">环境函数</h3>

<p>使子进程也可使用<br />
声明：export -f function_name<br />
查看：export -f 或 declare -xf</p>

<h3 id="函数递归示例">函数递归示例</h3>

<ul>
<li><p>函数递归：<br />
函数直接或间接调用自身<br />
注意递归层数</p></li>

<li><p>示例：阶乘</p></li>
</ul>

<h3 id="fork">fork×××</h3>

<p>fork×××是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源</p>

<ul>
<li><p>函数实现<br />
:(){ :|:&amp; };:<br />
bomb() { bomb | bomb &amp; }; bomb</p></li>

<li><p>脚本实现<br />
cat Bomb.sh<br />
#!/bin/bash<br />
./$0|./$0&amp;</p>

<p>func_factorial(){
        local input=$1
        if func_ispositint $input ;then
                [ $input -gt 1 ] &amp;&amp; echo $[<code>func_factorial $[input-1]</code>*input] || echo 1
        else
                echo -e &ldquo;Please input a positive integer&rdquo;
                return 1
        fi<br />
}</p></li>
</ul>

<h3 id="注意知识点">注意知识点：</h3>

<ol>
<li>函数就像一个普通命令，声明定义之后（source之后）直接使用即可，看不出和命令的区别。因此命名函数的时候最好以func_funcname的方式进行命名加以区分。</li>
<li>删除函数和删除变量一样 用unset func_name命令即可</li>

<li><p>注意下面这两个命令，它俩显示是已经加载入内存中正在被引用的函数</p>

<ul>
<li>declare -F ：只看函数名，后面可以跟函数名查询特定的函数，下同</li>
<li>declare -f : 看函数的定义内容，也就是/etc/init.d/functions文件中的内容</li>
</ul></li>

<li><p>可以把自己常用的函数写在一个文件里，然后source它引用。<br />
比如系统中/etc/init.d/function中的actions()函数就可拿来直接用，先source或者.它即可.注意脚本中也要source它，这样它才能在开启的子shell中也运行。</p>

<p>action string true ：它就会显示正确结果  action string false : 它就会显示错误结果</p></li>

<li><p>注意因为函数是在当前shell中运行，因此它的变量会影响当前脚本或者shell中的变量结果（也就是两个变量名字相同会造成变量污染），因此 函数中的变量一般都定义为 local variable=赋值;</p>

<ul>
<li>三种常见变量1.普通变量直接赋值无需定义，当前shell中有效；2.export 全局变量(环境变量） 可以定义的时候赋值，也可以普通变量赋值完之后再定义，子shell和当前shell有效；3.局部变量local 函数中使用</li>
</ul></li>

<li><p>三个返回：return 返回出函数；break,continue 返回出循环；exit 返回出shell(脚本） ；</p>

<ul>
<li>一个等待：wait 后台命令结束后自动返回前台并打印PS1提示符</li>
<li>注意所有的返回都是返回到执行这个函数，脚本，循环的上一层环境命令处，返回命令后面的命令（在这个函数，脚本，循环中）则不再执行了。</li>
</ul></li>

<li><p>{ cmd; cdm;} 也可以看作是一个匿名函数（没有名字的函数，只能调用一次），更详细的关于括号的解释参考其他博客。</p></li>

<li><p>return 后面不加数字的话就是返回上面的最后一个命令的$?值作为这整个函数的返回值，如果加上数字则把这个数字当做这个函数整体的返回值$?.</p></li>

<li><p>函数类似脚本后面也可以跟参数，用法一模一样。注意$*和$@的区别，加上双引号引用此参数传递到子函数或者子脚本中，前者代表一整个字符串作为一个参数，后者代表分别作为一个一个参数。不加上双引号没区别，这也是因为不加双引号会把里面的空格作为分隔符。</p>

<ul>
<li>注意如果是脚本中调用函数，则脚本后面的参数调入到函数中时，如若函数后的参数是脚本所用的参数，一定要注意参数用$加数字方式的时候，写好顺序。同时如果想要函数对这些参数进行改变，一定注意函数内部的变量不要定义为局部变量才可。</li>
</ul></li>

<li><p>函数如果写在脚本中要写在最前面以供后面的命令调用，注意shell中的函数没有先声明后定义的用法，只能写在最前面，不像C语言可以先声明后面再定义。</p></li>

<li><p>注意函数递归是先递归到最里层，然后最里层返回一个返回值，然后在从最里层往外返回到最外层。因此最里层一定要写好返回值的条件，不然会永远递归下去消耗系统资源。递归×××就从此而来。</p></li>

<li><p>通过阶乘的编写需要注意递归函数的编写：</p>

<ul>
<li>return返回的值是函数的返回值存在$?中，不能作为函数名字的结果被上一层递归计算</li>
<li>用echo 返回出值，然后就可以代表这个函数名字当前层级的值，可以被上一层级来利用它进行计算</li>
<li>注意echo 返回值不能写在最后，只能写在递归的判断里面，否则每次递归都会echo 一次，会导致每次递归函数名的返回值是两个（2层） 3个（三层）&hellip;. 这样的话就没办法把函数本身当做一个数值来进行计算了。</li>
<li>最底层没有返回结果则会永远递归下去，不断的开子进程，folk×××就是利用此</li>
</ul></li>
</ol>

<h3 id="信号捕捉trap">信号捕捉trap</h3>

<ol>
<li><p>trap &lsquo;触发指令&rsquo; 信号<br />
进程收到系统发出的指定信号后，将执行自定义指令，而不会执行原操作</p></li>

<li><p>trap &ldquo; 信号<br />
忽略信号的操作</p></li>

<li><p>trap &lsquo;-&rsquo; 信号<br />
恢复原信号的操作</p></li>

<li><p>trap -p<br />
列出自定义信号操作</p></li>

<li><p>trap finish EXIT<br />
当脚本退出时，执行finish函数</p></li>
</ol>

<h3 id="注意点-1">注意点：</h3>

<ol>
<li>trap的用处就是在shell（主要体现在脚本）中，让某些命令无法进行操作，比如说kill -9 命令等等。可以保证脚本的各种运行状态</li>
<li>还有一种情况就是脚本执行一半因为某些特殊情况非正常退出，或者说遇到某些条件判断退出了，则在退出的时候捕获到退出信号EXIT（EXIT信号并未在kill -l中列出），则会执行退出时指定的命令或者函数（需要脚本前面提前定义函数等）（If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.）</li>
<li>trap的生效在脚本中也是从前到后的，因此trap的信号捕获命令一定要写在脚本的最前端。同时后面的信号可以写对应的数字标号，特殊的0表示shell(脚本)退出信号。</li>
<li>注意下面trap中写的echo命令会打断sleep,如果想要不打断，则中间的命令部分什么也不写空着最好，这样int命令将没办法执行任何操作了。</li>
</ol>

<h4 id="trap示例">trap示例</h4>

<pre><code>#!/bin/bash
trap 'echo “signal:SIGINT&quot;' int
trap -p

for((i=0;i&lt;=10;i++))
do
sleep 1
echo $i
done

trap '' int
trap -p

for((i=11;i&lt;=20;i++))
do
sleep 1
echo $i
done

trap '-' int
trap -p

for((i=21;i&lt;=30;i++))
do
sleep 1
echo $i
done
</code></pre>

<h2 id="数组">数组</h2>

<ol>
<li>变量：存储单个元素的内存空间</li>
<li>数组：存储多个元素的连续的内存空间，相当于多个变量的集合</li>

<li><p>数组名和索引<br />
索引：编号从0开始，属于数值索引</p>

<ul>
<li>注意：索引可支持使用自定义的格式，而不仅是数值格式，即为关联索引，从bash4.0版本之后开始支持</li>
</ul></li>
</ol>

<h3 id="声明数组">声明数组：</h3>

<p>declare -a ARRAY_NAME 普通数组：可以不用先声明，直接使用即可<br />
declare -A ARRAY_NAME 关联数组：必须先声明才可以使用,如果先使用了，必须unset之后再重新声明才可以使用<br />
 <strong>注意：两者不可相互转换</strong></p>

<h3 id="数组注意点">数组注意点：</h3>

<ol>
<li>bash的数组支持稀疏格式（索引不连续），非常实用，但是要注意稀疏格式的数组总个数就是有元素的个数，而不是数组的下标的最大值的个数</li>
<li>注意字符串（也就是变量名）取长度的时候不要加下标${#varialble}，只有包含多个元素的数组取长度的时候才加下标${#array[*]}。同时字符串想要取中间的部分字符，只能用${var：#：#}的这种方式，因为var它就相当于数组只有一个元素它本身（或者说这个字符串开头的地址var[0])</li>
<li>而数组中的每个元素中内容想要切片的话则要加上下标${array[INDEX]：#：#}，（此时就是把这个带下标的数组元素名当做一个地址，看作是本身的下标0了）。取数组中的各个元素的话则是${array[*|@]：#：#}的方式。</li>

<li><p>不写下标默认为0，因此字符串数组（也就是变量）就是代表整个字符串，而数组就是代表数组里面的第一个元素。</p>

<p>17:47[root@centos7 /etc/sysconfig/network-scripts]# abc=12334
17:54[root@centos7 /etc/sysconfig/network-scripts]# echo ${abc[0]}
12334
17:54[root@centos7 /etc/sysconfig/network-scripts]# echo ${abc}
12334
17:54[root@centos7 /etc/sysconfig/network-scripts]# echo ${#abc}
5</p>

<p>17:57[root@centos7 /data/scriptest]# array=([1]=12wad [5]=ff [6]=cvv [8]=1wd234)
17:57[root@centos7 /data/scriptest]# echo $array</p>

<p>17:57[root@centos7 /data/scriptest]# echo ${array[0]}</p>

<p>17:58[root@centos7 /data/scriptest]# echo ${array[1]}
12wad
17:58[root@centos7 /data/scriptest]# echo ${#array[1]}  :第一个元素的长度
5
17:58[root@centos7 /data/scriptest]# echo ${#array[<em>]}  ：数组总长度，稀疏数组只看有几个元素就是几
4
17:58[root@centos7 /data/scriptest]# echo ${array[1]:2:3} ：第一个元素内容切片
wad
17:58[root@centos7 /data/scriptest]# echo ${array[</em>]}
12wad ff cvv 1wd234
20:00[root@centos7 /data/scriptest]# echo ${array[<em>]:2:2} ：取不同的数组元素，注意和元素内容切片的区分
ff cvv
20:00[root@centos7 /data/scriptest]# echo ${array[</em>]:2:3}
ff cvv 1wd234</p></li>
</ol>

<h3 id="数组赋值">数组赋值</h3>

<h4 id="数组元素的赋值">数组元素的赋值</h4>

<p>(1) 一次只赋值一个元素<br />
ARRAY_NAME[INDEX]=VALUE<br />
weekdays[0]=&ldquo;Sunday&rdquo;<br />
weekdays[4]=&ldquo;Thursday&rdquo;<br />
(2) 一次赋值全部元素（注意尽量要加上引号，虽然空格也可以作为分隔符）<br />
ARRAY_NAME=(&ldquo;VAL1&rdquo; &ldquo;VAL2&rdquo; &ldquo;VAL3&rdquo; &hellip;)<br />
(3) 只赋值特定元素<br />
ARRAY_NAME=([0]=&ldquo;VAL1&rdquo; [3]=&ldquo;VAL2&rdquo; &hellip;)<br />
(4) 交互式数组值对赋值（注意有一个-a的选项）<br />
read -a ARRAY</p>

<h3 id="显示所有数组-declare-a">显示所有数组：declare -a</h3>

<h4 id="特殊的赋值方式">特殊的赋值方式：</h4>

<p>num=({1..10}) ：1到10赋值给num[0]到num[9]<br />
file=(*.sh) :当前目录中sh后缀的文件名赋值给file数组</p>

<p>####
稀疏方式赋值注意：如果先一个一个赋值，然后又一次赋值特定元素(3中的方式)，就算赋值的元素下标并不一样，但这样仍然则会将一个一个赋值的结果给覆盖掉。但是反过来如果先一次性赋值（3中的方式），然后再一个一个赋值下标不同的数组元素，则不会覆盖掉一次性赋值的元素例子：</p>

<pre><code>19:40[root@centos7 /data]# testarray[2]=12
19:40[root@centos7 /data]# testarray[5]=1234
19:40[root@centos7 /data]# echo ${testarray[2]} 
12
19:40[root@centos7 /data]# declare -a
declare -a testarray='( [2]=&quot;12&quot; [5]=&quot;1234&quot;)'
19:40[root@centos7 /data]# testarray=( [1]=wade [3]=waef )
19:40[root@centos7 /data]# echo ${testarray[2]} 

19:40[root@centos7 /data]# declare -a
declare -a testarray='([1]=&quot;wade&quot; [3]=&quot;waef&quot;)'
上面会覆盖，然后继续，下面的不会覆盖：
19:40[root@centos7 /data]# testarray[2]=12
19:44[root@centos7 /data]# testarray[5]=1234
19:44[root@centos7 /data]# declare -a
declare -a testarray='([1]=&quot;wade&quot; [2]=&quot;12&quot; [3]=&quot;waef&quot; [5]=&quot;1234&quot;)'
</code></pre>

<h3 id="引用数组">引用数组</h3>

<ol>
<li><p>引用数组元素<br />
${ARRAY_NAME[INDEX]}</p>

<ul>
<li><strong>注意：省略[INDEX]表示引用下标为0的元素</strong></li>
</ul></li>

<li><p>引用数组所有元素<br />
${ARRAY_NAME[*]}<br />
${ARRAY_NAME[@]}</p></li>

<li><p>数组的长度(数组中元素的个数)<br />
${#ARRAY_NAME[*]}<br />
${#ARRAY_NAME[@]}</p></li>

<li><p>删除数组中的某元素：导致稀疏格式<br />
unset ARRAY[INDEX]</p></li>

<li><p><strong>删除整个数组（类似的还有删除变量，删除函数，注意都是从内存中删除掉）</strong><br />
unset ARRAY</p></li>
</ol>

<h3 id="数组数据处理">数组数据处理</h3>

<h4 id="引用数组中的元素">引用数组中的元素：</h4>

<ol>
<li><p>数组切片：<br />
${ARRAY[*]:offset:number}<br />
offset 要跳过的元素个数<br />
number 要取出的元素个数</p></li>

<li><p>取偏移量之后的所有元素<br />
${ARRAY[*]:offset}</p></li>

<li><p>向数组中追加元素（因为下标从0开始）：<br />
ARRAY[${#ARRAY[*]}]=value</p></li>

<li><p>关联数组：<br />
declare -A ARRAY_NAME<br />
ARRAY_NAME=([idx_name1]=&lsquo;val1&rsquo; [idx_name2]=&lsquo;val2‘&hellip;)<br />
注意：关联数组必须先声明再调用</p></li>
</ol>

<h3 id="示例">示例</h3>

<ul>
<li><p>生成10个随机数保存于数组中，并找出其最大值和最小值<br />
(优化算法：不要每次都判断是否是第一个，把第一个赋值写在for循环外面，然后for循环直接从1开始即可)</p>

<pre><code>#!/bin/bash
</code></pre>

<p>declare -i min max
declare -a nums
for ((i=0;i&lt;10;i++));do
nums[$i]=$RANDOM
[ $i -eq 0 ] &amp;&amp; min=${nums[$i]} &amp;&amp; max=${nums[$i]}&amp;&amp; continue
[ ${nums[$i]} -gt $max ] &amp;&amp; max=${nums[$i]}
[ ${nums[$i]} -lt $min ] &amp;&amp; min=${nums[$i]}
done
echo “All numbers are ${nums[*]}”
echo Max is $max
echo Min is $min</p></li>
</ul>

<h3 id="示例-1">示例</h3>

<ul>
<li><p>编写脚本，定义一个数组，数组中的元素对应的值是/var/log目录下所有以.log结尾的文件；统计出其下标为偶数的文件中的行数之和</p>

<p>#!/bin/bash
#
declare -a files
files=(/var/log/<em>.log)
declare -i lines=0
for i in $(seq 0 $[${#files[</em>]}-1]); do
if [ $[$i%2] -eq 0 ];then
let lines+=$(wc -l ${files[$i]} | cut -d&rsquo; &lsquo; -f1)
fi
done
echo &ldquo;Lines: $lines.&rdquo;</p></li>
</ul>

<h3 id="字符串切片">字符串切片</h3>

<ol>
<li>${#var}:返回字符串变量var的长度</li>
<li>${var:offset}:返回字符串变量var中从第offset个字符后（不包括第offset个字符）的字符开始，到最后的部分，offset的取值在0 到 ${#var}-1 之间(bash4.2后，允许为负值)</li>
<li>${var:offset:number}：返回字符串变量var中从第offset个字符后（不包括第offset个字符）的字符开始，长度为number的部分</li>

<li><p>${var: -length}：取字符串的最右侧几个字符<br />
注意：冒号后必须有一空白字符</p></li>

<li><p>${var:offset:-length}：从最左侧跳过offset字符，一直向右取到距离最右侧lengh个字符之前的内容</p></li>

<li><p>${var: -length:-offset}：先从最右侧向左取到length个字符开始，再向右取到距离最右侧offset个字符之间的内容<br />
<strong>注意：-length前有空格（中间的那个必须有空格，：最后的一项可以不加空格)</strong></p></li>
</ol>

<h3 id="字符串处理">字符串处理</h3>

<ol>
<li><p>基于模式取子串<br />
${var#*word}：其中word可以是指定的任意字符<br />
功能：自左而右，查找var变量所存储的字符串中，第一次出现的word, 删除字符串开头至第一次出现word字符串（含）之间的所有字符</p></li>

<li><p>${var##*word}：同上，贪婪模式，不同的是，删除的是字符串开头至最后一次由word指定的字符之间的所有内容</p>

<ul>
<li>示例：<br />
file=“var/log/messages”<br />
${file# <em>/}: log/messages<br />
${file##</em>/}: messages</li>
</ul></li>

<li><p>${var%word*}：其中word可以是指定的任意字符<br />
功能：自右而左，查找var变量所存储的字符串中，第一次出现的word, 删除字符串最后一个字符向左至第一次出现word字符串（含）之间的所有字符</p>

<ul>
<li>例子：<br />
file=&ldquo;/var/log/messages&rdquo;<br />
${file%/*}: /var/log</li>
</ul></li>

<li><p>${var%%word*}：同上，只不过删除字符串最右侧的字符向左至最后一次出现word字符之间的所有字符</p>

<ul>
<li>示例：<br />
url=<a href="http://www.51cto.com:80">http://www.51cto.com:80</a><br />
${url## <em>:} 80<br />
${url%%:</em>} http</li>
</ul></li>
</ol>

<h4 id="查找替换">查找替换</h4>

<ol>
<li>${var/pattern/substr}：查找var所表示的字符串中，第一次被pattern所匹配到的字符串，以substr替换之</li>
<li>${var//pattern/substr}:查找var所表示的字符串中，所有能被pattern所匹配到的字符串，以substr替换之</li>
<li>${var/#pattern/substr}：查找var所表示的字符串中，行首被pattern所匹配到的字符串，以substr替换之</li>
<li>${var/%pattern/substr}：查找var所表示的字符串中，行尾被pattern所匹配到的字符串，以substr替换之</li>
</ol>

<h4 id="查找并删除">查找并删除</h4>

<ol>
<li>${var/pattern}：删除var表示的字符串中第一次被pattern匹配到的字符串，从左往右匹配</li>
<li>${var//pattern}：删除var表示的字符串中所有被pattern匹配到的字符串，从左往右匹配</li>
<li>${var/#pattern}：删除var表示的字符串中所有以pattern为行首匹配到的字符串</li>
<li>${var/%pattern}：删除var所表示的字符串中所有以pattern为行尾所匹配到的字符串</li>
</ol>

<h4 id="字符大小写转换">字符大小写转换</h4>

<p>${var^^}：把var中的所有小写字母转换为大写<br />
${var,,}：把var中的所有大写字母转换为小写</p>

<h3 id="变量赋值的其他形式">变量赋值的其他形式</h3>

<p><a href="https://img.it610.com/image/info8/c327c5cec35a43269b7f897e7094f0ed.jpg"><img src="https://img.it610.com/image/info8/c327c5cec35a43269b7f897e7094f0ed.jpg" alt="19.Shell编程进阶,数组,字符串,\(for,select,while read
line\)_第1张图片" /></a></p>

<ul>
<li>注意里面的expr是一个字符串，不是一个变量。直接就是双引号引起来的字符串。</li>
</ul>

<h3 id="高级变量用法-有类型变量">高级变量用法-有类型变量</h3>

<ul>
<li>Shell变量一般是无类型的，但是bash Shell提供了declare和typeset两个命令</li>
<li>它可用于指定变量的类型，两个命令是等价的</li>
</ul>

<h4 id="declare-选项-变量名">declare [选项] 变量名</h4>

<p>-r 声明或显示只读变量<br />
-i 将变量定义为整型数<br />
-a 将变量定义为数组<br />
-A 将变量定义为关联数组<br />
-f 显示已定义的所有函数名及其内容<br />
-F 仅显示已定义的所有函数名<br />
-x 声明或显示环境变量和函数 ：或者export<br />
-l 声明变量为小写字母 declare –l var=UPPER ：即使输入大写字母，也会变成小写字母，下同相反<br />
-u 声明变量为大写字母 declare –u var=lower</p>

<h3 id="eval命令-很实用-但是要会用它">eval命令 ：很实用，但是要会用它</h3>

<p>eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。该命令适用于那些一次扫描无法实现其功能的变量.该命令对变量进行两次扫描</p>

<ul>
<li>示例：<br />
[root@server ~]# CMD=whoami<br />
[root@server ~]# echo $CMD<br />
whoami<br />
[root@server ~]# eval $CMD<br />
root<br />
[root@server ~]# n=10<br />
[root@server ~]# echo {0..$n}<br />
{0..10}<br />
[root@server ~]# eval echo {0..$n}<br />
0 1 2 3 4 5 6 7 8 9 10</li>
</ul>

<p>####
间接变量引用:可以增加脚本灵活性，比如变量中存放了一个命令（其实直接写上$CMDvariable就能直接使用，要结果的话用echo加上反向单引号也能用<code>$CMDvariable</code>,)</p>

<ul>
<li>如果第一个变量的值是第二个变量的名字，从第一个变量引用第二个变量的值就称为间接变量引用</li>
<li>variable1的值是variable2，而variable2又是变量名，variable2的值为value，</li>

<li><p>间接变量引用是指通过variable1获得变量值value的行为<br />
variable1=variable2<br />
variable2=value</p></li>

<li><p>bash Shell提供了两种格式实现间接变量引用<br />
eval tempvar=\$$variable1 ：注意不加\的话则会把当前shell的PID显示出来（$$)<br />
tempvar=${!variable1}</p></li>

<li><p>示例：<br />
[root@server ~]# N=NAME<br />
[root@server ~]# NAME=wang<br />
[root@server ~]# N1=${!N}<br />
[root@server ~]# echo $N1<br />
wangxiaochun<br />
[root@server ~]# eval N2=\$$N<br />
[root@server ~]# echo $N2<br />
wang</p></li>
</ul>

<h3 id="创建临时文件">创建临时文件</h3>

<p>mktemp命令：创建并显示临时文件，可避免冲突<br />
mktemp [OPTION]&hellip; [TEMPLATE]<br />
TEMPLATE: filenameXXX<br />
X至少要出现三个</p>

<ul>
<li>OPTION：<br />
-d: 创建临时目录<br />
-p DIR或&ndash;tmpdir=DIR：指明临时文件所存放目录位置</li>
<li>示例：<br />
mktemp /tmp/testXXX<br />
tmpdir=<code>mktemp –d /tmp/testdirXXX</code><br />
mktemp &ndash;tmpdir=/testdir testXXXXXX</li>
</ul>

<h3 id="注意">注意</h3>

<ol>
<li>它创建临时文件的时候会有默认的输出，因此可以把它命令的结果存入到变量中比如file=<code>mktemp /data/tempXXXX</code></li>
<li>平常创临时文件的时候直接就写上了路径 ，不过也可以分开写 要难过-p 指定dir 然后后面只写临时文件名字就行了。不过一般不这么麻烦</li>
<li>自己单独编译安装的时候某些文件就要用到临时文件</li>
</ol>

<h2 id="安装复制文件">安装复制文件</h2>

<h3 id="install命令">install命令：</h3>

<p>install [OPTION]&hellip; [-T] SOURCE DEST 单文件<br />
install [OPTION]&hellip; SOURCE&hellip; DIRECTORY<br />
install [OPTION]&hellip; -t DIRECTORY SOURCE&hellip;<br />
 <strong>install [OPTION]&hellip; -d DIRECTORY&hellip;创建空目录</strong></p>

<ul>
<li>选项：<br />
-m MODE，默认755<br />
-o OWNER<br />
-g GROUP</li>
<li>示例：<br />
install -m 700 -o wang -g admins srcfile desfile<br />
install –m 770 –d /testdir/installdir</li>
</ul>

<h3 id="注意-1">注意：</h3>

<ol>
<li>install相当于cp ,chown ,chgrp ，chmod的集合</li>
<li>如果直接install 来进行拷贝，它和cp命令相比，它会让文件全部加上执行权限（ugo都加上）（而且它默认不是交互式，直接覆盖）</li>
<li>命令用法如其名，实现脚本一键安装，修改文件属性</li>
<li>注意他可以直接创建一个新的空文件夹，cp没有这功能（虽然cp拷贝的时候可以对应创建文件夹，但不能直接命令来单独创建一个空文件夹）</li>
</ol>

<h3 id="expect介绍">expect介绍</h3>

<p>expect 是由Don Libes基于Tcl（ Tool Command Language ）语言开发的，主要应用于自动化交互式操作的场景，借助
expect
处理交互的命令，可以将交互过程如：ssh登录，ftp登录等写在一个脚本上，使之自动化完成。尤其适用于需要对多台服务器执行相同操作的环境中，可以大大提高系统管理人员的工作效率</p>

<p>它执行的时候会捕获屏幕上出现的关键字，然后根据出现的key来自动提交（输入）内容</p>

<h3 id="expect命令-需要额外安装-默认不安装">expect命令:需要额外安装，默认不安装</h3>

<ul>
<li><p>expect 语法：<br />
expect [选项] [ -c cmds ] [ [ -[f|b] ] cmdfile ] [ args ]</p></li>

<li><p>选项<br />
-c：从命令行执行expect脚本， <strong>默认expect是交互地执行的</strong><br />
示例：expect -c &lsquo;expect &ldquo;\n&rdquo; {send &ldquo;pressed enter\n&rdquo;}<br />
-d：可以输出输出调试信息<br />
示例：expect -d ssh.exp</p></li>

<li><p>expect中相关命令<br />
spawn 启动新的进程<br />
send 用于向进程发送字符串<br />
expect 从进程接收字符串<br />
interact 允许用户交互 ：比如只ssh登陆，然后登录后继续手工命令<br />
exp_continue 匹配多个字符串在执行动作后加此命令</p></li>
</ul>

<h4 id="expect最常用的语法-tcl语言-模式-动作">expect最常用的语法(tcl语言:模式-动作)</h4>

<ol>
<li><p>单一分支模式语法：<br />
expect “hi” {send “You said hi\n&rdquo;}<br />
匹配到hi后，会输出“you said hi” ，并换行</p></li>

<li><p>多分支模式语法：<br />
expect &ldquo;hi&rdquo; { send &ldquo;You said hi\n&rdquo; } \<br />
&ldquo;hehe&rdquo; { send &ldquo;Hehe yourself\n&rdquo; } \<br />
&ldquo;bye&rdquo; { send &ldquo;Good bye\n&rdquo; }</p>

<ul>
<li>匹配hi,hello,bye任意字符串时，执行相应输出。等同如下：<br />
expect {<br />
&ldquo;hi&rdquo; { send &ldquo;You said hi\n&rdquo;}<br />
&ldquo;hehe&rdquo; { send &ldquo;Hehe yourself\n&rdquo;}<br />
&ldquo;bye&rdquo; { send &ldquo; Good bye\n&rdquo;}<br />
}</li>
</ul></li>
</ol>

<h3 id="注意-2">注意：</h3>

<ol>
<li>expect是一个程序命令包，它里面包含了一个同名的expect命令。</li>

<li><p>expect默认交互式，进去之后再输入命令（比如 <strong>再输入spawn expect</strong> 等）<br />
示例：</p>

<p>示例
#!/usr/bin/expect
spawn scp /etc/fstab 192.168.8.100:/app
expect {
&ldquo;yes/no&rdquo; { send &ldquo;yes\n&rdquo;;exp_continue }
&ldquo;password&rdquo; { send &ldquo;www.123\n&rdquo; }
}
expect eof</p>

<p>#!/usr/bin/expect
spawn ssh 192.168.8.100
expect {
&ldquo;yes/no&rdquo; { send &ldquo;yes\n&rdquo;;exp_continue }
&ldquo;password&rdquo; { send &ldquo;www.123\n&rdquo; }
}
interact
#expect eof</p>

<p>示例:变量，变量设置和赋值用set，后面不加等号
#!/usr/bin/expect
set ip 192.168.8.100
set user root
set password magedu
set timeout 10
spawn ssh $user@$ip
expect {
&ldquo;yes/no&rdquo; { send &ldquo;yes\n&rdquo;;exp_continue }
&ldquo;password&rdquo; { send &ldquo;$password\n&rdquo; }
}
interact</p>

<p>示例:位置参数：变量从0开始而不是shell中的从1开始
#!/usr/bin/expect
set ip [lindex $argv 0]
set user [lindex $argv 1]
set password [lindex $argv 2]
spawn ssh $user@$ip
expect {
&ldquo;yes/no&rdquo; { send &ldquo;yes\n&rdquo;;exp_continue }
&ldquo;password&rdquo; { send &ldquo;$password\n&rdquo; }
}
interact
#./ssh3.exp 192.168.8.100 root www</p>

<p>示例：执行多个命令
#!/usr/bin/expect
set ip [lindex $argv 0]
set user [lindex $argv 1]
set password [lindex $argv 2]
set timeout 10
spawn ssh $user@$ip
expect {
&ldquo;yes/no&rdquo; { send &ldquo;yes\n&rdquo;;exp_continue }
&ldquo;password&rdquo; { send &ldquo;$password\n&rdquo; }
}
expect &ldquo;]#&rdquo; { send &ldquo;useradd haha\n&rdquo; }
expect &ldquo;]#&rdquo; { send &ldquo;echo www |passwd &ndash;stdin haha\n&rdquo; }
send &ldquo;exit\n&rdquo;
expect eof
#./ssh4.exp 192.168.8.100 root www</p>

<p>示例：shell脚本调用expect，就是用多行重定向的方式来使用expect
#!/bin/bash
ip=$1
user=$2
password=$3
expect &lt;</p></li>
</ol>

<p>转载于:<a href="https://blog.51cto.com/14228129/2379087">https://blog.51cto.com/14228129/2379087</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>