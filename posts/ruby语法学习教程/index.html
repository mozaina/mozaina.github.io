<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>ruby语法学习教程 | 开发者问答集锦</title>
    <meta property="og:title" content="ruby语法学习教程 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="ruby语法学习教程">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/ruby%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">ruby语法学习教程</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>第一部分 Ruby语言基础</p>

<p>第一章 Ruby语言概述<br />
§1.1 Ruby的历史<br />
Ruby语言的发明人是日本人松本行弘(Matsumoto Yukihiro)，大家亲切的称呼他&rdquo;Matz&rdquo;。<br />
可能会出乎大家的意料，Ruby并不是一种近年来才诞生的语言，它的历史可以追溯到1993年，Ruby之父Matz开始对脚本语言感兴趣。在通过一些分析和思考之后，Matz认为脚本语言是可以变得很强大和灵活的，于是他准备把脚本语言作为他的发展方向。
和很多人一样，Matz是一个面向对象程序设计的fans，自然而然他想研究一种支持面向对象程序设计的脚本语言。随后的一段时间，他到网络上搜集了一些相关的资料，并且发现了Perl
5，当时Perl 5还没有发布。通过一段时间了解后，Matz.发现Perl
5这并不是他想的东西，所以他放弃了把Perl当作一个面向对象的脚本语言使用的念头。随后Matz转向了Python，Python是一个解释型的、面向对象语言，但是Matz发现Python并不能完全算作“面向对象”语言。Matz认为Python是面向对象和过程化程序设计语言（Procedural
Programming Language）的混合产物。Matz希望找到的是一种比Perl更强大、比Python更面向对象的语言，但是很遗憾,
这样的语言当时在地球上并不存在。于是Matz打算自己设计一个全新的编程语言。1993年2月24日是一个值得纪念的日子，在这一天Ruby诞生了。
1995年12月Matz推出了Ruby的第一个版本Ruby 0.95。
在1996年以前，都是Matz.一个人在开发进行Ruby的开发。后来随着Ruby社区的渐渐形成，很多社区成员给了Matz许多有意义的帮助，包括提交bug和patch等。现在，Ruby像其他开源项目一样，有自己的开发团队，任何有能力的个人或团体都可以参与Ruby的开发与进化。</p>

<p>§1.2 Ruby名字的由来<br />
首先明确一点，Ruby并不是其他单词的缩写。受Perl的影响，Matz也想用一种宝石来命名他的新语言，他使用了他的一位同事的生肖石－红宝石。后来，Matz意识到Ruby这个名字十分恰当，首先，在生肖石中，Pearl代表六月，而Ruby代表七月。在字体大小上，Pearl大小是5pt,
ruby的大小是5.5pt。所以Ruby这个名字对于一种Perl的后续语言十分合适。</p>

<p>§1.3 Ruby的特点<br />
Ruby是一种功能强大的面向对象的脚本语言，可以使用它方便快捷地进行面向对象程序设计。与Perl类似，而且Ruby具有强大的文本处理功能，使文本处理变得简单。此外还可以方便地使用C语言来扩展Ruby的功能。<br />
若您曾经“想要一种简单的面向对象的语言”，或者认为“Perl的功能虽然好用，但它的语法真让人受不了”，又或者觉得“LISP系列语言的思想不错，但到处都是括号真让人讨厌，最起码算式应该按照通常的样式书写”。那么，Ruby或许能让您满意。</p>

<p>归纳起来，Ruby有以下优点：<br />
 解释型执行，方便快捷<br />
Ruby是解释型语言，其程序无需编译即可执行。<br />
 语法简单、优雅<br />
语法比较简单，类似Algol系语法。<br />
 完全面向对象<br />
Ruby从一开始就被设计成纯粹的面向对象语言，因此所有东西都是对象，例如整数等基本数据类型。<br />
 内置正则式引擎，适合文本处理<br />
Ruby支持功能强大的字符串操作和正则表达式检索功能，可以方便的对字符串进行处理。<br />
 自动垃圾收集<br />
具有垃圾回收（Garbage Collect，GC）功能，能自动回收不再使用的对象。不需要用户对内存进行管理。<br />
 跨平台和高度可移植性<br />
Ruby支持多种平台，在Windows, Unix, Linux,
MacOS上都可以运行。Ruby程序的可移植性非常好，绝大多数程序可以不加修改的在各种平台上加以运行。<br />
 有优雅、完善的异常处理机制<br />
Ruby提供了一整套异常处理机制，可以方便优雅地处理代码处理出错的情况。<br />
 拥有很多高级特性<br />
Ruby拥有很多高级特性，例如操作符重载、Mix-ins、特殊方法等等，是用这些特性可以方便地完成各种强大的功能。</p>

<p>同时，由于是解释型语言，Ruby也有下列缺点：<br />
 解释型语言，所以速度较慢<br />
 静态检查比较少<br />
§1.4 Ruby和Python的比较<br />
Python是Ruby的劲敌。其功力深厚，可谓“千年蛇妖”。但matz认为Python的功能仍不完美，不然就不会创造Ruby了。</p>

<p>第二章 Ruby编程环境<br />
§2.1 Ruby的安装<br />
Ruby支持多种平台，包括Windows、Linux、各种类UNIX、MacOS X等。<br />
§2.1.1 在Windows 95/98/Me/XP上安装Ruby<br />
对于使用Windows平台的用户，安装Ruby是相当简单直接的事情。最方便的方法是使用“One-Click Ruby Installer”。<br />
不知你有没有听说过SourceForge？SourceForge
是全球最大的开放源代码软件开发平台和仓库。它集成了很多开放源代码应用程序，为软件开发提供了整套生命周期服务。在Ruby世界，也有一个类似的网站，那就是Rubyforge。“One-
Click Ruby
Installer”是Rubyforge上的一个开源项目，也是Rubyforge上下载量最大的项目之一。这个项目将Ruby语言核心和一系列常用扩展集成到了一起，还包含支持Ruby的免费的IDE工具FreeRIDE和SciTE，除了这些之外还包括帮助文档，示例代码，RubyGems包管理器，Fox
GUI库，fxri（Interactive Ruby Help &amp;
Console）等。和正如它名字所示，使用它，Ruby安装变得前所未见的容易。你可以在下面的地址下载到它的最新版本：<br />
<a href="http://rubyforge.org/projects/rubyinstaller/">http://rubyforge.org/projects/rubyinstaller/</a><br />
§2.1.2 在Linux上安装Ruby<br />
在linux下Ruby的安装要稍微复杂一些，推荐使用源码编译的方式安装，这样可以保证安装的是最新版本。<br />
首先到ruby主站<a href="http://www.ruby-lang.org/en/">http://www.ruby-lang.org/en/</a> 下载源代码，下载完毕后解压到目录，然后使用以下命令：<br />
./configure<br />
./make; make install<br />
执行上面的命令需要root权限，默认安装到/usr/local下。你也可以使用“./configure &ndash;prefix=自定义路径”来指定安装目录。<br />
windows上的ruby one-click
installer默认安装了RubyGems，但在Linux下我们需要手动安装RubyGems。RubyGems是一个Ruby的包管理器，我们后边会讲到它。<br />
首先从Rubyforge下载RubyGems的最近版本，地址如下：<br />
<a href="http://rubyforge.org/projects/rubygems/">http://rubyforge.org/projects/rubygems/</a><br />
解压RubyGems以后到相应目录下输入ruby setup.rb，屏幕上打印一些日志以后会告诉你安装成功，执行gem -v可以查看gem安装版本号。<br />
§2.2 运行Ruby<br />
下面，我们将以Windows平台下的Ruby环境举例如何运行Ruby。<br />
§2.2.1 使用Ruby</p>

<p>将“Hello World”作为学习计算机语言第一个学写的程序，现在已经成为一种传统。该程序最早出现在由Brian Kernighan和Dennis
Ritchie写的经典计算机程序设计教程《The C Programming Language》。我们来看看Ruby世界的“Hello World”：</p>

<p>在Windows中，打开命令行提示符窗口，在提示符上输入“Ruby”并回车，Ruby解释器就会运行并等候输入程序。Ruby可执行文件应该包含在系统搜索路径内。<br />
输入下面的程序：</p>

<p>print &ldquo;Hello World!&rdquo;</p>

<p>然后按Ctrl+D再按回车键，你就会看到Ruby执行程序的输出结果：</p>

<p>你也可以先将代码保存为文件，然后使用再Ruby解释器执行：</p>

<p>§2.2.2 使用FreeRIDE和SciTE<br />
FreeRIDE是一个支持Ruby语言的免费IDE环境。FreeRIDE本身就是使用Ruby语言开发，它也是Rubyforge上的重要项目之一。<br />
可以使用FreeRIDE来编写调试和执行Ruby代码，FreeRIDE内置了交互式变成环境和Ruby语言在线帮助，功能十分强大。</p>

<p>Scintilla是一个免费的源代码编辑控件，它完全开放源代码，并允许用户自由地用于开源软件或是商业软件中。SciTE是用这个控件开发了一个编辑软件，在“One-
Click Ruby Installer”中，SciTE集成了Ruby语言支持，使用起来非常方便。相比FreeRIDE，它的特点就是使用简单。</p>

<p>§2.2.3 使用fxri<br />
Fxri是一个Ruby交互帮助和控制台工具。它不仅可作为语言的在线帮助，而且可以用作交互式Ruby解释器来执行程序。对于学习Ruby语言，fxri是一个非常方便的帮手。<br />
不知你有没有听说过Fox ToolKit，它是相当轻巧的开放源代码的图形库。FXRuby是RubyForge上的一个项目，提供了Ruby语言使用Fox
ToolKit的接口。而Fxri正是基于FXRuby开发，Fxri同样是RubyForge上的项目。这样你应该可以猜到Fxri名字的由来</p>

<p>Fxri同时集成了Ruby-irb和Ruby-ri的功能，有了它，你可以抛开Ruby-irb，Ruby-
ri了，但如果你用的不是Windows系统的话，算我没说<br />
§2.3 Ruby-irb<br />
Ruby-irb是交互式Ruby（Interactive Ruby）的简称，用来从标准输入读入并执行Ruby代码的工具，像一个shell。<br />
使用命令“irb”进入交互式模式，然后可以象输入命令行命令一样输入Ruby代码，代码执行的结果会立刻显示：</p>

<p>§2.4 Ruby-ri<br />
和Perl一样，Ruby也设计了嵌入式文档。 ruby-ri就是查看文档的工具。Ruby-ri的执行命令为“ri”，例如你可以通过“ri
String.new”来查询String类的new方法：</p>

<p>§2.5 RubyGems<br />
RubyGems是Ruby社区流行的包管理工具，在以前如果要下载一个Ruby扩展或者应用程序的话，你需要先下载相应的zip包，然后解压缩，再将应用或者扩展安装到Ruby对应的目录中。但是有了RubyGems所有这些麻烦都没有了，你只需要一条命令就可以从远程服务器上下载相应的包，如果相应的应用包含其他扩展，RubyGems会提示你从远程安装所依赖的扩展。安装后
RubyGems会运行相应的程序生成rdoc帮助文档。当然你也可以将软件包下载到本地运行RubyGems本地安装命令。<br />
统一化的管理带来的好处就是简单，有了RubyGems包管理器，Ruby应用的安装将变得前所未见的容易。RubyGems是Rubyforge下载量最大的项目之一，现在Ruby社区的应用都在朝着RubyGems的方向发展，RubyGems也将成为Ruby事实上的包管理器标准。<br />
RubyGems包管理器的可执行命令是“gem”，gem命令包含很多子命令和相应的选项，例如：<br />
gem -h/&ndash;help – 显示命令帮助<br />
gem -v/&ndash;version – 显示Gems的版本号</p>

<p>第三章 类与对象<br />
Ruby是一种真正的面向对象程序设计语言，面向对象指以对象为中心的理论体系。<br />
 封装（Encapsulation）<br />
将内部结构和算法隐藏起来，以确保只有特定的过程(也叫方法)才能直接操作数据，其结果是不能从外部直接使用数据构造，同时一旦内部构造发生变化也不会对外界造成不良影响。这种隔离方法就叫做封装。<br />
 继承<br />
 多态（Polymorphism）<br />
根据对象的不同选择合适的操作。在Ruby中的实现方法是，根据被调的对象的不同来选择不同的方法。</p>

<p>虽然有很多语言都宣称自己是面向对象的，但是他们往往对面向对象的解释都一样，大多是以自己特有的方式来解释什么是面向对象，而在实际情况中，这些面向对象语言又采用了很多非面向对象的做法。<br />
以 Java 为例：如果你想取一个数字取绝对值，java 的做法是：<br />
int num = Math.abs(-99);<br />
也就是将一个数值传递给 Math 类的一个静态函数 abs 处理。为什么这么做？因为在 java 中，数值是基本类型不是类。<br />
而在 Ruby 中，任何事物都是对象，也就是说，数字–99就是对象，取绝对值这样的操作应该属于数字本身，所以Ruby的做法就是：<br />
c = -99.abs<br />
在Ruby中，你所操作的一切都是对象，操作的结果也是对象。<br />
§3.1 类的定义<br />
类是对具有同样属性和同样行为的对象的抽象，Ruby中类的声明使用class关键字。定义类的语法如下，<br />
class ClassName<br />
def method_name(variables)<br />
#some code<br />
end<br />
end<br />
类的定义要在class…end之间，在上面的格式中，ClassName是类名，类名必须以大写字母开始，也就是说类名要是个常量。</p>

<p>看下面的例子：<br />
class Person<br />
def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
end<br />
end</p>

<p>若某个类已经被定义过，此时又用相同的类名进行类定义的话，就意味着对原有的类的定义进行追加。</p>

<p>class Test<br />
def meth1<br />
puts &ldquo;This is meth1&rdquo;<br />
end<br />
end</p>

<p>class Test<br />
def meth2<br />
puts &ldquo;This is meth2&rdquo;<br />
end<br />
end</p>

<p>在Test类中，原有meth1方法，我们又追加了meth2方法，这时候，对于Test类的对象，meth1和meth2同样可用。<br />
§3.2 对象，属性和方法<br />
类在实例化后生成对象，在强调对象归属于某类时，有时候我们也使用实例对象一词。<br />
方法（Method）是对对象进行的操作。操作对象(被调)以self来表示。在Ruby中，除去内部类的对象以外，通常对象的构造都是动态确定的。某对象的性质由其内部定义的方法所决定。<br />
看下面的例子，我们使用new方法构造一个新的对象，</p>

<p>class Person<br />
def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
end<br />
end<br />
people = Person.new(&lsquo;Tom&rsquo;, &lsquo;male&rsquo;, 15)</p>

<p>我们可以使用Person.new方法来创建一个Person类的实例对象。以@打头的变量是实例变量，他们从属于某一实例对象，Ruby中实例变量的命名规则是变量名以@开始，您只能在方法内部使用它。<br />
initialize方法使对象变为“就绪”状态，initialize方法是一个特殊的方法，这个方法在构造实例对象时会被自动调用。<br />
对实例进行初始化操作时，需要重定义initialize方法。类方法new的默认的行为就是对新生成的实例执行initialize方法，传给new方法的参数会被原封不动地传给initialize方法。另外，若带块调用时，该块会被传给initialize方法。因此，不必对new方法进行重定义。<br />
在Ruby中，只有方法可以操作实例变量，因此可以说Ruby中的封装是强制性的。在对象外部不可以直接访问，只能通过接口方法访问。</p>

<p>class Person<br />
def name<br />
@name<br />
end</p>

<p>def gender<br />
@gender<br />
end</p>

<p>def age<br />
@age<br />
end<br />
end</p>

<p>people = Person.new(&lsquo;Tom&rsquo;, &lsquo;male&rsquo;, 15)<br />
puts people.name<br />
puts people.gender<br />
puts people.age</p>

<p>输出结果为：<br />
Tom<br />
male<br />
15</p>

<p>在Ruby中，一个对象的内部属性都是私有的。
上面的代码中，我们定义了方法name，gender，age三个方法用来访问Person类实例对象的实例变量。注意name，gender，age访问只能读取相应实例变量，而不能改变它们的值。</p>

<p>我们也可以用成员变量只读控制符attr_reader来达到同样的效果。<br />
class Person<br />
attr_reader :name, :gender, :age<br />
end</p>

<p>类似地，我们可以定义方法去改变成员变量的值。<br />
class Person<br />
def name=(name)<br />
@name=name<br />
end</p>

<p>def gender=(gender)<br />
@gender=gender<br />
end</p>

<p>def age=(age)<br />
@age=age<br />
end<br />
end<br />
people = Person.new(&lsquo;Tom&rsquo;, &lsquo;male&rsquo;, 15)<br />
people.name = &ldquo;Henry&rdquo;<br />
people.gender = &ldquo;male&rdquo;<br />
people.age = 25</p>

<p>也可以用成员变量写控制符attr_writer来达到同样的效果。<br />
class Person<br />
attr_writer :name, :gender, :age<br />
end</p>

<p>我们也可以使用attr_accessor来说明成员变量既可以读，也可以写。<br />
class Person<br />
attr_accessor :name, :gender, :age<br />
end</p>

<p>也可以使用attr控制符来控制变量是否可读写。attr 只能带一个符号参数， 第二个参数是一个 bool
参数，用于指示是否为符号参数产生写方法。它的默认值是 false，只产生读方法，不产生写方法。<br />
class Person<br />
attr :name, true #读写<br />
attr :gender, true #读写<br />
attr :age, true #读写<br />
attr :id, false #只读<br />
end</p>

<p>注意attr_reader，attr_writer，attr_accessor和attr不是语言的关键字，而是Module模块的方法。</p>

<p>class Test<br />
attr_accessor :value<br />
end<br />
puts Test.instance_methods - Test.superclass.public_methods</p>

<p>执行结果为：<br />
value<br />
value=</p>

<p>上面代码中，我们使用Test.instance_methods得到Test类所有的实例方法，使用Test.superclass.public_methods得到Test父类所有的实例方法，然后相减就得到Test类不包含父类的所有的实例方法。<br />
由于instance_methods方法返回值为一个Array，所以我们作差值运算，Array的具体操作后面章节会讲到。</p>

<p>也可以重定义方法，重定义一个方法时，新的定义会覆盖原有的定义。</p>

<p>下面的例子重定义类中的方法meth1，<br />
class Test<br />
def meth1<br />
puts &ldquo;This is meth1&rdquo;<br />
end<br />
end</p>

<p>a = Test.new<br />
a.meth1</p>

<p>class Test<br />
def meth1<br />
puts &ldquo;This is new meth1&rdquo;<br />
end<br />
end</p>

<p>a. meth1</p>

<p>执行结果为：<br />
This is meth1<br />
This is new meth1</p>

<p>重定义同一个类时，意味着对原有定义进行补充，不会覆盖原来的定义。而重定义方法时，则会覆盖原有定义。</p>

<p>我们可以使用self标识本身，self和Java中的this有些类似，代表当前对象。<br />
class Person<br />
def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
end</p>

<p>def &lt;=&gt;(other)<br />
self.age &lt;=&gt; other.age<br />
end<br />
end</p>

<p>&lt;=&gt; 方法通常意思为比较，返回值为-1，0或1分别表示小于，等于和大于。<br />
§3.3 继承<br />
Ruby继承的语法很简单，使用 &lt; 即可。<br />
class Student &lt; Person<br />
def initialize(name, gender, age, school)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
@school = school<br />
end<br />
end</p>

<p>Ruby语言只支持单继承，每一个类都只能有一个直接父类。这样避免了多继承的复杂度。但同时，Ruby提供了mixin的机制可以用来实现多继承。</p>

<p>可以使用super关键字调用对象父类的方法，当super省略参数时，将使用当前方法的参数来进行调用。<br />
class Base<br />
def meth(info)<br />
puts &ldquo;This is Base #{info}&rdquo;<br />
end<br />
end</p>

<p>class Derived &lt; Base<br />
def meth(info)<br />
puts &ldquo;This is derived #{info}&rdquo;<br />
super<br />
end<br />
end</p>

<p>obj1 = Derived.new<br />
obj1.meth(&ldquo;test&rdquo;)</p>

<p>执行结果为：<br />
This is derived test<br />
This is Base test</p>

<p>如果传入的参数被修改再调用super的话，那么将会使用使用修改后的值。</p>

<p>class Base<br />
def meth(info)<br />
puts &ldquo;This is Base #{info}&rdquo;<br />
end<br />
end</p>

<p>class Derived &lt; Base<br />
def meth(info)<br />
puts &ldquo;This is derived #{info}&rdquo;<br />
info = &ldquo;over&rdquo;<br />
super<br />
end<br />
end</p>

<p>obj1 = Derived.new<br />
obj1.meth(&ldquo;test&rdquo;)</p>

<p>执行结果为：<br />
This is derived test<br />
This is Base over<br />
§3.4 特殊方法与特殊类<br />
特殊方法是指某实例所特有的方法。一个对象有哪些行为由对向所属的类决定，但是有时候，一些特殊的对象有何其他对象不一样的行为，在多数程序设计语言中，例如C++和Java，我们必须定义一个新类，但在Ruby中，我们可以定义只从属于某个特定对象的方法，这种方法我们成为特殊方法(Singleton
Method)。</p>

<p>class SingletonTest<br />
def info<br />
puts &ldquo;This is This is SingletonTest method&rdquo;<br />
end<br />
end</p>

<p>obj1 = SingletonTest.new<br />
obj2 = SingletonTest.new</p>

<p>def obj2.info<br />
puts &ldquo;This is obj2&rdquo;<br />
end</p>

<p>obj1.info<br />
obj2.info</p>

<p>执行结果为：<br />
This is This is SingletonTest method<br />
This is obj2</p>

<p>有时候，我们需要给一个对象定义一系列的特殊方法，如果按照前面的方法，那么只能一个一个定义：</p>

<p>def obj2.singleton_method1<br />
end</p>

<p>def obj2.singleton_method2<br />
end</p>

<p>def obj2.singleton_method3<br />
end<br />
……<br />
def obj2.singleton_methodn<br />
end</p>

<p>这样做非常繁复麻烦，而且无法给出一个统一的概念模型，因此Ruby提供了另外一种方法，<br />
class &lt;&lt; obj<br />
……<br />
end</p>

<p>obj是一个具体的对象实例，class &lt;&lt; 代表它的特殊类。</p>

<p>class SingletonTest<br />
def meth1<br />
puts &ldquo;This is meth1&rdquo;<br />
end</p>

<p>def meth2<br />
puts &ldquo;This is meth2&rdquo;<br />
end<br />
end</p>

<p>obj1 = SingletonTest.new<br />
obj2 = SingletonTest.new</p>

<p>class &lt;&lt; obj2<br />
def meth1<br />
puts &ldquo;This is obj2&rsquo;s meth1&rdquo;<br />
end</p>

<p>def meth2<br />
puts &ldquo;This is obj2&rsquo;s meth2&rdquo;<br />
end<br />
end</p>

<p>obj1.meth1<br />
obj1.meth2<br />
obj2.meth1<br />
obj2.meth2</p>

<p>执行结果为：<br />
This is meth1<br />
This is meth2<br />
This is obj2&rsquo;s meth1<br />
This is obj2&rsquo;s meth2</p>

<p>§3.5 类变量与类方法<br />
类变量被一个类的所有实例对象共享，也可以被类方法访问到。类变量名以‘@@’，开始，例如‘@@number’。和全局变量，实例变量不同，类变量在使用前必须初始化：<br />
class Person<br />
@@number = 0 #使用前必须有初值<br />
def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
@@number += 1<br />
end<br />
end</p>

<p>类变量是私有的，在类外无法直接访问，你只能通过实例方法和类方法去访问它。</p>

<p>同样，类方法是属于一个类的方法，定义类方法时需要在方法前加上类名：<br />
class Person<br />
@@number = 0</p>

<p>def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
@@number += 1<br />
end</p>

<p>def Person.getNumber #类方法<br />
return @@number<br />
end<br />
end</p>

<p>除了Person.getNumber这种方式定义类方法外，还可以使用其它方式定义类方法，在后续章节可以陆续见到。</p>

<p>§3.4 存取控制<br />
当你设计一个类时，你需要决定哪些属性和方法可以在类外被访问到，哪些属性和方法在类外被隐藏。如果一个类有过多的属性和方法在类外可以被访问到，那么势必破坏这个类的封装性。幸运的是在Ruby中，只能通过方法去改变一个类的属性，这样我们只需要考虑方法的存取控制。<br />
方法的存取控制有三种：<br />
 公有方法(Public Method)<br />
 方法在任何地方都可以被调用，这是方法的默认存取控制。除了initialize和initialize_cpoy方法，他们永远是私有方法。<br />
 保护方法(Protected Method)<br />
 方法只能被定义这个方法的类自己的对象和这个类的子类的对象所访问。<br />
 私有方法(private Method)<br />
 方法只能被定义这个方法的类的对象自己访问，即使是这个类的其他对象也不能访问。</p>

<p>Ruby中的保护方法和私有方法与一般面向对象程序设计语言的概念有所区别，保护方法的意思是方法只能方法只能被定义这个方法的类自己的对象和子类的对象访问，私有方法只能被对象自己访问。</p>

<p>class Test<br />
def method1 #默认为公有方法<br />
…<br />
end</p>

<p>protected #保护方法<br />
def method2<br />
…<br />
end</p>

<p>private #私有方法<br />
def method3<br />
end</p>

<p>public<br />
def test_protected(arg) #arg是Test类的对象<br />
arg.method2 #正确，可以访问同类其他对象的保护方法<br />
end</p>

<p>def test_private(arg) #arg是Test类的对象<br />
arg.method3 #错误，不能访问同类其他对象的私有方法<br />
end<br />
end</p>

<p>obj1 = Test.new<br />
obj2 = Test.new</p>

<p>obj1.test_protected(obj2)<br />
obj1.test_private(obj2)</p>

<p>可以看到，和C++/Java相比，Ruby提供了更好的封装性。</p>

<p>也可以使用以下更简单的形式：<br />
class Test<br />
def method1<br />
&hellip;<br />
end</p>

<p>def method2<br />
&hellip;<br />
end</p>

<p>def method3<br />
&hellip;<br />
end</p>

<p>def methdo4<br />
&hellip;<br />
end</p>

<p>public :method1<br />
protected :method2<br />
private :method3, :method4<br />
end</p>

<p>Ruby和C++/Java的一个显著不同是存取控制是程序运行时决定的而不是静态绑定的。所以只有在访问一个受限制的方法时才会产生运行时错误。</p>

<p>§3.6 元类<br />
在Ruby中一切都是对象。类和实例对象都是对象。这句话听起来有点拗口，让我们来看一个例子：<br />
class Person<br />
def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
end<br />
end<br />
a = Person.new(&lsquo;Tom&rsquo;, &lsquo;male&rsquo;, 15)</p>

<p>puts a.object_id =&gt; 22429840<br />
puts Person.object_id =&gt; 22429960</p>

<p>没错，类也是对象，这是Ruby和C++/Java的一个显著不同，在C++/Java中，类仅仅是一个数据抽象，并没有类也是对象这样的概念。而在Ruby中存在着元类的概念，类也是对象，所有类都是元类的实例对象。和C++/Java相比，Ruby的面向对象程度更高。<br />
可以看到，类对象和实例对象一样有自己的ojbect_id，你可以象调用一个实例对象的方法一样去用它去调用类方法。所有类对象的类是Class类，Oject类是所有类的基类。<br />
irb(main):003:0&gt; Object.class<br />
=&gt; Class<br />
irb(main):004:0&gt; Object.superclass<br />
=&gt; nil</p>

<p>这样，我们可以从另一个角度去理解类变量与类方法，类变量就是一个类对象的实例变量，类方法就是指一个类对象类的特殊方法。<br />
类方法具体可分为两种：第一种是在所有的类的父类Class中定义的，且被所有的类所共享的方法；第二种是各个类所特有的特殊方法。<br />
类方法中的self指的是类本身，这点需要牢记，这样我们可以使用多种方式定义类方法。</p>

<p>class Test<br />
#定义类方法方式1<br />
def Test.meth1</p>

<h1 id="toc_0">&hellip;</h1>

<p>end</p>

<p>#定义类方法方式2<br />
def self.meth2</p>

<h1 id="toc_1">&hellip;</h1>

<p>end</p>

<p>#定义类方法方式3<br />
class &lt;&lt; Test<br />
def meth3</p>

<h1 id="toc_2">&hellip;</h1>

<p>end<br />
end</p>

<p>#定义类方法方式4<br />
class &lt;&lt; self<br />
def meth4</p>

<h1 id="toc_3">&hellip;</h1>

<p>end<br />
end<br />
end</p>

<p>§3.7 Ruby的动态性<br />
可以重新定义同一个方法，<br />
class RedefTest<br />
def meth<br />
puts &ldquo;This is meth&rdquo;<br />
end<br />
end</p>

<p>obj1 = RedefTest.new<br />
obj1.meth</p>

<p>class RedefTest<br />
def meth<br />
puts &ldquo;This is new meth&rdquo;<br />
end<br />
end</p>

<p>obj1.meth</p>

<p>执行结果为：<br />
This is meth<br />
This is new meth</p>

<p>可以使用undef_method取消一个方法的定义，</p>

<p>class UndefTest<br />
def meth<br />
puts &ldquo;This is meth&rdquo;<br />
end<br />
end</p>

<p>obj1 = UndefTest.new<br />
obj1.meth</p>

<p>class UndefTest<br />
undef_method(:meth)<br />
end</p>

<p>obj1.meth</p>

<p>执行结果为：<br />
This is meth<br />
test.rb:14: undefined method `meth&rsquo; for #<0x2ac8240> (NoMethodError)</p>

<p>§3.8 变量<br />
变量名长度只受内存大小的限制。可以通过区分Ruby变量名的首字符来区分它是局部变量、实例变量、类变量、全局变量还是常量。通常情况下，变量名的第二位字符以后是数字、字母或下划线，但有的内部变量名比较特殊，如“$？”。</p>

<p>§3.8.1 局部变量<br />
局部变量以小写字母或下划线开始。</p>

<p>num = 1<br />
foo</p>

<p>局部变量的作用域起始于声明处，结束于该声明所在的块、方法定义、类／模块定义的结尾。</p>

<p>2.times {<br />
p defined?(num)<br />
num = 10<br />
p num<br />
}</p>

<p>输出为：<br />
nil<br />
10<br />
nil<br />
10</p>

<p>即使声明部分未被解释器执行仍有效，因为已经经过解释器的处理。</p>

<p>v = 1 if false<br />
p defined?(v)<br />
p v</p>

<p>输出为：<br />
&ldquo;local-variable&rdquo;<br />
nil</p>

<p>但若块已经变成过程对象的话，则局部变量将一直持续到该过程对象终结为止。若多个过程对象引用同一个作用域的话，局部变量将被这些对象所共享。<br />
(to-do例子)</p>

<p>§3.8.2 实例变量<br />
以@开始的变量是实例变量，实例变量属于特定的对象。<br />
class Person<br />
def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
end<br />
end</p>

<p>上面的例子中，@name， @gender，@age都是实例变量。可以在类或子类的方法中引用实例变量。若引用尚未被初始化的实例变量的话，其值为nil。</p>

<p>§3.8.3 类变量<br />
以@@开始的变量是类变量。类变量在类的定义中定义，可以在类的特殊方法、实例方法等处对类变量进行赋值和引用。类变量被类，类的子类和他们的实例对象共享。<br />
class Person<br />
@@number = 0 #使用前必须有初值<br />
def initialize(name, gender, age)<br />
@name = name<br />
@gender = gender<br />
@age = age<br />
@@number += 1<br />
end<br />
end</p>

<p>类变量是私有的，在类外无法直接访问，你只能通过实例方法和类方法去访问它。可以把类变量看作一种被类、子类以及它们的实例所共享的全局变量。<br />
模块中定义的类变量(模块变量)被所有包含该模块的类所共享。<br />
module TestModule<br />
@@foo = 10<br />
end<br />
class Klass<br />
include Foo<br />
p @@foo += 1 # =&gt; 11<br />
end<br />
class Base<br />
include Foo<br />
p @@foo += 2 # =&gt; 12<br />
end</p>

<p>§3.8.4 全局变量<br />
以$开始的变量是全局变量，全局变量可以在程序的任何地方加以引用。全局变量无需变量声明。引用尚未初始化的全局变量时，其值为nil。<br />
Ruby运行时环境预定义了一系列的全局变量，有关预定义的全局变量的信息，请参见附表。</p>

<p>§3.8.5 常量<br />
常量以大写字母开始，常数的定义和初始化由赋值过程完成。<br />
PI = 3.14<br />
E = 2.71<br />
若对已定义的常数进行赋值的话，会出现警告信息。若引用未定义的常数会引发NameError异常。<br />
PI = 3.14<br />
obj1 = 2 * PI * 10<br />
PI = 3.1415 # warning: already initialized constant PI<br />
obj2 = Foo #uninitialized constant Foo (NameError)</p>

<p>常量可以定义在类和模块中，不能定义在方法中。</p>

<p>class Meth<br />
PI = 3.14 #OK<br />
end</p>

<p>def circle_area(arg)<br />
PI = 3.14 #ERROR<br />
PI * arg * arg<br />
end</p>

<p>若想在外部访问类或模块中的常数时，要使用“：：”操作符。</p>

<p>class Meth<br />
PI = 3.14<br />
end</p>

<p>def circle_area(arg)<br />
Math::PI * arg * arg<br />
end</p>

<p>在类定义表达式生成类对象的同时，还会将类对象赋值给一个与该类同名的常数，引用类名也就是引用该常数。<br />
class Test<br />
end</p>

<p>p Test.class #Class<br />
p Test #test</p>

<p>若想访问Object类中的常数(顶层的常数)时，也需要也使用&rdquo;::&ldquo;操作符，但操作符左边为空。</p>

<p>§3.8 与定义有关的操作<br />
§3.8.1 alias<br />
Alias关键字给方法或全局变量添加别名。可以给方法名指定一个标识符或Symbol作为别名。给方法添加别名时，别名方法将和此刻的原始方法绑定，此后即使重新定义了原始方法，别名方法仍然保持着重定义前的老方法的特性。若改变了某方法的内容后，又想使用修改前的方法时，别名会很有用。也可以使用Module#alias_method给方法添加别名。</p>

<h1 id="定义meth方法">定义meth方法</h1>

<p>def meth<br />
puts &ldquo;This is meth&rdquo;<br />
end</p>

<p>#设定别名<br />
alias :orig_meth :meth</p>

<p>#重定义foo<br />
def meth<br />
puts &ldquo;This is new meth&rdquo;<br />
end</p>

<p>p meth</p>

<p>执行结果为：<br />
This is new meth<br />
nil</p>

<p>给全局变量设定别名意味两个名称指向同一个全局变量。当你向一个赋值时，另一个也会被改变。</p>

<p>$abc = 1<br />
alias $xyz $abc<br />
$xyz = 2<br />
p [$abc, $xyz] # =&gt; [2, 2]</p>

<p>但是不能给正则表达式中的变量$1，$2等添加别名，另外,有些全局变量对于解释器来说是举足轻重的，若重新定义它们的话，有时会影响解释器的正常工作。</p>

<p>§3.8.2 undef<br />
undef用来取消一个方法的定义，也可以使用Module#undef_method方法取消方法的定义。undef会取消方法名和方法定义之间的关系，即使超类中有同名方法，调用时也会引发异常。</p>

<p>class Base<br />
def meth<br />
puts &ldquo;This is Base#meth&rdquo;<br />
end<br />
end</p>

<p>class Derived &lt; Base<br />
def meth<br />
puts &ldquo;This is Derived#meth&rdquo;<br />
end<br />
end</p>

<p>class Test1 &lt; Derived<br />
def meth<br />
puts &ldquo;This is Test1#meth&rdquo;<br />
end</p>

<p>undef_method(:meth)<br />
end</p>

<p>obj1 = Test1.new<br />
obj1.meth</p>

<p>执行结果为：<br />
Tes1.rb:22: undefined method `meth&rsquo; for #<0x2ac7c88> (NoMethodError)</p>

<p>而Module#remove_method方法只负责取消当前类中方法名和方法定义之间的关系，父类的同名方法仍可调用，这点差别非常重要。<br />
class Base<br />
def meth<br />
puts &ldquo;This is Base#meth&rdquo;<br />
end<br />
end</p>

<p>class Derived &lt; Base<br />
def meth<br />
puts &ldquo;This is Derived#meth&rdquo;<br />
end<br />
end</p>

<p>class Test2 &lt; Derived<br />
def meth<br />
puts &ldquo;This is Test2#meth&rdquo;<br />
end</p>

<p>remove_method(:meth)<br />
end</p>

<p>obj2 = Test2.new<br />
obj2.meth</p>

<p>执行结果为：<br />
This is Derived#meth</p>

<p>用alias添加别名或用undef取消定义时，会修改类的接口，而不受父类的限制。继承和Mix-
in的功能都是在类中添加方法，而undef则可以取消方法。但是，如果取消了类所必需的方法(被其他方法所调用的方法)的话，其后果不堪设想。</p>

<p>§3.8.3 defined?<br />
Defined?用来判断表达式是否定义。若表达式尚未定义，则返回nil，若已经定义，则返回一个字符串描述该表达式的种类。</p>

<p>defined? Val #=&gt; nil<br />
defined? true #=&gt; “true”<br />
defined? $* #=&gt; &ldquo;global-variable&rdquo;<br />
defined? Array #=&gt; &ldquo;constant&rdquo;<br />
defined? Math::PI #=&gt; &ldquo;constant&rdquo;<br />
defined? num = 0 #=&gt; &ldquo;assignment&rdquo;<br />
defined? 100 #=&gt; &ldquo;expression&rdquo;<br />
defined? 100.times #=&gt; &ldquo;method&rdquo;</p>

<p>虽然defined?看起来像一个方法，实际上是Ruby语法中的操作符，因此不会对参数进行计算。因此下面的表达式并不会输出“abc”。<br />
defined? print(&ldquo;abc\n&rdquo;)</p>

<p>如果是方法未定义，或方法使用undef或Module#remove_method取消了原有定义，defined?都将返回nil。<br />
注意如果一个方法以大写字母开头，使用defined? 判断时需要在方法名后添加&rdquo;()&ldquo;时，否则方法名会被当做常数处理。<br />
def Foo(arg)<br />
end</p>

<p>p defined? Foo # =&gt; nil<br />
p defined? Foo() # =&gt; &ldquo;method&rdquo;</p>

<p>Foo = 1<br />
p defined? Foo # =&gt; &ldquo;constant&rdquo;</p>

<p>还可以使用下列特殊用法：</p>

<p> 判断yield是否可用<br />
defined? yield<br />
若yield调用可用，则返回真，具体返回值为字符串&rdquo;yield&rdquo;。它的作用同block_given?一样，可以判断能否以带块方式来调用某方法。<br />
class Base<br />
def foo<br />
puts defined? yield<br />
end<br />
end</p>

<p>a = Base.new<br />
a.foo<br />
a.foo {}</p>

<p>执行结果为：<br />
nil<br />
yield</p>

<p> 判断super是否可用<br />
defined? super<br />
若super可被调用，则返回真， 具体返回值为字符串&rdquo;super&rdquo;。</p>

<p>class Base<br />
def foo<br />
end<br />
end</p>

<p>class Derived &lt; Base<br />
def foo<br />
puts defined? super<br />
end</p>

<p>def fun<br />
puts defined? super<br />
end<br />
end</p>

<p>obj = Derived.new<br />
obj.foo<br />
obj.fun</p>

<p>执行结果为：<br />
super<br />
nil</p>

<p> 返回没有赋值但已经定义的局部变量.</p>

<p>defined? a = 1 #=&gt; assignment<br />
p a # =&gt; nil</p>

<p> 在正则表达式中使用<br />
/(.)/ =~ &ldquo;foo&rdquo;<br />
p defined? $&amp; # =&gt; &ldquo;$&amp;&rdquo;<br />
p defined? $1 # =&gt; &ldquo;$1&rdquo;<br />
p defined? $2 # =&gt; nil</p>

<p>第四章 基本类型<br />
§4.1 Array<br />
Array也称作数组，是一系列元素的有序集合。你可以显式使用Array类的new方法来创建一个数组对象，你也可以用方括号包围起来一些以逗号分隔的数字或字符串构成一个数组。</p>

<p>irb(main):007:0&gt; a = [ &ldquo;first&rdquo; &ldquo;second&rdquo; &ldquo;third&rdquo; ]<br />
=&gt; [&ldquo;firstsecondthird&rdquo;]<br />
irb(main):008:0&gt; a = [ &ldquo;first&rdquo;, &ldquo;second&rdquo;, &ldquo;third&rdquo; ]<br />
=&gt; [&ldquo;first&rdquo;, &ldquo;second&rdquo;, &ldquo;third&rdquo;]<br />
irb(main):009:0&gt; a.class<br />
=&gt; Array<br />
irb(main):010:0&gt; a.length<br />
=&gt; 3<br />
irb(main):011:0&gt; a[0]<br />
=&gt; &ldquo;first&rdquo;<br />
irb(main):012:0&gt; a[1]<br />
=&gt; &ldquo;second&rdquo;<br />
irb(main):013:0&gt; a[2]<br />
=&gt; &ldquo;third&rdquo;<br />
irb(main):014:0&gt; a[3]<br />
=&gt; nil<br />
irb(main):015:0&gt; b = Array.new<br />
=&gt; []<br />
irb(main):016:0&gt; b.class<br />
=&gt; Array<br />
irb(main):017:0&gt; b.length<br />
=&gt; 0<br />
irb(main):018:0&gt; b[0] = &ldquo;first&rdquo;<br />
=&gt; &ldquo;first&rdquo;<br />
irb(main):019:0&gt; b[1] = &ldquo;second&rdquo;<br />
=&gt; &ldquo;second&rdquo;<br />
irb(main):020:0&gt; b<br />
=&gt; [&ldquo;first&rdquo;, &ldquo;second&rdquo;]</p>

<p>数组可以使用 [] 来索引，其实 []
是Array类的一个方法，它甚至可以被子类覆盖(overridden)。Ruby中比较有趣的是有多种对数组的索引方法，你可以用负数来索引数组。负数表示从尾部开始，例如索引为-1表示最后一个元素，索引为-2表示倒数第二个元素，以此类推。</p>

<p>irb(main):021:0&gt; a = [ 1, 2, 3, 4, 5]<br />
=&gt; [1, 2, 3, 4, 5]<br />
irb(main):022:0&gt; a[-1]<br />
=&gt; 5<br />
irb(main):023:0&gt; a[-2]<br />
=&gt; 4<br />
irb(main):024:0&gt; a[-9]<br />
=&gt; nil</p>

<p>你也可以使用一对数来索引数组，第一个数表示开始位置，第二数表示从开始位置起的元素数目。</p>

<p>irb(main):025:0&gt; a = [ 1, 2, 3, 4, 5]<br />
=&gt; [1, 2, 3, 4, 5]<br />
irb(main):026:0&gt; a[1, 3]<br />
=&gt; [2, 3, 4]<br />
irb(main):027:0&gt; a[3, 1]<br />
=&gt; [4]<br />
irb(main):028:0&gt; a[-3, 1]<br />
=&gt; [3]</p>

<p>你甚至可以用一个范围来索引数组，.. 表示包含尾部元素，&hellip; 表示不包含尾部元素。</p>

<p>irb(main):029:0&gt; a = [ 1, 2, 3, 4, 5]<br />
=&gt; [1, 2, 3, 4, 5]<br />
irb(main):030:0&gt; a[1..3]<br />
=&gt; [2, 3, 4]<br />
irb(main):031:0&gt; a[1&hellip;3]<br />
=&gt; [2, 3]</p>

<p>§4.2 Hash<br />
Hash也称作哈希表哈希表，类似于数组但是每个元素都有索引，有时候也被称作关联数组，哈希数组或字典。哈希表和数组不同，数组只能使用数字索引，而哈希表则可以使用任何对象索引。哈希表和数组的另一个显著不同是哈希表中的元素是无序的。在Ruby中每个哈希表都是Hash类的对象。<br />
在哈希表中，我们称索引为Key，被索引的元素称为Value。<br />
我们可以使用=&gt;连接的元素来创建一个哈希表，注意哈希表外部是使用大括号包围。</p>

<p>irb(main):032:0&gt; h = { &ldquo;first&rdquo; =&gt; &ldquo;Amy&rdquo;, &ldquo;second&rdquo; =&gt; &ldquo;Mike&rdquo;, &ldquo;third&rdquo; =&gt; &ldquo;Tom&rdquo;
}<br />
=&gt; {&ldquo;third&rdquo;=&gt;&ldquo;Tom&rdquo;, &ldquo;second&rdquo;=&gt;&ldquo;Mike&rdquo;, &ldquo;first&rdquo;=&gt;&ldquo;Amy&rdquo;}<br />
irb(main):033:0&gt; h.length<br />
=&gt; 3<br />
irb(main):034:0&gt; h[&ldquo;first&rdquo;]<br />
=&gt; &ldquo;Amy&rdquo;<br />
irb(main):035:0&gt; h[&lsquo;second&rsquo;]<br />
=&gt; &ldquo;Mike&rdquo;<br />
irb(main):036:0&gt; h[100] = &ldquo;Henry&rdquo;<br />
=&gt; &ldquo;Henry&rdquo;<br />
irb(main):037:0&gt; h[&ldquo;nine&rdquo;] = &ldquo;Rose&rdquo;<br />
=&gt; &ldquo;Rose&rdquo;<br />
irb(main):038:0&gt; h<br />
=&gt; {&ldquo;third&rdquo;=&gt;&ldquo;Tom&rdquo;, &ldquo;second&rdquo;=&gt;&ldquo;Mike&rdquo;, 100=&gt;&ldquo;Henry&rdquo;, &ldquo;first&rdquo;=&gt;&ldquo;Amy&rdquo;,
&ldquo;nine&rdquo;=&gt;&ldquo;Rose&rdquo;}</p>

<p>§4.3 Number<br />
Ruby支持整数类型和浮点数类型。整数可以是任意长度(这个长度只和内存大小有关)。在一定范围内的整数被视为Fixnum类的对象。超出这个范围的整数被视为Bignum类的对象。</p>

<p>num = 81</p>

<p>6.times do<br />
puts &ldquo;#{num.class}: #{num}&rdquo;<br />
num *= num<br />
end</p>

<p>运行结果：<br />
Fixnum: 81<br />
Fixnum: 6561<br />
Fixnum: 43046721<br />
Bignum: 1853020188851841<br />
Bignum: 3433683820292512484657849089281<br />
Bignum: 11790184577738583171520872861412518665678211592275841109096961</p>

<p>和C/C++相同，Ruby规定以0开头的数为八进制数，以0x开头的数为十六进制数，以0b开头的数为二进制数。</p>

<p>irb(main):001:0&gt; 16<br />
=&gt; 16<br />
irb(main):002:0&gt; 020<br />
=&gt; 16<br />
irb(main):003:0&gt; 0x10<br />
=&gt; 16<br />
irb(main):004:0&gt; 0b10000<br />
=&gt; 16</p>

<p>一个数中间可以用下划线连接，下划线自动被忽略。</p>

<p>irb(main):005:0&gt; 123_456_789<br />
=&gt; 123456789</p>

<p>可以使用&rdquo;?\C-x&rdquo;或&rdquo;?\cx&rdquo;生成控制字符。</p>

<p>如果一个数包含小数点或者包含&rdquo;e&rdquo;，那么这个数将被转为Float类的对象。</p>

<p>irb(main):012:0&gt; 1.0.class<br />
=&gt; Float<br />
irb(main):013:0&gt; 1.0e3.class<br />
=&gt; Float<br />
§4.4 String<br />
String也称作字符串，是单引号或双引号包围起来的一串字符。单引号和双引号的意义有所不同，双引号包围的字符作变量替换，单引号包围的变量不做替换。可以在字符串中使用
#{expr} 嵌入代码。</p>

<p>irb(main):022:0&gt; &ldquo;The seconds in a day is: #{24*60*60}&rdquo;<br />
=&gt; &ldquo;The seconds in a day is: 86400&rdquo;<br />
irb(main):023:0&gt; &lsquo;The seconds in a day is: #{24*60*60}&rsquo;<br />
=&gt; &ldquo;The seconds in a day is: \#{24*60*60}&rdquo;</p>

<p>也可以使用 %q 和 %Q 来生成字符串对象。%q 相当于单引号，%Q相当于双引号。</p>

<p>irb(main):051:0&gt; %q/Single quote/<br />
=&gt; &ldquo;Single quote&rdquo;<br />
irb(main):052:0&gt; %Q/Double quote/<br />
=&gt; &ldquo;Double quote&rdquo;<br />
irb(main):053:0&gt; %q/ #{50*50} /<br />
=&gt; &ldquo; \#{50*50} &ldquo;<br />
irb(main):054:0&gt; %Q/ #{50*50} /<br />
=&gt; &ldquo; 2500 &ldquo;</p>

<p>%q 和 %Q 后面的第一个字符为分隔符。二哥分隔符之间的字符被认为一个是字符串。但是如果这个分隔符是 [ { 。</p>

<p>irb(main):055:0&gt; %q{This is a string}<br />
=&gt; &ldquo;This is a string&rdquo;<br />
irb(main):056:0&gt; %Q[This is a string]<br />
=&gt; &ldquo;This is a string&rdquo;<br />
irb(main):057:0&gt; %q<br />
=&gt; &ldquo;This is a string&rdquo;</p>

<p>你也可以使用“Here Document”的方法来生成字符串，这种方法规定 &lt;&lt; 之后的字符串作为结束标志。<br />
string = &lt; With publication started in June 1948 and a current circulation of
3 million,<br />
People&rsquo;s Daily is the most influential and authoritative newspaper in China.<br />
According to UNESCO, it takes its place among the world top 10.<br />
END_OF_STRING</p>

<p>需要注意，表示结尾的END_OF_STRING必须放在行首。<br />
§4.5 Range<br />
Range也称作范围，用来表示一个都是连续的值的序列。可以使用 .. 和 &hellip;
操作符来产生Range，前者表示包含最后一个元素，后者表示不包含最后一个元素。Range对象所属的类是Range。注意Range和Array是不同的，可以使用Range类的to_a方法将一个Range对象转化为Array对象。</p>

<p>irb(main):003:0&gt; (1..10).to_a<br />
=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br />
irb(main):004:0&gt; (&lsquo;bar&rsquo;..&lsquo;bat&rsquo;).to_a<br />
=&gt; [&ldquo;bar&rdquo;, &ldquo;bas&rdquo;, &ldquo;bat&rdquo;]<br />
irb(main):005:0&gt; (1&hellip;10).to_a<br />
=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>

<p>Range除了表示一个序列外还可以出现在条件语句中。在条件语句中，可以把Range看作一个双向开关，当第一个条件满足时打开开关，当第二个条件满足时关闭开关。<br />
a = [0, 1, 2, 3, 4, 5, 6]<br />
a.each do |i|<br />
print i, &ldquo; &rdquo; if i == 1 .. i == 5<br />
end</p>

<p>执行结果为<br />
1 2 3 4 5</p>

<p>上述代码中if i == 1 .. i ==
5表示只有满足i==1且不满足i==5时条件为真，当不满足i==1或满足i==5时条件为假，直观地看，就是表示元素需要位于范围之中。</p>

<p>可以使用 === 来测试一个元素是否在某个范围：</p>

<p>irb(main):093:0&gt; (1..10) === 3<br />
=&gt; true<br />
irb(main):094:0&gt; (1..10) === 30<br />
=&gt; false<br />
irb(main):095:0&gt; (1..10) === 2.71828<br />
=&gt; true<br />
irb(main):096:0&gt; (&lsquo;a&rsquo;..&lsquo;f&rsquo;) == &lsquo;c&rsquo;<br />
=&gt; false<br />
irb(main):097:0&gt; (&lsquo;a&rsquo;..&lsquo;f&rsquo;) == &lsquo;g&rsquo;<br />
=&gt; false</p>

<p>Range也可以位于case语句之内：</p>

<p>score = 98<br />
case score<br />
when 85..100 then puts &ldquo;A&rdquo;<br />
when 70&hellip;85 then puts &ldquo;B&rdquo;<br />
when 60&hellip;70 then puts &ldquo;C&rdquo;<br />
else puts &ldquo;D&rdquo;<br />
end</p>

<p>执行结果为：<br />
A<br />
§4.6 Symbol<br />
Symbol是个简单的对象，它使用名字作为唯一的标识符。Symbol对象代表解释器内部一个唯一的名字。Symbol的产生很简单，只需要给一个字符序列前添加“：”或使用“to_sym”方法。
Symbol对象从属于Symbol类。<br />
String和Symbol两者具有紧密的联系。每个symbol都有个字符串的名字(可以使用to_s方法得到)。而每个String可以请求它的相应symbol(通过to_sym方法)。String和Symbol是紧密相联的，但它们不是同一个东西，他们分别是String类和Symbol类的对象。<br />
有读者可能会问，为什么要存在Symbol对象呢？因为symbol可以大大提高速度。Symbol的内部表示是一个整数，用来做Hash表中检索字符串的关键字，而Ruby语言执行时解析器、运算器需要大量的类名字、方法名字的检索，这可以大大加快解析和执行时字符串查找的速度。<br />
想想，如果没有Symbol，如果需要用方法名称作为参数时，我们必须给一个字符串用来表示方法的名称，解释器处理时首先要作字符串解析，然后才能找到出相应的方法，而如果使用Symbol会大大加快这一速度。<br />
在使用中，Symbol往往表示一个名字，例如一个变量 foo的值为1，那么 :foo可以理解为变量名，如果直接引用foo，会得到1，但如果是
:foo就指变量名本身。</p>

<p>Symbol对象是唯一的。每次你在代码中使用:test,
你是要引用一个名字为&rdquo;test&rdquo;的Symbol类的对象。Ruby保证系统中只有一个名字为test的Symbol对象,
所以所有对:test的引用都将引用同一个对象。</p>

<p>irb(main):001:0&gt; module One<br />
irb(main):002:1&gt; class Test<br />
irb(main):003:2&gt; end<br />
irb(main):004:1&gt; $f1 = :Test<br />
irb(main):005:1&gt; end<br />
=&gt; :Test<br />
irb(main):006:0&gt; module Two<br />
irb(main):007:1&gt; Test = 1<br />
irb(main):008:1&gt; $f2 = :Test<br />
irb(main):009:1&gt; end<br />
=&gt; :Test<br />
irb(main):010:0&gt; def Test()<br />
irb(main):011:1&gt; end<br />
=&gt; nil<br />
irb(main):012:0&gt; $f3 = :Test<br />
=&gt; :Test<br />
irb(main):013:0&gt; $1.object_id<br />
=&gt; 4<br />
irb(main):014:0&gt; $2.object_id<br />
=&gt; 4<br />
irb(main):015:0&gt; $3.object_id<br />
=&gt; 4</p>

<p>§4.7 正则表达式<br />
正则表达式的类是Regexp，可以使用/或%r生成正则表达式。</p>

<p>irb(main):103:0&gt; a = /\s<em>[a-f]/<br />
=&gt; /\s</em>[a-f]/<br />
irb(main):104:0&gt; a.class<br />
=&gt; Regexp<br />
irb(main):105:0&gt; b = %r{\s<em>[a-f]}<br />
=&gt; /\s</em>[a-f]/<br />
irb(main):106:0&gt; b.class<br />
=&gt; Regexp<br />
irb(main):107:0&gt; c = Regexp.new(&rsquo;\s<em>[a-f]&lsquo;)<br />
=&gt; /\s</em>[a-f]/<br />
irb(main):108:0&gt; c.class<br />
=&gt; Regexp</p>

<p>你可以使用Regexp#match(string)方法或者=~运算符来匹配正则表达式，你也可以使用!~来测试是否不匹配。</p>

<p>irb(main):113:0&gt; sentence = &ldquo;This is a dog.&rdquo;<br />
=&gt; &ldquo;This is a dog.&rdquo;<br />
irb(main):114:0&gt; sentence =~ /dog/<br />
=&gt; 10<br />
irb(main):115:0&gt; sentence =~ /a/<br />
=&gt; 8<br />
irb(main):116:0&gt; /o/ =~ sentence<br />
=&gt; 11<br />
irb(main):117:0&gt; sentence !~ /xyz/<br />
=&gt; true</p>

<p>另外，在匹配正则表达式时，会将匹配到的字符串存放在 $&amp; 变量中，$&rsquo; 变量中存放已经匹配过的字符序列，$` 变量中存放还未匹配的字符序列。</p>

<p>irb(main):118:0&gt; sentence = &ldquo;This is a dog.&rdquo;<br />
=&gt; &ldquo;This is a dog.&rdquo;<br />
irb(main):119:0&gt; sentence =~ /a/<br />
=&gt; 8<br />
irb(main):120:0&gt; puts $&amp;<br />
a<br />
=&gt; nil<br />
irb(main):121:0&gt; puts $&rsquo;<br />
dog.<br />
=&gt; nil<br />
irb(main):122:0&gt; puts $`<br />
This is<br />
=&gt; nil</p>

<p>第五章 代码块和迭代器<br />
§5.1 代码块(Block)<br />
§5.1.1 什么是代码块<br />
在Ruby中在在大括号之间的代码或放在do/end之间的代码是一个代码块。代码块只能出现在一个方法的后边，它紧接在方法最后一个参数的同一行上。代码块的内容并不会被马上执行，当执行到被调用的方法时，解释器的运行时环境会记住代码块出现的现场，然后执行被调用的方法。</p>

<p>[1,2,3,4,5].each { |i|<br />
puts i<br />
}</p>

<p>[1,2,3,4,5].each do |i|<br />
puts i<br />
end</p>

<p>一般的使用习惯是：（to-do 具体解释）<br />
 当关心边际(side effect)效应时使用 do/end。<br />
 当关心返回结果应时使用大括号。</p>

<p>§5.1.2 代码块与对象<br />
代码块并不是对象，但可以方便的转化为Proc类的对象。有三种转化的方法：<br />
 将一个代码块传递给最后一个参数以&amp;开始的方法。<br />
def meth1(p1, p2, &amp;block)<br />
puts block.inspect<br />
puts block.call<br />
end<br />
meth1(1, 2) { &ldquo;This is a block&rdquo; }</p>

<p> 使用Proc.new方法，后边的参数为一个代码块：<br />
block = Proc.new { &ldquo;a block&rdquo; }</p>

<p> 调用Kernel.lambda方法：<br />
block = lambda { &ldquo;a block&rdquo; }</p>

<p>前两种方法是等价的，而第三种方法，用 lambda 生成的 Proc 对象和用 Proc.new 生成的 Proc
对象之间是有差别的。这是一个微妙的差别，这个差别与 return 关键字相关。lambda 中的 return 从 lambda 返回。而 Proc 中的
return 从外围方法返回。<br />
可以看以下两个例子：<br />
def test_proc<br />
p = Proc.new { return 1 }<br />
p.call<br />
puts &ldquo;Never come here&rdquo;<br />
end</p>

<p>test_proc #=&gt; 1</p>

<p>执行后&rdquo;Never come here&rdquo;不会被输出，执行p.call相当于在test_proc方法内执行了return语句。</p>

<p>def test_lambda<br />
p = lambda { return 1 }<br />
result = p.call<br />
puts &ldquo;The value is: #{result}&rdquo;<br />
end</p>

<p>test_lambda</p>

<p>执行后的结果为：<br />
The value is: 1</p>

<p>可见使用lambda生成的Proc对象执行call方法调用时，return表示从lambda包围得块内返回。</p>

<p>在一个代码块中执行next语句会导致代码块返回。返回值就是next语句后带的参数。如果next后没有参数，那么返回值为nil。</p>

<p>def meth2<br />
result = yield<br />
&ldquo;The block result is #{result}&rdquo;<br />
end</p>

<p>puts meth2 { next 9 }</p>

<p>pr = Proc.new { next 100 }<br />
puts pr.call</p>

<p>pr = lambda { next }<br />
puts pr.call</p>

<p>执行结果为：<br />
The block result is 9<br />
100<br />
nil<br />
§5.2 迭代器(Iterator)<br />
§5.2.1 什么是迭代器<br />
简单的讲，一个迭代器就是一个能接受代码块的方法。当初为了进行迭代操作而设置了带块方法，所以现在它仍然常常被称作迭带器。</p>

<p>[1,2,3,4,5].each { |i|<br />
puts i<br />
}<br />
上述代码中，each方法反复调用代码块，我们称each方法为一个迭代器。</p>

<p>迭代器(Iterator)即指调用带块方法。实际上，在早期版本的 Ruby
中，使用代码块的方法被称为迭代器，因为它们就是被设计来实现循环迭代的。但是在Ruby发展过程中，代码块的用途在后来已经得到了很大的增强，从最初的循环抽象到任何事情。可以将那些进行迭代操作的方法叫做迭代器，但如果将所有带块方法的调用过程都看作迭带器的话，并不合适而且概念上会引起混乱</p>

<p>§5.2.2 使用迭代器<br />
#一个使用迭代器的简单例子，数组中每一个元素作为参数执行其后的代码块<br />
[&lsquo;This&rsquo;, &lsquo;is&rsquo;, &lsquo;a&rsquo;, &lsquo;dog&rsquo;].each do |entry|<br />
print entry, &lsquo; &rsquo;<br />
end</p>

<p>执行结果为：<br />
This is a dog</p>

<p>#另一个使用迭代器的例子，代码块可以访问其外的数据<br />
factorial = 1<br />
1.upto(10) do |i|<br />
factorial*= i<br />
end<br />
puts factorial<br />
执行结果为：<br />
3628800</p>

<p>#代码块的返回值可以被调用者使用<br />
b = [1, 2, 3, 4, 5].map do |entry|<br />
entry * entry<br />
end<br />
print b.inspect</p>

<p>执行结果为：<br />
[1, 4, 9, 16, 25]</p>

<p>#代码块也可以使用一个以上的参数<br />
result = (0..100).inject(0) do |sum, i|<br />
sum + i<br />
end<br />
print result</p>

<p>执行结果为：<br />
5050</p>

<p>§5.2.3 yield<br />
在方法中可以使用yield来执行代码块的内容，就好像传入的代码块是这个方法的一部分一样。每当碰到一个yield调用，代码块的内容就会被执行一次。当代码块执行结束后，程序会回到yield的那一行继续向下执行。</p>

<p>def twoTimes<br />
yield<br />
yield<br />
end<br />
twoTimes { puts &ldquo;Hello World!&rdquo; }</p>

<p>执行结果为：<br />
Hello World!<br />
Hello World!</p>

<p>你可以使用yield操作传参数给一个代码块，并且从代码块取回返回值。</p>

<p>def fibonacii(max)<br />
f1, f2 = 1, 1<br />
while f1 &lt;= max<br />
yield f1<br />
f1, f2 = f2, f1+f2<br />
end<br />
end</p>

<p>fibonacii(1000) { |f| print f, &ldquo; &rdquo; }</p>

<p>执行结果为：<br />
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</p>

<p>在这个例子中，yield接收一个参数，这个参数将会在执行的时候传递给指定的代码块。在代码块中，接收的参数使用两个竖线括起来放在代码块的头部。yield操作也可以有返回值，yield操作的返回值就是代码块中最后一个表达式的值。</p>

<p>§5.2.4 编写自己的迭代器<br />
def factorial(count, &amp;block)<br />
value = 1<br />
1.upto(count) do |i|<br />
value = value * i<br />
block.call(i, value)<br />
end<br />
end</p>

<p>factorial(5) do |i, sum|<br />
puts &ldquo;factorial(#{i}) = #{sum}&rdquo;<br />
end</p>

<p>执行结果为：<br />
factorial(1) = 1<br />
factorial(2) = 2<br />
factorial(3) = 6<br />
factorial(4) = 24<br />
factorial(5) = 120</p>

<p>也可以将传入的代码块保存以供以后使用：<br />
class Mathematics<br />
def initialize(&amp;block)<br />
@block = block<br />
end</p>

<p>def factorial(max)<br />
value = 1<br />
1.upto(max) do |i|<br />
value = value * i<br />
@block.call(value)<br />
end<br />
end<br />
end</p>

<p>the_value = Mathematics.new do |count|<br />
puts &ldquo;Current value is #{count}&rdquo;<br />
end</p>

<p>the_value.factorial(5)</p>

<p>执行结果为：<br />
Current value is 1<br />
Current value is 2<br />
Current value is 6<br />
Current value is 24<br />
Current value is 120</p>

<p>第六章 表达式<br />
Ruby语言的一切都有返回值，这是Ruby语言和其他程序设计语言的一个显著不同。<br />
irb(main):006:0&gt; a = b = c = 0<br />
=&gt; 0<br />
irb(main):007:0&gt; print &ldquo;\n&rdquo;</p>

<p>=&gt; nil<br />
同样，if和case语句也有返回值，if和case语句的返回值就是if和case中最后一个执行语句的值。<br />
irb(main):014:0&gt; if( 1+1 == 2)<br />
irb(main):015:1&gt; &ldquo;Like in school.&rdquo;<br />
irb(main):016:1&gt; else<br />
irb(main):017:1* &ldquo;What a surprise!&rdquo;<br />
irb(main):018:1&gt; end<br />
=&gt; &ldquo;Like in school.&rdquo;</p>

<p>§6.1 运算符<br />
和其他程序设计语言一样，Ruby中含有丰富的运算符。但是在Ruby中，大多数运算符实际上是方法调用。例如 a+b，其实真实执行的是
a.+(b)，调用a对象的+方法，b作为这个方法的参数。这样带来了相当的灵活性，你可以改变原有运算符的语义从而赋予它新的含义。</p>

<p>以下代码仅仅作为一个例子重写Fixnum类的 + 方法，赋予两个定长整数相加新的含义。<br />
irb(main):001:0&gt; class Fixnum<br />
irb(main):002:1&gt; alias the_plus +<br />
irb(main):003:1* def +(integer)<br />
irb(main):004:2&gt; the_plus(integer) * 2<br />
irb(main):005:2&gt; end<br />
irb(main):006:1&gt; end<br />
=&gt; nil<br />
irb(main):007:0&gt; 1+1<br />
=&gt; 4<br />
irb(main):032:0&gt; 2+2<br />
=&gt; 8<br />
irb(main):132:0&gt; 2+5<br />
=&gt; 14</p>

<p>对于运算符(+ - * / % ** &amp; | ^ &lt;&lt; &gt;&gt; &amp;&amp; ||),Ruby有相应形式的赋值运算符缩写形式+=, -=等。</p>

<p>运算符优先级：<br />
::<br />
[]<br />
+(一元) -(一元) ! ~<br />
* / %<br />
+ -<br />
&lt;&lt; &gt;&gt;<br />
&amp;<br />
| ^<br />
&gt; &gt;= &lt; &lt;=<br />
&lt;=&gt; == === != =~ !~<br />
&amp;&amp;<br />
||<br />
.. …<br />
?:<br />
= += -= *= /=(所有的赋值运算符缩写)<br />
not<br />
and or</p>

<p>以下运算符不能作为方法调用，也就是说不能改变以下运算符的含义：<br />
…<br />
!<br />
not<br />
&amp;&amp;<br />
And<br />
||<br />
Or</p>

<h1 id="toc_5">::</h1>

<p>+= -= *= /=(所有的赋值运算符缩写)<br />
?:</p>

<p>§6.2 命令替换<br />
在Shell中，可以使用反引号（<code>）执行命令替换。  
</code>date<code>=〉Mon Nov 27 11:07:22 CST 2006  
</code>pwd` =〉/usr/include</p>

<p>Ruby也有这个功能。在Ruby中，可以使用反引号或%x来执行命令替换。命令替换表达式的返回值就是命令执行的输出结果。命令执行的返回值存储在全局变量$?中。<br />
irb(main):2134:0&gt; %x{echo &ldquo;Hello World!&rdquo;}<br />
=&gt; &ldquo;\&ldquo;Hello World!\&rdquo;\n&rdquo;</p>

<p>反引号的默认行为是执行命令替换，同样，我们也可以重写它，赋予它新的含义。<br />
alias old_backquote <code>
def</code>(cmd)<br />
result = old_backquote(cmd)<br />
if $? != 0<br />
fail &ldquo;Command #{cmd} failed: #$?&rdquo;<br />
else<br />
puts &ldquo;Command #{cmd} success.&rdquo;<br />
end<br />
result<br />
end<br />
print <code>date</code><br />
print <code>data</code></p>

<p>执行结果为：<br />
Command date success.<br />
Mon Jan 15 21:48:16 CST 2007<br />
Command uname success.<br />
Linux</p>

<p>§6.3 赋值运算符<br />
to-do 定义。</p>

<p>赋值运算的返回值就是左值的值，所以可以进行链式赋值。<br />
irb(main):001:0&gt; a = b = c = 5<br />
=&gt; 5<br />
irb(main):002:0&gt; a = ( b = 1 + 2 ) + 5<br />
=&gt; 8</p>

<p>Ruby的基本赋值有两种形式，一种左边是一个对象或变量，这时把右边的值或变量的引用赋予左边。这种赋值运算由语言本身提供。<br />
irb(main):003:0&gt; str = &ldquo;This is a dog.&rdquo;<br />
=&gt; &ldquo;This is a dog.&rdquo;<br />
irb(main):004:0&gt; num = 100<br />
=&gt; 100<br />
另一种形式的赋值运算左边是一个类的实例的某一属性，这时候是执行这个类的方法，方法名称为“属性=”。方法的返回值就是右值的值，你可以重写这个方法从而赋予它新的含义。</p>

<p>irb(main):001:0&gt; class Test<br />
irb(main):002:1&gt; def num=(num)<br />
irb(main):003:2&gt; @num = num<br />
irb(main):004:2&gt; end<br />
irb(main):005:1&gt; end<br />
=&gt; nil<br />
irb(main):006:0&gt; t = Test.new<br />
=&gt; #<0x2e20568><br />
irb(main):007:0&gt; t.num = 10<br />
=&gt; 10</p>

<p>§6.4 并行赋值<br />
Ruby中另一个有趣的地方是支持并行赋值。例如，交换两个变量a,b的值可以写为：<br />
a,b = b,a<br />
Ruby会先从左到右依次计算 = 右边的表达式，然后再执行赋值的动作。<br />
irb(main):008:0&gt; x = 0<br />
=&gt; 0<br />
irb(main):009:0&gt; a,b,c = x, x+=1, x+=2<br />
=&gt; [0, 1, 3]</p>

<p>如果左边的变量比右边的多，那么多余的变量会被赋为nil.<br />
irb(main):001:0&gt; x, y, z = 1, 2<br />
=&gt; [1, 2]<br />
irb(main):002:0&gt; print z<br />
nil=&gt; nil</p>

<p>如果右边的变量或值比左边的多，那么多余的会被忽略。<br />
irb(main):001:0&gt; x, y = 1, 2, 3 # 3将被忽略<br />
=&gt; [1, 2, 3]</p>

<p>也可以在数组赋值时使用并行赋值。<br />
irb(main):001:0&gt; a = [1, 2, 3, 4, 5]<br />
=&gt; [1, 2, 3, 4, 5]<br />
irb(main):002:0&gt; x, y = a<br />
=&gt; [1, 2, 3, 4, 5]<br />
irb(main):003:0&gt; puts x, y<br />
1<br />
2<br />
=&gt; nil</p>

<p>在对数组进行并行赋值时可以使用*，*出现在左边最后一个变量时，表示将数组中所有剩余的值赋给这个变量。</p>

<p>irb(main):001:0&gt; a = [1, 2, 3, 4, 5]<br />
=&gt; [1, 2, 3, 4, 5]<br />
irb(main):002:0&gt; x,*y = a<br />
=&gt; [1, 2, 3, 4, 5]<br />
irb(main):003:0&gt; puts x<br />
1<br />
=&gt; nil<br />
irb(main):004:0&gt; puts y<br />
2<br />
3<br />
4<br />
5<br />
=&gt; nil</p>

<p>*出现在右边最后一个变量时，和左边类似。<br />
a = [1, 2, 3, 4]<br />
b, c = 9, a =〉b == 9, c == [1, 2, 3, 4]<br />
b, c = 9, *a =〉b == 9, c == 1<br />
b, *c = 9, a =〉b == 9, c == [[1, 2, 3, 4]]<br />
b, *c = 9, *a =〉b == 9, c == [1, 2, 3, 4]</p>

<p>§6.5 嵌套赋值<br />
在赋值中，左边的变量可以使用括号括起来。这样括号内的变量被视作位于一个层次。<br />
b, (c, d), e = 1,2,3,4 =〉b == 1, c == 2, d == nil, e == 3<br />
b, (c, d), e = [1,2,3,4] =〉b == 1, c == 2, d == nil, e == 3<br />
b, (c, d), e = 1,[2,3],4 =〉b == 1, c == 2, d == 3, e == 4<br />
b, (c, d), e = 1,[2,3,4],5 =〉b == 1, c == 2, d == 3, e == 5<br />
b, (c,*d), e = 1,[2,3,4],5 =〉b == 1, c == 2, d == [3, 4], e == 5</p>

<p>§6.6 其他赋值<br />
Ruby支持自加（+=）和自减运算符。和C/C++/Java一样，a = a + 2可以写成a+=2。其它类似的运算符还有%= ~= /= = += |=
&amp;= &gt;&gt;= &lt;&lt;= *= &amp;&amp;= ||= **=。<br />
我们经常可以遇到类似这样的语句words[key] ||= []，他与words[key] = words[key] ||
[]等价，意思是如果Hash表words[key]的值为空时，对words[key]赋值为一个新建的空数组，否则不变。<br />
相应的，对于<br />
num = 1 if num.nil?<br />
num = 1 unless num<br />
Ruby中习惯写为 num ||= 1，这样代码更简洁。<br />
§6.7 条件运算<br />
布尔运算符<br />
在Ruby中定义nil和false为假，其他值为真。注意，和C/C++不同的是0并不被解释为假，空字符串也一样。<br />
Ruby支持常见的布尔运算符，例如 and和 &amp;&amp;，而且还引入一个新的布尔运算符‘defined？’。</p>

<p>和其他程序设计语言一样，and 和 &amp;&amp; 代表与关系。<br />
or 和 || 代表或关系。<br />
Not 和 ！ 代表非关系。</p>

<p>如果参数没有定义 defined？ 返回nil,否则返回一个描述串用来描述参数信息。<br />
irb(main):013:0&gt; defined? 1<br />
=&gt; &ldquo;expression&rdquo;<br />
irb(main):014:0&gt; defined? dummy<br />
=&gt; nil<br />
irb(main):015:0&gt; defined? printf<br />
=&gt; &ldquo;method&rdquo;<br />
irb(main):016:0&gt; defined? String<br />
=&gt; &ldquo;constant&rdquo;<br />
irb(main):017:0&gt; defined? $_<br />
=&gt; &ldquo;global-variable&rdquo;<br />
irb(main):018:0&gt; defined? Math::PI<br />
=&gt; &ldquo;constant&rdquo;<br />
irb(main):019:0&gt; defined? a = 0<br />
=&gt; &ldquo;assignment&rdquo;<br />
irb(main):020:0&gt; defined? 30.abs<br />
=&gt; &ldquo;method&rdquo;</p>

<p>条件运算符<br />
Ruby支持一系列条件运算符，==， ===， &lt;=&gt;，=~，eql? 等等，equal?。除了&lt;=&gt; 其他的都是类方法。 == 和 =~ 有否定形式 !=
和 !~。</p>

<p>If和unless<br />
Ruby中的if和其他程序设计语言中的if大同小异：<br />
if x == 5 then<br />
print “The value of x is 5.”<br />
elsif x == 0 then<br />
print “The value of x is 0.”<br />
else<br />
print “The value of x is ”, x<br />
end</p>

<p>也可以省略then：<br />
if x == 5<br />
print “The value of x is 5.”<br />
elsif x == 0<br />
print “The value of x is 0.”<br />
else<br />
print “The value of x is ”, x<br />
end</p>

<p>如果为了代码紧凑而将代码放到同一行则不能省略then：<br />
if x == 5 then print “The value of x is 5.”<br />
elsif x == 0 then print “The value of x is 0.”<br />
else print “The value of x is ”, x<br />
end</p>

<p>也可以使用冒号分隔，这样代码更紧凑 :<br />
if x == 5: print “The value of x is 5.”<br />
elsif x == 0: print “The value of x is 0.”<br />
else print “The value of x is ”, x<br />
end</p>

<p>正如我们前面所说的，if是一个表达式，它有自己的返回值。你可以忽略这个返回值，但是他确实存在。If语句的返回值就是最后执行的语句的值。<br />
x = 10<br />
str = if x == 5: &ldquo;x==5&rdquo;<br />
elsif x == 0: &ldquo;x==0&rdquo;<br />
else &ldquo;x==?&rdquo;<br />
end<br />
执行后str的内容为：x== ?</p>

<p>Ruby也支持if的否定形式unless，unless的语法和if没有差别。<br />
unless x != 5<br />
print “The value of x is 5.”<br />
else<br />
print “The value of x is not 5.”<br />
end</p>

<p>Ruby也支持C/C++的 ?:运算符。<br />
str = x == 5? &ldquo;x==5&rdquo;:&ldquo;x==?&rdquo;</p>

<p>Ruby也从Perl那里继承了一个很好的语法，你可以将条件写到表达式的后边。<br />
puts &ldquo;a = #{a}&rdquo; if debug<br />
print total unless total.zero?</p>

<p>§6.8 case表达式<br />
Ruby中的case语句非常强大，首先我们来看一个基本用法：<br />
grade = case<br />
when point &gt;= 85: &lsquo;A&rsquo;<br />
when point &gt;= 70 &amp;&amp; point &lt; 80: &lsquo;B&rsquo;<br />
when point &gt;= 60 &amp;&amp; point &lt; 70: &lsquo;C&rsquo;<br />
when point &lt; 60: &rsquo;D&rsquo;<br />
else &lsquo;E&rsquo;<br />
end<br />
这里case语句的作用和if表达式类似，case语句的返回值就是最后一个执行的表达式的值。和if语句类似，如果写在同一行的话需要加then或冒号。</p>

<p>另一种也是最常用的形式是在case后列出目标，然后每个语句依次和目标比较：<br />
case input_line<br />
when &ldquo;debug&rdquo;<br />
print &ldquo;We are in debug mode.&rdquo;<br />
when /p\s+(\w+)/<br />
dump_variable($1)<br />
when &ldquo;quit&rdquo;, &ldquo;exit&rdquo;<br />
exit<br />
else<br />
print &ldquo;Illegal command: #{input_line}&rdquo;<br />
end</p>

<p>另一个例子：<br />
Season = case month<br />
when 3..5 : &ldquo;Spring&rdquo;<br />
when 6..8 : &ldquo;Summer&rdquo;<br />
when 9..11: &ldquo;Autumn&rdquo;<br />
when 12..2: &ldquo;Winter&rdquo;<br />
else &ldquo;Error&rdquo;<br />
end</p>

<p>Ruby提供了一个运算符===，只要一个类提供了===方法，那这个类的对象就可以出现在case语句中。例如对于正则表达式定义了===为模式匹配。</p>

<p>Ruby中，所有类的基类是Class类，所有类实例都是Class类的实例（to-do）。它定义===的含义为为参数所提供是否为实例的类或父类。<br />
case shape<br />
when Square, Rectangle</p>

<h1 id="toc_6">&hellip;</h1>

<p>when Circle</p>

<h1 id="toc_7">&hellip;</h1>

<p>when Triangle</p>

<h1 id="toc_8">&hellip;</h1>

<p>else</p>

<h1 id="toc_9">&hellip;</h1>

<p>end</p>

<p>§6.9 循环<br />
§6.9.1 Loop<br />
Loop循环始终执行其后的方法块，直到break退出。<br />
x = 0<br />
loop do<br />
x += 1<br />
if x &lt;= 5: print x, &ldquo; &rdquo;<br />
else break<br />
end<br />
end<br />
执行结果为：1 2 3 4 5 。<br />
§6.9.2 While<br />
当条件为真时While循环继续，条件为假时退出循环。<br />
x = 0<br />
while x &lt; 10<br />
x += 1<br />
end</p>

<p>§6.9.3 Until<br />
Until和While厢房当条件为假时While循环继续，条件为真时退出循环。<br />
x = 0<br />
until x == 9<br />
x += 1<br />
end</p>

<p>§6.9.4 Iterator<br />
和C/C++/Java不同，Ruby语言并不支持C/C++/Java中的For循环，但Ruby通过迭代器来提供更为强大的功能。先看一个例子：<br />
4.times do<br />
puts &ldquo;Hello!&rdquo;<br />
end<br />
执行结果为：<br />
Hello!<br />
Hello!<br />
Hello!<br />
Hello!<br />
除了times方法之外，整数还提供upto和downto两个方法，看以下例子，<br />
0.upto(9) do |i|<br />
print i, &ldquo; &rdquo;<br />
end<br />
执行结果为0 1 2 3 4 5 6 7 8 9 。</p>

<p>也可以使用Step方法，step第二个参数表示步长：<br />
0.step(10, 2) do |i|<br />
print i, &ldquo; &rdquo;<br />
end<br />
执行结果为：0 2 4 6 8 10 。</p>

<p>许多容器类，例如数组，提供了each方法依次遍历容器中的数据：<br />
[1, 2, 3, 4, 5].each { |i| print i, &ldquo; &ldquo;}<br />
执行结果为：1 2 3 4 5 。</p>

<p>如果一个类支持each方法，那么就可以使用Enumerable模块中的一些方法。<br />
[&ldquo;apple&rdquo;, &ldquo;orange&rdquo;, &ldquo;banana&rdquo;, &ldquo;watermelon&rdquo;].grep(/an/) do |fruit|<br />
puts fruit<br />
end<br />
执行结果为：<br />
orange<br />
banana</p>

<p>§6.9.5 For..In<br />
如果一个类提供了each方法，那么相应的，这个类的对象可以使用For..in循环。例如Array类和Range类都有each方法：<br />
for fruit in [&ldquo;apple&rdquo;, &ldquo;orange&rdquo;, &ldquo;banana&rdquo;, &ldquo;watermelon&rdquo;]<br />
print fruit, &ldquo; &rdquo;<br />
end<br />
执行结果为：apple orange banana watermelon 。<br />
for i in 1..9<br />
print i, &ldquo; &rdquo;<br />
end<br />
执行结果为：1 2 3 4 5 6 7 8 9 。</p>

<p>§6.9.6 Break，Redo，Next<br />
Break，Redo和Next用来改变循环的流程。</p>

<p>§6.9.6.1 break<br />
Break用来退出当前循环：</p>

<p>times = 0<br />
loop do<br />
times += 1<br />
print &ldquo;hello #{times}\n&rdquo;<br />
break if times &gt; 2<br />
end</p>

<p>执行结果为：<br />
hello 1<br />
hello 2<br />
hello 3</p>

<p>与C/C++不同，如果循环有多重的话，break将退出最内层的循环。<br />
outer = 0<br />
loop do<br />
outer += 1</p>

<p>inner = 0<br />
loop do<br />
inner += 1<br />
print &ldquo;Inner #{inner}\n&rdquo;<br />
break if inner &gt; 1<br />
end</p>

<p>print &ldquo;Outer #{outer}\n&rdquo;<br />
break if outer &gt; 1<br />
end</p>

<p>执行结果为：<br />
Inner 1<br />
Inner 2<br />
Outer 1<br />
Inner 1<br />
Inner 2<br />
Outer 2</p>

<p>另一个与C/C++语言不同的地方是break只能从循环中退出，而不能从case中退出。</p>

<p>§6.9.6.2 redo<br />
redo语句重新执行当前这一次循环。</p>

<p>count = 0</p>

<p>for i in 1..3<br />
print &ldquo;hello #{i}\n&rdquo;<br />
break if count == 1</p>

<p>if i &gt; 1<br />
count += 1<br />
redo<br />
end<br />
end</p>

<p>执行结果为：<br />
hello 1<br />
hello 2<br />
hello 2</p>

<p>上面的例子中，使用redo后，循环变量i的值还是2，可见redo语句重新执行了这次循环。</p>

<p>和break语句类似，redo语句只对最内层的循环起作用。</p>

<p>3.times do<br />
count = 0<br />
for i in 1..3<br />
print &ldquo;hello #{i}\n&rdquo;<br />
break if count == 1</p>

<p>if i &gt; 1<br />
count += 1<br />
redo<br />
end<br />
end<br />
end</p>

<p>执行结果为：<br />
hello 1<br />
hello 2<br />
hello 2<br />
hello 1<br />
hello 2<br />
hello 2<br />
hello 1<br />
hello 2<br />
hello 2</p>

<p>§6.9.6.3 next<br />
Next类似C/C++中的continue语句，跳转到当前循环的头部，执行下一次循环。</p>

<p>loop do<br />
times += 1<br />
next if times == 2<br />
print &ldquo;hello #{times}\n&rdquo;<br />
break if times &gt; 3<br />
end</p>

<p>执行结果为：<br />
hello 1<br />
hello 3<br />
hello 4</p>

<p>与break，redo类似，如果循环有多重，那么next只对最内侧的循环起作用。</p>

<p>outer = 0<br />
loop do<br />
outer += 1</p>

<p>inner = 0<br />
loop do<br />
inner += 1<br />
next if inner == 1<br />
print &ldquo;Inner #{inner}\n&rdquo;<br />
break if inner &gt; 1<br />
end</p>

<p>print &ldquo;Outer #{outer}\n&rdquo;<br />
break if outer &gt; 1<br />
end</p>

<p>执行结果为：<br />
Inner 2<br />
Outer 1<br />
Inner 2<br />
Outer 2</p>

<p>§6.9.7 Retry<br />
上一节我们看到，可以使用redo重新执行当前这一次的循环，有时候，我们也需要重新执行整个循环而不是仅仅执行当前这次，这时候我们可以用时retry。在迭代、块或for语句中使用retry，意味着重启迭代器。同时迭代器的参数也将被重新计算。</p>

<p>一个示例如下，<br />
for i in 1..5<br />
retry if some_condition # 从 i == 1 开始重新执行<br />
end</p>

<p>看一个完整可执行的例子：<br />
count = 0</p>

<p>for i in 1..3<br />
pr</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a></li>
        
        <li><a href="/posts/051rubyonrails%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%981hellorails/">051RubyonRails學習筆記1Hellorails</a></li>
        
        <li><a href="/posts/053rubyonrails%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%986%E9%87%8D%E6%A7%8B%E5%88%AA%E9%99%A4%E7%95%99%E8%A8%80%E5%AE%89%E5%85%A8/">053RubyonRails學習筆記6重構刪除留言安全</a></li>
        
        <li><a href="/posts/055rubyonrails%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%987carrierwaveimplementation/">055RubyonRails學習筆記7CarrierwaveImplementation</a></li>
        
        <li><a href="/posts/065rubyonrails%E7%AD%86%E8%A8%9810showtargetinfoongooglemaps/">065Rubyonrails筆記10showtargetinfoongooglemaps</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/ruby'>ruby</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>