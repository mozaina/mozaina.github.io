<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Posts | 开发者问答集锦</title>
    <meta property="og:title" content="Posts - 开发者问答集锦">
    <meta property="og:type" content="article">
        
        
    <meta name="Keywords" content="">
    <meta name="description" content="Posts">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <link rel="alternate" type="application/rss+xml+xml" href="https://zaina.newban.cn/posts/index.xml" title="开发者问答集锦" />
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%BA%94shell%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/" title="Linux之shell脚本自动化编程五shell变量详解和各种括号的作用">Linux之shell脚本自动化编程五shell变量详解和各种括号的作用</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            一些基础知识 

最常用的还是我们的bash。今天我们主要学习一下shell变量。
shell变量 
首先先来了解一下shell变量的命名规则，参考了http://www.runoob.com/linux/linux-shell-variable.html
和c语言是一样的，因为linux内核就是c写的嘛。

保留的关键字还是蛮多的。

以前我们赋值用了let，其实不需要用的。

变量名和等号之间，等号和值之间都不能有空格，不然会报错。不过文件名的条件就比较宽松了。

下面具体认识一下环境变量和局部变量。参考了https://blog.csdn.net/apollon_krj/article/details/70148022

env看一下环境变量还是挺多的。


unset的取消是一次性的，看到unset以后，~也变成了root了，因为以前root的HOME变量就是root的家/root，但是现在HOME变量已经没有了。

我们可以再人为给HOME赋值回去，然后发现~又回来了。当然我们还可以赋别的值，不过这些都是暂时的，再开一个会话就会恢复正常了，因为这些更改都没有改变配置文件的内容。

在配置文件里面改动的话，我们就在/etc/bashrc里面改动吧。

看到新开的已经是更新了，不过当前shell里面需要.或者source执行一下。一次性定义环境变量有如下方法。不过都是一次性的。



如果在shell里赋值而不不加export，不会出现在env命令(environment)打印出来的环境变量中。



确实awk命令里面正好和echo里面是反过来的，而且awk里面单引号即使用反斜杠转义还是打不出来$a。


如果不加大括号没有解析的原因应该是没有cmdkang变量，这个其实不是歧义，这个解析的时候应该是遇到非法字符才会停止，可以说是一种贪婪解析，解析不成功的话，命令还是会执行，但是会直接放弃不能解析的字符，所以结果是code.tar.gz，中间没有解析成的$cmd_kang直接丢弃或者说因为没有这个变量所以是空的。tar命令这里复习了一下,c是打包,f是执行文件路径，z是压缩格式是gz。

给cmd_kang赋值以后可以解析成功，不过我们其实只是想解析cmd而已，那么我们加一个大括号即可。

小括号不行，因为以前其实有过小括号是在子shell里面执行命令，里面必须是命令，中括号也不行，中括号是字符匹配用的，所以用了大括号。


下面看到的特殊变量在env是没有的，所以不算是环境变量。

不过在/etc/bashrc里面有*。

但是@就没有。





脚本后面跟了三个用空格隔开的参数，$#就是3，$1,$2分别就是后面跟着的第一个和第二个参数。上面暂时看不出来$*和$@的区别。



上面$?在脚本里的应用可能暂时看不懂，后面学习if之后就开可以看懂了。


这里只读变量最好不要轻易设定，因为在当前会话里面已经该不回去了，好在这样定义变量是一次性的，重启之后或者重开一个会话变量就没了，我们在写脚本的时候设置一个了一个只读变量想该回去也很简单，只需要把脚本里的readonly删掉，然后重新加载一遍配置文件就好了。

shell变量还可以是字符串，前面其实也有过。
字符串的相关操作 

echo是shell内置命令，awk不是，这或许就是单双引号有差异的原因了。……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%BA%94shell%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%90%84%E7%A7%8D%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%BA%8Cbash%E8%84%9A%E6%9C%AC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E5%92%8C%E5%AD%90shell/" title="Linux之Shell脚本自动化编程二bash脚本混合编程和子shell">Linux之Shell脚本自动化编程二bash脚本混合编程和子shell</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            bash脚本混合编程 脚本混合编程说的是在bash的脚本里面可以加入python等其他编程脚本语言的，但是根据我们上一讲所讲的内容，#!这种shebang只在第一行才有效果，那也就说只能指定一个解释器，那么如何混合编程呢？其实c和汇编混合编程还是很常见的，不过我也没有实际去编过，我们前面学了python，我们就来看bash脚本里如何运行一段python。其实就是用了之前学过的一个输入重定向，没有那么难。

看到我们也就是用了一个输入重定向给/usr/bin/python去解释执行。 &lt;

如果代码有缩进。

不加-，EOF顶头的话，就会显示缩进错误。如果加一个-，就没有问题了。

下面这样也是不行的。

加了-的话前面有缩进也是可以的。

这种写法就很方便了，因为你不需要写完python之后再在下一行顶头写了，看着也很整齐，对于有强迫症的人来说是很重要的，就像我。另外如果你看bash脚本的执行结果，就会发现，即使上一行有错误，下一行还是可以执行，这和python是不一样的。

python脚本里面是第一行错了第二行不可能执行的，在bash里面也是。

在python脚本里面是不能执行bash代码的，因为bash的命令不是python的关键字，在python脚本里面是不识别的。

执行bash脚本的时候还需要注意一个问题，就是哪个shell执行的问题。
子shell 
看到脚本执行的cd并没有改变当前shell的路径。但是我们如果在前面加.或者source就是在当前shell里面执行。

source和.可以让脚本在当前shell里面执行。

那前面没有加.或者source的时候脚本去哪里执行了呢？其实是去子shell里面执行了。什么是子shell呢？参考了https://www.linuxidc.com/Linux/2017-08/146606.htm
子shell的概念贯穿整个shell，写shell脚本时更是不可不知。所谓子shell，即从当前shell环境新开一个shell环境，这个新开的shell环境就称为子shell(subshell)，而开启子shell的环境称为该子shell的父shell。子shell和父shell的关系其实就是子进程和父进程的关系，只不过子shell和父shell是关联的进程是bash进程。子shell会从父shell中继承很多环境，如变量、命令全路径、文件描述符、当前工作目录、陷阱等等，但子shell有很多种类型，不同类型的子shell继承的环境不相同。可以使用 $BASH_SUBSHELL 变量来查看从当前进程开始的子shell层数， $BASHPID 查看当前所处BASH的PID，这不同于特殊变量&rdquo;$$&ldquo;值，因为&rdquo;$$&ldquo;会从父进程继承。
何时产生子shell?
要解释清楚子shell以及产生何种类型的子shell，需要搞清楚Linux中如何产生子进程。Linux上创建子进程的方式有三种：一种是fork出来的进程，一种是exec出来的进程，一种是clone出来的进程。此处无需关心clone，因为它用来实现Linux中的线程。
(1).fork是复制进程，它会复制当前进程的副本(不考虑写时复制的模式)，以适当的方式将这些资源交给子进程。所以子进程掌握的资源和父进程是一样的，包括内存中的内容，所以也包括环境变量和变量。但父子进程是完全独立的，它们是一个程序的两个实例。
(2).exec是加载另一个应用程序，替代当前运行的进程，也就是说在不创建新进程的情况下加载一个新程序。exec还有一个动作：在进程执行完毕后，退出exec所在的shell环境。
所以为了保证进程安全， 若要形成新的且独立的子进程，都会先fork一份当前进程，然后在fork出来的子进程上调用exec来加载新程序替代该子进程 。例如在bash下执行cp命令，会先fork出一个bash，然后再exec加载cp程序覆盖子bash进程变成cp进程。再来说明子shell的问题。一般fork出来的子进程，内容和父进程是一样的(包括变量)，例如执行cp命令时也能获取到父进程的变量。但是cp命令在哪里执行呢？执行cp命令敲入回车后，当前的bash进程fork出一个子bash，然后子bash通过exec加载cp程序替代子bash。这算是进入了子shell吗？更通用的问题是：什么情况下会进入子shell环境，什么时候不进入子shel环境呢？判断是否进入了子shell的方式非常简单，执行&rdquo;echo $BASHPID&rdquo;，如果该值和父bash进程的pid值不同，则表示进入了子shell。在shell中是否进入子shell的情况可以分为几种：


$$变量被继承了，expr是以标准输出格式打印表达式的值，表达式也有很多格式，里面还会有逻辑运算，比较运算，算术运算，这不是我们今天的重点，并且其实也不难，并且其实用echo也可以输出，这里稍微补充一下下面的内容，参考了https://www.cnblogs.com/hyc- blog/p/7880163.html


|的意思是如果arg1不是null或者0，就返回arg1，否则返回arg2。&amp;的意思是如果参数都不是null或者0，换句话说就是有一个参数是0或者null，那么就返回arg1，否则返回0。

let上面是用来给变量赋值，但是其实let也可以完成一些运算。

我们下面先来体会一下echo和expr区别。

区别应该已经显而易见了，expr是可以进行运算的，不过格式是运算符前后都要有空格，否则也不认为是要运算，echo是根本就不能进行运算，只是照本宣科。其实let也是可以进行运算的，而且根据http://daizj.iteye.com/blog/2255906
let执行的效率要高于expr，但是let有一点缺点就是不能直接输出。



&amp;这个符号在前面作业管理那里见过，在一个命令后面加这个，就会把进程放在后台运行。|是要进程管道的连接符，它们都需要转义或者说修饰。

好了好了，我们先扯回去，我们现在说的是子shell这个事情。上面看到的结果是进程管道后面的命令确实是在子shell里面执行的，而不是在当前shell下面执行的。

并且子shell进程很快就会结束了，而且子shell里面的变量是没有传到父shell里面的，这其实很好理解，一般都是子承父业。


给定的变量被自动标记导出到之后的执行的命令环境中，也就是之后的命令都会按照新赋给这个变量的值来打印。

可以看到这个2869的bash shell确实是2339的一个子进程，$$这个变量没有被继承，我们用exit可以退出这个子shell，然后这个对应的子进程就被处理掉了。……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%BA%8Cbash%E8%84%9A%E6%9C%AC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E5%92%8C%E5%AD%90shell/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%B9%9Dshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E4%BB%A5%E5%8F%8A%E6%94%B6%E5%B0%BE%E4%B8%8A/" title="Linux之Shell脚本自动化编程九shell脚本编程实战以及收尾上">Linux之Shell脚本自动化编程九shell脚本编程实战以及收尾上</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            find的补充 find不用-regex而是用我们以前用的-name的话是可以用相对路径来查找的，但是相对路径也必须要输全了。

awk的小应用 以前我们用sed做过这个事情，现在我们用awk来做这个事情就会比较简单。

这个应该不需要解释了。那么在每一行前面加上行号也很简单了，虽然这个没办法影响到原文件。

这里补充一个小知识，python里面是可以当作计算器使用的，但是bash不可以，我们可以按一个bc软件就支持了，yum -y install bc，然后输入bc，就可以在里面做一些简单的数学运算，但是看到三角函数都没有，退出的话是ctrl+c。

Linux全量增量备份脚本 一些服务器都是全年不关机的，那么对软件和硬件的压力还是蛮大的，说不定什么时候服务器就不行了，那么备份就相当重要了，备份其实前面就说过分为全量备份和增量备份，如果都是全量备份那存储空间的要求就太高了，一个服务器一天可能就要产生几百个G的数据，并且有些数据可能要保存好几十个年头，每天都进行全量备份，那得要多少块硬盘，而且备份肯定不要备份到本机，备份到本机如果本机的磁盘坏了还有什么意义？那么肯定备份文件传输到别的服务器就需要端口资源或者无线的话就需要网络资源，如果文件太大，这些资源的占用也很厉害。于是一般的做法是每隔一个比较长的时间进行一次全量备份，期间都进行增量备份。那么我们下面尝试写一个全量增量备份脚本，备份规则是这样的，每星期天全量备份一次，周一到周六增量备份就可以。全量备份比较简单，我们先写全量备份部分的代码，假设我要备份/etc/里面的文件，为了进一步减小占用的空间，我们用tar再把文件打包压缩一下。当然下面写的只是备份的第一部，因为备份文件还在这台服务器上，那么服务器坏了照样还是不行。第二步就是要把备份文件传输到别的主机上才行。

那么增量备份呢？也许你有用find -mtime 1也就是查找最近一天修改的文件这样的想法

，这种想法也是我第一下就想到的一个想法，不过这里有两个命令可以自动做到这一点，一个是rsync，另一个是tar -g 。首先来看rsync吧。 参考了https://www.cnblogs.com/kevingrace/p/6601088.html
rsync可能需要安装一下,yum -y install rsync。

man一下rsync，写着是一种快速，多功能的远程和本地文件拷贝工具，这个有三种大的方式，第一种是本地，也就是也就是自己的服务器和自己的服务器通信，其实这个是没有什么意义的，但是由于我的青云主机已经到期了，然后也没钱去用其他阿里云，腾讯云的主机，那么我们下面演示还是在本地演示。第二种是通过远程shell，第三种是通过rsync守护进程，我们主要还是来说第一种，我们主要是说HOST可以是别的主机名，也可以是ip。

这里说一下-a，相当于-rlptoD。

-r是递归的意思，-l我们先不去管它，-p是保存权限，-o是保存所有者，-g是保存文件的属组等，-t是保存了修改的时间。

z是压缩的意思。

delete和上面说的意思差不多。

我们怎么看到的不是压缩文件呢？这是因为那些文件只是在传输过程中打包压缩了，传输到了目的地就会自动解压解包了。

由于这是第一次备份，增量备份也就和全量没什么区别。那么下面我们来一个增量备份。我们加了一个-v选项以看见备份的过程。

其实-z和&ndash;delete可以不要的，不过-a是得要的。


我修改了一下文件权限，看到再备份一次，备份的文件权限也跟着变了。

我们下面看一下&ndash;delete的作用。下面是不加&ndash;delete。不会删除这个g。

然后是加的，明确显示删除了这个g。



只有一个副本的意思就是说如果你改动一个文件再备份一次，那么备份文件里的这个文件也随着改动，并且原来的副本就没有了，但是其实这也不是完全对的，因为我们不一定备份到一个文件夹，我们上面是都备份到了backup文件夹，我们完全可以以备份时间命名一个文件夹，这也很简单，我们以前就用date这种格式实现过。
看到这个A确实没有被删除。

第二种是用tar -g备份。




tar -g后面跟的是时间戳，那么什么是时间戳呢？这个时间戳可以自己命名的。看到里面是一串数字。

时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。通俗的讲， 时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据。 它的提出主要是为用户提供一份电子证据， 以证明用户的某些数据的产生时间。 在实际应用上， 它可以使用在包括电子商务、 金融活动的各个方面， 尤其可以用来支撑公开密钥基础设施的 “不可否认” 服务。增量备份就是要根据时间戳信息去只备份修改过的内容。由于上面是第一次备份，也就是全量备份了。下面看看增量备份。一次是修改了文件内容，一个是修改文件权限。看到第一次d/a等没有修改的都没有打印出来，只打印了目录的一个结构和修改过的d/a，第二次打印了目录结构和修改过权限的d/a。……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%B9%9Dshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E4%BB%A5%E5%8F%8A%E6%94%B6%E5%B0%BE%E4%B8%8A/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%B8%83%E5%87%BD%E6%95%B0%E5%92%8Csed%E8%AF%A6%E8%A7%A3/" title="Linux之Shell脚本自动化编程七函数和sed详解">Linux之Shell脚本自动化编程七函数和sed详解</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            shell函数 shell里函数里面的语句需要用大括号括起来，这一点和c语言是一样的。上面函数格式中的[]的意思是可选的，也就是说function可有可无，funnanme后面的小括号可有可无？我下面试了一下，这个还真的必须有，应该是调用的时候不需要加括号，这一点和其他的语言不同，比如python，c。return可有可无。
如果写在一行需要注意{后面需要一个空格，还有}的前面必须有一个分号，不过分行写就不存在这样的问题了。和前面一样，如果是在子shell里执行的，当前shell还是找不到，只有. ./a这种才能调用定义的函数f。函数的返回值必须是一个数字，并且在0-255之间。
看下面的return后面没有加;也是ok的。
数字和字符串相加，返回的是数字。
返回值应该是自然数，可以大于255，返回值应该是只有8位来存的，所以就是0-2^8-1，也就是0-255，如果超过255，会溢出，256=100000000，而最高位溢出了，那就是0了，因为只有8位，并且一定要是整数才行。
c语言，python都是可以在调用函数的时候给函数传递参数，不过我们看到bash里调用函数连括号都不用，函数里面也根本没办法去接受参数，那怎么传递参数呢？就是通过$n这个机制。
10以上是需要大括号的，$10是先$1=1，然后加一个0。
了解一下$-。
我们man set一下可以看看。
这些一般我们也不需要去改，就不展开了。下面是一点数组的知识。
这种替换其实我不说我们也是可以看懂的，它也没有改变a原来的元素，要想改变直接a[0]去赋值就可以了。unset是可以删除数组的，当然它本身也就是删除变量的一个命令，数组也算是变量嘛。shell函数还有一个比较特别的地方，就是函数不会在子shell中执行，当然看过我前面文章的小伙伴知道，放在管道后面还是会在子shell里执行的。所以就导致了在函数里面定义变量的作用域是当前shell，这和python函数里面定义的变量是局部变量不一样。
不过shell这种方式未必就是好的。我们有两种方式可以让函数里面的变量不影响当前shell，一个是在函数的变量前面加一个local，还有就是在脚本中执行，并且是子shell的形式。
那么其实第三种也很好理解，就是加一对小括号，让语句在子shell里面执行。
这里我再说一个小问题，就是vim的语法高亮问题。
如果文件有后缀或者第一行有#!/bin/bash，那么bash脚本就会有语法高亮，不然就不会，虽然可以运行。而c语言貌似怎么都会高亮，我猜这个原因还是因为内核是c编写的，不过必须是以.c结尾，用gcc编译的时候才能编译，不然会有file not recognized: File format not recognized，也就是不识别文件格式。虚拟机启动以后，sshd要过一段时间才能启动，所以可能xshell连不上，这个没出问题的话等一会就可以连上了。
shell文件包含 在脚本里面.或者source有两个地方需要注意，一个就是不需要后面的脚本有可执行权限，也就是上面的c，二就是如果有一些参数传递或者前后联系，加.或者source是在脚本的那个shell执行，而不是又开了一个shell，参数或者操作是可以供a脚本使用的，因为我们前面也学过嘛，脚本本身不加.或者source的话是在子shell执行的，子shell的参数变化不会影响到父shell。
使用.或者source可以不要可执行权限不是脚本里面的专利，这一点是都有的，可能以前讲子shell的时候忽略了这一点。a没有执行权限，加.或者source可以执行，但是不加执行就会报错。
那么lcl可以执行脚本a吗？不可以，因为其实lcl对于/root这个目录都没有任何权限，是不可能执行里面的文件的，lcl其实只需要一个/root的x权限就可以用.执行了。
不过echo 这个命令需要的权限很低。换个级别高的useradd也就不行了。
sed详解 先来看一个官方的文档。
sed是一个过滤和转换文本的流编辑命令。一个流编辑器被用来对一个输入的流（一个文件或者通过管道输入）进行基本的文本转换操作。
a的作用是文本添加，如果多行的话，需要\，这个下面会看到，i,c同样是\换行。
这个确实是在第3行的下一行也就是第四行加了一行后面的字，而且原来的文件内容是没有变化的。如果是3a呢？第四行是会被覆盖吗？看下图就知道答案是没有，原来的第四行变成了第5行。这个\其实可以不要，a后面的字符串会直接被操作的，不过中间不要有空格，因为空格是分隔符。但是我们发现3a
newline，newline却还是顶头写了。下图还可以看出，如果a前面不加数字，每一行的后面都会加上新的一行。
=是在每一行的上一行打印行号。
2,3a是在原来的2,3行后面加，而下图中的2,4a是在原文的2,3,4后面加，我如果想在偶数行加呢？本来想试下{2，4}a，但是不行。
数组也不行，并且从下图中还发现，似乎顶头的空格都是不管用的，都是会被忽略，还有就是这个命令的输入和输出定向都是同一个文件的时候，这个文件会被清空，这个以前也见过，我们可以重定向到别的文件。
nl就是在cat的基础上加一个行数而已。
我们还是用testfile试一试。看下图会发现，其实一般不需要用引号，但是当出现$这种符号的时候，还必须得用单引号，本来想试一下有没有^，看来是没有，不过第一行直接写1就行，也不需要。
下图看出只有单引号配合\有添加多行的能力，双引号不行，d后面不用跟字符串，跟了还会报错。
i确实是加到了2的上一行，也就是第一行。
其实我们可以用/etc/passwd，因为不会改变原文，不用担心。下图：
如果要替换添加的字符串中有空格，还是要用引号引起来，单双引号都可以。
也可以把2,5c也引进去。
打印指定行。但是暂时还是做不到打印不连续的行，比如第5行和第7行。
上面举的例子颇具误导性，其实找的不是/root/p是root，不过人家也说了，这个//是正则表达式的边界p是打印的意思。
其实这不和-n搭配其实没有什么意义。
但是对于d来说，加-n反而什么都看不见，其实也很好理解，因为它们已经被i删除了嘛。
加了{}，就得用引号了，并且不能用小括号。最后的那个q我的理解是这样的，如果有q，正则替换一次就结束命令，如果没有，会匹配出所有的root，然后把匹配到的所有行的bash替换为blueshell。
换一个文件a试一试，果然是如此。请看下下张图。如果你们还记得花括号的一个用处。
但是这里也是用不了。因为其实看起来像，但是格式其实还是有区别的。
上面的方法已经不适用了，因为ifconfig这个命令是没有了。我们可以用ip a。一步一步去去除多余的得到ip。^.*inet的意思就是从最左边到inet，/g是什么意思呢，g这个参数上面没有提到。
我们来看一下g是什么意思，官方的意思是把保持空间拷贝到模式空间，而G的意思是追加。d的意思是清空模式空间，开始下一轮循环。
保持空间和模式空间是什么？参考了http://blog.51cto.com/13691477/2113141
我们就先来看着图分析一下，1!G;h;$!d的过程：首先sed没是一行一行读的，先执行的是G，G的作用是追加hold space的内容到pattern space，而且第一行不执行G，此时第一行的内容One进入pattern space,然后是h,作用是覆盖pattern space的内容到hold place，那么现在保持空间和模式空间都是One，然后是d，清空模式空间，但是保持空间不受影响，sed是每读一行执行一次后面的命令。那么第一行结束以后。该第二行了，首先Two先进入模式空间，第二行是要执行G的，于是One就从保持空间追加到了模式空间了，当然模式空间已经有一个Two，现在也就是Two和One，保持空间还是One,然后是h，那么保持空间就和模式空间一样了，复制是要覆盖的，保持空间现在有Two和One，然后又清空模式空间，进入下一行，模式空间现在是
Three，然后G，注意追加是往后追加，所以模式空间现在从上到下依次是Three,Two，One，然后是h，保持空间现在从上到下依次是Three,Two，One，最后一行不执行d，就直接输出了，那么实际上h最后一行不执行h也是可以的。
上面有一个有意思的命令tac，它其实就是倒着输出而已，tac就是cat倒过来嘛，也很形象。
我们分析一下上面的&rsquo;1!G;H;$!d&rsquo;，第一行首先模式空间是One,然后H，保持空间原来应该是空的，那么就作为空行，现在就是空行和One,然后清空模式空间，进入下一行，模式空间是Two，然后G，那么模式空间就是Two，空行，One，然后H，那么保持空间就是空行，One,Two,空行，One，然后清空模式空间，进入下一行，模式空间是Three，G一下，模式空间就是Three，空行，One,Two,空行，One，H一下，保持空间就是空行，One,Two,空行，One，Three，空行，One,Two,空行，One，然后输出模式空间里面的值，就是Three，空行，One,Two,空行，One，图解会更清晰
。然后再分析一下&rsquo;1!g;h;$!d&rsquo;，这个我就直接图解了：
sed &lsquo;1!g;h&rsquo; 1为什么会输出三个one呢？其实是因为每次读一行之后如果不清空模式空间的话，就会自动输出模式空间里面的内容，并自动清空，也就是输出一次自动清空一次，所以是三个One，大家可以试着自己分析一下。如果是sed &lsquo;1!……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%B8%83%E5%87%BD%E6%95%B0%E5%92%8Csed%E8%AF%A6%E8%A7%A3/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E7%B3%BB%E5%88%97%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E9%87%8D%E5%90%AF%E7%8A%B6%E6%80%81/" title="Linux之shell脚本系列之服务启动关闭重启状态">Linux之shell脚本系列之服务启动关闭重启状态</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            ……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E7%B3%BB%E5%88%97%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E9%87%8D%E5%90%AF%E7%8A%B6%E6%80%81/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AF%87%E4%B8%80/" title="linux之shell脚本学习篇一">linux之shell脚本学习篇一</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            此文包含脚本服务请求，字符串截取，文件读写内容，打印内容换行。
#!/bin/bash
retMsg=&ldquo;&rdquo;;
while read LINE
do
echo &ldquo;this is text: $LINE&rdquo;;
retMsg=/usr/bin/curl -o test3.log -w %{http_code}&quot;\\\n&quot; $LINE; #http请求, 响应内容写文件以及响应状态码
echo &ldquo;Retutn value is text: $http_code&rdquo;;
if [ &ldquo;$retMsg&rdquo; == &ldquo;200&rdquo; ]
then
echo &ldquo;请求服务成功&rdquo;;
#else
echo &ldquo;请求服务失败&rdquo;; while read MOBILE
do
echo &ldquo;The rtn mobile is $MOBILE&rdquo;;
a=&ldquo;$MOBILE&rdquo;;
info=echo &quot;$a&quot;|awk -F ',' '{print $1}'; #按，截取字符串
url=echo &quot;$a&quot;|awk -F ',' '{print $2}'; #按，截取字符串
echo -e &ldquo;截取后的字符串:\n$info\n$url&rdquo;; #字符串换行
done &lt; mobile.……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AF%87%E4%B8%80/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B8%89%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5forwhileifexpect%E7%AD%89/" title="Linux之shell脚本学习三常用的语句forwhileifexpect等">Linux之shell脚本学习三常用的语句forwhileifexpect等</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            一、for语句 for NUM in 1 2 3 ## 1 2 3 分别赋给变量NUM for NUM in {1..3} ##1..3所有的数分别赋给变量NUM for NUM in `seq 1 3` 或者 for NUM in `seq 1 2 10` ##for NUM in `seq 1 2 10`设置循环步长为2。 do 可执行的语句 done  for语句示例： vim test.sh #!/bin/bash for NUM in 1 2 3 do echo $NUM done  
设置步长：
vim test.sh #!/bin/bash for NUM in `seq 1 2 10` do echo $NUM done……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B8%89%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5forwhileifexpect%E7%AD%89/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA/" title="Linux之Shell脚本创建">Linux之Shell脚本创建</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            ……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E7%BC%96%E7%A8%8B%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/" title="Linux之shell编程脚本执行方式">Linux之shell编程脚本执行方式</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            1.以bash进程来执行（不需要赋予文件执行权限）
命令：
 bash test.sh sh test.sh  2.直接命令执行（首先要先赋予文件执行权限 chmod 755 test.sh）
命令：
 绝对路径 /root/sh/test.sh 相对路径 ./test.sh 变量&rdquo;PATH&rdquo;功能，将test.sh放入PATH指定目录内 test.sh  3.利用source来执行脚本（不需要赋予文件执行权限）
命令：
 source test.sh . test.sh  区别：
当使用直接执行方式（绝对路径、相对路径，利用PATH变量）或利用bash(或sh)来执行脚本时，该脚本会在一个新的bash环境中执行（子进程bash），子进程中的各项变量或操作将会结束而不会传回到父进程中。
利用source来执行脚本，是在父进程中执行。……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E7%BC%96%E7%A8%8B%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F/">阅读全文</a></p>
    </article>
    
    
    
    <article class="post">
        <header>
            <h1 class="post-title">
                <a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E7%BC%96%E7%A8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95/" title="Linux之shell编程条件测试">Linux之shell编程条件测试</a>
            </h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        <div class="post-content">
            ……
        </div>
        <p class="readmore"><a href="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E7%BC%96%E7%A8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95/">阅读全文</a></p>
    </article>
    
    
    



<ol class="page-navigator">
    
    <li class="prev">
        <a href="https://zaina.newban.cn/posts/page/1545/">上一页</a>
    </li>
    

    

    
        
        
    
    

    
        
        
        <li >
            <a href="https://zaina.newban.cn/posts/">1</a>
        </li>
        
    
        
        <li>
            <span>...</span>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/posts/page/1544/">1544</a>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/posts/page/1545/">1545</a>
        </li>
        
    
        
        
        <li  class="current">
            <a href="https://zaina.newban.cn/posts/page/1546/">1546</a>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/posts/page/1547/">1547</a>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/posts/page/1548/">1548</a>
        </li>
        
    
        
        <li>
            <span>...</span>
        </li>
        
    
        
        
        <li >
            <a href="https://zaina.newban.cn/posts/page/1960/">1960</a>
        </li>
        
    

    
    

    <li class="next">
        <a href="https://zaina.newban.cn/posts/page/1547/">下一页</a>
    </li>
    
</ol>




</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>