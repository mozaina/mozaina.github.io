<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux3Shell基础 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux3Shell基础 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux3Shell基础">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux3shell%E5%9F%BA%E7%A1%80/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux3Shell基础</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>Linux（1）：简介与系统安装：<a href="https://mp.csdn.net/postedit/88633915">https://mp.csdn.net/postedit/88633915</a></p>

<p>Linux（2）：常用命令：<a href="https://mp.csdn.net/postedit/88639718">https://mp.csdn.net/postedit/88639718</a></p>

<p>鸟哥的Linux私房菜：<a href="https://wizardforcel.gitbooks.io/vbird-linux-">https://wizardforcel.gitbooks.io/vbird-linux-</a>
basic-4e/content/86.html</p>

<p><strong>目录</strong></p>

<p>9 Shell基础</p>

<p>9.1 shell概述</p>

<p>9.1.1 shell概述</p>

<p>9.1.2 bash shell 的内置命令：type</p>

<p>9.2 shell的变量功能</p>

<p>9.2.1 什么是变量</p>

<p>9.2.2 变量的显示与设置：echo、unset</p>

<p>9.2.3 环境变量的功能（env、set、export）</p>

<p>9.2.4 影响显示结果的语系变量（locale）</p>

<p>9.2.5 变量的有效范围</p>

<p>9.2.6 变量键盘读取、数组与声明：read，array，declare</p>

<p>9.2.7 与文件系统及程序的限制关系：ulimit</p>

<p>9.2.8 变量内容的删除、替代与替换</p>

<p>9.3 脚本执行方式</p>

<p>9.3.1 echo</p>

<p>9.3.2 第一个脚本</p>

<p>9.4 别名与快捷键</p>

<p>9.4.1 别名</p>

<p>9.4.2 快捷键</p>

<p>9.5 历史命令</p>

<p>9.5.1 history</p>

<p>9.5.2 历史命令的调用</p>

<p>9.5.3 命令和文件补全</p>

<p>9.6 数据流重定向</p>

<p>9.6.1 标准输入输出</p>

<p>9.6.2 输出重定向</p>

<p>9.6.3 输入重定向（standard input ： &lt; 与 &lt;</p>

<p>9.7 管道符</p>

<p>9.7.1 多命令顺序执行</p>

<p>9.7.2 管道符</p>

<p>9.8 通配符与特殊符号</p>

<p>9.8.1 通配符</p>

<p>9.8.2 Bash中其他特殊符号</p>

<p>9.9 Bash Shell 的操作环境</p>

<p>9.9.1 路径与命令查找顺序</p>

<p>9.9.2 bash 的登录与欢迎信息：/etc/issue，/etc/motd</p>

<p>9.9.3 bash 的环境配置文件</p>

<p>9.9.4 终端机的环境设置： stty, set</p>

<hr />

<h1 id="9-shell基础">9 Shell基础</h1>

<h2 id="9-1-shell概述">9.1 shell概述</h2>

<h3 id="9-1-1-shell概述">9.1.1 shell概述</h3>

<p><img src="https://img.it610.com/image/info8/9d757bc34fb247c7b31f9c2420967705.jpg" alt="" /></p>

<p><a href="https://img.it610.com/image/info8/98f46660206246278441e8e31eef98b0.jpg"><img src="https://img.it610.com/image/info8/98f46660206246278441e8e31eef98b0.jpg" alt="Linux（3）：Shell基础_第1张图片" /></a></p>

<p>管理整个计算机硬件的其实是 <strong>操作系统的内核（kernel）</strong> ，这个内核是需要被保护的，所以我们一般用户就只能通过 <strong>shell</strong> 来跟
<strong>内核</strong> 通信，以让内核达到我们线索想要达到的工作。我们必须要通过 <strong>“shell”（内核）</strong>
将我们输入的命令与内核通信，好让内核可以控制硬件来正确无误地工作。</p>

<p><a href="https://img.it610.com/image/info8/793f648ce0be41fdadffccb56a1cc5db.jpg"><img src="https://img.it610.com/image/info8/793f648ce0be41fdadffccb56a1cc5db.jpg" alt="Linux（3）：Shell基础_第2张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/91bde437b62f4679bd4b3b55f81fa692.jpg"><img src="https://img.it610.com/image/info8/91bde437b62f4679bd4b3b55f81fa692.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/bc81530dc2a04483a8fded33f1be5c95.jpg"><img src="https://img.it610.com/image/info8/bc81530dc2a04483a8fded33f1be5c95.jpg" alt="" /></a></p>

<p><img src="https://img.it610.com/image/info8/0779385c19aa4e58a7145a756226a077.jpg" alt="" /></p>

<p>Linux中的标准的默认的 <strong>shell</strong> 是 <strong>Bash</strong> 。</p>

<p><a href="https://img.it610.com/image/info8/8393aa640ed844f88bac9bcfe0ae0105.jpg"><img src="https://img.it610.com/image/info8/8393aa640ed844f88bac9bcfe0ae0105.jpg" alt="Linux（3）：Shell基础_第3张图片" /></a></p>

<p>已进入系统就用到的shell就是父shell，可以用base命令，调用子shell。</p>

<p><a href="https://img.it610.com/image/info8/3cf540acd8d841d48fca8ed85743549a.png"><img src="https://img.it610.com/image/info8/3cf540acd8d841d48fca8ed85743549a.png" alt="Linux（3）：Shell基础_第4张图片" /></a></p>

<h3 id="9-1-2-bash-shell-的内置命令-type">9.1.2 bash shell 的内置命令：type</h3>

<p><strong>type命令</strong> 用来显示指定命令的类型，判断给出的指令是 <strong>内部指令</strong> 还是 <strong>外部指令</strong> 。</p>

<p>命令类型：</p>

<ul>
<li>alias：别名。</li>
<li>keyword：关键字，Shell保留字。</li>
<li>function：函数，Shell函数。</li>
<li>builtin：内建命令，Shell内建命令。</li>
<li>file：文件，磁盘文件，外部命令。</li>
<li>unfound：没有找到。</li>
</ul>

<p><strong>语法：</strong></p>

<pre><code>type(选项)(参数)
</code></pre>

<p><strong>选项：</strong></p>

<pre><code>-t：输出“file”、“alias”或者“builtin”，分别表示给定的指令为“外部指令”、“命令别名”或者“内部指令”；
-p：如果给出的指令为外部指令，则显示其绝对路径；
-a：在环境变量“PATH”指定的路径中，显示给定指令的信息，包括命令别名。
</code></pre>

<p><strong>参数：</strong></p>

<p>指令：要显示类型的指令。</p>

<p>通过 <strong>type</strong> 这个命令我们可以知道每个命令是否为 <strong>bash的内置命令</strong> 。此外由于利用 type
找到后面的名称时，如果后面接的名称并不能以执行文件的状态被找到，那么该名称是不会被显示出来的。就是说type主要在找出 <strong>“执行文件”</strong> 而不是一般
<strong>文件名</strong> 。所以，这个 <strong>type</strong> 也可以用来作为类似 <strong>which命令</strong> 的用途了。</p>

<p>如果命令太长，可以使用 <strong>“\[enter]”</strong> 来将 <strong>[enter]</strong> 这个按键“转义”，让 <strong>[enter]</strong>
不再具有“开始执行”的功能，从而进行换行。如果顺利转义 <strong>[enter]</strong> 后，下一行最前面就会出现&gt;的符号，可以继续输入命令。</p>

<h2 id="9-2-shell的变量功能">9.2 shell的变量功能</h2>

<h3 id="9-2-1-什么是变量">9.2.1 什么是变量</h3>

<p>变量是以一组文字或者符号等，来替代一些设置或者是一串保留的数据。例如，我们每个账号的邮件信箱默认是以 <strong>MAIL</strong> 这个变量来进行访问的，当
<strong>dnteal</strong> 这个用户登录时，他便会取得 <strong>MAL</strong> 这个变量，而这个变量的内容其实就是var/spool/mail/dmtsai，那如果
<strong>vbird</strong> 登录呢？他取得的MAIL这个变量的内容其实就是 <strong>/var/spoonaiwbird</strong> 。而我们使用信件读取命令 <strong>mail</strong>
来读取自己的邮件信箱时，这个程序可以直接读取 <strong>MAIL</strong> 这个变量的内容，就能够自动分辨出属于自己的信箱信件了。</p>

<p><a href="https://img.it610.com/image/info8/f1a85d46c28343fe9364aa8f6357c93d.jpg"><img src="https://img.it610.com/image/info8/f1a85d46c28343fe9364aa8f6357c93d.jpg" alt="Linux（3）：Shell基础_第5张图片" /></a></p>

<h3 id="9-2-2-变量的显示与设置-echo-unset">9.2.2 变量的显示与设置：echo、unset</h3>

<p>变量的显示可以使用 <strong>echo，</strong> 只需要在变量名称前面加上$，或者以${变量}的方式显示都可以：</p>

<p><img src="https://img.it610.com/image/info8/155254e0b11b466790b6b4bf88a31a5e.png" alt="" /></p>

<p><strong>变量的设置规则：</strong></p>

<p>1. 变量与内容以一个等号 <strong>[=]</strong> 来连接，如下所示：</p>

<p><strong>[myname=VBird]</strong></p>

<p>2. 等号两边不能 <strong>直接接空格符</strong> ，如下所示为 <strong>错误</strong> ：</p>

<p><strong>[myname = VBird] 或 [myname=VBird Tsai]</strong></p>

<p>3. 变量名称只能是 <strong>英文字母与数字</strong> ，但是开头字符 <strong>不能是数字</strong> ，如下为 <strong>错误</strong> ：</p>

<p><strong>[2myname=VBird]</strong></p>

<p>4. 变量内容若有空格符可使用双引号[&ldquo;]或单引号[&lsquo;]将变量内容结合起来，但</p>

<ul>
<li>双引号内的特殊字符如$等，可以 <strong>保有原来的特性</strong> ，如下所示：</li>
</ul>

<p><strong>[var=&ldquo;lang is $LANG&rdquo;] 则 [echo $var] 可得 [lang is zh_TW.UTF-8]</strong></p>

<ul>
<li>单引号内的特殊字符则仅为 <strong>一般字符(纯文本)</strong> ，如下所示：</li>
</ul>

<p><strong>[var=&lsquo;lang is $LANG&rsquo;] 则 [echo $var] 可得 [lang is $LANG]</strong></p>

<p>5. 可用转义字符 <strong>[ \ ]</strong> 将特殊符号(如 <strong>[Enter]</strong> ， <strong>$</strong> ， *<em>*</em> ， <strong>空格符</strong> ， <strong>&lsquo;</strong>
等)变成一般字符，如：</p>

<p><strong>[myname=VBird\ Tsai]</strong></p>

<p>6. 在一串指令的执行中，还需要通过其他的命令提供的信息时，可以使用反单引号 <strong>[<code>指令</code>]</strong> 或 <strong>[$(指令)]</strong> 。特别注意，那个
<strong><code>** 是键盘上方的数字键 1 左边那个按键，而不是单引号！在一串命令中，在 **</code></strong>
之内的命令将会被先执行，而其执行出来的结果将作为外部的输入信息。例如想要取得核心版本的设定：</p>

<p><strong>[version=$(uname -r)] 再 [echo $version] 可得 [3.10.0-229.e17.x86_64]</strong></p>

<p>7. 若该变量为了增加变量内容时，则可用 <strong>“$变量名称”</strong> 或 <strong>${变量}</strong> 累加内容，如下所示:</p>

<p><strong>[PATH=&ldquo;$PATH&rdquo;:/home/bin] 或 [PATH=${PATH}:/home/bin]</strong></p>

<p>8. 若该变量需要在其他子程序执行，则需要以 <strong>export</strong> 来使变量变成环境变量:</p>

<p><strong>[export PATH]</strong></p>

<p>9. 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断(纯粹依照使用者兴趣与嗜好)；</p>

<p>10.取消变量的方法为使用 unset : [uset 变量名称] 例如取消 myname 的设定：<br />
<strong>[unset myname]</strong></p>

<p>例如：</p>

<p><strong>① 如何让我刚才设置的name=VBird可以用在下个shell的程序?</strong><br />
 <strong>[root@localhost ~]# name=VBird<br />
[root@localhost ~]# bash &lt;==进入到所谓的子进程<br />
[root@localhost ~]# echo $name &lt;==子进程：再次echo 一下；<br />
&lt;==结果是空的，并没有刚才设置的内容。<br />
[root@localhost ~]# exit<br />
[root@localhost ~]# export name<br />
[root@localhost ~]# bash &lt;==进入到所谓的子进程<br />
[root@localhost ~]# echo $name &lt;==子进程：在此执行<br />
VBird &lt;==看吧！出现设置值了<br />
[root@localhost ~]# exit &lt;==子进程：离开这个子进程</strong><br />
什么是“子进程”呢?就是说在我目前这个 <strong>shell</strong> 的情况下，去打开另一个新的 <strong>shell</strong> ，新那个 <strong>shell</strong> 就是
<strong>子进程</strong> 。在一般的状态下， <strong>父进程的自定义变量是无法在子进程内使用的</strong> 。但是通过 <strong>export</strong> 将变量变成 <strong>环境变量</strong>
后，就能够在子进程下面应用了。</p>

<p><strong>② 知何进入到你目前内核的模块目录？</strong><br />
 <strong>[root@localhost ~]# cd /1ib/modules/&ldquo;uname -r&rdquo;/kernel<br />
[root@localhost ~]# ed /1tb/aodulas/$(uname -r)/kornel</strong><br />
每个Unux都能够拥有多个内核版本，且几乎distribution的所有内核版本都不相同。</p>

<p><strong>③</strong> <strong>每个crontab相关文件名的权限</strong></p>

<p><strong>ls -l <code>locate crontab</code></strong><br />
<a href="https://img.it610.com/image/info8/aac7b91698b248a1bd76521edc8e9bad.jpg"><img src="https://img.it610.com/image/info8/aac7b91698b248a1bd76521edc8e9bad.jpg" alt="Linux（3）：Shell基础_第6张图片" /></a></p>

<h3 id="9-2-3-环境变量的功能-env-set-export">9.2.3 环境变量的功能（env、set、export）</h3>

<p><strong>（1）env</strong></p>

<p>使用 <strong>env</strong> 列出目前的 <strong>shell</strong> 环境下的所有环境变量与其内容。 <strong>env</strong> 是environment（环境）的缩写。</p>

<p><a href="https://img.it610.com/image/info8/23372a98dcbe4d888d1d2dbb184ca611.jpg"><img src="https://img.it610.com/image/info8/23372a98dcbe4d888d1d2dbb184ca611.jpg" alt="Linux（3）：Shell基础_第7张图片" /></a></p>

<ul>
<li>HOME：代表用户的主文件夹，可以使用cd~、cd 直接回到用户主文件夹。</li>
<li>SHELL：告知我们，目前这个环境使用的 SHELL 是哪个程序？ Linux 默认使用 /bin/bash 的。</li>
<li>HISTSIZE：这个与『历史命令』有关，亦即是我们曾经下达过的命令可以被系统记录下来，而记录的 “条数” 则是由这个值来配置的。</li>
<li>MAIL：当我们使用 <strong>mail</strong> 这个命令在收信时系统会去读取的邮件信箱文件（mailbox)。</li>
<li>PATH：就是执行文件查找的路径，目录与目录中间以冒号（：）分隔，由于文件的查找是依序由 <strong>PATH变量</strong> 内的目录来查询，所以目录的顺序也是重要的。</li>
<li>LANG：这个重要。就是语系数据，很多信息都会用到它。举例来说，当我们在启动某些 <strong>Perl</strong> 的程序语言文件时，它会主动去分析语系数据文件，如果发现有它无法解析的编码语系，可能会产生错误。一般来说，我们中文编码通常是zh_CN.gb2312或者是zhCN.UTF-8，这两个编码偏偏不容易被解译出来，所以有的时候，可能需要修改一下语系数据。</li>
<li>HRANDOM：这是“随机数”的变量。目前大多数的distributions都会有随机数生成器，那就是 <strong>/dov/random</strong> 这个文件。我们可以通过这个随机数文件相关的变量（$RANDOM）来随机取得随机数值。BASH的环境下，这个RANDOM变量的内容介于0~32767之间，所以你只要 echo $RANDOM时，系统就会主动随机取出一个介于0~32767的数值。万一我想要使用0~9<br />
间的数值呢?利用declare声明数值类型，然后这样做就可以了；</li>
</ul>

<p>** [root@localhost ~]# declare -i number=$RANDOM*10/32768；echo $number<br />
8 &lt;==此时会随机取出0~9之间的数值。**</p>

<p><strong>（2）set</strong></p>

<p>用 set 观察所有变量 (含 <strong>环境变量</strong> 与 <strong>自定义变量</strong> )</p>

<p><a href="https://img.it610.com/image/info8/b1475cdc0f214479907d8a13a573d204.jpg"><img src="https://img.it610.com/image/info8/b1475cdc0f214479907d8a13a573d204.jpg" alt="Linux（3）：Shell基础_第8张图片" /></a></p>

<p>一般来说，不论是否为环境变量，只要跟我们目前这个 <strong>shell</strong> 的操作接口有关的变量，通常都会被设置为大写字符，也就是说，基本上，在Linux
默认的情况下，使用 <strong>{大写的字母}</strong> 来设置的变量一般为 <strong>系统内定需要的变量</strong> 。</p>

<p><strong>一些较为重要的系统内定变量：</strong></p>

<p><strong>① PS1：(提示字符的配置)</strong></p>

<p>这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的“命令提示字符”。当我们每次按下 <strong>[Enter] 按键</strong>
去运行某个命令后，最后要再次出现提示字符时， 就会主动去读取这个变量值了。上面 <strong>PS1</strong> 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息，
每个 distributions 的 bash 默认的 PS1 变量内容可能有些许的差异，你可以用 <strong>man bash</strong> 去查询一下 PS1
的相关说明，以理解下面的一些符号意义。</p>

<ul>
<li>\d ：可显示出『星期 月 日』的日期格式，如：&rdquo;Mon Feb 2&rdquo;</li>
<li>\H ：完整的主机名。举例来说，鸟哥的练习机为『www.vbird.tsai』</li>
<li>\h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略</li>
<li>\t ：显示时间，为 24 小时格式的『HH:MM:SS』</li>
<li>\T ：显示时间，为 12 小时格式的『HH:MM:SS』</li>
<li>\A ：显示时间，为 24 小时格式的『HH:MM』</li>
<li>\@ ：显示时间，为 12 小时格式的『am/pm』样式</li>
<li>\u ：目前使用者的账号名称，如『root』；</li>
<li>\v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示</li>
<li>\w ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹（家目录）会以 ~ 取代；</li>
<li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。</li>
<li>\# ：执行的第几个命令。</li>
<li>\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～</li>
</ul>

<p><strong>例如：更改PS1变量的值</strong></p>

<p><strong>[root@www ~ ]# cd /home</strong></p>

<p><strong>[root@www home]# PS1=&rsquo;[\u@\h \w \A #\#]\$ &lsquo;</strong></p>

<p><strong>[root@www /home 17:02 #85]#</strong></p>

<p><strong>② $：(关于本 shell 的 PID)</strong></p>

<p>“ <strong>$</strong> ”本身也是个变量。这个代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID (Process ID)。想要知道我们的
shell 的 PID ，就可以用： <strong>echo $$</strong> 即可！出现的数字就是你的 <strong>PID 号码</strong> 。</p>

<p><strong>③ ?：(关于上个运行命令的回传值)</strong></p>

<p>问号也是一个特殊的变量。 这个变量是： <strong>『上一个运行的命令所回传的值』</strong> ， 上面这句话的重点是 <strong>『上一个命令』</strong> 与 <strong>『回传值』</strong>
两个地方。当我们运行某些命令时， 这些命令都会回传一个运行后的代码。一般来说，如果成功的运行该命令， 则会回传一个 <strong>0 值</strong>
，如果运行过程发生错误，就会回传 <strong>『错误代码』</strong> 才对！一般就是以非为 0 的数值来取代。</p>

<p>例如：</p>

<pre><code>[root@www ~]# echo $SHELL
/bin/bash                                  &lt;==可顺利显示！没有错误！
[root@www ~]# echo $?
0                                          &lt;==因为没问题，所以回传值为 0
[root@www ~]# 12name=VBird
-bash: 12name=VBird: command not found     &lt;==发生错误了！bash回报有问题
[root@www ~]# echo $?
127                                        &lt;==因为有问题，回传错误代码(非为0)
# 错误代码回传值依据软件而有不同，我们可以利用这个代码来搜寻错误的原因喔！
[root@www ~]# echo $?
0
# 咦！怎么又变成正确了？这是因为 &quot;?&quot; 只与『上一个运行命令』有关，
# 所以，我们上一个命令是运行『 echo $? 』，当然没有错误，所以是 0 没错！
</code></pre>

<p><strong>④ OSTYPE, HOSTTYPE, MACHTYPE：(主机硬件与核心的等级)</strong></p>

<p>目前个人计算机的 CPU 主要分为 <strong><sup>32</sup>&frasl;<sub>64</sub></strong> 位，其中 32 位又可分为 <strong>i386, i586, i686</strong> ，而 64 位则称为
<strong>x86_64</strong> 。 由于不同等级的 CPU 命令集不太相同，因此你的软件可能会针对某些 CPU 进行优化，以求取较佳的软件性能。你可以在 x86_64
的硬件上安装 i386 的 Linux 操作系统，但是你无法在 i686 的硬件上安装 x86_64 的 Linux 操作系统。</p>

<p><strong>（3） export： 自定义变量转成环境变量</strong></p>

<p><strong>因为子进程仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量，</strong> 所以你原本 <strong>bash</strong>
中的自定义变量在进入了子进程之后就会消失不见，一直到你离开了子进程并回到原本的父进程后，这个变量才会又出现。如你想要让变量内容继续的在子程序中使用，那么可以用：</p>

<p><strong>[root@www ~]# export 变量名称</strong></p>

<p>如果仅执行 export 而没有接变量时，那么此时将会把所有的“环境变量”显示出来。</p>

<p><a href="https://img.it610.com/image/info8/4fefe7d7a49f4cdb87b083b34d0676c0.png"><img src="https://img.it610.com/image/info8/4fefe7d7a49f4cdb87b083b34d0676c0.png" alt="Linux（3）：Shell基础_第9张图片" /></a></p>

<h3 id="9-2-4-影响显示结果的语系变量-locale">9.2.4 影响显示结果的语系变量（locale）</h3>

<p><strong>（1）查看Linux支持的语言：</strong></p>

<p><a href="https://img.it610.com/image/info8/ec4db9b627874dfb895fe3eeec46cbbe.png"><img src="https://img.it610.com/image/info8/ec4db9b627874dfb895fe3eeec46cbbe.png" alt="Linux（3）：Shell基础_第10张图片" /></a></p>

<p><strong>（2）如何修订这些编码</strong></p>

<p>当使用 <strong>locale</strong> 时，系统时列出目前 <strong>Linux 主机</strong> 内保有的语系文件，这些语系文件都放置在 <strong>/usr/lib/locale/</strong>
这个目录中。</p>

<pre><code>[root@www ~]# locale         &lt;==后面不加任何选项与参数即可！
LANG=en_US                   &lt;==主语言的环境
LC_CTYPE=&quot;en_US&quot;             &lt;==字符(文字)辨识的编码
LC_NUMERIC=&quot;en_US&quot;           &lt;==数字系统的显示信息
LC_TIME=&quot;en_US&quot;              &lt;==时间系统的显示数据
LC_COLLATE=&quot;en_US&quot;           &lt;==字符串的比较与排序等
LC_MONETARY=&quot;en_US&quot;          &lt;==币值格式的显示等
LC_MESSAGES=&quot;en_US&quot;          &lt;==信息显示的内容，如菜单、错误信息等
LC_ALL=                      &lt;==整体语系的环境
</code></pre>

<p>如果其他语系变量都未设置，且你有设置 <strong>LANG</strong> 或者是 <strong>LC_ALL</strong> 时，则其他的语系变量就会被这两个变量所替代。这也是为什么我们在
<strong>Linux</strong> 当中，通常说明仅设置 <strong>LANG</strong> 这个变量而已，因为它是最主要的设置变量。</p>

<p><strong>默认的语系</strong> 定义在：</p>

<pre><code>[root@www ~]# cat /etc/sysconfig/i18n
LANG=&quot;zh_TW.UTF-8&quot;
</code></pre>

<h3 id="9-2-5-变量的有效范围">9.2.5 变量的有效范围</h3>

<p>被 <strong>export</strong> 后的变量，我们可以称他为『 <strong>环境变量</strong> 』！ 环境变量可以被子程序所引用，但是其他的自定义变量内容就不会存在于子程序中。</p>

<p>为什么环境变量的数据可以被子进程所引用呢？这是因为 <strong>内存配置</strong> 的关系。理论上是这样的：</p>

<ul>
<li>当启动一个shell，操作系统会分配一记忆块给shell使用，此内存内的变量可让子进程取用；</li>
<li>若在父进程利用 <strong>export</strong> 功能，可以让自定义变量的内容写到上述的记忆块当中（环境变量）；</li>
<li>当加载另一个shell时（即启动子进程，而离开原本的父进程了），子shell可以将父shell的环境变量所在的记忆块导入自己的环境变量块当中。</li>
</ul>

<p>通过这样的关系，我们就可以让某些安量在相关的进程之间存在，以帮助自己更方便地操作环境。不对要提醒的是，这个 “环境发量” 与 “bash的操作环境”
意思不大一样。举例来说， <strong>PS1</strong> 并不是环境变量，但是过个 <strong>PS1</strong> 会影响到比bash的接口（提示符）。</p>

<h3 id="9-2-6-变量键盘读取-数组与声明-read-array-declare">9.2.6 变量键盘读取、数组与声明：read，array，declare</h3>

<p><strong>（1）read</strong></p>

<p>要读取来自键盘输入的变量，就是用 <strong>read</strong> 这个命令：</p>

<p><strong>[root@www ~]# read [-pt] variable</strong></p>

<p><strong>选项与参数：</strong></p>

<ul>
<li>-p ：后面可以接提示字符！</li>
<li>-t ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待使用者！</li>
</ul>

<p><strong>例如：</strong></p>

<p>① 让用户由键盘输入一内容，将该内容变成名为 atest 的变量</p>

<pre><code>[root@www ~]# read atest
This is a test        &lt;==此时光标会等待你输入！请输入左侧文字看看
[root@www ~]# echo $atest
This is a test          &lt;==你刚刚输入的数据已经变成一个变量内容！
</code></pre>

<p>② 提示使用者 30 秒内输入自己的大名，将该输入字符串作为名为 named 的变量内容</p>

<pre><code>[root@www ~]# read -p &quot;Please keyin your name: &quot; -t 30 named
Please keyin your name: VBird Tsai   &lt;==注意看，会有提示字符喔！
[root@www ~]# echo $named
VBird Tsai                           &lt;==输入的数据又变成一个变量的内容了！
</code></pre>

<p><strong>（2）declare / typeset</strong></p>

<p><strong>declare 或 typeset</strong> 是一样的功能，就是声明量的类型。如果使用 <strong>declare</strong> 后面并没有接任何参数，那么 <strong>bash</strong>
就会主动将所有的变量名称与内容全部调出来，就好像使用 <strong>set</strong> 一样。</p>

<p><strong>[root@www ~]# declare [-aixr] variable</strong></p>

<p><strong>选项与参数：</strong></p>

<ul>
<li>-a ：将后面名为 variable 的变量定义成为数组 (array) 类型</li>
<li>-i ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型</li>
<li>-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；</li>
<li>-r ：将变量配置成为 readonly 类型，该变量不可被更改内容，也不能 unset</li>
</ul>

<p>范例一：让变量 sum 进行 100+300+50 的加总结果</p>

<pre><code>[root@www ~]# sum=100+300+50
[root@www ~]# echo $sum
100+300+50  &lt;==咦！怎么没有帮我计算加总？因为这是文字型态的变量属性啊！
[root@www ~]# declare -i sum=100+300+50
[root@www ~]# echo $sum
[root@www ~]# 450
</code></pre>

<p><strong>bash</strong> 对于变量有几个基本的定义：</p>

<ul>
<li>变量类型默认为 <strong>“字符串”</strong> ，所以若不指定变量类型，则1+2为一个“字符串”而不是“计算式”，所以上述第一个执行的结果才会出现那个情况；</li>
<li>bash 环境中的数值运算，默认最多仅能到达整数形态，所以 <sup>1</sup>&frasl;<sub>3</sub> 结果是 0</li>
</ul>

<p>如果不小心将变量设置为“ <strong>只读</strong> ”，通常得要注销再登录才能复原该变量的类型。</p>

<p>如果需要 <strong>非字符串类型</strong> 的变量，那就得要进行变量的声明才行。</p>

<pre><code>范例二：将 sum 变成环境变量
[root@www ~]# declare -x sum
[root@www ~]# export | grep sum
declare -ix sum=&quot;450&quot;          &lt;==果然出现了！包括有 i 与 x 的宣告！

范例三：让 sum 变成只读属性，不可更动！
[root@www ~]# declare -r sum
[root@www ~]# sum=tesgting
-bash: sum: readonly variable  &lt;==不能改这个变量了！ 

范例四：让 sum 变成非环境变量的自定义变量吧！
[root@www ~]# declare +x sum  &lt;== 将 - 变成 + 可以进行『取消』动作
[root@www ~]# declare -p sum  &lt;== -p 可以单独列出变量的类型
declare -ir sum=&quot;450&quot;         &lt;== 只剩下 i, r 的类型，不具有 x 
</code></pre>

<p><strong>（3）数组 (array)</strong></p>

<p>数组 (array) 变量类型，在bash中，数组的设置方式是： <strong>var[index] = content</strong> 。</p>

<p>我有一个数组名为 var ，而这个数组的内容为 var[1]=小明，var[2]=大明， var[3]=好明 &hellip;. 等等，那个 index
就是一些数字，重点是用 <strong>中刮号 ([ ])</strong> 来配置的。</p>

<pre><code>范例：配置上面提到的 var[1] ～ var[3] 的变量。
[root@www ~]# var[1]=&quot;small min&quot;
[root@www ~]# var[2]=&quot;big min&quot;
[root@www ~]# var[3]=&quot;nice min&quot;
[root@www ~]# echo &quot;${var[1]}, ${var[2]}, ${var[3]}&quot;
small min, big min, nice min
</code></pre>

<p>数组的变量类型比较有趣的地方在于“读取”，一般来说，建议直接以 ${数组} 的方式来读取，会比较正确无误。</p>

<h3 id="9-2-7-与文件系统及程序的限制关系-ulimit">9.2.7 与文件系统及程序的限制关系：ulimit</h3>

<p>Linux对于每个用户，系统限制其最大进程数。为提高性能，可以根据设备资源情况，设置各linux 用户的最大进程数。</p>

<p>ulimit主要是用来限制 <strong>进程对资源的使用情况</strong> 的，它支持各种类型的限制，常用的有：</p>

<ul>
<li>内核文件的大小限制</li>
<li>进程数据块的大小限制</li>
<li>Shell进程创建文件大小限制</li>
<li>可加锁内存大小限制</li>
<li>常驻内存集的大小限制</li>
<li>打开文件句柄数限制</li>
<li>分配堆栈的最大大小限制</li>
<li>CPU占用时间限制用户最大可用的进程数限制</li>
<li>Shell进程所能使用的最大虚拟内存限制</li>
</ul>

<p>ulimit使用的 <strong>基本格式</strong> 为： <strong>ulimit [options] [limit]</strong></p>

<p>具体的options参数含义如下表所示：</p>

<p>选项 含义：</p>

<ul>
<li><strong>-a 显示当前系统所有的limit资源信息。</strong></li>
<li>-H 设置硬资源限制，一旦设置不能增加。</li>
<li>-S 设置软资源限制，设置后可以增加，但是不能超过硬资源设置。</li>
<li>-c 最大的core文件的大小，以 blocks 为单位。</li>
<li>-f 进程可以创建文件的最大值，以blocks 为单位.</li>
<li>-d 进程最大的数据段的大小，以Kbytes 为单位。</li>
<li>-m 最大内存大小，以Kbytes为单位。</li>
<li><strong>-n 查看进程可以打开的最大文件描述符的数量。</strong></li>
<li>-s 线程栈大小，以Kbytes为单位。</li>
<li>-p 管道缓冲区的大小，以Kbytes 为单位。</li>
<li><strong>-u 用户最大可用的进程数。</strong></li>
<li>-v 进程最大可用的虚拟内存，以Kbytes 为单位。</li>
<li>-t 最大CPU占用时间，以秒为单位。</li>
<li>-l 最大可加锁内存大小，以Kbytes 为单位。</li>
</ul>

<p>其中ulimit
-n用于限制进程能够打开的文件描述符的最大数目。因为任何设备在linux下都是文件，通信的接口也有专门的接口文件负责，所以linux下进程tcp链接的最大并发量也受限于该值。</p>

<p>想要复解ulimit的设置最简单的方法就是 <strong>注销再登录</strong> ，否则就是得要重新以 <strong>ulimit</strong>
设置才行，不让要注意的是一般身份用户如果以ulimit设置了 <strong>-f</strong> 的文件大小，那么他只能继续减小文件容量，不能增加文件容量。</p>

<p><img src="https://img.it610.com/image/info8/8a5d857831d145869715670f82193fa6.jpg" alt="" /></p>

<p><strong>dd命令：</strong></p>

<p>Linux dd命令用于读取、转换并输出数据。dd可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p>

<p><strong>参数说明:</strong></p>

<ul>
<li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。</li>
<li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。</li>

<li><p>ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br />
obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br />
bs=bytes：同时设置读入/输出的块大小为bytes个字节。</p></li>

<li><p>cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</p></li>

<li><p>skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</p></li>

<li><p>seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</p></li>

<li><p>count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</p></li>

<li><p>conv=，关键字可以有以下11种：</p>

<ul>
<li>conversion：用指定的参数转换文件。</li>
<li>ascii：转换ebcdic为ascii</li>
<li>ebcdic：转换ascii为ebcdic</li>
<li>ibm：转换ascii为alternate ebcdic</li>
<li>block：把每一行转换为长度为cbs，不足部分用空格填充</li>
<li>unblock：使每一行的长度都为cbs，不足部分用空格填充</li>
<li>lcase：把大写字符转换为小写字符</li>
<li>ucase：把小写字符转换为大写字符</li>
<li>swab：交换输入的每对字节</li>
<li>noerror：出错时不停止</li>
<li>notrunc：不截短输出文件</li>
<li>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li>
</ul></li>

<li><p>--help：显示帮助信息</p></li>

<li><p>--version：显示版本信息</p></li>
</ul>

<p><strong>示例：</strong></p>

<p>① 在Linux 下制作启动盘，可使用如下命令：</p>

<pre><code>dd if=boot.img of=/dev/fd0 bs=1440k 
</code></pre>

<p>② 将testfile文件中的所有英文字母转换为大写，然后转成为testfile_1文件，在命令提示符中使用如下命令：</p>

<pre><code>dd if=testfile_2 of=testfile_1 conv=ucase 
</code></pre>

<h3 id="9-2-8-变量内容的删除-替代与替换">9.2.8 变量内容的删除、替代与替换</h3>

<p><strong>（1）变量内容的删除</strong></p>

<pre><code>范例一：先让小写的 path 自定义变量配置的与 PATH 内容相同
[root@www ~]# path=${PATH}
[root@www ~]# echo $path
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin


范例二：假设我不喜欢 kerberos，所以要将前两个目录删除掉，如何显示？
[root@www ~]# echo ${path#/*kerberos/bin:}
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
</code></pre>

<p>上面范例的重点如下：</p>

<p><strong>$</strong> {variable#/*kerberos/bin:}</p>

<p>上面的特殊字体部分是关键词！用在这种删除模式所必须存在的</p>

<p>${ <strong>variable</strong> #/*kerberos/bin:}</p>

<p>这就是原本的变量名称，以上面范例二来说，这里就填写 path 这个『变量名称』！</p>

<p>${variable <strong>#</strong> /*kerberos/bin:}</p>

<p>这是重点！代表『从变量内容的最前面开始向右删除』，且仅删除最短的那个</p>

<p>${variable# <strong>/*kerberos/bin:</strong> }</p>

<p>代表要被删除的部分，由于 # 代表由前面开始删除，所以这里便由开始的 / 写起。</p>

<p>需要注意的是，我们还可以透过通配符 * 来取代 0 到无穷多个任意字符。</p>

<pre><code>范例三：我想要删除前面所有的目录，仅保留最后一个目录
[root@www ~]# echo ${path#/*:}
/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
</code></pre>

<h1 id="由于一个-仅删除掉最短的那个-因此他删除的情况可以用底下的删除线来看-usr-kerberos-sbin">由于一个 <strong>#</strong> 仅删除掉最短的那个，因此他删除的情况可以用底下的删除线来看： <del>/usr/kerberos/sbin:</del></h1>

<p>/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</p>

<pre><code>[root@www ~]# echo ${path##/*:}
/root/bin
</code></pre>

<h1 id="多加了一个-变成-之后-他变成-删除掉最长的那个数据-亦即是">多加了一个 # 变成 ## 之后，他变成『删除掉最长的那个数据』。亦即是：</h1>

<p><del>/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:</del>
/root/bin</p>

<p>因为在 PATH 这个变量的内容中，每个目录都是以冒号 <strong>“:”</strong> 隔开的， 所以要从头删除掉目录就是介于 <strong>斜线 (/) 到冒号 (:)</strong>
之间的数据！</p>

<p>但是 PATH 中不止一个冒号 ( <strong>:</strong> ) 啊！ 所以 <strong># 与 ##</strong> 就分别代表：</p>

<ul>
<li># ：符合取代文字的『最短的』那一个；</li>
<li>##：符合取代文字的『最长的』那一个。</li>
</ul>

<p>上面谈到的是从前面开始删除变量内容，那么如果想要从后面向前删除变量内容呢？这个时候就要用上 <strong>百分比（%）</strong> 符号了。如下。</p>

<pre><code>范例四：想要删除最后面那个目录，亦即从 : 到 bin 为止的字符串
[root@www ~]# echo ${path%:*bin}
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin 
</code></pre>

<h1 id="这个">这个 <strong>%</strong></h1>

<p>符号代表由最后面开始向前删除！所以上面得到的结果其实是来自如下：/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
<del>:/root/bin</del></p>

<pre><code>范例五：那如果我只想要保留第一个目录呢？
[root@www ~]# echo ${path%%:*bin}
/usr/kerberos/sbin
</code></pre>

<h1 id="同样的-代表的则是最长的符合字符串-所以结果其实是来自如下-usr-kerberos-sbin">同样的， <strong>%%</strong> 代表的则是最长的符合字符串，所以结果其实是来自如下：/usr/kerberos/sbin</h1>

<p><del>:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</del></p>

<p><strong>（2）变量内容的替换</strong></p>

<pre><code>范例六：将 path 的变量内容内的 sbin 取代成大写 SBIN：
[root@www ~]# echo ${path/sbin/SBIN}
/usr/kerberos/SBIN:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
</code></pre>

<h1 id="关键词在于那两个斜线-两斜线中间的是-旧字符串-后面的是-新字符串-所以结果就会出现如上述的特殊字体部分">关键词在于那两个斜线，两斜线中间的是 <strong>旧字符串</strong> ，后面的是 <strong>新字符串</strong> ，所以结果就会出现如上述的特殊字体部分。</h1>

<pre><code>[root@www ~]# echo ${path//sbin/SBIN}
/usr/kerberos/SBIN:/usr/kerberos/bin:/usr/local/SBIN:/usr/local/bin:/SBIN:/bin:
/usr/SBIN:/usr/bin:/root/bin
</code></pre>

<h1 id="如果是两条斜线-那么就变成所有符合的内容都会被取代">如果是两条斜线，那么就变成所有符合的内容都会被取代！</h1>

<p><strong>总结：</strong></p>

<p><a href="https://img.it610.com/image/info8/2f3492d2548a4e6cb03bbead7ace94f1.jpg"><img src="https://img.it610.com/image/info8/2f3492d2548a4e6cb03bbead7ace94f1.jpg" alt="Linux（3）：Shell基础_第11张图片" /></a></p>

<p><strong>（3）变量的测试与内容替换</strong></p>

<p>在某些时刻我们常常需要『判断』某个变量是否存在，若变量存在则使用既有的配置，若变量不存在则给予一个常用的配置。</p>

<p>我们举下面的例子来说明。</p>

<pre><code>范例一：测试一下是否存在 username 这个变量，若不存在则给予 username 内容为 root
[root@www ~]# echo $username
                                  &lt;==由于出现空白，所以 username 可能不存在，也可能是空字符串
[root@www ~]# username=${username-root}
[root@www ~]# echo $username
root                              &lt;==因为 username 没有配置，所以主动给予名为 root 的内容。
[root@www ~]# username=&quot;vbird tsai&quot; &lt;==主动配置 username 的内容
[root@www ~]# username=${username-root}
[root@www ~]# echo $username
vbird tsai                   &lt;==因为 username 已经配置了，所以使用旧有的配置而不以 root 取代
</code></pre>

<p>在上面的范例中，重点在于减号 <strong>“-”</strong> 后面接的关键字。</p>

<p><strong>new_var</strong> =${old_var-content}<br />
新的变量，主要用来取代旧变量。新旧变量名称其实常常是一样的<br />
new_var= <strong>$</strong> {old_var-content}<br />
这是本范例中的关键词部分！必须要存在的哩！<br />
new_var=${ <strong>old_var</strong> -content}<br />
旧的变量，被测试的项目！<br />
new_var=${old_var- <strong>content</strong> }<br />
变量的『内容』，在本范例中，这个部分是在『给予未配置变量的内容』</p>

<p>不过这还是有点问题！因为 username 可能已经被配置为『空字符串』了！果真如此的话，那你还可以使用底下的范例来给予 username 的内容成为
root ！</p>

<pre><code>范例二：若 username 未配置或为空字符串，则将 username 内容配置为 root
[root@www ~]# username=&quot;&quot;
[root@www ~]# username=${username-root}
[root@www ~]# echo $username
                   &lt;==因为 username 被配置为空字符串了！所以当然还是保留为空字符串！
[root@www ~]# username=${username:-root}
[root@www ~]# echo $username
root               &lt;==加上“:”后若变量内容为空或者是未配置，都能够以后面的内容替换！
</code></pre>

<p><a href="https://img.it610.com/image/info8/5dcaf81eb384425da8a2275102f3bdb5.jpg"><img src="https://img.it610.com/image/info8/5dcaf81eb384425da8a2275102f3bdb5.jpg" alt="Linux（3）：Shell基础_第12张图片" /></a></p>

<pre><code>测试：先假设 str 不存在 (用 unset) ，然后测试一下等号 (=) 的用法：
[root@www ~]# unset str; var=${str=newvar}
[root@www ~]# echo var=&quot;$var&quot;, str=&quot;$str&quot;
var=newvar, str=newvar  &lt;==因为 str 不存在，所以 var/str 均为 newvar

测试：如果 str 已存在了，测试一下 var 会变怎样？
[root@www ~]# str=&quot;oldvar&quot;; var=${str=newvar}
[root@www ~]# echo var=&quot;$var&quot;, str=&quot;$str&quot;
var=oldvar, str=oldvar  &lt;==因为 str 存在，所以 var 等于 str 的内容
</code></pre>

<p>如果旧变量不存在，整个测试旧告诉我“有错误”，此时就能够使用问好“？”，如下所示。</p>

<pre><code>测试：若 str 不存在时，则 var 的测试结果直接显示 &quot;无此变量&quot;
[root@www ~]# unset str; var=${str?无此变量}
-bash: str: 无此变量    &lt;==因为 str 不存在，所以输出错误信息  

测试：若 str 存在时，则 var 的内容会与 str 相同！
[root@www ~]# str=&quot;oldvar&quot;; var=${str?novar}
[root@www ~]# echo var=&quot;$var&quot;, str=&quot;$str&quot;
var=oldvar, str=oldvar  &lt;==因为 str 存在，所以 var 等于 str 的内容
</code></pre>

<h2 id="9-3-脚本执行方式">9.3 脚本执行方式</h2>

<h3 id="9-3-1-echo">9.3.1 echo</h3>

<p><a href="https://img.it610.com/image/info8/384151cc2a7f429795d049f9afacf95d.jpg"><img src="https://img.it610.com/image/info8/384151cc2a7f429795d049f9afacf95d.jpg" alt="Linux（3）：Shell基础_第13张图片" /></a></p>

<p><strong>echo</strong> 命令的功能是在显示器上 <strong>显示一段文字</strong> ，一般起到 <strong>一个提示的作用</strong> 。<br />
该命令的一般格式为：</p>

<p>****<strong>echo [-ne][字符串]或 echo [&ndash;help][&ndash;version]</strong><br />
其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。用echo命令输出加引号的字符串时，将字符串原样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。<br />
补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。<br />
参 数：</p>

<ul>
<li><strong>-n</strong> 不要在最后自动换行</li>
<li><strong>-e</strong> 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：</li>
</ul>

<p><a href="https://img.it610.com/image/info8/51143cab4c234036920c55ef530bd822.jpg"><img src="https://img.it610.com/image/info8/51143cab4c234036920c55ef530bd822.jpg" alt="Linux（3）：Shell基础_第14张图片" /></a></p>

<p>\\ 插入 <strong>\字符</strong> ；</p>

<p><a href="https://img.it610.com/image/info8/a5e5cc7002aa4ca0b0e73d29f127495a.jpg"><img src="https://img.it610.com/image/info8/a5e5cc7002aa4ca0b0e73d29f127495a.jpg" alt="Linux（3）：Shell基础_第15张图片" /></a></p>

<p><img src="https://img.it610.com/image/info8/fdfddeba683244e1adba8fb8e0e975ca.jpg" alt="" /></p>

<p>echo支持 <strong>修改颜色</strong>
。<img src="https://img.it610.com/image/info8/08806379b6954e3cac3f7f373ced5fee.jpg" alt="" /></p>

<p><img src="https://img.it610.com/image/info8/569fb8d193d04dbe84f88ac4a575f26a.jpg" alt="" /></p>

<p><img src="https://img.it610.com/image/info8/9a63bcb956174b79a46de7a6f5d97d45.jpg" alt="" /></p>

<p>变量的显示：echo。变量的显示能利用echo读出，只是需要在 <strong>变量名称</strong> 前面加上 <strong>$</strong> ，或者是以 <strong>${变量}</strong> 的方式来显示都可以。</p>

<h3 id="9-3-2-第一个脚本">9.3.2 第一个脚本</h3>

<p><a href="https://img.it610.com/image/info8/31ff7ec676b14b3b8d75e578c04d948e.jpg"><img src="https://img.it610.com/image/info8/31ff7ec676b14b3b8d75e578c04d948e.jpg" alt="Linux（3）：Shell基础_第16张图片" /></a></p>

<p>在脚本中第一行要写 #!/bin/bash ，以说明接下来的是标准的Linux shell脚本。</p>

<p>执行脚本的方法：</p>

<ol>
<li>直接命令执行：先赋予执行权限，再使用相对路径或绝对路径调用；或者使用变量“PATH”功能，将hello.sh 放在PATH指定的目录内，例如：~/bin/</li>
<li>以bash进程来执行：通过 <strong>“bash hello.sh”</strong> 或 <strong>“sh hello.sh”</strong> 调用执行脚本。</li>
</ol>

<p>如下图所示。</p>

<p>命令执行时输入命令太长时，利用“\[Enter]”来换行。</p>

<p><a href="https://img.it610.com/image/info8/c15f8b89611f4a918c3c328e1642fe76.jpg"><img src="https://img.it610.com/image/info8/c15f8b89611f4a918c3c328e1642fe76.jpg" alt="Linux（3）：Shell基础_第17张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/0fa53741d36247779a87d87784d9b771.png"><img src="https://img.it610.com/image/info8/0fa53741d36247779a87d87784d9b771.png" alt="" /></a></p>

<h2 id="9-4-别名与快捷键">9.4 别名与快捷键</h2>

<h3 id="9-4-1-别名">9.4.1 别名</h3>

<p>Linux的标准shell是Bash。</p>

<p><a href="https://img.it610.com/image/info8/0852d1b3254644d9afce3907b26a6fca.jpg"><img src="https://img.it610.com/image/info8/0852d1b3254644d9afce3907b26a6fca.jpg" alt="Linux（3）：Shell基础_第18张图片" /></a></p>

<p>如何知道目前有哪些的命令别名呢？就使用 <strong>alias ：</strong></p>

<p><a href="https://img.it610.com/image/info8/c5c0974d5d3a4ec7a2132f844c354360.png"><img src="https://img.it610.com/image/info8/c5c0974d5d3a4ec7a2132f844c354360.png" alt="Linux（3）：Shell基础_第19张图片" /></a></p>

<p>也可使用alias进行修改：</p>

<p><img src="https://img.it610.com/image/info8/dd68752bff054f5b8a1a8d32c4269562.jpg" alt="" /></p>

<p>修改是临时修改的，重启系统就会失效。</p>

<p><a href="https://img.it610.com/image/info8/c2c42228fc5e4ceb967e39303506c2ce.jpg"><img src="https://img.it610.com/image/info8/c2c42228fc5e4ceb967e39303506c2ce.jpg" alt="Linux（3）：Shell基础_第20张图片" /></a></p>

<p>对每个用户单独生效。</p>

<p><a href="https://img.it610.com/image/info8/d1c9db00297c4440b95664cc3502eedf.png"><img src="https://img.it610.com/image/info8/d1c9db00297c4440b95664cc3502eedf.png" alt="Linux（3）：Shell基础_第21张图片" /></a></p>

<p>通过 <strong>source .bashrc</strong> 可立即生效。</p>

<p>unalias也是临时删除，永久删除也需要修改 ~/.bashrc。</p>

<p><a href="https://img.it610.com/image/info8/6b29feb4251f41b58cccaf22961653ca.jpg"><img src="https://img.it610.com/image/info8/6b29feb4251f41b58cccaf22961653ca.jpg" alt="Linux（3）：Shell基础_第22张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/c049e437c2fd43079891d80615280051.png"><img src="https://img.it610.com/image/info8/c049e437c2fd43079891d80615280051.png" alt="" /></a></p>

<p>/bin/ls 为绝对路径，直接用该命令来执行； ls 为命令别名： <strong>alias ls=&lsquo;ls &ndash;color=auto&rsquo;。</strong></p>

<p><img src="https://img.it610.com/image/info8/b84f3186ea4a45c9b4993c1bb0755dd6.png" alt="" /></p>

<h3 id="9-4-2-快捷键">9.4.2 快捷键</h3>

<p><a href="https://img.it610.com/image/info8/8e271573a02d415b83ae0143f4245d12.jpg"><img src="https://img.it610.com/image/info8/8e271573a02d415b83ae0143f4245d12.jpg" alt="Linux（3）：Shell基础_第23张图片" /></a></p>

<h2 id="9-5-历史命令">9.5 历史命令</h2>

<h3 id="9-5-1-history">9.5.1 history</h3>

<p><a href="https://img.it610.com/image/info8/fd2b0ac3535f4516ae2054cae5d8e26b.jpg"><img src="https://img.it610.com/image/info8/fd2b0ac3535f4516ae2054cae5d8e26b.jpg" alt="Linux（3）：Shell基础_第24张图片" /></a></p>

<p><strong>[root@www ~]# history [n]<br />
[root@www ~]# history [-c]<br />
[root@www ~]# history [-raw] histfiles</strong><br />
选项与参数：</p>

<ul>
<li>n ：数字，意思是『要列出最近的 n 笔命令行表』的意思！</li>
<li>-c ：将目前的 shell 中的所有 history 内容全部消除</li>
<li>-a ：将目前新增的 history 命令新增入 histfiles 中，若没有加 histfiles ，则默认写入 ~/.bash_history</li>
<li>-r ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；</li>

<li><p>-w ：将目前的 history 记忆内容写入 histfiles 中！</p>

<p>范例一：列出目前内存内的所有 history 记忆
[root@www ~]# history</p>

<h1 id="前面省略">前面省略</h1>

<p>1017  man bash
 1018  ll
 1019  history
 1020  history</p></li>
</ul>

<h1 id="列出的信息当中-共分两栏-第一栏为该命令在这个-shell-当中的代码-另一个则是命令本身的内容喔-至于会显示几笔命令记录-则与-histsize">列出的信息当中，共分两栏，第一栏为该命令在这个 shell 当中的代码，另一个则是命令本身的内容喔！至于会显示几笔命令记录，则与 HISTSIZE</h1>

<p>有关！</p>

<pre><code>范例二：列出目前最近的 3 笔数据
[root@www ~]# history 3
 1019  history 
 1020  history
 1021  history 3


范例三：立刻将目前的数据写入 histfile 当中
[root@www ~]# history -w
# 在默认的情况下，会将历史纪录写入 ~/.bash_history 当中！
[root@www ~]# echo $HISTSIZE
1000
</code></pre>

<p>在正常的情况下，历史命令的读取与记录是这样的：</p>

<p>当我们以 bash 登陆 Linux 主机之后，系统会主动的由家目录的 <strong>~/.bash_history</strong> 读取以前曾经下过的命令，那么
~/.bash_history 会记录几笔数据呢？这就与你 bash 的 <strong>HISTFILESIZE</strong> 这个变量配置值有关了！</p>

<p>假设我这次登陆主机后，共下达过 <strong>100</strong> 次命令，『等我注销时， 系统就会将 <strong>101~1100</strong> 这总共 1000 笔历史命令升级到
~/.bash_history 当中。』 也就是说，历史命令在我注销时，会将最近的 HISTFILESIZE 笔记录到我的纪录文件当中啦！当然，也可以用
<strong>history -w</strong> 强制立刻写入的！那为何用『升级』两个字呢？ 因为 <strong>~/.bash_history</strong> 记录的笔数永远都是
HISTFILESIZE 那么多， <strong>旧的信息会被主动的拿掉</strong> ！ 仅保留最新的！</p>

<p><a href="https://img.it610.com/image/info8/dbe0d41bce4244329041c01bdf4f76af.jpg"><img src="https://img.it610.com/image/info8/dbe0d41bce4244329041c01bdf4f76af.jpg" alt="" /></a></p>

<p><strong>vi /etc/profile</strong></p>

<p><a href="https://img.it610.com/image/info8/811d297b496d4bf48eb071675a5635b8.jpg"><img src="https://img.it610.com/image/info8/811d297b496d4bf48eb071675a5635b8.jpg" alt="Linux（3）：Shell基础_第25张图片" /></a></p>

<p>~/.bash_history 记录的是前一次登录以前所执行过的命令，而至于 <strong>这一次登录所执行的命令都被暂存在临时内存</strong>
中，当你成功注销系统后，该命令记忆才会记录到 <strong>.bash_history</strong> 中。</p>

<h3 id="9-5-2-历史命令的调用">9.5.2 历史命令的调用</h3>

<p>那么 history 这个历史命令只可以让我查询命令而已吗？当然不止，。 我们可以利用相关的功能来帮我们运行命令！</p>

<p><strong>[root@www ~]# !number<br />
[root@www ~]# !command<br />
[root@www ~]# !!</strong></p>

<p><strong>选项与参数：</strong><br />
number ：运行第几笔命令的意思；<br />
command ：由最近的命令向前搜寻『命令串开头为 command』的那个命令，并运行；<br />
!! ：就是运行上一个命令(相当于按↑按键后，按 Enter)</p>

<p><a href="https://img.it610.com/image/info8/aade54090d51400b87611c6c4e9b14b8.jpg"><img src="https://img.it610.com/image/info8/aade54090d51400b87611c6c4e9b14b8.jpg" alt="Linux（3）：Shell基础_第26张图片" /></a></p>

<pre><code>[root@www ~]# history
   66  man rm
   67  alias
   68  man history
   69  history 
[root@www ~]# !66  &lt;==运行第 66 笔命令
[root@www ~]# !!   &lt;==运行上一个命令，本例中亦即 !66 
[root@www ~]# !al  &lt;==运行最近以 al 为开头的命令(上头列出的第 67 个)
</code></pre>

<h3 id="9-5-3-命令和文件补全">9.5.3 命令和文件补全</h3>

<p>###
<img src="https://img.it610.com/image/info8/ee21a1e9b045415aa8affa495187cc39.jpg" alt="" /></p>

<p>系统命令的补全也依赖于 <strong>$PATH</strong> 环境变量。这个按键的功能就是在bash里面才有的。</p>

<p>命令与文件补全功能([Tab]按键的好处）<br />
经常在bash环境中使用[Tab]是个很好的习惯，因为 <strong>至少可以让你少打很多字，并且确定输入的数据是正确的</strong>
。使用[Tab]按键的时机依据[Tab]接在命令后或参数后而有所不同。</p>

<ul>
<li>[Tab] 接在一串命令的第一个字的后面，则为 <strong>命令补全</strong> ；</li>
<li>[Tab] 接在一串命令的第二个字以后时，则为 <strong>文件补齐</strong> 。</li>
</ul>

<p>所以说，如果我想要知道我的环境中所有可以执行的命令有几个，就直接在 <strong>bash</strong> 的提示符后面连续 <strong>按两次[Tab]</strong>
按键就能够显示所有的可执行命令了。那如果想要知道系统当中所有以c为开头的命令呢?就按下 <strong>“c[Tab][Tab]”</strong> 就好。</p>

<h2 id="9-6-数据流重定向">9.6 数据流重定向</h2>

<p>数据流重导向 （redirect） 由字面上的意思来看，好像就是将“数据给他传导到其他地方去”的样子？
没错～数据流重导向就是将某个指令执行后应该要出现在屏幕上的数据， 给他传输到其他的地方，例如文件或者是设备 （例如打印机之类的）！这在 <strong>Linux
的文字模式</strong> 下面可重要的！ 尤其是如果我们想要将某些数据储存下来时，就更有用了！</p>

<p>一般来说，如果你要执行一个指令，通常他会是这样的：</p>

<p><img src="https://img.it610.com/image/info8/e5d2a87135fa428eadc1bc7d9f8a08b1.jpg" alt="" /></p>

<p>图1 指令执行过程的数据传输情况</p>

<p>我们执行一个指令的时候，这个指令可能会由文件读入数据，经过处理之后，再将数据输出到屏幕上。 在上图当中， <strong>standard output</strong> 与
<strong>standard error output</strong> 分别代表 <strong>“标准输出 （STDOUT）”</strong> 与 <strong>“标准错误输出 （STDERR）”</strong> ，
这两个默认都是输出到屏幕上面来的。</p>

<p><strong>standard output</strong> 与 <strong>standard error output</strong></p>

<p>简单的说，标准输出指的是“指令执行所回传的正确的讯息”，而标准错误输出可理解为“ 指令执行失败后，所回传的错误讯息”。举个简单例子来说，我们的系统默认有
/etc/crontab 但却无 /etc/vbirdsay， 此时若下达“ cat /etc/crontab /etc/vbirdsay
”这个指令时，cat 会进行：</p>

<ul>
<li>标准输出：读取 /etc/crontab 后，将该文件内容显示到屏幕上；</li>
<li>标准错误输出：因为无法找到 /etc/vbirdsay，因此在屏幕上显示错误讯息</li>
</ul>

<h3 id="9-6-1-标准输入输出">9.6.1 标准输入输出</h3>

<p><a href="https://img.it610.com/image/info8/2bf07f09cb62404b98f10fc45e3a8bd7.jpg"><img src="https://img.it610.com/image/info8/2bf07f09cb62404b98f10fc45e3a8bd7.jpg" alt="Linux（3）：Shell基础_第27张图片" /></a></p>

<p>在Linux中，一切皆文件。</p>

<p>不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱乱的！那能不能通过某些机制将这两股数据分开呢？
当然可以！那就是数据流重导向的功能啊！数据流重导向可以将 <strong>standard output （简称 stdout）</strong> 与 <strong>standard
error output （简称 stderr）</strong> 分别传送到其他的文件或设备去，而分别传送所用的特殊字符则如下所示：</p>

<ol>
<li>标准输入 （stdin） ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</li>
<li>标准输出 （stdout）：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</li>
<li>标准错误输出（stderr）：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</li>
</ol>

<h3 id="9-6-2-输出重定向">9.6.2 输出重定向</h3>

<p><img src="https://img.it610.com/image/info8/161c49a3e1bb4815887cf1696c7258fd.jpg" alt="" /></p>

<ul>
<li>1&gt; ：以覆盖的方法将“正确的数据”输出到指定的文件或设备上；</li>
<li>1&gt;&gt;：以累加的方法将“正确的数据”输出到指定的文件或设备上；</li>
<li>2&gt; ：以覆盖的方法将“错误的数据”输出到指定的文件或设备上；</li>
<li>2&gt;&gt;：以累加的方法将“错误的数据”输出到指定的文件或设备上；</li>
</ul>

<p>要注意， <strong>“ 1 &gt;&gt; ”</strong>以及 <strong>“ 2 &gt;&gt; ”</strong>中间是没有空格的。</p>

<p>Windows和Linux中都有定时任务。</p>

<p><a href="https://img.it610.com/image/info8/17eb9017d2544b84a1638556bcf57e6f.jpg"><img src="https://img.it610.com/image/info8/17eb9017d2544b84a1638556bcf57e6f.jpg" alt="Linux（3）：Shell基础_第28张图片" /></a></p>

<p>此时错误输出时，大于号的右边没有空格。</p>

<p>例如：</p>

<p>（1）如果想要将正确的与错误的数据分别存入不同的文件中需要怎么做？</p>

<pre><code>范例：将 stdout 与 stderr 分存到不同的文件去
[dmtsai@study ~]$ find /home -name .bashrc &gt; list_right 2&gt; list_error
</code></pre>

<p>（2）/dev/null 垃圾桶黑洞设备与特殊写法</p>

<p>/dev/null
可以吃掉任何导向这个设备的信息，结果不显示在屏幕，也不保存在文件里：<img src="https://img.it610.com/image/info8/52efe17f7efb45ba83f3b92e8b716a12.jpg" alt="" /></p>

<pre><code>范例四：承范例三，将错误的数据丢弃，屏幕上显示正确的数据
[dmtsai@study ~]$ find /home -name .bashrc 2&gt; /dev/null
/home/dmtsai/.bashrc  &lt;==只有 stdout 会显示到屏幕上， stderr 被丢弃了
</code></pre>

<p>（3）要将正确与错误数据通通写入同一个文件去呢？</p>

<pre><code>范例五：将指令的数据全部写入名为 list 的文件中
[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt; list  &lt;==错误
[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1     &lt;==正确
[dmtsai@study ~]$ find /home -name .bashrc &amp;&gt; list         &lt;==正确
</code></pre>

<p>上述表格第一行错误的原因是，由于两股数据同时写入一个文件，又没有使用 <strong>特殊的语法</strong> ，
此时两股数据可能会交叉写入该文件内，造成次序的错乱。所以虽然最终 <strong>list</strong>
文件还是会产生，但是里面的数据排列就会怪怪的，而不是原本屏幕上的输出排序。 至于写入同一个文件的特殊语法如上表所示，你可以使用 **2 &gt;&amp;1
**也可以使用 ** &amp;&gt; 。**</p>

<p><strong>为何要使用命令输出重导向呢？</strong></p>

<ul>
<li>屏幕输出的信息很重要，而且我们需要将他存下来的时候；</li>
<li>背景执行中的程序，不希望他干扰屏幕正常的输出结果时；</li>
<li>一些系统的例行命令 （例如写在 /etc/crontab 中的文件） 的执行结果，希望他可以存下来时；</li>
<li>一些执行命令的可能已知错误讯息时，想以“ 2&gt; /dev/null ”将他丢掉时；</li>
<li>错误讯息与正确讯息需要分别输出时。</li>
</ul>

<h3 id="9-6-3-输入重定向-standard-input-与">9.6.3 输入重定向（standard input ： &lt; 与 &lt;</h3>

<p><a href="https://img.it610.com/image/info8/97767133b17247488dba4da8e2a0f2ef.jpg"><img src="https://img.it610.com/image/info8/97767133b17247488dba4da8e2a0f2ef.jpg" alt="Linux（3）：Shell基础_第29张图片" /></a></p>

<p>执行wc命令后，点“Ctrl+D”退出输入。</p>

<p><a href="https://img.it610.com/image/info8/4526ca5bf89f44218d4aecf81821d48e.png"><img src="https://img.it610.com/image/info8/4526ca5bf89f44218d4aecf81821d48e.png" alt="Linux（3）：Shell基础_第30张图片" /></a></p>

<p><strong>行数、单词数、字符数。</strong></p>

<p><a href="https://img.it610.com/image/info8/97fb6dec2cda49d89d5cc9feb19ff7a2.jpg"><img src="https://img.it610.com/image/info8/97fb6dec2cda49d89d5cc9feb19ff7a2.jpg" alt="Linux（3）：Shell基础_第31张图片" /></a></p>

<p>软件安装打补丁时可能会用到 <strong>输入重定向</strong> 。</p>

<p>以最简单的说法来说， <strong>“就是“将原本需要由键盘输入的数据，改由文件内容来取代”的意思。</strong></p>

<p><strong>cat：</strong></p>

<p>cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的；</p>

<p>cat主要有 <strong>三大功能：</strong></p>

<ol>
<li>一次显示整个文件。$ cat filename；</li>
<li>从键盘创建一个文件。$ cat &gt; filename 只能创建新文件,不能编辑已有文件；</li>
<li>将几个文件合并为一个文件。$cat file1 file2 &gt; file</li>
</ol>

<p>cat具体命令格式为 : <strong>cat [-AbeEnstTuv] [&ndash;help] [&ndash;version] fileName</strong></p>

<p><strong>参数说明：</strong></p>

<ul>
<li><strong>-n 或 &ndash;number</strong> ：由 1 开始对所有输出的行数编号。</li>
<li><strong>-b 或 &ndash;number-nonblank</strong> ：和 -n 相似，只不过对于空白行不编号。</li>
<li><strong>-s 或 &ndash;squeeze-blank</strong> ：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
<li><strong>-v 或 &ndash;show-nonprinting</strong> ：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</li>
<li><strong>-E 或 &ndash;show-ends</strong> : 在每行结束处显示 $。</li>
<li><strong>-T 或 &ndash;show-tabs</strong> : 将 TAB 字符显示为 ^I。</li>
<li><strong>-A, &ndash;show-all</strong> ：等价于 -vET。</li>
<li><strong>-e：</strong> 等价于&rdquo;-vE&rdquo;选项；</li>
<li><strong>-t：</strong> 等价于&rdquo;-vT&rdquo;选项；</li>
</ul>

<p><strong>示例：</strong></p>

<pre><code>清空 /etc/test.txt 文档内容：
cat /dev/null &gt; /etc/test.txt

cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：
cat /dev/fd0 &gt; OUTFILE

相反的，如果想把 image file 写到软盘，输入：
cat IMG_FILE &gt; /dev/fd0
</code></pre>

<p><strong>注</strong> ：</p>

<ul>
<li>1. OUTFILE 指输出的镜像文件名。</li>
<li>2. IMG_FILE 指镜像文件。</li>
<li>3. 若从镜像文件写回 device 时，device 容量需与相当。</li>
<li>4. 通常用制作开机磁片。</li>
</ul>

<p><strong>然后由下面的 cat 指令操作来了解一下什么叫做“键盘输入”：</strong></p>

<pre><code>范例六：利用 cat 指令来创建一个文件的简单流程
[dmtsai@study ~]$ cat &gt; catfile
testing
cat file test
&lt;==这里按下 [ctrl]+d 来离开

[dmtsai@study ~]$ cat catfile
testing
cat file test
</code></pre>

<p>由于加入 ** &gt; **在 cat 后，所以那个 catfile 会被主动的创建，而内容就是刚刚键盘上面输入的那两行数据了。</p>

<p>能不能用纯文本文件取代键盘的输入，也就是说，用 <strong>某个文件的内容来取代键盘的敲击</strong> 呢？ 如下所示：</p>

<pre><code>范例七：用 stdin 取代键盘的输入以创建新文件的简单流程
[dmtsai@study ~]$ cat &gt; catfile &lt; ~/.bashrc
[dmtsai@study ~]$ ll catfile ~/.bashrc
-rw-r--r--. 1 dmtsai dmtsai 231 Mar  6 06:06 /home/dmtsai/.bashrc
-rw-rw-r--. 1 dmtsai dmtsai 231 Jul  9 18:58 catfile
# 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！
</code></pre>

<p>** &lt;&lt;** 这个连续两个小于的符号,代表的是 <strong>“结束的输入字符”</strong> 的意思。举例来讲：“我要用 cat 直接将输入的讯息输出到 catfile
中， 且当由键盘输入 eof 时，该次输入就结束”，那我可以这样做：</p>

<pre><code>[dmtsai@study ~]$ cat &gt; catfile &lt;&lt; &quot;eof&quot;
&gt; This is a test.
&gt; OK now stop
&gt; eof           &lt;==输入这关键字，立刻就结束而不需要输入 [ctrl]+d

[dmtsai@study ~]$ cat catfile
This is a test.
OK now stop     &lt;==只有这两行，不会存在关键字那一行！
</code></pre>

<p>利用 &lt;&lt; 右侧的控制字符，我们可以终止一次输入， 而不必输入 [crtl]+d 来结束。</p>

<h2 id="9-7-管道符">9.7 管道符</h2>

<h3 id="9-7-1-多命令顺序执行">9.7.1 多命令顺序执行</h3>

<p><a href="https://img.it610.com/image/info8/1b64269b67ce4499bb6e2c827eb62df9.jpg"><img src="https://img.it610.com/image/info8/1b64269b67ce4499bb6e2c827eb62df9.jpg" alt="Linux（3）：Shell基础_第32张图片" /></a></p>

<p><strong>（1）cmd ; cmd</strong> （不考虑指令相关性的连续指令下达）</p>

<p>在指令与指令中间利用分号 <strong>（;）</strong> 来隔开，这样一来，分号前的指令执行完后就会立刻接着执行后面的指令了。</p>

<p>简单地检测命令是否正确执行。</p>

<p><strong>（2）$? （指令回传值） 与 &amp;&amp; 或 ||</strong></p>

<p>如同上面谈到的，两个指令之间有 <strong>相依性</strong> ，而这个相依性主要判断的地方就在于 <strong>前一个指令执行的结果是否正确</strong> 。
指令回传值，“若前一个指令执行的结果为正确，在 Linux 下面会回传一个 <strong>$? = 0</strong> 的值”。
那么我们怎么通过这个回传值来判断后续的指令是否要执行呢？这就得要借由“ ** &amp;&amp;** ”及“ <strong>||</strong> ”的帮忙了！ 注意喔，两个 ** &amp;**
之间是没有空格的！那个 <strong>|</strong> 则是 <strong>[Shift]+[]</strong> 的按键结果。</p>

<p><strong>例如：</strong> 我不清楚 /tmp/abc 是否存在，但就是要创建 /tmp/abc/hehe 文件</p>

<pre><code>[dmtsai@study ~]$ ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe
</code></pre>

<p>上面这个范例总是会尝试创建 <strong>/tmp/abc/hehe</strong> 的喔！不论 <strong>/tmp/abc</strong> 是否存在。 由于Linux
下面的指令都是由左往右执行的，所以范例三有几种结果我们来分析一下：</p>

<ul>
<li>（1）若 /tmp/abc 不存在故回传 $?≠0，则 （2）因为 || 遇到非为 0 的 $? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 $?=0 （3）因为 &amp;&amp; 遇到 $?=0 故会执行 touch /tmp/abc/hehe，最终 hehe 就被创建了；</li>
<li>（1）若 /tmp/abc 存在故回传 $?=0，则 （2）因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故 （3）因为 &amp;&amp; 遇到 $?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</li>
</ul>

<p>整个流程图示如下：</p>

<p><a href="https://img.it610.com/image/info8/55ccc6210c1f4f4ba7d7677652036f30.gif"><img src="https://img.it610.com/image/info8/55ccc6210c1f4f4ba7d7677652036f30.gif" alt="Linux（3）：Shell基础_第33张图片" /></a></p>

<p>图 指令依序执行的关系示意图</p>

<p><strong>例题：</strong> 以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 &ldquo;exist&rdquo; ，若不存在，则显示 &ldquo;not
exist&rdquo;！这又牵涉到逻辑判断的问题，如果存在就显示某个数据，若不存在就显示其他数据，那我可以这样做：</p>

<pre><code> ls /tmp/vbirding &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;
</code></pre>

<p>由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错。一般来说，假设判断式有三个，也就是：</p>

<blockquote>
<p>command1 &amp;&amp; command2 || command3</p>
</blockquote>

<p>而且顺序通常不会变，因为一般来说， command2 与 command3 会放置肯定可以执行成功的指令</p>

<p><a href="https://img.it610.com/image/info8/af80c26c43ae4cf383384879f64e071d.png"><img src="https://img.it610.com/image/info8/af80c26c43ae4cf383384879f64e071d.png" alt="" /></a></p>

<p>不能将&amp;&amp;与|| 弄反，应该先写逻辑与，再写逻辑或：</p>

<p><a href="https://img.it610.com/image/info8/27303ff09a1b45b8bfa1e32a208ae252.jpg"><img src="https://img.it610.com/image/info8/27303ff09a1b45b8bfa1e32a208ae252.jpg" alt="Linux（3）：Shell基础_第34张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/7d69354a96b347178e337ea7ee90970a.jpg"><img src="https://img.it610.com/image/info8/7d69354a96b347178e337ea7ee90970a.jpg" alt="" /></a></p>

<p><a href="https://img.it610.com/image/info8/168c2d2688744c5fb94b0ab11f5a43e5.jpg"><img src="https://img.it610.com/image/info8/168c2d2688744c5fb94b0ab11f5a43e5.jpg" alt="Linux（3）：Shell基础_第35张图片" /></a></p>

<h3 id="9-7-2-管道符">9.7.2 管道符</h3>

<p>就如同前面所说的， bash 命令执行的时候有输出的数据会出现！ 那么如果这群数据 <strong>必需要经过几道手续</strong>
之后才能得到我们所想要的格式，应该如何来设置？ 这就牵涉到 <strong>管线命令的问题了 （pipe）</strong> ，管线命令使用的是“ <strong>|</strong> ”这个界定符号！
另外，管线命令与“连续下达命令”是不一样的！ 下面我们先举一个例子来说明一下简单的管线命令。</p>

<p>假设我们想要知道 <strong>/etc/</strong> 下面有多少文件，那么可以利用 <strong>ls /etc</strong> 来查阅，不过， 因为 <strong>/etc</strong>
下面的文件太多，导致一口气就将屏幕塞满了～不知道前面输出的内容是啥？此时，我们可以通过 <strong>less</strong> 指令的协助，利用：</p>

<pre><code>[root@localhost ~]# ls -al /etc | less
</code></pre>

<p>如此一来，使用 ls 指令输出后的内容，就能够被 less 读取，并且利用 less 的功能，我们就能够前后翻动相关的信息了。我们就来了解一下这个管线命令“
| ”的用途吧！ 其实这个管线命令“ | ”仅能处理经由前面一个指令传来的正确信息，也就是 <strong>standard output</strong> 的信息，对于
<strong>stdandard error</strong> 并没有直接处理的能力。那么整体的管线命令可以使用下图表示：</p>

<p><a href="https://img.it610.com/image/info8/8452c7d4a1ae4fb6b4e12a6ac0438687.png"><img src="https://img.it610.com/image/info8/8452c7d4a1ae4fb6b4e12a6ac0438687.png" alt="Linux（3）：Shell基础_第36张图片" /></a></p>

<p>图 管线命令的处理示意图</p>

<p>在每个管线后面接的第一个数据必定是 <strong>“指令”</strong> 喔！而且这个指令必须要能够接受 <strong>standard input</strong> 的数据才行，这样的指令才可以是为
<strong>“管线命令”</strong> ，例如 <strong>less</strong> , <strong>more</strong> , <strong>head</strong> , <strong>tail</strong> 等都是可以接受 <strong>standard</strong>
<strong>input</strong> 的管线命令啦。至于例如 <strong>ls, cp, mv</strong> 等就不是管线命令了！因为 <strong>ls, cp, mv</strong> 并不会接受来自
<strong>stdin</strong> 的数据。 也就是说，管线命令主要有两个比较需要注意的地方：</p>

<ul>
<li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li>
<li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</li>
</ul>

<p>如果要让 standard error 可以被管线命令所使用，那该如何处理？其实就是通过上一小节的数据流重导向。</p>

<p><strong>（1）选取命令： cut, grep</strong></p>

<p>一般来说，选取讯息通常是针对“一行一行”来分析的， 并不是整篇讯息分析的喔～下面我们介绍两个很常用的讯息选取命令：</p>

<p><strong>① cut：</strong></p>

<p><strong>[dmtsai@study ~]$ cut -d &lsquo;分隔字符&rsquo; -f fields &lt;==用于有特定分隔字符<br />
[dmtsai@study ~]$ cut -c 字符区间 &lt;==用于排列整齐的讯息</strong><br />
选项与参数：</p>

<ul>
<li>-d ：后面接分隔字符。与 -f 一起使用；</li>
<li>-f ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；</li>
<li>-c ：以字符 （characters） 的单位取出固定字符区间；</li>
</ul>

<p>例如：将 export 输出的讯息，取得第 12 字符以后的所有字串</p>

<pre><code>[dmtsai@study ~]$ export | cut -c 12-
HISTCONTROL=&quot;ignoredups&quot;
HISTSIZE=&quot;1000&quot;
HOME=&quot;/home/dmtsai&quot;
HOSTNAME=&quot;study.centos.vbird&quot;
.....（其他省略）.....
# 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！
# 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！
</code></pre>

<p>cut 在处理多空格相连的数据时，可能会比较吃力一点，所以某些时刻可能会使用 awk 来取代！</p>

<p><strong>② grep</strong></p>

<p>刚刚的 cut 是将 <strong>一行</strong> 讯息当中，取出某部分我们想要的，而 grep 则是分析 <strong>一行讯息</strong> ， 若当中有我们所需要的信息，就将
<strong>该行</strong> 拿出来～简单的语法是这样的：</p>

<p><strong>[dmtsai@study ~]$ grep [-acinv] [&ndash;color=auto] &lsquo;搜寻字串&rsquo; filename</strong><br />
 <strong>选项与参数：</strong></p>

<ul>
<li>-a ：将 binary 文件以 text 文件的方式搜寻数据</li>
<li>-c ：计算找到 &lsquo;搜寻字串&rsquo; 的次数</li>
<li>-i ：忽略大小写的不同，所以大小写视为相同</li>
<li>-n ：顺便输出行号</li>
<li>-v ：反向选择，亦即显示出没有 &lsquo;搜寻字串&rsquo; 内容的那一行！</li>
<li>--color=auto ：可以将找到的关键字部分加上颜色的显示喔！</li>
</ul>

<p>范例：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一列</p>

<p><img src="https://img.it610.com/image/info8/e4dff50e8da844f5966ed731acb47c4c.jpg" alt="" /></p>

<p>CentOS 7 当中，默认的 grep 已经主动加上 &ndash;color=auto 在 alias 内了！</p>

<p><strong>（2）排序命令： sort, wc, uniq</strong></p>

<p>下面我们介绍几个好用的排序与统计指令：</p>

<p><strong>① sort</strong></p>

<p>sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据类型来排序喔！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此，
如果您需要排序时，建议使用 <strong>LANG=C</strong> 来让语系统一，数据排序比较好一些。 <strong>[dmtsai@study ~]$ sort
[-fbMnrtuk] [file or stdin]</strong><br />
 <strong>选项与参数：</strong></p>

<ul>
<li>-f ：忽略大小写的差异，例如 A 与 a 视为编码相同；</li>
<li>-b ：忽略最前面的空白字符部分；</li>
<li>-M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</li>
<li>-n ：使用“纯数字”进行排序（默认是以文字体态来排序的）；</li>
<li>-r ：反向排序；</li>
<li>-u ：就是 uniq ，相同的数据中，仅出现一行代表；</li>
<li>-t ：分隔符号，默认是用 [tab] 键来分隔；</li>
<li>-k ：以那个区间 （field） 来进行排序的意思</li>
</ul>

<p>示例：</p>

<pre><code>范例：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？
[dmtsai@study ~]$ cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash
# 看到特殊字体的输出部分了吧？怎么会这样排列啊？
# 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：
# cat /etc/passwd | sort -t ':' -k 3 -n
# 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！

范例：利用 last ，将输出的数据仅取帐号，并加以排序
[dmtsai@study ~]$ last | cut -d ' ' -f1 | sort
</code></pre>

<p><strong>② uniq</strong></p>

<p>如果我排序完成了，想要将重复的数据仅列出一个显示，可以怎么做呢？</p>

<p><strong>[dmtsai@study ~]$ uniq [-ic]</strong><br />
选项与参数：</p>

<ul>
<li>-i ：忽略大小写字符的不同；</li>

<li><p>-c ：进行计数</p>

<p>使用 last 将帐号列出，仅取出帐号栏，进行排序，还想要知道每个人的登陆总次数
[root@localhost ~]# last | cut -d &lsquo; &rsquo; -f 1 | sort | uniq -c
      1
      9 reboot
     20 root
      1 wtmp</p></li>
</ul>

<p><strong>③ wc</strong></p>

<p>如果我想要知道 <strong>/etc/man_db.conf</strong> 这个文件里面有多少字？多少行？多少字符的话， 可以怎么做呢？其实可以利用 wc
这个指令来达成喔！他可以帮我们计算输出的讯息的整体数据。</p>

<p><strong>[dmtsai@study ~]$ wc [-lwm]</strong><br />
选项与参数：</p>

<ul>
<li>-l ：仅列出行；</li>
<li>-w ：仅列出多少字（英文单字）；</li>

<li><p>-m ：多少字符；</p>

<p>范例：我知道使用 last 可以输出登陆者，但是 last 最后两行并非帐号内容，那么请问，我该如何以一行指令串取得登陆系统的总人次？
[root@localhost ~]# last |grep [a-zA-Z] | grep -v &lsquo;wtmp&rsquo; | wc -l
29</p>

<h1 id="由于-last-会输出空白行-wtmp-unknown-reboot-等无关帐号登陆的信息-因此-我利用">由于 last 会输出空白行, wtmp, unknown, reboot 等无关帐号登陆的信息，因此，我利用</h1>

<h1 id="grep-取出非空白行-以及去除上述关键字那几行-再计算行数-就能够了解啰">grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰！</h1></li>
</ul>

<p><strong>（3）双向重定向： tee</strong></p>

<p>我们由前一节知道 ** &gt;** 会将数据流整个传送给文件或设备，因此我们除非去读取该文件或设备，
否则就无法继续利用这个数据流。万一我想要将这个数据流的处理过程中将某段讯息存下来，应该怎么做？ 利用 <strong>tee</strong> 就可以～我们可以这样简单的看一下：</p>

<p>图 tee 的工作流程示意图</p>

<p>tee 会同时将数据流分送到文件去与屏幕 （ <strong>screen</strong> ）；而输出到屏幕的，其实就是 <strong>stdout</strong> ，那就可以让下个指令继续处理喔！</p>

<p><strong>[dmtsai@study ~]$ tee [-a] file</strong><br />
选项与参数：</p>

<ul>
<li>-a ：以累加 （append） 的方式，将数据加入 file 当中！</li>
</ul>

<p>例如：让我们将 last 的输出存一份到 last.list 文件中，并在屏幕显示第一列；</p>

<p><a href="https://img.it610.com/image/info8/49d3813abc2e4b839a2e140eeed221d9.png"><img src="https://img.it610.com/image/info8/49d3813abc2e4b839a2e140eeed221d9.png" alt="Linux（3）：Shell基础_第37张图片" /></a></p>

<p><img src="https://img.it610.com/image/info8/b0a25d08486c416abc476b6dd83c1ce1.png" alt="" /></p>

<p><strong>（4）字符转换命令： tr, col, join, paste, expand</strong></p>

<p><strong>① tr</strong></p>

<p>我们在 vim 程序编辑器当中，提到过 DOS 断行字符与 Unix 断行字符的不同，并且可以使用 dos2unix 与 unix2dos 来完成转换。</p>

<p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</p>

<p><strong>[dmtsai@study ~]$ tr [-ds] SET1 &hellip;</strong><br />
选项与参数：</p>

<ul>
<li>-d ：删除讯息当中的 SET1 这个字串；</li>

<li><p>-s ：取代掉重复的字符！</p>

<p>范例：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除
[dmtsai@study ~]$ cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd
[dmtsai@study ~]$ file /etc/passwd ~/passwd
/etc/passwd:         ASCII text
/home/dmtsai/passwd: ASCII text, with CRLF line terminators  &lt;==就是 DOS 断行
[dmtsai@study ~]$ cat ~/passwd | tr -d &lsquo;\r&rsquo; &gt; ~/passwd.linux</p>

<h1 id="那个-r-指的是-dos-的断行字符-关于更多的字符-请参考-man-tr">那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</h1>

<p>[dmtsai@study ~]$ ll /etc/passwd ~/passwd*
-rw-r&ndash;r&ndash;. 1 root   root   2092 Jun 17 00:20 /etc/passwd
-rw-r&ndash;r&ndash;. 1 dmtsai dmtsai 2133 Jul  9 22:13 /home/dmtsai/passwd
-rw-rw-r&ndash;. 1 dmtsai dmtsai 2092 Jul  9 22:13 /home/dmtsai/passwd.linux</p>

<h1 id="处理过后-发现文件大小与原本的-etc-passwd-就一致了">处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</h1></li>
</ul>

<p><strong>② col</strong></p>

<p><strong>[dmtsai@study ~]$ col [-xb]</strong><br />
选项与参数：</p>

<ul>
<li><p>-x ：将 tab 键转换成对等的空白键</p>

<p>范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白
[dmtsai@study ~]$ cat -A /etc/man_db.conf  &lt;==此时会看到很多 ^I 的符号，那就是 tab
[dmtsai@study ~]$ cat /etc/man_db.conf | col -x | cat -A | more</p>

<h1 id="嘿嘿-如此一来-tab-按键会被取代成为空白键-输出就美观多了">嘿嘿！如此一来， [tab] 按键会被取代成为空白键，输出就美观多了！</h1></li>
</ul>

<p>虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 <strong>[tab] 按键</strong> 取代成为 <strong>空白键</strong> ！ 例如上面的例子当中，如果使用
cat -A 则 [tab] 会以 <strong>^I 来</strong> 表示。 但经过 <strong>col -x</strong> 的处理，则会将 [tab] 取代成为对等的空白键！</p>

<p><strong>③ join</strong></p>

<p>join 看字面上的意义 （加入/参加） 就可以知道，他是在处理两个文件之间的数据， 而且，主要是在处理“两个文件当中，有 <strong>&ldquo;相同数据&rdquo;</strong>
的那一行，才将他加在一起”的意思。</p>

<p><strong>[dmtsai@study ~]$ join [-ti12] file1 file2</strong><br />
选项与参数：</p>

<ul>
<li>-t ：join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，</li>
<li>如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个！</li>
<li>-i ：忽略大小写的差异；</li>
<li>-1 ：这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思；</li>
<li>-2 ：代表“第二个文件要用那个字段来分析”的意思。</li>
</ul>

<p>我们利用下面的简单例子来说明：</p>

<pre><code>我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 
        /etc/group 当中的第三个字段，请问如何将两个文件整合？
[root@study ~]# join -t ':' -1 4 /etc/passwd -2 3 /etc/group | head -n 3
0:root:x:0:root:/root:/bin/bash:root:x:
1:bin:x:1:bin:/bin:/sbin/nologin:bin:x:
2:daemon:x:2:daemon:/sbin:/sbin/nologin:daemon:x:
# 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。
</code></pre>

<p>需要特别注意的是，在使用 <strong>join</strong> 之前，你所需要处理的文件应该要事先经过 <strong>排序 （sort）</strong> 处理！ 否则有些比对的项目会被略过！</p>

<p><strong>④ paste</strong></p>

<p>这个 paste 就要比 join 简单多了！相对于 <strong>join</strong> 必须要比对两个文件的数据相关性， <strong>paste</strong>
就直接“将两行贴在一起，且中间以 <strong>[tab]</strong> 键隔开”而已！简单的使用方法：</p>

<p><strong>[dmtsai@study ~]$ paste [-d] file1 file2</strong><br />
选项与参数：</p>

<ul>
<li>-d ：后面可以接分隔字符。默认是以 [tab] 来分隔的！</li>
<li>- ：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</li>
</ul>

<p>例如：用 root 身份，先将 /etc/group 读出（用 cat），然后将 /etc/passwd 与 /etc/shadow 同一行贴在一起：</p>

<p><a href="https://img.it610.com/image/info8/eec4d6d0ac884a14bdc6efb2378d1fa4.png"><img src="https://img.it610.com/image/info8/eec4d6d0ac884a14bdc6efb2378d1fa4.png" alt="" /></a></p>

<p><strong>⑤ expand</strong></p>

<p>就是在将 <strong>[tab] 按键</strong> 转成 <strong>空白键</strong> 啦～可以这样玩：</p>

<p><strong>[dmtsai@study ~]$ expand [-t] file</strong><br />
选项与参数：</p>

<ul>
<li><p>-t ：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</p>

<p>将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出；仅取前三行；将所有的符号都列出来；将 [tab] 按键设置成 6 个字符
[dmtsai@study ~]$ grep &lsquo;^MANPATH&rsquo; /etc/man_db.conf | head -n 3 | expand -t 6 - | cat -A
MANPATH_MAP /bin              /usr/share/man$
MANPATH_MAP /usr/bin          /usr/share/man$
MANPATH_MAP /sbin             /usr/share/man$
123456123456123456123456123456123456123456123456&hellip;</p>

<h1 id="仔细看一下上面的数字说明-因为我是以-6-个字符来代表一个-tab-的长度-所以-man-到-usr-之间">仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，MAN&hellip; 到 /usr 之间</h1>

<p>会隔 12 （两个 [tab]） 个字符喔！如果 tab 改成 9 的话，情况就又不同了！</p></li>
</ul>

<p>此外，您也可以参考一下 unexpand 这个将空白转成 [tab] 的指令功能。</p>

<p><strong>（5）切割命令： split</strong></p>

<p>如果你有文件太大，导致一些携带式设备无法复制的问题，找 split 就对了！
他可以帮你将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了！</p>

<p><strong>[dmtsai@study ~]$ split [-bl] file PREFIX</strong><br />
选项与参数：</p>

<ul>
<li>-b ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；</li>
<li>-l ：以行数来进行分区。</li>

<li><p>PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。</p>

<p>范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？
[dmtsai@study ~]$ cd /tmp; split -b 300k /etc/services services
[dmtsai@study tmp]$ ll -k services*
-rw-rw-r&ndash;. 1 dmtsai dmtsai 307200 Jul  9 22:52 servicesaa
-rw-rw-r&ndash;. 1 dmtsai dmtsai 307200 Jul  9 22:52 servicesab
-rw-rw-r&ndash;. 1 dmtsai dmtsai  55893 Jul  9 22:52 servicesac</p>

<h1 id="那个文件名可以随意取的啦-我们只要写上前导文字-小文件就会以xxxaa-xxxab-xxxac-等方式来创建小文件的">那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！</h1>

<p>范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback
[dmtsai@study tmp]$ cat services* &gt;&gt; servicesback</p>

<h1 id="就用数据流重导向就好啦">就用数据流重导向就好啦！</h1>

<p>范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件
[dmtsai@study tmp]$ ls -al / | split -l 10 - lsroot
[dmtsai@study tmp]$ wc -l lsroot*
  10 lsrootaa
  10 lsrootab
   4 lsrootac
  24 total</p>

<h1 id="重点在那个-啦-一般来说-如果需要-stdout-stdin-时-但偏偏又没有文件">重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，</h1>

<h1 id="有的只是-时-那么那个-就会被当成-stdin-或-stdout">有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</h1></li>
</ul>

<p><strong>（6）参数代换： xargs</strong></p>

<p>xargs 是在做什么的呢？就以字面上的意义来看， <strong>x</strong> 是加减乘除的乘号， <strong>args</strong> 则是 <strong>arguments （参数）</strong>
的意思，所以说，这个玩意儿就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以 <strong>空白字符</strong> 或 <strong>断行字符</strong>
作为分辨，将 stdin 的数据分隔成为 <strong>arguments</strong> 。
因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了。</p>

<p><strong>[dmtsai@study ~]$ xargs [-0epn] command</strong><br />
选项与参数：</p>

<ul>
<li>-0 ：如果输入的 stdin 含有特殊字符，例如 <strong>`</strong> , *<em>*</em> , <strong>空白键</strong> 等等字符时，这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔！</li>
<li>-e ：这个是 EOF （end of file） 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，就会停止继续工作！</li>
<li>-p ：在执行每个指令的 argument 时，都会询问使用者的意思；</li>
<li>-n ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</li>
</ul>

<p>当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</p>

<p>例如：将所有的 /etc/passwd 内的账号都以finger查询，但一次查询5个账户</p>

<p><a href="https://img.it610.com/image/info8/8943c26f063745869f9af421a3684ade.png"><img src="https://img.it610.com/image/info8/8943c26f063745869f9af421a3684ade.png" alt="Linux（3）：Shell基础_第38张图片" /></a></p>

<p>这个 <strong>-p</strong> 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</p>

<ul>
<li><strong>finger：</strong></li>
</ul>

<p>finger命令可以让使用者查询一些其他使用者的资料。会列出来的资料有：</p>

<ul>
<li>Login Name</li>
<li>User Name</li>
<li>Home directory</li>
<li>Shell</li>
<li>Login status</li>
<li>mail status</li>
<li>.plan</li>
<li>.project</li>
<li>.forward</li>
</ul>

<p>其中 .plan、.project 和 .forward 就是使用者在他的 <strong>Home Directory</strong> 里的 <strong>.plan ， .project
和 .forward</strong> 等档案里的资料。如果没有就没有。finger
指令并不限定于在同一服务器上查询，也可以寻找某一个远端服务器上的使用者。只要给一个像是 E-mail address 一般的地址即可。</p>

<p>使用权限：所有使用者。</p>

<p><strong>语法：</strong></p>

<pre><code>finger [options] user[@address]
</code></pre>

<p><strong>参数说明</strong> ：</p>

<ul>
<li>-l 多行显示。</li>
<li>-s 单行显示。这个选项只显示登入名称、真实姓名、终端机名称、闲置时间、登入时间、办公室号码及电话号码。如果所查询的使用者是远端服务器的使用者，这个选项无效。</li>
</ul>

<p>会使用 <strong>xargs</strong> 的原因是， 很多指令其实并不支持 <strong>管线命令</strong> ，因此我们可以通过 <strong>xargs</strong> 来提供该指令引用
<strong>standard input</strong> 之用！</p>

<pre><code>范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性
[dmtsai@study ~]$ find /usr/sbin -perm +7000 | xargs ls -l
-rwx--s--x. 1 root lock      11208 Jun 10  2014 /usr/sbin/lockdev
-rwsr-xr-x. 1 root root     113400 Mar  6 12:17 /usr/sbin/mount.nfs
-rwxr-sr-x. 1 root root      11208 Mar  6 11:05 /usr/sbin/netreport
.....（下面省略）.....
# 应该会想到使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例
</code></pre>

<p><strong>（7）关于减号 - 的用途</strong></p>

<p>管线命令在 <strong>bash</strong> 的连续的处理程序中是相当重要的！另外，在 log file 的分析当中也是相当重要的一环，
所以请特别留意！另外，在管线命令当中，常常会使用到前一个指令的 <strong>stdout</strong> 作为这次的 <strong>stdin</strong> ， 某些指令需要用到文件名称 （例如
tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 &ldquo;-&rdquo; 来替代， 举例来说：</p>

<p><a href="https://img.it610.com/image/info8/e8ca3b9fbc894bf5a40aa740c39ef0a0.png"><img src="https://img.it610.com/image/info8/e8ca3b9fbc894bf5a40aa740c39ef0a0.png" alt="Linux（3）：Shell基础_第39张图片" /></a></p>

<p><img src="https://img.it610.com/image/info8/a3842d83867540dc8cff0265739f6e73.png" alt="" /></p>

<p>上面这个例子是说：“我将 <strong>/home</strong> 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 <strong>stdout</strong> ； 经过管线后，将
<strong>tar -cvf - /home</strong> 传送给后面的 <strong>tar -xvf -</strong> ”。后面的这个 <strong>-</strong> 则是取用前一个指令的 <strong>stdout</strong>
， 因此，我们就不需要使用 <strong>filename</strong> 了！</p>

<p><img src="https://img.it610.com/image/info8/80b7f174db4940e1b58f842dd0836116.jpg" alt="" /></p>

<p>more 是用来查看文件中的内容，分屏显示。</p>

<p>使用管道符，命令2一定要能操作命令1。</p>

<p><a href="https://img.it610.com/image/info8/96853d3c1cac4bf7aa68db51ee56a4cf.jpg"><img src="https://img.it610.com/image/info8/96853d3c1cac4bf7aa68db51ee56a4cf.jpg" alt="Linux（3）：Shell基础_第40张图片" /></a></p>

<p><strong>netstat -a</strong> ：查看系统中所有的网络连接。</p>

<p>LISTEN：这个端口被监听，等待有人访问； ESTABLISHED：有人正在连接。</p>

<p><a href="https://img.it610.com/image/info8/13728dfd5877490080e0c86b9f9b04eb.jpg"><img src="https://img.it610.com/image/info8/13728dfd5877490080e0c86b9f9b04eb.jpg" alt="" /></a></p>

<h2 id="9-8-通配符与特殊符号">9.8 通配符与特殊符号</h2>

<h3 id="9-8-1-通配符">9.8.1 通配符</h3>

<p>一般查找目录。</p>

<p><a href="https://img.it610.com/image/info8/a5da31b4ee36441e8c78741b43ba634f.jpg"><img src="https://img.it610.com/image/info8/a5da31b4ee36441e8c78741b43ba634f.jpg" alt="Linux（3）：Shell基础_第41张图片" /></a></p>

<h3 id="9-8-2-bash中其他特殊符号">9.8.2 Bash中其他特殊符号</h3>

<p><a href="https://img.it610.com/image/info8/15113bb08b1a41a0b435b96c7c264479.jpg"><img src="https://img.it610.com/image/info8/15113bb08b1a41a0b435b96c7c264479.jpg" alt="Linux（3）：Shell基础_第42张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/c02e2121847e488d9dd749e7c96af65f.jpg"><img src="https://img.it610.com/image/info8/c02e2121847e488d9dd749e7c96af65f.jpg" alt="Linux（3）：Shell基础_第43张图片" /></a></p>

<p>以上为 bash 环境中常见的特殊符号汇整！理论上，你的“文件名”尽量不要使用到上述的字符！</p>

<p><a href="https://img.it610.com/image/info8/f4dce83d01e745e5921cc421133cca8e.png"><img src="https://img.it610.com/image/info8/f4dce83d01e745e5921cc421133cca8e.png" alt="Linux（3）：Shell基础_第44张图片" /></a></p>

<p>反引号：在键盘1旁边。</p>

<p><a href="https://img.it610.com/image/info8/1bdfdb4b04104b799450e85f2ef85461.png"><img src="https://img.it610.com/image/info8/1bdfdb4b04104b799450e85f2ef85461.png" alt="Linux（3）：Shell基础_第45张图片" /></a></p>

<p><img src="https://img.it610.com/image/info8/d205f691f6e94d9a88032010e3876d7c.jpg" alt="" /></p>

<h2 id="9-9-bash-shell-的操作环境">9.9 Bash Shell 的操作环境</h2>

<h3 id="9-9-1-路径与命令查找顺序">9.9.1 路径与命令查找顺序</h3>

<p><a href="https://img.it610.com/image/info8/6b29feb4251f41b58cccaf22961653ca.jpg"><img src="https://img.it610.com/image/info8/6b29feb4251f41b58cccaf22961653ca.jpg" alt="Linux（3）：Shell基础_第46张图片" /></a></p>

<h3 id="9-9-2-bash-的登录与欢迎信息-etc-issue-etc-motd">9.9.2 bash 的登录与欢迎信息：/etc/issue，/etc/motd</h3>

<p>bash的登录和欢迎信息设置。</p>

<p>issue内的各代码的意义：</p>

<ul>
<li>\d 本地端时间的日期</li>
<li>\l 显示第几个终端机接口</li>
<li>\m 显示硬件的等级(i386/i486/i586)</li>
<li>\n 显示主机的网络名称</li>
<li>\o 显示domain name</li>
<li>\r 操作系统的版本(uname -r)</li>
<li>\t 显示本地端时间的时间</li>
<li>\s 操作系统时间</li>
<li>\v 操作系统的版本<br /></li>
</ul>

<p>1、 <strong>/etc/issue</strong> 本地登陆显示的信息， <strong>本地登录前</strong></p>

<p>2、 <strong>/etc/issue.net</strong> 网络登陆显示的信息， <strong>登录后显示，需要由sshd配置</strong></p>

<p>3、 <strong>/etc/motd</strong> 常用于通告信息，如计划关机时间的警告等， <strong>登陆后的提示信息</strong></p>

<p>至于文件 <strong>/etc/motd</strong> ，( <strong>motd即motd即message of today</strong> 布告栏信息的缩写)
则是在每次用户登录时，motd文件的内容会显示在用户的终端。系统管理员可以在文件中编辑系统活动消息，例如：管理员通知用户系统何时进行软件或硬件的升级、何时进行系统维护等。如果shell支持中文，还可以使用中文，这样看起来更易于了解。/etc/motd缺点是，现在许多用户登录系统时选择自动进入图形界面，所以这些信息往往看不到。</p>

<p><strong>issue与motd文件主要区别</strong> 在于：当一个用户过本地文本设备（如本地终端，本地虚拟控制台等）登录 <strong>/etc/issue</strong>
的文件内容显示在login提示符之前，而 <strong>/etc/motd</strong> 内容显示在用户成功登录系统之后。</p>

<p><strong>issue.net文件（只针对网络用户）&ndash;</strong>
若通过远程本文设备（如通过ssh或telnet等）登录，则显示该文件的内容。使用ssh登录时，会不会显示 <strong>issue信息</strong> 由sshd服务的
<strong>sshd_config的Banner属性</strong> 配置决定。</p>

<p>其中上面的三个文件，issue.net和motd文件都是在登录后显示，那么顺序是怎么样的呢，如下图所示：</p>

<p><a href="https://img.it610.com/image/info8/22278bc05859449bb5c06efa7b0a0a99.jpg"><img src="https://img.it610.com/image/info8/22278bc05859449bb5c06efa7b0a0a99.jpg" alt="Linux（3）：Shell基础_第47张图片" /></a></p>

<p>在这里使用的是 <strong>Putty</strong> 进行登录，我们可以发现先显示的是 <strong>issue.net</strong> 文件中的内容，最后才显示 <strong>motd</strong>
文件中的内容。又使用 <strong>Xshell</strong> 进行登录，得出的结果一样、都是先显示 <strong>issue.net</strong> 文件内容，最后显示 <strong>motd</strong>
文件的内容。 <strong>中间隔着上次登录信息</strong> 。</p>

<p>其中不同的是：</p>

<ul>
<li>使用Putty登录时，当我们 <strong>输入用户名root</strong> 后，就显示了 <strong>issue.net</strong> 的内容， <strong>输入密码后，</strong> 再显示的motd的内容。</li>
<li>使用Xshell登录时，只有当我们输入用户名和密码后，验证成功了，才会依次显示issue.net和motd文件的内容。</li>
</ul>

<h3 id="9-9-3-bash-的环境配置文件">9.9.3 bash 的环境配置文件</h3>

<p>在Linux中系统有一些环境配置文件，让bash在启动是直接读取这些配置文件，以规划好bash的操作环境。配置文件可分为 <strong>全体的配置文件</strong> 以及
<strong>用户个人偏好配置文件。</strong></p>

<p><strong>一、login 与 non-login shell</strong></p>

<ul>
<li>login shell： 取得 bash 是需要完整的登录流程，就称为 login shell。例如，你要由 tty1~tty6 登入，需要输入用户的账号与密码，此时取得的 bash 就称为 login shell</li>
<li>non-login shell：取得 bash 接口的方法不需要重复登入的操作。例如，①你以 X widow 登入 Linux后，在以 X 图形化接口启动终端机，此时那个终端并没有需要再次输入账号和密码，那个 bash 的环境就称 non-login shell 。② 你原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入账号和密码，那第二个 bash（子程序）也是 non-login shell。</li>
</ul>

<p>介绍 login 和 non-login shell 是因为这两个取得 <strong>bash</strong> 的情况下， <strong>读取的配置文件数据</strong> 并不一样所致。</p>

<p><strong>（1）login shell</strong></p>

<p>我们先来谈谈 <strong>login shell</strong> 。一般来说 login shell 会读取两个配置文件：</p>

<ul>
<li>/etc/profile：这是系统整体的设定，最好不要修改这个文件；</li>
<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，可以写在这里。</li>
</ul>

<p><strong>① /etc/profile(login shell 才会读)</strong><br />
可以使用 vim 去阅读这个文件的内容，这个配置文件可以利用 <strong>使用者的标识符（UID）</strong> 来决定很多重要的变量数据，这也是每个使用者登入取得 bash
时一定会读取的文件,所以如果你想要帮所有者设定整体环境，可以改这里。不过，没事还是不要随便改这个文件，这个文件设定的有其他重要变量，也会引用其他文件。例如，/etc/profile.d/*.sh、/etc/local.conf等等。</p>

<p>这个文件设置的变量主要有：</p>

<ul>
<li>PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；</li>
<li>MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名；</li>
<li>USER：根据使用者的帐号设置此一变量内容；</li>
<li>HOSTNAME：依据主机的 hostname 指令决定此一变量内容；</li>
<li>HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000 ；</li>
<li>umask：包括 root 默认为 022 而一般用户为 002 等！</li>
</ul>

<p><strong>/etc/profile</strong> 可不止会做这些事而已，他还会去调用外部的设置数据！在 CentOS 5.x 默认的情况下，下面这些数据会依序的被调用进来：</p>

<ul>
<li>/etc/inputrc</li>
</ul>

<p>其实这个文件并没有被执行。/etc/profle会主动判断用户有没有自定义输入的按键功能，如果没有的话，/etc/protile
就会决定设置“INPUTRC=/etc/inputrc”这个变量。此文件内容为bash 的热键、[Tab]有没有声音等的数据。</p>

<ul>
<li>/etc/profile.d/*.sh</li>
</ul>

<p>其实这是个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该文件就会被
<strong>/etc/profile</strong> 调用进来。在 CentOS 5.x 中，这个目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls
指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在这个目录下面自行创建扩展名为 .sh
的文件，并将所需要的数据写入即可！</p>

<ul>
<li>/et/sysconfigi18n</li>
</ul>

<p>这个文件是由/etc/prolle.d/lang.sh调用的。这也是我们决定bash 默认使用何种语系的重要配置文件。文件里最重要的就是
LANG/LC_ALL 这些个变量的设置。 <strong>bash</strong> 的 <strong>login shell</strong> 情况下所读取的整体环境配置文件其实只有
<strong>/etc/profile，</strong> 但是 <strong>/etc/profile</strong> 还会调用其他的配置文件，所以让我们的bash操作接口变得非常的友善。</p>

<p><strong>② ~/.bash_profile(login shell 才会读)</strong><br />
bash 在读完整体环境设定的 /etc/profile 并藉此呼叫其他配置文件后，接下来则是会读取使用者的个人配置文件。在login shell 的
bash 环境中，所读取的个人偏好配置文件其实主要有三个，依顺序分别为：</p>

<ol>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
</ol>

<p>其实 <strong>bash</strong> 的 <strong>login shell</strong> 设定只会读取上面三个文件的其中一个，而读取的顺序则是依照上面的顺序。 如果
~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。
会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。<br />
最后，看看这个 login shell 的读取流程：<br />
<img src="https://img.it610.com/image/info8/306a231611a142ffb725c398e1c0b118.jpg" alt="" /></p>

<p><strong>实线</strong> 的方向是主线程流程， <strong>虚线</strong> 的方向则是被调用的配置文件。</p>

<p><strong>source ：读入环境配置文件的指令</strong></p>

<p>由于 <strong>/etc/profile</strong> 与 <strong>~/.bash_profile</strong> 都是在取得 login shell 的时候才会读取的配置文件，所以，
如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。那么，能不能直接读取配置文件而不登出登陆呢？ 可以的！那就得要利用
source 这个指令了！</p>

<p><strong>[root@localhost ~]# source 配置文件文件名</strong></p>

<pre><code>范例：将主文件夹的 ~/.bashrc 的设置读入目前的 bash 环境中
[dmtsai@study ~]$ source ~/.bashrc  &lt;==下面这两个指令是一样的！
[dmtsai@study ~]$  .  ~/.bashrc
</code></pre>

<p>利用 <strong>source</strong> 或 <strong>小数点 （.）</strong> 都可以将配置文件的内容读进来目前的 shell 环境中！ 举例来说，我修改了
<strong>~/.bashrc</strong> ，那么不需要登出，立即以 <strong>source ~/.bashrc</strong> 就可以将刚刚最新设置的内容读进来目前的环境中！还有，包括
~/bash_profile 以及 /etc/profile 的设置中， 很多时候也都是利用到这个 <strong>source （或小数点）</strong> 的功能！</p>

<p>有没有可能会使用到不同环境配置文件的时候？有啊！ 最常发生在一个人的工作环境分为多种情况的时候了！举个例子来说，在鸟哥的大型主机中，
常常需要负责两到三个不同的案子，每个案子所需要处理的环境变量订定并不相同，
那么鸟哥就将这两三个案子分别编写属于该案子的环境变量设置文件，当需要该环境时，就直接“ source 变量文件
”，如此一来，环境变量的设置就变的更简便而灵活了！</p>

<p><strong>（2）non-login shell</strong></p>

<ul>
<li>~/.bashrc （non-login shell 会读）</li>
</ul>

<p>谈完了 login shell 后，那么 non-login shell 这种非登陆情况取得 bash 操作接口的环境配置文件又是什么？ 当你取得 non-
login shell 时，该 bash 配置文件仅会读取 <strong>~/.bashrc</strong> 而已！那么默认的 ~/.bashrc 内容是如何？</p>

<pre><code>[root@study ~]# cat ~/.bashrc
# .bashrc

# User specific aliases and functions
alias rm='rm -i'             &lt;==使用者的个人设置
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then  &lt;==整体的环境设置
        . /etc/bashrc
fi
</code></pre>

<p>特别注意一下，由于 root 的身份与一般使用者不同。以 root 的身份登录和一般使用者的 ~/.bashrc 会有些许不同。看一下，你会发现在 root
的 ~/.bashrc 中其实已经规范了较为保险的命令别名了。 此外，咱们的 CentOS 5.x 还会主动的调用 /etc/bashrc
这个文件喔！为什么需要调用 /etc/bashrc 呢？ 因为 /etc/bashrc 帮我们的 bash 定义出下面的数据：</p>

<ul>
<li>依据不同的 UID 规范出 umask 的值；</li>
<li>依据不同的 UID 规范出提示字符 （就是 PS1 变量）；</li>
<li>调用 /etc/profile.d/*.sh 的设置</li>
</ul>

<p>你要注意的是，这个 <strong>/etc/bashrc</strong> 是 CentOS 特有的 （其实是 Red Hat 系统特有的），其他不同的 distributions
可能会放置在不同的文件名就是了。由于这个 ~/.bashrc 会调用 /etc/bashrc 及 /etc/profile.d/*.sh ，
所以，万一你没有 ~/.bashrc （可能自己不小心将他删除了），那么你会发现你的 bash 提示字符可能会变成这个样子：</p>

<pre><code>-bash-4.2$
</code></pre>

<p>不要太担心啦！这是正常的，因为你并没有调用 <strong>/etc/bashrc</strong> 来规范 PS1 变量啦！而且这样的情况也不会影响你的 bash 使用。
如果你想要将命令提示字符捉回来，那么可以复制 <strong>/etc/skel/.bashrc</strong> 到你的主文件夹，再修订一下你所想要的内容， 并使用
<strong>source</strong> 去调用 <strong>~/.bashrc</strong> ，那你的命令提示字符就会回来啦！</p>

<p><strong>二、其他相关的配置文件</strong></p>

<p>事实上还有一些配置文件可能会影响到你的 bash 操作的，下面就来谈一谈：</p>

<ul>
<li>/etc/man_db.conf</li>
</ul>

<p>这个文件乍看之下好像跟 bash 没相关性，但是对于系统管理员来说， 却也是很重要的一个文件！这文件的内容“规范了使用 man 的时候， man page
的路径到哪里去寻找！”所以说的简单一点，这个文件规定了下达 man 的时候，该去哪里查看数据的路径设置！</p>

<p>那么什么时候要来修改这个文件呢？如果你是以 tarball 的方式来安装你的数据，那么你的 man page 可能会放置在
/usr/local/softpackage/man 里头，那个 softpackage 是你的套件名称， 这个时候你就得以手动的方式将该路径加到
/etc/man_db.conf 里头，否则使用 man 的时候就会找不到相关的说明文档。</p>

<ul>
<li>~/.bash_history</li>
</ul>

<p>还记得我们在历史命令提到过这个文件吧？默认的情况下， 我们的历史命令就记录在这里！而这个文件能够记录几笔数据，则与 <strong>HISTFILESIZE</strong>
这个变量有关。每次登陆 bash 后，bash 会先读取这个文件，将所有的历史指令读入内存， 因此，当我们登陆 bash 后就可以查知上次使用过哪些指令。</p>

<ul>
<li>~/.bash_logout</li>
</ul>

<p>这个文件则记录了“当我登出 bash 后，系统再帮我做完什么动作后才离开”的意思。 你可以去读取一下这个文件的内容，默认的情况下，登出时， bash
只是帮我们清掉屏幕的讯息而已。 不过，你也可以将一些备份或者是其他你认为重要的工作写在这个文件中 （例如清空暂存盘）， 那么当你离开 Linux
的时候，就可以解决一些烦人的事情！</p>

<h3 id="9-9-4-终端机的环境设置-stty-set">9.9.4 终端机的环境设置： stty, set</h3>

<p><strong>（1）stty</strong></p>

<p>如何查阅目前的一些按键内容呢？可以利用 stty （setting tty 终端机的意思） 呢！ <strong>stty</strong> 也可以帮助设置终端机的输入按键代表意义！</p>

<p><strong>[dmtsai@study ~]$ stty [-a]</strong><br />
 <strong>选项与参数</strong> ：<br />
-a ：将目前所有的 stty 参数列出来；</p>

<pre><code>范例一：列出所有的按键与按键内容
[dmtsai@study ~]$ stty -a
speed 38400 baud; rows 20; columns 90; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;
flush = ^O; min = 1; time = 0;
....（以下省略）....
</code></pre>

<p>我们可以利用 <strong>stty -a</strong> 来列出目前环境中所有的按键列表，在上头的列表当中，需要注意的是特殊字体那几个， 此外，如果出现 <strong>^</strong> 表示
<strong>[Ctrl]</strong> 那个按键的意思。举例来说， <strong>intr = ^C</strong> 表示利用 <strong>[ctrl] + c</strong> 来达成的。几个重要的代表意义是：</p>

<ul>
<li>intr : 送出一个 interrupt （中断） 的讯号给目前正在 run 的程序 （就是终止啰！）；</li>
<li>quit : 送出一个 quit 的讯号给目前正在 run 的程序；</li>
<li>erase : 向后删除字符，</li>
<li>kill : 删除在目前命令行上的所有文字；</li>
<li>eof : End of file 的意思，代表“结束输入”。</li>
<li>start : 在某个程序停止后，重新启动他的 output</li>
<li>stop : 停止目前屏幕的输出；</li>
<li>susp : 送出一个 terminal stop 的讯号给正在 run 的程序。</li>
</ul>

<p><strong>（2）set</strong></p>

<p>除了 stty 之外，其实我们的 bash 还有自己的一些终端机设置值呢！那就是利用 set 来设置的！ 我们之前提到一些变量时，可以利用 set
来显示，除此之外，其实 set 还可以帮我们设置整个指令输出/输入的环境。 例如 <strong>记录历史命令</strong> 、 <strong>显示错误内容</strong> 等等。</p>

<p><strong>[dmtsai@study ~]$ set [-uvCHhmBx]</strong><br />
 <strong>选项与参数：</strong></p>

<ul>
<li>-u ：默认不启用。若启用后，当使用未设置变量时，会显示错误讯息；</li>
<li>-v ：默认不启用。若启用后，在讯息被输出前，会先显示讯息的原始内容；</li>
<li>-x ：默认不启用。若启用后，在指令被执行前，会显示指令内容（前面有 ++ 符号）</li>
<li>-h ：默认启用。与历史命令有关；</li>
<li>-H ：默认启用。与历史命令有关；</li>
<li>-m ：默认启用。与工作管理有关；</li>
<li>-B ：默认启用。与刮号 [] 的作用有关；</li>

<li><p>-C ：默认不启用。若使用 &gt; 等，则若文件存在时，该文件不会被覆盖。</p>

<p>范例一：显示目前所有的 set 设置值
[dmtsai@study ~]$ echo $-
himBH</p>

<h1 id="那个-变量内容就是-set-的所有设置啦-bash-默认是-himbh-喔">那个 $- 变量内容就是 set 的所有设置啦！ bash 默认是 himBH 喔！</h1>

<p>范例二：设置 &ldquo;若使用未定义变量时，则显示错误讯息&rdquo;
[dmtsai@study ~]$ set -u
[dmtsai@study ~]$ echo $vbirding
-bash: vbirding: unbound variable</p>

<h1 id="默认情况下-未设置-未宣告-的变量都会是-空的-不过-若设置-u-参数">默认情况下，未设置/未宣告 的变量都会是“空的”，不过，若设置 -u 参数，</h1>

<h1 id="那么当使用未设置的变量时-就会有问题啦-很多的-shell-都默认启用-u-参数">那么当使用未设置的变量时，就会有问题啦！很多的 shell 都默认启用 -u 参数。</h1>

<h1 id="若要取消这个参数-输入-set-u-即可">若要取消这个参数，输入 set +u 即可！</h1>

<p>范例三：执行前，显示该指令内容。
[dmtsai@study ~]$ set -x
++ printf &lsquo;\033]0;%s@%s:%s\007&rsquo; dmtsai study &lsquo;~&rsquo;    # 这个是在列出提示字符的控制码！
[dmtsai@study ~]$ echo ${HOME}</p>

<ul>
<li><p>echo /home/dmtsai
/home/dmtsai
++ printf &lsquo;\033]0;%s@%s:%s\007&rsquo; dmtsai study &lsquo;~&rsquo;</p>

<h1 id="看见否-要输出的指令都会先被打印到屏幕上喔-前面会多出-的符号">看见否？要输出的指令都会先被打印到屏幕上喔！前面会多出 + 的符号！</h1></li>
</ul></li>
</ul>

<p>另外，其实我们还有其他的按键设置功能呢！就是在前一小节提到的 /etc/inputrc 这个文件里面设置。 还有例如 <strong>/etc/DIR</strong> _
<strong>COLORS</strong> _ **** 与 <strong>/usr/share/terminfo/</strong>_ **** 等，也都是与终端机有关的环境设置文件呢！ _</p>

<p>我们将 bash 默认的组合键给他汇整如下：</p>

<p><a href="https://img.it610.com/image/info8/9dbc8d281573435b8d5861f392071c82.jpg"><img src="https://img.it610.com/image/info8/9dbc8d281573435b8d5861f392071c82.jpg" alt="Linux（3）：Shell基础_第48张图片" /></a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>