<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell脚本编程神器之awk语法案例详解 | 开发者问答集锦</title>
    <meta property="og:title" content="shell脚本编程神器之awk语法案例详解 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell脚本编程神器之awk语法案例详解">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E7%A5%9E%E5%99%A8%E4%B9%8Bawk%E8%AF%AD%E6%B3%95%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell脚本编程神器之awk语法案例详解</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>AWK入门指南</p>

<h3 id="文章目录">文章目录</h3>

<ul>
<li>shell脚本编程神器之awk语法案例详解

<ul>
<li>安装AWK</li>
<li>AWK 起步示例</li>
<li>AWK程序的结构</li>
<li>执行 awk 程序

<ul>
<li>awk 的错误提示</li>
</ul></li>
<li>简单输出

<ul>
<li>打印每一行</li>
<li>打印特定行</li>
<li>NF，字段数量</li>
<li>打印行号</li>
<li>在输出中添加内容</li>
</ul></li>
<li>高级输出

<ul>
<li>字段排队</li>
<li>排序输出</li>
<li>选择

<ul>
<li>通过对比选择</li>
</ul></li>
<li>通过计算选择</li>
<li>通过文本内容选择</li>
<li>模式组合</li>
<li>BEGIN 与 END</li>
<li>AWK 工作流图</li>
<li>使用 AWK 进行计算

<ul>
<li>计数</li>
<li>求和与平均值</li>
</ul></li>
<li>处理文本</li>
<li>打印最后一个输入行</li>
</ul></li>
<li>AWK 内置函数

<ul>
<li>行、单词以及字符的计数</li>
<li>AWK 控制语句

<ul>
<li>if-else 语句</li>
<li>while 语句</li>
<li>for 语句</li>
</ul></li>
<li>数组</li>
<li>--dump-variables 操作查看全局变量</li>
<li>--help 操作可以寻得帮助</li>
<li>--version 查看版本信息</li>
<li>-v 操作</li>
<li>--lint 操作提示信息</li>
<li>正则匹配</li>
<li>内置变量

<ul>
<li>ARGC ：命令行中提供的参数个数</li>
<li>ARGV 表示命令行入参构成的数组，索引是 0~ARGC-1</li>
<li>CONVFMT</li>
<li>ENVIRON 环境变量</li>
<li>FILENAME 表示当前文件</li>
<li>FS 表示文件分隔符</li>
<li>NF 表示当前行的字段（列数）</li>
<li>NR 表示当前读到的行数</li>
<li>RLENGTH</li>
<li>RSTART 表示第一个<strong>match</strong>函数匹配到的字符串中的位置</li>
<li>$0 表示全部的输入记录</li>
<li>$n 表示第n列(第n个字段)，以文件分隔符分隔，默认是空白字符。</li>
<li>ARGIND 表示当前处理的 ARGV 的索引值</li>
<li>PROCINFO 表示进程相关信息</li>
</ul></li>
<li>运算符操作

<ul>
<li>自增符操作</li>
<li>自减符操作</li>
<li>+=、 -=、 *=、/=、%=、 ^=、**=操作</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>三目运算符</li>
<li>字符串连接符</li>
<li>数组关系操作符</li>
<li>正则表达式操作符</li>
</ul></li>
<li>数组

<ul>
<li><strong>delete</strong> 删除数组元素</li>
<li>多维数组</li>
</ul></li>
<li>字符串函数

<ul>
<li>index(str, substr)</li>
<li>gsub(regex, sub, string)</li>
<li>match(str, regex)</li>
<li>split(str, arr, regex)</li>
<li>strtonum(str)</li>
<li>substr(str, start, l)</li>
<li>tolower(str)</li>
<li>toupper(str)</li>
</ul></li>
<li>时间函数

<ul>
<li>systime()</li>
<li>mktime(datespec)</li>
<li>strftime(format, timestamp)</li>
</ul></li>
<li>位操作函数

<ul>
<li>and</li>
<li>lshift(num, size)</li>
<li>rshift(num, size)</li>
<li>or 按位或</li>
<li>xor 异或</li>
</ul></li>
</ul></li>
<li>自定义函数

<ul>
<li>输出转移操作

<ul>
<li>重定向数据到文件</li>
<li>追加内容到文件中</li>
<li>管道 pipe</li>
<li>双向通信</li>
</ul></li>
<li>整齐打印

<ul>
<li>水平tab间隔打印</li>
<li>垂直tab打印</li>
<li>回车打印</li>
<li>换页打印</li>
<li>格式说明符</li>
</ul></li>
</ul></li>
<li>AWK 概览

<ul>
<li>AWK 的类型</li>
<li>AWK 的典型应用场景</li>
<li>AWK 环境

<ul>
<li>安装包管理器</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h1 id="shell脚本编程神器之awk语法案例详解">shell脚本编程神器之awk语法案例详解</h1>

<h3 id="安装awk">安装AWK</h3>

<pre><code># 使用yum安装
yum install gawk

# 安装后检查是否安装ok
which awk
## 一般输出安装路径是在： /bin/awk
</code></pre>

<h3 id="awk-起步示例">AWK 起步示例</h3>

<p>假设存在一个文件 emp.data，其中包含员工的姓名、薪资（美元/小时）以及小时数，一个员工一行数据,其内容如下:</p>

<pre><code>Beth    4.00    0
Dan 3.75    0
kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Susie   4.25    18
</code></pre>

<p>如果想打印出 工作时长超过0小时的员工姓名和工资(薪资乘以时间)，以下命令可以完成:</p>

<pre><code>awk '$3&gt;0 {print $1, $2*$3}'  emp.data
</code></pre>

<p>得到如下输出：</p>

<pre><code>kathy 40
Mark 100
Mary 121
Susie 76.5
</code></pre>

<p>**该命令告诉系统执行括号内的awk程序，从输入文件 emp.data 获取所需要的数据。引号内的部分是个完整的awk程序，包含单个 模式-动作 语句。模式
$3 &gt;0 用于匹配第三列大于0的输入行，动作： **<br />
<code>{print $1, $2*$3}</code><br />
打印每个匹配行的第一个字段、第二个字段与第三个字段的乘积。</p>

<p>还可以打印没有工作过的员工姓名：</p>

<pre><code>awk '$3==0 {print $1}'  emp.data
</code></pre>

<p>将会输出：</p>

<pre><code>Beth
Dan
</code></pre>

<h3 id="awk程序的结构">AWK程序的结构</h3>

<p>回过头来看一下上述命令。 <strong>引号之间的部分是awk编程语言写就的程序</strong> 。 每个awk程序都是 <strong>一个或多个 模式-动作</strong> 语句的序列：</p>

<p><strong>pattern {pattern}</strong><br />
<strong>pattern {pattern}</strong><br />
<strong>…</strong></p>

<p>awk 的基本操作是一行一行的扫描输入，搜索匹配任意程序中模式的行。 词语“匹配”的准确意义是视具体的模式而言，对于模式 $3&gt;0
来说，意思是“条件为真”。<br />
每个模式依次测试每个输入行。对于匹配到行的模式，其对应的动作（也许包含多步）得到执行，然后读取下一行并继续匹配，直到所有的输入读取完毕。</p>

<table>
<thead>
<tr>
<th>模式</th>
<th>动作</th>
</tr>
</thead>

<tbody>
<tr>
<td>$3==0</td>
<td>{print $1}</td>
</tr>
</tbody>
</table>

<p>模式-动作 语句中的 模式或动作（但不是两者同时省略）都可以省略。如果某个模式没有动作，例如：</p>

<p><code>$3==0</code></p>

<p>那么模式匹配到的每一行都会被打出来。输出如下：</p>

<pre><code>Beth    4.00    0
Dan     3.75    0
</code></pre>

<p>如果是没有动作的模式，例如：<br />
<code>{print $1}</code><br />
则会打印第一列，输出如下：</p>

<pre><code>Beth
Dan
kathy
Mark
Mary
Susie
</code></pre>

<p><strong>由于模式和动作两者任一都是可选的，所以需要使用大括号包围动作用以区分其他模式。</strong></p>

<h3 id="执行-awk-程序">执行 awk 程序</h3>

<p>执行awk程序有多种，可以输入如下形式的命令行：<br />
<code>awk 'program codes' inputfiles</code><br />
从而在每个指定的输入文件上执行这个program。例如：<br />
<code>awk '$3==0 {print $1}' file1 file2</code><br />
打印 file1 和 file2 文件中第三列为0的每一行的第一个字段。</p>

<p>也可以省略命令行中的输入文件，仅仅输入：<br />
<code>awk 'program codes'</code><br />
在这种情况下，awk 将会应用于你在终端接着输入的任意数据行，直到你输入一个文件结束信号（Unix系统上为control-d）。示例：</p>

<pre><code>awk '$3&gt;0 {print $1}'
Mary 20 1000   #输入该行回车
Mary  # 计算机输出，匹配到了信息
Belly 30 3000  #继续输入改行
Belly #计算机输出
</code></pre>

<p><strong>注意事项：</strong> 命令行中的程序是用单引号包围着的。这会防止shell解释程序中$这样的字符，也允许程序的长度超过一行。<br />
<strong>当程序比较长的时候，可以将程序写入到一个文件</strong> ，以下命令行：<br />
<code>awk -f programfile optional list of input files</code></p>

<p>其中 -f 选项指示 awk 从指定文件中获取程序。可以使用任意文件名替换 programfile。</p>

<h4 id="awk-的错误提示">awk 的错误提示</h4>

<p>如果你的 awk 程序存在错误， awk 会给你一些诊断信息。例如，如果你打错了大括号，如下所示：</p>

<p><code>awk '$3==0 [print $1}' emp.data</code><br />
会提示如下错误：</p>

<pre><code>awk: $3==0 [print $1}
awk:       ^ syntax error
awk: $3==0 [print $1}
awk:                ^ syntax error
</code></pre>

<h3 id="简单输出">简单输出</h3>

<p>awk中仅仅只有两种类型 <strong>数值</strong> 、 <strong>字符</strong> 构成的字符串。通常情况下，一个字段是一个不包含任何空格或制表符的连续字符序列。<br />
当前输入的 行中的第一个字段被称作 $1，第二个是 $2，以此类推。 整个行的内容被定义为 $0。 每一行的字段数量可以不同。</p>

<p>大都数情况下，我们仅仅只是打印出其中每一行的某些字段，或者也还需要做一些计算。</p>

<h4 id="打印每一行">打印每一行</h4>

<p>如果一个动作没有任何模式，这个动作针对所有输入的行进行操作。 <strong>print</strong> 语句用来打印（输出）当前输入的行。<br />
所以 <code>{print}</code>等效于 <code>{print $0}</code></p>

<h4 id="打印特定行">打印特定行</h4>

<p><code>{print $1,$3}</code>将输出：</p>

<pre><code>Beth 0
Dan 0
kathy 10
Mark 20
Mary 22
Susie 18
</code></pre>

<p><strong>在 print 语句中被逗号分隔的表达式，在默认情况下他们将会用一个空格分割来输出。</strong>
每一行print生成的内容都会以一个换行符作为结束。但这些默认行为都可以自定义。</p>

<h4 id="nf-字段数量">NF，字段数量</h4>

<p>AWK 会对当前输入的行有多少字段进行计数，并且将当前行的字段数量存储在一个内建的称为 NF 的变量中。因此<br />
<code>{print NF,$1,$NF}</code>会打印出 每一行的字段数量、第一个字段的值、最后一个字段的值。<br />
输出：</p>

<pre><code>3 Beth 0
3 Dan 0
3 kathy 10
3 Mark 20
3 Mary 22
3 Susie 18
</code></pre>

<h4 id="打印行号">打印行号</h4>

<p>awk 提供了另一个内建变量， NR。他存储了当前已经读取了多少行的计数。可以使用 NR和$0给emp.data的每一行加上行号：<br />
<code>{print NR,$0}</code><br />
输出如下：</p>

<pre><code>1 Beth  4.00    0
2 Dan   3.75    0
3 kathy 4.00    10
4 Mark  5.00    20
5 Mary  5.50    22
6 Susie 4.25    18
</code></pre>

<h4 id="在输出中添加内容">在输出中添加内容</h4>

<p>还可以在字段中间或者计算的值中间打印输出想要的内容：<br />
<code>{print &quot;total pay for&quot;, $1, &quot;is&quot;, $2*$3}</code><br />
输出如下：</p>

<pre><code>total pay for Beth is 0
total pay for Dan is 0
total pay for kathy is 40
total pay for Mark is 100
total pay for Mary is 121
total pay for Susie is 76.5
</code></pre>

<h3 id="高级输出">高级输出</h3>

<p>print 语句可用于快速而简单的输出。若要严格按照你所想的格式化输出，则需要使用 <strong>printf</strong> 语句。</p>

<h4 id="字段排队">字段排队</h4>

<p>printf 语句格式如下：</p>

<blockquote>
<p>printf(format, value1, value2, …, valueN)</p>
</blockquote>

<p>其中 format 是字符串，包含要逐字打印的文本，穿插在 format 之后的每个值该如何打印的规格。一个规格是一个 %
符，后面跟着一些字符，用来控制一个 value 的格式。因此，有过少个 value 要打印，在 fromat 中就要有多少个 % 规格。<br />
打印每个员工的总薪酬：<br />
<code>{printf(&quot;total pay for %s is $%.2f\n&quot;, $1, $2*$3)}</code><br />
输出如下：</p>

<pre><code>awk '{printf(&quot;total pay for %s is $%.2f\n&quot;, $1, $2*$3)}'  emp.data
total pay for Beth is $0.00
total pay for Dan is $0.00
total pay for kathy is $40.00
total pay for Mark is $100.00
total pay for Mary is $121.00
total pay for Susie is $76.50
</code></pre>

<h4 id="排序输出">排序输出</h4>

<p>以薪酬递增的方式输出每一行：</p>

<p><code>awk '{printf(&quot;%6.2f %s\n&quot;, $2*$3, $0)}' emp.data | sort</code></p>

<p>将awk的输出通过管道传给 **sort **命令，输出如下：</p>

<pre><code>  0.00  Beth    4.00    0
  0.00  Dan     3.75    0
100.00  Mark    5.00    20
121.00  Mary    5.50    22
 40.00  kathy   4.00    10
 76.50  Susie   4.25    18
</code></pre>

<h4 id="选择">选择</h4>

<p>awk
的模式适用于为进一步的处理从输入中选择相关的数据行。由于不带动作的模式会打印所有匹配的行，所以很多awk程序仅仅包含一个模式。本节将给出一些有用的模式示例。</p>

<h5 id="通过对比选择">通过对比选择</h5>

<p>使用一个对比模式来选择每小时赚5美元或更多的员工记录，亦即第二个字段大于等于5的行：<br />
<code>$2&gt;=5</code></p>

<pre><code>awk '$2&gt;=5'  emp.data
Mark    5.00    20
Mary    5.50    22
</code></pre>

<h4 id="通过计算选择">通过计算选择</h4>

<pre><code>awk '$2*$3&gt;50 {printf(&quot;$%.2f for %s\n&quot;, $2*$3, $1)}'  emp.data
$100.00 for Mark
$121.00 for Mary
$76.50 for Susie
</code></pre>

<h4 id="通过文本内容选择">通过文本内容选择</h4>

<p>除了数值测试，还可以选择包含特定单词或短语的输入行。这个程序会打印所有第一个字段为 Susie 的行：</p>

<p><code>$1==&quot;Susie&quot;</code></p>

<p>操作符 == 用于测试相等性。 也可以使用正则表达式的模式查找包含任意任意字母组合，单词或短语的文本。如以下可以匹配到任意位置包含Susie的行：<br />
<code>/Susie/</code></p>

<pre><code>awk '/Susie/'  emp.data
Susie   4.25    18
</code></pre>

<h4 id="模式组合">模式组合</h4>

<p>可以使用括号和逻辑操作符号与&amp;&amp;、或||，以及 非! 对模式进行组合。<br />
<code>$2&gt;=4||$3&gt;=20</code><br />
会打印第二个字段大于等于4或者第三个字段大于等于20的行：</p>

<pre><code>awk '$2&gt;=4||$3&gt;=20'  emp.data
Beth    4.00    0
kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Susie   4.25    18
</code></pre>

<h4 id="begin-与-end">BEGIN 与 END</h4>

<p>特殊模式 BEGIN 用于匹配第一个输入文件的第一行之前的位置。END 则用于匹配处理过的最后一个文件的最后一行的位置。</p>

<p>这个程序使用 BEGIN 来输出一个标题：</p>

<pre><code>BEGIN {print &quot;Name RATE HOURS&quot;; print &quot;&quot;}
    {print}



awk 'BEGIN {print &quot;Name RATE HOURS&quot;; print &quot;&quot;}
{print}' emp.data

## 输出如下：

Name RATE HOURS

Beth    4.00    0
Dan     3.75    0
kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Susie   4.25    18
</code></pre>

<p><strong>注意事项：</strong></p>

<ul>
<li><blockquote>
<p>awk 可以在一行上放多个语句，步过要使用分号;进行分隔。</p>
</blockquote></li>

<li><blockquote>
<p>普通的 print 是打印当前输入行， print “” 则会打印一个空行。</p>
</blockquote></li>
</ul>

<h4 id="awk-工作流图">AWK 工作流图</h4>

<p><a href="https://img.it610.com/image/info8/f33ce972303d40e6bddca304a304ef35.png"><img src="https://img.it610.com/image/info8/f33ce972303d40e6bddca304a304ef35.png" alt="shell脚本编程神器之awk语法案例详解_第1张图片" /></a></p>

<p>AWK 是按一行一行地读取输入的。</p>

<ul>
<li>1.首先执行 <strong>BEGIN</strong> 块</li>
<li>2.从输入中读取一行</li>
<li>3.在这次读取的这一行中执行 AWK 命令</li>
<li>4.如果文件还没有读取完毕，则重复步骤2、3</li>
<li>5.执行 <strong>END</strong> 块中的 awk 命令</li>
</ul>

<h4 id="使用-awk-进行计算">使用 AWK 进行计算</h4>

<p>一个动作就是一个以新行或者分号分隔的语句序列。</p>

<h5 id="计数">计数</h5>

<pre><code>$3 &gt; 15 {emp = emp + 1}
END {print emp, &quot;employees worked more than 15 hours&quot;}



awk '$3 &gt; 15 {emp = emp + 1}
&gt; END {print emp, &quot;employees worked more than 15 hours&quot;}' emp.data

## 输出结果：
3 employees worked more than 15 hours
</code></pre>

<p>用作数字的 awk 变量的默认初始值为0， 所以不需要初始化
emp。创建一个变量emp初始值为0，如果读入的那一行的第三个字段大于15，则emp在自身值的基础上自增1，读完最后一行后输出存在多少个员工工作时长超过15个小时的语句。</p>

<h5 id="求和与平均值">求和与平均值</h5>

<p>为计算员工数目，可以使用内置变量 NR，保存了当前位置读取的行数；在所有输入的结尾它的值就是所读行的总行数。</p>

<p><code>END {print NR, &quot;employees&quot;}</code></p>

<pre><code>awk 'END {print NR, &quot;employees&quot;}'  emp.data

## 输出结果为：
6 employees
</code></pre>

<p>如下是一个使用 NR 来计算薪酬均值的程序：</p>

<pre><code>awk '{pay = pay + $2*$3}
&gt; END {print NR, &quot;employees&quot;
&gt; print &quot;total pay is&quot;, pay
&gt; print &quot;average pay is&quot;, pay/NR
&gt; }' emp.data

## 输出结果为：
6 employees
total pay is 337.5
average pay is 56.25
</code></pre>

<h4 id="处理文本">处理文本</h4>

<p>awk 的优势之一是能像大多数语言处理数字一样方便地处理字符串。 awk 可以保存数字也可以保存字符。找出时薪最高的员工:</p>

<pre><code>$2 &gt; maxrate { maxrate = $2; maxemp = $1 }
END { print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp }



 awk '$2 &gt; maxrate { maxrate = $2; maxemp = $1 }
&gt; END { print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp }' emp.data

## 输出结果为：
highest hourly rate: 5.50 for Mary



awk '{names = names $1 &quot; &quot;}                    
END {print names}' emp.data

## 输出结果：
Beth Dan kathy Mark Mary Susie 
</code></pre>

<h4 id="打印最后一个输入行">打印最后一个输入行</h4>

<p>虽然在 END 动作中 NR 还保留着它的值， 但 $0 没有。</p>

<pre><code>{last = $0}
END {print last}



awk '
&gt; {last = $0}
&gt; END {print last}' emp.data

## 输出结果：
Susie   4.25    18
</code></pre>

<h3 id="awk-内置函数">AWK 内置函数</h3>

<p>前面已经看到 awk 内置变量用来保存某些频繁使用的数量， NF 表示所在行的总列数， NR 表示当前是第多少行…<br />
还有内置函数用来计算其他有用的数值。除了 平方根、对数、随机数此类的算术函数外，还有操作文本的函数。其中之一是 length 用于计算一个字符串的长度。</p>

<pre><code>awk '{print $1, length($1)}'  emp.data

## 输出结果：
Beth 4
Dan 3
kathy 5
Mark 4
Mary 4
Susie 5
</code></pre>

<h4 id="行-单词以及字符的计数">行、单词以及字符的计数</h4>

<p>使用 length、NF、NR来统计输入中行、单词以及字符的数量。为了简便，将每个字段看作一个单词。</p>

<pre><code>awk ' { nc = nc + length($0) + 1
&gt;       nw = nw + NF
&gt;     }
&gt; END { print NR, &quot;lines,&quot;, nw, &quot;words,&quot;, nc, &quot;characters&quot; }' emp.data

## 输出结果为：
6 lines, 18 words, 82 characters
</code></pre>

<p>因为 $0 不会包含行末的换行符，所以另外加了个1。</p>

<h4 id="awk-控制语句">AWK 控制语句</h4>

<p>awk 为选择提供了一个 if-else 语句， 以及为循环提供了几个语句，它们仅在动作中使用。</p>

<h5 id="if-else-语句">if-else 语句</h5>

<p>如下是一个计算时薪超过6美元的员工总薪酬与平均薪酬。它使用一个 if 来防范零除问题。</p>

<pre><code>$2 &gt; 6 { n = n+1; pay = pay + $2*$3 }
END {
    if(n &gt; 0)
        print n, &quot;employees, total pay is&quot;, pay,
               &quot;average pay is&quot;, pay/n
    else
        print &quot;no employees are paid more than $6/hour&quot;

}




awk '$2 &gt; 6 { n = n+1; pay = pay + $2*$3 }
&gt; END {
&gt;     if(n &gt; 0)
&gt;         print n, &quot;employees, total pay is&quot;, pay,
&gt;                &quot;average pay is&quot;, pay/n
&gt;     else
&gt;         print &quot;no employees are paid more than $6/hour&quot;
&gt;         
&gt; }' emp.data

## 输出结果为：
no employees are paid more than $6/hour
</code></pre>

<p><strong>注意事项：</strong> 我们可以使用一个逗号将一个长语句截断为多行来书写.</p>

<h5 id="while-语句">while 语句</h5>

<pre><code>{
    i = 1
    while ( i &lt;=3 ){
        # while 循环体(这一行是注释内容)
        printf(&quot;\t%.2f\n&quot;, $1*(1+$2)^i)
        i = i + 1
    }
}
</code></pre>

<p>while 后面是圆括号，里面是布尔表达式。 循环体是条件后大括号包围的语句。 ^ 是指数操作符。 # 后面是注释。</p>

<p>演示1000美元，利率为6%与12%，5年的复利分别是如何增长的：</p>

<pre><code>awk '
&gt; {
&gt;     i = 1
&gt;     while ( i &lt;=5 ){
&gt;         # while 循环体(这一行是注释内容)
&gt;         printf(&quot;\t%.2f\n&quot;, $1*(1+$2)^i)
&gt;         i = i + 1
&gt;     }
&gt; }
&gt; ' 
1000 .06 5
        1060.00
        1123.60
        1191.02
        1262.48
        1338.23
1000 .12 5
        1120.00
        1254.40
        1404.93
        1573.52
        1762.34
</code></pre>

<h5 id="for-语句">for 语句</h5>

<p>使用for循环实现上述例子：</p>

<pre><code>awk '
&gt; {
&gt;     for( i = 1; i &lt;= $3; i = i+1 ){
&gt;         printf(&quot;\t%.2f\n&quot;, $1*(1+$2)^i)
&gt;     }
&gt; }
&gt; '
1000 .06 5
        1060.00
        1123.60
        1191.02
        1262.48
        1338.23
1000 .12 5
        1120.00
        1254.40
        1404.93
        1573.52
        1762.34
</code></pre>

<h4 id="数组">数组</h4>

<p>awk 为存储一组相关的值提供了数组，虽然数组给予了awk很强的能力，但是在这里我们仅仅展示一个简单的例子。<br />
第一个动作将输入行存为数组 line 的连续元素；<br />
<strong>第一行放在line[1]，第二行放在line[2]</strong> 。 END 动作使用一个while语句从后往前打印数组中的输入行：</p>

<pre><code># 反转-按行逆序打印输入

{line[NR] = $0}

END {
        i = NR
        while(i &gt; 0){
            print line[i]
            i = i-1
        }
}




awk '
&gt; {line[NR] = $0}
&gt; 
&gt; END {
&gt;         i = NR
&gt;         while(i &gt; 0){
&gt;             print line[i]
&gt;             i = i-1
&gt;         }
&gt; }' emp.data

# 输出结果为：
Susie   4.25    18
Mary    5.50    22
Mark    5.00    20
kathy   4.00    10
Dan     3.75    0
Beth    4.00    0
</code></pre>

<h4 id="dump-variables-操作查看全局变量">–dump-variables 操作查看全局变量</h4>

<p>-dump-variables[=file] 操作可以打印全局变量到文件中，默认是“awkvars.out”文件。</p>

<pre><code>awk --dump-variables ''

# 查看文件awkvars.out 
cat awkvars.out 

ARGC: number (1)
ARGIND: number (0)
ARGV: array, 1 elements
BINMODE: number (0)
CONVFMT: string (&quot;%.6g&quot;)
ERRNO: number (0)
FIELDWIDTHS: string (&quot;&quot;)
FILENAME: string (&quot;&quot;)
FNR: number (0)
FS: string (&quot; &quot;)
IGNORECASE: number (0)
LINT: number (0)
NF: number (0)
NR: number (0)
OFMT: string (&quot;%.6g&quot;)
OFS: string (&quot; &quot;)
ORS: string (&quot;\n&quot;)
RLENGTH: number (0)
RS: string (&quot;\n&quot;)
RSTART: number (0)
RT: string (&quot;&quot;)
SUBSEP: string (&quot;\034&quot;)
TEXTDOMAIN: string (&quot;messages&quot;)
</code></pre>

<h4 id="help-操作可以寻得帮助">–help 操作可以寻得帮助</h4>

<pre><code>awk --help
# 输出信息如下：

Usage: awk [POSIX or GNU style options] -f progfile [--] file ...
Usage: awk [POSIX or GNU style options] [--] 'program' file ...
POSIX options:          GNU long options:
        -f progfile             --file=progfile
        -F fs                   --field-separator=fs
        -v var=val              --assign=var=val
        -m[fr] val
        -O                      --optimize
        -W compat               --compat
        -W copyleft             --copyleft
        -W copyright            --copyright
        -W dump-variables[=file]        --dump-variables[=file]
        -W exec=file            --exec=file
        -W gen-po               --gen-po
        -W help                 --help
        -W lint[=fatal]         --lint[=fatal]
        -W lint-old             --lint-old
        -W non-decimal-data     --non-decimal-data
        -W profile[=file]       --profile[=file]
        -W posix                --posix
        -W re-interval          --re-interval
        -W source=program-text  --source=program-text
        -W traditional          --traditional
        -W usage                --usage
        -W use-lc-numeric       --use-lc-numeric
        -W version              --version

To report bugs, see node `Bugs' in `gawk.info', which is
section `Reporting Problems and Bugs' in the printed version.

gawk is a pattern scanning and processing language.
By default it reads standard input and writes standard output.

Examples:
        gawk '{ sum += $1 }; END { print sum }' file
        gawk -F: '{ print $1 }' /etc/passwd
</code></pre>

<h4 id="version-查看版本信息">–version 查看版本信息</h4>

<pre><code>awk --version
# 输出结果如下:

GNU Awk 3.1.7
Copyright (C) 1989, 1991-2009 Free Software Foundation.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see http://www.gnu.org/licenses/.
</code></pre>

<h4 id="v-操作">-v 操作</h4>

<p><strong>-v</strong> 操作允许给一个变量分配值。允许在程序执行之前分配。</p>

<pre><code>awk -v name=LFF 'BEGIN {printf(&quot;username=%s\n&quot;, name)}'

# 输出结果为：
username=LFF
</code></pre>

<h4 id="lint-操作提示信息">–lint 操作提示信息</h4>

<p><strong>–lint</strong> 操作允许输出检查信息，比如当参数提供错误，会将警告信息当作错误。</p>

<pre><code>awk --lint '' /bin/ls

# 输出结果为：
awk: warning: empty program text on command line
awk: warning: source file does not end in newline
awk: warning: no program text at all!
</code></pre>

<h4 id="正则匹配">正则匹配</h4>

<p>匹配输入行中包含字符a的行，全部输出。</p>

<pre><code>awk '/a/ {print $0}'  emp.data

# 输出结果为：
Dan     3.75    0
kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
</code></pre>

<p>打印输入行中包含字符a的行数：</p>

<pre><code>awk '/a/ {++cnt} END {print &quot;匹配的行数为:&quot;, cnt}' emp.data

# 输出结果为:
匹配的行数为: 4
</code></pre>

<h4 id="内置变量">内置变量</h4>

<h5 id="argc-命令行中提供的参数个数">ARGC ：命令行中提供的参数个数</h5>

<p><code>shell awk 'BEGIN {print &quot;Arguments =&quot;, ARGC}' One Two Three Four Arguments =
5</code></p>

<h5 id="argv-表示命令行入参构成的数组-索引是-0-argc-1">ARGV 表示命令行入参构成的数组，索引是 0~ARGC-1</h5>

<pre><code> awk 'BEGIN { 
&gt;    for (i = 0; i &lt; ARGC - 1; ++i) { 
&gt;       printf &quot;ARGV[%d] = %s\n&quot;, i, ARGV[i] 
&gt;    } 
&gt; }' one two three four

# 输出结果为：
ARGV[0] = awk
ARGV[1] = one
ARGV[2] = two
ARGV[3] = three
</code></pre>

<h5 id="convfmt">CONVFMT</h5>

<p>表示数字的转换格式。默认值是 <strong>%.6g</strong> 。</p>

<pre><code>awk 'BEGIN { print &quot;Conversion Format =&quot;, CONVFMT }'

#输出：
Conversion Format = %.6g
</code></pre>

<h5 id="environ-环境变量">ENVIRON 环境变量</h5>

<pre><code>awk 'BEGIN { print ENVIRON[&quot;USER&quot;] }'

# 输出当前用户
deploy
</code></pre>

<p>我们可以借助env命令查看linux服务器上的全部环境变量：</p>

<pre><code>env

# 查看当前服务器上的所有环境变量
HOSTNAME=sz-local3
TERM=vt100
SHELL=/bin/bash
HISTSIZE=1000
SSH_CLIENT=10.89.4.224 53217 22
QTDIR=/usr/lib64/qt-3.3
OLDPWD=/data/app
QTINC=/usr/lib64/qt-3.3/include
SSH_TTY=/dev/pts/0
GREP_OPTTIONS=--color=always
USER=deploy
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.tbz=01;31:*.tbz2=01;31:*.bz=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:
MAIL=/var/spool/mail/deploy
PATH=/usr/lib/jdk1.7.0_76/bin:/usr/lib64/qt-3.3/bin:/data/app/node-v4.2.4-linux-x64/bin:/usr/lib/jdk1.7.0_76/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/deploy/bin
PWD=/data/app/lff
JAVA_HOME=/usr/lib/jdk1.7.0_76
LANG=en_US.UTF-8
HISTCONTROL=ignoredups
SHLVL=1
HOME=/home/deploy
LOGNAME=deploy
QTLIB=/usr/lib64/qt-3.3/lib
CVS_RSH=ssh
CLASSPATH=/usr/lib/jdk1.7.0_76/lib:/usr/lib/jdk1.7.0_76/lib:
SSH_CONNECTION=10.89.4.224 53217 10.193.1.27 22
LESSOPEN=||/usr/bin/lesspipe.sh %s
G_BROKEN_FILENAMES=1
_=/bin/env
</code></pre>

<h5 id="filename-表示当前文件">FILENAME 表示当前文件</h5>

<pre><code>awk 'END {print FILENAME}' emp.data

# 输出结果为：
emp.data
</code></pre>

<h5 id="fs-表示文件分隔符">FS 表示文件分隔符</h5>

<p>FS 表示文件分割符，默认是空白字符。也可以使用 <strong>-F</strong> 命令行变更。</p>

<pre><code>awk 'BEGIN {print &quot;FS = &quot; FS}' | cat -vte

# 输出结果为：
FS =  $
</code></pre>

<h5 id="nf-表示当前行的字段-列数">NF 表示当前行的字段（列数）</h5>

<h5 id="nr-表示当前读到的行数">NR 表示当前读到的行数</h5>

<h5 id="rlength">RLENGTH</h5>

<p>表示匹配函数 <strong>match</strong> 到的字符串的长度。</p>

<pre><code>awk '
BEGIN {
       if(match(&quot;One Two Three&quot;, &quot;re&quot;)){
          print RLENGTH
       }
}'

# 匹配到了Three中的re，输出结果为：
2
</code></pre>

<h5 id="rstart-表示第一个-match-函数匹配到的字符串中的位置">RSTART 表示第一个 <strong>match</strong> 函数匹配到的字符串中的位置</h5>

<pre><code>awk '
BEGIN {
       if(match(&quot;One Two Three There&quot;, &quot;re&quot;)){
          print RSTART 
       }
}'

# 从O开始，到Three的r，位置处于11，输出结果为：
11
</code></pre>

<h5 id="0-表示全部的输入记录">$0 表示全部的输入记录</h5>

<h5 id="n-表示第n列-第n个字段-以文件分隔符分隔-默认是空白字符">$n 表示第n列(第n个字段)，以文件分隔符分隔，默认是空白字符。</h5>

<h5 id="argind-表示当前处理的-argv-的索引值">ARGIND 表示当前处理的 ARGV 的索引值</h5>

<h5 id="procinfo-表示进程相关信息">PROCINFO 表示进程相关信息</h5>

<pre><code>awk 'BEGIN {print PROCINFO[&quot;pid&quot;]}'
5142
</code></pre>

<h4 id="运算符操作">运算符操作</h4>

<h5 id="自增符操作">自增符操作</h5>

<pre><code>awk 'BEGIN {print ++a}'
# 先自增，输出结果为：
1
# 后自增，输出结果为：
awk 'BEGIN {print a++}'
0
</code></pre>

<h5 id="自减符操作">自减符操作</h5>

<pre><code>awk 'BEGIN {print --a}'
-1
awk 'BEGIN {print a--}'
0
</code></pre>

<h5 id="操作">+=、 -=、 *=、/=、%=、 ^=、**=操作</h5>

<pre><code>awk 'BEGIN {print cnt+=10; print cnt}'
10
10

awk 'BEGIN {cnt=10 ;print cnt*=10; print cnt}'
100
100

awk 'BEGIN {cnt=10 ;print cnt-=10; print cnt}'
0
0
awk 'BEGIN {cnt=10 ;print cnt/=10; print cnt}'
1
1
awk 'BEGIN {cnt=10 ;print cnt%=10; print cnt}'
0
0
awk 'BEGIN {cnt=10 ;print cnt^=10; print cnt}'
10000000000
10000000000
awk 'BEGIN {cnt=10 ;print cnt**=10; print cnt}'
10000000000
10000000000
</code></pre>

<h5 id="关系运算符">关系运算符</h5>

<ul>
<li>==</li>
<li>!=</li>
<li>&lt;</li>
<li>&lt;=</li>
<li>&gt;</li>
<li>&gt;=</li>
</ul>

<h5 id="逻辑运算符">逻辑运算符</h5>

<ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>!</li>
</ul>

<h5 id="三目运算符">三目运算符</h5>

<ul>
<li>? :</li>
</ul>

<h5 id="字符串连接符">字符串连接符</h5>

<p>空白字符是字符串连接符</p>

<pre><code>awk 'BEGIN {a=&quot;hello, &quot;; b=&quot;world!&quot;; c= a b; print(c)}'

# 输出连接结果
hello, world!
</code></pre>

<h5 id="数组关系操作符">数组关系操作符</h5>

<p><strong>for in</strong> 操作常用于遍历数组。</p>

<pre><code>awk '
&gt; BEGIN { arr[1] = &quot;a&quot;; arr[2] = &quot;b&quot;; arr[3] = &quot;c&quot;;  
&gt; for(i in arr){
&gt;     print(&quot;a[&quot;, i, &quot;]=&quot;, arr[i])
&gt; }
&gt; }'

# 遍历输出数组元素：
a[ 1 ]= a
a[ 2 ]= b
a[ 3 ]= c
</code></pre>

<h5 id="正则表达式操作符">正则表达式操作符</h5>

<ul>
<li>点符 <strong>.</strong> ： 匹配任意单个字符</li>
</ul>

<p>示例：</p>

<pre><code>echo -e &quot;cat\nbat\nfun\nfin\nfan&quot; | awk '/f.n/'

fun
fin
fan
</code></pre>

<ul>
<li><strong>^</strong> 符：匹配开头</li>
</ul>

<p>匹配 <strong>The</strong> 开头的字符串：</p>

<pre><code>echo -e &quot;This\nThat\nThere\nTheir\nthese&quot; | awk '/^The/'

There
Their
</code></pre>

<ul>
<li><strong>$</strong> 符：匹配结尾</li>
</ul>

<p>匹配 <strong>n</strong> 结尾的字符串：</p>

<pre><code>echo -e &quot;knife\nknow\nfun\nfin\nfan\nnine&quot; | awk '/n$/'

fun
fin
fan
</code></pre>

<ul>
<li><strong>[]</strong> 符 ：匹配字符集多选一</li>
</ul>

<p>匹配 Call 或者 Tall：</p>

<pre><code>echo -e &quot;Call\nTall\nBall&quot; | awk '/[CT]all/'

Call
Tall
</code></pre>

<ul>
<li>排除匹配</li>
</ul>

<p>使用^排除，匹配不是 Call且不是Tall的字符串：</p>

<pre><code>echo -e &quot;Call\nTall\nBall&quot; | awk '/[^CT]all/'

Ball
</code></pre>

<ul>
<li>可选匹配</li>
</ul>

<p>匹配 Call 或者 Tall</p>

<pre><code>echo -e &quot;Call\nTall\nBall\nSmall\nShall&quot; | awk '/Call|Ball/'

Call
Ball
</code></pre>

<ul>
<li><p><strong>？</strong> 符号 ：0 或 1次匹配</p>

<p>echo -e &ldquo;Colour\nColor&rdquo; | awk &lsquo;/Colou?r/&rsquo;</p>

<p>Colour
Color</p></li>

<li><ul>
<li>符号： 表示0或多个匹配

<br />
<br /></li>
</ul>

<p>echo -e &ldquo;ca\ncat\ncatt&rdquo; | awk &lsquo;/cat*/&rsquo;</p>

<p>ca
cat
catt</p></li>

<li><p><strong>()</strong> 分组匹配</p>

<p>echo -e &ldquo;Apple Juice\nApple Pie\nApple Tart\nApple Cake&rdquo; | awk
   &lsquo;/Apple (Juice|Cake)/&rsquo;</p>

<p>Apple Juice
Apple Cake</p></li>
</ul>

<h4 id="数组-1">数组</h4>

<pre><code>awk 'BEGIN {
   fruits[&quot;mango&quot;] = &quot;yellow&quot;;
   fruits[&quot;orange&quot;] = &quot;orange&quot;
   print fruits[&quot;orange&quot;] &quot;\n&quot; fruits[&quot;mango&quot;]
}'

orange
yellow
</code></pre>

<h5 id="delete-删除数组元素"><strong>delete</strong> 删除数组元素</h5>

<pre><code>awk 'BEGIN {
   fruits[&quot;mango&quot;] = &quot;yellow&quot;;
   fruits[&quot;orange&quot;] = &quot;orange&quot;;
   delete fruits[&quot;orange&quot;];
   for(i in fruits){print fruits[i]}
}'

# 删除orange后，只剩下yello
yellow
</code></pre>

<h5 id="多维数组">多维数组</h5>

<pre><code>100   200   300
400   500   600
700   800   900
</code></pre>

<p>array[0][0] 存储 100，array[0][1] 存储 200。<br />
<strong>正确的语法是 array[“0,0”] = 100</strong></p>

<pre><code>awk 'BEGIN {
   array[&quot;0,0&quot;] = 100;
   array[&quot;0,1&quot;] = 200;
   array[&quot;0,2&quot;] = 300;
   array[&quot;1,0&quot;] = 400;
   array[&quot;1,1&quot;] = 500;
   array[&quot;1,2&quot;] = 600;

   # print array elements
   print &quot;array[0,0] = &quot; array[&quot;0,0&quot;];
   print &quot;array[0,1] = &quot; array[&quot;0,1&quot;];
   print &quot;array[0,2] = &quot; array[&quot;0,2&quot;];
   print &quot;array[1,0] = &quot; array[&quot;1,0&quot;];
   print &quot;array[1,1] = &quot; array[&quot;1,1&quot;];
   print &quot;array[1,2] = &quot; array[&quot;1,2&quot;];
}'
</code></pre>

<h4 id="字符串函数">字符串函数</h4>

<h5 id="index-str-substr">index(str, substr)</h5>

<p>子串 substr 出现在字符串 str 中的开始位置，从1开始计数。</p>

<pre><code>awk 'BEGIN {print index(&quot;Hello&quot;, &quot;ll&quot;)}'
3
</code></pre>

<h5 id="gsub-regex-sub-string">gsub(regex, sub, string)</h5>

<p>正则匹配 regex，将其替换为 sub指定的内容， string是所选的字符串。</p>

<pre><code>awk 'BEGIN { str = &quot;Hello,World！&quot;; gsub(&quot;World&quot;, &quot;Lily&quot;, str); print str}'
Hello,Lily！
</code></pre>

<h5 id="match-str-regex">match(str, regex)</h5>

<p>匹配则返回regex在str中的起始位置，否则返回0表示没有匹配到。</p>

<pre><code>awk 'BEGIN {str = &quot;Hello,world!&quot;; ret = match(str, &quot;wo&quot;); print str, ret}'
Hello,world! 7
</code></pre>

<h5 id="split-str-arr-regex">split(str, arr, regex)</h5>

<p>将 str 按 regex 匹配拆分，得到的每个拆分作为元素保存在 arr 数组中。</p>

<pre><code>awk 'BEGIN {str = &quot;Hello,Hellokitty&quot;; split(str, arr, &quot;,&quot;);  
for(ele in arr){
    print arr[ele]
}}'

Hello
Hellokitty
</code></pre>

<h5 id="strtonum-str">strtonum(str)</h5>

<p>将字符串强转成数值类型， str开头是0的话会转为八进制， 是0x或0X开头的话会转为十六进制。</p>

<pre><code> awk 'BEGIN {
&gt;    print &quot;Decimal num = &quot; strtonum(&quot;123&quot;)
&gt;    print &quot;Octal num = &quot; strtonum(&quot;0123&quot;)
&gt;    print &quot;Hexadecimal num = &quot; strtonum(&quot;0x123&quot;)
&gt; }'
Decimal num = 123
Octal num = 83
Hexadecimal num = 291
</code></pre>

<h5 id="substr-str-start-l">substr(str, start, l)</h5>

<p>获取字串，从字符串 str 中的 start位置开始截取长度为 <em><strong>L</strong></em> 的字符串。</p>

<pre><code>awk 'BEGIN {str = &quot;nihaoya!&quot;; print substr(str, 1, 2)}'
ni
</code></pre>

<h5 id="tolower-str">tolower(str)</h5>

<p>将字符串 str 小写化。</p>

<pre><code>awk 'BEGIN{ print tolower(&quot;HeLLo&quot;)}'
hello
</code></pre>

<h5 id="toupper-str">toupper(str)</h5>

<p>将字符串 str 大写化。</p>

<pre><code>awk 'BEGIN{ print toupper(&quot;HeLLo&quot;)}'
HELLO
</code></pre>

<h4 id="时间函数">时间函数</h4>

<h5 id="systime">systime()</h5>

<p>获取自 1970-01-01 00:00:00 至今的unix时间戳</p>

<pre><code>awk 'BEGIN {print systime()}'
1545742584
</code></pre>

<h5 id="mktime-datespec">mktime(datespec)</h5>

<p>将指定的日期格式串转换为时间戳，datespec 格式是 YYYY mm dd HH MM SS</p>

<pre><code>awk 'BEGIN {print mktime(&quot;2018 12 25 21 07 00&quot;)}'
1545743220
</code></pre>

<h5 id="strftime-format-timestamp">strftime(format, timestamp)</h5>

<p>将时间戳 timestamp 转换成指定格式format的字符串</p>

<pre><code> awk 'BEGIN {
&gt;    print strftime(&quot;Time = %m/%d/%Y %H:%M:%S&quot;, systime())
&gt; }'
Time = 12/25/2018 21:11:09
</code></pre>

<h4 id="位操作函数">位操作函数</h4>

<h5 id="and">and</h5>

<p>按位与</p>

<pre><code>awk 'BEGIN {
   num1 = 10
   num2 = 6
   printf &quot;(%d AND %d) = %d\n&quot;, num1, num2, and(num1, num2)
}'

# 输出结果为：
(10 AND 6) = 2
</code></pre>

<h5 id="lshift-num-size">lshift(num, size)</h5>

<p>将num按位左移size位数, 左移一位相当于乘以2</p>

<pre><code>awk 'BEGIN {print lshift(10, 1)}'
20
</code></pre>

<h5 id="rshift-num-size">rshift(num, size)</h5>

<p>将num按位右移size位数, 右移一位相当于除以2</p>

<pre><code>awk 'BEGIN {print rshift(10, 1)}'
5
</code></pre>

<h5 id="or-按位或">or 按位或</h5>

<pre><code>awk 'BEGIN {
   num1 = 10
   num2 = 6
   printf &quot;(%d OR %d) = %d\n&quot;, num1, num2, or(num1, num2)
}'

# 输出结果为：
(10 OR 6) = 14
</code></pre>

<h5 id="xor-异或">xor 异或</h5>

<pre><code>awk 'BEGIN {
   num1 = 10
   num2 = 6
   printf &quot;(%d XOR %d) = %d\n&quot;, num1, num2, xor(num1, num2)
}'

# 输出结果为：
(10 XOR 6) = 12
</code></pre>

<h3 id="自定义函数">自定义函数</h3>

<p>语法形式:</p>

<pre><code>function function_name(argument1, argument2, ...) { 
   function body
}
</code></pre>

<p>示例：</p>

<pre><code># Returns minimum number
function find_min(num1, num2){
   if (num1 &lt; num2)
   return num1
   return num2
}
# Returns maximum number
function find_max(num1, num2){
   if (num1 &gt; num2)
   return num1
   return num2
}
# Main function
function main(num1, num2){
   # Find minimum number
   result = find_min(10, 20)
   print &quot;Minimum =&quot;, result

   # Find maximum number
   result = find_max(10, 20)
   print &quot;Maximum =&quot;, result
}
# Script execution starts here
BEGIN {
   main(10, 20)
}
</code></pre>

<h4 id="输出转移操作">输出转移操作</h4>

<h5 id="重定向数据到文件">重定向数据到文件</h5>

<p>我们还可以将数据导入到文件中。在 <strong>print</strong> 或者 <strong>printf</strong> 后增加重定向的文件语句。<br />
语法：</p>

<blockquote>
<p>print data &gt; outputfile</p>
</blockquote>

<p>将数据 data 写入到 outputfile，如果 outputfile 不存在则创建。当指定重定向时，文件 output
会清除所有内容，然后写入数据。顺序写操作则不会提前清除文件内容，只是追加。</p>

<pre><code># 将 &quot;Old data&quot; 写入 message.txt 文件中，没有则创建 message.txt 文件。
echo &quot;Old data&quot; &gt; message.txt
# 查看文件内容
cat message.txt 
# 输出结果：
Old data
</code></pre>

<p>然后执行：</p>

<pre><code>awk 'BEGIN {print &quot;Hello,World!&quot; &gt; &quot;message.txt&quot;}'
cat message.txt 
# 文件的旧内容清楚了，内容已经被替换
Hello,World!
</code></pre>

<h5 id="追加内容到文件中">追加内容到文件中</h5>

<blockquote>
<p>print DATA &gt;&gt; output-file</p>
</blockquote>

<pre><code>echo &quot;Old data&quot; &gt; /tmp/message.txt
cat /tmp/message.txt
# 查看文件内容
Old data

# 追加内容到文件中
awk 'BEGIN { print &quot;Hello, World !!!&quot; &gt;&gt; &quot;/tmp/message.txt&quot; }'
cat /tmp/message.txt

#  输出内容：
Old data
Hello, World !!!
</code></pre>

<h5 id="管道-pipe">管道 pipe</h5>

<p>可能需要发送输出数据到其它程序，通过管道而不是文件。<br />
这种转移方式会打开一个管道命令，并且会通过管道将数据项通过管道传到另一个进程去执行命令。<br />
转移参数是一个 awk 表达式。</p>

<p>管道的语法如下：</p>

<blockquote>
<p>print items | command</p>
</blockquote>

<p>示例：使用 <strong>tr</strong> 命令将小写转换为大写</p>

<pre><code>awk 'BEGIN { print &quot;hello, world !!!&quot; | &quot;tr [a-z] [A-Z]&quot; }'
HELLO, WORLD !!!
</code></pre>

<p>更过关于 <strong>tr</strong> 的使用方法，可以使用 tr &ndash;help 查看帮助信息。</p>

<h5 id="双向通信">双向通信</h5>

<p>awk 可以通过 <strong>| &amp;</strong> 跟外部进程通信。</p>

<pre><code>awk 'BEGIN {
&gt;    cmd = &quot;tr [a-z] [A-Z]&quot;
&gt;    print &quot;hello, world !!!&quot; |&amp; cmd
&gt;    close(cmd, &quot;to&quot;)
&gt;    
&gt;    cmd |&amp; getline out
&gt;    print out;
&gt;    close(cmd);
&gt; }'
HELLO, WORLD !!!
</code></pre>

<p>说明：</p>

<ul>
<li>第一条语句， <strong>cmd=“tr [a-z] [A-Z]”</strong> ，是我们建立双向通信的命令。</li>
<li>接下来的语句，print 命令提供输入到 <strong>tr</strong> 命令。 这里的 <strong>| &amp;</strong> 表示双向通信。</li>
<li>第三条语句， <strong>close(cmd,“to”)</strong> ，在完成执行后，关闭 <strong>to</strong> 进程。</li>
<li><strong>cmd | &amp; getline out</strong> 借助getline函数将结果输出 到 out 变量中。</li>
<li>最后打印out，并使用 <strong>close</strong> 函数关闭命令。</li>
</ul>

<h4 id="整齐打印">整齐打印</h4>

<pre><code>awk 'BEGIN { printf &quot;Hello\nWorld\n&quot; }'

# 输出结果为：
Hello
World
</code></pre>

<h5 id="水平tab间隔打印">水平tab间隔打印</h5>

<pre><code>awk 'BEGIN { printf &quot;Sr No\tName\tSub\tMarks\n&quot; }'

Sr No   Name    Sub Marks
</code></pre>

<h5 id="垂直tab打印">垂直tab打印</h5>

<pre><code>awk 'BEGIN { printf &quot;Sr No\vName\vSub\vMarks\n&quot; }'

# 输出结果为：
Sr No
     Name
         Sub
            Marks
</code></pre>

<h5 id="回车打印">回车打印</h5>

<pre><code>awk 'BEGIN { printf &quot;Field 1\rField 2\rField 3\rField 4\n&quot; }'

输出：
Field 4
</code></pre>

<h5 id="换页打印">换页打印</h5>

<pre><code>awk 'BEGIN { printf &quot;Sr No\fName\fSub\fMarks\n&quot; }'
Sr No
     Name
         Sub
            Marks
</code></pre>

<h5 id="格式说明符">格式说明符</h5>

<ul>
<li><p>%c ： 表示一个单个字符</p>

<p>awk &lsquo;BEGIN { printf &ldquo;ASCII value 65 = character %c\n&rdquo;, 65 }&rsquo;
ASCII value 65 = character A</p></li>

<li><p>%d and %i : 表示十进制的整数</p>

<p>awk &lsquo;BEGIN { printf &ldquo;Percentags = %d\n&rdquo;, 80.66 }&rsquo;</p>

<p>输出结果为：
Percentags = 80</p></li>

<li><p>%e and %E ： 科学记数法</p>

<p>awk &lsquo;BEGIN { printf &ldquo;Percentags = %E\n&rdquo;, 80.66 }&rsquo;</p>

<p>输出结果为：
Percentags = 8.066000e+01</p></li>

<li><p>%f : 浮点数</p>

<p>awk &lsquo;BEGIN { printf &ldquo;Percentags = %f\n&rdquo;, 80.66 }&rsquo;</p>

<p>输出结果为：
Percentags = 80.660000</p></li>

<li><p>%s ： 表示字符串</p>

<p>awk &lsquo;BEGIN { printf &ldquo;Name = %s\n&rdquo;, &ldquo;Sherlock Holmes&rdquo; }&rsquo;</p>

<p>输出结果为：</p>

<p>Name = Sherlock Holmes</p></li>

<li><p>%nd : 指定宽度打印</p>

<p>awk &lsquo;BEGIN {
   num1 = 10; num2 = 20; printf &ldquo;Num1 = %10d\nNum2 = %10d\n&rdquo;, num1, num2
}&rsquo;</p>

<h1 id="输出结果为">输出结果为：</h1>

<p>Num1 =         10
Num2 =         20</p></li>
</ul>

<h3 id="awk-概览">AWK 概览</h3>

<p>AWK 是一种解释性编程语言。是专门为处理文本而设计的。名字是来自于设计者的名字 —— Alfred Aho, Peter Weinberger, and
Brian Kernighan.</p>

<h4 id="awk-的类型">AWK 的类型</h4>

<ul>
<li>AWK ： AT&amp;T 实验室</li>
<li>NAWK ：AWK 的新的改进版本</li>
<li>GAWK ： GNU AWK。 所有GNU/Linux发行版都是GAWK。它与AWK和NAWK完全兼容。</li>
</ul>

<h4 id="awk-的典型应用场景">AWK 的典型应用场景</h4>

<ul>
<li>文本处理</li>
<li>生成格式化的文本报告</li>
<li>处理算术操作</li>
<li>处理字符串操作</li>
</ul>

<h4 id="awk-环境">AWK 环境</h4>

<p>描述如何在 GNU/Linux 系统中安装 AWK 环境。</p>

<h5 id="安装包管理器">安装包管理器</h5>

<p>一般情况下， AWK 默认在大都数 GNU/Linux 系统中都是安装发行的。<br />
你可以使用 <strong>which</strong> 命令，检查awk在系统中是否安装好了。<br />
如果没有安装 awk， 可以按如下命令借助 高级安装包 APT安装 AWK：</p>

<pre><code>sudo apt-get update
sudo apt-get install gawk



yum install gawk

# 查看
which awk

# 输出结果为：
/bin/awk
</code></pre>

<p>从源代码中安装：</p>

<ul>
<li>wget <a href="http://ftp.gnu.org/gnu/gawk/gawk-4.1.1.tar.xz">http://ftp.gnu.org/gnu/gawk/gawk-4.1.1.tar.xz</a></li>
<li>tar xvf gawk-4.1.1.tar.xz</li>
<li>./configure</li>
<li>make</li>
<li>make check</li>
<li>sudo make install</li>
<li>which awk</li>
</ul>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>