<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell编程人入门到入坑 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell编程人入门到入坑 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell编程人入门到入坑">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E4%BA%BA%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%91/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell编程人入门到入坑</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="shell-基础">Shell 基础。</h2>

<hr />

<h3 id="文章目录">文章目录</h3>

<pre><code>* Shell 基础。
  * Shell 概述。
  * Shell 的分类。
  * Shell 脚本的执行方式。
      * 第一个脚本。
  * Bash 的基本功能。
      * 历史命令与补全。
        * 历史命令的调用。
        * 命令与文件补全。
      * 命令别名与常用快捷键。
      * 命令的执行顺序。
      * 删除别名。
  * bash 常用快捷键。
  * 输入输出重定向。
      * 输出重定向。
      * 输入重定向。
  * 多命令顺序执行与管道。
      * 管道符～`|`。
      * 通配符与其他特殊符号。
  * Bash 的变量。
      * 用户自定义变量。
      * 环境变量。
      * 位置参数变量。
      * `$*` v.s. `$@`。
      * 预定义变量。
        * 接受键盘输入。
  * Bash 的运算符。
      * 数值运算 &amp; 运算符。
        * declare 声明变量类型。
      * 数值运算 ~ 方法 1。
      * 数值运算 ~ 方法 2 ~ expr 或 let 数值运算工具。
      * 数值运算 ~ 方法 3 ~ $((运算式)) or $[运算式]。
      * 变量测试与内容替换。
  * 环境变量配置文件。
        * 环境变量配置文件简介。
        * 环境变量配置文件作用。
      * 注销时生效的环境变量配置文件（~/.bash_logout）。
      * 历史命令文件（~/.bash_history）。
      * 登录界面信息（本地登录）。
      * 登录界面信息（远程登录）。
      * 登录后的欢迎信息。（远程 + 本地）~ `/etc/motd`。
  * 正则。
      * 正则 v.s. 通配符。
  * 字符截取命令。
      * 字段提取命令 ~ cut。
      * printf。
      * awk。
      * sed。
  * 字符处理命令。
  * 条件判断。
  * 流程控制。
      * if 语句。
        * 单分支 if 条件语句。
        * 双分支 if 条件语句。
      * case 语句。
      * for 循环。
      * while 循环。
</code></pre>

<hr />

<p>Shell 概述。<br />
Shell 脚本的执行方式。<br />
Bash 的基本功能。<br />
Bash 的变量。<br />
Bash 的运算符。<br />
环境变量配置文件。</p>

<h3 id="shell-概述">Shell 概述。</h3>

<ul>
<li>Shell 是一个命令行解释器，ta 为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。</li>
</ul>

<blockquote>
<p>外层应用程序 —&gt; Shell 命令解释器 —&gt; 内核 —&gt; 硬件。<br />
 内核只识别二进制（机器语言），我们输入的命令，如 ls，通过 Shell 翻译成机器语言，由内核按照我们的命令控制硬件，硬件将结果返回给内核，再由
Shell 把返回结果翻译成我们看得懂的信息交还给用户。<br />
 Windows 侦测鼠标点击 —&gt; Windows 图形交互界面就是 Windows 的 Shell。</p>
</blockquote>

<ul>
<li>Shell 还是一个功能强大的编程语言，易编写，易调试，灵活性较强。Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。

<br /></li>
</ul>

<h3 id="shell-的分类">Shell 的分类。</h3>

<ul>
<li><p>Bourne Shell：从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 <code>sh</code>。</p></li>

<li><p>C Shell：C Shell 主要在 BSD 版的 Unix 系统中使用，其语法和 C 语言相类似而得名。</p></li>
</ul>

<blockquote>
<p>Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。</p>

<ul>
<li>Bourne 家庭主要包括：sh、 ksh、 Bash、 psh、 zsh。</li>
<li>C 家庭主要包括：csh、 tcsh。<br />
Linux 标准 Shell：Bash。</li>
</ul>
</blockquote>

<ul>
<li><p>bash：bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。</p></li>

<li><p>Linux 支持的 Shell。</p>

<p>geek@geek-PC:~$ cat /etc/shells</p>

<h1 id="etc-shells-valid-login-shells">/etc/shells: valid login shells</h1>

<p>/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash</p>

<p>[root@localhost ~]# cat /etc/shells
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash</p></li>

<li><p>切换 Shell。</p>

<p>geek@geek-PC:~$ sh
$ ^C
$ exit
geek@geek-PC:~$ dash
$</p></li>

<li><p>nologin</p></li>
</ul>

<blockquote>
<p>普通用户：/bin/bash or /sbin/shutdown（具体用户 - 具体命令）。<br />
 伪用户：/sbin/nologin（不是用来执行命令的用户）。</p>
</blockquote>

<h3 id="shell-脚本的执行方式">Shell 脚本的执行方式。</h3>

<pre><code>[root@localhost geek]# echo &quot;hello world!&quot;
-bash: !&quot;: event not found
[root@localhost geek]# echo 'hello world!'
hello world!
</code></pre>

<ul>
<li>echo 输出命令。</li>
</ul>

<blockquote>
<p>[root@localhost ~]# echo [选项] [输出内容]<br />
 -e —&gt; 支持反斜线控制的字符转换。</p>
</blockquote>

<pre><code>[root@localhost ~]# echo -e &quot;ab\bc&quot;
ac
[root@localhost ~]# echo -e &quot;a\tb\tc\nd\te\tf&quot;
a   b   c
d   e   f
</code></pre>

<p>\0nnn —&gt; 八进制 ASCII 码。<br />
\xhh —&gt; 十六进制 ASCII 码。</p>

<pre><code>[root@localhost ~]# echo -e &quot;\x61\t\x62\t\x63\n\x64\t\x65\t\x66&quot;
a   b   c
d   e   f



[root@localhost ~]# echo -e &quot;\e[1;31m abcd \e[0m&quot;
 abcd 

\e[1; —&gt; 开启颜色输出。
\e[0m —&gt; 结束。
</code></pre>

<blockquote>
<p>30m —&gt; 黑色<br />
 31m —&gt; 红色<br />
 32m —&gt; 绿色<br />
 33m —&gt; 黄色<br />
 34m —&gt; 蓝色<br />
 35m —&gt; 洋红<br />
 36m —&gt; 青色<br />
 37m —&gt; 白色</p>
</blockquote>

<h5 id="第一个脚本">第一个脚本。</h5>

<pre><code>#! /bin/bash
#The first program.
# Author: Geek ~ Email: liyifan@lyfGeek.club

echo -e 'Geek, geek,!'



# 赋予执行权限，直接运行。
geek@geek-PC:~/Desktop/shell_geek$ ll
total 4
-rw-r--r-- 1 geek geek 102 Aug  5 21:28 hello.sh
geek@geek-PC:~/Desktop/shell_geek$ chmod +x hello.sh 
geek@geek-PC:~/Desktop/shell_geek$ ./hello.sh 
Geek, geek,!




# 通过 bash 调用执行脚本。可以不要执行权限。
geek@geek-PC:~/Desktop/shell_geek$ bash hello.sh 
Geek, geek,!
</code></pre>

<p>cat -A —&gt; 查看文件所有内容，包括隐藏字符。<br />
Linux 中的回车符 —&gt; <code>$</code>。<br />
Windows 中的回车符 —&gt; <code>^M$</code>。</p>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ cat -A hello.sh 
#! /bin/bash$
#The first program.$
# Author: Geek ~ Email: liyifan@lyfGeek.club$
$
echo -e 'Geek, geek,!'$
</code></pre>

<p>dos2unix 文件名。<br />
unix2dos</p>

<h3 id="bash-的基本功能">Bash 的基本功能。</h3>

<h5 id="历史命令与补全">历史命令与补全。</h5>

<pre><code>[root@localhost ~]# history [选项] [历史命令保存文件]
-c —&gt; 清空历史命令。
-w —&gt; 把缓存中的历史命令写入历史命令保存文件。默认：～/.bash_history。
</code></pre>

<blockquote>
<p>命令在正常登录退出后才会（自动）写入 ~/.bash_history。<br />
 历史命令默认会保存 1000 条，可以在环境变量配置文件 /etc/profile 中进行修改。</p>
</blockquote>

<pre><code>[root@localhost ~]# vim /etc/profile
HISTSIZE=1000
</code></pre>

<h6 id="历史命令的调用">历史命令的调用。</h6>

<blockquote>
<p>使用 <code>↑</code>、<code>↓</code>箭头调用以前的历史命令。<br />
 使用 <code>!n</code> 重复执行第 n 条历史命令。<br />
 使用 <code>!!</code> 重复执行上一条命令。<br />
 使用 <code>!字符串</code> 重复执行最后一条以该字符串开头的命令。</p>
</blockquote>

<h6 id="命令与文件补全">命令与文件补全。</h6>

<blockquote>
<p>在 bash 中，命令与文件补全是在非常方便与常用的命令，我们只要在输入命令或文件时，按 <code>Tab</code> 键就会自动进行补全。</p>
</blockquote>

<h5 id="命令别名与常用快捷键">命令别名与常用快捷键。</h5>

<blockquote>
<p>[root@localhost ~]# alias 别名=‘原命令’<br />
 // 设定命令别名。<br />
 [root@localhost ~]# alias<br />
 // 查询命令别名。<br />
 [root@localhost ~]# alias<br />
 alias cp=‘cp -i’<br />
 alias l.=‘ls -d .* &ndash;color=auto’<br />
 alias ll=‘ls -l &ndash;color=auto’<br />
 alias ls=‘ls &ndash;color=auto’<br />
 alias mv=‘mv -i’<br />
 alias rm=‘rm -i’<br />
 alias which=‘alias | /usr/bin/which &ndash;tty-only &ndash;read-alias &ndash;show-dot
&ndash;show-tilde’</p>
</blockquote>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ alias
alias dir='dir --color=auto'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -l'
alias ls='ls --color=auto'
alias vdir='vdir --color=auto'
</code></pre>

<h5 id="命令的执行顺序">命令的执行顺序。</h5>

<blockquote>
<p>第一顺位执行用绝对路径或相对路径执行的命令。<br />
 第二顺位执行别名。<br />
 第三顺位执行 <code>bash</code> 的内部命令。<br />
 第四顺位执行按照 <code>$PATH</code> 环境变量定义的目录查找顺序找到的第一个命令。</p>
</blockquote>

<pre><code>[root@localhost ~]# $PATH
-bash: /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin: No such file or directory
[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin



[root@localhost ~]# whereis ls
ls: /bin/ls /usr/share/man/man1/ls.1.gz
[root@localhost ~]# whereis cd
cd: /usr/share/man/man1/cd.1.gz  # shell 自带命令。只有帮助文档。
</code></pre>

<p>用命令行定义的别名临时生效。—&gt; 永久生效。—&gt; 配置文件。</p>

<pre><code>[root@localhost ~]# vi /root/.bashrc
</code></pre>

<h5 id="删除别名">删除别名。</h5>

<pre><code>[root@localhost ~]# unalias 别名
</code></pre>

<h3 id="bash-常用快捷键">bash 常用快捷键。</h3>

<blockquote>
<ul>
<li><p>Ctrl - A。<br />
—&gt; 把光标移动到命令行的开头。如果我们输入的命令过长，想要把光标移动到命令行的开头时使用。</p></li>

<li><p>Ctrl - E。<br />
—&gt; 把光标移动到命令行的结尾。</p></li>

<li><p>Ctrl - C。<br />
—&gt; 强制终止当前的命令。</p></li>

<li><p>Ctrl - L。<br />
—&gt; 清屏。相当于 clear 命令。</p></li>
</ul>

<p>-Ctrl - U。<br />
 —&gt; 删除或剪切光标之前的命令。我们输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个命令会更加方便。</p>

<ul>
<li><p>Ctrl - K。<br />
—&gt; 删除或剪切光标后的内容。</p></li>

<li><p>Ctrl - Y。<br />
—&gt; 粘贴 Ctrl - U 或 Ctrl - K 剪切的内容。</p></li>

<li><p>Ctrl - R。<br />
—&gt; 在历史命令中搜索。按下 Ctrl - R 后，就会进入搜索页面，只要输入内容，就会在历史命令搜索。</p></li>

<li><p>Ctrl - D。<br />
—&gt; 退出当前终端。</p></li>

<li><p>Ctrl - Z。<br />
—&gt; 暂停。并放入后台。这个快捷键牵扯工作管理的内容，—— &gt;系统管理章节。</p></li>

<li><p>Ctrl - S。<br />
—&gt; 暂停屏幕输出。</p></li>

<li><p>Ctrl - Q。<br />
—&gt; 恢复屏幕输出。</p></li>
</ul>
</blockquote>

<h3 id="输入输出重定向">输入输出重定向。</h3>

<ul>
<li>标准输入输出设备。</li>
</ul>

<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>键盘</td>
<td>/dev/stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>

<tr>
<td>显示器</td>
<td>/dev/stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>

<tr>
<td>显示器</td>
<td>/dev/stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>

<h5 id="输出重定向">输出重定向。</h5>

<p>改变输出方向，屏幕 —&gt; 文件。</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>符号</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>标准输出重定向</td>
<td>命令 &gt; 文件</td>
<td>以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。</td>
</tr>

<tr>
<td>命令 &gt;&gt; 文件</td>
<td>以追加的方式，把命令的正确输出输出到指定的文件或设备当中。</td>
<td></td>
</tr>

<tr>
<td>标准错误输出重定向</td>
<td>错误命令 <code>2&gt;</code> 文件</td>
<td>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</td>
</tr>

<tr>
<td>错误命令 <code>2&gt;&gt;</code> 文件</td>
<td>以追加的方式，把命令的错误输出输出到指定的文件或设备当中。</td>
<td></td>
</tr>
</tbody>
</table>

<pre><code>geek@geek-PC:~$ date
Mon Feb 24 12:57:02 CST 2020
</code></pre>

<p>如果用 <code>&gt;&gt;</code> ，<code>command not found</code> 不会写入文件。</p>

<pre><code>[root@localhost geek]# lst &gt;&gt; error_test.txt
-bash: lst: command not found
[root@localhost geek]# cat error_test.txt 

geek@geek-PC:~/Desktop/shell_geek$ lsa 2&gt;&gt; error.txt
geek@geek-PC:~/Desktop/shell_geek$ ls
error.txt  hello.sh
geek@geek-PC:~/Desktop/shell_geek$ cat error.txt 
bash: lsa: command not found
</code></pre>

<p>正确输出和错误输出同时保存。</p>

<p>解释：<code>2&gt;&amp;1</code> —&gt; 先把错误输出保存在正确输出中。<br />
再把正确输出和错误输出保存在文件中。</p>

<p>|<br />
&mdash;|&mdash;<br />
命令 &gt; 文件 2&gt;&amp;1 | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件中。<br />
命令 &gt;&gt; 文件 2&gt;&amp;1 | 以追加的方式，把正确输出和错误输出都保存到同一个文件中。<br />
命令 &amp;&gt; 文件 | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件中。<br />
命令 &amp;&gt;&gt; 文件 | 以追加的方式，把正确输出和错误输出都保存到同一个文件中。<br />
命令 &gt;&gt; ‘文件1’ 2 &gt;&gt; ‘文件2’ | 把正确的输出追加到文件 1，把错误的输出追加到文件 2。</p>

<pre><code>[root@localhost geek]# lsa &gt;&gt; true.txt 2&gt;&gt;false.txt



[root@localhost geek]# ls &amp;&gt; /dev/null
[root@localhost geek]# cat /dev/null
# Linux 垃圾箱。
</code></pre>

<h5 id="输入重定向">输入重定向。</h5>

<blockquote>
<p>[root@localhost ~]# wc [选项] [文件名]<br />
 -c —&gt; 统计字节数。<br />
 -w —&gt; 统计单词数。<br />
 -l —&gt; 统计行数。</p>

<p>wc<br />
 …<br />
 …<br />
 Ctrl - D。</p>

<p>命令 &lt; 文件。 # 把文件作为命令的输入。</p>
</blockquote>

<pre><code>[root@localhost ~]# wc &lt; anaconda-ks.cfg 
  31  115 1107
</code></pre>

<p>&lt;&lt; —&gt; 统计两个符号之间的内容。</p>

<pre><code>[root@localhost ~]# wc &lt;&lt; geek
&gt; hello
&gt; world
&gt; geek
 2  2 12
</code></pre>

<h3 id="多命令顺序执行与管道">多命令顺序执行与管道。</h3>

<ul>
<li>多命令执行顺序。</li>
</ul>

<table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>;</code></td>
<td>命令 1 <code>:</code> 命令 2</td>
<td>多个命令顺序执行，命令之间没有任何逻辑联系。</td>
</tr>

<tr>
<td><code>&amp;&amp;</code></td>
<td>命令 1 <code>&amp;&amp;</code> 命令 2</td>
<td>逻辑与。</td>
</tr>
</tbody>
</table>

<p>当命令 1 正确执行，命令 2 才会执行。<br />
当命令 1 执行不正确，命令 2 不会执行。<br />
<code>||</code> | 命令 1 <code>||</code> 命令 2 | 逻辑或。<br />
当命令 1 执行不正确，命令 2 才会执行。<br />
当命令 1 执行正确，命令 2 不会执行。</p>

<p><code>:</code> —&gt; 用来简化操作。</p>

<blockquote>
<p>[root@localhost ~]# dd if=输入文件 of=输出文件 bs=字节数 count=个数<br />
 选项。<br />
 if=输入文件。—&gt; 指定源文件或设备。<br />
 of=输出文件。—&gt; 指定目标文件或目标设备。<br />
 bs=字节数。—&gt; 指定一次输入/输出多少字节，即把多少字节看作一个数据块。<br />
 count=个数。—&gt; 指定输入/输出多少个数据块。</p>

<p>cp
命令只能复制文件。dd（磁盘复制、数据复制命令）可以复制特殊命令、特殊文件，复制分区甚至整个硬盘。不仅复制分区或硬盘中的数据，并且复制分区或硬盘的文件系统。（磁盘对拷命令）。</p>
</blockquote>

<pre><code>[root@localhost ~]# date; dd if=/dev/zero of=/root/testfile bs=1k count=100000; date
</code></pre>

<p>// 每次从 /dev/zero 复制 1k 数据到 /root/testfile，执行 100_000 次，并统计时间。</p>

<ul>
<li><p><code>&amp;&amp;</code>。</p>

<p>[root@localhost ~]# ls &amp;&amp; echo yes
anaconda-ks.cfg  geek  install.log  install.log.syslog
yes</p>

<p>[root@localhost ~]# ./configure &amp;&amp; make &amp;&amp; make install</p></li>

<li><p><code>||</code>。</p>

<p>[root@localhost ~]# lsa || echo no
no</p>

<p>[root@localhost ~]# 命令 &amp;&amp; echo yes || echo no</p></li>
</ul>

<p>&amp;&amp; 优先级高于 ||。</p>

<h5 id="管道符">管道符～<code>|</code>。</h5>

<blockquote>
<p>[root@localhost ~]# 命令 1 | 命令 2<br />
 // 命令 1 的正确输出作为命令 2 的操作对象。<br />
 颜色显示。</p>
</blockquote>

<pre><code>[root@localhost ~]# ll -a /etc/ | more

[root@localhost ~]# netstat -an | grep &quot;ESTABLISHED&quot;
tcp        0      0 192.168.223.129:22          192.168.223.1:39006         ESTABLISHED
</code></pre>

<blockquote>
<p>[root@localhost ~]# grep [选项] “搜索内容” 文件名<br />
 选项。<br />
 -i。—&gt; 忽略大小写。<br />
 -n。—&gt; 输出行号。<br />
 -v。—&gt; 反向查找。<br />
 –color=auto。—&gt; 搜索出的关键字用颜色显示。</p>
</blockquote>

<h5 id="通配符与其他特殊符号">通配符与其他特殊符号。</h5>

<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>?</td>
<td>匹配一个任意字符。</td>
</tr>

<tr>
<td>*</td>
<td>匹配 0 个或多个任意字符，也就是可以匹配任何内容。</td>
</tr>

<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符。eg. [abc] 代表一定匹配一个字符，或者是 a，或者是 b，或者是 c。</td>
</tr>

<tr>
<td>[ - ]</td>
<td>匹配中括号中任意一个字符，<code>-</code> 代表一个范围。eg. [a-z] 代表匹配一个小写字母。</td>
</tr>

<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符。eg. <code>[^0-9]</code> 代表匹配一个不是数字的字符。</td>
</tr>

<tr>
<td>符号</td>
<td>作用</td>
</tr>

<tr>
<td>&mdash;</td>
<td>&mdash;</td>
</tr>

<tr>
<td>‘’</td>
<td>单引号，在单绰号中所有的特殊符号，eg. $ 和 `（反引号）都没有特殊含义。</td>
</tr>

<tr>
<td>“”</td>
<td>双引号。在双绰号中特殊符号都没有特殊含义，但是 $（调用变量的值）、`（引用命令） 和 \（转义符） 是例外。拥有特殊含义。</td>
</tr>

<tr>
<td>``</td>
<td>反引号。反引号中的内容是系统命令。在 Bash 中会优先执行 ta。</td>
</tr>

<tr>
<td>$()</td>
<td>和反引号作用一样，用来引用系统命令。推荐使用，因为反引号容易看错。</td>
</tr>

<tr>
<td>#</td>
<td>在 Shell 脚本中，# 开头的行表示注释。</td>
</tr>

<tr>
<td>$</td>
<td>用于调用变量的值。eg. 调用变量 name 的值：$name。</td>
</tr>

<tr>
<td></td>
<td>转义符。跟在 \ 之后的符号将失去特殊含义，变为普通字符。eg. $ 将输出为 $ 符号，而不是当作变量引用。</td>
</tr>
</tbody>
</table>

<pre><code>geek@geek-PC:~$ name=geek
geek@geek-PC:~$ echo '$name'
$name
geek@geek-PC:~$ echo &quot;$name&quot;
geek
geek@geek-PC:~$ echo '$(date)'
$(date)
geek@geek-PC:~$ echo &quot;$(date)&quot;
Fri 07 Aug 2020 01:26:30 PM CST
geek@geek-PC:~$ echo date
date
geek@geek-PC:~$ echo geek
geek
geek@geek-PC:~$ echo name
name




geek@geek-PC:~$ abc=`date`
geek@geek-PC:~$ echo abc
abc
geek@geek-PC:~$ echo $abc
Fri 07 Aug 2020 01:29:06 PM CST
</code></pre>

<h3 id="bash-的变量">Bash 的变量。</h3>

<p>变量是计算机内存的单元，其中存放的值可以改变。当 SheII 脚本需要保存一些信息时，如一个文件名或是一个数字，就把 ta
存放在一个变量中。每个变量有一个名字，所以很容易引用 ta。使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。</p>

<h5 id="用户自定义变量">用户自定义变量。</h5>

<ul>
<li>变量设置规则。</li>
</ul>

<blockquote>
<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是 “2name”，则是错误的。</li>
<li>在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。</li>
<li>变量用等号连接值，等号左右两侧不能有空格。<br />
变量的值如果有空格，需要使用单引号或双引号包括。</li>
<li>在变量的值中，可以使用 “\” 转义符。</li>
<li>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含<code>$变量名</code>或用<code>${变量名}</code> 包含。</li>
<li>如果是把命令的结果作为变量值赋予变量，则需要使用反引号或 <code>$()</code> 包含命令。</li>
<li>环境变量名建议大写，便于区分。


<br /></li>
</ul>
</blockquote>

<ul>
<li>用户自定义变量。</li>
<li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。</li>
<li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li>

<li><p>预定义变量：是 Bash 中己经定义好的变量，变量名不能自定义，变量作用也是固定的。</p>

<p>geek@geek-PC:~$ name=&ldquo;Yifan Li&rdquo;
geek@geek-PC:~$ aa=123
geek@geek-PC:~$ aa=&ldquo;$aa&rdquo;456
geek@geek-PC:~$ echo aa
aa
geek@geek-PC:~$ echo $aa
123456
geek@geek-PC:~$ aa=${aa}789
geek@geek-PC:~$ echo $aa
123456789
geek@geek-PC:~$ echo $name
Yifan Li</p></li>

<li><p>变量调用。</p></li>
</ul>

<blockquote>
<p>echo $name</p>
</blockquote>

<ul>
<li>变量查看。</li>
</ul>

<blockquote>
<p>set</p>
</blockquote>

<ul>
<li>变量删除。</li>
</ul>

<blockquote>
<p>unset name</p>
</blockquote>

<h5 id="环境变量">环境变量。</h5>

<blockquote>
<p>用户自定义变量只在当前的 SheII 中生效，而环境变量会在当前SheII 和这个 SheII 的所有子 SheII
当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的 SheII 中生效。</p>
</blockquote>

<ul>
<li>设置环境变量。</li>
</ul>

<blockquote>
<p>export 变量名=变量值</p>
</blockquote>

<ul>
<li>查询变量。</li>
</ul>

<blockquote>
<p>env</p>
</blockquote>

<ul>
<li>删除变量。</li>
</ul>

<blockquote>
<p>unset 变量名</p>
</blockquote>

<pre><code>geek@geek-PC:~$ pstree
systemd─┬─ModemManager───2*[{ModemManager}]
        ├─NetworkManager─┬─dhclient
        │                └─2*[{NetworkManager}]
        ├─VGAuthService
        ├─accounts-daemon───2*[{accounts-daemon}]
        ├─alsactl
        ├─avahi-daemon───avahi-daemon
        ├─avfsd───3*[{avfsd}]
        ├─bluetoothd
        ├─cron
        ├─cupsd
        ├─2*[dbus-daemon]
        ├─dde-clipboardlo───5*[{dde-clipboardlo}]
        ├─dde-file-manage───2*[{dde-file-manage}]
        ├─dde-system-daem─┬─rfkill
        │                 └─12*[{dde-system-daem}]
        ├─deepin-anything───deepin-anything───{deepin-anything}
        ├─deepin-sync-hel───4*[{deepin-sync-hel}]
        ├─deepin-wine───WeChat.exe───45*[{WeChat.exe}]
        ├─et───9*[{et}]
        ├─explorer.exe───3*[{explorer.exe}]
        ├─fcitx───{fcitx}
        ├─fcitx-dbus-watc
        ├─geoclue───2*[{geoclue}]
        ├─gnome-keyring-d─┬─ssh-agent
        │                 └─3*[{gnome-keyring-d}]
        ├─imwheel
        ├─lastore-daemon───9*[{lastore-daemon}]
        ├─lightdm─┬─Xorg───{Xorg}
        │         ├─lightdm─┬─startdde─┬─agent───2*[{agent}]
        │         │         │          ├─chromium─┬─chrome-sandbox───chromium───chromium─┬─5*[chromium───9*[{chromium}]]
        │         │         │          │          │                                      └─chromium───11*[{chromium}]
        │         │         │          │          ├─chromium─┬─chromium
        │         │         │          │          │          └─7*[{chromium}]
        │         │         │          │          ├─chromium───8*[{chromium}]
        │         │         │          │          └─26*[{chromium}]
        │         │         │          ├─dde-clipboard───5*[{dde-clipboard}]
        │         │         │          ├─dde-desktop───10*[{dde-desktop}]
        │         │         │          ├─dde-dock───9*[{dde-dock}]
        │         │         │          ├─dde-file-manage───10*[{dde-file-manage}]
        │         │         │          ├─dde-osd───8*[{dde-osd}]
        │         │         │          ├─dde-polkit-agen───5*[{dde-polkit-agen}]
        │         │         │          ├─dde-printer───6*[{dde-printer}]
        │         │         │          ├─dde-session-dae───22*[{dde-session-dae}]
        │         │         │          ├─deepin-deepinid───7*[{deepin-deepinid}]
        │         │         │          ├─kwin_no_scale───kwin_x11───10*[{kwin_x11}]
        │         │         │          ├─sh───default-termina─┬─deepin-terminal─┬─bash───bash───pstree
        │         │         │          │                      │                 └─2*[{deepin-terminal}]
        │         │         │          │                      └─7*[{default-termina}]




geek@geek-PC:~$ $PATH
bash: /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin: No such file or directory
</code></pre>

<ul>
<li>PS1 ~ 定义系统提示符的变量。</li>
</ul>

<blockquote>
<p>\d ~ 显示日期，格式为“星期 月 日”。<br />
 \h ~ 显示简写主机名。如默认主机名&rdquo;localhost&rdquo;。<br />
 \t ~ 显示 24 小时制时间，格式为 “HH:MM:SS”。<br />
 \T ~ 显示 12 小时制时间，格式为 “HH:MM:SS”。<br />
 \A ~ 显示 24 小时制时间，格式为 “HH:MM”。<br />
 \u ~ 显示当前用户名。<br />
 \w ~ 显示当前所在目录的完整名称。<br />
 \W ~ 显示当前所在目录的最后一个目录。<br />
 # ~ 执行的第几个命令。<br />
 $ ~ 提示符。如果是 root 用户会显示提示符为 “#”，如果是普通用户会显示提示符为 “$”。</p>
</blockquote>

<pre><code>geek@geek-PC:~$ echo $PS1
\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$
</code></pre>

<h5 id="位置参数变量">位置参数变量。</h5>

<ul>
<li><p>$n。<br />
n 为数字，$0 代表命令本身，$1 ~ $9 代表第一到第九个参数，十以上的参数代表需要用大括号包含，eg. ${10}。</p></li>

<li><p><code>$*</code>。<br />
这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体。</p></li>

<li><p>$@。<br />
这个变量也代表命令行中所有的参数，不过 $@ 把每个参数区分对待。</p></li>

<li><p>$#。<br />
这个变量代表命令行中所有参数的个数。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ cat args.sh
#!/bin/bash</p>

<p>echo $0
echo $1
echo $2
echo $3</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ bash args.sh 11 22 33
args.sh
11
22
33</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ cat args_math.sh
#!/bin/bash</p>

<p>num1=$1
num2=$2
sum=$(($num1 + $num2))</p>

<p>echo $sum
geek@geek-PC:~/Desktop/shell_geek$ bash args_math.sh 1 2
3</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ cat args_num.sh
#!/bin/bash</p>

<p>echo &ldquo;total parameters: $#.&rdquo;</p>

<p>echo &ldquo;The parameters are: $*.&rdquo;</p>

<p>echo &ldquo;The parameters are: $@.&rdquo;
geek@geek-PC:~/Desktop/shell_geek$ bash args_num.sh a1 b1 c1 d1
total parameters: 4.
The parameters are: a1 b1 c1 d1.
The parameters are: a1 b1 c1 d1.</p></li>
</ul>

<h5 id="v-s"><code>$*</code> v.s. <code>$@</code>。</h5>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ cat args_dif.sh 
#!/bin/bash

for i in &quot;$*&quot;
    do
        echo &quot;The parameterrs: $i.&quot;
    done

x=1

for y in &quot;$@&quot;
    do 
        echo &quot;The parameter - $x is: $y.&quot;
        x=$(($x + 1))
    done

geek@geek-PC:~/Desktop/shell_geek$ bash args_dif.sh a1 b1 c1 d1 e1
The parameterrs: a1 b1 c1 d1 e1.
The parameter - 1 is: a1.
The parameter - 2 is: b1.
The parameter - 3 is: c1.
The parameter - 4 is: d1.
The parameter - 5 is: e1.
</code></pre>

<h5 id="预定义变量">预定义变量。</h5>

<table>
<thead>
<tr>
<th>预定义变量</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>$?</td>
<td>最后一次执行的命令的返回状态。0 ~ 上一个命令正确执行。非 0（具体是哪一个数字由命令本身决定）~ 上一个命令执行不正确。</td>
</tr>

<tr>
<td>$$</td>
<td>当前进程的 PID。</td>
</tr>

<tr>
<td>$!</td>
<td>后台运行的最后一个进程的进程号（PID）。</td>
</tr>
</tbody>
</table>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ ls
args_dif.sh  args_math.sh  args_num.sh  args.sh  error.txt  hello.sh
geek@geek-PC:~/Desktop/shell_geek$ echo $?
0
geek@geek-PC:~/Desktop/shell_geek$ lsa
bash: lsa: command not found
geek@geek-PC:~/Desktop/shell_geek$ echo $?
127
geek@geek-PC:~/Desktop/shell_geek$ ls a
ls: cannot access 'a': No such file or directory
geek@geek-PC:~/Desktop/shell_geek$ echo $?
2
</code></pre>

<h6 id="接受键盘输入">接受键盘输入。</h6>

<blockquote>
<p>read [选项] [变量名]<br />
 -p “提示信息”。 在等待 read 输入时，输出提示信息。<br />
 -t 秒数。 read 命令会一直等待用户输入，使用此选项可以指定等待时间。<br />
 -n 字符数。 read 命令只接受指定的字符数，就会执行。（不用按回车）。<br />
 -s。 隐藏输入的数据。适用于机密信息的输入。</p>
</blockquote>

<pre><code>#!/bin/bash

# 提示“请输入姓名”并等待 30 秒，把用户的输入保存入变量 name 中。
read -t 30 -p &quot;Please input your name: &quot; name
echo &quot;Name is $name.&quot;

read -s -t 30 -p &quot;Please input your age: &quot; age
# 隐私数据使用 -s。
echo &quot;Age is $age.&quot;
echo -e &quot;\n&quot;

read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender
# 使用 &quot;-n 1&quot; 选项只接受一个输入字符就会执行（不用输回车）。
echo -e &quot;\n&quot;
echo &quot;gender is $gender.&quot;
</code></pre>

<h3 id="bash-的运算符">Bash 的运算符。</h3>

<h5 id="数值运算-运算符">数值运算 &amp; 运算符。</h5>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ aa=11
geek@geek-PC:~/Desktop/shell_geek$ bb=22
geek@geek-PC:~/Desktop/shell_geek$ cc=$aa+$bb
geek@geek-PC:~/Desktop/shell_geek$ echo $cc
11+22
</code></pre>

<h6 id="declare-声明变量类型">declare 声明变量类型。</h6>

<blockquote>
<p>declare [+/-] [选项] 变量名<br />
 选项。<br />
 -。 给变量设定类型属性。<br />
 +。 取消变量的类型属性。<br />
 -i。 将变量声明为整数型（integer）。<br />
 -x。 将变量声明为环境变量。<br />
 -p。 显示 / 指定变量的被声明的类型。</p>
</blockquote>

<pre><code>geek@geek-PC:~$ aa=11
geek@geek-PC:~$ bb=22
geek@geek-PC:~$ cc=$aa+$bb
geek@geek-PC:~$ echo $cc
11+22
geek@geek-PC:~$ declare -p aa
declare -- aa=&quot;11&quot;
geek@geek-PC:~$ export aa
geek@geek-PC:~$ declare -p aa
declare -x aa=&quot;11&quot;
</code></pre>

<h5 id="数值运算-方法-1">数值运算 ~ 方法 1。</h5>

<pre><code>geek@geek-PC:~$ aa=11
geek@geek-PC:~$ bb=22
geek@geek-PC:~$ declare -i cc=$aa+$bb
geek@geek-PC:~$ echo cc
cc
geek@geek-PC:~$ echo $cc
33
</code></pre>

<h5 id="数值运算-方法-2-expr-或-let-数值运算工具">数值运算 ~ 方法 2 ~ expr 或 let 数值运算工具。</h5>

<pre><code>geek@geek-PC:~$ aa=11
geek@geek-PC:~$ bb=22
geek@geek-PC:~$ dd=$(expr $aa+$bb)
geek@geek-PC:~$ echo dd
dd
geek@geek-PC:~$ echo $dd
11+22
geek@geek-PC:~$ dd=$(expr $aa + $bb)  # + 号左右必须有空格。
geek@geek-PC:~$ echo $dd
33
</code></pre>

<h5 id="数值运算-方法-3-运算式-or-运算式">数值运算 ~ 方法 3 ~ $((运算式)) or $[运算式]。</h5>

<pre><code>geek@geek-PC:~$ aa=11
geek@geek-PC:~$ bb=22
geek@geek-PC:~$ ff=$(($aa+$bb))
geek@geek-PC:~$ gg=$[$aa+$bb]
geek@geek-PC:~$ echo $ff
33
geek@geek-PC:~$ echo $gg
33




geek@geek-PC:~$ gg=$(( (7+8)*6/3 ))
geek@geek-PC:~$ echo $gg
30
</code></pre>

<h5 id="变量测试与内容替换">变量测试与内容替换。</h5>

<table>
<thead>
<tr>
<th>变量置换方式</th>
<th>变量 y 没有设置值</th>
<th>变量 y 为空值</th>
<th>变量 y 设置值</th>
</tr>
</thead>

<tbody>
<tr>
<td>x=$ {y -新值}</td>
<td>x = 新值</td>
<td>x 为空</td>
<td>x=$y</td>
</tr>

<tr>
<td>x=$ {y: -新值}</td>
<td>x = 新值</td>
<td>x = 新值</td>
<td>x=$y</td>
</tr>

<tr>
<td>x=$ {y+新值}</td>
<td>x 为空</td>
<td>x = 新值</td>
<td>x = 新值</td>
</tr>

<tr>
<td>x=$ {y: +新值}</td>
<td>x 为空</td>
<td>x 为空</td>
<td>x = 新值</td>
</tr>

<tr>
<td>x=$ {y = 新值}</td>
<td>x = 新值</td>
<td></td>
<td></td>
</tr>

<tr>
<td>y = 新值</td>
<td>x 为空</td>
<td></td>
<td></td>
</tr>

<tr>
<td>y 值不变</td>
<td>x=$y</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>y 值不变<br />
x=$ {y := 新值} | x = 新值<br />
y = 新值 | x = 新值<br />
y = 新值 | x=$y<br />
y 值不变<br />
x=$ {y?新值} | 新值输出到标准错误输出（就是屏幕） | x 为空 | x=$y<br />
x=$ {y:?新值} | 新值输出到标准错误输出（就是屏幕） | 新值输出到标准错误输出（就是屏幕） | x=$y</p>

<h3 id="环境变量配置文件">环境变量配置文件。</h3>

<h6 id="环境变量配置文件简介">环境变量配置文件简介。</h6>

<p>环境变量可以在一系列 Shell 中生效。本地变量只能在当前 Shell 文件中生效。<br />
环境变量有系统默认变量。变量名称和作用固定，我们可以改变 ta 的值。<br />
环境变量允许用户把自己定义的本地变量声明为环境变量。<br />
环境变量配置文件：系统每次启动读取生效。（登录）</p>

<ul>
<li>source 命令。</li>
</ul>

<blockquote>
<p>[root@localhost]# source 配置文件<br />
 或<br />
 [root@localhost]# . 配置文件 # . 就是 source。</p>
</blockquote>

<p>环境变量配置文件中主要定义对系统的操作环境生效的系统默认环境变量，eg. PATH, HISTSIZE, PSI, HOSTNAME 等默认环境变量。</p>

<pre><code>[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin

geek@geek-PC:~$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin




PATH=&quot;$PATH&quot;:/root  # 重启失效。
</code></pre>

<ul>
<li>/etc/profile</li>
<li>/etc/profile.d/*.sh</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
</ul>

<p>/etc/* —&gt; 对所有登录此 Linux 系统的用户都生效。</p>

<h6 id="环境变量配置文件作用">环境变量配置文件作用。</h6>

<p><a href="https://img.it610.com/image/info8/c0206821f6404a1f8405e72552e832b9.jpg"><img src="https://img.it610.com/image/info8/c0206821f6404a1f8405e72552e832b9.jpg" alt="Shell
编程～人入门到入坑。_第1张图片" /></a><br />
一般前面的配置文件会调用后面的配置文件。</p>

<pre><code>[root@localhost ~]# cat ~/.bashrc 
# .bashrc

# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi
</code></pre>

<p>后面的配置文件会覆盖前面的。</p>

<p>但这里使用 <code>：</code> 追加，在原来的 $PATH 基础上再增加。</p>

<blockquote>
<p><code>PATH=$PATH:$HOME/bin</code></p>
</blockquote>

<pre><code>[root@localhost ~]# cat ~/.bash_profile 
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin

export PATH
</code></pre>

<h5 id="注销时生效的环境变量配置文件-bash-logout">注销时生效的环境变量配置文件（~/.bash_logout）。</h5>

<h5 id="历史命令文件-bash-history">历史命令文件（~/.bash_history）。</h5>

<h5 id="登录界面信息-本地登录">登录界面信息（本地登录）。</h5>

<pre><code>[root@localhost ~]# cat /etc/issue
CentOS release 6.10 (Final)
Kernel \r on an \m
</code></pre>

<table>
<thead>
<tr>
<th>转义符</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>\d</td>
<td>显示当前系统日期</td>
</tr>

<tr>
<td>\s</td>
<td>显示操作系统名称</td>
</tr>

<tr>
<td>\l</td>
<td>显示登录的终端号，这个比较常用。</td>
</tr>

<tr>
<td>\m</td>
<td>显示硬件体系结构，如 i386 、i686 等。</td>
</tr>

<tr>
<td>\n</td>
<td>显示主机名。</td>
</tr>

<tr>
<td>\o</td>
<td>显示域名。</td>
</tr>

<tr>
<td>\r</td>
<td>显示内核版本。</td>
</tr>

<tr>
<td>\t</td>
<td>显示当前系统时间。</td>
</tr>

<tr>
<td>\u</td>
<td>显示当前登录用户的序列号。</td>
</tr>
</tbody>
</table>

<h5 id="登录界面信息-远程登录">登录界面信息（远程登录）。</h5>

<pre><code>[root@localhost ~]# vim /etc/ssh/sshd_config

# no default banner path
#Banner none

Banner /etc/issue.net
</code></pre>

<h5 id="登录后的欢迎信息-远程-本地-etc-motd">登录后的欢迎信息。（远程 + 本地）~ <code>/etc/motd</code>。</h5>

<h3 id="正则">正则。</h3>

<h5 id="正则-v-s-通配符">正则 v.s. 通配符。</h5>

<blockquote>
<p>正则表达式用来在文件中匹配符合条件的<code>字符串</code>，正则是包含匹配。<br />
 grep、awk、sed 等命令可以支持正则表达式。</p>

<p>通配符用来匹配符合条件的<code>文件名</code>，通配符是<code>完全匹配</code>。ls 、find 、cp 这些命令不支持正则表达式，所以只能使用 Shell 自己<br />
 的通配符来进行匹配了。</p>
</blockquote>

<table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>*</td>
<td>前一个字符匹配 0 次或任意多次。</td>
</tr>

<tr>
<td>.</td>
<td>匹配除了换行符外任意一字符。</td>
</tr>

<tr>
<td>^</td>
<td>匹配行首。eg. ^hello 会匹配以hello 开头的行。</td>
</tr>

<tr>
<td>$</td>
<td>匹配行尾。eg. $hello 会匹配以hello 结尾的行。</td>
</tr>

<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一字符，只匹配一个字符。eg. [aeiou] 匹配任意一个元音字母，[0-9] 匹配任意一位数字，[a-z][0-9]</td>
</tr>
</tbody>
</table>

<p>匹配小写字和一位数字构成的两位字符。<br />
[^] | 匹配除中括号的字符以外的任意一个字符。eg. [^0-9 ] 匹配任意一位非数字字符，[^a-z] 表示任意一位非小写字母。<br />
\ | 转义符。用于取消。将特殊符号的含义取消。<br />
{n} | 表示其前面的字符恰好出现 n 次。eg. [0-9]{4} 匹配 4 位数字，[1][3-8][0-9]{9} 匹配手机号码。<br />
{n, } | 表示其前面的字符出现不小于 n 次。eg. [0-9]{2,} 表示两位及以上的数字。<br />
{n,m} | 表示其前面的字符至少出现 n 次，最多出现 m 次。eg. [a-z]{6,8} 匹配 6 到 8 位的小写字母。</p>

<p>^$</p>

<p>匹配空白行。</p>

<h3 id="字符截取命令">字符截取命令。</h3>

<h5 id="字段提取命令-cut">字段提取命令 ~ cut。</h5>

<blockquote>
<p>cut [选项] 文件名<br />
 选项。<br />
 -f 列号。 提取第几列。<br />
 -d 分隔符。 按照指定分隔符分隔列。</p>
</blockquote>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ vim student.txt
geek@geek-PC:~/Desktop/shell_geek$ cat student.txt 
ID  name    gender  mark
1   Liming  M   86
2   sc  M   90
3   Geek    M   83



geek@geek-PC:~/Desktop/shell_geek$ cut -f 2 student.txt 
name
Liming
sc
Geek
geek@geek-PC:~/Desktop/shell_geek$ cut -f 2,4 student.txt 
name    mark
Liming  86
sc  90
Geek    83
</code></pre>

<ul>
<li><p>-d。指定分隔符。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ cut -d &ldquo;:&rdquo; -f 1,3 /etc/passwd</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ cat /etc/passwd | grep /bin/bash
root:x:0:0:root:/root:/bin/bash
geek:x:1000:1000::/home/geek:/bin/bash
geek@geek-PC:~/Desktop/shell_geek$ cat /etc/passwd | grep /bin/bash | grep -v root
geek:x:1000:1000::/home/geek:/bin/bash
geek@geek-PC:~/Desktop/shell_geek$ cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &ldquo;:&rdquo; -f 1
geek</p></li>

<li><p>分隔符不是制表符。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            1.9G     0  1.9G   0% /dev
tmpfs           392M  3.0M  389M   1% /run
/dev/sda5        15G  7.1G  7.0G  51% /
tmpfs           2.0G  116M  1.8G   6% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup
/dev/sda3       9.8G  6.0G  3.3G  65% /recovery
/dev/sda1       1.5G  110M  1.3G   8% /boot
/dev/sda7        17G   12G  3.8G  76% /data
tmpfs           392M   64K  392M   1% /run/user/1000
geek@geek-PC:~/Desktop/shell_geek$ df -h | grep &ldquo;sda5&rdquo;
/dev/sda5        15G  7.1G  7.0G  51% /
geek@geek-PC:~/Desktop/shell_geek$ df -h | grep &ldquo;sda5&rdquo; | cut -f 5
/dev/sda5        15G  7.1G  7.0G  51% /</p></li>
</ul>

<p>↓ ↓ ↓</p>

<p>awk。</p>

<h5 id="printf">printf。</h5>

<blockquote>
<ul>
<li>printf ‘输出类型 输出格式’ 输出内容<br />
输出类型。<br />
%ns～输出字符串。n 是数字。指代输出几个字符。<br />
%ni～输出整数。n 是数字。指代输出几个数字。<br />
%m.nf～输出浮点数。m 和 n 是数字，指代输出的整数位数和小数位数。eg. 8.2f 代表共输出 8 位数，其中 2 位是小数，6 位是整数。


<br /></li>
</ul>
</blockquote>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ printf %s 1 2 3 4 5 6
123456geek@geek-PC:~/Desktop/shell_geek$ printf %s %s %s 1 2 3 4 5 6
%s%s123456geek@geek-PC:~/Desktop/shell_geek$ printf '%s %s %s' 1 2 3 4 5 6
1 2 34 5 6geek@geek-PC:~/Desktop/shell_geek$ printf '%s %s %s\n' 1 2 3 4 5 6
1 2 3
4 5 6
</code></pre>

<ul>
<li><p>输出文件内容。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ printf &lsquo;%s&rsquo; student.txt
student.txtgeek@geek-PC:~/Desktop/shell_geek$ cat student.txt | printf &lsquo;%s&rsquo;
geek@geek-PC:~/Desktop/shell_geek$ printf &lsquo;%s&rsquo; $(cat student.txt)
IDnamegendermark1LimingM862scM903GeekM83geek@geek-PC:~/Desktop/shell_geek$</p></li>
</ul>

<p>在 awk 命令的输出中支持 print 和 printf 命令。</p>

<ul>
<li><p>print。<br />
会在每个输出之后自动加一个换行符。（Linux 默认没有 print 命令）。</p></li>

<li><p>printf。<br />
标准格式输出命令，并不会自动加入换行符。如果需要换行，需要手工加入换行符。</p></li>
</ul>

<h5 id="awk">awk。</h5>

<blockquote>
<p>awk ‘条件 1 {动作 1} 条件 2 {动作 2} …’ 文件名</p>

<ul>
<li>条件（Pattern）。<br />
一般使用关系表达式作为条件。<br />
x &gt; 10 ~ 判断变量 x 是否大于 10。<br />
x &gt;= 10<br />
x &lt;= 10</li>
<li>动作（Action）。<br />
格式化输出。<br />
流程控制语句。


<br /></li>
</ul>
</blockquote>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ vim student.txt 
geek@geek-PC:~/Desktop/shell_geek$ cat student.txt 
ID  name    PHP Linux   MySQL   average
1   Liming  82  95  86  87.66
2   sc      74  96  87  85.66
3   Geek    99  83  93  91.66




geek@geek-PC:~/Desktop/shell_geek$ awk '{printf $2 &quot;\t&quot; $6 &quot;\n&quot;}' student.txt 
name    average
Liming  87.66
sc  85.66
Geek    91.66

geek@geek-PC:~/Desktop/shell_geek$ df -h | awk '{print $1 &quot;\t&quot; $3}'
Filesystem  Used
udev    0
tmpfs   3.0M
/dev/sda5   7.1G
tmpfs   116M
tmpfs   4.0K
tmpfs   0
/dev/sda3   6.0G
/dev/sda1   110M
/dev/sda7   12G
tmpfs   72K
</code></pre>

<blockquote>
<p>$ df -h | grep sda5 | awk ‘{print $5}’ | cut -d “%” -f 1<br />
 51</p>
</blockquote>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ awk 'BEGIN{print &quot;start...&quot;} {print $2 &quot;\t $5&quot;}' student.txt 
start...
name     $5
Liming   $5
sc   $5
Geek     $5
</code></pre>

<p>awk：先读入第一行数据，再执行。</p>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ awk '{FS=&quot;:&quot;} {print $1 &quot;\t&quot; $3}' /etc/passwd
root:x:0:0:root:/root:/bin/bash 
daemon  1
bin 2
</code></pre>

<p>BEGIN：读取数据之前。</p>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ awk 'BEGIN{FS=&quot;:&quot;} {print $1 &quot;\t&quot; $3}' /etc/passwd
root    0
daemon  1
bin 2
</code></pre>

<ul>
<li><blockquote>
<p>$ awk ‘BEGIN{FS=&rdquo;:&ldquo;}END{print “~~~”} {print $1 “\t” $3}’ /etc/passwd</p>
</blockquote>

<p>geek@geek-PC:~/Desktop/shell_geek$ cat student.txt | grep -v name | awk &lsquo;$6 &gt;= 87 {printf $2 &ldquo;\n&rdquo;}&rsquo;
Liming
Geek</p></li>
</ul>

<h5 id="sed">sed。</h5>

<p>sed 是一种几乎包括在所有 UNIX 平台的轻量级流编辑器。sed 主要是用来将数据进行选取、替换、删除、新增的命令。</p>

<p>（使用 vi，需要将命令结果先保存到文件，在进行修改）。</p>

<p>sed 直接使用管道符修改。</p>

<blockquote>
<p>sed [选项] ‘[动作]’ 文件名<br />
 选项。<br />
 -n。 一般 sed 命令会把所有数据都输出到屏幕。如果加入此选项，则只会把经过 sed 命令处理的行输出到屏幕。<br />
 -e。 允许对输入数据应用多条 sed 命令编辑。<br />
 -i。 用 sed 的修改结果直接修改读取数据的文件，而不是由屏幕输出。</p>
</blockquote>

<ul>
<li><p>动作。</p></li>

<li><p>a\。<br />
追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用 <code>\</code> 代表数据未完结。</p></li>

<li><p>c \。<br />
行替换，用 c 后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用 <code>\</code> 代表数据未完结。</p></li>

<li><p>i \。<br />
插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用 <code>\</code> 代表数据未完结。</p></li>

<li><p>d。<br />
删除。删除指定的行。</p></li>

<li><p>p。<br />
打印，输出指定的行。</p></li>

<li><p>s。<br />
字串替换。用一个字符串替换另外一个字符串。格式为 <code>行范围s/旧字串/新字串/g</code>（和 vim 中的替换格式类似）。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ sed &lsquo;2p&rsquo; student.txt
ID  name    PHP Linux   MySQL   average
1   Liming  82  95  86  87.66
1   Liming  82  95  86  87.66
2   sc  74  96  87  85.66
3   Geek    99  83  93  91.66</p>

<h1 id="第二行输出了-2-遍">第二行输出了 2 遍。</h1>

<p>geek@geek-PC:~/Desktop/shell_geek$ sed -n &lsquo;2p&rsquo; student.txt
1   Liming  82  95  86  87.66</p></li>

<li><p>删除第 2 到 3 行内容。但不会删除原文件内容。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ sed &lsquo;2,2d&rsquo; student.txt
ID  name    PHP Linux   MySQL   average
2   sc  74  96  87  85.66
3   Geek    99  83  93  91.66</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ sed &lsquo;2i hello \&rsquo; student.txt
ID  name    PHP Linux   MySQL   average
hello
1   Liming  82  95  86  87.66
2   sc  74  96  87  85.66
3   Geek    99  83  93  91.66
geek@geek-PC:~/Desktop/shell_geek$ sed &lsquo;2i hello <br />
&gt; world&rsquo; student.txt
ID  name    PHP Linux   MySQL   average
hello
world
1   Liming  82  95  86  87.66
2   sc  74  96  87  85.66
3   Geek    99  83  93  91.66</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ sed &lsquo;3s/74/99/g&rsquo; student.txt
ID  name    PHP Linux   MySQL   average
1   Liming  82  95  86  87.66
2   sc  99  96  87  85.66
3   Geek    99  83  93  91.66</p>

<h1 id="修改源文件">修改源文件。</h1>

<p>geek@geek-PC:~/Desktop/shell_geek$ sed -i &lsquo;3s/74/99/g&rsquo; student.txt
geek@geek-PC:~/Desktop/shell_geek$ cat student.txt
ID  name    PHP Linux   MySQL   average
1   Liming  82  95  86  87.66
2   sc  99  96  87  85.66
3   Geek    99  83  93  91.66</p></li>
</ul>

<h3 id="字符处理命令">字符处理命令。</h3>

<blockquote>
<p>sort [选项] 文件名<br />
 选项。<br />
 -f。 忽略大小写。<br />
 -n。 以数值型进行排序，默认使用字符串型排序。<br />
 -r。 反向排序。<br />
 -t。 指定分隔符，默认是分隔符是制表符。<br />
 -k n[,m]。 按照指定的字段范围排序。从第 n 字段开始，m 字段结束（默认到行尾）。</p>

<p>sort -t “:” -k 3,3 /etc/passd<br />
 指定分隔符是“：”，用第三个字段开头，第三个字段结尾排序。</p>
</blockquote>

<h3 id="条件判断">条件判断。</h3>

<table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>-b 文件</td>
<td>判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）。</td>
</tr>

<tr>
<td>-c 文件</td>
<td>判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）。</td>
</tr>

<tr>
<td>-d 文件</td>
<td>判断该文件是否存在，并且是否为目录文件（是目录为真）。</td>
</tr>

<tr>
<td>-e 文件</td>
<td>判断该文件是否存在（存在为真）。</td>
</tr>

<tr>
<td>-f 文件</td>
<td>判断该文件是否存在，并且是否为普通文件（是普通文件为真）。</td>
</tr>

<tr>
<td>-L 文件</td>
<td>判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）。</td>
</tr>

<tr>
<td>-p 文件</td>
<td>判断该文件是否存在，并且是否为管道文件（是管道文件为真）。</td>
</tr>

<tr>
<td>-s 文件</td>
<td>判断该文件是否存在，并且是否为非空（非空为真）。</td>
</tr>

<tr>
<td>-S 文件</td>
<td>判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）。</td>
</tr>
</tbody>
</table>

<pre><code>geek@geek-PC:~/Desktop/shell_geek$ test -e student.txt 
geek@geek-PC:~/Desktop/shell_geek$ echo $?
0
geek@geek-PC:~/Desktop/shell_geek$ [-e student.txtabc]
bash: [-e: command not found
geek@geek-PC:~/Desktop/shell_geek$ [ -e student.txtabc ]
geek@geek-PC:~/Desktop/shell_geek$ echo $?
1




geek@geek-PC:~/Desktop/shell_geek$ [ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;
yes
</code></pre>

<ul>
<li>按照文件权限进行判断。</li>
</ul>

<table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>-r 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）。</td>
</tr>

<tr>
<td>-w 文件</td>
<td>判断文件是否存在，并且是否该文件拥有写权限（有写权限为真）。</td>
</tr>

<tr>
<td>-x 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）。</td>
</tr>

<tr>
<td>-u 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有 SUID 权限（有 SUID 权限为真）。</td>
</tr>

<tr>
<td>-g 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SGID 权限（有 SGID 权限为真）。</td>
</tr>

<tr>
<td>-k 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SBit 权限（有 SBit 权限为真）。</td>
</tr>
</tbody>
</table>

<ul>
<li>两个文件之前的比较。</li>
</ul>

<table>
<thead>
<tr>
<th>选项</th>
<th>作用。</th>
</tr>
</thead>

<tbody>
<tr>
<td>文件1 -nt 文件2</td>
<td>判断文件1 的修改时间否比文件2 的新。（如果新之前为真）。</td>
</tr>

<tr>
<td>文件1 -ot 文件2</td>
<td>判断文件1 的修改时间是否比文件2 旧。（如果旧则为真）。</td>
</tr>

<tr>
<td>文件1 -ef 文件2</td>
<td>判断文件1 是否和文件2 的 Inode 号一致，可以理解为两个文件是否为同一个文件。（用于判断硬链接是很好的方法）。</td>
</tr>
</tbody>
</table>

<ul>
<li>两个整数之间的比较。</li>
</ul>

<table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>整数1 -eq 整数2</td>
<td>判断整数1 是否和整数2 相等（相等为真）。</td>
</tr>

<tr>
<td>整数1 -ne 整数</td>
<td>判断整数1 是否和整数2 不相等（不相等为真）。2</td>
</tr>

<tr>
<td>整数1 -gt 整数2</td>
<td>判断整数1 是否大于整数2 （大于为真）。</td>
</tr>

<tr>
<td>整数1 -lt 整数2</td>
<td>判断整数1 是否小于整数2 （小于为真）。</td>
</tr>

<tr>
<td>整数1 -ge 整数2</td>
<td>判断整数1 是否大于等于整数2 （大于等于为真）。</td>
</tr>

<tr>
<td>整数1 -le 整数2</td>
<td>判断整数1 是否小于等于整数2 （小于等于为真）。</td>
</tr>
</tbody>
</table>

<ul>
<li>字符串的比较。</li>
</ul>

<table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>-z 字符串</td>
<td>判断字符串是否为空（为空返回真）。</td>
</tr>

<tr>
<td>-n 字符串</td>
<td>判断字符串是否为非空（非空返回真）。</td>
</tr>

<tr>
<td>字串1 == 字串2</td>
<td>判断字符串1 是否和字符串2 相等（相等返回真）。</td>
</tr>

<tr>
<td>字串1 != 字串2</td>
<td>判断字符串1 是否和字符串2 不相等（不相等返回真）。</td>
</tr>
</tbody>
</table>

<blockquote>
<p>[ -z “$name” ] &amp;&amp; echo yes || echo no</p>
</blockquote>

<ul>
<li>多重条件判断。</li>
</ul>

<table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>判断1 -a 判断2</td>
<td>逻辑与。判断1 和判断2 都成立，最终的结果才为真。</td>
</tr>

<tr>
<td>判断1 -o 判断2</td>
<td>逻辑或。判断1 和判断2 有一个成立，最终的结果就为真。</td>
</tr>

<tr>
<td>! 判断。</td>
<td>逻辑非。使原始的判断式取反。</td>
</tr>
</tbody>
</table>

<h3 id="流程控制">流程控制。</h3>

<h5 id="if-语句">if 语句。</h5>

<h6 id="单分支-if-条件语句">单分支 if 条件语句。</h6>

<pre><code>if [ 条件判断式 ];then
    ...
fi

~ or

if [ 条件判断式 ]
    then
        ...
fi
</code></pre>

<ul>
<li><p>eg. 判断分区使用率。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ cat fenqu.sh
#!/bin/bash</p>

<h1 id="统计根分区使用率">统计根分区使用率。</h1>

<h1 id="author-geek">Author: Geek.</h1>

<p>rate=$(df -h | grep /dev/sda3 | awk &lsquo;{print $5}&rsquo; | cut -d &ldquo;%&rdquo; -f1)</p>

<p>echo $rate</p>

<p>if [ $rate -ge 80 ]
then
    echo &ldquo;Warning! /dev/sda3 is full,!&rdquo;
fi
geek@geek-PC:~/Desktop/shell_geek$ bash fenqu.sh
65</p></li>
</ul>

<h6 id="双分支-if-条件语句">双分支 if 条件语句。</h6>

<pre><code>if [ 条件判断式 ]
    then
        条件成立时，。。。
    else
        条件不成立时，。。。
fi
</code></pre>

<ul>
<li><p>eg. 备份 MySQL。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ vim mysql_bak.sh
geek@geek-PC:~/Desktop/shell_geek$ cat mysql_bak.sh
#!/bin/bash</p>

<h1 id="备份-mysql-数据库">备份 MySQL 数据库。</h1>

<h1 id="author-geek-1">Author: Geek</h1>

<h1 id="同步系统时间">同步系统时间。</h1>

<p>ntpdate asia.pool.ntp.org &amp;&gt; /dev/null</p>

<h1 id="把系统时间按照-年月日-的格式赋值给变量-date">把系统时间按照“年月日”的格式赋值给变量 date。</h1>

<p>date=$(date +%y%m%d)</p>

<h1 id="统计-mysql-数据库的大小-并把大小赋值给-size-变量">统计 MySQL 数据库的大小，并把大小赋值给 size 变量。</h1>

<p>size=$(du -sh /var/lib/mysql)</p>

<p>if [ -d /tmp/dbbak ]
then
    echo &ldquo;Date: $date&rdquo; &gt; /tmp/dbbak/dbinfo.txt
    echo &ldquo;data size: $size&rdquo; &gt;&gt; /tmp/dbbak/dbinfo/txt
    cd /tmp/dbbak
    tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null
    rm -rf /tmp/dbbak/dbinfo.txt
else
    mkdir /tmp/dbbak
    echo &ldquo;Date: $date&rdquo; &gt; /tmp/dbbak/dbinfo.txt
    echo &ldquo;data size: $size&rdquo; &gt;&gt; /tmp/dbbak/dbinfo/txt
    cd /tmp/dbbak
    tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null
    rm -rf /tmp/dbbak/dbinfo.txt
fi</p></li>

<li><p>判断 Apache 服务。</p>

<p>geek@geek-PC:~/Desktop/shell_geek$ cat pio.sh
#!/bin/bash</p>

<p>port=$(nmap -sT 192.168.142.161 | grep tcp | grep http | awk &lsquo;{print $2}&rsquo;)</p>

<p>if [ &ldquo;$port&rdquo; == &ldquo;open&rdquo; ]
    then
        echo &ldquo;$(date) httpd is ok!!&rdquo; &gt;&gt; /tmp/http_acc.log
    else
        /etc/rc.d/init.d/httpd restart &amp;&gt; /dev/null
        echo &ldquo;$(date) http reboot!!&rdquo; &gt;&gt; /tmp/http_err.log
fi</p></li>
</ul>

<h5 id="case-语句">case 语句。</h5>

<pre><code>case $变量名 in
    &quot;值 1&quot;)
        如果变量的值等于值 1，则执行程序 1。
        ;;
    &quot;值 2&quot;)
        如果变量的值等于值 2，则执行程序 2。
        ;;
    ... 省略其他分支。
    *)
        如果变量的值不是以上的值，则执行此程序。
        ;;
esac
</code></pre>

<h5 id="for-循环">for 循环。</h5>

<h5 id="while-循环">while 循环。</h5>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>