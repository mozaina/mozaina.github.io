<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>LinuxCommandLineandShellScriptingBible3rdPartII | 开发者问答集锦</title>
    <meta property="og:title" content="LinuxCommandLineandShellScriptingBible3rdPartII - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="LinuxCommandLineandShellScriptingBible3rdPartII">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxcommandlineandshellscriptingbible3rdpartii/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">LinuxCommandLineandShellScriptingBible3rdPartII</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>Part II Shell Scripting Basics</p>

<h1 id="toc_0">**</h1>

<hr />

<p>Chapter 11 Basic Script Building</p>

<hr />

<h2 id="section-using-multiple-commands">Section : Using Multiple Commands</h2>

<p>===================================</p>

<p>If you want to run two commands together, you can enter them on the same
prompt line, separated with a semicolon:<br />
$ date ; who</p>

<h1 id="section-creating-a-script-file">Section : Creating a Script File</h1>

<p>When creating a shell script file, you must specify the shell you are using in
the first line of the file.<br />
Here’s the format for this:</p>

<p>#!/bin/bash</p>

<p>In a normal shell script line, the pound sign (#) is used as a comment line.<br />
However, the first line of a shell script file is<br />
a special case, and the pound sign followed by the exclamation point tells the
shell what shell to run the script under.</p>

<p>After indicating the shell, commands are entered onto each line of the file,
followed by a carriage return.</p>

<p>$ ./test1<br />
$ ls -l test1<br />
$ chmod u+x test1</p>

<h2 id="section-displaying-messages">Section : Displaying Messages</h2>

<p>=================================</p>

<p>$ echo This is a test<br />
$ echo &ldquo;This is a test to see if you&rsquo;re paying attention&rdquo;<br />
$ echo &lsquo;Rich says &ldquo;scripting is easy&rdquo;.&rsquo;</p>

<p>The echo command uses either double or single quotes to delineate text
strings.<br />
If you use them within your string, you need to use one type of quote within
the text and the other type to delineate the string.</p>

<p>echo -n &ldquo;The time and date are: &ldquo;<br />
echo a text string on the same line as a command output</p>

<h2 id="section-using-variables">Section : Using Variables</h2>

<p>==============================</p>

<p>Environment variables:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p><em>echo &ldquo;User info for userid: $USER&rdquo;<br />
echo UID: $UID</em><br />
Using the envi- ronment variable’s name preceded by a dollar sign.</p>

<p>$ echo &ldquo;The cost of the item is \$15&rdquo;<br />
To display an actual dollar sign, you must precede it with a backslash
character.</p>

<p>User variables<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>1.can be any text string of up to 20 letters, digits, or an underscore
character.<br />
2.case sensitive<br />
3.No spaces can appear between the variable, the equal sign, and the value<br />
4.user variables can be referenced using the dollar sign</p>

<p>Command substitution<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
Command substitution allows you to assign the output of a shell command to a
variable.</p>

<p>two ways to assign the output of a command to a variable:</p>

<p>■ The backtick character (`)<br />
testing=&lsquo;date&rsquo;</p>

<p>■ The $() format<br />
testing=$(date)</p>

<p>#!/bin/bash</p>

<h1 id="copy-the-usr-bin-directory-listing-to-a-log-file">copy the /usr/bin directory listing to a log file</h1>

<p>today=$(date +%y%m%d)<br />
ls /usr/bin -al &gt; log.$today</p>

<p>The +%y%m%d format instructs the date command to display the date as a two-
digit year, month, and day:<br />
$ date +%y%m%d<br />
140131<br />
$</p>

<p>Command substitution creates what’s called a subshell to run the enclosed
command.<br />
Because of that, any variables you create in the script aren’t available to
the subshell command.</p>

<p>Subshells are also created if you run a command from the command prompt using
the ./ path,<br />
but they aren’t cre- ated if you just run the command without a path.</p>

<h1 id="section-redirecting-input-and-output">Section : Redirecting Input and Output</h1>

<p>Output redirection<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
sending output from a command to a file:<br />
command &gt; outputfile</p>

<p>$ date &gt; test6<br />
$ date &gt;&gt; test6</p>

<p>Input redirection<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
takes the content of a file and redi- rects it to a command:<br />
command &lt; inputfile</p>

<p>$ wc &lt; test6</p>

<p>The wc command provides a count of text in the data. By default, it produces
three values:<br />
■ The number of lines in the text<br />
■ The number of words in the text<br />
■ The number of bytes in the text</p>

<p>inline input redirection:<br />
Another method of input redirection,<br />
This method allows you to specify the data for input redirection on the
command line instead of in a file.<br />
1.must specify a text marker that delineates the beginning and end of the data<br />
2.use any string value for the text marker</p>

<p>command &lt;&lt; marker<br />
data<br />
marker</p>

<p>$ wc &lt;&lt; EOF<br />
&gt; test string 1<br />
&gt; test string 2<br />
&gt; test string 3<br />
&gt; EOF<br />
3 9 42<br />
$</p>

<h1 id="section-pipes">Section : Pipes</h1>

<p>$ rpm -qa &gt; rpm.list<br />
$ sort &lt; rpm.list</p>

<p>That was useful, but again,Instead of redirecting the output of a command to a
file,<br />
you can redirect the output to another command. This process is called piping.</p>

<p>command1 | command2<br />
The pipe is put between the commands to redirect the output from one to the
other<br />
The Linux system actually runs both commands at the same time, linking them
together internally in the system.<br />
As the first command produces output, it’s sent immediately to the second
command.<br />
No inter- mediate files or buffer areas are used to transfer the data.</p>

<p>$ rpm -qa | sort<br />
$ rpm -qa | sort | more<br />
you can use one of the text paging commands (such as less or more) to force
the output to stop at every screen of data.</p>

<p>$ rpm -qa | sort &gt; rpm.list<br />
$ more rpm.list</p>

<h1 id="section-performing-math">Section : Performing Math</h1>

<p>There are two different ways to perform mathematical operations in your shell
scripts.</p>

<p>The expr command:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
The expr command recognizes a few different mathematical and string operators</p>

<p>$ expr 5 * 2<br />
expr: syntax error<br />
$</p>

<p>$ expr 5 \* 2<br />
10<br />
$<br />
To solve this problem, you need to use the shell escape character (the
backslash) to identify any characters that may be misinterpreted by the shell
before being passed to the expr command.</p>

<p>Using brackets:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;<br />
Using brackets makes shell math much easier than with the expr command.</p>

<p>In bash, when assigning a mathematical value to a variable,<br />
you can enclose the mathematical equa- tion<br />
using a dollar sign and square brackets ($[ operation ])。</p>

<p>#!/bin/bash<br />
var1=100<br />
var2=50<br />
var3=45<br />
var4=$[$var1 * ($var2 - $var3)]<br />
echo The final result is $var4</p>

<p>A floating-point solution:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
uses the built-in bash calculator, called bc.</p>

<p>You can access the bash calculator from the shell prompt using the bc command:<br />
$ bc</p>

<p>To exit the bash calculator, you must enter quit.<br />
The floating-point arithmetic is controlled by a built-in variable called
scale.</p>

<p>$ bc -q<br />
var1=10<br />
var1 * 4 40<br />
var2 = var1 / 5<br />
print var2<br />
2<br />
quit<br />
$</p>

<p>Yes, you can use the command substitution character to run a bc command and
assign the output to a vari- able!<br />
The basic format to use is this:</p>

<p>variable=$(echo &ldquo;options; expression&rdquo; | bc)</p>

<p>options, allows you to set variables.more than one variable, separate them
using the semicolon.</p>

<p>The bc command recognizes input redirection, allowing you to redirect a file
to the bc command for processing.</p>

<p>The best method is to use inline input redirection, which allows you to
redirect data directly from the command line.<br />
In the shell script, you assign the output to a variable:</p>

<p>variable=$(bc &lt;&lt; EOF<br />
options<br />
statements<br />
expressions<br />
EOF<br />
)</p>

<p>The EOF text string indicates the beginning and end of the inline redirection
data.</p>

<p>$ cat test12<br />
#!/bin/bash<br />
var1=10.46<br />
var2=43.67<br />
var3=33.2<br />
var4=71<br />
var5=$(bc &lt;&lt; EOF<br />
scale = 4<br />
a1 = ( $var1 * $var2)<br />
b1 = ($var3 * $var4)<br />
a1 + b1<br />
EOF<br />
)<br />
echo The final answer for this mess is $var5<br />
$</p>

<h2 id="section-exiting-the-script">Section : Exiting the Script</h2>

<p>================================</p>

<p>Every command that runs in the shell uses an exit status to indicate to the
shell that it’s finished processing.</p>

<p>Checking the exit status:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
Linux provides the $? special variable that holds the exit status value from
the last com- mand that executed.<br />
You must view or use the $? variable immediately after the command you want to
check.</p>

<p>$ echo $?</p>

<p>The exit command:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<hr />

<h1 id="chapter-12-using-structured-commands">Chapter 12 Using Structured Commands</h1>

<hr />

<h2 id="section-working-with-the-if-then-statement">Section : Working with the if-then Statement</h2>

<p>===================================<br />
if command<br />
then<br />
commands<br />
fi</p>

<p>if command ; then<br />
commands<br />
fi</p>

<p>The bash shell if statement runs the command defined on the if line.<br />
If the exit status of the command (see Chapter 11) is zero (the command
completed successfully),<br />
the commands listed under the then section are executed.<br />
If the exit status of the command is anything else,<br />
the then commands aren’t executed,<br />
and the bash shell moves on to the next com- mand in the script.</p>

<p>$ cat test3.sh<br />
#!/bin/bash</p>

<h1 id="testing-multiple-commands-in-the-then-section">testing multiple commands in the then section #</h1>

<p>testuser=Christine</p>

<p>if grep $testuser /etc/passwd<br />
then<br />
echo &ldquo;This is my first command&rdquo;<br />
echo &ldquo;This is my second command&rdquo;<br />
echo &ldquo;I can even put in other commands besides echo:&rdquo;<br />
ls -a /home/$testuser/.b*<br />
fi<br />
$</p>

<h2 id="section-exploring-the-if-then-else-statement">Section : Exploring the if-then-else Statement</h2>

<p>=================================================<br />
if command ; then<br />
commands #When the command in the if statement line returns with a zero exit
status code<br />
else<br />
commands<br />
fi</p>

<h2 id="section-nesting-ifs">Section : Nesting ifs</h2>

<p>========================<br />
if command1 ; then<br />
commands<br />
elif command2 ; then<br />
more commands<br />
fi</p>

<h2 id="section-trying-the-test-command">Section: Trying the test Command</h2>

<p>==================================<br />
test condition</p>

<p>The test command provides a way to test different conditions in an if-then
statement.<br />
If the condition listed in the test command evaluates to TRUE, the test
command exits with a zero exit status code.<br />
If the condition is FALSE, the test command exits with a non-zero exit status
code</p>

<p>The bash shell provides an alternative way of testing a condition without
declaring the test command in an if-then statement:<br />
The square brackets define the test condition.<br />
Be careful; you must have a space after the first bracket and a space before
the last bracket, or you’ll get an error message.</p>

<p>if [space condition space]<br />
then<br />
commands<br />
fi</p>

<p>The test command and test conditions can evaluate three classes of conditions:<br />
■ Numeric comparisons<br />
if [ $value1 -gt 5 ]<br />
&hellip;&hellip;</p>

<p>■ String comparisons<br />
The test String Comparisons:<br />
str1 = str2 Checks if str1 is the same as string str2<br />
str1 != str2 Checks if str1 is not the same as str2<br />
str1 &lt; str2 Checks if str1 is less than str2<br />
-n str1 Checks if str1 has a length greater than zero<br />
-z str1 Checks if str1 has a length of zero</p>

<p>if [ $USER = $testuser ]<br />
&hellip;..</p>

<p>if [ $val1 &gt; $val2 ]<br />
&hellip;..</p>

<p>Test comparisons use standard ASCII ordering, using each character’s ASCII
numeric value to determine the sort order.<br />
The sort command uses the sorting order defined for the system locale language
settings.<br />
For the English language, the locale settings specify that lowercase letters
appear before uppercase letters in sorted order.</p>

<p>The -n and -z comparisons are handy when trying to evaluate whether a variable
contains data:</p>

<p>if [ -n $val1 ]<br />
&hellip;&hellip;</p>

<p>■ File comparisons<br />
The test File Comparisons:</p>

<p>-d file ,Checks if file exists and is a directory<br />
-e file, Checksiffileexists<br />
-f file ,Checks if file exists and is a file<br />
-r file,Checks if file exists and is readable<br />
-s file,<br />
-w file,<br />
-x file,<br />
-O file,<br />
-G file,<br />
file1 -nt file2,Checks if file1 is newer than file2<br />
file1 -ot file2,</p>

<p>if [ -d $jump_directory ]<br />
&hellip;&hellip;</p>

<h2 id="section-considering-compound-testing">Section : Considering Compound Testing</h2>

<p>========================================<br />
■ [ condition1 ] &amp;&amp; [ condition2 ]</p>

<p>if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ]<br />
&hellip;&hellip;</p>

<p>■ [ condition1 ] || [ condition2 ]</p>

<h2 id="section-working-with-advanced-if-then-features">Section: Working with Advanced if-then Features</h2>

<p>================================================</p>

<p>Using double parentheses:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
The double parentheses command allows you to incorporate advanced mathematical
formulas in your comparisons.</p>

<p>(( expression ))</p>

<p>The test command allows for only simple arithmetic operations ;<br />
The double parentheses command provides more mathematical symbols;</p>

<p>Using double brackets:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
The double bracket command provides advanced features for string comparisons:<br />
[[ expression ]]</p>

<p>if [[ $USER == r* ]] #define a regular expression<br />
&hellip;&hellip;</p>

<h2 id="section-considering-the-case-command">Section : Considering the case Command</h2>

<p>=========================================<br />
The case command checks multiple values of a single variable in a list-
oriented format:</p>

<p>case variable in<br />
pattern1 | pattern2) commands1;;<br />
pattern3) commands2;;<br />
*) default commands;;<br />
esac</p>

<p>case $USER in<br />
rich | barbara)<br />
echo &ldquo;Welcome, $USER&rdquo;<br />
echo &ldquo;Please enjoy your visit&rdquo;;;</p>

<p>testing)<br />
echo &ldquo;Special testing account&rdquo;;;</p>

<p>jessica)<br />
echo &ldquo;Do not forget to log off when you&rsquo;re done&rdquo;;;</p>

<p>*)<br />
echo &ldquo;Sorry, you are not allowed here&rdquo;;;</p>

<p>esac</p>

<h2 id="toc_19">**************************************</h2>

<h1 id="chapter-13-more-structured-commands">Chapter 13 More Structured Commands</h1>

<hr />

<h3 id="section-the-for-command">Section : The for Command</h3>

<p>===================================<br />
Here’s the basic format of the bash shell for command:<br />
The first iteration uses the first item in the list,</p>

<p>for var in list<br />
do<br />
commands<br />
done</p>

<p>Reading values in a list<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
for test in Alabama Alaska Arizona Arkansas California Colorado<br />
do<br />
echo The next state is $test<br />
done</p>

<p>Reading complex values in a list<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
■ Use the escape character (the backslash) to escape the single quotation
mark.<br />
■ Use double quotation marks to define the values that use single quotation
marks.</p>

<p>for test in I don\&rsquo;t know if &ldquo;this&rsquo;ll&rdquo; work<br />
do<br />
echo &ldquo;word:$test&rdquo;<br />
done</p>

<p>for test in Nevada &ldquo;New Hampshire&rdquo; &ldquo;New Mexico&rdquo; &ldquo;New York&rdquo;<br />
do<br />
echo &ldquo;Now going to $test&rdquo;<br />
done</p>

<p>Reading a list from a variable<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
#!/bin/bash</p>

<h1 id="using-a-variable-to-hold-the-list">using a variable to hold the list</h1>

<p>list=&ldquo;Alabama Alaska Arizona Arkansas Colorado&rdquo;<br />
list=$list&rdquo; Connecticut&rdquo;</p>

<p>for state in $list<br />
do<br />
echo &ldquo;Have you ever visited $state?&rdquo;<br />
done</p>

<p>Reading values from a command<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
Notice that the states file includes each state on a separate line,<br />
The for command still iterates through the output of the cat command one line
at a time,<br />
the for command still takes each word as a separate value.</p>

<p>#!/bin/bash</p>

<h1 id="reading-values-from-a-file">reading values from a file</h1>

<p>file=&ldquo;states&rdquo;<br />
for state in $(cat $file)<br />
do<br />
echo &ldquo;Visit beautiful $state&rdquo;<br />
done</p>

<p>Changing the field separator<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
the special environment variable IFS, called the internal field separator.<br />
The IFS environment variable defines a list of characters the bash shell uses
as field separators.<br />
By default, the bash shell considers the following characters as field
separators:<br />
■ A space<br />
■ A tab<br />
■ A newline</p>

<p>To solve this problem, you can temporarily change the IFS environment variable
values in your shell script to restrict the characters the bash shell
recognizes as field separators.</p>

<p>IFS=$&rsquo;\n&rsquo;</p>

<p>This technique can be coded like this:<br />
IFS.OLD=$IFS<br />
IFS=$&rsquo;\n&rsquo;</p>

<p>IFS=$IFS.OLD</p>

<p>Suppose you want to iterate through values in a file that are separated by a
colon (such as in the /etc/ passwd file):<br />
IFS=:</p>

<p>If you want to specify more than one IFS character:<br />
This assignment uses the newline, colon, semicolon, and double quotation mark
characters as field separators.<br />
IFS=$&rsquo;\n&rsquo;:;&rdquo;</p>

<p>Reading a directory using wildcards<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
it’s perfectly legal to have directory and filenames that contain spaces.<br />
To accom- modate that, you should enclose the $file variable in double
quotation marks.</p>

<p>#!/bin/bash</p>

<h1 id="iterate-through-all-the-files-in-a-directory">iterate through all the files in a directory</h1>

<p>for file in ~/*<br />
#for file in /home/rich/.b* /home/rich/badtest<br />
do<br />
if [ -d &ldquo;$file&rdquo; ]<br />
then<br />
echo &ldquo;$file is dir&rdquo;<br />
elif [ -f &ldquo;$file&rdquo; ]<br />
then<br />
echo &ldquo;$file is file&rdquo;<br />
fi<br />
done</p>

<h3 id="section-the-c-style-for-command">Section : The C-Style for Command</h3>

<p>====================================<br />
shows you how to use a C-style for command in a bash shell script.</p>

<p>Here’s the basic format of the C-style bash for loop:</p>

<p>for (( variable assignment ; condition ; iteration process ))</p>

<p>#!/bin/bash</p>

<h1 id="testing-the-c-style-for-loop">testing the C-style for loop</h1>

<p>for (( i=1; i &lt;= 10; i++ ))<br />
do<br />
echo &ldquo;The next number is $i&rdquo;<br />
done</p>

<p>#!/bin/bash</p>

<h1 id="multiple-variables">multiple variables</h1>

<p>for (( a=1, b=10; a &lt;= 10; a++, b&ndash; ))<br />
do<br />
echo &ldquo;$a - $b&rdquo;<br />
done</p>

<h3 id="section-the-while-command">Section : The while Command</h3>

<p>================================</p>

<p>Basic while format:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
Here’s fhe format of the while command:</p>

<p>while test command<br />
do<br />
other commands<br />
done</p>

<p>var1=10<br />
while [ $var1 -gt 0 ]<br />
do<br />
echo $var1<br />
var1=$[ $var1 - 1 ]<br />
done</p>

<p>Using multiple test commands:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
The while command allows you to define multiple test commands on the while
statement,<br />
Only the exit status of the last test command is used to determine when the
loop stops.</p>

<p>#!/bin/bash</p>

<h1 id="testing-a-multicommand-while-loop">testing a multicommand while loop</h1>

<p>var1=10<br />
while echo $var1<br />
[ $var1 -ge 0 ]<br />
do<br />
echo &ldquo;This is inside<br />
var1=$[ $var1 - 1 ]<br />
done</p>

<h3 id="section-the-until-command">Section : The until Command</h3>

<p>===============================<br />
As long as the exit status of the test command is non-zero, the bash shell
executes the commands listed in the loop.<br />
When the test command returns a zero exit sta- tus, the loop stops.<br />
As you would expect, the format of the until command is:</p>

<p>you can have more than one test command in the until command statement.<br />
Only the exit status of the last command determines if the bash shell executes
the other commands defined.</p>

<p>until test commands<br />
do<br />
other commands<br />
done</p>

<p>#!/bin/bash</p>

<h1 id="using-the-until-command">using the until command</h1>

<p>var1=100<br />
until [ $var1 -eq 0 ]<br />
do<br />
echo $var1<br />
var1=$[ $var1 - 25 ]<br />
done</p>

<h3 id="section-nesting-loops">Section : Nesting Loops</h3>

<p>==========================</p>

<h3 id="section-looping-on-file-data">Section : Looping on File Data</h3>

<p>===============================<br />
This requires combining two of the techniques covered:<br />
■ Using nested loops<br />
■ Changing the IFS environment variable</p>

<h3 id="section-controlling-the-loop">Section : Controlling the Loop</h3>

<p>==================================<br />
■ The break command<br />
■ The continue command</p>

<p>Breaking out of an inner loop<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
the break command automatically terminates the innermost loop you’re in</p>

<p>Breaking out of an outer loop<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>break n<br />
where n indicates the level of the loop to break out of.<br />
By default, n is 1, indicating to break out of the current loop.</p>

<p>continue n<br />
where n defines the loop level to continue</p>

<h3 id="section-processing-the-output-of-a-loop">Section : Processing the Output of a Loop</h3>

<p>===============================================<br />
you can either pipe or redirect the output of a loop within your shell script.<br />
You do this by adding the processing command to the end of the done command:</p>

<p>for file in /home/rich/*<br />
do<br />
&hellip;<br />
done &gt; output.txt</p>

<p>for state in &ldquo;North Dakota&rdquo; Connecticut Illinois Alabama Tennessee<br />
do<br />
echo &ldquo;$state is the next place to go&rdquo;<br />
done | sor</p>

<h3 id="section-example">Section : example</h3>

<p>====================</p>

<p>Creating multiple user accounts<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>#!/bin/bash</p>

<h1 id="process-new-user-accounts">process new user accounts</h1>

<p>input=&ldquo;users.csv&rdquo;<br />
while IFS=&lsquo;,&rsquo; read -r userid name<br />
do<br />
echo &ldquo;adding $userid&rdquo;<br />
useradd -c &ldquo;$name&rdquo; -m $userid<br />
done &lt; &ldquo;$input&rdquo;<br />
$</p>

<hr />

<h1 id="chapter-14-handling-user-input">Chapter 14 Handling User Input</h1>

<hr />

<h2 id="section-passing-parameters">Section : Passing Parameters</h2>

<p>===================================<br />
Reading parameters:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>The bash shell assigns special variables, called positional parameters, to all
of the command line parameters entered.<br />
The positional parameter variables are standard numbers,<br />
with $0 being the script’s name,<br />
$1 being the first parameter,<br />
$2 being the second parameter, and so on, up to $9 for the ninth parameter.</p>

<p>$ cat test2.sh<br />
#!/bin/bash</p>

<h1 id="testing-two-command-line-parameters">testing two command line parameters #</h1>

<p>total=$[ $1 * $2 ]<br />
echo The first parameter is $1.<br />
echo The second parameter is $2.<br />
echo The total value is $total.<br />
$</p>

<p>After the ninth variable, you must use braces around the variable number, such
as ${10}.</p>

<p>$ cat test4.sh<br />
#!/bin/bash</p>

<h1 id="handling-lots-of-parameters">handling lots of parameters</h1>

<p>total=$[ ${10} * ${11} ]</p>

<p>Reading the script name:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>The basename command returns just the script’s name without the path:</p>

<h1 id="using-basename-with-the-0-parameter">Using basename with the $0 parameter #</h1>

<p>name=$(basename $0)<br />
echo<br />
echo The script name is: $name</p>

<p>#!/bin/bash</p>

<h1 id="testing-a-multi-function-script">Testing a Multi-function script #</h1>

<p>name=$(basename $0)</p>

<p>if [ $name = &ldquo;addem&rdquo; ]<br />
then<br />
total=$[ $1 + $2 ] #<br />
elif [ $name = &ldquo;multem&rdquo; ]<br />
then<br />
total=$[ $1 * $2<br />
fi</p>

<p>$ cp<br />
$ chmod u+x addem $<br />
$ ln -s test6.sh multem $<br />
$ ls -l *em</p>

<p>Testing parameters;<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
$ cat test7.sh<br />
#!/bin/bash</p>

<h1 id="testing-parameters-before-use">testing parameters before use #</h1>

<p>if [ -n &ldquo;$1&rdquo; ]<br />
then<br />
echo Hello $1, glad to meet you.<br />
else<br />
echo &ldquo;Sorry, you did not identify yourself. &rdquo;<br />
fi<br />
$</p>

<h3 id="section-using-special-parameter-variables">Section : Using Special Parameter Variables</h3>

<p>=============================================</p>

<p>Counting parameters<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
The special $# variable contains the number of command line parameters
included when the script was run<br />
#!/bin/bash</p>

<h1 id="getting-the-number-of-parameters">getting the number of parameters</h1>

<p>echo There were $# parameters supplied.<br />
$</p>

<p>#!/bin/bash</p>

<h1 id="testing-parameters">Testing parameters #</h1>

<p>if [ $# -ne 2 ]<br />
&hellip;..</p>

<p>$ cat test10.sh<br />
#!/bin/bash</p>

<h1 id="grabbing-the-last-parameter">Grabbing the last parameter</h1>

<p>params=$#<br />
echo</p>

<p>echo The last parameter is ${!#} //Not ${$#}<br />
echo</p>

<p>Grabbing all the data<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
The $* variable takes all the parameters supplied on the command line as a
single word.<br />
the $* variable treats them all as one parameter.</p>

<p>The $@ variable, on the other hand, takes all the parameters supplied on the
command line as separate words in the same string.<br />
It allows you to iterate through the values, separating out each parameter
supplied.<br />
This is most often accomplished using the for command.</p>

<p>#!/bin/bash</p>

<h1 id="testing-and">testing $* and $@ #</h1>

<p>echo<br />
count=1</p>

<p>for param in &ldquo;$<em>&rdquo;<br />
do<br />
echo &ldquo;\$</em> Parameter #$count = $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>echo<br />
count=1</p>

<p>for param in &ldquo;$@&rdquo;<br />
do<br />
echo &ldquo;\$@ Parameter #$count = $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>Section : Being Shifty</p>

<p>=========================<br />
When you use the shift command, it moves each parameter variable one position
to the left by default.</p>

<p>#!/bin/bash</p>

<h1 id="demonstrating-the-shift-command">demonstrating the shift command</h1>

<p>echo<br />
count=1<br />
while [ -n &ldquo;$1&rdquo; ]<br />
do<br />
echo &ldquo;Parameter #$count = $1&rdquo;<br />
count=$[ $count + 1 ]<br />
shift<br />
done</p>

<p>$ cat test14.sh<br />
#!/bin/bash</p>

<h1 id="demonstrating-a-multi-position-shift">demonstrating a multi-position shift</h1>

<p>echo<br />
echo &ldquo;The original parameters: $*&rdquo;<br />
shift 2<br />
echo &ldquo;Here&rsquo;s the new first parameter: $1&rdquo;<br />
$<br />
$ ./test14.sh 1 2 3 4 5<br />
The original parameters: 1 2 3 4 5<br />
Here&rsquo;s the new first parameter: 3<br />
$</p>

<p>$</p>

<h3 id="section-working-with-options">Section : Working with Options</h3>

<p>================================</p>

<p>Finding your options:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
Processing simple options</p>

<p>#!/bin/bash</p>

<h1 id="extracting-command-line-options-as-parameters">extracting command line options as parameters #</h1>

<p>echo<br />
while [ -n &ldquo;$1&rdquo; ]<br />
do<br />
case &ldquo;$1&rdquo; in<br />
-a) echo &ldquo;Found the -a option&rdquo; ;;<br />
-b) echo &ldquo;Found the -b option&rdquo; ;;<br />
-c) echo &ldquo;Found the -c option&rdquo; ;;<br />
*) echo &ldquo;$1 is not an option&rdquo; ;;<br />
esac<br />
shift<br />
done</p>

<p>$<br />
$ ./test15.sh -a -b -c -d</p>

<p>Using the getopt command<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>getopt optstring parameters</p>

<p>$ getopt ab:cd -a -b test1 -cd test2 test3 -a -b test1 -c -d &ndash; test2 test3<br />
$</p>

<p>Using getopt in your scripts<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
One of the set command options is the double dash (&ndash;).<br />
The double dash instructs set to replace the command line parameter variables
with the values on the set command’s com- mand line.</p>

<p>set &ndash; $(getopt -q ab:cd &ldquo;$@&rdquo;)</p>

<p>#!/bin/bash</p>

<h1 id="extract-command-line-options-values-with-getopt">Extract command line options &amp; values with getopt #</h1>

<p>set &ndash; $(getopt -q ab:cd &ldquo;$@&rdquo;)<br />
&hellip;&hellip;</p>

<p>Advancing to getopts<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>getopts optstring variable</p>

<p>To suppress error messages, start the optstring with a colon.<br />
The OPTARG environment variable contains the value to be used if an option
requires a parameter value.<br />
The OPTIND environ- ment variable contains the value of the current location
within the parameter list where getopts left off.</p>

<h1 id="section-standardizing-options">Section : Standardizing Options</h1>

<h3 id="section-getting-user-input">Section : Getting User Input</h3>

<p>==================================</p>

<p>Reading basics<br />
-&mdash;&mdash;&mdash;&mdash;&ndash;<br />
the read command places the data into a variable.</p>

<p>The read command assigns all data entered at the prompt to a single variable,<br />
or you can specify multiple vari- ables.<br />
You can also specify no variables on the read command line.<br />
If you do that, the read com- mand places any data it receives in the special
environment variable REPLY:</p>

<p>#!/bin/bash</p>

<h1 id="testing-the-read-command">testing the read command</h1>

<p>echo -n &ldquo;Enter your name: &ldquo;<br />
read name<br />
echo &ldquo;Hello $name, welcome to my program. &ldquo;</p>

<p>#!/bin/bash</p>

<h1 id="testing-the-read-p-option">testing the read -p option</h1>

<p>read -p &ldquo;Please enter your age: &ldquo; age<br />
days=$[ $age * 365 ]<br />
echo &ldquo;That makes you over $days days old! &ldquo;</p>

<p>Timing out<br />
-&mdash;&mdash;&mdash;&ndash;<br />
The -t option specifies the number of seconds for the read command to wait for
input.<br />
When the timer expires, the read command returns a non-zero exit status</p>

<p>if read -t 5 -p &ldquo;Please enter your name: &ldquo; name<br />
&hellip;&hellip;</p>

<p>set the read command to count the input charac- ters.<br />
When a preset number of characters has been entered, it automatically exits,
assigning the entered data to the variable</p>

<p>#!/bin/bash</p>

<h1 id="getting-just-one-character-of-input">getting just one character of input</h1>

<p>read -n1 -p &ldquo;Do you want to continue [Y/N]? &ldquo; answer<br />
case $answer in<br />
Y | y)<br />
echo<br />
echo &ldquo;fine, continue on&hellip;&rdquo;;;<br />
N | n)<br />
echo<br />
echo OK, goodbye<br />
exit;;<br />
esac<br />
echo &ldquo;This is the end of the script&rdquo;<br />
$</p>

<p>Reading with no display<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
The -s option prevents the data entered in the read command from being
displayed on the monitor;</p>

<p>Reading from a file<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
Each call to the read command reads a single line of text from the file.<br />
When no more lines are left in the file, the read command exits with a non-
zero exit status<br />
The most common method is to pipe the result of the cat command of the file
directly to a while command that contains the read command.<br />
#!/bin/bash<br />
cat test | while read line<br />
do<br />
echo &ldquo;Line $count: $line&rdquo;<br />
count=$[ $count + 1]<br />
done</p>

<hr />

<h1 id="chapter-15-presenting-data">Chapter 15 Presenting Data</h1>

<hr />

<h2 id="section-understanding-input-and-output">Section : Understanding Input and Output</h2>

<p>===================================</p>

<p>the cat command with data entered from STDIN:<br />
$ cat</p>

<p>the cat command to accept input from another file<br />
$ cat &lt; testfile</p>

<p>Redirecting errors only:<br />
$ ls -al badfile 2&gt; test4</p>

<p>Redirecting errors and data:<br />
$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</p>

<p>You can use this technique to separate normal script output from any error
messages that occur in the script.</p>

<p>the &amp;&gt; symbol:<br />
redirect both STDERR and STDOUT output to the same output file.</p>

<p>$ ls -al test test2 test3 badtest &amp;&gt; test7</p>

<h2 id="section-redirecting-output-in-scripts">Section : Redirecting Output in Scripts</h2>

<p>=======================================<br />
There are two methods for redirecting output in the script:</p>

<p>■ Temporarily redirecting each line<br />
you can redirect an indi- vidual output line to STDERR.<br />
You just need to use the output redirection symbol to redi- rect the output to
the STDERR file descriptor.<br />
When you redirect to a file descriptor, you must precede the file descriptor
number with an ampersand (&amp;):</p>

<p>$ echo &ldquo;This is an error message&rdquo; &gt;&amp;2</p>

<p>$ ./test8 2&gt; test9</p>

<p>■ Permanently redirecting all commands in the script</p>

<p>you can tell the shell to redirect a specific file descriptor for the duration
of the script by using the exec command:</p>

<p>#!/bin/bash</p>

<h1 id="redirecting-all-output-to-a-file">redirecting all output to a file</h1>

<p>exec 1&gt;testout</p>

<p>echo &ldquo;This is a test of redirecting all output&rdquo;<br />
echo &ldquo;from a script to another file.&rdquo;<br />
echo &ldquo;without having to redirect every individual line&rdquo;</p>

<p>#!/bin/bash</p>

<h1 id="redirecting-output-to-different-locations">redirecting output to different locations</h1>

<p>exec 2&gt;testerror</p>

<p>echo &ldquo;This is the start of the script&rdquo;<br />
echo &ldquo;now redirecting all output to another location&rdquo;</p>

<p>exec 1&gt;testout</p>

<p>echo &ldquo;This output should go to the testout file&rdquo;</p>

<h2 id="section-redirecting-input-in-scripts">Section : Redirecting Input in Scripts</h2>

<p>=========================================<br />
$ cat test12<br />
#!/bin/bash</p>

<h1 id="redirecting-file-input">redirecting file input</h1>

<p>exec 0&lt; testfile</p>

<p>count=1<br />
while read line<br />
do<br />
echo &ldquo;Line #$count: $line&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<h2 id="section-creating-your-own-redirection">Section : Creating Your Own Redirection</h2>

<p>==========================================</p>

<p>Creating output file descriptors<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
#!/bin/bash</p>

<h1 id="using-an-alternative-file-descriptor">using an alternative file descriptor</h1>

<p>exec 3&gt;test13out<br />
echo &ldquo;This should display on the monitor&rdquo;<br />
echo &ldquo;and this should be stored in the file&rdquo; &gt;&amp;3</p>

<p>Redirecting file descriptors<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
#!/bin/bash</p>

<h1 id="storing-stdout-then-coming-back-to-it">storing STDOUT, then coming back to it</h1>

<p>exec 3&gt;&amp;1<br />
exec 1&gt;test14out</p>

<p>echo &ldquo;This should store in the output file&rdquo; echo &ldquo;along with this line.&rdquo;</p>

<p>exec 1&gt;&amp;3</p>

<p>echo &ldquo;Now things should be back to normal&rdquo;<br />
$</p>

<p>Creating input file descriptors:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
#!/bin/bash</p>

<h1 id="redirecting-input-file-descriptors">redirecting input file descriptors</h1>

<p>exec 6</p>

<p>exec 0&lt; testfile</p>

<p>count=1<br />
while read line do<br />
echo &ldquo;Line #$count: $line&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>exec 0</p>

<p>read -p &ldquo;Are you done now? &rdquo; answer</p>

<p>Creating a read/write file descriptor<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
#!/bin/bash</p>

<h1 id="testing-input-output-file-descriptor">testing input/output file descriptor</h1>

<p>exec 3&lt;&gt; testfile</p>

<p>read line echo &ldquo;Read: $line&rdquo;<br />
echo &ldquo;This is a test line&rdquo; &gt;&amp;3<br />
$</p>

<p>Closing file descriptors<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
the shell automatically closes them when the script exits.<br />
or To close a file descriptor, redirect it to the special symbol &amp;-.<br />
exec 3&gt;&amp;-</p>

<p>#!/bin/bash</p>

<h1 id="testing-closing-file-descriptors">testing closing file descriptors</h1>

<p>exec 3&gt; test17file<br />
echo &ldquo;This is a test line of data&rdquo; &gt;&amp;3<br />
exec 3&gt;&amp;-<br />
echo &ldquo;This won&rsquo;t work&rdquo; &gt;&amp;3<br />
$</p>

<h2 id="section-listing-open-file-descriptors">Section : Listing Open File Descriptors</h2>

<p>=========================================<br />
The lsof command lists all the open file descriptors on the entire Linux
system.</p>

<p>$ /usr/sbin/lsof -a -p $$ -d 0,1,2<br />
-p, which allows you to specify a process ID (PID)<br />
-d, which allows you to specify the file descriptor numbers to display<br />
the special environment variable $$, which the shell sets to the current PID<br />
The -a option is used to perform a Boolean AND of the results of the other two
options,</p>

<h1 id="section-suppressing-command-output">Section : Suppressing Command Output</h1>

<p>you can redirect STDERR to a special file called the null file.<br />
Any data that the shell outputs to the null file is not saved, thus the data
are lost.</p>

<p>$ ls -al &gt; /dev/null<br />
$ cat /dev/null<br />
$</p>

<p>it is often used by programmers to quickly remove data from an existing file
without having to remove the file and re-create it:<br />
$ cat /dev/null &gt; testfile<br />
$ cat testfile $</p>

<h2 id="section-using-temporary-files">Section : Using Temporary Files</h2>

<p>=================================<br />
Linux uses the /tmp directory for files that don’t need to be kept
indefinitely.<br />
automatically remove any files in the /tmp directory at bootup.</p>

<p>The mktemp command allows you to easily create a unique temporary file in the
/tmp folder.</p>

<p>Creating a local temporary file<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
To create a temporary file in a local directory with the mktemp command, you
just need to specify a filename template.<br />
The template consists of any text filename, plus six X’s appended to the end
of the filename:</p>

<p>$ mktemp testing.XXXXXX<br />
$ ls -al testing*<br />
-rw&mdash;&mdash;- 1 rich rich 0 Oct 17 21:30 testing.UfIi13<br />
$</p>

<p>save that filename in a vari- able, so you can refer to it later on in the
script:</p>

<p>#!/bin/bash</p>

<h1 id="creating-and-using-a-temp-file">creating and using a temp file</h1>

<p>tempfile=$(mktemp test19.XXXXXX)<br />
exec 3&gt;$tempfile<br />
echo &ldquo;This script writes to temp file $tempfile&rdquo;<br />
echo &ldquo;This is the first line&rdquo; &gt;&amp;3</p>

<p>Creating a temporary file in /tmp<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
The -t option forces mktemp to create the file in the temporary directory of
the system.</p>

<p>$ mktemp -t test.XXXXXX</p>

<p>#!/bin/bash</p>

<h1 id="creating-a-temp-file-in-tmp">creating a temp file in /tmp</h1>

<p>tempfile=$(mktemp -t tmp.XXXXXX)<br />
echo &ldquo;This is a test file.&rdquo; &gt; $tempfile<br />
echo &ldquo;This is the second line of the test.&rdquo; &gt;&gt; $tempfile</p>

<p>Creating a temporary directory<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
The -d option tells the mktemp command to create a temporary directory instead
of a file.</p>

<p>#!/bin/bash</p>

<h1 id="using-a-temporary-directory">using a temporary directory</h1>

<p>tempdir=$(mktemp -d dir.XXXXXX)<br />
cd $tempdir</p>

<p>tempfile1=$(mktemp temp.XXXXXX)</p>

<h2 id="section-logging-messages">Section : Logging Messages</h2>

<p>==========================<br />
The tee command is a handy way to send output both to the standard output and
to a log file.</p>

<p>tee filename</p>

<p>Because tee redirects data from STDIN, you can use it with the pipe command to
redirect output from any command:</p>

<p>$ date | tee testfile<br />
$ date | tee -a testfile [append data to the file,]</p>

<h2 id="section-example-1">Section : Example</h2>

<p>=====================<br />
#!/bin/bash</p>

<h1 id="read-file-and-create-insert-statements-for-mysql">read file and create INSERT statements for MySQL</h1>

<p>outfile=&lsquo;members.sql&rsquo;<br />
IFS=&lsquo;,&rsquo;<br />
while read lname fname address city state zip<br />
do<br />
cat &gt;&gt; $outfile &lt;&lt; EOF<br />
INSERT INTO members (lname,fname,address,city,state,zip) VALUES (&lsquo;$lname&rsquo;,
&lsquo;$fname&rsquo;, &lsquo;$address&rsquo;, &lsquo;$city&rsquo;, &lsquo;$state&rsquo;, &lsquo;$zip&rsquo;);<br />
EOF<br />
done &lt; ${1}<br />
$</p>

<p>The output redirection appends the cat command output to the file .<br />
The input to the cat command is redirected from the standard input to use the
data stored inside the script.</p>

<hr />

<h1 id="chapter-16-script-control">Chapter 16 Script Control</h1>

<hr />

<h2 id="section-handling-signals">Section : Handling Signals</h2>

<p>===================================<br />
The Ctrl+C key combination sends a SIGINT signal,<br />
which simply stops the current process running in the shell.<br />
The Ctrl+Z key combination generates a SIGTSTP signal,<br />
stopping any processes running in the shell.</p>

<p>view the stopped jobs using the ps command:<br />
$ ps -l</p>

<p>1.If you really want to exit the shell with a stopped job still active, just
type the exit com- mand again.<br />
The shell exits, terminating the stopped job.<br />
2.Alternately, now that you know the PID of the stopped job, you can use the
kill command to send a SIGKILL signal to terminate it:<br />
$ kill -9 2456</p>

<p>Trapping signals<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
The trap command allows you to specify which Linux signals your shell script
can watch for and intercept from the shell.</p>

<p>trap commands signals</p>

<p>#!/bin/bash</p>

<h1 id="testing-signal-trapping">Testing signal trapping</h1>

<p>trap &ldquo;echo &lsquo; Sorry! I have trapped Ctrl-C&rsquo;&rdquo; SIGINT</p>

<p>echo This is a test script</p>

<p>count=1<br />
while [ $count -le 10 ] do<br />
echo &ldquo;Loop #$count&rdquo; sleep 1<br />
count=$[ $count + 1 ]<br />
done</p>

<p>echo &ldquo;This is the end of the test script&rdquo;</p>

<p>Trapping a script exit<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
#!/bin/bash<br />
trap &ldquo;echo Goodbye&hellip;&rdquo; EXIT</p>

<p>count=1<br />
while [ $count -le 5 ]<br />
do<br />
echo &ldquo;Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1 ]<br />
done</p>

<p>Modifying or removing a trap<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
#!/bin/bash</p>

<h1 id="modifying-a-set-trap">Modifying a set trap</h1>

<p>trap &ldquo;echo &lsquo; Sorry&hellip; Ctrl-C is trapped.&rsquo;&rdquo; SIGINT</p>

<p>count=1<br />
while [ $count -le 5 ] do<br />
echo &ldquo;Loop #$count&rdquo; sleep 1<br />
count=$[ $count + 1 ]<br />
done<br />
#modify a trap<br />
trap &ldquo;echo &lsquo; I modified the trap!&rsquo;&rdquo; SIGINT</p>

<h1 id="remove-the-trap">Remove the trap</h1>

<p>trap &ndash; SIGINT</p>

<p>Section : Running Scripts in Background Mode</p>

<p>===============================================</p>

<p>In background mode, a process runs without being associated with a STDIN,
STDOUT, and STDERR on a terminal session</p>

<p>Running in the background<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
To run a shell script in background mode from the command line interface,<br />
just place an ampersand symbol (&amp;) after the command:</p>

<p>$ ./test4.sh &amp;</p>

<p>Running multiple background jobs<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
each of the background processes is tied to the terminal session (pts/0)
terminal.<br />
If the terminal session exits, the background process also exits.</p>

<h2 id="section-running-scripts-without-a-hang-up">Section : Running Scripts without a Hang-Up</h2>

<p>===========================================<br />
the nohup command:<br />
start a shell script from a terminal session and let the script run in
background mode until it finishes, even if you exit the terminal session.</p>

<p>$ nohup ./test1.sh &amp;</p>

<p>Because the nohup command disassociates the process from the terminal, the
process loses the STDOUT and STDERR output links.<br />
automatically redirects STDOUT and STDERR messages to a file, called
nohup.out.</p>

<h2 id="section-controlling-the-job">Section : Controlling the Job</h2>

<p>================================</p>

<p>The function of starting, stopping, killing, and resuming jobs is called job
control.</p>

<p>Viewing jobs<br />
-&mdash;&mdash;&mdash;&ndash;<br />
The jobs command allows you to view the current jobs being handled by the
shell:</p>

<p>$ jobs<br />
[1]+ Stopped ./test10.sh<br />
[2]- Running ./test10.sh &gt; test10.out &amp;<br />
$</p>

<p>view the various jobs’ PIDs by adding the -l parameter (lowercase L)</p>

<p>$ jobs -l<br />
[1]+ 1897 Stopped ./test10.sh<br />
[2]- 1917 Running ./test10.sh &gt; test10.out &amp;<br />
$</p>

<p>The job with the plus sign<br />
is considered the default job. It would be the job referenced by any job
control commands if a job number wasn’t specified in the command line.<br />
The job with the minus sign<br />
is the job that would become the default job when the current default job
finishes processing.</p>

<p>Using the kill command<br />
to send a SIGHUP signal to the default process causes the job to terminate.</p>

<p>$ kill 1955<br />
$<br />
[3]+ Terminated<br />
$</p>

<p>Restarting stopped jobs:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
ctrl+C<br />
ctrl+Z</p>

<p>To restart a job , use the bg command:</p>

<p>$ ./test11.sh<br />
^Z<br />
$ bg<br />
#this restart the default job with +<br />
#If you have additional jobs, you need to use the job number along with the bg
command:<br />
&hellip;..</p>

<p>$ jobs<br />
[1]+ Running<br />
$</p>

<h2 id="section-being-nice">Section : Being Nice</h2>

<p>======================<br />
By default, all processes started from the shell have the same scheduling
priority on the Linux system.<br />
The scheduling priority is an integer value, from -20 (the highest priority)
to +19 (the low- est priority).</p>

<p>By default, the bash shell starts all processes with a scheduling priority of
0.</p>

<p>Using the nice command<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
The nice command allows you to set the scheduling priority of a command</p>

<p>$ nice -n 10 ./test4.sh &gt; test4.out &amp;</p>

<p>$ ps -p 4973 -o pid,ppid,ni,cmd</p>

<p>$ nice -10 ./test4.sh &gt; test4.out &amp;</p>

<p>Using the renice command<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
change the priority of a command that’s already running on the system.</p>

<p>specify the PID of a run- ning process to change its priority:</p>

<p>$ renice -n 10 -p 5055<br />
$ ps -p 5055 -o pid,ppid,ni,cmd</p>

<h2 id="section-running-like-clockwork">Section : Running Like Clockwork</h2>

<p>==================================</p>

<p>Scheduling a job using the at command<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
specify a time when the Linux system will run a script.</p>

<p>The at daemon, atd, runs in the background and checks the job queue for jobs
to run.</p>

<p>By default, the atd daemon checks this directory every 60 seconds.</p>

<p>By default, at jobs are submitted to the at job a queue.<br />
Any output destined to STDOUT or STDERR is mailed to the user via the mail
system.<br />
command format:</p>

<p>at [-f filename] time</p>

<p>time formats:<br />
■ A standard hour and minute, such as 10:15<br />
■ An AM/PM indicator, such as 10:15PM<br />
■ A specific named time, such as now, noon, midnight, or teatime (4PM)<br />
■ A standard date format, such as MMDDYY, MM/DD/YY, or DD.MM.YY<br />
&hellip;.</p>

<p>Listing pending jobs<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
The atq command allows you to view what jobs are pending on the system:</p>

<p>Removing jobs<br />
-&mdash;&mdash;&mdash;&mdash;&ndash;<br />
the atrm command to remove a pending job:</p>

<p>Scheduling regular scripts<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
the cron program to allow you to schedule jobs that need to run on a regular
basis.<br />
The cron program runs in the background and checks special tables, called cron
tables, for jobs that are scheduled to run.</p>

<p>The format for the cron table is:<br />
min hour dayofmonth month dayofweek command</p>

<p>if you want to run a command at 10:15 on every day, you would use this cron
table entry:</p>

<p>15 10 * * * command</p>

<p>00 12 * * * if [<code>date +%d -d tomorrow</code> = 01 ] ; then ; command<br />
This checks every day at 12 noon to see if it’s the last day of the month, and
if so, cron runs the command</p>

<p>15 10 * * * /home/rich/test4.sh &gt; test4out</p>

<p>Building the cron table<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
Linux provides the crontab command for handling the cron table.<br />
To list an existing cron table, use the -l parameter:<br />
$ crontab -l<br />
no crontab for rich<br />
$</p>

<p>To add entries to your cron table, use the -e parameter.</p>

<p>If anacron determines that a job has missed a scheduled running, it runs the
job as soon as possible.</p>

<p>Starting scripts with a new shell<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>