<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux基础篇学习shell及shell脚本 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux基础篇学习shell及shell脚本 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux基础篇学习shell及shell脚本">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%9F%BA%E7%A1%80%E7%AF%87%E5%AD%A6%E4%B9%A0shell%E5%8F%8Ashell%E8%84%9A%E6%9C%AC/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux基础篇学习shell及shell脚本</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="概述">概述</h2>

<h3 id="shell概念">shell概念</h3>

<p>shell又称命令解释器，它能识别用户输入的各种命令，并传递给操作系统</p>

<blockquote>
<p>它的作用类似于Windows操作系统中的命令行，但是，Shell的功能远比命令行强大的多；在UNIX或者localhost中，Shell既是用户交互的界面，也是控制系统的脚本语言</p>
</blockquote>

<h3 id="shell的种类">shell的种类</h3>

<p>CentOS linux系统默认的shell为bash</p>

<table>
<thead>
<tr>
<th>shell</th>
<th>相关</th>
</tr>
</thead>

<tbody>
<tr>
<td>Bourne Shell</td>
<td>标识为sh，该Shell由Steve</td>
</tr>
</tbody>
</table>

<p>Bourne在贝尔实验室时编写。在许多Unix系统中，该Shell是root用户的默认的Shell。<br />
Bourne-Again Shell | 标识为bash，该Shell由Brian Fox在1987年编写，是绝大多数linux发行版的默认的Shell。<br />
Korn Shell | 标识为ksh，该Shell由贝尔实验室的David Korn在二十世纪八十年代早期编写。它完全向上兼容 Bourne Shell
并包含了C Shell 的很多特性。<br />
C Shell | 标识为csh，该Shell由Bill Joy在BSD系统上开发。由于其语法类似于C语言，因此称为C Shell。</p>

<h3 id="bash-shell特性">bash shell特性</h3>

<ol>
<li>历史命令 history</li>
<li>命令和文件补全 Tab</li>
<li>命令别名 alias</li>
<li>作业控制 job（前台fg，后台bg）</li>
<li>程序脚本</li>
<li>通配符</li>
<li>管道 | tee</li>
</ol>

<h4 id="shell相关">shell相关</h4>

<p>查看系统shell <code>cat /etc/shells</code><br />
查看系统默认shell <code>echo $SHELL</code><br />
查看系统的bash版本 <code>bash --version</code> 或 <code>rpm -qa bash</code><br />
检查bash是否安全</p>

<p>老版本的bash存在较为严重的安全信息，凭借漏洞，攻击者可能会接管计算机的整个系统</p>

<pre><code>[root@zycentos7 ~]# env x='(){:;};echo be careful ' bash -c &quot;echo this is a test&quot;
this is a test
</code></pre>

<p>如果返回如下内容，则需要升级bash <code>yum -y update bash</code></p>

<pre><code>be careful
this ia a test
</code></pre>

<h2 id="shell脚本概念">shell脚本概念</h2>

<p>命令或程序语句不在命令行下执行，而是通过一个程序文件来执行，该程序文件就是脚本</p>

<h3 id="常见的脚本语言及其优点">常见的脚本语言及其优点</h3>

<table>
<thead>
<tr>
<th>语言</th>
<th>优点</th>
</tr>
</thead>

<tbody>
<tr>
<td>php语言</td>
<td>优势在于小型网站系统的开发</td>
</tr>

<tr>
<td>perl语言</td>
<td>优势在于开发较为复杂的运维工具软件、web界面的管理工具和web业务的开发（例如：跳板机、批量管理软件saltstack等）</td>
</tr>

<tr>
<td>python语言</td>
<td>上层语言，类似于Java，go等编程语言（cmdb自动化运维平台，openstack）</td>
</tr>

<tr>
<td>shell语言</td>
<td>优势在于处理偏操作系统底层的业务，使用shell更符合liunx运维简单、易用、高效的原则</td>
</tr>
</tbody>
</table>

<h3 id="shell脚本的建立与执行">shell脚本的建立与执行</h3>

<p>shell脚本运行时首先查找系统环境变量ENV，该变量制定了环境文件（加载顺序通常是/etc/profile 、～/.bash_profile
、～/.bashrc 、/etc/bashrc等），在加载了以上环境变量文件后，shell就开始执行shell脚本中的内容</p>

<h4 id="shell脚本的运行">shell脚本的运行</h4>

<ol>
<li><p><code>sh test.sh</code> 或 <code>bash test.sh</code><br />
脚本文件 <strong>本身没有执行权限</strong> 或者脚本文件 <strong>开头没有指定解释器</strong> 时使用<br />
执行脚本都会启动新的子shell执行，执行完后，退回到父shell</p></li>

<li><p><code>./test.sh</code> 或 <code>path/test.sh</code><br />
指定在当前目录下执行脚本，但是脚本需要有执行权限</p></li>

<li><p><code>source test.sh</code> 或 <code>.test.sh</code><br />
使用source或‘.’ 读入或加载指定的shell脚本文件，然后依次执行指定的shell脚本文件中的所有语句<br />
在当前父shell脚本进程中运行，结束后脚本中的变量（函数）值在当前shell中依然存在</p></li>

<li><p><code>sh &lt; test.sh</code> 或 <code>cat test.sh | sh :</code><br />
sh可接收标准输入</p>

<p>[root@zycentos7 ~]# cat a.sh
userdir=<code>pwd</code>
[root@zycentos7 ~]# sh a.sh
[root@zycentos7 ~]# echo $userdir</p>

<p>[root@zycentos7 ~]# source a.sh
[root@zycentos7 ~]# echo $userdir
/root</p></li>
</ol>

<h3 id="shell脚本注释">shell脚本注释</h3>

<ol>
<li><p>单行注释<br />
#</p></li>

<li><p>多行注释<br />
:&lt; …注释内容<br />
BLOCK</p></li>
</ol>

<h3 id="shell脚本规范">shell脚本规范</h3>

<ol>
<li><p>开头指定shell解释器<br />
<code>#!bin/bash</code> 其他#行表示注释<br />
名称见名知义，backup_mysql.sh<br />
尽量不用中文注释</p></li>

<li><p>开头加版本版权等信息<br />
~.vimrc配置，代码缩进</p></li>

<li><p>多使用内部命令<br />
提高性能<br />
type查看</p></li>

<li><p>不用cat，少用管道</p></li>

<li><p>仔细阅读出错信息</p></li>

<li><p>仔细阅读出错信息</p></li>

<li><p>脚本以.sh为扩展名</p></li>
</ol>

<h2 id="变量">变量</h2>

<h3 id="变量类型">变量类型</h3>

<p>可以在创建变量的shell以及派生出来的任意子进程shell中使用，又可分为：自定义环境变量和bash内的环境变量</p>

<h4 id="环境变量-全局变量">环境变量（全局变量）</h4>

<p>环境变量的名字均采用大写形式</p>

<h4 id="普通变量-局部变量">普通变量（局部变量）</h4>

<p>只能在创建他们的shell函数或shell脚本中使用</p>

<h3 id="变量的导出">变量的导出</h3>

<p><strong>set</strong> 输出所有变量<br />
<strong>env</strong> 输出全局变量<br />
<strong>declare</strong> 输出所有变量、函数、和已经导出的变量</p>

<h3 id="自定义全局变量">自定义全局变量</h3>

<h4 id="语法">语法</h4>

<pre><code>export NAME=value



[root@zycentos7 ~]# declare -x JOB=linux
[root@zycentos7 ~]# declare|grep JOB
JOB=linux
_=JOB=linux
[root@zycentos7 ~]# declare|grep JOB
JOB=linux
</code></pre>

<h3 id="自定义局部变量">自定义局部变量</h3>

<pre><code>[root@zycentos7 ~]# a=&quot;BeiJing TIME:`date`&quot; ;反引号
[root@zycentos7 ~]# echo $a
BeiJing TIME:Sun Dec 8 15:29:53 CST 2019
[root@zycentos7 ~]# a='BeiJing TIME:&quot;date&quot;' ;双引号，弱引用
[root@zycentos7 ~]# echo $a
BeiJing TIME:&quot;date&quot;
[root@zycentos7 ~]# a='BeiJing TIME:'date'' ;单引号，强引用，所见即所得
[root@zycentos7 ~]# echo $a
BeiJing TIME:`date`
[root@zycentos7 ~]# CMD=$(pwd)
[root@zycentos7 ~]# echo $CMD
/root
</code></pre>

<h3 id="变量永久生效">变量永久生效</h3>

<ol>
<li><p>局部变量保存位置，当前用户有效<br />
<code>~.bash_profile</code><br />
<code>.bashrc</code></p></li>

<li><p>全局变量保存位置，全局有效<br />
<code>/etc/profile</code><br />
<code>/etc/profile.d/</code><br />
<code>/etc/bashrc</code></p></li>
</ol>

<h3 id="设置登录提示">设置登录提示</h3>

<ol>
<li><p>vim /etc/motd<br />
方法二：</p></li>

<li><p>vim /etc/profile.d/zhao.sh</p></li>
</ol>

<h3 id="环境变量初始化与对应文件的生效顺序">环境变量初始化与对应文件的生效顺序</h3>

<p>linux系统bash加载环境变量的过程<br />
系统运行shell的方式<br />
（1）通过系统用户登录后默认运行的shell<br />
（2）非交互式运行Shell<br />
（3）执行脚本运行非交互式shell</p>

<pre><code>[root@zycentos7 ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
</code></pre>

<h3 id="bash-shell-相关运算">bash shell 相关运算</h3>

<h4 id="1-生成加密密码">1. 生成加密密码</h4>

<p>Centos 6 <code>grub-md5-cryp</code><br />
Centos 7 <code>grub2-mkpasswd-pbkdf2</code></p>

<h4 id="2-生成自然数">2. 生成自然数</h4>

<p><strong>$ Number</strong> 第Number个参数<br />
<strong>$#</strong> 参数个数</p>

<p>echo输出自然数</p>

<pre><code>[root@zycentos7 ~]# echo {0..10}
0 1 2 3 4 5 6 7 8 9 10
</code></pre>

<h5 id="eval">eval</h5>

<p>eval会对后面的cmdLine进行两遍扫描，如果在第一遍扫面后cmdLine是一个普通命令，则执行此命令；如果cmdLine中含有变量的间接引用，则保证简介引用的语义</p>

<p>eval生成随机数</p>

<pre><code>[root@zycentos7 ~]# cat test.sh
END=5
for i in `eval echo {1..$END}`
do
echo $i
done
[root@zycentos7 ~]# sh test.sh
1
2
3
4
5
</code></pre>

<p>测试eval</p>

<pre><code>[root@zycentos7 ~]# set 11 22 33 44
[root@zycentos7 ~]# echo $4
44
[root@zycentos7 ~]# echo $#
4
[root@zycentos7 ~]# echo &quot;$$#&quot;
7107#
[root@zycentos7 ~]# echo &quot;\$$#&quot;
$4
[root@zycentos7 ~]# eval echo &quot;\$$#&quot;
44
</code></pre>

<h5 id="seq-产生从某个数到另一个数之间的所有整数">seq 产生从某个数到另一个数之间的所有整数</h5>

<pre><code>seq [选项]... 尾数
seq [选项]... 首数 尾数
seq [选项]... 首数 增量 尾数
</code></pre>

<p>seq -w 在列前添加0，使得宽度相同</p>

<pre><code>[root@zycentos7 ~]# seq -w 98 100
098
099
100
</code></pre>

<p>seq -f 使用printf 样式的浮点格式</p>

<pre><code>-f&quot;%#g&quot;（补空格）
-f&quot;%0#g&quot;（补0）
[root@zycentos7 ~]# seq -f&quot;%4g&quot; 8 12
   8
   9
  10
  11
  12
[root@zycentos7 ~]# seq -f&quot;%04g&quot; 8 12
0008
0009
0010
0011
0012
</code></pre>

<p>-s 指定分隔符（默认使用\n）换行\n无效</p>

<pre><code>[root@zycentos7 ~]# seq -s&quot; &quot; -f&quot;str%02g&quot; 9 11
str09 str10 str11
[root@zycentos7 ~]# seq -s&quot;`echo -e &quot;\t&quot;`&quot; -f&quot;str%02g&quot; 9 11
str09   str10   str11
</code></pre>

<h4 id="3-生成随机数">3.生成随机数</h4>

<p>（1）通过内部系统变量（$RANDOM） <code>echo $RANDOM</code><br />
（2）使用awk的随机函数 <code>awk 'BEGIN{srand();print rand()*1000000}'</code><br />
（3）openssl rand产生随机数 <code>openssl rand -base64 8</code></p>

<pre><code>1.八位字母和数字的组合
openssl rand -base64 8|md5sum|cut -c 1-8
2.八位数字
openssl rand -base64 8|cksum|cut -c 1-8
</code></pre>

<p>（4）通过时间获得随机数（date）</p>

<pre><code>1.生成19位数字
date +%s%N  #
2.取八位数字
date +%s%N|cut -c 6-13
13578053
3.八位字母和数字的组合
date +%s%N|md5sum|head -c 8
</code></pre>

<p>（5）通过系统内唯一数据生成随机数</p>

<blockquote>
<p>1./dev/random存储系统当前运行的环境的实时数据，可以看作系统某时候的唯一值数据，提供优质随机数<br />
 2./dev/urandom是非阻塞的随机数产生器，读取时不会产生阻塞，速度更快、安全性较差的随机数发生器</p>
</blockquote>

<pre><code>1.生成数字和字母混合的随机字符串
cat /dev/urandom|head -n 10|md5sum|head -c 10
【dc32c5047f】
2.生成全字符的随机字符串
cat /dev/urandom|strings -n 8|head -n 1
【}pFYi%%D~】
3.生成数字加字母的随机字符串，其中 strings -n设置字符串的字符数，head -n设置输出的行数
cat /dev/urandom|sed -e 's#[^a-zA-Z0-9]##g'|strings -n 8|head -n 1
【aPdKtMod】
4.生成全数字的随机字符串
head -200 /dev/urandom|cksum|cut -d &quot; &quot; -f1
【1182233652】
</code></pre>

<p>（6）读取Linux的uuid码</p>

<blockquote>
<p>UUID码全称是通用唯一识别码 (Universally Unique Identifier,
UUID)，UUID格式是：包含32个16进制数字，以“-”连接号分为五段，形式为8-4-4-4-12的32个字符，linux的uuid码由内核提供，在/proc/sys/kernel/random/uuid文件内。</p>
</blockquote>

<p><code>cat/proc/sys/kernel/random/uuid</code> 每次获取到的数据都会不同</p>

<pre><code>1.获取不同的随机整数
cat /proc/sys/kernel/random/uuid |cksum|cut -f1 -d &quot; &quot;  #
【3838247832】
2.数字加字母的随机数
cat /proc/sys/kernel/random/uuid |md5sum|cut -c 1-8  #
【6092539b】
</code></pre>

<p>（7）从元素池中随机抽取</p>

<blockquote>
<p>pool=(a b c d e f g h i j k l m n o p q r s t 1 2 3 4 5 6 7 8 9 10)<br />
 num=KaTeX parse error: Expected &lsquo;}&rsquo;, got &lsquo;#&rsquo; at position 2: {#̲pool[*]}
result…{pool[$((RANDOM%num))]}<br />
 用于生成一段特定长度的有数字和字母组成的字符串，字符串中元素来自自定义的池子</p>
</blockquote>

<pre><code>[root@zycentos7 ~]# cat seqeand.sh
length=8 
i=1 

seq=(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z) 

num_seq=${#seq[@]} 

while [ &quot;$i&quot; -le &quot;$length&quot; ] 
do 
 seqrand[$i]=${seq[$((RANDOM%num_seq))]} 
 let &quot;i=i+1&quot; 
done 

echo &quot;The random string is:&quot; 
for j in ${seqrand[@]} 
do 
 echo -n $j 
done 
echo 
[root@zycentos7 ~]# sh seqeand.sh
The random string is:
j2dZnA5r
</code></pre>

<h4 id="4-生成随机uuid">4.生成随机UUID</h4>

<pre><code>[root@zycentos7 ~]# cat /proc/sys/kernel/random/uuid
75052f89-9b32-4dcd-8deb-146a616be19e
</code></pre>

<h4 id="5-生成随机mac地址">5.生成随机MAC地址</h4>

<pre><code>（1）echo &quot;00:60:2F$(dd bs=1 count=3 if=/dev/random 2&gt;/dev/null |hexdump -v -e '/1 &quot;:%02X&quot;')&quot;
（2）echo &quot;$(hexdump -n3 -e'/3 &quot;00:60:2F&quot; 3/1 &quot;:%02X&quot;' /dev/random)&quot;
（3）printf '00:60:2F:%02X:%02X:%02X\n' $[RANDOM%256] $[RANDOM%256] 
（4）echo 00:60:2f:`openssl rand -hex 3 | sed 's/\(..\)/\1:/g; s/.$//'`
</code></pre>

<h4 id="6-命令排序">6.命令排序</h4>

<p><strong>;</strong> 不具备逻辑判断<br />
<strong>&amp; &amp;</strong> 前一个命令执行成功才继续执行下一个命令<br />
<strong>||</strong> 前一个命令执行的结果不影响下一个命令</p>

<pre><code>command &amp; 后台执行
command &amp;&gt;/dev/null 混合重定向（标准输出1，错误输出2）
command1 &amp;&amp; command2 命令排序，逻辑判断
</code></pre>

<h2 id="shell脚本进阶">shell脚本进阶</h2>

<h3 id="1-shell脚本之特殊变量">1.shell脚本之特殊变量</h3>

<h4 id="常用的特殊位置参数变量说明">常用的特殊位置参数变量说明</h4>

<table>
<thead>
<tr>
<th>位置变量</th>
<th>作用说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>$0</td>
<td>获取当前执行的Shell脚本的 <strong>文件名</strong> ，如果执行脚本包含了路径，那么就包括脚本路径</td>
</tr>

<tr>
<td>$n</td>
<td>获取当前执行的Shell脚本的 <strong>第n个参数值</strong> ，n=1…9，n大于9用大括号括起来，例如${10}，接的参数以空格隔开</td>
</tr>

<tr>
<td>$#</td>
<td>获取当前执行的Shell脚本后面接的 <strong>参数</strong> 的总 <strong>个数</strong></td>
</tr>

<tr>
<td>$*或$@</td>
<td>获取当前Shell脚本所有 <strong>传参</strong> 的 <strong>参数</strong></td>
</tr>

<tr>
<td>“$*”</td>
<td>将所有的 <strong>参数</strong> 视为单个 <strong>字符串</strong> ，相当于&rdquo;$1 $2 $3&rdquo;</td>
</tr>

<tr>
<td>“$@”</td>
<td>将所有的参数视为不同的独立字符串，相当于&rdquo;$1&rdquo; “$2” “$3”…&rdquo;</td>
</tr>
</tbody>
</table>

<p>$@和&rdquo;$@“等价，$<em>和”$</em>&rdquo; 不等价<br />
&rdquo;$@&ldquo;是将多参数传递给其他程序的最佳方式，因为它会保留所有的内嵌在每个参数里的任何空白</p>

<pre><code>[root@zycentos7 ~]# dirname /root/test/test.sh
/root/test
[root@zycentos7 ~]# basename /root/test/test.sh
test.sh
</code></pre>

<p>&rdquo;$*“和”$@&ldquo;的区别测试</p>

<pre><code>[root@zycentos7 ~]# set -- This &quot;is a&quot; test
[root@zycentos7 ~]#  for i in &quot;$@&quot;;do echo $i;done
This
is a
test
[root@zycentos7 ~]#  for i in &quot;$*&quot;;do echo $i;done
This is a test
</code></pre>

<p>$<em>和&rdquo;$</em>&ldquo;的区别</p>

<pre><code>$* 参数单独列出
&quot;$*&quot; 所有参数当成一个整体



n=0
for i in $*
do
    echo $i
    let n++
done
echo $n
echo &quot;---------------------&quot;
for j in &quot;$@&quot;
do
    echo $j
done
</code></pre>

<h4 id="shell进程的特殊状态变量说明">Shell进程的特殊状态变量说明</h4>

<table>
<thead>
<tr>
<th>位置变量</th>
<th>作用说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>$?</td>
<td>获取执行上一个指令的 <strong>执行状态返回值</strong> (0成功，非0为失败)</td>
</tr>

<tr>
<td>$$</td>
<td>获取当前执行的Shell脚本的 <strong>进程号</strong> (PID)</td>
</tr>

<tr>
<td>$!</td>
<td>获取上一个在后台工作的进程的进程号(PID)</td>
</tr>

<tr>
<td>$_</td>
<td>获取在此之前执行的命令或脚本的最后一个参数</td>
</tr>
</tbody>
</table>

<pre><code>[root@zycentos7 ~]# cat c.sh
read -p &quot;please input your number:&quot; num
if [ 5 -eq $num ]
then
    echo &quot;$num&quot;
    exit 10
elif [ 6 -eq $num ]
then
    echo &quot;$num&quot;
    exit 20
else
    echo &quot;$num&quot;
    exit 30
fi
[root@zycentos7 ~]# sh c.sh
please input your number:4
4
[root@zycentos7 ~]# echo $?
30
[root@zycentos7 ~]# ls -l
[root@zycentos7 ~]# echo $_
-l
</code></pre>

<p>在企业场景下，“$?”返回值的用法如下：</p>

<ol>
<li>判断命令、脚本或函数等程序是否执行成功</li>
<li>若在脚本中调用执行“exit 数字”，则会返回这个数字给“$?”变量</li>
<li>如果是在函数里，则通过“return 数字”把这个数字以函数返回值的形式传给“$?&rdquo;</li>
</ol>

<p><strong>练习</strong> 【$$的企业级应用】实现系统中多次执行某一个脚本后的进程只有一个</p>

<blockquote>
<p>说明：有时执行定时任务脚本的频率比较快，并不知道上一个脚本是否真的执行完毕，但是，业务要求同一时刻只能有一个同样的脚本在运行，此时就可以利用$$获取上一次运行的脚本进程号，当程序重新运行时，根据获得的进程号，清理掉上一次的进程，运行新的脚本命令</p>
</blockquote>

<h3 id="2-shell的内置变量">2.shell的内置变量</h3>

<p>内部命令：echo ,eval,exec,export,read,shift</p>

<h4 id="echo">echo</h4>

<table>
<thead>
<tr>
<th>echo参数选项</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>-n</td>
<td>不换行输出内容</td>
</tr>

<tr>
<td>-e</td>
<td>解析转义字符</td>
</tr>

<tr>
<td>转义字符</td>
<td>说明</td>
</tr>

<tr>
<td>&mdash;</td>
<td>&mdash;</td>
</tr>

<tr>
<td>\n</td>
<td>换行</td>
</tr>

<tr>
<td>\r</td>
<td>回车</td>
</tr>

<tr>
<td>\t</td>
<td>制表符(tab)</td>
</tr>

<tr>
<td>\b</td>
<td>退格</td>
</tr>

<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
</tbody>
</table>

<h4 id="exec">exec</h4>

<p>exec命令能够在不创建新的子进程的前提下，转去执行指定的命令，当指定<br />
的命令执行完毕后，该进程( 也就是最初的Shell)就终止了</p>

<pre><code>[zhao@zycentos7 ~]$ exec date   ;root用户执行会退出登录
Wed Dec 18 08:55:46 CST 2019



exec &lt; /etc/passwd
while read line
do
    echo $line
done
</code></pre>

<p>当使用exec打开文件后，read 命令每次都会将文件指针移动到文件的下一行进行读取，直到文件末尾，利用这个可以实现处理文件内容</p>

<h4 id="read">read</h4>

<p>read -p</p>

<h4 id="shift">shift</h4>

<p>shift 语句会按如下方式重新命名所有的位置参数变量</p>

<blockquote>
<p>即$2成为$1、$3成为$2等，以此类推<br />
 在程序中每使用一次shift 语句，都会使所有的位置参数依次向左移动一个位置，并使位置参数$#减1,直到减到0为止</p>
</blockquote>

<p><strong>应用场景</strong> 当我们写Shell希望像命令行的命令通过参数控制不同的功能时，就会先传一个类似-c的参数，然后再接内容</p>

<h4 id="exit">exit</h4>

<p>退出Shell程序，在exit之后可以有选择地指定一个数位作为返回状态</p>

<h3 id="3-shell脚本之子串及特殊变量">3.shell脚本之子串及特殊变量</h3>

<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>${parameter}</td>
<td>返回字符串的内容</td>
</tr>

<tr>
<td>${#parameter}</td>
<td>统计字符串长度</td>
</tr>

<tr>
<td>${parameter:offset}</td>
<td>从第offset个字符开始输出</td>
</tr>

<tr>
<td>${parameter:offset:length}</td>
<td>从第offset个字符开始输出length个字符</td>
</tr>

<tr>
<td>${parameter#word}</td>
<td>从开头开始删除最短匹配的字符串</td>
</tr>

<tr>
<td>${parameter##word}</td>
<td>从开头开始删除最长匹配的字符串</td>
</tr>

<tr>
<td>${parameter%word}</td>
<td>从结尾开始删除最短匹配的字符串</td>
</tr>

<tr>
<td>${parameter%%word}</td>
<td>从结尾开始删除最长匹配的字符串</td>
</tr>

<tr>
<td>${parameter/pattern/string}</td>
<td>使用string代替 <strong>第一个</strong> 匹配的pattern</td>
</tr>

<tr>
<td>${parameter//pattern/string}</td>
<td>使用string <strong>代替所有</strong> 匹配的pattern</td>
</tr>
</tbody>
</table>

<p><strong>实例1</strong> 统计字符串a的长度</p>

<pre><code>echo  ${#a} ;速度最快
expr length &quot;$a&quot;
echo $a|wc -L
echo $a|awk '{print length($0)}'
</code></pre>

<p><strong>实例2</strong> 批量修改文件名：将testXX.txt修改为ybcXX.txt</p>

<pre><code>[root@zycentos7 ~]# touch file/test{01..20}.txt
[root@zycentos7 ~]# cat mv.sh
for i in `ls file`
do
    echo $i
    mv file/$i file/${i/test/ybc}
done
[root@zycentos7 ~]# sh mv.sh
</code></pre>

<p><strong>实例3</strong> 打印下面语句中字符数小于6的单词</p>

<pre><code>I am oldboy linux,welcome to our training.



[root@zycentos7 ~]# cat cut.sh
for i in `cat a.txt`
do
    #echo ${#i}
    if [ ${#i} -lt 6 ]
    then
        echo $i
    fi
done
[root@zycentos7 ~]# sh cut.sh
I
am
to
our
</code></pre>

<h4 id="shell的特殊扩展变量">shell的特殊扩展变量</h4>

<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>{parameter:-word}</td>
<td>parameter有值输出值，无则输出word</td>
</tr>

<tr>
<td>{parameter:=word}</td>
<td>parameter有值输出值，无则输出word，并将word赋值给parameter</td>
</tr>

<tr>
<td>{parameter:?word}</td>
<td>parameter值为空，word作为标准错误输出</td>
</tr>

<tr>
<td>{parameter:+word}</td>
<td>parameter值不为空，输出时word替换其值</td>
</tr>
</tbody>
</table>

<p><strong>实例</strong> 删除7天的过期备份数据</p>

<pre><code>DIR_BACK=backup
find ${DIR_BACK:-/backup} -type f -mtime +7 -exec rm -rf {} \;
</code></pre>

<p>防止忘记定义DIR_BACK变量而导致异常</p>

<h3 id="4-shell脚本之数值运算">4.shell脚本之数值运算</h3>

<h4 id="常见的算术运算符">常见的算术运算符</h4>

<p>+、-、 <em>、/、%、++、–、 &amp;&amp;、||、！、**（幂运算）<br />
比较符号：==、!=、=（对于字符串表示相当于）<br />
赋值符号：=、+=、-=、</em>=、/=、%=</p>

<h4 id="常见的算术运算命令">常见的算术运算命令</h4>

<table>
<thead>
<tr>
<th>运算操作符与运算命令</th>
<th>意义</th>
</tr>
</thead>

<tbody>
<tr>
<td>(())</td>
<td>用于整数运算的常用运算符，效率很高</td>
</tr>

<tr>
<td>let</td>
<td>用于整数运算，类似于“(())’</td>
</tr>

<tr>
<td>expr</td>
<td>可用于整数运算，但还有很多其他的额外功能</td>
</tr>

<tr>
<td>bc</td>
<td>Linux下的一个计算器程序(适合整数及小数运算)</td>
</tr>

<tr>
<td>$[]</td>
<td>用于整数运算</td>
</tr>

<tr>
<td>awk</td>
<td>awk既可以用于整数运算，也可以用于小数运算</td>
</tr>

<tr>
<td>declare</td>
<td>定义变量值和属性，-i 参数可以用于定义整形变量，做运算</td>
</tr>
</tbody>
</table>

<h5 id="let">let</h5>

<p>语法</p>

<pre><code>let 赋值表达式
</code></pre>

<p>let赋值表达式的功能等同于“((赋值表达式))”<br />
范例5-12:监控Web服务状态，如果访问两次均失败，则报警(let 应用案例)。</p>

<h5 id="expr">expr</h5>

<p>要注意，在使用expr时：</p>

<ol>
<li>运算符及用于计算的数字左右都至少有一个空格，否则会报错</li>
<li>使用乘号时，必须用反斜线屏蔽其特定含义，因为Shell可能会误解星号的含义</li>
</ol>

<blockquote>
<p>expr命令用途：<br />
 (1)整数运算<br />
 (2)字符串匹配<br />
 (3)字符串长度计算</p>
</blockquote>

<p>双小括号 “(())” 的操作方法</p>

<table>
<thead>
<tr>
<th>运算操作符与运算命令</th>
<th>意义</th>
</tr>
</thead>

<tbody>
<tr>
<td>((i=i+1))</td>
<td>此种书写方法为运算后赋值法，即将i+1的运算结果赋值给变量i，不能用“echo</td>
</tr>
</tbody>
</table>

<p>((i=i+1))”的形式输出表达式的值，但可以用echo $((i=i+1))输出其值<br />
i=$((i+1)) | 可以在“(())” 前加$符,表示将表达式运算后赋值给i<br />
((8&gt;7&amp;&amp;5==5)) | 可以进行比较操作，还可以加入逻辑与和逻辑或，用于条件判断<br />
echo $((2+1)) | 需要直接输出运算表达式的运算结果时，可以在“(O)&rdquo; 前加$符</p>

<p><strong>实例1</strong> 判断一个变量值或字符串是否是整数</p>

<pre><code>read -p &quot;num1:&quot; num1
read -p &quot;num1:&quot; num2
expr $num1 + 1 &gt;/dev/null 2&gt;&amp;1
if [ $? -ne 0 ]
then
    echo &quot;请您输入一个正确的整数..&quot;
    exit
fi
expr $num2 + 1 &gt;/dev/null 2&gt;&amp;1
if [ $? -ne 0 ]
then
    echo &quot;请您输入一个正确的整数..&quot;
    exit
fi
echo &quot;$num1 + $num2 = `expr $num1 + $num2`&quot;
echo &quot;$num1 - $num2 = `expr $num1 - $num2`&quot;
echo &quot;$num1 * $num2 = `expr $num1 \* $num2`&quot;
echo &quot;$num1 / $num2 = `expr $num1 / $num2`&quot;
</code></pre>

<p>实现原理：利用以expr作运算时变量或者字符串必须是整数的规则，把一个变量或字符串和一个已知的整数（非0）相加，看命令返回值是否为0，为0，则认为做加法的变量或字符串为整数，否则就不是</p>

<p><strong>实例2</strong> 判断文件扩展名是否符合要求</p>

<pre><code>if expr &quot;$1&quot; : &quot;.*\.pub&quot; &gt;/dev/null 2&gt;&amp;1
then
    echo &quot;真..&quot;
else
    echo &quot;假..&quot;
fi
</code></pre>

<h3 id="5-shell脚本之条件测试">5.shell脚本之条件测试</h3>

<p>常用语法</p>

<table>
<thead>
<tr>
<th>条件测试语法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>test</td>
<td>test 命令和“”之间至少有一个 <strong>空格</strong></td>
</tr>

<tr>
<td>[ ]</td>
<td>[]的边界和内容之间至少有一个 <strong>空格</strong></td>
</tr>

<tr>
<td>[[ ]]</td>
<td>[[]] 的边界和内容之间至少有一个 <strong>空格</strong></td>
</tr>

<tr>
<td>((&lt; 测试表达式&gt;))</td>
<td>一般用于if语句，(()) 两端不需要有空格</td>
</tr>
</tbody>
</table>

<blockquote>
<p>1.在[]中可以使用通配符等进行模式匹配<br />
 2.&amp;&amp;、|、&gt;、 3.对于整数的关系运算，也可以使用Shell 的算术运算符(())</p>
</blockquote>

<p>文件测试表达式</p>

<table>
<thead>
<tr>
<th>常用文件测试操作符</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>-d</td>
<td>文件存在且为目录则为真</td>
</tr>

<tr>
<td>-f</td>
<td>文件存在且为普通文件则为真</td>
</tr>

<tr>
<td>-e</td>
<td>文件存在则为真，注意区别于“-f”， -e不辨别是目录还是文件</td>
</tr>

<tr>
<td>-r</td>
<td>文件存在且可读则为真</td>
</tr>

<tr>
<td>-s</td>
<td>文件存在且文件大小不为0则为真</td>
</tr>

<tr>
<td>-w</td>
<td>文件存在且可写则为真</td>
</tr>

<tr>
<td>-x</td>
<td>文件存在且可执行则为真</td>
</tr>

<tr>
<td>-L</td>
<td>文件存在且为链接文件则为真</td>
</tr>

<tr>
<td>fl -nt f2</td>
<td>文件fl比文件f2新则为真（修改时间） <strong>newer than</strong></td>
</tr>

<tr>
<td>fl -otf2</td>
<td>文件fl比文件f2旧则为真（修改时间） <strong>older than</strong></td>
</tr>
</tbody>
</table>

<p>字符串测试表达式</p>

<table>
<thead>
<tr>
<th>常用字符串测试操作符</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>-n “字符串”</td>
<td>字符串的长度不为0则为真 <strong>no zero</strong></td>
</tr>

<tr>
<td>-z “字符串”</td>
<td>字符串的长度为0则为真 <strong>zero</strong></td>
</tr>
</tbody>
</table>

<pre><code>&quot;串1&quot; = &quot;串2&quot;，可使用&quot;==&quot;代替&quot;=&quot;
&quot;串1&quot; != &quot;串2&quot;，不可使用&quot;!==&quot;代替&quot;=&quot;
</code></pre>

<p>对于字符串的测试，一定要将字符串加双引号之后再进行比较，如[ -n “$myvar”
]，特别是使用[]的场景，字符串比较时若等号两端没有空格，则会导致判断出现逻辑错误</p>

<p>整数二元比较操作符</p>

<table>
<thead>
<tr>
<th>if条件命令选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>-eq</td>
<td>比较两个参数是否相等（例如，if [ 2 –eq 5 ]）</td>
</tr>

<tr>
<td>-ne</td>
<td>比较两个参数是否不相等</td>
</tr>

<tr>
<td>-lt</td>
<td>参数1是否小于参数2</td>
</tr>

<tr>
<td>-le</td>
<td>参数1是否小于等于参数2</td>
</tr>

<tr>
<td>-gt</td>
<td>参数1是否大于参数2</td>
</tr>

<tr>
<td>-ge</td>
<td>参数1是否大于等于参数2</td>
</tr>
</tbody>
</table>

<p>逻辑操作符</p>

<table>
<thead>
<tr>
<th>if条件命令选项</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>-a</td>
<td>与，两端都为真，结果为真</td>
</tr>

<tr>
<td>-o</td>
<td>或，两端有一个为真，结果为真</td>
</tr>

<tr>
<td>！</td>
<td>两端相反，结果为真</td>
</tr>
</tbody>
</table>

<p><strong>练习1</strong> 条件测试的方法</p>

<ol>
<li>test条件测试</li>
</ol>

<p>如果文件存在，输出true，否则输出false</p>

<pre><code>test -f file &amp;&amp; echo true || echo false
</code></pre>

<p>测试字符串是否为0</p>

<pre><code>[root@zycentos7 ~]# test -z &quot;oldboy&quot; &amp;&amp; echo 1 || echo 0
0
[root@zycentos7 ~]# test -z &quot;&quot; &amp;&amp; echo 1 || echo 0
1
</code></pre>

<ol>
<li>[]条件测试语法</li>
</ol>

<p>如果文件存在，输出1，否则输出0</p>

<pre><code>[ -f file ] &amp;&amp; echo 1 || echo 0
</code></pre>

<ol>
<li>[[]]语法格式</li>
</ol>

<p>如果文件存在，输出y，否则输出n</p>

<pre><code>[[ -f file ]] &amp;&amp; echo y || echo n
</code></pre>

<blockquote>
<p>三种方法的比较<br />
 [[]] 与其他两种测试表达式的其别在于，其内可以使用通配符，并且&amp;&amp; || &gt;</p>
</blockquote>

<p><strong>练习2</strong> 文件测表达式</p>

<p>测试shell变量</p>

<pre><code>[root@zycentos7 ~]# file1=/etc/services
[root@zycentos7 ~]# [ -f &quot;$file1&quot; ] &amp;&amp; echo y || echo n
y
</code></pre>

<p><strong>练习3</strong> 字符串测试表达式</p>

<pre><code>[ -n &quot;abc&quot; ] &amp;&amp; echo 1 || echo 0
</code></pre>

<h3 id="6-shell脚本之条件判断">6.shell脚本之条件判断</h3>

<h4 id="if条件语句">if条件语句</h4>

<p>单分支结构</p>

<pre><code>if &lt;条件表达式&gt;
then
    指令
fi
</code></pre>

<p>双分支结构</p>

<pre><code>if &lt;条件表达式&gt;
then
    指令集1
else
    指令集2
fi
</code></pre>

<p>多分支结构</p>

<pre><code>if &lt;条件表达式1&gt;
then
    指令1
elif &lt;条件表达式2&gt;
then
    指令2
else
    指令3
fi
</code></pre>

<p><strong>练习</strong> 猜一猜</p>

<pre><code>while true
do
read -p &quot;input the number you think:&quot; num
if [ $num -gt 58 ]
then
    echo &quot;猜大了&quot;
elif [ $num -lt 58 ]
then
    echo &quot;猜小了&quot;
else
    echo &quot;恭喜，猜对了&quot;
    exit 10
fi
done
</code></pre>

<h4 id="case条件语句">case条件语句</h4>

<pre><code>case &quot;变量&quot; in
    值1)
        指令1...
        ;;
    值2)
        指令2...
        ;;
    *)
        指令3...
esac
</code></pre>

<p><strong>企业案例</strong> rsync服务的启动脚本</p>

<pre><code>case $1 in
    start)
        rsync --daemon
        #echo &quot;start&quot;
        ;;
    stop)
        pkill rsync
        #echo &quot;stop&quot;
        ;;
    restart)
        pkill rsync
        rsync --daemon
        #echo &quot;restart&quot;
        ;;
    *)
        echo &quot;User:`basename $0` start | stop | restart.&quot;
esac



[root@zycentos7 ~]# mv RSYNC.sh /usr/local/bin/RSYNC
[root@zycentos7 ~]# chmod a+x /usr/local/bin/RSYNC
[root@zycentos7 ~]# ll /usr/local/bin/RSYNC
-rwxr-xr-x. 1 root root 441 Dec 15 04:38 /usr/local/bin/RSYNC
[root@zycentos7 ~]# RSYNC start
</code></pre>

<p>给输出的字符串加颜色</p>

<pre><code> echo -e &quot;\033[32m 字符串 \033[0m&quot;
</code></pre>

<table>
<thead>
<tr>
<th>033[#m中的#值</th>
<th>颜色</th>
</tr>
</thead>

<tbody>
<tr>
<td>30</td>
<td>黑</td>
</tr>

<tr>
<td>31</td>
<td>红</td>
</tr>

<tr>
<td>32</td>
<td>绿</td>
</tr>

<tr>
<td>33</td>
<td>棕</td>
</tr>

<tr>
<td>34</td>
<td>蓝</td>
</tr>

<tr>
<td>35</td>
<td>洋红</td>
</tr>

<tr>
<td>36</td>
<td>蓝绿</td>
</tr>

<tr>
<td>37</td>
<td>白</td>
</tr>
</tbody>
</table>

<p>给输出的字符串加背景颜色</p>

<pre><code> echo -e &quot;\033[40;32m 字符串 \033[0m&quot;
</code></pre>

<table>
<thead>
<tr>
<th>033[#;中的#值</th>
<th>颜色</th>
</tr>
</thead>

<tbody>
<tr>
<td>40</td>
<td>黑</td>
</tr>

<tr>
<td>41</td>
<td>红</td>
</tr>

<tr>
<td>42</td>
<td>绿</td>
</tr>

<tr>
<td>33</td>
<td>棕</td>
</tr>

<tr>
<td>44</td>
<td>蓝</td>
</tr>

<tr>
<td>45</td>
<td>洋红</td>
</tr>

<tr>
<td>46</td>
<td>蓝绿</td>
</tr>

<tr>
<td>47</td>
<td>白</td>
</tr>
</tbody>
</table>

<p>让输出的字符串闪烁</p>

<pre><code>echo -e &quot;\033[05;37m 字符串 \033[0m&quot;
</code></pre>

<p><strong>推荐使用</strong> 通过定义变量的方式给字体加颜色</p>

<pre><code>RED_COLOR='\E[1;31m'
GREEN_COLOR='\E[1;32m'
YELLOW_COLOR='\E[1;33m'
BLUE_COLOR='\E[1;34m'
PINK='\E[1;35m'
RES='\E[0m'
echo -e &quot;${RED_COLOR}======red color======${RES}&quot;
echo -e &quot;${YELLOW_COLOR}======yellow color======${RES}&quot;
echo -e &quot;${BLUE_COLOR}======blue color======${RES}&quot;
echo -e &quot;${GREEN_COLOR}======green color======${RES}&quot;
echo -e &quot;${PINK}======pink color======${RES}&quot;
</code></pre>

<h3 id="7-shell脚本之循环">7.shell脚本之循环</h3>

<h4 id="while循环">while循环</h4>

<pre><code>while &lt;条件表达式&gt;
do
    指令...
done
</code></pre>

<h4 id="util循环">util循环</h4>

<pre><code>util &lt;条件表达式&gt;
do
    指令...
done
</code></pre>

<h4 id="for循环">for循环</h4>

<pre><code>for 变量名 in 变量取值列表
do
    指令...
done
</code></pre>

<p>c风格</p>

<pre><code>for ((exp1;exp2;exp3))
do
    指令...
done
</code></pre>

<p><strong>练习</strong> 修改for循环默认的分隔符（空格）为换行</p>

<pre><code>IFS_old=$IFS
IFS=$'\n'
for i in `cat /etc/passwd`
do
    echo $i
done
IFS=$IFS_old
</code></pre>

<h4 id="循环控制">循环控制</h4>

<p>条件与循环控制及程序返回值命令知识表</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>break n</td>
<td>省略n表示跳出整个循环，n表示跳出循环的层数</td>
</tr>

<tr>
<td>continue n</td>
<td>省略n表示跳过本次循环，忽略本次循环的剩余代码，进人循环的下一次循环，n表示退到第n层继续循环</td>
</tr>

<tr>
<td>exit n</td>
<td>退出当前Shell程序，n为上一次程序执行的状态返回值，n可以省略（$?）</td>
</tr>

<tr>
<td>return n</td>
<td>用于在函数里作为函数的返回值，以判断函数执行是否正确（$?）</td>
</tr>
</tbody>
</table>

<p><strong>练习</strong> 输出九九乘法表</p>

<pre><code>for((i=1;i&lt;=9;i++))
do
    for((j=1;j&lt;=i;j++))
    do
        echo -ne &quot;$i*$j=$(($i*$j))\t&quot;
    done
    echo &quot;&quot;
done
</code></pre>

<h3 id="7-shell脚本之数组">7.shell脚本之数组</h3>

<h3 id="数组赋值">数组赋值</h3>

<ol>
<li><p>一次赋一个值（单独定义数组的各个部分） <code>数组名[下标]=变量值</code></p>

<p>[root@zycentos7 ~]# array[0]=pear
[root@zycentos7 ~]# array[1]=apple
[root@zycentos7 ~]# echo ${array} ${array[1]}
pear apple</p></li>

<li><p>一次赋多个值</p>

<p>passwd=(<code>cat /etc/passwd</code>)  ;将该文件中的每一个行作为一个元数赋值给数组passwd
array6=(1 2 3 4 5 6 &ldquo;linux shell&rdquo; [20]=ansinble)    ;一次赋多个值，并指定其中某些值
array=(yi bochen)   ;数组以空格符分隔各个数组元素
array=(&ldquo;yi bochen&rdquo;) ;数组元素值中含有空格，加&rdquo;&rdquo;
path=($PATH $SHELL)</p></li>
</ol>

<h4 id="数组操作">数组操作</h4>

<ol>
<li><p>获取数组长度</p>

<p>echo ${#colors[@]}
echo ${#colors[*]}</p></li>

<li><p>获取某一数组元素长度</p>

<p>echo ${#colors[1]}</p></li>

<li><p>引用数组</p>

<p>${数组名[下标]}
${数组名[@]:1} ;从下标为1开始打印全部
${数组名[@]:1:2}   ;从下标为1开始打印2个</p></li>

<li><p>遍历数组</p></li>
</ol>

<p>直接输出数组所有元素</p>

<pre><code>echo ${path[@]}
</code></pre>

<p>按数组 <strong>元素</strong> 取值，可以不连续取值</p>

<pre><code>for var in ${colors[@]};do echo $var;done
</code></pre>

<p>按数组 <strong>下标</strong> （索引）取值，只能连续取值</p>

<pre><code>for((i=0;i&lt;${#colors[@]};i++));do echo ${colors[i]};done
</code></pre>

<ol>
<li><p>删除数组</p>

<p>unset array[2]  ;删除数组中的某个元素
unset array ;删除整个数组</p></li>

<li><p>修改数组中的某一元素值</p>

<p>declare -a filename[1]=Linux</p></li>

<li><p>根据索引查看</p>

<p>echo ${filename[@]:1}   ;从下标为1开始打印全部
echo ${filename[@]:1:2} ;从下标为1开始打印2个</p></li>
</ol>

<p><strong>练习1</strong> 标准输入保存到数组里</p>

<blockquote>
<p>读入标准输入<br />
 (1) $1 $2<br />
 (2) read -p “” num<br />
 (3) cat &lt;&lt; EOF</p>

<p>EOF</p>
</blockquote>

<pre><code>i=0
while true
do
read -p &quot;&quot; num
array[$i]=$num
echo ${array[@]}
let i++
done
</code></pre>

<p><strong>练习2</strong> 字符串保存到数组里<br />
加空格保存</p>

<blockquote>
<p>使用空格对字符进行分隔<br />
 str=<code>echo $str|sed ‘s/./&amp; /g’</code></p>
</blockquote>

<pre><code>chars=&quot;abcde&quot;
chars=`echo $chars|sed 's/./&amp; /g'`
j=0
for i in $chars
do
    array[$j]=$i
    let j++
    echo ${array[@]}
done
</code></pre>

<p>将字符逐个取出</p>

<pre><code>chars=&quot;abcd&quot;
for((n=0;n&lt;${#chars};n++))
do
array[$n]=${chars:$n:1}
echo ${array[@]}
done
</code></pre>

<p><strong>练习3</strong> 将数组里的数值分别乘以8并打印</p>

<pre><code>array=(1 2 3 4 5)
j=0
for i in ${array[@]}
do
    array[$j]=$(($i*8))
    let j++
done
echo ${array[@]}
</code></pre>

<h3 id="8-shell脚本之函数">8.shell脚本之函数</h3>

<p>函数是完成特定功能的代码片段（块）<br />
在shell中定义函数可以使用代码模块化，便于复用代码，函数必须先定义才可以使用</p>

<h4 id="定义函数">定义函数</h4>

<p>格式1</p>

<pre><code>function 函数名( )
{
指令… }
</code></pre>

<p>格式2</p>

<pre><code>函数名（）
{
指令… }
</code></pre>

<p>格式3</p>

<pre><code>function 函数名
{
指令… }
</code></pre>

<h4 id="调用函数">调用函数</h4>

<pre><code>函数名
函数名 参数1 参数2
</code></pre>

<p><strong>练习1</strong> 写一个脚本，判定192.168.232.123-192.168.232.126之间的主机哪些在线</p>

<blockquote>
<p>要求：<br />
 1、使用函数来实现一台主机的判定过程<br />
 2、在主程序中来调用此函数判定指定范围内的所有主机的在线情况</p>
</blockquote>

<ol>
<li><p>直接使用函数实现（无参数，无返回值）</p>

<p>PING(){
    for i in <code>seq 123 126</code>
    do
        if ping -c 1 -w 1 192.168.232.$i &amp;&gt;/dev/null 2&gt;&amp;1
        then
            echo &ldquo;192.168.232.$i is Tong&rdquo;
        else
            echo &ldquo;192.168.232.$i is NOT Tong&rdquo;
        fi
    done
}
PING</p></li>

<li><p>使用函数返回值判断（有参数，有返回值）</p>

<p>PING(){
    if ping -c 1 -W 1 $1 &amp;&gt; /dev/null
    then
        return 0
    else
        return 1
    fi
}
for i in {123..126}
do
    PING 192.168.232.$i
    if [ $? -eq 0 ]
        then
            echo &ldquo;192.168.232.$i is up.&rdquo;
        else
            echo &ldquo;192.168.232.$i is down.&rdquo;
    fi
done</p></li>

<li><p>使用函数传参（有参数，无返回值）</p>

<p>PING(){
for i in <code>seq $1 $2</code>
do
   ping -c 1 $3$i &gt;/dev/null 2&gt;&amp;1
   if [ $? -eq 0 ]
   then
       echo &ldquo;$3$i Tong..&rdquo;
   else
       echo &ldquo;$3$i Not Tong..&rdquo;
   fi
done
}
PING $1 $2 &ldquo;192.168.232.&rdquo;
[root@zycentos7 ~]# sh ping.sh 123 126
192.168.232.123 Not Tong..
192.168.232.124 Not Tong..
192.168.232.125 Tong..
192.168.232.126 Not Tong..</p></li>
</ol>

<p><strong>练习2</strong> 写一个脚本，使用函数完成</p>

<blockquote>
<p>要求<br />
 1、函数能够接受一个参数，参数为用户名<br />
 判断一个用户是否存在，如果存在，就返回此用户的shell和UID，并返回正常状态值；如果不存在，就说此用户不存在，并返回错误状态值<br />
 2、在主程序中调用函数</p>
</blockquote>

<pre><code>USER_CHECK(){
    if id $1 &gt;/dev/null 2&gt;&amp;1
    then
        grep &quot;^$1:&quot; /etc/passwd | cut -d: -f 3,7
        n=0
    else
        echo &quot;no&quot;
        n=1
    fi
    return $n
}
while true
do
read -p &quot;username[q|Q,exit]:&quot; username
if [[ $username == &quot;&quot; ]]
then
    echo &quot;root&quot;
elif [[ $username == &quot;q&quot; || $username == &quot;Q&quot; ]]
then
    exit
else
    USER_CHECK $username
    if [ $? -eq 0 ]
    then
        echo &quot;状态值：0 true&quot;
    else
        echo &quot;状态值：1 false&quot;
    fi
fi
done
</code></pre>

<h3 id="9-脚本运行方法">9.脚本运行方法</h3>

<table>
<thead>
<tr>
<th>用法</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>sh while1.sh &amp;</td>
<td>把脚本whilel .sh放到后台执行(在后台运行脚本时常用的方法)</td>
</tr>

<tr>
<td>ctl+c</td>
<td>停止执行当前脚本或任务</td>
</tr>

<tr>
<td>ctl+z</td>
<td>暂停执行当前脚本或任务</td>
</tr>

<tr>
<td>bg</td>
<td>把当前脚本或任务放到后台执行，background</td>
</tr>

<tr>
<td>fg</td>
<td>把当前脚本或任务放到前台执行，如果有多个任务，可以使用fg加任务编号调出对应的脚本任务，如fg2,是指调出第二个脚本任务，frontground</td>
</tr>

<tr>
<td>jobs</td>
<td>查看当前执行的脚本或任务</td>
</tr>

<tr>
<td>kill</td>
<td>关闭执行的脚本任务，即以“kill %任务编号”的形式关闭脚本,这个任务编号，可以通过jobs来获得</td>
</tr>

<tr>
<td>killall 或 pkill</td>
<td>杀掉进程</td>
</tr>

<tr>
<td>ps</td>
<td>查看进程</td>
</tr>

<tr>
<td>pstree</td>
<td>显示进程状态树</td>
</tr>

<tr>
<td>top</td>
<td>显示进程</td>
</tr>

<tr>
<td>renice</td>
<td>改变优先权</td>
</tr>

<tr>
<td>nohup</td>
<td>用户退出系统之后继续工作</td>
</tr>

<tr>
<td>pgrep</td>
<td>查找匹配条件的进程</td>
</tr>

<tr>
<td>strace</td>
<td>跟踪一个进程的系统调用情况</td>
</tr>

<tr>
<td>ltrace</td>
<td>跟踪进程调用库函数的情况</td>
</tr>
</tbody>
</table>

<h2 id="练习">练习</h2>

<p><strong>练习1</strong> 用户批量管理工具（增删改查）</p>

<pre><code>#定义变量
passwd=&quot;123456&quot;
read_username=&quot;read -p &quot;请输入用户名:&quot; username&quot;
read_num1=&quot;read -p &quot;起始位置:&quot; num1&quot;
read_num2=&quot;read -p &quot;终止位置:&quot; num2&quot;

#判断用户是否存在
CHECK_USER(){
    id $username$i &gt;/dev/null 2&gt;&amp;1
    if [ $? -eq 0 ]
    then
        n=0
    else
        n=1
    fi
    return $n
}

#创建用户
CREATE_USER(){
    #read -p &quot;请输入用户名&quot; username
    #read -p &quot;请输入用户名&quot; num1
    #read -p &quot;请输入用户名&quot; num2
    useradd $username$i
    echo &quot;$passwd&quot; |passwd --stdin $username$i &gt;/dev/null 2&gt;&amp;1
}

#实现完整的用户创建功能
CREATE_USER_FULL(){
    $read_username
    $read_num1
    $read_num2
    #read -p &quot;请输入用户名&quot; username
    #read -p &quot;起始位置&quot; num1
    #read -p &quot;终止位置&quot; num2
    for i in `seq -f &quot;%02g&quot; $num1 $num2`
    do
        CHECK_USER
        if [ $? -eq 1 ]
        then
            CREATE_USER
        else
            echo &quot;$username$i 已存在&quot;
        fi
    done
}

#实现函数查看功能
SCAN_USER_LIST(){
    array=`awk -F: '$3&gt;=1000 {print $1}' /etc/passwd`
    echo ${array[@]}
}

#修改用户密码
UPDATE_PASSWD(){
    echo &quot;$1&quot; |passwd --stdin $username$i &gt;/dev/null 2&gt;&amp;1
}

#实现批量修改用户密码
UPDATE_PASSWD_FULL(){
    $read_username
    $read_num1
    $read_num2
    #read -p &quot;请输入用户名&quot; username
    #read -p &quot;起始位置&quot; num1
    #read -p &quot;终止位置&quot; num2
    read -p &quot;请输入密码：&quot; passwd
    for i in `seq -f &quot;%02g&quot; $num1 $num2`
    do
        UPDATE_PASSWD $passwd
    done
}

#实现批量删除用户
DELETE_USER_FULL(){
    $read_username
    $read_num1
    $read_num2
    #read -p &quot;请输入用户名&quot; username
    #read -p &quot;起始位置&quot; num1
    #read -p &quot;终止位置&quot; num2
    for i in `seq -f &quot;%02g&quot; $num1 $num2`
    do
        userdel -r $username$i
    done
}

while true
do
cat &lt;&lt; EOF
--------------------菜单----------------------
+           1.创建用户                       +
+           2.修改用户密码                   +
+           3.删除用户                       +
+           4.查看用户                       +
+           5.退出                           +
----------------------------------------------
EOF
read -p &quot;请输入菜单号（1-5）：&quot; num
case $num in
    1)
        CREATE_USER_FULL
        ;;
    2)
        UPDATE_PASSWD_FULL
        ;;
    3)
        DELETE_USER_FULL
        ;;
    4)
        SCAN_USER_LIST
        ;;
    5)
        exit
        ;;
    *)
        echo &quot;请输入正确的菜单号...&quot;
esac
done
</code></pre>

<p><strong>练习2</strong> 获取随机字符串或数字<br />
（1）获取随机8位字符串<br />
（2）获取随机8位数字</p>

<pre><code>length=8
i=1
seq=(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)
num_seq=${#seq[@]}
while [ &quot;$i&quot; -le &quot;$length&quot; ]
do
     seqrand[$i]=${seq[$((RANDOM%num_seq))]}
     let &quot;i=i+1&quot;
done
echo &quot;The random string is:&quot;
for j in ${seqrand[@]}
do
    echo -n $j
done



[root@zycentos7 ~]# uptime|awk -F&quot;:|,&quot; '{print &quot;1分钟平均负载:&quot;,$7&quot;\n5分钟平均 负载:&quot;$8&quot;\n15分钟平均负载:&quot;$9}'
1分钟平均负载:  0.00
5分钟平均负载: 0.01
15分钟平均负载: 0.05
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>