<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>scala学习笔记二交互式shell编程使用 | 开发者问答集锦</title>
    <meta property="og:title" content="scala学习笔记二交互式shell编程使用 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="scala学习笔记二交互式shell编程使用">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%E4%BA%A4%E4%BA%92%E5%BC%8Fshell%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">scala学习笔记二交互式shell编程使用</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>今天接着学习scala，我是按照《scala编程中文版》这本书来进行学习的，感觉书中讲的很不错，也差不多都能弄明白，跟着书中的章节来一步一步的学下来，书中提到代码全部都是自己实践敲一遍，很多问题都是在不经意间出现，动手实践一方面可以加强自己对一门新的语言的学习理解程度，另一方面可以帮助自己体会语言的语法和书写方式，再者，也是最重要的就是自己在写每一句代码的时候不可能会全部按照书中的来写，那么就会产生一些新的东西了，这就是动手去实践的重要性，可以说，读研给我最大的收获之一吧，就是：遇事在没有自己动手去做之前都不敢轻易说不，遇上问题在没有动手去差很多资料解决之前不敢轻易说不会，这也是因为自己在本科的时候太过于安逸了吧，现在希望尽量去多学多做少说话。</p>

<p>好了，扯远了，下面是今天的学习笔记，所有内容均来源于底部参考书籍，自己动手实践的时候加了东西，如有冒犯请告知。</p>

<pre><code>1.Scala 里可以使用 new 实例化对象或类实例
当你在 Scala 里实例化对象， 可以使用值和类型把它参数化： parameterize。 参数化的意思是在你创建实例的时候“设置” 它。通过把加在括号里的对象传递给实例的构造器的方式来用值参数化实例，如：实例化一个数字：
val big = new java.math.BigInteger(&quot;12345&quot;)
也可以使用类似于java中的数组方式赋值
val str_list = new Array[String](4)
等价于：val str_list: Array[String] = new Array[String](3)
str_list(0) = &quot;沂&quot;
str_list(1) = &quot;水&quot;
str_list(2) = &quot;寒&quot;
str_list(3) = &quot;城&quot;
for (i  for(i&gt;&gt; for i in range(6):
...     print i
...
0
1
2
3
4
5
个人觉得，至于简洁性不相上下
Scala的一个通用规则：如果方法仅带一个参数，你可以不带点或括号的调用它。本例中的to实际上是带一个Int参数的方法。代码 0 to 2 被
转换成方法调用(0).to(2)。
从技术上讲，Scala没有操作符重载，因为它根本没有传统意义上的操作符。取而代之的是，诸如+，-，*和/这样的字符可以用来做方法名。因此，当第一步里你在 Scala 解释器里输入 1 + 2，你实际上正在 Int 对象 1 上调用一个名为+的方法，并把 2 当作参数传给它
当对带有括号并包括一到若干参数的变量赋值时，编译器将把它转化为对带有括号里参数和等号右边的对象的 update 方法的调用
则上面的语句等价为：
val str_list = new Array[String](4)
等价于：val str_list: Array[String] = new Array[String](3)
str_list.update(0,&quot;沂&quot;)
str_list.update(1,&quot;水&quot;)
str_list.update(2,&quot;寒&quot;)
str_list.update(2,&quot;城&quot;)
for (i  val str_list=Array.apply(&quot;yi&quot;,&quot;shui&quot;,&quot;han&quot;,&quot;cheng&quot;)
str_list: Array[String] = Array(yi, shui, han, cheng)

2.方法不应该有副作用是函数风格编程的一个很重要的理念。方法唯一的效果应该是计算并返回值。用这种方式工作的好处就是方法之间很少纠缠在一起，因此就更加可靠和可重用。另一个好处（静态类型语言里）是传入传出方法的所有东西都被类型检查器检查，因此逻辑错误会更有可能把自己表现为类型错误。把这个函数式编程的哲学应用到对象世界里意味着使对象不可变。
在scala中数组Array是可变的对象，而list却是不可变的，这个区别于java的可变的list
创建一个list也很简单如下：
scala&gt; val num_list=List(23,45,67,89)
num_list: List[Int] = List(23, 45, 67, 89)

scala&gt; var num_list0=List(12,34,56,78)
num_list0: List[Int] = List(12, 34, 56, 78)
scala可以将两个列表拼接到一起就像python中的一样如下：
scala&gt; val merge_list=num_list:::num_list0
merge_list: List[Int] = List(23, 45, 67, 89, 12, 34, 56, 78)将num_list0拼在了num_list后面
如果说操作符：：：相当于python中的extend的话那么操作符：：就相当于python中的append方法了如下：
scala&gt; val new_list=100::num_list0
new_list: List[Int] = List(100, 12, 34, 56, 78)  将新数值100添加到了num_list0前面
一个简单的需记住的规则：
如果一个方法被用作操作符标注，如 a* b，那么方法被左操作数调用，就像 a.*(b)——除非方法名以冒号结尾。这种情况下，方法被右操作数
调用。因此， 1 :: twoThree 里， ::方法被 twoThree 调用，传入 1，像这样： twoThree.::(1)
由于定义空类的捷径是Nil，所以一种初始化新List的方法是把所有元素用cons操作符串起来， Nil作为最后一个元素，如下：
scala&gt; val new_list=100::99::88::77::66::55::44::33::22::11::Nil
new_list: List[Int] = List(100, 99, 88, 77, 66, 55, 44, 33, 22, 11)
要在最后用到 Nil 的理由是
::是定义在 List 类上的方法。如果你想只是写成 1 :: 2 :: 3，由于 3 是Int 类型，没有::方法，因此会导致编译失败
为什么列表不支持 append？
类List没有提供append操作，因为随着列表变长append的耗时将呈线性增长，而使用::做前缀则仅花费常量时间。如果你想通过添加元素来构造列表，你的选择是把它们前缀进去，当你完成之后再调用 reverse；或使用 ListBuffer，一种提供 append 操作的可变列表，当你完成之后调用 toList。
3.元组： tuple
与列表一样，元组也是不可变的，但与列表不同，元组可以包含不同类型的元素。而列表应该是List[Int]或List[String]的样子，元组可以同时拥有Int和String。元组很有用，比方说，如果你需要在方法里返回多个对象。Java里你将经常创建一个JavaBean样子的类去装多个返回值，Scala里你可以简单地返回一个元组。而且这么做的确简单：实例化一个装有一些对象的新元组，只要把这些对象放在括号里，并用逗号分隔即可，元组的实际类型取决于它含有的元素数量和这些元素的类型
如下：
scala&gt; val new_tuple=(&quot;20123456&quot;,&quot;沂水寒城&quot;)
new_tuple: (String, String) = (20123456,沂水寒城)
访问元祖中的元素的话可以使用点号，下划线和一个基于 1 的元素索引访问它，如下：
scala&gt; println(new_tuple._1)
20123456
scala&gt; println(new_tuple._2)
沂水寒城
不能用类似数组下标的方式访问元祖原因：
因为 List 的 apply 方法始终返回同样的类型，但是元组里的或许类型不同，_N 数字是基于 1 的，而不是基于 0 的，因为对于拥有静态类型元组的其他语言，从1开始是传统的设定
4.set和map
Scala 致力于帮助你充分利用函数式和指令式风格两方面的好处，它的集合类型库于是就区分了集合类的可变和不可变。
数组始终是可变的，而列表始终不可变。
Scala 同样提供了可变和不可变的替代品，不过用了不同的办法。对于集和映射， Scala 把可变性建模在类继承中。
Scala 的 API 包含了集的一个基本特质： trait，特质这个概念接近于 Java 的接口
Scala 于是提供了两个子特质，一个是可变的集，另一个是不可变的集。
三个特质都共享同样的简化名， Set。然而它们的全称不一样，因为每个都放在不同的包里。 如下：
scala&gt; var test_set=Set(&quot;沂&quot;, &quot;水&quot;, &quot;寒&quot;,&quot;城&quot;)
test_set: scala.collection.immutable.Set[String] = Set(沂, 水, 寒, 城)
scala&gt; println(test_set.contains(&quot;ABC&quot;))
false
scala&gt; test_set+=&quot;ABC&quot;
scala&gt; println(test_set.contains(&quot;ABC&quot;))
true
上述代码简单创建了一个缺省的不可变集合test_set，查询test_set是否包含某个元素，不包含的话将这个元素添加进去再次查询是否包含
对于set的+：
可变的和不可变的集都提供了+方法，但它们的行为不同。可变集将把元素加入自身，不可变集将创建并返回一个包含了添加元素的新集
如果想显式地定义可变集可以这样写：
import scala.collection.mutable.Set
对，没看错，这个就是上面的代码在scala的交互式shell中创建了test_set之后返回值的类型相对的类型在mutable和immutable之间的差别
如果你需要一个不可变的HashSet可以这么做：
import scala.collection.immutable.HashSet
val test_set0 = HashSet(&quot;张三&quot;, &quot;李四&quot;,&quot;张飞&quot;,&quot;赵云&quot;,&quot;马岱&quot;)
println(test_set0 + &quot;关羽&quot;)
如下：
scala&gt; import scala.collection.immutable.HashSet
import scala.collection.immutable.HashSet
scala&gt; val test_set0 = HashSet(&quot;张三&quot;, &quot;李四&quot;,&quot;张飞&quot;,&quot;赵云&quot;,&quot;马岱&quot;)
test_set0: scala.collection.immutable.HashSet[String] = Set(张飞, 李四, 马岱, 赵云, 张三)
scala&gt; println(test_set0 + &quot;关羽&quot;)
Set(张飞, 李四, 马岱, 赵云, 关羽, 张三)
Map 是 Scala 里另一种有用的集合类。和集一样， Scala 采用了类继承机制提供了可变的和不可变的两种版本的 Map
scala.collection 包里面有一个基础 Map 特质和两个子特质 Map：可变的 Map 在scala.collection.mutable 里，不可变的在 scala.collection.immutable 里
简单的代码演示如下：
（1）可变版本的map创建
import scala.collection.mutable.Map
val test_map = Map[String, String]()
test_map(&quot;id_123&quot;)=&quot;刘备&quot;
test_map(&quot;id_124&quot;)=&quot;孙权&quot;
test_map(&quot;id_125&quot;)=&quot;曹操&quot;
test_map+=(&quot;id_001&quot;-&gt;&quot;吕布&quot;)
test_map+=(&quot;id_002&quot;-&gt;&quot;关羽&quot;)
test_map+=(&quot;id_003&quot;-&gt;&quot;张飞&quot;)
结果如下：
scala&gt; import scala.collection.mutable.Map
import scala.collection.mutable.Map
scala&gt; val test_map = Map[String, String]()
test_map: scala.collection.mutable.Map[String,String] = Map()                        
scala&gt; test_map(&quot;id_123&quot;)=&quot;刘备&quot;
scala&gt; test_map(&quot;id_124&quot;)=&quot;孙权&quot;
scala&gt; test_map(&quot;id_125&quot;)=&quot;曹操&quot;
scala&gt; test_map+=(&quot;id_001&quot;-&gt;&quot;吕布&quot;)
res10: test_map.type = Map(id_124 -&gt; 孙权, id_001 -&gt; 吕布, id_123 -&gt; 刘备, id_125 -&gt; 曹操)
scala&gt; test_map+=(&quot;id_002&quot;-&gt;&quot;关羽&quot;)
res11: test_map.type = Map(id_124 -&gt; 孙权, id_001 -&gt; 吕布, id_123 -&gt; 刘备, id_125 -&gt; 曹操, id_002 -&gt; 关羽)
scala&gt; test_map+=(&quot;id_003&quot;-&gt;&quot;张飞&quot;)
res12: test_map.type = Map(id_124 -&gt; 孙权, id_001 -&gt; 吕布, id_003 -&gt; 张飞, id_123 -&gt; 刘备, id_125 -&gt; 曹操, id_002 -&gt; 关羽)
上面简单的代码中使用了两种方式赋值，前三个使用的是类似于字典键值对的方式赋值，因为映射原理就是这个，在scala的交互式shell中前三个输入后均没有返回结果，后三个使用的是书中的赋值方式直接使用操作方法+来添加元素，可以看到：每一次的添加元素之后都有返回在添加完该元素后当下的map是什么内容
（2）不可变版本的map创建
不可变版本的map在scala中是缺省的也就是说默认的创建的map如果没有显式地指明类型（即导入模块）那么都认为是不可变的map
val test_map0=Map(&quot;id_123&quot;-&gt;&quot;刘备&quot;,&quot;id_124&quot;-&gt;&quot;孙权&quot;,&quot;id_125&quot;-&gt;&quot;曹操&quot;,&quot;id_001&quot;-&gt;&quot;吕布&quot;,&quot;id_002&quot;-&gt;&quot;关羽&quot;,&quot;id_003&quot;-&gt;&quot;张飞&quot;)
结果如下：
scala&gt; val test_map_new=Map(3-&gt;&quot;刘备&quot;,4-&gt;&quot;孙权&quot;,5-&gt;&quot;曹操&quot;,0-&gt;&quot;吕布&quot;,1-&gt;&quot;关羽&quot;,2-&gt;&quot;张飞&quot;)
test_map_new: scala.collection.immutable.Map[Int,String] = Map(0 -&gt; 吕布, 5 -&gt; 曹操, 1 -&gt; 关羽, 2 -&gt; 张飞, 3 -&gt; 刘备, 4 -&gt; 孙权)
简单的实现遍历输出：
scala&gt; for (i
</code></pre>

<p>参考书籍：</p>

<h3 id="scala编程中文完整版">Scala编程中文完整版</h3>

<p>keep learning&hellip;</p>

<p>上述提供的链接可以下载使用这本书，欢迎交流学习！</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>