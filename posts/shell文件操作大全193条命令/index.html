<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell文件操作大全193条命令 | 开发者问答集锦</title>
    <meta property="og:title" content="shell文件操作大全193条命令 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell文件操作大全193条命令">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8193%E6%9D%A1%E5%91%BD%E4%BB%A4/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell文件操作大全193条命令</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p>1.创建文件夹<br />
#!/bin/sh<br />
mkdir -m 777 &ldquo;%%1&rdquo;</p>

<p>2.创建文件<br />
#!/bin/sh<br />
touch &ldquo;%%1&rdquo;</p>

<p>3.删除文件<br />
#!/bin/sh<br />
rm -if &ldquo;%%1&rdquo;</p>

<p>4.删除文件夹<br />
#!/bin/sh<br />
rm -rf &ldquo;%%1&rdquo;</p>

<p>5.删除一个目录下所有的文件夹<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
for dir2del in $direc/* ; do<br />
if [ -d $dir2del ]; then<br />
rm -rf $dir2del<br />
fi<br />
done</p>

<p>6.清空文件夹<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
rm -if $direc/*<br />
for dir2del in $direc/* ; do<br />
if [ -d $dir2del ]; then<br />
rm -rf $dir2del<br />
fi<br />
done</p>

<p>7.读取文件<br />
#!/bin/sh<br />
7.1.操作系统默认编码<br />
cat &ldquo;%%1&rdquo; | while read line; do<br />
echo $line;<br />
done</p>

<p>7.2.UTF-8编码<br />
cat &ldquo;%%1&rdquo; | while read line; do<br />
echo $line;<br />
done</p>

<p>7.3.分块读取<br />
cat &ldquo;%%1&rdquo; | while read line; do<br />
echo $line;<br />
done</p>

<p>8.写入文件<br />
#!/bin/sh<br />
cat &gt; &ldquo;%%1&rdquo; &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>tee &ldquo;%%1&rdquo; &gt; /dev/null &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>#sed -i &lsquo;$a %%2&rsquo; %%2</p>

<p>9.写入随机文件<br />
#!/bin/sh<br />
cat &gt; &ldquo;%%1&rdquo; &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>tee &ldquo;%%1&rdquo; &gt; /dev/null &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>#sed -i &lsquo;$a %%2&rsquo; %%2</p>

<p>10.读取文件属性<br />
#!/bin/bash<br />
file=%%1<br />
file=${file:?&lsquo;必须给出参数&rsquo;}<br />
if [ ! -e $file ]; then<br />
echo &ldquo;$file 不存在&rdquo;<br />
exit 1<br />
fi<br />
if [ -d $file ]; then<br />
echo &ldquo;$file 是一个目录&rdquo;<br />
if [ -x $file ]; then<br />
echo &ldquo;可以&rdquo;<br />
else<br />
echo &ldquo;不可以&rdquo;<br />
fi<br />
echo &ldquo;对此进行搜索&rdquo;<br />
elif [ -f $file ]; then<br />
echo &ldquo;$file 是一个正规文件&rdquo;<br />
else<br />
echo &ldquo;$file不是一个正规文件&rdquo;<br />
fi<br />
if [ -O $file ]; then<br />
echo &ldquo;你是$file的拥有者&rdquo;<br />
else<br />
echo &ldquo;你不是$file的拥有者&rdquo;<br />
fi<br />
if [ -r $file ]; then<br />
echo &ldquo;你对$file拥有&rdquo;<br />
else<br />
echo &ldquo;你并不对$file拥有&rdquo;<br />
fi<br />
echo &ldquo;可读权限&rdquo;<br />
if [ -w $file ]; then<br />
echo &ldquo;你对$file拥有&rdquo;<br />
else<br />
echo &ldquo;你并不对$file拥有&rdquo;<br />
fi<br />
echo &ldquo;可写权限&rdquo;<br />
if [ -x $file -a ! -d $file ]; then<br />
echo &ldquo;你拥有对$file&rdquo;<br />
else<br />
echo &ldquo;你并不拥有对$file&rdquo;<br />
fi<br />
echo &ldquo;可执行的权限&rdquo;</p>

<p>11.写入文件属性<br />
#!/bin/bash<br />
#修改存放在ext2、ext3、ext4、xfs、ubifs、reiserfs、jfs等文件系统上的文件或目录属性，使用权限超级用户。<br />
#一些功能是由Linux内核版本来支持的，如果Linux内核版本低于2.2，那么许多功能不能实现。同样－D检查压缩文件中的错误的功能，需要2.5.19以上内核才能支持。另外，通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。<br />
chattr [-RV] [-+=AacDdijsSu] [-v version] 文件或目录<br />
－R：递归处理所有的文件及子目录。<br />
－V：详细显示修改内容，并打印输出。<br />
－：失效属性。<br />
＋：激活属性。<br />
= ：指定属性。<br />
A：Atime，告诉系统不要修改对这个文件的最后访问时间。<br />
S：Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。<br />
a：Append
Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件。<br />
i：Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。<br />
D：检查压缩文件中的错误。<br />
d：No dump，在进行文件系统备份时，dump程序将忽略这个文件。<br />
C：Compress，系统以透明的方式压缩这个文件。从这个文件读取时，返回的是解压之后的数据；而向这个文件中写入数据时，数据首先被压缩之后才写入磁盘。<br />
S：Secure Delete，让系统在删除这个文件时，使用0填充文件所在的区域。<br />
u：Undelete，当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件。</p>

<p>12.枚举一个目录中的所有文件夹<br />
#!/bin/bash<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find &ldquo;%%1&rdquo; -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
#&ldquo;$path&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>13.复制文件夹<br />
#!/bin/sh<br />
cp -rf &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>14.复制一个目录下所有的文件夹到另一个目录下<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
for dir2cp in $direc/* ; do<br />
if [ -d $dir2cp ]; then<br />
cp $dir2cp &ldquo;%%2&rdquo;<br />
fi<br />
done</p>

<p>15.移动文件夹<br />
#!/bin/sh<br />
mv -rf &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>16.移动一个目录下所有的文件夹到另一个目录下<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
for dir2mv in $direc/* ; do<br />
if [ -d $dir2mv ]; then<br />
mv $dir2mv &ldquo;%%2&rdquo;<br />
fi<br />
done</p>

<p>17.以一个文件夹的框架在另一个目录下创建文件夹和空文件<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;%%2/${path:${#direc}+1}&rdquo;<br />
done<br />
IFS=$OLDIFS<br />
#cp -a &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>表达式 含义<br />
${#string}<br />
{#string}<br />
1，取得字符串长度<br />
string=abc12342341 //等号二边不要有空格<br />
echo ${#string} //结果11<br />
expr length $string //结果11<br />
expr &ldquo;$string&rdquo; : &ldquo;.*&rdquo; //结果11 分号二边要有空格,这里的:根match的用法差不多2，字符串所在位置<br />
expr index $string &lsquo;123&rsquo; //结果4
字符串对应的下标是从0开始的这个方法让我想起来了js的indexOf，各种语言对字符串的操作方法大方向都差不多，如果有语言基础的话，学习shell会很快的。<br />
3，从字符串开头到子串的最大长度<br />
expr match $string &lsquo;abc.<em>3&rsquo; //结果9个人觉得这个函数的用处不大，为什么要从开头开始呢。<br />
4，字符串截取<br />
echo ${string:4} //2342341 从第4位开始截取后面所有字符串<br />
echo ${string:3:3} //123 从第3位开始截取后面3位<br />
echo ${string:3:6} //123423 从第3位开始截取后面6位<br />
echo ${string: -4} //2341 ：右边有空格 截取后4位<br />
echo ${string:(-4)} //2341 同上<br />
expr substr $string 3 3 //123 从第3位开始截取后面3位上面的方法让我想起了，php的substr函数，后面截取的规则是一样的。<br />
5，匹配显示内容<br />
//例3中也有match和这里的match不同，上面显示的是匹配字符的长度，而下面的是匹配的内容<br />
expr match $string &lsquo;\([a-c]</em>[0-9]<em>\)&rsquo; //abc12342341<br />
expr $string : &lsquo;\([a-c]</em>[0-9]\)&rsquo; //abc1<br />
expr $string : &lsquo;.*\([0-9][0-9][0-9]\)&rsquo; //341
显示括号中匹配的内容这里括号的用法，是不是根其他的括号用法有相似之处呢，<br />
6，截取不匹配的内容<br />
echo ${string#a*3} //42341 从$string左边开始，去掉最短匹配子串<br />
echo ${string#c*3} //abc12342341 这样什么也没有匹配到<br />
echo ${string#*c1*3} //42341 从$string左边开始，去掉最短匹配子串<br />
echo ${string##a*3} //41 从$string左边开始，去掉最长匹配子串<br />
echo ${string%3*1} //abc12342 从$string右边开始，去掉最短匹配子串<br />
echo ${string%%3*1} //abc12
从$string右边开始，去掉最长匹配子串这里要注意，必须从字符串的第一个字符开始，或者从最后一个开始，<br />
7，匹配并且替换<br />
echo ${string/23/bb} //abc1bb42341 替换一次<br />
echo ${string//23/bb} //abc1bb4bb41 双斜杠替换所有匹配<br />
echo ${string/#abc/bb} //bb12342341 #以什么开头来匹配，根php中的^有点像<br />
echo ${string/%41/bb} //abc123423bb %以什么结尾来匹配，根php中的$有点像</p>

<p>#!/bin/bash<br />
direc=$(pwd)<br />
for file in &ldquo;$(direc)/<em>&rdquo;<br />
do<br />
if [ &ldquo;${file##</em>.}&rdquo; = &ldquo;sh&rdquo; ]; then<br />
xterm -e bash $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;bin&rdquo; ]; then<br />
xterm -e $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;run&rdquo; ]; then<br />
xterm -e $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;bundle&rdquo; ]; then<br />
xterm -e $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;pl&rdquo; ]; then<br />
xterm -e perl $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;class&rdquo; ]; then<br />
xterm -e java ${file%.</em>}<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;rpm&rdquo; ]; then<br />
xterm -e rpm -ivh $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;rb&rdquo; ]; then<br />
xterm -e ruby $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;py&rdquo; ]; then<br />
xterm -e python $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;jar&rdquo; ]; then<br />
xterm -e java -jar $file<br />
fi<br />
done<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in <code>ls $path</code><br />
do<br />
if [ &ldquo;${file##<em>.}&rdquo; = &ldquo;sh&rdquo; ]; then<br />
xterm -e bash &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;bin&rdquo; ]; then<br />
xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;run&rdquo; ]; then<br />
xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;bundle&rdquo; ]; then<br />
xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;pl&rdquo; ]; then<br />
xterm -e perl &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;class&rdquo; ]; then<br />
xterm -e java &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;${file%.<em>}&ldquo;&rdquo;&ldquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;rpm&rdquo; ]; then<br />
xterm -e rpm -ivh &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;rb&rdquo; ]; then<br />
xterm -e ruby &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;py&rdquo; ]; then<br />
xterm -e python &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##*.}&rdquo; = &ldquo;jar&rdquo; ]; then<br />
xterm -e java -jar &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>18.复制文件<br />
#!/bin/sh<br />
cp %%1 %%2</p>

<p>19.复制一个目录下所有的文件到另一个目录<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; $(pwd)<br />
for file in &ldquo;$direc/*&rdquo;<br />
do<br />
cp &ldquo;$file&rdquo; &ldquo;%%1&rdquo;<br />
done</p>

<p>20.提取扩展名<br />
#!/bin/sh<br />
%%2=${%%1##.}</p>

<p>21.提取文件名<br />
#!/bin/sh<br />
%%2=&ldquo;$(basename %%1)&rdquo;</p>

<p>22.提取文件路径<br />
#!/bin/sh<br />
%%2=&ldquo;$(dirname %%1)&rdquo;</p>

<p>23.替换扩展名<br />
#!/bin/sh<br />
%%3=&ldquo;$(basename %%1)$%%2&rdquo;</p>

<p>24.追加路径<br />
#!/bin/sh<br />
%%3=&ldquo;$(dirname %%1)/$%%2&rdquo;</p>

<p>25.移动文件<br />
#!/bin/sh<br />
mv &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>26.移动一个目录下所有文件到另一个目录<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
OLDIFS=$IFS<br />
IFS=:<br />
for file in &ldquo;$(direc)/*&rdquo;<br />
do<br />
mv &ldquo;$file&rdquo; &ldquo;%%1&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>27.指定目录下搜索文件<br />
#!/bin/sh<br />
find -name &ldquo;%%1&rdquo;</p>

<p>28.打开文件对话框<br />
#!/bin/sh<br />
%%1=&ldquo;$(Xdialog &ndash;fselect &lsquo;~/&rsquo; 0 0 2&gt;&amp;1)&rdquo;</p>

<p>29.文件分割<br />
#!/bin/sh<br />
split -b 2k &ldquo;%%1&rdquo;</p>

<p>while read f1 f2 f3<br />
do<br />
echo $f1 &gt;&gt; f1<br />
echo $f2 &gt;&gt; f2<br />
echo $f3 &gt;&gt; f3<br />
done</p>

<p>#!/bin/bash<br />
linenum=<code>wc -l httperr8007.log| awk '{print $1}'</code><br />
n1=1<br />
file=1<br />
while [ $n1 -lt $linenum ]<br />
do<br />
n2=<code>expr $n1 + 999</code><br />
sed -n &ldquo;${n1}, ${n2}p&rdquo; httperr8007.log &gt; file_$file.log<br />
n1=<code>expr $n2 + 1</code><br />
file=<code>expr $file + 1</code><br />
done</p>

<p>其中httperr8007.log为你想分割的大文件，file_$file.log
为分割后的文件，最后为file_1.log，file_2.log，file_3.log……,分割完后的每个文件只有1000行（参数可以自己设置）</p>

<p>split 参数：<br />
-b ：后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等；<br />
-l ：以行数来进行分割；</p>

<p>#按每个文件1000行来分割除</p>

<p>split -l 1000 httperr8007.log httperr</p>

<p>httpaa，httpab，httpac &hellip;&hellip;..</p>

<p>#按照每个文件100K来分割</p>

<p>split -b 100k httperr8007.log http</p>

<p>httpaa，httpab，httpac &hellip;&hellip;..</p>

<p>#!/bin/bash<br />
if [ $# -ne 2 ]; then<br />
echo &lsquo;Usage: split file size(in bytes)&rsquo;<br />
exit<br />
fi</p>

<p>file=$1<br />
size=$2</p>

<p>if [ ! -f $file ]; then<br />
echo &ldquo;$file doesn&rsquo;t exist&rdquo;<br />
exit<br />
fi</p>

<p>#TODO: test if $size is a valid integer</p>

<p>filesize=<code>/bin/ls -l $file | awk '{print $5}'</code><br />
echo filesize: $filesize</p>

<p>let pieces=$filesize/$size<br />
let remain=$filesize-$pieces*$size<br />
if [ $remain -gt 0 ]; then<br />
let pieces=$pieces+1<br />
fi<br />
echo pieces: $pieces</p>

<p>i=0<br />
while [ $i -lt $pieces ];<br />
do<br />
echo split: $file.$i:<br />
dd if=$file of=$file.$i bs=$size count=1 skip=$i<br />
let i=$i+1<br />
done</p>

<p>echo &ldquo;#!/bin/bash&rdquo; &gt; merge</p>

<p>echo &ldquo;i=0&rdquo; &gt;&gt; merge<br />
echo &ldquo;while [ $i -lt $pieces ];&rdquo; &gt;&gt; merge<br />
echo &ldquo;do&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; if [ ! -f $file.$i ]; then&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i missed&rdquo; &gt;&gt; merge<br />
echo &ldquo; rm -f $file.merged&rdquo; &gt;&gt; merge<br />
echo &ldquo; exit&rdquo; &gt;&gt; merge<br />
echo &ldquo; fi&rdquo; &gt;&gt; merge<br />
echo &ldquo; dd if=$file.$i of=$file.merged bs=$size count=1 seek=$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; let i=$i+1&rdquo; &gt;&gt; merge<br />
echo &ldquo;done&rdquo; &gt;&gt; merge<br />
chmod u+x merge&rsquo;</p>

<p>30.文件合并<br />
#!/bin/sh<br />
cp &ldquo;%%1&rdquo;+&ldquo;%%2&rdquo; &ldquo;%%3&rdquo;</p>

<p>exec 3 exec 4 while read f1 do<br />
echo $f1 $f2 &gt;&gt; join.txt<br />
done</p>

<p>#!/bin/bash<br />
if [ $# -ne 2 ]; then<br />
echo &lsquo;Usage: split file size(in bytes)&rsquo;<br />
exit<br />
fi</p>

<p>file=$1<br />
size=$2</p>

<p>if [ ! -f $file ]; then<br />
echo &ldquo;$file doesn&rsquo;t exist&rdquo;<br />
exit<br />
fi</p>

<p>#TODO: test if $size is a valid integer</p>

<p>filesize=<code>/bin/ls -l $file | awk '{print $5}'</code><br />
echo filesize: $filesize</p>

<p>let pieces=$filesize/$size<br />
let remain=$filesize-$pieces*$size<br />
if [ $remain -gt 0 ]; then<br />
let pieces=$pieces+1<br />
fi<br />
echo pieces: $pieces</p>

<p>i=0<br />
while [ $i -lt $pieces ];<br />
do<br />
echo split: $file.$i:<br />
dd if=$file of=$file.$i bs=$size count=1 skip=$i<br />
let i=$i+1<br />
done</p>

<p>echo &ldquo;#!/bin/bash&rdquo; &gt; merge</p>

<p>echo &ldquo;i=0&rdquo; &gt;&gt; merge<br />
echo &ldquo;while [ $i -lt $pieces ];&rdquo; &gt;&gt; merge<br />
echo &ldquo;do&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; if [ ! -f $file.$i ]; then&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i missed&rdquo; &gt;&gt; merge<br />
echo &ldquo; rm -f $file.merged&rdquo; &gt;&gt; merge<br />
echo &ldquo; exit&rdquo; &gt;&gt; merge<br />
echo &ldquo; fi&rdquo; &gt;&gt; merge<br />
echo &ldquo; dd if=$file.$i of=$file.merged bs=$size count=1 seek=$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; let i=$i+1&rdquo; &gt;&gt; merge<br />
echo &ldquo;done&rdquo; &gt;&gt; merge<br />
chmod u+x merge&rsquo;</p>

<p>31.文件简单加密<br />
#!/bin/bash<br />
#make test &amp;&amp; make strings &amp;&amp; sudo make install<br />
shc -r -f %%1.sh<br />
#%%1.x<br />
#%%1.x.c</p>

<p>32.文件简单解密<br />
#!/bin/bash<br />
#make test &amp;&amp; make strings &amp;&amp; sudo make install<br />
shc -r -f %%1.sh<br />
#%%1.x<br />
#%%1.x.c</p>

<p>33.读取ini文件属性<br />
#!/bin/bash<br />
if [ &ldquo;$%%3&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">1</a></sup><em>$/d<br />
s/;.</em>$//<br />
p<br />
}&rdquo; $1<br />
elif [ &ldquo;$%%4&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">2</a></sup><em>$/d<br />
s/;.</em>$//<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">3</a></sup><em>$%%3[ | ]</em>=[ | ]<em>\(.</em>\)[ | ]<em>/\1/p<br />
}&rdquo; $1<br />
else<br />
if [ &ldquo;$%%4&rdquo; = &ldquo;#&rdquo; ];then<br />
sed &ldquo;/\[$%%2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">4</a></sup><em>$%%3[ | ]</em>=.<em>/ /<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $1<br />
else<br />
sed &ldquo;/\[$2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">5</a></sup><em>$%%3[ | ]</em>=.*/$%%3=$%%4/<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $%%1<br />
fi<br />
fi</p>

<p>34.合并一个文件下所有的文件<br />
#!/bin/sh<br />
cat $(ls |grep -E &lsquo;%%1\.&lsquo;) &gt; %%1</p>

<p>#!/bin/bash<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find %%1 -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in $path/<em>.c $path/</em>.cpp<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \*.[A-Za-z]+ ]]; then<br />
#&ldquo;$(path)/$(file)&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>#!/bin/bash<br />
cat &lt; combine.c<br />
#include<br />
int main()<br />
{<br />
FILE *f1,*f2,*f3;<br />
f1=fopen(&ldquo;a1.txt&rdquo;,&ldquo;r&rdquo;);<br />
f2=fopen(&ldquo;a2.txt&rdquo;,&ldquo;r&rdquo;);<br />
f3=fopen(&ldquo;a3.txt&rdquo;,&ldquo;w&rdquo;);<br />
int a,b;<br />
a=getw(f1); /<em>从a1.txt和a2.txt中分别取最小的数a和b</em>/<br />
b=getw(f2);<br />
while(!feof(f1)&amp;&amp;!feof(f2)) /<em>两个文件都没结束时，执行循环、比较</em>/<br />
{<br />
if(a&lt;=b)<br />
{<br />
putw(a,f3);<br />
a=getw(f1);<br />
}<br />
else<br />
{putw(b,f3);<br />
b=getw(f2);<br />
}<br />
}<br />
if(feof(f1)) /<em>文件a1.txt结束时，把a2.txt中的数全部输入a3.txt</em>/<br />
{putw(b,f3);<br />
while((b=getw(f2))!=EOF)<br />
putw(b,f3);<br />
}<br />
if(feof(f2)) /<em>同上</em>/<br />
{<br />
putw(a,f3);<br />
while((a=getw(f1))!=EOF)<br />
putw(a,f3);<br />
}<br />
fclose(f1);<br />
fclose(f2);<br />
fclose(f3);<br />
printf(&ldquo;已完成!&rdquo;);<br />
return 0;<br />
}<br />
EOF<br />
gcc -o combine combine.c<br />
if [ $? -eq 0 ]; then<br />
./combine<br />
else<br />
echo &lsquo;Compile ERROR&rsquo;<br />
fi</p>

<p>35.写入ini文件属性<br />
#!/bin/bash<br />
if [ &ldquo;$%%3&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">6</a></sup><em>$/d<br />
s/;.</em>$//<br />
p<br />
}&rdquo; $1<br />
elif [ &ldquo;$%%4&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">7</a></sup><em>$/d<br />
s/;.</em>$//<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">8</a></sup><em>$%%3[ | ]</em>=[ | ]<em>\(.</em>\)[ | ]<em>/\1/p<br />
}&rdquo; $1<br />
else<br />
if [ &ldquo;$%%4&rdquo; = &ldquo;#&rdquo; ];then<br />
sed &ldquo;/\[$%%2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">9</a></sup><em>$%%3[ | ]</em>=.<em>/ /<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $%%1<br />
else<br />
sed &ldquo;/\[$%%2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">10</a></sup><em>$%%3[ | ]</em>=.*/$%%3=$%%4/<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $%%1<br />
fi<br />
fi</p>

<p>36.获得当前路径<br />
#!/bin/sh<br />
%%1=$(pwd)</p>

<p>37.读取XML数据库</p>

<p>如何通过shell命令行读取xml文件中某个属性所对应的值？<br />
例如：<br />
BuildVersion 5<br />
我希望能够通过Unix shell命令对属性键的名称BuildVersion进行查询，返回的结果是5，如何实现呀？<br />
#!/bin/bash<br />
grep BuildVersion|sed &rsquo;s/.<em>&lt;.&gt;\([^.</em>/\1/&rsquo;</p>

<p>结果返回的是“BuildVersion”，而不是“5”，如果要查询BuildVersion自动返回数值5应当如何写？</p>

<p>应该没错的。试一下： echo &ldquo;BuildVersion 5&rdquo;|grep BuildVersion|sed
&rsquo;s/.<em>&lt;.&gt;\([^.</em>/\1/&lsquo;我在SL的终端里试，返回值是5</p>

<p>目前需要从xml文件提取数据，想做一个xmlparser.sh<br />
xml 类似这样</p>

<p>希望输入 xmlparser.sh a.xml hostip可以返回192.168.0.1</p>

<p>#!/bin/sh</p>

<p>if [ $# -ne 2 ];then<br />
echo &ldquo;Usage: $0  &ldquo;<br />
exit 0<br />
fi</p>

<p>grep $2 $1|awk &lsquo;{print $2}&rsquo;|grep -o &ldquo;[0-9.]*&rdquo;</p>

<p>把<br />
grep $2 $1|awk &lsquo;{print $2}&rsquo;|grep -o &ldquo;[0-9.]*&rdquo;<br />
改成<br />
grep $2 $1|awk &lsquo;{print $2}&rsquo;|grep -Eo &ldquo;[0-9.]+&rdquo;<br />
楼上这个有问题，如果我要得到的是</p>

<p>中的sharename，那么，呵呵，就错了</p>

<p>我觉得应该先定位到第二个参数“$2”的位置，然后再提取“=”后面的内容</p>

<p>这里有个完整的实现：<br />
Parse Simple XML Files using Bash – Extract Name Value Pairs and Attributes<br />
<a href="http://www.humbug.in/2010/parse-simple-xml-files-using-bash-extract-name-">http://www.humbug.in/2010/parse-simple-xml-files-using-bash-extract-name-</a>
value-pairs-and-attributes/</p>

<p>不过需要安装xmllint.</p>

<p>设计到对多个xml文件进行element的读取和列表。有人做过么？<br />
举个例子，<br />
多个xml文件里面都有</p>

<p>xxx</p>

<p>通过shell读取，然后合并到一起，再生成一个新的xml，但是其他元素不变。</p>

<p>aaa</p>

<p>bbb</p>

<p>如果格式异常简单，没有特例，那么可以用shell实现<br />
如果有可能格式复杂，因为shell的命令所使用的正则表达式都不支持跨行匹配，所以用shell来解决这个问题就绕圈子了。<br />
用perl来作这个工作最直接、简单。perl的XML:DOM模块是专门处理XML文件的。</p>

<p>偶倒是觉得,用PHP写Scripts也很方便,功能强大,而且,跨平台,</p>

<p>#!/bin/sh</p>

<p>sed -n &lsquo;//{</p>

<p>N;</p>

<p>/\n[[:space:]]*/{</p>

<p>N;</p>

<p>/.*/p</p>

<p>}</p>

<p>D;</p>

<p>n</p>

<p>}&rsquo;</p>

<p>这小段代码能把一个xml文件中,你要的东西拿出来.<br />
你可以用for file in $*把这些信息都&gt;&gt;tmpfile中.<br />
然后用sed 在指定文件的指定位置用r命令把tmpfile粘贴进来~~~~</p>

<p>大思路如此^_^ 我想有这个东西(只要能正确的跑出结果)后面就不难了吧&hellip;</p>

<p>Name<br />
xmllint — command line XML tool</p>

<p>Synopsis<br />
xmllint [[&ndash;version] | [&ndash;debug] | [&ndash;shell] | [&ndash;debugent] | [&ndash;copy] |
[&ndash;recover] | [&ndash;noent] | [&ndash;noout] | [&ndash;nonet] | [&ndash;htmlout] | [&ndash;nowrap] |
[&ndash;valid] | [&ndash;postvalid] | [&ndash;dtdvalid URL] | [&ndash;dtdvalidfpi FPI] |
[&ndash;timing] | [&ndash;output file] | [&ndash;repeat] | [&ndash;insert] | [&ndash;compress] |
[&ndash;html] | [&ndash;xmlout] | [&ndash;push] | [&ndash;memory] | [&ndash;maxmem nbbytes] |
[&ndash;nowarning] | [&ndash;noblanks] | [&ndash;nocdata] | [&ndash;format] | [&ndash;encode encoding]
| [&ndash;dropdtd] | [&ndash;nsclean] | [&ndash;testIO] | [&ndash;catalogs] | [&ndash;nocatalogs] |
[&ndash;auto] | [&ndash;xinclude] | [&ndash;noxincludenode] | [&ndash;loaddtd] | [&ndash;dtdattr] |
[&ndash;stream] | [&ndash;walker] | [&ndash;pattern patternvalue] | [&ndash;chkregister] |
[&ndash;relaxng] | [&ndash;schema] | [&ndash;c14n]] [xmlfile]</p>

<p>Introduction<br />
The xmllint program parses one or more XML files, specified on the command
line as xmlfile. It prints various types of output, depending upon the options
selected. It is useful for detecting errors both in XML code and in the XML
parser itself.</p>

<p>It is included in libxml2.</p>

<p>Options<br />
--version<br />
Display the version of libxml2 used.<br />
--debug<br />
Parse a file and output an annotated tree of the in-memory version of the
document.<br />
--shell<br />
Run a navigating shell. Details on available commands in shell mode are below.<br />
--debugent<br />
Debug the entities defined in the document.<br />
--copy<br />
Test the internal copy implementation.<br />
--recover<br />
Output any parsable portions of an invalid document.<br />
--noent<br />
Substitute entity values for entity references. By default, xmllint leaves
entity references in place.<br />
--nocdata<br />
Substitute CDATA section by equivalent text nodes.<br />
--nsclean<br />
Remove redundant namespace declarations.<br />
--noout<br />
Suppress output. By default, xmllint outputs the result tree.<br />
--htmlout<br />
Output results as an HTML file. This causes xmllint to output the necessary
HTML tags surrounding the result tree output so the results can be displayed
in a browser.<br />
--nowrap<br />
Do not output HTML doc wrapper.<br />
--valid<br />
Determine if the document is a valid instance of the included Document Type
Definition (DTD). A DTD to be validated against also can be specified at the
command line using the &ndash;dtdvalid option. By default, xmllint also checks to
determine if the document is well-formed.<br />
--postvalid<br />
Validate after parsing is completed.<br />
--dtdvalid URL<br />
Use the DTD specified by URL for validation.<br />
--dtdvalidfpi FPI<br />
Use the DTD specified by the Public Identifier FPI for validation, note that
this will require a Catalog exporting that Public Identifier to work.<br />
--timing<br />
Output information about the time it takes xmllint to perform the various
steps.<br />
--output file<br />
Define a file path where xmllint will save the result of parsing. Usually the
programs build a tree and save it on stdout, with this option the result XML
instance will be saved onto a file.<br />
--repeat<br />
Repeat 100 times, for timing or profiling.<br />
--insert<br />
Test for valid insertions.<br />
--compress<br />
Turn on gzip compression of output.<br />
--html<br />
Use the HTML parser.<br />
--xmlout<br />
Used in conjunction with &ndash;html. Usually when HTML is parsed the document is
saved with the HTML serializer, but with this option the resulting document is
saved with the XML serializer. This is primarily used to generate XHTML from
HTML input.<br />
--push<br />
Use the push mode of the parser.<br />
--memory<br />
Parse from memory.<br />
--maxmem nnbytes<br />
Test the parser memory support. nnbytes is the maximum number of bytes the
library is allowed to allocate. This can also be used to make sure batch
processing of XML files will not exhaust the virtual memory of the server
running them.<br />
--nowarning<br />
Do not emit warnings from the parser and/or validator.<br />
--noblanks<br />
Drop ignorable blank spaces.<br />
--format<br />
Reformat and reindent the output. The $XMLLINT_INDENT environment variable
controls the indentation (default value is two spaces &ldquo; &ldquo;).<br />
--testIO<br />
Test user input/output support.<br />
--encode encoding<br />
Output in the given encoding.<br />
--catalogs<br />
Use the catalogs from $SGML_CATALOG_FILES. Otherwise /etc/xml/catalog is used
by default.<br />
--nocatalogs<br />
Do not use any catalogs.<br />
--auto<br />
Generate a small document for testing purposes.<br />
--xinclude<br />
Do XInclude processing.<br />
--noxincludenode<br />
Do XInclude processing but do not generate XInclude start and end nodes.<br />
--loaddtd<br />
Fetch external DTD.<br />
--dtdattr<br />
Fetch external DTD and populate the tree with inherited attributes.<br />
--dropdtd<br />
Remove DTD from output.<br />
--stream<br />
Use streaming API - useful when used in combination with &ndash;relaxng or &ndash;valid
options for validation of files that are too large to be held in memory.<br />
--walker<br />
Test the walker module, which is a reader interface but for a document tree,
instead of using the reader API on an unparsed document it works on a existing
in-memory tree. Used in debugging.<br />
--chkregister<br />
Turn on node registration. Useful for developers testing libxml2 node tracking
code.<br />
--pattern patternvalue<br />
Used to exercise the pattern recognition engine, which can be used with the
reader interface to the parser. It allows to select some nodes in the document
based on an XPath (subset) expression. Used for debugging.<br />
--relaxng schema<br />
Use RelaxNG file named schema for validation.<br />
--schema schema<br />
Use a W3C XML Schema file named schema for validation.<br />
--c14n<br />
Use the W3C XML Canonicalisation (C14N) to serialize the result of parsing to
stdout. It keeps comments in the result.<br />
Shell<br />
xmllint offers an interactive shell mode invoked with the &ndash;shell command.
Available commands in shell mode include:</p>

<p>base<br />
display XML base of the node<br />
bye<br />
leave shell<br />
cat node<br />
Display node if given or current node.<br />
cd path<br />
Change the current node to path (if given and unique) or root if no argument
given.<br />
dir path<br />
Dumps information about the node (namespace, attributes, content).<br />
du path<br />
Show the structure of the subtree under path or the current node.<br />
exit<br />
Leave the shell.<br />
help<br />
Show this help.<br />
free<br />
Display memory usage.<br />
load name<br />
Load a new document with the given name.<br />
ls path<br />
List contents of path (if given) or the current directory.<br />
pwd<br />
Display the path to the current node.<br />
quit<br />
Leave the shell.<br />
save name<br />
Saves the current document to name if given or to the original name.<br />
validate<br />
Check the document for error.<br />
write name<br />
Write the current node to the given filename.<br />
Catalogs<br />
Catalog behavior can be changed by redirecting queries to the user&rsquo;s own set
of catalogs. This can be done by setting the XML_CATALOG_FILES environment
variable to a list of catalogs. An empty one should deactivate loading the
default /etc/xml/catalog default catalog.</p>

<p>Debugging Catalogs<br />
Setting the environment variable XML_DEBUG_CATALOG using the command &ldquo;export
XML_DEBUG_CATALOG=&rdquo; outputs debugging information related to catalog
operations.</p>

<p>Error Return Codes<br />
On the completion of execution, Xmllint returns the following error codes:</p>

<p>0<br />
No error<br />
1<br />
Unclassified<br />
2<br />
Error in DTD<br />
3<br />
Validation error<br />
4<br />
Validation error<br />
5<br />
Error in schema compilation<br />
6<br />
Error writing output<br />
7<br />
Error in pattern (generated when [&ndash;pattern] option is used)<br />
8<br />
Error in Reader registration (generated when [&ndash;chkregister] option is used)<br />
9<br />
Out of memory error</p>

<p>Parse Simple XML Files using Bash – Extract Name Value Pairs and Attributes</p>

<p>2 Comments<br />
1<br />
Tweet</p>

<p>Pratik Sinha | July 31, 2010</p>

<p>I have written up a simple routine par<strong><em>ML to parse simple XML files to
extract unique name values pairs and their attributes. The script extracts all
xml tags of the format xyz and dynamically creates bash variables which hold
values of the attributes as well as the elements. This is a good solution, if
you don’t wish to use xpath for some simple xml files. However you will need
xmllint installed on your system to use the script. Here’s a sample script
which uses the par</em></strong>ML function<br />
#!/bin/bash<br />
xmlFile=$1</p>

<p>function par**<em>ML() {<br />
elemList=( $(cat $xmlFile | tr &lsquo;\n&rsquo; &lsquo; &rsquo; | XMLLINT_INDENT=&ldquo;&rdquo; xmllint &ndash;format -
| /bin/grep -e &ldquo;$&rdquo; | while read line; do \<br />
echo $line | sed -e &rsquo;s/^.</em>&rsquo; -f 1; \<br />
done) )</p>

<p>totalNoOfTags=${#elemList[@]}; ((totalNoOfTags&ndash;))<br />
suffix=$(echo ${elemList[$totalNoOfTags]} | tr -d &lsquo;&gt;&rsquo;)<br />
suffix=&ldquo;${suffix}_&rdquo;</p>

<p>for (( i = 0 ; i &lt; ${#elemList[@]} ; i++ )); do<br />
elem=${elemList[$i]}<br />
elemLine=$(cat $xmlFile | tr &lsquo;\n&rsquo; &lsquo; &rsquo; | XMLLINT<em>INDENT=&ldquo;&rdquo; xmllint &ndash;format - |
/bin/grep &ldquo;$elem&gt;&rdquo;)<br />
echo $elemLine | grep -e &ldquo;^[^ ]<em>&gt;$&rdquo; 1&gt;/dev/null 2&gt;&amp;1<br />
if [ &ldquo;0&rdquo; = &ldquo;$?&rdquo; ]; then<br />
continue<br />
fi<br />
elemVal=$(echo $elemLine | tr &lsquo;\011&rsquo; &lsquo;\040&rsquo;| sed -e &rsquo;s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">11</a></sup></em>//&rsquo; -e
&rsquo;s/^&lt;.&gt;\([^$/\1/&rsquo; | sed -e &rsquo;s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">12</a></sup><em>//&rsquo; | sed -e &rsquo;s/[ ]</em>$//&lsquo;)<br />
xmlElem=&ldquo;${suffix}$(echo $elem | sed &rsquo;s/-/</em>/g&rsquo;)&rdquo;<br />
eval ${xmlElem}=<code>echo -ne \&quot;&quot;${elemVal}&quot;\&quot;</code><br />
attrList=($(cat $xmlFile | tr &lsquo;\n&rsquo; &lsquo; &rsquo; | XMLLINT_INDENT=&ldquo;&rdquo; xmllint &ndash;format -
| /bin/grep &ldquo;$elem&gt;&rdquo; | tr &lsquo;\011&rsquo; &lsquo;\040&rsquo; | sed -e &rsquo;s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">13</a></sup>*//&rsquo; | cut -d &lsquo;&gt;&rsquo; -f 1
| sed -e &rsquo;s/^&lsquo;))<br />
for (( j = 0 ; j &lt; ${#attrList[@]} ; j++ )); do<br />
attr=${attrList[$j]}<br />
((j++))<br />
attrVal=$(echo ${attrList[$j]} | tr &lsquo;&gt;&rsquo; &lsquo; &lsquo;)<br />
attrName=<code>echo -ne ${xmlElem}_${attr}</code><br />
eval ${attrName}=<code>echo -ne \&quot;&quot;${attrVal}&quot;\&quot;</code><br />
done<br />
done<br />
}</p>

<p>par***ML<br />
echo &ldquo;$status_xyz | $status_abc | $status_pqr&rdquo; #Variables for each XML ELement<br />
echo &ldquo;$status_xyz_arg1 | $status_abc_arg2 | $status_pqr_arg3 |
$status_pqr_arg4&rdquo; #Variables for each XML Attribute<br />
echo &ldquo;&rdquo;</p>

<p>#All the variables that were produced by the par***ML function<br />
set | /bin/grep -e &ldquo;^$suffix&rdquo;</p>

<p>The XML File used for the above script example is:</p>

<p>a<br />
p<br />
x</p>

<p>The root tag, which in this case is “status”, is used as a suffix for all
variables. Once the XML file is passed to the function, it dynamically creates
the variables $status_xyz, $status_abc, $status_pqr, $status_xyz_arg1,
$status_abc_arg2, $status_pqr_arg3 and $status_pqr_arg4.</p>

<p>The output when the script is ran with the xml file as an argument is<br />
@$ bash par***ML.sh test.xml<br />
a | p | x<br />
1 | 2 | 3 | a phrase</p>

<p>status_abc=p<br />
status_abc_arg2=2<br />
status_pqr=x<br />
status_pqr_arg3=3<br />
status_pqr_arg4=&lsquo;a phrase&rsquo;<br />
status_xyz=a<br />
status_xyz_arg1=1</p>

<p>This script won’t work for XML files like the one below with duplicate element
names.</p>

<p>a<br />
p<br />
x</p>

<p>This script also won’t be able to extract attributes of elements without any
CDATA. For eg, the script won’t be able to create variables corresponding to .
It will only create the variables corresponding to abc.</p>

<p>abc</p>

<p>38.写入XML数据库<br />
#!/bin/bash</p>

<p>39.ZIP压缩文件<br />
#!/bin/sh<br />
zip -r &ldquo;/%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>40.ZIP解压缩<br />
#!/bin/sh<br />
unzip -x &ldquo;/%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>41.获得应用程序完整路径<br />
#!/bin/bash</p>

<p>42.ZIP压缩文件夹<br />
#!/bin/bash</p>

<p>43.递归删除目录下的文件<br />
#!/bin/bash<br />
rm -if &ldquo;%%1/<em>&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find %%1 -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in $path/</em>.c $path/<em>.cpp<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \</em>.[A-Za-z]+ ]]; then<br />
#&ldquo;$(path)/$(file)&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>44.IDEA加密算法<br />
#!/bin/bash</p>

<p>45.RC6算法<br />
#!/bin/bash<br />
cat &lt; rc6.c<br />
#include<br />
/* Timing data for RC6 (rc6.c)</p>

<p>128 bit key:<br />
Key Setup: 1632 cycles<br />
Encrypt: 270 cycles = 94.8 mbits/sec<br />
Decrypt: 226 cycles = 113.3 mbits/sec<br />
Mean: 248 cycles = 103.2 mbits/sec</p>

<p>192 bit key:<br />
Key Setup: 1885 cycles<br />
Encrypt: 267 cycles = 95.9 mbits/sec<br />
Decrypt: 235 cycles = 108.9 mbits/sec<br />
Mean: 251 cycles = 102.0 mbits/sec</p>

<p>256 bit key:<br />
Key Setup: 1877 cycles<br />
Encrypt: 270 cycles = 94.8 mbits/sec<br />
Decrypt: 227 cycles = 112.8 mbits/sec<br />
Mean: 249 cycles = 103.0 mbits/sec</p>

<p>*/</p>

<p>#include &ldquo;../std_defs.h&rdquo;</p>

<p>static char *alg_name[] = { &ldquo;rc6&rdquo;, &ldquo;rc6.c&rdquo;, &ldquo;rc6&rdquo; };</p>

<p>char **cipher_name()<br />
{<br />
return alg_name;<br />
}</p>

<p>#define f_rnd(i,a,b,c,d) \<br />
u = rotl(d * (d + d + 1), 5); \<br />
t = rotl(b * (b + b + 1), 5); \<br />
a = rotl(a ^ t, u) + l_key; \<br />
c = rotl(c ^ u, t) + l_key[i + 1]</p>

<p>#define i_rnd(i,a,b,c,d) \<br />
u = rotl(d * (d + d + 1), 5); \<br />
t = rotl(b * (b + b + 1), 5); \<br />
c = rotr(c - l_key[i + 1], t) ^ u; \<br />
a = rotr(a - l_key, u) ^ t</p>

<p>u4byte l_key[44]; /* storage for the key schedule */</p>

<p>/* initialise the key schedule from the user supplied key */</p>

<p>u4byte *set_key(const u4byte in_key[], const u4byte key_len)<br />
{ u4byte i, j, k, a, b, l[8], t;</p>

<p>l_key[0] = 0xb7e15163;</p>

<p>for(k = 1; k &lt; 44; ++k)</p>

<p>l_key[k] = l_key[k - 1] + 0x9e3779b9;</p>

<p>for(k = 0; k &lt; key_len / 32; ++k)</p>

<p>l[k] = in_key[k];</p>

<p>t = (key_len / 32) - 1; // t = (key_len / 32);</p>

<p>a = b = i = j = 0;</p>

<p>for(k = 0; k &lt; 132; ++k)<br />
{ a = rotl(l_key + a + b, 3); b += a;<br />
b = rotl(l[j] + b, b);<br />
l_key = a; l[j] = b;<br />
i = (i == 43 ? 0 : i + 1); // i = (i + 1) % 44;<br />
j = (j == t ? 0 : j + 1); // j = (j + 1) % t;<br />
}</p>

<p>return l_key;<br />
};</p>

<p>/* encrypt a block of text */</p>

<p>void encrypt(const u4byte in_blk[4], u4byte out_blk[4])<br />
{ u4byte a,b,c,d,t,u;</p>

<p>a = in_blk[0]; b = in_blk[1] + l_key[0];<br />
c = in_blk[2]; d = in_blk[3] + l_key[1];</p>

<p>f_rnd( 2,a,b,c,d); f_rnd( 4,b,c,d,a);<br />
f_rnd( 6,c,d,a,b); f_rnd( 8,d,a,b,c);<br />
f_rnd(10,a,b,c,d); f_rnd(12,b,c,d,a);<br />
f_rnd(14,c,d,a,b); f_rnd(16,d,a,b,c);<br />
f_rnd(18,a,b,c,d); f_rnd(20,b,c,d,a);<br />
f_rnd(22,c,d,a,b); f_rnd(24,d,a,b,c);<br />
f_rnd(26,a,b,c,d); f_rnd(28,b,c,d,a);<br />
f_rnd(30,c,d,a,b); f_rnd(32,d,a,b,c);<br />
f_rnd(34,a,b,c,d); f_rnd(36,b,c,d,a);<br />
f_rnd(38,c,d,a,b); f_rnd(40,d,a,b,c);</p>

<p>out_blk[0] = a + l_key[42]; out_blk[1] = b;<br />
out_blk[2] = c + l_key[43]; out_blk[3] = d;<br />
};</p>

<p>/* decrypt a block of text */</p>

<p>void decrypt(const u4byte in_blk[4], u4byte out_blk[4])<br />
{ u4byte a,b,c,d,t,u;</p>

<p>d = in_blk[3]; c = in_blk[2] - l_key[43];<br />
b = in_blk[1]; a = in_blk[0] - l_key[42];</p>

<p>i_rnd(40,d,a,b,c); i_rnd(38,c,d,a,b);<br />
i_rnd(36,b,c,d,a); i_rnd(34,a,b,c,d);<br />
i_rnd(32,d,a,b,c); i_rnd(30,c,d,a,b);<br />
i_rnd(28,b,c,d,a); i_rnd(26,a,b,c,d);<br />
i_rnd(24,d,a,b,c); i_rnd(22,c,d,a,b);<br />
i_rnd(20,b,c,d,a); i_rnd(18,a,b,c,d);<br />
i_rnd(16,d,a,b,c); i_rnd(14,c,d,a,b);<br />
i_rnd(12,b,c,d,a); i_rnd(10,a,b,c,d);<br />
i_rnd( 8,d,a,b,c); i_rnd( 6,c,d,a,b);<br />
i_rnd( 4,b,c,d,a); i_rnd( 2,a,b,c,d);</p>

<p>out_blk[3] = d - l_key[1]; out_blk[2] = c;<br />
out_blk[1] = b - l_key[0]; out_blk[0] = a;<br />
};<br />
int main()<br />
{</p>

<p>return 0;<br />
}<br />
EOF<br />
gcc -o rc6 rc6.c<br />
if [ $? -eq 0 ]; then<br />
./combine<br />
else<br />
echo &lsquo;Compile ERROR&rsquo;<br />
fi</p>

<p>46.Grep<br />
#!/bin/bash<br />
grep -qE %%1 %%2</p>

<p>47.直接创建多级目录<br />
#!/bin/bash<br />
mkdir -p %%1</p>

<p>48.批量重命名<br />
#!/bin/bash<br />
find $PWD -type f -name &lsquo;*\.cpp&rsquo; |sed s/&rsquo;\.cpp&rsquo;//g|awk &lsquo;{MV = &ldquo;mv&rdquo;};{C =
&ldquo;\.c&rdquo;};{ CPP=&rdquo;\.cpp&rdquo;}; {print MV, $1 CPP , $1 C}&lsquo;|sh<br />
ls | awk -F &lsquo;-&rsquo; &lsquo;{print &ldquo;mv &ldquo;$0&rdquo; &ldquo;$2}&rsquo; #去掉带&rsquo;-&lsquo;的前缀</p>

<p>49.文本查找替换<br />
#!/bin/bash<br />
sed -e &rsquo;s:%%2:%%3:g&rsquo; %%1<br />
#sed -e &rsquo;s/%%2/%%3/g&rsquo; %%1</p>

<p>50.文件关联<br />
#!/bin/bash</p>

<p>51.批量转换编码从GB2312到Unicode<br />
#!/bin/bash<br />
scode=&ldquo;gbk&rdquo;<br />
dcode=&ldquo;ucs2&rdquo;<br />
for FILE in $(find $(pwd) -type f)<br />
do<br />
TMP_file=$(mktemp -p $(pwd))<br />
if [ -f $FILE ]; then<br />
Fright=$(stat -c %a $FILE)<br />
Fuser=$(stat -c %U $FILE)<br />
Fgrp=$(stat -c %G $FILE)<br />
iconv -f $scode -t $dcode $FILE -o $TMP_file<br />
mv $TMP_file $FILE<br />
chmod $Fright $FILE<br />
chown $Fuser.$Fgrp $FILE<br />
fi<br />
done</p>

<p>52.设置JDK环境变量<br />
#!/bin/bash<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;<em>.bin&rsquo; \) -print0 | xargs -0 chmod +x<br />
find -type f \( -iname &lsquo;</em>.bin&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.bin)<br />
xterm -e &ldquo;$filename&rdquo; &amp;&amp; rm -if &ldquo;$filename&rdquo;<br />
;;<br />
esac<br />
done<br />
OLDIFS=$IFS<br />
IFS=$&rsquo;\n&rsquo;<br />
for line in <code>cat ~/.bashrc</code><br />
do<br />
if [[ &ldquo;$line&rdquo; =~ .<em>export.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ .<em>JAVA_HOME=.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]]; then<br />
javahome=$line<br />
fi<br />
fi<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ PATH=\$PATH:\$JAVA_HOME/bin:\$JAVA_HOME/jre/bin$
]];then<br />
javapath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ CLASSPATH=.:\$JAVA_HOME/lib:\$JAVA_HOME/jre/lib$
]];then<br />
classpath=$line<br />
fi<br />
done<br />
if [ ! -n &ldquo;$javahome&rdquo; ]; then<br />
sed -i &lsquo;$a export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_25&rsquo; ~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${javahome//\\/\\\\}&rsquo;:export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_32:g&rsquo;
~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$javapath&rdquo; ]; then<br />
sed -i &lsquo;$a export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&rsquo; ~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$classpath&rdquo; ]; then<br />
sed -i &lsquo;$a export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib&rsquo; ~/.bashrc<br />
fi<br />
IFS=$OLDIFS</p>

<p>#!/bin/bash<br />
shift<br />
OLDIFS=$IFS<br />
IFS=$&rsquo;\n&rsquo;<br />
for line in <code>cat ~/TestBash.txt</code> #~/.bashrc<br />
do<br />
if [[ &ldquo;$line&rdquo; =~ .<em>export.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ export\ CLASSPATH=.:\$JAVA_HOME/lib:\$JAVA_HOME/jre/lib$ ]];
then<br />
classpath=$line<br />
elif [[ &ldquo;$line&rdquo; =~ export\ PATH=\$PATH:\$CATALINA_HOME/bin$ ]]; then<br />
jbosspath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ .<em>JAVA_HOME=.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
javahome=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>CATALINA_HOME=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
catalinahome=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>TOMCAT_HOME=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
tomcathome=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>CATALINA_BASE=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
catalinabase=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>JBOSS_HOME=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
jbosshome=$line<br />
fi<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ ^PATH=\$PATH:\$JAVA_HOME/bin:\$JAVA_HOME/jre/bin$ ]];then<br />
javapath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ CLASSPATH=.:\$JAVA_HOME/lib:\$JAVA_HOME/jre/lib$
]];then<br />
classpath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ PATH=\$PATH:\$JBOSS_HOME/bin$ ]];then<br />
jbosspath=$line<br />
fi<br />
done<br />
if [ ! -n &ldquo;$javahome&rdquo; ]; then<br />
sed -i &lsquo;$a export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_24&rsquo; ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${javahome//\\/\\\\}&rsquo;:export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_24:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$javapath&rdquo; ]; then<br />
sed -i &lsquo;$a PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&rsquo; ~/TestBash.txt
#~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$classpath&rdquo; ]; then<br />
sed -i &lsquo;$a export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib&rsquo;
~/TestBash.txt #~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$catalinahome&rdquo; ]; then<br />
sed -i &lsquo;$a export CATALINA_HOME=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${catalinahome//\\/\\\\}&rsquo;:export CATALINA_HOME=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$tomcathome&rdquo; ]; then<br />
sed -i &lsquo;$a export TOMCAT_HOME=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${tomcathome//\\/\\\\}&rsquo;:export TOMCAT_HOME=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$catalinabase&rdquo; ]; then<br />
sed -i &lsquo;$a export CATALINA_BASE=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${catalinabase//\\/\\\\}&rsquo;:export CATALINA_BASE=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$jbosshome&rdquo; ]; then<br />
sed -i &lsquo;$a export JBOSS_HOME=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${jbosshome//\\/\\\\}&rsquo;:export JBOSS_HOME=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$jbosspath&rdquo; ]; then<br />
sed -i &lsquo;$a export PATH=$PATH:$CATALINA_HOME/bin&rsquo; ~/TestBash.txt #~/.bashrc<br />
fi<br />
IFS=$OLDIFS</p>

<p>53.批量转换编码从Unicode到GB2312<br />
#!/bin/bash<br />
scode=&ldquo;ucs2&rdquo;<br />
dcode=&ldquo;gbk&rdquo;<br />
for FILE in $(find $(pwd) -type f)<br />
do<br />
TMP_file=$(mktemp -p $(pwd))<br />
if [ -f $FILE ]; then<br />
Fright=$(stat -c %a $FILE)<br />
Fuser=$(stat -c %U $FILE)<br />
Fgrp=$(stat -c %G $FILE)<br />
iconv -f $scode -t $dcode $FILE -o $TMP_file<br />
mv $TMP_file $FILE<br />
chmod $Fright $FILE<br />
chown $Fuser.$Fgrp $FILE<br />
fi<br />
done</p>

<p>54.删除空文件夹<br />
#!/bin/bash<br />
rmdir -p %%1</p>

<p>55.GB2312文件转UTF-8格式<br />
#!/bin/bash<br />
iconv -f gbk -t utf8 %%1 -o %%2</p>

<p>56.UTF-8文件转GB2312格式<br />
#!/bin/bash<br />
iconv -f utf8 -t gbk %%1 -o %%2</p>

<p>57.获取文件路径的父路径<br />
#!/bin/bash<br />
%%1=basename $PWD</p>

<p>58.Unicode文件转UTF-8格式<br />
#!/bin/bash<br />
iconv -f ucs2 -t utf-8 %%1 -o %%2</p>

<p>59.CRC循环冗余校验<br />
#!/bin/bash<br />
cat &lt; crc.c<br />
#include</p>

<p>unsigned long int crc32_table[256];</p>

<p>unsigned long int ulPolynomial = 0x04c11db7;</p>

<p>unsigned long int Reflect(unsigned long int ref, char ch)</p>

<p>{ unsigned long int value(0);</p>

<p>// 交换bit0和bit7，bit1和bit6，类推</p>

<p>for(int i = 1; i &lt; (ch + 1); i++)</p>

<p>{ if(ref &amp; 1)</p>

<p>value |= 1 &lt;&lt; (ch - i);</p>

<p>ref &gt;&gt;= 1; }</p>

<p>return value;</p>

<p>}</p>

<p>init_crc32_table()</p>

<p>{ unsigned long int crc,temp;</p>

<p>// 256个值</p>

<p>for(int i = 0; i &lt;= 0xFF; i++)</p>

<p>{ temp=Reflect(i, 8);</p>

<p>crc32_table[i]= temp&lt;&lt; 24;</p>

<p>for (int j = 0; j &lt; 8; j++){</p>

<p>unsigned long int t1,t2;</p>

<p>unsigned long int flag=crc32_table[i]&0x80000000;</p>

<p>t1=(crc32_table[i] &lt;&lt; 1);</p>

<p>if(flag==0)</p>

<p>t2=0;</p>

<p>else</p>

<p>t2=ulPolynomial;</p>

<p>crc32_table[i] =t1^t2 ; }</p>

<p>crc=crc32_table[i];</p>

<p>crc32_table[i] = Reflect(crc32_table[i], 32);<br />
}<br />
}<br />
unsigned long GenerateCRC32(char xdata * DataBuf,unsigned long len)</p>

<p>{</p>

<p>unsigned long oldcrc32;</p>

<p>unsigned long crc32;</p>

<p>unsigned long oldcrc;</p>

<p>unsigned int charcnt;</p>

<p>char c,t;</p>

<p>oldcrc32 = 0x00000000; //初值为0</p>

<p>charcnt=0;</p>

<p>while (len&ndash;) {</p>

<p>t= (oldcrc32 &gt;&gt; 24) &amp; 0xFF; //要移出的字节的值</p>

<p>oldcrc=crc_32_tab[t]; //根据移出的字节的值查表</p>

<p>c=DataBuf[charcnt]; //新移进来的字节值</p>

<p>oldcrc32= (oldcrc32 &lt;&lt; 8) | c; //将新移进来的字节值添在寄存器末字节中</p>

<p>oldcrc32=oldcrc32^oldcrc; //将寄存器与查出的值进行xor运算</p>

<p>charcnt++;</p>

<p>}</p>

<p>crc32=oldcrc32;</p>

<p>return crc32;</p>

<p>}</p>

<p>参数表可以先在PC机上算出来，也可在程序初始化时完成。下面是用于计算参数表的c语言子程序，在Visual C++ 6.0下编译通过。</p>

<p>#include</p>

<p>unsigned long int crc32_table[256];</p>

<p>unsigned long int ulPolynomial = 0x04c11db7;</p>

<p>unsigned long int Reflect(unsigned long int ref, char ch)</p>

<p>{ unsigned long int value(0);</p>

<p>// 交换bit0和bit7，bit1和bit6，类推</p>

<p>for(int i = 1; i &lt; (ch + 1); i++)</p>

<p>{ if(ref &amp; 1)</p>

<p>value |= 1 &lt;&lt; (ch - i);</p>

<p>ref &gt;&gt;= 1; }</p>

<p>return value;</p>

<p>}<br />
int main()<br />
{<br />
unsigned long int crc,temp;</p>

<p>// 256个值</p>

<p>for(int i = 0; i &lt;= 0xFF; i++)</p>

<p>{<br />
temp=Reflect(i, 8);<br />
crc32_table[i]= temp&lt;&lt; 24;</p>

<p>for (int j = 0; j &lt; 8; j++){</p>

<p>unsigned long int t1,t2;</p>

<p>unsigned long int flag=crc32_table[i]&0x80000000;<br />
t1=(crc32_table[i] &lt;&lt; 1);</p>

<p>if(flag==0)</p>

<p>t2=0;</p>

<p>else</p>

<p>t2=ulPolynomial;</p>

<p>crc32_table[i] =t1^t2 ;<br />
}</p>

<p>crc=crc32_table[i];<br />
crc32_table[i] = Reflect(crc32_table[i], 32);<br />
}<br />
return 0;<br />
}<br />
EOF<br />
gcc -o crc crc.c<br />
if [ $? -eq 0 ]; then<br />
./combine<br />
else<br />
echo &lsquo;Compile ERROR&rsquo;<br />
fi</p>

<p>60.判断是否为空文件<br />
#!/bin/bash</p>

<p>61.终止程序<br />
#!/bin/sh<br />
kill -KILL pidof %%1 -s<br />
#killall %%1</p>

<p>62.定时关机<br />
#!/bin/sh<br />
shutdown -h %%1 &amp; #23:00<br />
#shutdown -h now<br />
#halt<br />
#/sbin/poweroff<br />
#init 0</p>

<p>63.显示进程列表<br />
#!/bin/sh<br />
ps aux<br />
#fuser -l</p>

<p>64.遍历文件夹列出文件大小<br />
#!/bin/sh<br />
du -sH &ldquo;%%1/*&rdquo;</p>

<p>65.GOST算法<br />
#!/bin/bash</p>

<p>66.对目标压缩文件解压缩到指定文件夹<br />
#!/bin/bash</p>

<p>67.保存文件时重名自动生成新文件<br />
#!/bin/bash</p>

<p>68.打开网页<br />
#!/bin/sh<br />
lynx %%1</p>

<p>69.删除空文件夹整合操作<br />
#!/bin/bash</p>

<p>70.获取磁盘所有分区<br />
#!/bin/sh<br />
df -k</p>

<p>71.激活一个程序或程序关联的文件<br />
#!/bin/bash</p>

<p>72.MP3播放<br />
#!/bin/sh<br />
amp &ldquo;%%1&rdquo;</p>

<p>73.WAV播放<br />
#!/bin/sh<br />
amp &ldquo;%%1&rdquo;</p>

<p>74.写图像到剪切板<br />
#!/bin/bash</p>

<p>75.从剪贴板复制图像到窗体<br />
#!/bin/bash</p>

<p>76.删除文件夹下的所有文件且不删除文件夹下的文件夹<br />
#!/bin/sh<br />
rm -if &ldquo;%%1/*&rdquo;</p>

<p>77.XML遍历结点属性值<br />
#!/bin/bash</p>

<p>78.Unicode文件转GB2312格式<br />
#!/bin/sh<br />
iconv -f ucs2 -t gbk %%1 -o %%2</p>

<p>79.开源程序库Xercesc-C++代码工程中内联80.提取包含头文件列表<br />
#!/bin/bash</p>

<p>81.GB2312文件转Unicode格式<br />
#!/bin/sh<br />
iconv -f gbk -t ucs2 %%1 -o %%2</p>

<p>82.Java程序打包<br />
#!/bin/bash</p>

<p>83.UTF-8文件转Unicode格式<br />
#!/bin/bash<br />
iconv -f utf8 -t ucs2 %%1 -o %%2</p>

<p>84.创建PDF文档<br />
#!/bin/bash</p>

<p>85.创建Word文档<br />
#!/bin/bash</p>

<p>86.快速高效的文件加密<br />
#!/bin/bash</p>

<p>87.从CSV文件构造XML文档<br />
#!/bin/bash</p>

<p>88.从XML文档生成CSV文件<br />
#!/bin/bash</p>

<p>89.模拟键盘输入字符串<br />
#!/bin/bash</p>

<p>90.提取PDF文件中的文本<br />
#!/bin/bash</p>

<p>91.操作内存映射文件<br />
#!/bin/bash<br />
91.1发送内存映射数据<br />
#!/bin/bash</p>

<p>91.2接收内存映射数据<br />
#!/bin/bash</p>

<p>92.重定向windows控制台程序的输出信息<br />
#!/bin/bash</p>

<p>93.基数转序数<br />
#!/bin/bash</p>

<p>94.数字月份转英文<br />
#!/bin/bash</p>

<p>95.报表相关<br />
#!/bin/bash</p>

<p>96.根据进程名获取进程ID<br />
#!/bin/bash<br />
pidof %%1 -s</p>

<p>96.BCP导入<br />
#!/bin/bash</p>

<p>97.BCP导出<br />
#!/bin/bash</p>

<p>98.计算文件MD5值<br />
#!/bin/bash<br />
md5sum &ldquo;%%1&rdquo;</p>

<p>99.计算获取文件夹中文件的MD5值<br />
#!/bin/bash</p>

<p>100.复制一个目录下所有文件到一个文件夹中<br />
#!/bin/bash<br />
cp $(find &ldquo;%%1&rdquo; -name <em>.</em>) &ldquo;%%2&rdquo;</p>

<p>101.移动一个目录下所有文件到一个文件夹中<br />
#!/bin/bash<br />
mv $(find &ldquo;%%1&rdquo; -name <em>.</em>) &ldquo;%%2&rdquo;</p>

<p>102.文件RSA高级加密<br />
十进制到十六进制<br />
typeset -i16 BASE_16_NUM<br />
BASE_16_NUM=%%1<br />
echo $BASE_16_NUM</p>

<p>八进制到十六进制<br />
#!/bin/bash<br />
typeset -i16 BASE_16_NUM<br />
BASE_16_NUM=8#%%1<br />
echo $BASE_16_NUM</p>

<p>十进制到八进制<br />
#!/bin/bash<br />
printf %o %%1; echo</p>

<p>十进制到十六进制<br />
#!/bin/bash<br />
printf %x %%1; echo</p>

<p>103.计算文件大小<br />
#!/bin/bash<br />
wc &ldquo;%%1&rdquo;</p>

<p>104.计算文件夹的大小<br />
#!/sbin/ksh<br />
dir=%%1<br />
(cd $dir;pwd)<br />
find $dir -type d -print | du | awk &lsquo;{print $2, &ldquo;== (&rdquo;$<sup>1</sup>&frasl;<sub>2</sub>&rdquo;kb)&ldquo;}&rsquo; |sort -f |<br />
sed -e &ldquo;s,[^ /]<em>/([^ /]</em>) ==,|&ndash;1,&rdquo; -e&rdquo;s,[^ /]*/,| ,g&rdquo;</p>

<p>105.快速获得当前程序的驱动器、路径、文件名和扩展名</p>

<p>106.磁盘剩余空间计算<br />
#!/bin/bash<br />
df -k</p>

<p>107.获取当前程序进程ID<br />
#!/bin/bash<br />
pidof %%1 -s</p>

<p>108.全盘搜索文件<br />
#!/bin/bash<br />
#updatedb<br />
#locate %%1<br />
slocate %%1</p>

<p>109.获得当前登录的用户名<br />
#!/bin/bash<br />
whoami</p>

<p>110.获得所有用户名<br />
#!/bin/bash<br />
who</p>

<p>111.创建MySQL管理用户<br />
#!/bin/bash<br />
mysqladmin -u root password %%1</p>

<p>112.管理MySQL数据库服务器<br />
#!/bin/bash<br />
112.1.启动MySQL数据库服务器<br />
mysqld -console</p>

<p>112.2.登录MySQL数据库服务器<br />
112.2.1.登录本地MySQL数据库服务器<br />
mysql -uroot -p%%1</p>

<p>112.2.2.登录远程MySQL数据库服务器<br />
mysql -h %%1 -u %%2 -p%%3</p>

<p>112.3.关闭MySQL数据库服务器<br />
mysqladmin -u root shutdown<br />
#pkill -9 mysql</p>

<p>112.4.测试MySQL数据库服务器<br />
mysqlshow || mysqlshow -u root mysql || mysqladmin version status || mysql
test</p>

<p>113.MySQL执行查询<br />
#!/bin/sh<br />
mysqladmin -u %%1 -p%%2 SELECT * INTO OUTFILE &lsquo;./bestlovesky.xls&rsquo; FROM
bestlovesky WHERE 1 ORDER BY id DESC LIMIT 0, 50;</p>

<p>mysql -u %%1 -p%%2 -e &ldquo;SELECT * INTO OUTFILE &lsquo;./bestlovesky.xls&rsquo; FROM
bestlovesky WHERE 1 ORDER BY id DESC LIMIT 0, 50;&rdquo;</p>

<p>114.创建Oracle管理用户<br />
#!/bin/sh<br />
114.1.创建新用户<br />
create user test identified by test default tablespace ts_test temporary<br />
tablespace temp;</p>

<p>114.2.给用户角色特权<br />
grant connect,resource to test;</p>

<p>115.登录Oracle数据库<br />
#!/bin/bash<br />
sqlplusw<br />
sqlplus /nolog<br />
conn username/password@Oranet<br />
conn system/systempwd@whfc<br />
conn sys/syspwd@whfc as sysdba</p>

<p>115.创建Oracle表空间<br />
#!/bin/bash<br />
conn system@whfc01<br />
create tablespace ts_test datafile &lsquo;/data2/oradata/ciis/ts_test01.dbf&rsquo; size</p>

<p>116.添加Oracle数据文件<br />
#!/bin/bash<br />
alter tablespace ts_test add datafile &lsquo;/data2/oradata/ciis/ts_test02.dbf&rsquo; size</p>

<p>117.查看Oracle表空间大小<br />
#!/bin/bash<br />
desc DBA_DATA_FILES</p>

<p>118.查看Oracle剩余表空间大小<br />
#!/bin/bash<br />
desc DBA_FREE_SPACE</p>

<p>119.查看Oracle当前用户表名<br />
#!/bin/bash<br />
select * from tab;</p>

<p>120.Oracle创建索引<br />
#!/bin/bash<br />
CREATE INDEX idx_book_bookid ON book(bookname);</p>

<p>121.Oracle创建主键约束<br />
#!/bin/bash<br />
ALTER TABLE book ADD CONSTRAINT pk_book_bookid PRIMARY KEY (bookid);</p>

<p>122.Oracle显示表结构<br />
#!/bin/bash<br />
desc book</p>

<p>123.Oracle查看表的索引<br />
#!/bin/bash<br />
column index_name format a30<br />
select table_name, index_name from user_indexes;</p>

<p>124.Oracle查看索引列<br />
#!/bin/bash<br />
select table_name, index_name, column_name, column_position from
user_ind_columns;</p>

<p>125.Oracle查看数据段占空间大小<br />
#!/bin/bash<br />
desc user_segments</p>

<p>126.Oracle查看表占空间大小<br />
#!/bin/bash<br />
select segment_name,segment_type,bytes from user_segments where
segment_type=&lsquo;TABLE&rsquo;;</p>

<p>127.安全删除USB<br />
#!/bin/bash<br />
rundll32.exe shell32.dll,Control_RunDLL hotplug.dll</p>

<p>128.打开SQL Server Management Studio<br />
#!/bin/bash<br />
sqlwb %%1.sql</p>

<p>129.MySQL数据库导出备份<br />
#!/bin/bash<br />
mysqldump -u %%1 -p %%2 %%3&gt;%%4.sql<br />
mysqldump &ndash;opt test &gt; mysql.test //将数据库test导出到mysql.test文件，后面是一个文本文件<br />
mysqldump -u root -p123456 &ndash;databases dbname &gt; mysql.dbname
//就是把数据库dbname导出到文件mysql.dbname中。</p>

<p>130.MySQL数据库数据导入<br />
mysql -u %%1 -p %%2 %%3 mysqlimport -u root -p123456 &lt; mysql.dbname<br />
将文本数据导入数据库：<br />
文本数据的字段之间用tab键隔开<br />
use test<br />
load data local infile &ldquo;文件名&rdquo; into table 表名；<br />
eg: load data local infile &ldquo;D:/mysql.txt&rdquo; into table mytable;<br />
导入.sql 文件命令<br />
use database<br />
source d:/mysql.sql;</p>

<p>131.MySQL数据库检查<br />
mysqlcheck -o %%3 -u %%1 -p %%2</p>

<p>132.MySQL数据表文件修复<br />
myisamchk -B -o %%1.myd</p>

<p>1,查看数据库状态 及启动停止<br />
/etc/init.d/mysqld status<br />
/etc/init.d/mysqld start<br />
/etc/init.d/mysqld stop</p>

<p>2,给用户配置初始密码123456：<br />
mysqladmin -u root -password 123456</p>

<p>3,修改root用户密码为 abc123<br />
mysqladmin -u root -p123456 password abc123</p>

<p>4,如果想去掉密码：<br />
mysqladmin -u root -pabc123 password &ldquo;&rdquo;</p>

<p>5,root连接数据库有密码和无密码：<br />
mysql -u root(-uroot) -p<br />
mysql</p>

<p>6,增加用户 test1 密码 abc,让它可以在任何主机上登录，并对所有数据库有查询，插入，修改，删除的权限：<br />
格式： grant select on 数据库.* to 用户名@登录主机 identified by &ldquo;密码&rdquo;<br />
grant select,insert,update,delete on <em>.</em> to test1@&ldquo;%&rdquo; Identified by &ldquo;abc&rdquo;;</p>

<p>8,增加一个用户test2,让它只可以在localhost上登录，并可以对数据库mydb进行查询，插入，修改，删除的操作，<br />
这样用户即使使用知道test2的密码，他也无法从internet 上直接访问数据库，只能通过mysql主机上的web页面来访问。<br />
grant select,insert,update,delete on mydb.* to test2@localhost identified by
&ldquo;abc&rdquo;;<br />
grant select,insert,update,delete on mydb.* to test2@localhost identified by
&ldquo;&rdquo;; 设置无密码</p>

<p>9,显示数据库列表：<br />
show databases;<br />
use mysql 打开库<br />
show tables;</p>

<p>10,表的操作<br />
describle 表名； 显示数据表的结构<br />
create database 库名；<br />
drop database 库名；<br />
create table 表名(字段设定列表）<br />
drop table 表名；<br />
delete from 表名；清空表记录<br />
select * from 表名； 显示表中的记录<br />
insert into 表名 values(， ，)</p>

<p>alter table 表名 add column</p>

<p>133.检查端口占用<br />
#!/bin/bash<br />
netstat -ano</p>

<p>134.Linux下检查Apache是否安装<br />
#!/bin/bash<br />
rpm -qa | grep httpd</p>

<p>135.Linux下启动Apache服务<br />
#!/bin/bash<br />
service httpd start</p>

<p>136.Linux下停止Apache服务<br />
#!/bin/bash<br />
service httpd stop</p>

<p>137.Linux下重新启动Apache服务<br />
#!/bin/bash<br />
service httpd restart</p>

<p>138.Linux下自动加载Apache 服务<br />
#!/bin/bash<br />
chkconfig - level 3 httpd on</p>

<p>139.Linux下不自动加载Apache 服务<br />
#!/bin/bash<br />
chkconfig - level 3 httpd off</p>

<p>140.Linux下检查VSFTP是否安装<br />
#!/bin/bash<br />
rpm -qa | grep vsftpd</p>

<p>141.Linux下启动VSFTP服务<br />
#!/bin/bash<br />
service vsftpd start</p>

<p>142.Linux下停止VSFTP服务<br />
#!/bin/bash<br />
service vsftpd stop</p>

<p>143.Linux下重新启动VSFTP服务<br />
#!/bin/bash<br />
service vsftpd restart</p>

<p>144.Linux下检查VSFTP是否被启动<br />
#!/bin/bash<br />
pstree | grep vsftpd</p>

<p>145.Linux下检查Sendmail是否安装<br />
#!/bin/bash<br />
rpm -qa | grep sendmail</p>

<p>146.Linux下启动Sendmail服务<br />
#!/bin/bash<br />
service sendmail start</p>

<p>147.Linux下停止Sendmail服务<br />
#!/bin/bash<br />
service sendma stop</p>

<p>148.Linux下重新启动Sendmail服务<br />
#!/bin/bash<br />
service sendmail restart</p>

<p>149.Linux下自动加载Sendmail 服务<br />
#!/bin/bash<br />
chkconfig - level 3 sendmail on</p>

<p>150.Linux下不自动加载Sendmail 服务<br />
#!/bin/bash<br />
chkconfig - level 3 sendmail off</p>

<p>151.Linux下文本图形界面配置启动服务<br />
#!/bin/bash<br />
ntsysv</p>

<p>152.以数组的方式删除文件夹</p>

<p>153.GCC批量编译<br />
#!/bin/bash<br />
find -type f \( -iname &lsquo;<em>.c&rsquo; -o -iname &lsquo;</em>.cpp&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.c)<br />
gcc &ldquo;$filename&rdquo; -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .c)&rdquo;<br />
;;<br />
*.cpp)<br />
gcc &ldquo;$filename&rdquo; -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .cpp)&rdquo;<br />
;;<br />
esac<br />
done</p>

<p>154.批量赋予可执行权限<br />
#!/bin/bash<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;<em>.sh&rsquo; -o -iname &lsquo;</em>.csh&rsquo; -o -iname &lsquo;<em>.ksh&rsquo; -o
-iname &lsquo;</em>.pl&rsquo; -o -iname &lsquo;<em>.bin&rsquo; -o -iname &lsquo;</em>.run&rsquo; -o -iname &lsquo;<em>.bundle&rsquo; -o
-iname &lsquo;</em>.rb&rsquo; -o -iname &lsquo;*.py&rsquo; \) -print0 | xargs -0 chmod +x</p>

<p>#!/bin/bash<br />
for file in *.sh *.pl *.bin *.run *.bundle *.rb <em>.py<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \</em>.[A-Za-z]+ ]]; then<br />
chmod +x &ldquo;$(file)&rdquo;<br />
fi<br />
done<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $(pwd) -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in $path/<em>.sh $path/</em>.pl $path/<em>.bin $path/</em>.run $path/<em>.bundle
$path/</em>.rb $path/<em>.py<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \</em>.[A-Za-z]+ ]]; then<br />
chmod +x &ldquo;$(path)/$(file)&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>155.批量执行<br />
#!/bin/bash<br />
find -type f \( -iname &lsquo;<em>.sh&rsquo; -o -iname &lsquo;</em>.csh&rsquo; -o -iname &lsquo;<em>.ksh&rsquo; -o -iname
&lsquo;</em>.pl&rsquo; -o -iname &lsquo;<em>.bin&rsquo; -o -iname &lsquo;</em>.run&rsquo; -o -iname &lsquo;<em>.bundle&rsquo; -o -iname
&lsquo;</em>.bin&rsquo; -o -iname &lsquo;<em>.class&rsquo; -o -iname &lsquo;</em>.rpm&rsquo; -o -iname &lsquo;<em>.rb&rsquo; -o -iname
&lsquo;</em>.py&rsquo; -o -iname &lsquo;*.jar&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.sh | *.csh | *.ksh)<br />
if [ ! &ldquo;./&rdquo;&ldquo;$(basename $filename)&rdquo; = $0 ]; then<br />
xterm -e &ldquo;$filename&rdquo;<br />
fi<br />
;;<br />
*.pl)<br />
xterm -e perl &ldquo;$filename&rdquo;<br />
;;<br />
*.bin | *.run | *.bundle)<br />
xterm -e &ldquo;$filename&rdquo;<br />
;;<br />
*.class)<br />
xterm -e java &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .class)&rdquo;<br />
;;<br />
*.rpm)<br />
xterm -e rpm -ivh &ldquo;$filename&rdquo;<br />
;;<br />
*.rb)<br />
xterm -e ruby &ldquo;$filename&rdquo;<br />
;;<br />
*.py)<br />
xterm -e python &ldquo;$filename&rdquo;<br />
;;<br />
*.jar)<br />
xterm -e java -jar &ldquo;$filename&rdquo;<br />
;;<br />
esac<br />
done</p>

<p>#!/bin/bash<br />
find -maxdepth 1 -type f \( -iname &lsquo;<em>.sh&rsquo; -o -iname &lsquo;</em>.pl&rsquo; -o -iname &lsquo;<em>.bin&rsquo;
-o -iname &lsquo;</em>.run&rsquo; -o -iname &lsquo;<em>.bundle&rsquo; -o -iname &lsquo;</em>.bin&rsquo; -o -iname &lsquo;<em>.class&rsquo;
-o -iname &lsquo;</em>.rpm&rsquo; -o -iname &lsquo;<em>.rb&rsquo; -o -iname &lsquo;</em>.py&rsquo; -o -iname &lsquo;<em>.jar&rsquo; \)
-print<br />
while read file<br />
do<br />
case &ldquo;${file##</em>.}&rdquo; in<br />
sh ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
pl ) xterm -e perl &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
bin ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
run ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
bundle ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
class ) xterm -e java &ldquo;&rdquo;&ldquo;&rdquo;${file%.*}&ldquo;&rdquo;&ldquo;&rdquo;;;<br />
rpm ) xterm -e rpm -ivh &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
rb ) xterm -e ruby &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
py ) xterm -e python &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
jar ) xterm -e java -jar &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
esac<br />
done</p>

<p>156.获取操作系统版本<br />
#!/bin/bash<br />
uname -r<br />
#uname -a</p>

<p>157.自身复制<br />
#!/bin/bash<br />
cp $0 &ldquo;%%1&rdquo;</p>

<p>158.GCC批量创建静态库<br />
#!/bin/bash<br />
find -type f \( -iname &lsquo;<em>.c&rsquo; -o -iname &lsquo;</em>.cpp&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.c)<br />
g++ -c -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .c)&ldquo;.o&rdquo;&rdquo;
&ldquo;$filename&rdquo;<br />
;;<br />
<em>.cpp)<br />
g++ -c -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .cpp)&ldquo;.o&rdquo;&rdquo;
&ldquo;$filename&rdquo;<br />
;;<br />
esac<br />
done<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $(pwd) -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
ar ru $path&rdquo;.a&rdquo; $path&rdquo;/</em>.o&rdquo; &amp;&amp; ranlib $path&rdquo;.a&rdquo;<br />
done<br />
IFS=$OLDIFS<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;*.o&rsquo; \) -print0 | xargs -0 rm -if</p>

<p>159.Java批量打包EJB<br />
#!/bin/bash<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;<em>.java&rsquo; \) -print0 | xargs -0 javac<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $(pwd) -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
jar -cvf &ldquo;$(path&rdquo;.jar&rdquo;)&rdquo; &ldquo;$(path&rdquo;/</em>.*&ldquo;)&rdquo; &amp;&amp; cp &ldquo;$(path&rdquo;.jar&rdquo;)&rdquo;
&ldquo;$(JBOSS_HOME&rdquo;/server/default/deploy&rdquo;)&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;*.class&rsquo; \) -print0 | xargs -0 rm -if</p>

<p>160.获取环境变量</p>

<p>161.dd<br />
#!/bin/bash<br />
dd</p>

<p>162.显示只有小写字母的文件<br />
#!/bin/bash<br />
ls -1|awk &lsquo;/<sup class="footnote-ref" id="fnref:lower"><a href="#fn:lower">14</a></sup>.*/&rsquo;</p>

<p>163.Zip压缩目录中的所有文件<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
targetpath=&ldquo;%%2&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
for file in $path/*<br />
do<br />
if [ -f $file ]; then<br />
zip -j &ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}.zip&rdquo; &ldquo;$file&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>164.Zip解压缩目录中的所有文件<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
targetpath=&ldquo;%%2&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
unzip -x &ldquo;$path/*.zip&rdquo; -d &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>165.分布式复制文件夹<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
targetpath=&ldquo;%%2&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
rm -if &ldquo;$targetpath/${path:${#direc}+1}/<em>.tmp&rdquo;<br />
for file in $path/</em><br />
do<br />
if [ -f $file ]; then<br />
cp &ldquo;$file&rdquo; &ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}.tmp&rdquo;<br />
mv &ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}.tmp&rdquo;
&ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>166.注册反注册组件<br />
#!/bin/bash<br />
regsvr32 &ldquo;%%1&rdquo;</p>

<p>167.LZMA<br />
#!/bin/bash</p>

<p>168.CAB压缩文件<br />
#!/bin/bash</p>

<p>169.CAB解压缩文件<br />
#!/bin/bash</p>

<p>170.锁定屏幕<br />
#!/bin/sh<br />
RUNDLL32.exe USER32,LockWorkStation</p>

<p>171.以其它用户的身份运行程序<br />
#!/bin/bash</p>

<p>172.添加系统用户<br />
#!/bin/sh<br />
useradd &ldquo;%%1&rdquo;</p>

<p>173.删除系统用户<br />
#!/bin/sh<br />
userdel &ldquo;%%1&rdquo;</p>

<p>174.添加用户组<br />
#!/bin/sh<br />
groupadd -g 2000 &ldquo;%%1&rdquo;</p>

<p>175.删除用户组<br />
#!/bin/sh<br />
groupdel &ldquo;%%1&rdquo;</p>

<p>176.赋予管理员权限<br />
#!/bin/bash</p>

<p>177.收回管理员权限<br />
#!/bin/bash</p>

<p>178.遍历目录产生删除文件的脚本<br />
#!/bin/bash</p>

<p>179.LZW压缩文件<br />
#!/bin/bash<br />
z</p>

<p>180.LZW解压缩文件<br />
#!/bin/bash<br />
z</p>

<p>181.递归赋予目录权限<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
chown -R root.root &ldquo;$path&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>182.卸载RPM包<br />
#!/bin/sh<br />
rpm -e &ldquo;%%1&rdquo;</p>

<p>183.删除源文件中的注释<br />
#!/bin/sh</p>

<p>184.设置目录下所有文件属性为可写<br />
#!/bin/sh</p>

<p>185.统计目录下所有文件的总共行数<br />
#!/bin/sh<br />
cat * |wc<br />
ls *|xargs wc -l<br />
find ./ -name &ldquo;*c&rdquo; | xargs wc -l</p>

<p>186.删除自身<br />
#!/bin/rm<br />
exit 65<br />
#rm $0</p>

<p>187.打开终端<br />
#!/bin/bash -l</p>

<p>188.弹出光驱<br />
#!/bin/sh<br />
eject</p>

<p>189.收回光驱<br />
#!/bin/sh<br />
eject -t</p>

<p>190.磁盘总空间计算</p>

<p>191.解析CSV文件</p>

<p>192.按行保存文件为数组</p>

<p>193.MySQL执行SQL文件<br />
mysqladmin -u %%1 -p%%2 &lt; %%3.sql</p>

<p>mysql -u %%1 -p%%2 -e &ldquo;SOURCE %%3.sql&rdquo;</p>

<p>1.创建文件夹<br />
#!/bin/sh<br />
mkdir -m 777 &ldquo;%%1&rdquo;</p>

<p>2.创建文件<br />
#!/bin/sh<br />
touch &ldquo;%%1&rdquo;</p>

<p>3.删除文件<br />
#!/bin/sh<br />
rm -if &ldquo;%%1&rdquo;</p>

<p>4.删除文件夹<br />
#!/bin/sh<br />
rm -rf &ldquo;%%1&rdquo;</p>

<p>5.删除一个目录下所有的文件夹<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
for dir2del in $direc/* ; do<br />
if [ -d $dir2del ]; then<br />
rm -rf $dir2del<br />
fi<br />
done</p>

<p>6.清空文件夹<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
rm -if $direc/*<br />
for dir2del in $direc/* ; do<br />
if [ -d $dir2del ]; then<br />
rm -rf $dir2del<br />
fi<br />
done</p>

<p>7.读取文件<br />
#!/bin/sh<br />
7.1.操作系统默认编码<br />
cat &ldquo;%%1&rdquo; | while read line; do<br />
echo $line;<br />
done</p>

<p>7.2.UTF-8编码<br />
cat &ldquo;%%1&rdquo; | while read line; do<br />
echo $line;<br />
done</p>

<p>7.3.分块读取<br />
cat &ldquo;%%1&rdquo; | while read line; do<br />
echo $line;<br />
done</p>

<p>8.写入文件<br />
#!/bin/sh<br />
cat &gt; &ldquo;%%1&rdquo; &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>tee &ldquo;%%1&rdquo; &gt; /dev/null &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>#sed -i &lsquo;$a %%2&rsquo; %%2</p>

<p>9.写入随机文件<br />
#!/bin/sh<br />
cat &gt; &ldquo;%%1&rdquo; &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>tee &ldquo;%%1&rdquo; &gt; /dev/null &lt;&lt; EOF<br />
%%2<br />
EOF</p>

<p>#sed -i &lsquo;$a %%2&rsquo; %%2</p>

<p>10.读取文件属性<br />
#!/bin/bash<br />
file=%%1<br />
file=${file:?&lsquo;必须给出参数&rsquo;}<br />
if [ ! -e $file ]; then<br />
echo &ldquo;$file 不存在&rdquo;<br />
exit 1<br />
fi<br />
if [ -d $file ]; then<br />
echo &ldquo;$file 是一个目录&rdquo;<br />
if [ -x $file ]; then<br />
echo &ldquo;可以&rdquo;<br />
else<br />
echo &ldquo;不可以&rdquo;<br />
fi<br />
echo &ldquo;对此进行搜索&rdquo;<br />
elif [ -f $file ]; then<br />
echo &ldquo;$file 是一个正规文件&rdquo;<br />
else<br />
echo &ldquo;$file不是一个正规文件&rdquo;<br />
fi<br />
if [ -O $file ]; then<br />
echo &ldquo;你是$file的拥有者&rdquo;<br />
else<br />
echo &ldquo;你不是$file的拥有者&rdquo;<br />
fi<br />
if [ -r $file ]; then<br />
echo &ldquo;你对$file拥有&rdquo;<br />
else<br />
echo &ldquo;你并不对$file拥有&rdquo;<br />
fi<br />
echo &ldquo;可读权限&rdquo;<br />
if [ -w $file ]; then<br />
echo &ldquo;你对$file拥有&rdquo;<br />
else<br />
echo &ldquo;你并不对$file拥有&rdquo;<br />
fi<br />
echo &ldquo;可写权限&rdquo;<br />
if [ -x $file -a ! -d $file ]; then<br />
echo &ldquo;你拥有对$file&rdquo;<br />
else<br />
echo &ldquo;你并不拥有对$file&rdquo;<br />
fi<br />
echo &ldquo;可执行的权限&rdquo;</p>

<p>11.写入文件属性<br />
#!/bin/bash<br />
#修改存放在ext2、ext3、ext4、xfs、ubifs、reiserfs、jfs等文件系统上的文件或目录属性，使用权限超级用户。<br />
#一些功能是由Linux内核版本来支持的，如果Linux内核版本低于2.2，那么许多功能不能实现。同样－D检查压缩文件中的错误的功能，需要2.5.19以上内核才能支持。另外，通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。<br />
chattr [-RV] [-+=AacDdijsSu] [-v version] 文件或目录<br />
－R：递归处理所有的文件及子目录。<br />
－V：详细显示修改内容，并打印输出。<br />
－：失效属性。<br />
＋：激活属性。<br />
= ：指定属性。<br />
A：Atime，告诉系统不要修改对这个文件的最后访问时间。<br />
S：Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。<br />
a：Append
Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件。<br />
i：Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。<br />
D：检查压缩文件中的错误。<br />
d：No dump，在进行文件系统备份时，dump程序将忽略这个文件。<br />
C：Compress，系统以透明的方式压缩这个文件。从这个文件读取时，返回的是解压之后的数据；而向这个文件中写入数据时，数据首先被压缩之后才写入磁盘。<br />
S：Secure Delete，让系统在删除这个文件时，使用0填充文件所在的区域。<br />
u：Undelete，当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件。</p>

<p>12.枚举一个目录中的所有文件夹<br />
#!/bin/bash<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find &ldquo;%%1&rdquo; -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
#&ldquo;$path&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>13.复制文件夹<br />
#!/bin/sh<br />
cp -rf &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>14.复制一个目录下所有的文件夹到另一个目录下<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
for dir2cp in $direc/* ; do<br />
if [ -d $dir2cp ]; then<br />
cp $dir2cp &ldquo;%%2&rdquo;<br />
fi<br />
done</p>

<p>15.移动文件夹<br />
#!/bin/sh<br />
mv -rf &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>16.移动一个目录下所有的文件夹到另一个目录下<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
for dir2mv in $direc/* ; do<br />
if [ -d $dir2mv ]; then<br />
mv $dir2mv &ldquo;%%2&rdquo;<br />
fi<br />
done</p>

<p>17.以一个文件夹的框架在另一个目录下创建文件夹和空文件<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;%%2/${path:${#direc}+1}&rdquo;<br />
done<br />
IFS=$OLDIFS<br />
#cp -a &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>表达式 含义<br />
${#string}<br />
{#string}<br />
1，取得字符串长度<br />
string=abc12342341 //等号二边不要有空格<br />
echo ${#string} //结果11<br />
expr length $string //结果11<br />
expr &ldquo;$string&rdquo; : &ldquo;.*&rdquo; //结果11 分号二边要有空格,这里的:根match的用法差不多2，字符串所在位置<br />
expr index $string &lsquo;123&rsquo; //结果4
字符串对应的下标是从0开始的这个方法让我想起来了js的indexOf，各种语言对字符串的操作方法大方向都差不多，如果有语言基础的话，学习shell会很快的。<br />
3，从字符串开头到子串的最大长度<br />
expr match $string &lsquo;abc.<em>3&rsquo; //结果9个人觉得这个函数的用处不大，为什么要从开头开始呢。<br />
4，字符串截取<br />
echo ${string:4} //2342341 从第4位开始截取后面所有字符串<br />
echo ${string:3:3} //123 从第3位开始截取后面3位<br />
echo ${string:3:6} //123423 从第3位开始截取后面6位<br />
echo ${string: -4} //2341 ：右边有空格 截取后4位<br />
echo ${string:(-4)} //2341 同上<br />
expr substr $string 3 3 //123 从第3位开始截取后面3位上面的方法让我想起了，php的substr函数，后面截取的规则是一样的。<br />
5，匹配显示内容<br />
//例3中也有match和这里的match不同，上面显示的是匹配字符的长度，而下面的是匹配的内容<br />
expr match $string &lsquo;\([a-c]</em>[0-9]<em>\)&rsquo; //abc12342341<br />
expr $string : &lsquo;\([a-c]</em>[0-9]\)&rsquo; //abc1<br />
expr $string : &lsquo;.*\([0-9][0-9][0-9]\)&rsquo; //341
显示括号中匹配的内容这里括号的用法，是不是根其他的括号用法有相似之处呢，<br />
6，截取不匹配的内容<br />
echo ${string#a*3} //42341 从$string左边开始，去掉最短匹配子串<br />
echo ${string#c*3} //abc12342341 这样什么也没有匹配到<br />
echo ${string#*c1*3} //42341 从$string左边开始，去掉最短匹配子串<br />
echo ${string##a*3} //41 从$string左边开始，去掉最长匹配子串<br />
echo ${string%3*1} //abc12342 从$string右边开始，去掉最短匹配子串<br />
echo ${string%%3*1} //abc12
从$string右边开始，去掉最长匹配子串这里要注意，必须从字符串的第一个字符开始，或者从最后一个开始，<br />
7，匹配并且替换<br />
echo ${string/23/bb} //abc1bb42341 替换一次<br />
echo ${string//23/bb} //abc1bb4bb41 双斜杠替换所有匹配<br />
echo ${string/#abc/bb} //bb12342341 #以什么开头来匹配，根php中的^有点像<br />
echo ${string/%41/bb} //abc123423bb %以什么结尾来匹配，根php中的$有点像</p>

<p>#!/bin/bash<br />
direc=$(pwd)<br />
for file in &ldquo;$(direc)/<em>&rdquo;<br />
do<br />
if [ &ldquo;${file##</em>.}&rdquo; = &ldquo;sh&rdquo; ]; then<br />
xterm -e bash $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;bin&rdquo; ]; then<br />
xterm -e $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;run&rdquo; ]; then<br />
xterm -e $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;bundle&rdquo; ]; then<br />
xterm -e $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;pl&rdquo; ]; then<br />
xterm -e perl $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;class&rdquo; ]; then<br />
xterm -e java ${file%.</em>}<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;rpm&rdquo; ]; then<br />
xterm -e rpm -ivh $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;rb&rdquo; ]; then<br />
xterm -e ruby $file<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;py&rdquo; ]; then<br />
xterm -e python $file<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;jar&rdquo; ]; then<br />
xterm -e java -jar $file<br />
fi<br />
done<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in <code>ls $path</code><br />
do<br />
if [ &ldquo;${file##<em>.}&rdquo; = &ldquo;sh&rdquo; ]; then<br />
xterm -e bash &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;bin&rdquo; ]; then<br />
xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;run&rdquo; ]; then<br />
xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;bundle&rdquo; ]; then<br />
xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;pl&rdquo; ]; then<br />
xterm -e perl &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;class&rdquo; ]; then<br />
xterm -e java &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;${file%.<em>}&ldquo;&rdquo;&ldquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;rpm&rdquo; ]; then<br />
xterm -e rpm -ivh &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##<em>.}&rdquo; = &ldquo;rb&rdquo; ]; then<br />
xterm -e ruby &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##</em>.}&rdquo; = &ldquo;py&rdquo; ]; then<br />
xterm -e python &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
elif [ &ldquo;${file##*.}&rdquo; = &ldquo;jar&rdquo; ]; then<br />
xterm -e java -jar &ldquo;&rdquo;&ldquo;&rdquo;$path&rdquo;/&ldquo;$file&rdquo;&ldquo;&rdquo;&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>18.复制文件<br />
#!/bin/sh<br />
cp %%1 %%2</p>

<p>19.复制一个目录下所有的文件到另一个目录<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; $(pwd)<br />
for file in &ldquo;$direc/*&rdquo;<br />
do<br />
cp &ldquo;$file&rdquo; &ldquo;%%1&rdquo;<br />
done</p>

<p>20.提取扩展名<br />
#!/bin/sh<br />
%%2=${%%1##.}</p>

<p>21.提取文件名<br />
#!/bin/sh<br />
%%2=&ldquo;$(basename %%1)&rdquo;</p>

<p>22.提取文件路径<br />
#!/bin/sh<br />
%%2=&ldquo;$(dirname %%1)&rdquo;</p>

<p>23.替换扩展名<br />
#!/bin/sh<br />
%%3=&ldquo;$(basename %%1)$%%2&rdquo;</p>

<p>24.追加路径<br />
#!/bin/sh<br />
%%3=&ldquo;$(dirname %%1)/$%%2&rdquo;</p>

<p>25.移动文件<br />
#!/bin/sh<br />
mv &ldquo;%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>26.移动一个目录下所有文件到另一个目录<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
OLDIFS=$IFS<br />
IFS=:<br />
for file in &ldquo;$(direc)/*&rdquo;<br />
do<br />
mv &ldquo;$file&rdquo; &ldquo;%%1&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>27.指定目录下搜索文件<br />
#!/bin/sh<br />
find -name &ldquo;%%1&rdquo;</p>

<p>28.打开文件对话框<br />
#!/bin/sh<br />
%%1=&ldquo;$(Xdialog &ndash;fselect &lsquo;~/&rsquo; 0 0 2&gt;&amp;1)&rdquo;</p>

<p>29.文件分割<br />
#!/bin/sh<br />
split -b 2k &ldquo;%%1&rdquo;</p>

<p>while read f1 f2 f3<br />
do<br />
echo $f1 &gt;&gt; f1<br />
echo $f2 &gt;&gt; f2<br />
echo $f3 &gt;&gt; f3<br />
done</p>

<p>#!/bin/bash<br />
linenum=<code>wc -l httperr8007.log| awk '{print $1}'</code><br />
n1=1<br />
file=1<br />
while [ $n1 -lt $linenum ]<br />
do<br />
n2=<code>expr $n1 + 999</code><br />
sed -n &ldquo;${n1}, ${n2}p&rdquo; httperr8007.log &gt; file_$file.log<br />
n1=<code>expr $n2 + 1</code><br />
file=<code>expr $file + 1</code><br />
done</p>

<p>其中httperr8007.log为你想分割的大文件，file_$file.log
为分割后的文件，最后为file_1.log，file_2.log，file_3.log……,分割完后的每个文件只有1000行（参数可以自己设置）</p>

<p>split 参数：<br />
-b ：后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等；<br />
-l ：以行数来进行分割；</p>

<p>#按每个文件1000行来分割除</p>

<p>split -l 1000 httperr8007.log httperr</p>

<p>httpaa，httpab，httpac &hellip;&hellip;..</p>

<p>#按照每个文件100K来分割</p>

<p>split -b 100k httperr8007.log http</p>

<p>httpaa，httpab，httpac &hellip;&hellip;..</p>

<p>#!/bin/bash<br />
if [ $# -ne 2 ]; then<br />
echo &lsquo;Usage: split file size(in bytes)&rsquo;<br />
exit<br />
fi</p>

<p>file=$1<br />
size=$2</p>

<p>if [ ! -f $file ]; then<br />
echo &ldquo;$file doesn&rsquo;t exist&rdquo;<br />
exit<br />
fi</p>

<p>#TODO: test if $size is a valid integer</p>

<p>filesize=<code>/bin/ls -l $file | awk '{print $5}'</code><br />
echo filesize: $filesize</p>

<p>let pieces=$filesize/$size<br />
let remain=$filesize-$pieces*$size<br />
if [ $remain -gt 0 ]; then<br />
let pieces=$pieces+1<br />
fi<br />
echo pieces: $pieces</p>

<p>i=0<br />
while [ $i -lt $pieces ];<br />
do<br />
echo split: $file.$i:<br />
dd if=$file of=$file.$i bs=$size count=1 skip=$i<br />
let i=$i+1<br />
done</p>

<p>echo &ldquo;#!/bin/bash&rdquo; &gt; merge</p>

<p>echo &ldquo;i=0&rdquo; &gt;&gt; merge<br />
echo &ldquo;while [ $i -lt $pieces ];&rdquo; &gt;&gt; merge<br />
echo &ldquo;do&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; if [ ! -f $file.$i ]; then&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i missed&rdquo; &gt;&gt; merge<br />
echo &ldquo; rm -f $file.merged&rdquo; &gt;&gt; merge<br />
echo &ldquo; exit&rdquo; &gt;&gt; merge<br />
echo &ldquo; fi&rdquo; &gt;&gt; merge<br />
echo &ldquo; dd if=$file.$i of=$file.merged bs=$size count=1 seek=$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; let i=$i+1&rdquo; &gt;&gt; merge<br />
echo &ldquo;done&rdquo; &gt;&gt; merge<br />
chmod u+x merge&rsquo;</p>

<p>30.文件合并<br />
#!/bin/sh<br />
cp &ldquo;%%1&rdquo;+&ldquo;%%2&rdquo; &ldquo;%%3&rdquo;</p>

<p>exec 3 exec 4 while read f1 do<br />
echo $f1 $f2 &gt;&gt; join.txt<br />
done</p>

<p>#!/bin/bash<br />
if [ $# -ne 2 ]; then<br />
echo &lsquo;Usage: split file size(in bytes)&rsquo;<br />
exit<br />
fi</p>

<p>file=$1<br />
size=$2</p>

<p>if [ ! -f $file ]; then<br />
echo &ldquo;$file doesn&rsquo;t exist&rdquo;<br />
exit<br />
fi</p>

<p>#TODO: test if $size is a valid integer</p>

<p>filesize=<code>/bin/ls -l $file | awk '{print $5}'</code><br />
echo filesize: $filesize</p>

<p>let pieces=$filesize/$size<br />
let remain=$filesize-$pieces*$size<br />
if [ $remain -gt 0 ]; then<br />
let pieces=$pieces+1<br />
fi<br />
echo pieces: $pieces</p>

<p>i=0<br />
while [ $i -lt $pieces ];<br />
do<br />
echo split: $file.$i:<br />
dd if=$file of=$file.$i bs=$size count=1 skip=$i<br />
let i=$i+1<br />
done</p>

<p>echo &ldquo;#!/bin/bash&rdquo; &gt; merge</p>

<p>echo &ldquo;i=0&rdquo; &gt;&gt; merge<br />
echo &ldquo;while [ $i -lt $pieces ];&rdquo; &gt;&gt; merge<br />
echo &ldquo;do&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; if [ ! -f $file.$i ]; then&rdquo; &gt;&gt; merge<br />
echo &ldquo; echo merge: $file.$i missed&rdquo; &gt;&gt; merge<br />
echo &ldquo; rm -f $file.merged&rdquo; &gt;&gt; merge<br />
echo &ldquo; exit&rdquo; &gt;&gt; merge<br />
echo &ldquo; fi&rdquo; &gt;&gt; merge<br />
echo &ldquo; dd if=$file.$i of=$file.merged bs=$size count=1 seek=$i&rdquo; &gt;&gt; merge<br />
echo &ldquo; let i=$i+1&rdquo; &gt;&gt; merge<br />
echo &ldquo;done&rdquo; &gt;&gt; merge<br />
chmod u+x merge&rsquo;</p>

<p>31.文件简单加密<br />
#!/bin/bash<br />
#make test &amp;&amp; make strings &amp;&amp; sudo make install<br />
shc -r -f %%1.sh<br />
#%%1.x<br />
#%%1.x.c</p>

<p>32.文件简单解密<br />
#!/bin/bash<br />
#make test &amp;&amp; make strings &amp;&amp; sudo make install<br />
shc -r -f %%1.sh<br />
#%%1.x<br />
#%%1.x.c</p>

<p>33.读取ini文件属性<br />
#!/bin/bash<br />
if [ &ldquo;$%%3&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">15</a></sup><em>$/d<br />
s/;.</em>$//<br />
p<br />
}&rdquo; $1<br />
elif [ &ldquo;$%%4&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">16</a></sup><em>$/d<br />
s/;.</em>$//<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">17</a></sup><em>$%%3[ | ]</em>=[ | ]<em>\(.</em>\)[ | ]<em>/\1/p<br />
}&rdquo; $1<br />
else<br />
if [ &ldquo;$%%4&rdquo; = &ldquo;#&rdquo; ];then<br />
sed &ldquo;/\[$%%2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">18</a></sup><em>$%%3[ | ]</em>=.<em>/ /<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $1<br />
else<br />
sed &ldquo;/\[$2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">19</a></sup><em>$%%3[ | ]</em>=.*/$%%3=$%%4/<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $%%1<br />
fi<br />
fi</p>

<p>34.合并一个文件下所有的文件<br />
#!/bin/sh<br />
cat $(ls |grep -E &lsquo;%%1\.&lsquo;) &gt; %%1</p>

<p>#!/bin/bash<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find %%1 -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in $path/<em>.c $path/</em>.cpp<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \*.[A-Za-z]+ ]]; then<br />
#&ldquo;$(path)/$(file)&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>#!/bin/bash<br />
cat &lt; combine.c<br />
#include<br />
int main()<br />
{<br />
FILE *f1,*f2,*f3;<br />
f1=fopen(&ldquo;a1.txt&rdquo;,&ldquo;r&rdquo;);<br />
f2=fopen(&ldquo;a2.txt&rdquo;,&ldquo;r&rdquo;);<br />
f3=fopen(&ldquo;a3.txt&rdquo;,&ldquo;w&rdquo;);<br />
int a,b;<br />
a=getw(f1); /<em>从a1.txt和a2.txt中分别取最小的数a和b</em>/<br />
b=getw(f2);<br />
while(!feof(f1)&amp;&amp;!feof(f2)) /<em>两个文件都没结束时，执行循环、比较</em>/<br />
{<br />
if(a&lt;=b)<br />
{<br />
putw(a,f3);<br />
a=getw(f1);<br />
}<br />
else<br />
{putw(b,f3);<br />
b=getw(f2);<br />
}<br />
}<br />
if(feof(f1)) /<em>文件a1.txt结束时，把a2.txt中的数全部输入a3.txt</em>/<br />
{putw(b,f3);<br />
while((b=getw(f2))!=EOF)<br />
putw(b,f3);<br />
}<br />
if(feof(f2)) /<em>同上</em>/<br />
{<br />
putw(a,f3);<br />
while((a=getw(f1))!=EOF)<br />
putw(a,f3);<br />
}<br />
fclose(f1);<br />
fclose(f2);<br />
fclose(f3);<br />
printf(&ldquo;已完成!&rdquo;);<br />
return 0;<br />
}<br />
EOF<br />
gcc -o combine combine.c<br />
if [ $? -eq 0 ]; then<br />
./combine<br />
else<br />
echo &lsquo;Compile ERROR&rsquo;<br />
fi</p>

<p>35.写入ini文件属性<br />
#!/bin/bash<br />
if [ &ldquo;$%%3&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">20</a></sup><em>$/d<br />
s/;.</em>$//<br />
p<br />
}&rdquo; $1<br />
elif [ &ldquo;$%%4&rdquo; = &ldquo;&rdquo; ];then<br />
sed -n &ldquo;/\[$%%2\]/,/\[.<em>\]/{<br />
/^\[.</em>\]/d<br />
/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">21</a></sup><em>$/d<br />
s/;.</em>$//<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">22</a></sup><em>$%%3[ | ]</em>=[ | ]<em>\(.</em>\)[ | ]<em>/\1/p<br />
}&rdquo; $1<br />
else<br />
if [ &ldquo;$%%4&rdquo; = &ldquo;#&rdquo; ];then<br />
sed &ldquo;/\[$%%2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">23</a></sup><em>$%%3[ | ]</em>=.<em>/ /<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $%%1<br />
else<br />
sed &ldquo;/\[$%%2\]/,/\[.</em>\]/{<br />
s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">24</a></sup><em>$%%3[ | ]</em>=.*/$%%3=$%%4/<br />
}p&rdquo; $1 &gt; /tmp/sed$$<br />
mv /tmp/sed$$ $%%1<br />
fi<br />
fi</p>

<p>36.获得当前路径<br />
#!/bin/sh<br />
%%1=$(pwd)</p>

<p>37.读取XML数据库</p>

<p>如何通过shell命令行读取xml文件中某个属性所对应的值？<br />
例如：<br />
BuildVersion 5<br />
我希望能够通过Unix shell命令对属性键的名称BuildVersion进行查询，返回的结果是5，如何实现呀？<br />
#!/bin/bash<br />
grep BuildVersion|sed &rsquo;s/.<em>&lt;.&gt;\([^.</em>/\1/&rsquo;</p>

<p>结果返回的是“BuildVersion”，而不是“5”，如果要查询BuildVersion自动返回数值5应当如何写？</p>

<p>应该没错的。试一下： echo &ldquo;BuildVersion 5&rdquo;|grep BuildVersion|sed
&rsquo;s/.<em>&lt;.&gt;\([^.</em>/\1/&lsquo;我在SL的终端里试，返回值是5</p>

<p>目前需要从xml文件提取数据，想做一个xmlparser.sh<br />
xml 类似这样</p>

<p>希望输入 xmlparser.sh a.xml hostip可以返回192.168.0.1</p>

<p>#!/bin/sh</p>

<p>if [ $# -ne 2 ];then<br />
echo &ldquo;Usage: $0  &ldquo;<br />
exit 0<br />
fi</p>

<p>grep $2 $1|awk &lsquo;{print $2}&rsquo;|grep -o &ldquo;[0-9.]*&rdquo;</p>

<p>把<br />
grep $2 $1|awk &lsquo;{print $2}&rsquo;|grep -o &ldquo;[0-9.]*&rdquo;<br />
改成<br />
grep $2 $1|awk &lsquo;{print $2}&rsquo;|grep -Eo &ldquo;[0-9.]+&rdquo;<br />
楼上这个有问题，如果我要得到的是</p>

<p>中的sharename，那么，呵呵，就错了</p>

<p>我觉得应该先定位到第二个参数“$2”的位置，然后再提取“=”后面的内容</p>

<p>这里有个完整的实现：<br />
Parse Simple XML Files using Bash – Extract Name Value Pairs and Attributes<br />
<a href="http://www.humbug.in/2010/parse-simple-xml-files-using-bash-extract-name-">http://www.humbug.in/2010/parse-simple-xml-files-using-bash-extract-name-</a>
value-pairs-and-attributes/</p>

<p>不过需要安装xmllint.</p>

<p>设计到对多个xml文件进行element的读取和列表。有人做过么？<br />
举个例子，<br />
多个xml文件里面都有</p>

<p>xxx</p>

<p>通过shell读取，然后合并到一起，再生成一个新的xml，但是其他元素不变。</p>

<p>aaa</p>

<p>bbb</p>

<p>如果格式异常简单，没有特例，那么可以用shell实现<br />
如果有可能格式复杂，因为shell的命令所使用的正则表达式都不支持跨行匹配，所以用shell来解决这个问题就绕圈子了。<br />
用perl来作这个工作最直接、简单。perl的XML:DOM模块是专门处理XML文件的。</p>

<p>偶倒是觉得,用PHP写Scripts也很方便,功能强大,而且,跨平台,</p>

<p>#!/bin/sh</p>

<p>sed -n &lsquo;//{</p>

<p>N;</p>

<p>/\n[[:space:]]*/{</p>

<p>N;</p>

<p>/.*/p</p>

<p>}</p>

<p>D;</p>

<p>n</p>

<p>}&rsquo;</p>

<p>这小段代码能把一个xml文件中,你要的东西拿出来.<br />
你可以用for file in $*把这些信息都&gt;&gt;tmpfile中.<br />
然后用sed 在指定文件的指定位置用r命令把tmpfile粘贴进来~~~~</p>

<p>大思路如此^_^ 我想有这个东西(只要能正确的跑出结果)后面就不难了吧&hellip;</p>

<p>Name<br />
xmllint — command line XML tool</p>

<p>Synopsis<br />
xmllint [[&ndash;version] | [&ndash;debug] | [&ndash;shell] | [&ndash;debugent] | [&ndash;copy] |
[&ndash;recover] | [&ndash;noent] | [&ndash;noout] | [&ndash;nonet] | [&ndash;htmlout] | [&ndash;nowrap] |
[&ndash;valid] | [&ndash;postvalid] | [&ndash;dtdvalid URL] | [&ndash;dtdvalidfpi FPI] |
[&ndash;timing] | [&ndash;output file] | [&ndash;repeat] | [&ndash;insert] | [&ndash;compress] |
[&ndash;html] | [&ndash;xmlout] | [&ndash;push] | [&ndash;memory] | [&ndash;maxmem nbbytes] |
[&ndash;nowarning] | [&ndash;noblanks] | [&ndash;nocdata] | [&ndash;format] | [&ndash;encode encoding]
| [&ndash;dropdtd] | [&ndash;nsclean] | [&ndash;testIO] | [&ndash;catalogs] | [&ndash;nocatalogs] |
[&ndash;auto] | [&ndash;xinclude] | [&ndash;noxincludenode] | [&ndash;loaddtd] | [&ndash;dtdattr] |
[&ndash;stream] | [&ndash;walker] | [&ndash;pattern patternvalue] | [&ndash;chkregister] |
[&ndash;relaxng] | [&ndash;schema] | [&ndash;c14n]] [xmlfile]</p>

<p>Introduction<br />
The xmllint program parses one or more XML files, specified on the command
line as xmlfile. It prints various types of output, depending upon the options
selected. It is useful for detecting errors both in XML code and in the XML
parser itself.</p>

<p>It is included in libxml2.</p>

<p>Options<br />
--version<br />
Display the version of libxml2 used.<br />
--debug<br />
Parse a file and output an annotated tree of the in-memory version of the
document.<br />
--shell<br />
Run a navigating shell. Details on available commands in shell mode are below.<br />
--debugent<br />
Debug the entities defined in the document.<br />
--copy<br />
Test the internal copy implementation.<br />
--recover<br />
Output any parsable portions of an invalid document.<br />
--noent<br />
Substitute entity values for entity references. By default, xmllint leaves
entity references in place.<br />
--nocdata<br />
Substitute CDATA section by equivalent text nodes.<br />
--nsclean<br />
Remove redundant namespace declarations.<br />
--noout<br />
Suppress output. By default, xmllint outputs the result tree.<br />
--htmlout<br />
Output results as an HTML file. This causes xmllint to output the necessary
HTML tags surrounding the result tree output so the results can be displayed
in a browser.<br />
--nowrap<br />
Do not output HTML doc wrapper.<br />
--valid<br />
Determine if the document is a valid instance of the included Document Type
Definition (DTD). A DTD to be validated against also can be specified at the
command line using the &ndash;dtdvalid option. By default, xmllint also checks to
determine if the document is well-formed.<br />
--postvalid<br />
Validate after parsing is completed.<br />
--dtdvalid URL<br />
Use the DTD specified by URL for validation.<br />
--dtdvalidfpi FPI<br />
Use the DTD specified by the Public Identifier FPI for validation, note that
this will require a Catalog exporting that Public Identifier to work.<br />
--timing<br />
Output information about the time it takes xmllint to perform the various
steps.<br />
--output file<br />
Define a file path where xmllint will save the result of parsing. Usually the
programs build a tree and save it on stdout, with this option the result XML
instance will be saved onto a file.<br />
--repeat<br />
Repeat 100 times, for timing or profiling.<br />
--insert<br />
Test for valid insertions.<br />
--compress<br />
Turn on gzip compression of output.<br />
--html<br />
Use the HTML parser.<br />
--xmlout<br />
Used in conjunction with &ndash;html. Usually when HTML is parsed the document is
saved with the HTML serializer, but with this option the resulting document is
saved with the XML serializer. This is primarily used to generate XHTML from
HTML input.<br />
--push<br />
Use the push mode of the parser.<br />
--memory<br />
Parse from memory.<br />
--maxmem nnbytes<br />
Test the parser memory support. nnbytes is the maximum number of bytes the
library is allowed to allocate. This can also be used to make sure batch
processing of XML files will not exhaust the virtual memory of the server
running them.<br />
--nowarning<br />
Do not emit warnings from the parser and/or validator.<br />
--noblanks<br />
Drop ignorable blank spaces.<br />
--format<br />
Reformat and reindent the output. The $XMLLINT_INDENT environment variable
controls the indentation (default value is two spaces &ldquo; &ldquo;).<br />
--testIO<br />
Test user input/output support.<br />
--encode encoding<br />
Output in the given encoding.<br />
--catalogs<br />
Use the catalogs from $SGML_CATALOG_FILES. Otherwise /etc/xml/catalog is used
by default.<br />
--nocatalogs<br />
Do not use any catalogs.<br />
--auto<br />
Generate a small document for testing purposes.<br />
--xinclude<br />
Do XInclude processing.<br />
--noxincludenode<br />
Do XInclude processing but do not generate XInclude start and end nodes.<br />
--loaddtd<br />
Fetch external DTD.<br />
--dtdattr<br />
Fetch external DTD and populate the tree with inherited attributes.<br />
--dropdtd<br />
Remove DTD from output.<br />
--stream<br />
Use streaming API - useful when used in combination with &ndash;relaxng or &ndash;valid
options for validation of files that are too large to be held in memory.<br />
--walker<br />
Test the walker module, which is a reader interface but for a document tree,
instead of using the reader API on an unparsed document it works on a existing
in-memory tree. Used in debugging.<br />
--chkregister<br />
Turn on node registration. Useful for developers testing libxml2 node tracking
code.<br />
--pattern patternvalue<br />
Used to exercise the pattern recognition engine, which can be used with the
reader interface to the parser. It allows to select some nodes in the document
based on an XPath (subset) expression. Used for debugging.<br />
--relaxng schema<br />
Use RelaxNG file named schema for validation.<br />
--schema schema<br />
Use a W3C XML Schema file named schema for validation.<br />
--c14n<br />
Use the W3C XML Canonicalisation (C14N) to serialize the result of parsing to
stdout. It keeps comments in the result.<br />
Shell<br />
xmllint offers an interactive shell mode invoked with the &ndash;shell command.
Available commands in shell mode include:</p>

<p>base<br />
display XML base of the node<br />
bye<br />
leave shell<br />
cat node<br />
Display node if given or current node.<br />
cd path<br />
Change the current node to path (if given and unique) or root if no argument
given.<br />
dir path<br />
Dumps information about the node (namespace, attributes, content).<br />
du path<br />
Show the structure of the subtree under path or the current node.<br />
exit<br />
Leave the shell.<br />
help<br />
Show this help.<br />
free<br />
Display memory usage.<br />
load name<br />
Load a new document with the given name.<br />
ls path<br />
List contents of path (if given) or the current directory.<br />
pwd<br />
Display the path to the current node.<br />
quit<br />
Leave the shell.<br />
save name<br />
Saves the current document to name if given or to the original name.<br />
validate<br />
Check the document for error.<br />
write name<br />
Write the current node to the given filename.<br />
Catalogs<br />
Catalog behavior can be changed by redirecting queries to the user&rsquo;s own set
of catalogs. This can be done by setting the XML_CATALOG_FILES environment
variable to a list of catalogs. An empty one should deactivate loading the
default /etc/xml/catalog default catalog.</p>

<p>Debugging Catalogs<br />
Setting the environment variable XML_DEBUG_CATALOG using the command &ldquo;export
XML_DEBUG_CATALOG=&rdquo; outputs debugging information related to catalog
operations.</p>

<p>Error Return Codes<br />
On the completion of execution, Xmllint returns the following error codes:</p>

<p>0<br />
No error<br />
1<br />
Unclassified<br />
2<br />
Error in DTD<br />
3<br />
Validation error<br />
4<br />
Validation error<br />
5<br />
Error in schema compilation<br />
6<br />
Error writing output<br />
7<br />
Error in pattern (generated when [&ndash;pattern] option is used)<br />
8<br />
Error in Reader registration (generated when [&ndash;chkregister] option is used)<br />
9<br />
Out of memory error</p>

<p>Parse Simple XML Files using Bash – Extract Name Value Pairs and Attributes</p>

<p>2 Comments<br />
1<br />
Tweet</p>

<p>Pratik Sinha | July 31, 2010</p>

<p>I have written up a simple routine par<strong><em>ML to parse simple XML files to
extract unique name values pairs and their attributes. The script extracts all
xml tags of the format xyz and dynamically creates bash variables which hold
values of the attributes as well as the elements. This is a good solution, if
you don’t wish to use xpath for some simple xml files. However you will need
xmllint installed on your system to use the script. Here’s a sample script
which uses the par</em></strong>ML function<br />
#!/bin/bash<br />
xmlFile=$1</p>

<p>function par**<em>ML() {<br />
elemList=( $(cat $xmlFile | tr &lsquo;\n&rsquo; &lsquo; &rsquo; | XMLLINT_INDENT=&ldquo;&rdquo; xmllint &ndash;format -
| /bin/grep -e &ldquo;$&rdquo; | while read line; do \<br />
echo $line | sed -e &rsquo;s/^.</em>&rsquo; -f 1; \<br />
done) )</p>

<p>totalNoOfTags=${#elemList[@]}; ((totalNoOfTags&ndash;))<br />
suffix=$(echo ${elemList[$totalNoOfTags]} | tr -d &lsquo;&gt;&rsquo;)<br />
suffix=&ldquo;${suffix}_&rdquo;</p>

<p>for (( i = 0 ; i &lt; ${#elemList[@]} ; i++ )); do<br />
elem=${elemList[$i]}<br />
elemLine=$(cat $xmlFile | tr &lsquo;\n&rsquo; &lsquo; &rsquo; | XMLLINT<em>INDENT=&ldquo;&rdquo; xmllint &ndash;format - |
/bin/grep &ldquo;$elem&gt;&rdquo;)<br />
echo $elemLine | grep -e &ldquo;^[^ ]<em>&gt;$&rdquo; 1&gt;/dev/null 2&gt;&amp;1<br />
if [ &ldquo;0&rdquo; = &ldquo;$?&rdquo; ]; then<br />
continue<br />
fi<br />
elemVal=$(echo $elemLine | tr &lsquo;\011&rsquo; &lsquo;\040&rsquo;| sed -e &rsquo;s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">25</a></sup></em>//&rsquo; -e
&rsquo;s/^&lt;.&gt;\([^$/\1/&rsquo; | sed -e &rsquo;s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">26</a></sup><em>//&rsquo; | sed -e &rsquo;s/[ ]</em>$//&lsquo;)<br />
xmlElem=&ldquo;${suffix}$(echo $elem | sed &rsquo;s/-/</em>/g&rsquo;)&rdquo;<br />
eval ${xmlElem}=<code>echo -ne \&quot;&quot;${elemVal}&quot;\&quot;</code><br />
attrList=($(cat $xmlFile | tr &lsquo;\n&rsquo; &lsquo; &rsquo; | XMLLINT_INDENT=&ldquo;&rdquo; xmllint &ndash;format -
| /bin/grep &ldquo;$elem&gt;&rdquo; | tr &lsquo;\011&rsquo; &lsquo;\040&rsquo; | sed -e &rsquo;s/<sup class="footnote-ref" id="fnref:-"><a href="#fn:-">27</a></sup>*//&rsquo; | cut -d &lsquo;&gt;&rsquo; -f 1
| sed -e &rsquo;s/^&lsquo;))<br />
for (( j = 0 ; j &lt; ${#attrList[@]} ; j++ )); do<br />
attr=${attrList[$j]}<br />
((j++))<br />
attrVal=$(echo ${attrList[$j]} | tr &lsquo;&gt;&rsquo; &lsquo; &lsquo;)<br />
attrName=<code>echo -ne ${xmlElem}_${attr}</code><br />
eval ${attrName}=<code>echo -ne \&quot;&quot;${attrVal}&quot;\&quot;</code><br />
done<br />
done<br />
}</p>

<p>par***ML<br />
echo &ldquo;$status_xyz | $status_abc | $status_pqr&rdquo; #Variables for each XML ELement<br />
echo &ldquo;$status_xyz_arg1 | $status_abc_arg2 | $status_pqr_arg3 |
$status_pqr_arg4&rdquo; #Variables for each XML Attribute<br />
echo &ldquo;&rdquo;</p>

<p>#All the variables that were produced by the par***ML function<br />
set | /bin/grep -e &ldquo;^$suffix&rdquo;</p>

<p>The XML File used for the above script example is:</p>

<p>a<br />
p<br />
x</p>

<p>The root tag, which in this case is “status”, is used as a suffix for all
variables. Once the XML file is passed to the function, it dynamically creates
the variables $status_xyz, $status_abc, $status_pqr, $status_xyz_arg1,
$status_abc_arg2, $status_pqr_arg3 and $status_pqr_arg4.</p>

<p>The output when the script is ran with the xml file as an argument is<br />
@$ bash par***ML.sh test.xml<br />
a | p | x<br />
1 | 2 | 3 | a phrase</p>

<p>status_abc=p<br />
status_abc_arg2=2<br />
status_pqr=x<br />
status_pqr_arg3=3<br />
status_pqr_arg4=&lsquo;a phrase&rsquo;<br />
status_xyz=a<br />
status_xyz_arg1=1</p>

<p>This script won’t work for XML files like the one below with duplicate element
names.</p>

<p>a<br />
p<br />
x</p>

<p>This script also won’t be able to extract attributes of elements without any
CDATA. For eg, the script won’t be able to create variables corresponding to .
It will only create the variables corresponding to abc.</p>

<p>abc</p>

<p>38.写入XML数据库<br />
#!/bin/bash</p>

<p>39.ZIP压缩文件<br />
#!/bin/sh<br />
zip -r &ldquo;/%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>40.ZIP解压缩<br />
#!/bin/sh<br />
unzip -x &ldquo;/%%1&rdquo; &ldquo;%%2&rdquo;</p>

<p>41.获得应用程序完整路径<br />
#!/bin/bash</p>

<p>42.ZIP压缩文件夹<br />
#!/bin/bash</p>

<p>43.递归删除目录下的文件<br />
#!/bin/bash<br />
rm -if &ldquo;%%1/<em>&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find %%1 -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in $path/</em>.c $path/<em>.cpp<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \</em>.[A-Za-z]+ ]]; then<br />
#&ldquo;$(path)/$(file)&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>44.IDEA加密算法<br />
#!/bin/bash</p>

<p>45.RC6算法<br />
#!/bin/bash<br />
cat &lt; rc6.c<br />
#include<br />
/* Timing data for RC6 (rc6.c)</p>

<p>128 bit key:<br />
Key Setup: 1632 cycles<br />
Encrypt: 270 cycles = 94.8 mbits/sec<br />
Decrypt: 226 cycles = 113.3 mbits/sec<br />
Mean: 248 cycles = 103.2 mbits/sec</p>

<p>192 bit key:<br />
Key Setup: 1885 cycles<br />
Encrypt: 267 cycles = 95.9 mbits/sec<br />
Decrypt: 235 cycles = 108.9 mbits/sec<br />
Mean: 251 cycles = 102.0 mbits/sec</p>

<p>256 bit key:<br />
Key Setup: 1877 cycles<br />
Encrypt: 270 cycles = 94.8 mbits/sec<br />
Decrypt: 227 cycles = 112.8 mbits/sec<br />
Mean: 249 cycles = 103.0 mbits/sec</p>

<p>*/</p>

<p>#include &ldquo;../std_defs.h&rdquo;</p>

<p>static char *alg_name[] = { &ldquo;rc6&rdquo;, &ldquo;rc6.c&rdquo;, &ldquo;rc6&rdquo; };</p>

<p>char **cipher_name()<br />
{<br />
return alg_name;<br />
}</p>

<p>#define f_rnd(i,a,b,c,d) \<br />
u = rotl(d * (d + d + 1), 5); \<br />
t = rotl(b * (b + b + 1), 5); \<br />
a = rotl(a ^ t, u) + l_key; \<br />
c = rotl(c ^ u, t) + l_key[i + 1]</p>

<p>#define i_rnd(i,a,b,c,d) \<br />
u = rotl(d * (d + d + 1), 5); \<br />
t = rotl(b * (b + b + 1), 5); \<br />
c = rotr(c - l_key[i + 1], t) ^ u; \<br />
a = rotr(a - l_key, u) ^ t</p>

<p>u4byte l_key[44]; /* storage for the key schedule */</p>

<p>/* initialise the key schedule from the user supplied key */</p>

<p>u4byte *set_key(const u4byte in_key[], const u4byte key_len)<br />
{ u4byte i, j, k, a, b, l[8], t;</p>

<p>l_key[0] = 0xb7e15163;</p>

<p>for(k = 1; k &lt; 44; ++k)</p>

<p>l_key[k] = l_key[k - 1] + 0x9e3779b9;</p>

<p>for(k = 0; k &lt; key_len / 32; ++k)</p>

<p>l[k] = in_key[k];</p>

<p>t = (key_len / 32) - 1; // t = (key_len / 32);</p>

<p>a = b = i = j = 0;</p>

<p>for(k = 0; k &lt; 132; ++k)<br />
{ a = rotl(l_key + a + b, 3); b += a;<br />
b = rotl(l[j] + b, b);<br />
l_key = a; l[j] = b;<br />
i = (i == 43 ? 0 : i + 1); // i = (i + 1) % 44;<br />
j = (j == t ? 0 : j + 1); // j = (j + 1) % t;<br />
}</p>

<p>return l_key;<br />
};</p>

<p>/* encrypt a block of text */</p>

<p>void encrypt(const u4byte in_blk[4], u4byte out_blk[4])<br />
{ u4byte a,b,c,d,t,u;</p>

<p>a = in_blk[0]; b = in_blk[1] + l_key[0];<br />
c = in_blk[2]; d = in_blk[3] + l_key[1];</p>

<p>f_rnd( 2,a,b,c,d); f_rnd( 4,b,c,d,a);<br />
f_rnd( 6,c,d,a,b); f_rnd( 8,d,a,b,c);<br />
f_rnd(10,a,b,c,d); f_rnd(12,b,c,d,a);<br />
f_rnd(14,c,d,a,b); f_rnd(16,d,a,b,c);<br />
f_rnd(18,a,b,c,d); f_rnd(20,b,c,d,a);<br />
f_rnd(22,c,d,a,b); f_rnd(24,d,a,b,c);<br />
f_rnd(26,a,b,c,d); f_rnd(28,b,c,d,a);<br />
f_rnd(30,c,d,a,b); f_rnd(32,d,a,b,c);<br />
f_rnd(34,a,b,c,d); f_rnd(36,b,c,d,a);<br />
f_rnd(38,c,d,a,b); f_rnd(40,d,a,b,c);</p>

<p>out_blk[0] = a + l_key[42]; out_blk[1] = b;<br />
out_blk[2] = c + l_key[43]; out_blk[3] = d;<br />
};</p>

<p>/* decrypt a block of text */</p>

<p>void decrypt(const u4byte in_blk[4], u4byte out_blk[4])<br />
{ u4byte a,b,c,d,t,u;</p>

<p>d = in_blk[3]; c = in_blk[2] - l_key[43];<br />
b = in_blk[1]; a = in_blk[0] - l_key[42];</p>

<p>i_rnd(40,d,a,b,c); i_rnd(38,c,d,a,b);<br />
i_rnd(36,b,c,d,a); i_rnd(34,a,b,c,d);<br />
i_rnd(32,d,a,b,c); i_rnd(30,c,d,a,b);<br />
i_rnd(28,b,c,d,a); i_rnd(26,a,b,c,d);<br />
i_rnd(24,d,a,b,c); i_rnd(22,c,d,a,b);<br />
i_rnd(20,b,c,d,a); i_rnd(18,a,b,c,d);<br />
i_rnd(16,d,a,b,c); i_rnd(14,c,d,a,b);<br />
i_rnd(12,b,c,d,a); i_rnd(10,a,b,c,d);<br />
i_rnd( 8,d,a,b,c); i_rnd( 6,c,d,a,b);<br />
i_rnd( 4,b,c,d,a); i_rnd( 2,a,b,c,d);</p>

<p>out_blk[3] = d - l_key[1]; out_blk[2] = c;<br />
out_blk[1] = b - l_key[0]; out_blk[0] = a;<br />
};<br />
int main()<br />
{</p>

<p>return 0;<br />
}<br />
EOF<br />
gcc -o rc6 rc6.c<br />
if [ $? -eq 0 ]; then<br />
./combine<br />
else<br />
echo &lsquo;Compile ERROR&rsquo;<br />
fi</p>

<p>46.Grep<br />
#!/bin/bash<br />
grep -qE %%1 %%2</p>

<p>47.直接创建多级目录<br />
#!/bin/bash<br />
mkdir -p %%1</p>

<p>48.批量重命名<br />
#!/bin/bash<br />
find $PWD -type f -name &lsquo;*\.cpp&rsquo; |sed s/&rsquo;\.cpp&rsquo;//g|awk &lsquo;{MV = &ldquo;mv&rdquo;};{C =
&ldquo;\.c&rdquo;};{ CPP=&rdquo;\.cpp&rdquo;}; {print MV, $1 CPP , $1 C}&lsquo;|sh<br />
ls | awk -F &lsquo;-&rsquo; &lsquo;{print &ldquo;mv &ldquo;$0&rdquo; &ldquo;$2}&rsquo; #去掉带&rsquo;-&lsquo;的前缀</p>

<p>49.文本查找替换<br />
#!/bin/bash<br />
sed -e &rsquo;s:%%2:%%3:g&rsquo; %%1<br />
#sed -e &rsquo;s/%%2/%%3/g&rsquo; %%1</p>

<p>50.文件关联<br />
#!/bin/bash</p>

<p>51.批量转换编码从GB2312到Unicode<br />
#!/bin/bash<br />
scode=&ldquo;gbk&rdquo;<br />
dcode=&ldquo;ucs2&rdquo;<br />
for FILE in $(find $(pwd) -type f)<br />
do<br />
TMP_file=$(mktemp -p $(pwd))<br />
if [ -f $FILE ]; then<br />
Fright=$(stat -c %a $FILE)<br />
Fuser=$(stat -c %U $FILE)<br />
Fgrp=$(stat -c %G $FILE)<br />
iconv -f $scode -t $dcode $FILE -o $TMP_file<br />
mv $TMP_file $FILE<br />
chmod $Fright $FILE<br />
chown $Fuser.$Fgrp $FILE<br />
fi<br />
done</p>

<p>52.设置JDK环境变量<br />
#!/bin/bash<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;<em>.bin&rsquo; \) -print0 | xargs -0 chmod +x<br />
find -type f \( -iname &lsquo;</em>.bin&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.bin)<br />
xterm -e &ldquo;$filename&rdquo; &amp;&amp; rm -if &ldquo;$filename&rdquo;<br />
;;<br />
esac<br />
done<br />
OLDIFS=$IFS<br />
IFS=$&rsquo;\n&rsquo;<br />
for line in <code>cat ~/.bashrc</code><br />
do<br />
if [[ &ldquo;$line&rdquo; =~ .<em>export.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ .<em>JAVA_HOME=.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]]; then<br />
javahome=$line<br />
fi<br />
fi<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ PATH=\$PATH:\$JAVA_HOME/bin:\$JAVA_HOME/jre/bin$
]];then<br />
javapath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ CLASSPATH=.:\$JAVA_HOME/lib:\$JAVA_HOME/jre/lib$
]];then<br />
classpath=$line<br />
fi<br />
done<br />
if [ ! -n &ldquo;$javahome&rdquo; ]; then<br />
sed -i &lsquo;$a export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_25&rsquo; ~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${javahome//\\/\\\\}&rsquo;:export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_32:g&rsquo;
~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$javapath&rdquo; ]; then<br />
sed -i &lsquo;$a export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&rsquo; ~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$classpath&rdquo; ]; then<br />
sed -i &lsquo;$a export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib&rsquo; ~/.bashrc<br />
fi<br />
IFS=$OLDIFS</p>

<p>#!/bin/bash<br />
shift<br />
OLDIFS=$IFS<br />
IFS=$&rsquo;\n&rsquo;<br />
for line in <code>cat ~/TestBash.txt</code> #~/.bashrc<br />
do<br />
if [[ &ldquo;$line&rdquo; =~ .<em>export.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ export\ CLASSPATH=.:\$JAVA_HOME/lib:\$JAVA_HOME/jre/lib$ ]];
then<br />
classpath=$line<br />
elif [[ &ldquo;$line&rdquo; =~ export\ PATH=\$PATH:\$CATALINA_HOME/bin$ ]]; then<br />
jbosspath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ .<em>JAVA_HOME=.</em> ]]; then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
javahome=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>CATALINA_HOME=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
catalinahome=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>TOMCAT_HOME=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
tomcathome=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>CATALINA_BASE=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
catalinabase=$line<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ .<em>JBOSS_HOME=.</em> ]];then<br />
if [[ &ldquo;$line&rdquo; =~ =(\/([0-9a-zA-Z._]+))+ ]];then<br />
jbosshome=$line<br />
fi<br />
fi<br />
elif [[ &ldquo;$line&rdquo; =~ ^PATH=\$PATH:\$JAVA_HOME/bin:\$JAVA_HOME/jre/bin$ ]];then<br />
javapath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ CLASSPATH=.:\$JAVA_HOME/lib:\$JAVA_HOME/jre/lib$
]];then<br />
classpath=$line<br />
fi<br />
if [[ &ldquo;$line&rdquo; =~ export\ PATH=\$PATH:\$JBOSS_HOME/bin$ ]];then<br />
jbosspath=$line<br />
fi<br />
done<br />
if [ ! -n &ldquo;$javahome&rdquo; ]; then<br />
sed -i &lsquo;$a export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_24&rsquo; ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${javahome//\\/\\\\}&rsquo;:export JAVA_HOME=&lsquo;$(pwd)&rsquo;/jdk1.6.0_24:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$javapath&rdquo; ]; then<br />
sed -i &lsquo;$a PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&rsquo; ~/TestBash.txt
#~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$classpath&rdquo; ]; then<br />
sed -i &lsquo;$a export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib&rsquo;
~/TestBash.txt #~/.bashrc<br />
fi<br />
if [ ! -n &ldquo;$catalinahome&rdquo; ]; then<br />
sed -i &lsquo;$a export CATALINA_HOME=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${catalinahome//\\/\\\\}&rsquo;:export CATALINA_HOME=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$tomcathome&rdquo; ]; then<br />
sed -i &lsquo;$a export TOMCAT_HOME=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${tomcathome//\\/\\\\}&rsquo;:export TOMCAT_HOME=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$catalinabase&rdquo; ]; then<br />
sed -i &lsquo;$a export CATALINA_BASE=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${catalinabase//\\/\\\\}&rsquo;:export CATALINA_BASE=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$jbosshome&rdquo; ]; then<br />
sed -i &lsquo;$a export JBOSS_HOME=&lsquo;$(pwd) ~/TestBash.txt #~/.bashrc<br />
else<br />
sed -i &rsquo;s:&lsquo;${jbosshome//\\/\\\\}&rsquo;:export JBOSS_HOME=&lsquo;$(pwd)&rsquo;:g&rsquo;
~/TestBash.txt<br />
fi<br />
if [ ! -n &ldquo;$jbosspath&rdquo; ]; then<br />
sed -i &lsquo;$a export PATH=$PATH:$CATALINA_HOME/bin&rsquo; ~/TestBash.txt #~/.bashrc<br />
fi<br />
IFS=$OLDIFS</p>

<p>53.批量转换编码从Unicode到GB2312<br />
#!/bin/bash<br />
scode=&ldquo;ucs2&rdquo;<br />
dcode=&ldquo;gbk&rdquo;<br />
for FILE in $(find $(pwd) -type f)<br />
do<br />
TMP_file=$(mktemp -p $(pwd))<br />
if [ -f $FILE ]; then<br />
Fright=$(stat -c %a $FILE)<br />
Fuser=$(stat -c %U $FILE)<br />
Fgrp=$(stat -c %G $FILE)<br />
iconv -f $scode -t $dcode $FILE -o $TMP_file<br />
mv $TMP_file $FILE<br />
chmod $Fright $FILE<br />
chown $Fuser.$Fgrp $FILE<br />
fi<br />
done</p>

<p>54.删除空文件夹<br />
#!/bin/bash<br />
rmdir -p %%1</p>

<p>55.GB2312文件转UTF-8格式<br />
#!/bin/bash<br />
iconv -f gbk -t utf8 %%1 -o %%2</p>

<p>56.UTF-8文件转GB2312格式<br />
#!/bin/bash<br />
iconv -f utf8 -t gbk %%1 -o %%2</p>

<p>57.获取文件路径的父路径<br />
#!/bin/bash<br />
%%1=basename $PWD</p>

<p>58.Unicode文件转UTF-8格式<br />
#!/bin/bash<br />
iconv -f ucs2 -t utf-8 %%1 -o %%2</p>

<p>59.CRC循环冗余校验<br />
#!/bin/bash<br />
cat &lt; crc.c<br />
#include</p>

<p>unsigned long int crc32_table[256];</p>

<p>unsigned long int ulPolynomial = 0x04c11db7;</p>

<p>unsigned long int Reflect(unsigned long int ref, char ch)</p>

<p>{ unsigned long int value(0);</p>

<p>// 交换bit0和bit7，bit1和bit6，类推</p>

<p>for(int i = 1; i &lt; (ch + 1); i++)</p>

<p>{ if(ref &amp; 1)</p>

<p>value |= 1 &lt;&lt; (ch - i);</p>

<p>ref &gt;&gt;= 1; }</p>

<p>return value;</p>

<p>}</p>

<p>init_crc32_table()</p>

<p>{ unsigned long int crc,temp;</p>

<p>// 256个值</p>

<p>for(int i = 0; i &lt;= 0xFF; i++)</p>

<p>{ temp=Reflect(i, 8);</p>

<p>crc32_table[i]= temp&lt;&lt; 24;</p>

<p>for (int j = 0; j &lt; 8; j++){</p>

<p>unsigned long int t1,t2;</p>

<p>unsigned long int flag=crc32_table[i]&0x80000000;</p>

<p>t1=(crc32_table[i] &lt;&lt; 1);</p>

<p>if(flag==0)</p>

<p>t2=0;</p>

<p>else</p>

<p>t2=ulPolynomial;</p>

<p>crc32_table[i] =t1^t2 ; }</p>

<p>crc=crc32_table[i];</p>

<p>crc32_table[i] = Reflect(crc32_table[i], 32);<br />
}<br />
}<br />
unsigned long GenerateCRC32(char xdata * DataBuf,unsigned long len)</p>

<p>{</p>

<p>unsigned long oldcrc32;</p>

<p>unsigned long crc32;</p>

<p>unsigned long oldcrc;</p>

<p>unsigned int charcnt;</p>

<p>char c,t;</p>

<p>oldcrc32 = 0x00000000; //初值为0</p>

<p>charcnt=0;</p>

<p>while (len&ndash;) {</p>

<p>t= (oldcrc32 &gt;&gt; 24) &amp; 0xFF; //要移出的字节的值</p>

<p>oldcrc=crc_32_tab[t]; //根据移出的字节的值查表</p>

<p>c=DataBuf[charcnt]; //新移进来的字节值</p>

<p>oldcrc32= (oldcrc32 &lt;&lt; 8) | c; //将新移进来的字节值添在寄存器末字节中</p>

<p>oldcrc32=oldcrc32^oldcrc; //将寄存器与查出的值进行xor运算</p>

<p>charcnt++;</p>

<p>}</p>

<p>crc32=oldcrc32;</p>

<p>return crc32;</p>

<p>}</p>

<p>参数表可以先在PC机上算出来，也可在程序初始化时完成。下面是用于计算参数表的c语言子程序，在Visual C++ 6.0下编译通过。</p>

<p>#include</p>

<p>unsigned long int crc32_table[256];</p>

<p>unsigned long int ulPolynomial = 0x04c11db7;</p>

<p>unsigned long int Reflect(unsigned long int ref, char ch)</p>

<p>{ unsigned long int value(0);</p>

<p>// 交换bit0和bit7，bit1和bit6，类推</p>

<p>for(int i = 1; i &lt; (ch + 1); i++)</p>

<p>{ if(ref &amp; 1)</p>

<p>value |= 1 &lt;&lt; (ch - i);</p>

<p>ref &gt;&gt;= 1; }</p>

<p>return value;</p>

<p>}<br />
int main()<br />
{<br />
unsigned long int crc,temp;</p>

<p>// 256个值</p>

<p>for(int i = 0; i &lt;= 0xFF; i++)</p>

<p>{<br />
temp=Reflect(i, 8);<br />
crc32_table[i]= temp&lt;&lt; 24;</p>

<p>for (int j = 0; j &lt; 8; j++){</p>

<p>unsigned long int t1,t2;</p>

<p>unsigned long int flag=crc32_table[i]&0x80000000;<br />
t1=(crc32_table[i] &lt;&lt; 1);</p>

<p>if(flag==0)</p>

<p>t2=0;</p>

<p>else</p>

<p>t2=ulPolynomial;</p>

<p>crc32_table[i] =t1^t2 ;<br />
}</p>

<p>crc=crc32_table[i];<br />
crc32_table[i] = Reflect(crc32_table[i], 32);<br />
}<br />
return 0;<br />
}<br />
EOF<br />
gcc -o crc crc.c<br />
if [ $? -eq 0 ]; then<br />
./combine<br />
else<br />
echo &lsquo;Compile ERROR&rsquo;<br />
fi</p>

<p>60.判断是否为空文件<br />
#!/bin/bash</p>

<p>61.终止程序<br />
#!/bin/sh<br />
kill -KILL pidof %%1 -s<br />
#killall %%1</p>

<p>62.定时关机<br />
#!/bin/sh<br />
shutdown -h %%1 &amp; #23:00<br />
#shutdown -h now<br />
#halt<br />
#/sbin/poweroff<br />
#init 0</p>

<p>63.显示进程列表<br />
#!/bin/sh<br />
ps aux<br />
#fuser -l</p>

<p>64.遍历文件夹列出文件大小<br />
#!/bin/sh<br />
du -sH &ldquo;%%1/*&rdquo;</p>

<p>65.GOST算法<br />
#!/bin/bash</p>

<p>66.对目标压缩文件解压缩到指定文件夹<br />
#!/bin/bash</p>

<p>67.保存文件时重名自动生成新文件<br />
#!/bin/bash</p>

<p>68.打开网页<br />
#!/bin/sh<br />
lynx %%1</p>

<p>69.删除空文件夹整合操作<br />
#!/bin/bash</p>

<p>70.获取磁盘所有分区<br />
#!/bin/sh<br />
df -k</p>

<p>71.激活一个程序或程序关联的文件<br />
#!/bin/bash</p>

<p>72.MP3播放<br />
#!/bin/sh<br />
amp &ldquo;%%1&rdquo;</p>

<p>73.WAV播放<br />
#!/bin/sh<br />
amp &ldquo;%%1&rdquo;</p>

<p>74.写图像到剪切板<br />
#!/bin/bash</p>

<p>75.从剪贴板复制图像到窗体<br />
#!/bin/bash</p>

<p>76.删除文件夹下的所有文件且不删除文件夹下的文件夹<br />
#!/bin/sh<br />
rm -if &ldquo;%%1/*&rdquo;</p>

<p>77.XML遍历结点属性值<br />
#!/bin/bash</p>

<p>78.Unicode文件转GB2312格式<br />
#!/bin/sh<br />
iconv -f ucs2 -t gbk %%1 -o %%2</p>

<p>79.开源程序库Xercesc-C++代码工程中内联80.提取包含头文件列表<br />
#!/bin/bash</p>

<p>81.GB2312文件转Unicode格式<br />
#!/bin/sh<br />
iconv -f gbk -t ucs2 %%1 -o %%2</p>

<p>82.Java程序打包<br />
#!/bin/bash</p>

<p>83.UTF-8文件转Unicode格式<br />
#!/bin/bash<br />
iconv -f utf8 -t ucs2 %%1 -o %%2</p>

<p>84.创建PDF文档<br />
#!/bin/bash</p>

<p>85.创建Word文档<br />
#!/bin/bash</p>

<p>86.快速高效的文件加密<br />
#!/bin/bash</p>

<p>87.从CSV文件构造XML文档<br />
#!/bin/bash</p>

<p>88.从XML文档生成CSV文件<br />
#!/bin/bash</p>

<p>89.模拟键盘输入字符串<br />
#!/bin/bash</p>

<p>90.提取PDF文件中的文本<br />
#!/bin/bash</p>

<p>91.操作内存映射文件<br />
#!/bin/bash<br />
91.1发送内存映射数据<br />
#!/bin/bash</p>

<p>91.2接收内存映射数据<br />
#!/bin/bash</p>

<p>92.重定向windows控制台程序的输出信息<br />
#!/bin/bash</p>

<p>93.基数转序数<br />
#!/bin/bash</p>

<p>94.数字月份转英文<br />
#!/bin/bash</p>

<p>95.报表相关<br />
#!/bin/bash</p>

<p>96.根据进程名获取进程ID<br />
#!/bin/bash<br />
pidof %%1 -s</p>

<p>96.BCP导入<br />
#!/bin/bash</p>

<p>97.BCP导出<br />
#!/bin/bash</p>

<p>98.计算文件MD5值<br />
#!/bin/bash<br />
md5sum &ldquo;%%1&rdquo;</p>

<p>99.计算获取文件夹中文件的MD5值<br />
#!/bin/bash</p>

<p>100.复制一个目录下所有文件到一个文件夹中<br />
#!/bin/bash<br />
cp $(find &ldquo;%%1&rdquo; -name <em>.</em>) &ldquo;%%2&rdquo;</p>

<p>101.移动一个目录下所有文件到一个文件夹中<br />
#!/bin/bash<br />
mv $(find &ldquo;%%1&rdquo; -name <em>.</em>) &ldquo;%%2&rdquo;</p>

<p>102.文件RSA高级加密<br />
十进制到十六进制<br />
typeset -i16 BASE_16_NUM<br />
BASE_16_NUM=%%1<br />
echo $BASE_16_NUM</p>

<p>八进制到十六进制<br />
#!/bin/bash<br />
typeset -i16 BASE_16_NUM<br />
BASE_16_NUM=8#%%1<br />
echo $BASE_16_NUM</p>

<p>十进制到八进制<br />
#!/bin/bash<br />
printf %o %%1; echo</p>

<p>十进制到十六进制<br />
#!/bin/bash<br />
printf %x %%1; echo</p>

<p>103.计算文件大小<br />
#!/bin/bash<br />
wc &ldquo;%%1&rdquo;</p>

<p>104.计算文件夹的大小<br />
#!/sbin/ksh<br />
dir=%%1<br />
(cd $dir;pwd)<br />
find $dir -type d -print | du | awk &lsquo;{print $2, &ldquo;== (&rdquo;$<sup>1</sup>&frasl;<sub>2</sub>&rdquo;kb)&ldquo;}&rsquo; |sort -f |<br />
sed -e &ldquo;s,[^ /]<em>/([^ /]</em>) ==,|&ndash;1,&rdquo; -e&rdquo;s,[^ /]*/,| ,g&rdquo;</p>

<p>105.快速获得当前程序的驱动器、路径、文件名和扩展名</p>

<p>106.磁盘剩余空间计算<br />
#!/bin/bash<br />
df -k</p>

<p>107.获取当前程序进程ID<br />
#!/bin/bash<br />
pidof %%1 -s</p>

<p>108.全盘搜索文件<br />
#!/bin/bash<br />
#updatedb<br />
#locate %%1<br />
slocate %%1</p>

<p>109.获得当前登录的用户名<br />
#!/bin/bash<br />
whoami</p>

<p>110.获得所有用户名<br />
#!/bin/bash<br />
who</p>

<p>111.创建MySQL管理用户<br />
#!/bin/bash<br />
mysqladmin -u root password %%1</p>

<p>112.管理MySQL数据库服务器<br />
#!/bin/bash<br />
112.1.启动MySQL数据库服务器<br />
mysqld -console</p>

<p>112.2.登录MySQL数据库服务器<br />
112.2.1.登录本地MySQL数据库服务器<br />
mysql -uroot -p%%1</p>

<p>112.2.2.登录远程MySQL数据库服务器<br />
mysql -h %%1 -u %%2 -p%%3</p>

<p>112.3.关闭MySQL数据库服务器<br />
mysqladmin -u root shutdown<br />
#pkill -9 mysql</p>

<p>112.4.测试MySQL数据库服务器<br />
mysqlshow || mysqlshow -u root mysql || mysqladmin version status || mysql
test</p>

<p>113.MySQL执行查询<br />
#!/bin/sh<br />
mysqladmin -u %%1 -p%%2 SELECT * INTO OUTFILE &lsquo;./bestlovesky.xls&rsquo; FROM
bestlovesky WHERE 1 ORDER BY id DESC LIMIT 0, 50;</p>

<p>mysql -u %%1 -p%%2 -e &ldquo;SELECT * INTO OUTFILE &lsquo;./bestlovesky.xls&rsquo; FROM
bestlovesky WHERE 1 ORDER BY id DESC LIMIT 0, 50;&rdquo;</p>

<p>114.创建Oracle管理用户<br />
#!/bin/sh<br />
114.1.创建新用户<br />
create user test identified by test default tablespace ts_test temporary<br />
tablespace temp;</p>

<p>114.2.给用户角色特权<br />
grant connect,resource to test;</p>

<p>115.登录Oracle数据库<br />
#!/bin/bash<br />
sqlplusw<br />
sqlplus /nolog<br />
conn username/password@Oranet<br />
conn system/systempwd@whfc<br />
conn sys/syspwd@whfc as sysdba</p>

<p>115.创建Oracle表空间<br />
#!/bin/bash<br />
conn system@whfc01<br />
create tablespace ts_test datafile &lsquo;/data2/oradata/ciis/ts_test01.dbf&rsquo; size</p>

<p>116.添加Oracle数据文件<br />
#!/bin/bash<br />
alter tablespace ts_test add datafile &lsquo;/data2/oradata/ciis/ts_test02.dbf&rsquo; size</p>

<p>117.查看Oracle表空间大小<br />
#!/bin/bash<br />
desc DBA_DATA_FILES</p>

<p>118.查看Oracle剩余表空间大小<br />
#!/bin/bash<br />
desc DBA_FREE_SPACE</p>

<p>119.查看Oracle当前用户表名<br />
#!/bin/bash<br />
select * from tab;</p>

<p>120.Oracle创建索引<br />
#!/bin/bash<br />
CREATE INDEX idx_book_bookid ON book(bookname);</p>

<p>121.Oracle创建主键约束<br />
#!/bin/bash<br />
ALTER TABLE book ADD CONSTRAINT pk_book_bookid PRIMARY KEY (bookid);</p>

<p>122.Oracle显示表结构<br />
#!/bin/bash<br />
desc book</p>

<p>123.Oracle查看表的索引<br />
#!/bin/bash<br />
column index_name format a30<br />
select table_name, index_name from user_indexes;</p>

<p>124.Oracle查看索引列<br />
#!/bin/bash<br />
select table_name, index_name, column_name, column_position from
user_ind_columns;</p>

<p>125.Oracle查看数据段占空间大小<br />
#!/bin/bash<br />
desc user_segments</p>

<p>126.Oracle查看表占空间大小<br />
#!/bin/bash<br />
select segment_name,segment_type,bytes from user_segments where
segment_type=&lsquo;TABLE&rsquo;;</p>

<p>127.安全删除USB<br />
#!/bin/bash<br />
rundll32.exe shell32.dll,Control_RunDLL hotplug.dll</p>

<p>128.打开SQL Server Management Studio<br />
#!/bin/bash<br />
sqlwb %%1.sql</p>

<p>129.MySQL数据库导出备份<br />
#!/bin/bash<br />
mysqldump -u %%1 -p %%2 %%3&gt;%%4.sql<br />
mysqldump &ndash;opt test &gt; mysql.test //将数据库test导出到mysql.test文件，后面是一个文本文件<br />
mysqldump -u root -p123456 &ndash;databases dbname &gt; mysql.dbname
//就是把数据库dbname导出到文件mysql.dbname中。</p>

<p>130.MySQL数据库数据导入<br />
mysql -u %%1 -p %%2 %%3 mysqlimport -u root -p123456 &lt; mysql.dbname<br />
将文本数据导入数据库：<br />
文本数据的字段之间用tab键隔开<br />
use test<br />
load data local infile &ldquo;文件名&rdquo; into table 表名；<br />
eg: load data local infile &ldquo;D:/mysql.txt&rdquo; into table mytable;<br />
导入.sql 文件命令<br />
use database<br />
source d:/mysql.sql;</p>

<p>131.MySQL数据库检查<br />
mysqlcheck -o %%3 -u %%1 -p %%2</p>

<p>132.MySQL数据表文件修复<br />
myisamchk -B -o %%1.myd</p>

<p>1,查看数据库状态 及启动停止<br />
/etc/init.d/mysqld status<br />
/etc/init.d/mysqld start<br />
/etc/init.d/mysqld stop</p>

<p>2,给用户配置初始密码123456：<br />
mysqladmin -u root -password 123456</p>

<p>3,修改root用户密码为 abc123<br />
mysqladmin -u root -p123456 password abc123</p>

<p>4,如果想去掉密码：<br />
mysqladmin -u root -pabc123 password &ldquo;&rdquo;</p>

<p>5,root连接数据库有密码和无密码：<br />
mysql -u root(-uroot) -p<br />
mysql</p>

<p>6,增加用户 test1 密码 abc,让它可以在任何主机上登录，并对所有数据库有查询，插入，修改，删除的权限：<br />
格式： grant select on 数据库.* to 用户名@登录主机 identified by &ldquo;密码&rdquo;<br />
grant select,insert,update,delete on <em>.</em> to test1@&ldquo;%&rdquo; Identified by &ldquo;abc&rdquo;;</p>

<p>8,增加一个用户test2,让它只可以在localhost上登录，并可以对数据库mydb进行查询，插入，修改，删除的操作，<br />
这样用户即使使用知道test2的密码，他也无法从internet 上直接访问数据库，只能通过mysql主机上的web页面来访问。<br />
grant select,insert,update,delete on mydb.* to test2@localhost identified by
&ldquo;abc&rdquo;;<br />
grant select,insert,update,delete on mydb.* to test2@localhost identified by
&ldquo;&rdquo;; 设置无密码</p>

<p>9,显示数据库列表：<br />
show databases;<br />
use mysql 打开库<br />
show tables;</p>

<p>10,表的操作<br />
describle 表名； 显示数据表的结构<br />
create database 库名；<br />
drop database 库名；<br />
create table 表名(字段设定列表）<br />
drop table 表名；<br />
delete from 表名；清空表记录<br />
select * from 表名； 显示表中的记录<br />
insert into 表名 values(， ，)</p>

<p>alter table 表名 add column</p>

<p>133.检查端口占用<br />
#!/bin/bash<br />
netstat -ano</p>

<p>134.Linux下检查Apache是否安装<br />
#!/bin/bash<br />
rpm -qa | grep httpd</p>

<p>135.Linux下启动Apache服务<br />
#!/bin/bash<br />
service httpd start</p>

<p>136.Linux下停止Apache服务<br />
#!/bin/bash<br />
service httpd stop</p>

<p>137.Linux下重新启动Apache服务<br />
#!/bin/bash<br />
service httpd restart</p>

<p>138.Linux下自动加载Apache 服务<br />
#!/bin/bash<br />
chkconfig - level 3 httpd on</p>

<p>139.Linux下不自动加载Apache 服务<br />
#!/bin/bash<br />
chkconfig - level 3 httpd off</p>

<p>140.Linux下检查VSFTP是否安装<br />
#!/bin/bash<br />
rpm -qa | grep vsftpd</p>

<p>141.Linux下启动VSFTP服务<br />
#!/bin/bash<br />
service vsftpd start</p>

<p>142.Linux下停止VSFTP服务<br />
#!/bin/bash<br />
service vsftpd stop</p>

<p>143.Linux下重新启动VSFTP服务<br />
#!/bin/bash<br />
service vsftpd restart</p>

<p>144.Linux下检查VSFTP是否被启动<br />
#!/bin/bash<br />
pstree | grep vsftpd</p>

<p>145.Linux下检查Sendmail是否安装<br />
#!/bin/bash<br />
rpm -qa | grep sendmail</p>

<p>146.Linux下启动Sendmail服务<br />
#!/bin/bash<br />
service sendmail start</p>

<p>147.Linux下停止Sendmail服务<br />
#!/bin/bash<br />
service sendma stop</p>

<p>148.Linux下重新启动Sendmail服务<br />
#!/bin/bash<br />
service sendmail restart</p>

<p>149.Linux下自动加载Sendmail 服务<br />
#!/bin/bash<br />
chkconfig - level 3 sendmail on</p>

<p>150.Linux下不自动加载Sendmail 服务<br />
#!/bin/bash<br />
chkconfig - level 3 sendmail off</p>

<p>151.Linux下文本图形界面配置启动服务<br />
#!/bin/bash<br />
ntsysv</p>

<p>152.以数组的方式删除文件夹</p>

<p>153.GCC批量编译<br />
#!/bin/bash<br />
find -type f \( -iname &lsquo;<em>.c&rsquo; -o -iname &lsquo;</em>.cpp&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.c)<br />
gcc &ldquo;$filename&rdquo; -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .c)&rdquo;<br />
;;<br />
*.cpp)<br />
gcc &ldquo;$filename&rdquo; -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .cpp)&rdquo;<br />
;;<br />
esac<br />
done</p>

<p>154.批量赋予可执行权限<br />
#!/bin/bash<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;<em>.sh&rsquo; -o -iname &lsquo;</em>.csh&rsquo; -o -iname &lsquo;<em>.ksh&rsquo; -o
-iname &lsquo;</em>.pl&rsquo; -o -iname &lsquo;<em>.bin&rsquo; -o -iname &lsquo;</em>.run&rsquo; -o -iname &lsquo;<em>.bundle&rsquo; -o
-iname &lsquo;</em>.rb&rsquo; -o -iname &lsquo;*.py&rsquo; \) -print0 | xargs -0 chmod +x</p>

<p>#!/bin/bash<br />
for file in *.sh *.pl *.bin *.run *.bundle *.rb <em>.py<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \</em>.[A-Za-z]+ ]]; then<br />
chmod +x &ldquo;$(file)&rdquo;<br />
fi<br />
done<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $(pwd) -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
for file in $path/<em>.sh $path/</em>.pl $path/<em>.bin $path/</em>.run $path/<em>.bundle
$path/</em>.rb $path/<em>.py<br />
do<br />
if [[ ! &ldquo;$file&rdquo; =~ \</em>.[A-Za-z]+ ]]; then<br />
chmod +x &ldquo;$(path)/$(file)&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>155.批量执行<br />
#!/bin/bash<br />
find -type f \( -iname &lsquo;<em>.sh&rsquo; -o -iname &lsquo;</em>.csh&rsquo; -o -iname &lsquo;<em>.ksh&rsquo; -o -iname
&lsquo;</em>.pl&rsquo; -o -iname &lsquo;<em>.bin&rsquo; -o -iname &lsquo;</em>.run&rsquo; -o -iname &lsquo;<em>.bundle&rsquo; -o -iname
&lsquo;</em>.bin&rsquo; -o -iname &lsquo;<em>.class&rsquo; -o -iname &lsquo;</em>.rpm&rsquo; -o -iname &lsquo;<em>.rb&rsquo; -o -iname
&lsquo;</em>.py&rsquo; -o -iname &lsquo;*.jar&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.sh | *.csh | *.ksh)<br />
if [ ! &ldquo;./&rdquo;&ldquo;$(basename $filename)&rdquo; = $0 ]; then<br />
xterm -e &ldquo;$filename&rdquo;<br />
fi<br />
;;<br />
*.pl)<br />
xterm -e perl &ldquo;$filename&rdquo;<br />
;;<br />
*.bin | *.run | *.bundle)<br />
xterm -e &ldquo;$filename&rdquo;<br />
;;<br />
*.class)<br />
xterm -e java &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .class)&rdquo;<br />
;;<br />
*.rpm)<br />
xterm -e rpm -ivh &ldquo;$filename&rdquo;<br />
;;<br />
*.rb)<br />
xterm -e ruby &ldquo;$filename&rdquo;<br />
;;<br />
*.py)<br />
xterm -e python &ldquo;$filename&rdquo;<br />
;;<br />
*.jar)<br />
xterm -e java -jar &ldquo;$filename&rdquo;<br />
;;<br />
esac<br />
done</p>

<p>#!/bin/bash<br />
find -maxdepth 1 -type f \( -iname &lsquo;<em>.sh&rsquo; -o -iname &lsquo;</em>.pl&rsquo; -o -iname &lsquo;<em>.bin&rsquo;
-o -iname &lsquo;</em>.run&rsquo; -o -iname &lsquo;<em>.bundle&rsquo; -o -iname &lsquo;</em>.bin&rsquo; -o -iname &lsquo;<em>.class&rsquo;
-o -iname &lsquo;</em>.rpm&rsquo; -o -iname &lsquo;<em>.rb&rsquo; -o -iname &lsquo;</em>.py&rsquo; -o -iname &lsquo;<em>.jar&rsquo; \)
-print<br />
while read file<br />
do<br />
case &ldquo;${file##</em>.}&rdquo; in<br />
sh ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
pl ) xterm -e perl &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
bin ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
run ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
bundle ) xterm -e &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
class ) xterm -e java &ldquo;&rdquo;&ldquo;&rdquo;${file%.*}&ldquo;&rdquo;&ldquo;&rdquo;;;<br />
rpm ) xterm -e rpm -ivh &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
rb ) xterm -e ruby &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
py ) xterm -e python &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
jar ) xterm -e java -jar &ldquo;&rdquo;&ldquo;&rdquo;$file&rdquo;&ldquo;&rdquo;&ldquo;;;<br />
esac<br />
done</p>

<p>156.获取操作系统版本<br />
#!/bin/bash<br />
uname -r<br />
#uname -a</p>

<p>157.自身复制<br />
#!/bin/bash<br />
cp $0 &ldquo;%%1&rdquo;</p>

<p>158.GCC批量创建静态库<br />
#!/bin/bash<br />
find -type f \( -iname &lsquo;<em>.c&rsquo; -o -iname &lsquo;</em>.cpp&rsquo; \) -print |<br />
while read filename<br />
do<br />
case &ldquo;$filename&rdquo; in<br />
*.c)<br />
g++ -c -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .c)&ldquo;.o&rdquo;&rdquo;
&ldquo;$filename&rdquo;<br />
;;<br />
<em>.cpp)<br />
g++ -c -o &ldquo;$(dirname &ldquo;$filename&rdquo;)&ldquo;/&rdquo;$(basename &ldquo;$filename&rdquo; .cpp)&ldquo;.o&rdquo;&rdquo;
&ldquo;$filename&rdquo;<br />
;;<br />
esac<br />
done<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $(pwd) -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
ar ru $path&rdquo;.a&rdquo; $path&rdquo;/</em>.o&rdquo; &amp;&amp; ranlib $path&rdquo;.a&rdquo;<br />
done<br />
IFS=$OLDIFS<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;*.o&rsquo; \) -print0 | xargs -0 rm -if</p>

<p>159.Java批量打包EJB<br />
#!/bin/bash<br />
find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;<em>.java&rsquo; \) -print0 | xargs -0 javac<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $(pwd) -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
jar -cvf &ldquo;$(path&rdquo;.jar&rdquo;)&rdquo; &ldquo;$(path&rdquo;/</em>.*&ldquo;)&rdquo; &amp;&amp; cp &ldquo;$(path&rdquo;.jar&rdquo;)&rdquo;
&ldquo;$(JBOSS_HOME&rdquo;/server/default/deploy&rdquo;)&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>find &ldquo;$PWD&rdquo; -type f \( -iname &lsquo;*.class&rsquo; \) -print0 | xargs -0 rm -if</p>

<p>160.获取环境变量</p>

<p>161.dd<br />
#!/bin/bash<br />
dd</p>

<p>162.显示只有小写字母的文件<br />
#!/bin/bash<br />
ls -1|awk &lsquo;/<sup class="footnote-ref" id="fnref:lower"><a href="#fn:lower">28</a></sup>.*/&rsquo;</p>

<p>163.Zip压缩目录中的所有文件<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
targetpath=&ldquo;%%2&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
for file in $path/*<br />
do<br />
if [ -f $file ]; then<br />
zip -j &ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}.zip&rdquo; &ldquo;$file&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>164.Zip解压缩目录中的所有文件<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
targetpath=&ldquo;%%2&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
unzip -x &ldquo;$path/*.zip&rdquo; -d &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>165.分布式复制文件夹<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
targetpath=&ldquo;%%2&rdquo;<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
mkdir -p &ldquo;$targetpath/${path:${#direc}+1}&rdquo;<br />
rm -if &ldquo;$targetpath/${path:${#direc}+1}/<em>.tmp&rdquo;<br />
for file in $path/</em><br />
do<br />
if [ -f $file ]; then<br />
cp &ldquo;$file&rdquo; &ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}.tmp&rdquo;<br />
mv &ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}.tmp&rdquo;
&ldquo;$targetpath/${path:${#direc}+1}/${file:${#path}+1}&rdquo;<br />
fi<br />
done<br />
done<br />
IFS=$OLDIFS</p>

<p>166.注册反注册组件<br />
#!/bin/bash<br />
regsvr32 &ldquo;%%1&rdquo;</p>

<p>167.LZMA<br />
#!/bin/bash</p>

<p>168.CAB压缩文件<br />
#!/bin/bash</p>

<p>169.CAB解压缩文件<br />
#!/bin/bash</p>

<p>170.锁定屏幕<br />
#!/bin/sh<br />
RUNDLL32.exe USER32,LockWorkStation</p>

<p>171.以其它用户的身份运行程序<br />
#!/bin/bash</p>

<p>172.添加系统用户<br />
#!/bin/sh<br />
useradd &ldquo;%%1&rdquo;</p>

<p>173.删除系统用户<br />
#!/bin/sh<br />
userdel &ldquo;%%1&rdquo;</p>

<p>174.添加用户组<br />
#!/bin/sh<br />
groupadd -g 2000 &ldquo;%%1&rdquo;</p>

<p>175.删除用户组<br />
#!/bin/sh<br />
groupdel &ldquo;%%1&rdquo;</p>

<p>176.赋予管理员权限<br />
#!/bin/bash</p>

<p>177.收回管理员权限<br />
#!/bin/bash</p>

<p>178.遍历目录产生删除文件的脚本<br />
#!/bin/bash</p>

<p>179.LZW压缩文件<br />
#!/bin/bash<br />
z</p>

<p>180.LZW解压缩文件<br />
#!/bin/bash<br />
z</p>

<p>181.递归赋予目录权限<br />
#!/bin/bash<br />
direc=&ldquo;%%1&rdquo; #$(pwd)<br />
OLDIFS=$IFS<br />
IFS=:<br />
for path in $( find $direc -type d -printf &ldquo;%p$IFS&rdquo;)<br />
do<br />
chown -R root.root &ldquo;$path&rdquo;<br />
done<br />
IFS=$OLDIFS</p>

<p>182.卸载RPM包<br />
#!/bin/sh<br />
rpm -e &ldquo;%%1&rdquo;</p>

<p>183.删除源文件中的注释<br />
#!/bin/sh</p>

<p>184.设置目录下所有文件属性为可写<br />
#!/bin/sh</p>

<p>185.统计目录下所有文件的总共行数<br />
#!/bin/sh<br />
cat * |wc<br />
ls *|xargs wc -l<br />
find ./ -name &ldquo;*c&rdquo; | xargs wc -l</p>

<p>186.删除自身<br />
#!/bin/rm<br />
exit 65<br />
#rm $0</p>

<p>187.打开终端<br />
#!/bin/bash -l</p>

<p>188.弹出光驱<br />
#!/bin/sh<br />
eject</p>

<p>189.收回光驱<br />
#!/bin/sh<br />
eject -t</p>

<p>190.磁盘总空间计算</p>

<p>191.解析CSV文件</p>

<p>192.按行保存文件为数组</p>

<p>193.MySQL执行SQL文件<br />
mysqladmin -u %%1 -p%%2 &lt; %%3.sql</p>

<p>mysql -u %%1 -p%%2 -e &ldquo;SOURCE %%3.sql&rdquo;</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:lower">[:lower:] <a class="footnote-return" href="#fnref:lower"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-"> |  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:-">  <a class="footnote-return" href="#fnref:-"><sup>[return]</sup></a></li>
<li id="fn:lower">[:lower:] <a class="footnote-return" href="#fnref:lower"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>