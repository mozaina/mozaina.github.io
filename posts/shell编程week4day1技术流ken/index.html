<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell编程week4day1技术流ken | 开发者问答集锦</title>
    <meta property="og:title" content="Shell编程week4day1技术流ken - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell编程week4day1技术流ken">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8Bweek4day1%E6%8A%80%E6%9C%AF%E6%B5%81ken/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell编程week4day1技术流ken</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="本节内容">本节内容</h2>

<p><strong>1.shell简介</strong></p>

<p><strong>2. shell分类</strong></p>

<p><strong>3. 查看shell</strong></p>

<p><strong>4. 第一个shell脚本</strong></p>

<p><strong>5. shell编程常用命令</strong></p>

<p><strong>5.1 grep</strong></p>

<p><strong>5.2 cut</strong></p>

<p><strong>5.3 sort</strong></p>

<p><strong>5.4 uniq</strong></p>

<p><strong>5.5 seq</strong></p>

<p><strong>5.6 tr</strong></p>

<p><strong>6. 课后作业</strong></p>

<h2 id="前言">前言</h2>

<p><strong>什么是脚本？</strong></p>

<p>脚本简单地说就是一条条的文字命令（一些指令的堆积），这些文字命令是可以看到的（如可以用记事本打开查看、编辑）。</p>

<p>常见的脚本： <strong>JavaScript（J</strong> <strong>S</strong> <strong>，前端）</strong> ，VBScript， <strong>ASP，</strong> <strong>JSP，PHP（后端）</strong>
，SQL（数据库操作语言），Perl， <strong>Shell</strong> ，python，Ruby，JavaFX， Lua等。</p>

<p><strong>为什么要学习和使用shell？</strong></p>

<p>Shell属于内置的脚本</p>

<p>程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务（批处理）</p>

<p>语法简单，代码写起来比较轻松，简单易学</p>

<h2 id="1-1-shell-简介">1.1 ****<strong>Shell 简介</strong></h2>

<p>Shell 是一个 C 语言编写的脚本语言，它是用户与 Linux 的桥梁，用户输入命令交给 Shell 处理， Shell
将相应的操作传递给内核（Kernel），内核把处理的结果输出给用户。</p>

<p>下面是流程示意图：</p>

<p><a href="https://img.it610.com/image/info8/f9135f2f1e1a45dababad362eded5693.jpg"><img src="https://img.it610.com/image/info8/f9135f2f1e1a45dababad362eded5693.jpg" alt="Shell编程\(week4_day1\)--技术流ken_第1张图片" /></a></p>

<p>Shell 既然是工作在 Linux 内核之上，那我们也有必要了解下 Linux 相关知识。 Linux 是一套免费试用和自由传播的类 Unix
操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任 务、支持多线程和多 CPU 的操作系统。</p>

<p>1983 年 9 月 27 日，Richard Stallman（理查德-马修-斯托曼）发起 GNU 计划，它的目标是创建一 套完全自由的操作系统。为保证
GNU 软件可以自由的使用、复制、修改和发布，所有的 GNU 软件都 有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU
通用公共许可 证（GNU General Plubic License，GPL），说白了就是不能做商业用途。</p>

<p>GNU 是&rdquo;GNU is Not Unix&rdquo;的递归缩写。UNIX 是一种广泛使用的商业操作系统的名称。</p>

<p>1985 年，Richard Stallman 又创立了自由软件基金会（Free Software Foundation，FSF）来为 GNU
计划提供技术、法律以及财政支持。</p>

<p>1990 年，GNU 计划开发主要项目有 Emacs（文本编辑器）、GCC（GNU Compiler Collection，GNU 编 译器集合）、Bash
等，GCC 是一套 GNU 开发的编程语言编译器。还有开发一些 UNIX 系统的程序库和 工具。</p>

<p>1991 年，Linuxs Torvalds（林纳斯- 托瓦兹）开发出了与 UNIX 兼容的 Linux 操作系统内核并在 GPL 条款下发布。</p>

<p>1992 年，Linux 与其他 GUN 软件结合，完全自由的 GUN/Linux 操作系统正式诞生，简称 Linux。</p>

<p>1995 年 1 月，Bob Young 创办 ACC 公司，以 GNU/Linux 为核心，开发出了 RedHat Linux 商业版。</p>

<p>Linux 基本思想有两点：第一，一切都是文件；第二，每个软件都有确定的用途。</p>

<p>与 Unix 思想十分 相近。 Kernel Shell 命令 用户 解析命令 并传递给内核 执行动作</p>

<h2 id="1-2-shell-分类">1.2 ****<strong>Shell 分类</strong></h2>

<h4 id="1-2-1-图形界面-shell-gui-shell">1.2.1 图形界面 Shell（GUI Shell）</h4>

<p>GUI 为 Unix 或者类 Unix 操作系统构造一个功能完善、操作简单以及界面友好的桌面环境。主流桌 面环境有 KDE，Gnome 等。</p>

<h4 id="1-2-2-命令行界面-shell-cli-shell">1.2.2 命令行界面 Shell（CLI Shell）</h4>

<p>CLI 是在用户提示符下键入可执行指令的界面，用户通过键盘输入指令，完成一系列操作。 在 Linux 系统上主流的 CLI 实现是 Bash，是许多
Linux 发行版默认的 Shell。还有许多 Unix 上 Shell，例如 tcsh、csh、ash、bsh、ksh 等。</p>

<h2 id="1-3-查看shell">1.3 ** 查看shell**</h2>

<p>Shell 是一个程序，一般都是放在/bin或者/user/bin目录下，当前 Linux 系统可用的 Shell
都记录在/etc/shells文件中。/etc/shells是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。</p>

<p>通过 cat 命令来查看当前 Linux 系统的可用 Shell：</p>

<pre><code>$ cat /etc/shells
/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh  
</code></pre>

<p>在现代的 Linux 上，sh 已经被 bash 代替，/bin/sh往往是指向/bin/bash的符号链接。</p>

<p>如果你希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量：</p>

<pre><code>$ echo $SHELL
/bin/bash  
</code></pre>

<p>输出结果表明默认的 Shell 是 bash。</p>

<p>SHELL是 Linux 系统中的环境变量，它指明了当前使用的 Shell 程序的位置，也就是使用的哪个 Shell。</p>

<h2 id="1-4-第一个-shell-脚本"><strong>1.</strong> <strong>4</strong> ** 第一个 Shell 脚本**</h2>

<p>主要讲解在大多 Linux 发行版下默认 Bash Shell。Linux 系统是 RedHat 下的 CentOS 操作系 统，完全免费。与其商业版
RHEL（Red Hat Enterprise Linux）出自同样的源代码，不同的是 CentOS 并不包含封闭源代码软件和售后支持。</p>

<p>用 vim 打开 test.sh，编写：</p>

<pre><code> # vim test.sh
 #!/bin/bash
echo &quot;Hello world!&quot;
</code></pre>

<p>第一行指定解释器，第二行打印 Hello world！</p>

<p>写好后，开始执行，执行 Shell 脚本有三种方法：</p>

<h3 id="方法-1-直接用-bash-解释器执行"><strong>方法 1：直接用 bash 解释器执行</strong></h3>

<pre><code># bash test.sh
Hello world!
</code></pre>

<p>当前终端会新生成一个子 bash 去执行脚本。</p>

<h3 id="方法-2-添加可执行权限"><strong>方法 2：添加可执行权限</strong></h3>

<pre><code> # ll
test.sh -rw-r--r--. 1 root root 32 Aug 18 01:07 test.sh
 # chmod +x test.sh
 # ./test.sh
-bash: ./test.sh: Permission denied
# chmod +x test.sh
# ./test.sh
Hello world!
</code></pre>

<p>这种方式默认根据脚本第一行指定的解释器处理，如果没写以当前默认 Shell 解释器执行。</p>

<p><strong>注意</strong> <strong>，这里在运行时一定要写成 ./test.sh（绝对路径亦可），</strong> <strong>而不是 test.sh</strong>
<strong>，运行其它二进制的程序也一样，直接写 test.sh，</strong> <strong>L</strong> <strong>inux 系统会去 PATH（</strong> <strong>环境变量</strong> <strong>） 里寻找有没有叫
test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成
test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</strong></p>

<h3 id="方法-3-source-命令执行-以当前默认-shell-解释器执行"><strong>方法 3：source 命令执行，以当前默认 Shell 解释器执行</strong></h3>

<pre><code># source test.sh
Hello world!
</code></pre>

<h3 id="source-filename-与-bash-filename-及-filename执行脚本的区别">source filename 与 bash filename 及./filename执行脚本的区别</h3>

<ul>
<li><p>当shell脚本具有可执行权限时，用bash filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所以”.”是用来表示当前目录的。</p></li>

<li><p>source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。</p></li>

<li><p>bash filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell。</p></li>
</ul>

<p>最后一句话什么意思那？</p>

<p><strong>子shell新建变量，在父shell中不会生效：</strong></p>

<p>我们可以使用命令pstree查看我们当前所处的位置</p>

<p>需要下载</p>

<pre><code>[root@ken ~]# yum search pstree
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
==================================================== Matched: pstree ====================================================
psmisc.x86_64 : Utilities for managing processes on your system
texlive-pst-tree.noarch : Trees, using pstricks
[root@ken ~]# yum install psmisc -y
</code></pre>

<p>使用pstree</p>

<p><a href="https://img.it610.com/image/info8/c3d556ab330a4d858531d6178d87d6bb.png"><img src="https://img.it610.com/image/info8/c3d556ab330a4d858531d6178d87d6bb.png" alt="Shell编程\(week4_day1\)--技术流ken_第2张图片" /></a></p>

<p>我们再次执行bash,就会进入到另外一个子shell中</p>

<p><a href="https://img.it610.com/image/info8/ffc1492929f14bceaeca17fc2ea9101d.png"><img src="https://img.it610.com/image/info8/ffc1492929f14bceaeca17fc2ea9101d.png" alt="Shell编程\(week4_day1\)--技术流ken_第3张图片" /></a></p>

<p>这个时候我们在这个子shell中定义一个变量，发现可以正确打印出来</p>

<pre><code>[root@ken ~]# age=25
[root@ken ~]# echo $age
25
</code></pre>

<p>现在我们退出当前的shell，即进入了当前子shell中的父shell中，再次打印我们刚才定义的变量</p>

<p>可以发现现在已经无法获取到我们刚才定义的变量值了。</p>

<p><a href="https://img.it610.com/image/info8/d02a706e92d24460b96c308aab652e1a.png"><img src="https://img.it610.com/image/info8/d02a706e92d24460b96c308aab652e1a.png" alt="Shell编程\(week4_day1\)--技术流ken_第4张图片" /></a></p>

<p><strong>子shell继承父shell的环境变量：</strong></p>

<p>我们把环境变量定义到profile的一个子文件中，并使用source执行该文件并生效</p>

<p>打开一个子shell，定义在父shell中的环境变量依然有效</p>

<p>反之，这种操作在子shell中操作，父shell也不能继承</p>

<pre><code>[root@ken ~]# cat /etc/profile.d/ken.sh
export name=ken
[root@ken ~]# source /etc/profile.d/ken.sh
[root@ken ~]# echo $name
ken
[root@ken ~]# bash
[root@ken ~]# echo $name
ken
</code></pre>

<h3 id="shell编程练习">shell编程练习：</h3>

<p>练习1：使用root用户帐号创建并执行test2.sh，实现 <strong>创建一个shell</strong> <strong>test</strong> <strong>用户</strong> ，并在其家目录中 <strong>新建文件</strong>
try.html。</p>

<p>练习2：统计当前系统总共有多少用户</p>

<p>练习3：统计当前已经安装的软件数量</p>

<h2 id="1-5-shell编程几个常用命令">1.5 shell编程几个常用命令</h2>

<h3 id="grep命令详解">grep命令详解</h3>

<p>过滤来自一个文件或标准输入匹配模式内容。</p>

<p>除了 grep 外，还有 egrep。egrep 是 grep 的扩展，相当于 grep -E。</p>

<pre><code>Usage: grep [OPTION]... PATTERN [FILE]...
</code></pre>

<h3 id="grep常用选项详解">grep常用选项详解</h3>

<p>选项  |</p>

<p>描述</p>

<p>&mdash;|&mdash;</p>

<p>-E，&ndash;extended-regexp</p>

<p>|</p>

<p>模式是扩展正则表达式（ERE）</p>

<p>-i，&ndash;ignore-case |</p>

<p>忽略大小写</p>

<p>-n，&ndash;line-number |</p>

<p>打印行号</p>

<p>-o，&ndash;only-matching |</p>

<p>只打印匹配的内容</p>

<p>-c，&ndash;count |</p>

<p>只打印每个文件匹配的行数</p>

<p>-B，&ndash;before-context=NUM |</p>

<p>打印匹配的前几行</p>

<p>-A，&ndash;after-context=NUM |</p>

<p>打印匹配的后几行</p>

<p>-C，&ndash;context=NUM</p>

<p>|</p>

<p>打印匹配的前后几行</p>

<p>--color[=WHEN],</p>

<p>|  匹配的字体颜色</p>

<p>-v，&ndash;invert-match</p>

<p>|  打印不匹配的行</p>

<h3 id="grep案例演示">grep案例演示</h3>

<p>1. -i, 忽略大小写</p>

<pre><code>[root@ken ~]# echo &quot;this is ken THIS IS KEN&quot; | grep -i 'ken'
this is ken THIS IS KEN
[root@ken ~]# echo &quot;this is ken THIS IS KEN&quot; | grep  'ken'
this is ken THIS IS KEN
</code></pre>

<p>2. -n,打印行号</p>

<pre><code>[root@ken ~]# grep -n 'root' /etc/passwd
1:root:x:0:0:root:/root:/bin/bash
10:operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>

<p>3. -o,只打印匹配的内容</p>

<pre><code>[root@ken ~]# echo &quot;this is ken THIS IS KEN&quot; | grep -o 'ken'
ken
[root@ken ~]# echo &quot;this is ken THIS IS KEN&quot; | grep  'ken'
this is ken THIS IS KEN
</code></pre>

<p>4. -c,打印文件匹配的行数</p>

<pre><code>[root@ken ~]# grep  -c 'root' /etc/passwd
2
[root@ken ~]# grep  'root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>

<p>5. -B，打印匹配的前几行</p>

<pre><code>[root@ken ~]# grep -B 3 'root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
--
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>

<p>6.-A，打印匹配的后几行</p>

<pre><code>[root@ken ~]# grep -A 3 'root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
--
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
</code></pre>

<p>7.-C,打印匹配的前后几行</p>

<pre><code>[root@ken ~]# grep -C 3 'root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
--
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
</code></pre>

<p>8. &ndash;color,在centos7中已经默认为 grep &ndash;color,在centos6中需要加上&ndash;color才会显示颜色</p>

<pre><code>[root@ken ~]# alias grep 
alias grep='grep --color=auto'
</code></pre>

<p>9. -v, 打印不匹配的行</p>

<pre><code>[root@ken ~]# echo -e &quot;hi\nthis is ken\nncie to meet you\nbye &quot; | grep -v 'ken'
hi
ncie to meet you
bye 
</code></pre>

<h3 id="一-cut命令">一、cut命令</h3>

<h3 id="语法">语法</h3>

<pre><code>cut  [-bn] [file]
cut [-c] [file]
cut [-df] [file]
</code></pre>

<p><strong>使用说明:</strong></p>

<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>

<p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p>

<p><strong>常用参数:</strong></p>

<ul>
<li><p>-c ：以字符为单位进行分割。</p></li>

<li><p>-d ：自定义分隔符。</p></li>

<li><p>-f ：与-d一起使用，指定显示哪个区域。</p></li>
</ul>

<p><strong>常用实例演示1： -c:以字符为单位进行分隔</strong></p>

<pre><code>[root@ken ~]# echo &quot;this is ken&quot; | cut -c  4
s
[root@ken ~]# echo &quot;this is ken&quot; | cut -c 5

[root@ken ~]# echo &quot;this is ken&quot; | cut -c 2
h  
</code></pre>

<p>[root@ken ~]# echo &ldquo;this is ken&rdquo; | cut -c 1-5<br />
this</p>

<p><strong>常用实例演示2：-d,-f：自定义分隔符并进行指定显示</strong></p>

<p><strong>1.从标准输入读取</strong></p>

<pre><code>[root@ken ~]# echo 'this is ken' | cut -d' ' -f3
ken  
</code></pre>

<p>[root@ken ~]# echo &ldquo;name:ken age:25 gender:male&rdquo; | cut -d &lsquo; &rsquo; -f2<br />
age:25</p>

<p><strong>2.从文件中读取</strong></p>

<pre><code>[root@ken ~]# echo &quot;this is ken&quot;&gt;test
[root@ken ~]#  cut -d' ' -f3 test
ken
</code></pre>

<h3 id="二-sort命令">二、sort命令</h3>

<pre><code> 
</code></pre>

<p>Linux sort命令用于将文本文件内容加以排序。</p>

<p>sort可针对文本文件的内容，以行为单位来排序。</p>

<h4 id="语法-1">语法：</h4>

<pre><code>sort [-bcdfimMnr][-o][-t][+-][--help][--verison][文件]  



 
</code></pre>

<h4 id="常用参数说明"><strong>常用参数说明</strong> ：</h4>

<ul>
<li>-k：根据切割后的那一段进行排序</li>
<li>-n 依照数值的大小排序（默认是根据字符进行排序）。</li>
<li>-r 以相反的顺序来排序。</li>
<li>-t 指定排序时所用的栏位分隔字符。</li>
<li>-u：去除重复的行（只要那个指定的字段重复，就认定是重复的行）</li>
</ul>

<h4 id="实例一-默认排序">实例一：默认排序</h4>

<p>在使用sort命令以默认的式对文件的行进行排序，使用的命令如下：</p>

<pre><code>[root@ken ~]# cat test
6 this is ken
2 this is ken
5 this is ken
6 this is ken
1 this is ken
8 this is ken
[root@ken ~]# sort test
1 this is ken
2 this is ken
5 this is ken
6 this is ken
6 this is ken
8 this is ken
</code></pre>

<p>sort 命令将以默认的方式将文本文件的第一列以ASCII 码的次序排列，并将结果输出到标准输出。</p>

<h4 id="实例二-取出排名前三">实例二：取出排名前三</h4>

<pre><code>[root@ken ~]# sort -r test | head -3
8 this is ken
6 this is ken
6 this is ken
</code></pre>

<h4 id="实例三-对文件中的内容按照e分割第二部分进行排序">实例三：对文件中的内容按照e分割第二部分进行排序</h4>

<pre><code>[root@ken ~]# sort -t 'e' -k 2 test
6 this:is:ke1
5 this:is:ke2
6 this:is:ke3
2 this:is:ke4
1 this:is:ke6
8 this:is:ke7
[root@ken ~]# sort -t 'e' -k 2  -r test
8 this:is:ke7
1 this:is:ke6
2 this:is:ke4
6 this:is:ke3
5 this:is:ke2
6 this:is:ke1
</code></pre>

<h4 id="实例四-去除重复的行">实例四：去除重复的行</h4>

<pre><code>[root@ken ~]# sort test
1 this:is:ke6
2 this:is:ke4
2 this:is:ke4
2 this:is:ke4
2 this:is:ke4
5 this:is:ke2
6 this:is:ke1
6 this:is:ke3
8 this:is:ke7
[root@ken ~]# sort -u test
1 this:is:ke6
2 this:is:ke4
5 this:is:ke2
6 this:is:ke1
6 this:is:ke3
8 this:is:ke7
</code></pre>

<h4 id="三-uniq命令">三、uniq命令</h4>

<h4 id="作用">作用：</h4>

<p>去除重复的行（相邻且相同，认定为重复）</p>

<h4 id="选项">选项：</h4>

<p>-c：在行首用数字表示该行出现了多少次</p>

<p>-u：仅仅显示那些没有出现重复过的行</p>

<h4 id="实例一-统计行数">实例一：统计行数</h4>

<pre><code>[root@ken ~]# uniq -c test
      1 6 this:is:ke3
      4 2 this:is:ke4
      1 5 this:is:ke2
      1 6 this:is:ke1
      1 1 this:is:ke6
      1 8 this:is:ke7
</code></pre>

<h4 id="实例二-将文件中相同的行去重">实例二：将文件中相同的行去重</h4>

<pre><code>[root@ken ~]# sort test | uniq
1 this:is:ke6
2 this:is:ke4
5 this:is:ke2
6 this:is:ke1
6 this:is:ke3
8 this:is:ke7
</code></pre>

<h4 id="四-seq命令">四、seq命令</h4>

<h4 id="作用-1">作用：</h4>

<p>生成一个数组序列</p>

<h4 id="格式">格式:</h4>

<p>seq [start [step]] stop</p>

<h4 id="实例">实例：</h4>

<pre><code>[root@ken ~]# seq 5       #终止位5
1
2
3
4
5
[root@ken ~]# seq 2 5     #起始位2，终止位5
2
3
4
5
[root@ken ~]# seq 2 2 10  #起始位2，步长为2，终止位10
2
4
6
8
10
</code></pre>

<h4 id="五-tr命令">五、tr命令</h4>

<h4 id="作用-2">作用：</h4>

<p>Linux tr 命令用于转换或删除文件中的字符。</p>

<p>tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p>

<p>a-z 任意小写</p>

<p>A-Z 任意大写</p>

<p>0-9 任意数字</p>

<h4 id="实例一-替换大小写">实例一：替换大小写</h4>

<pre><code>[root@ken ~]# echo &quot;this is ken&quot; | tr a-z A-Z
THIS IS KEN
[root@ken ~]# echo &quot;THIS IS KEN&quot; | tr A-Z a-z
this is ken
</code></pre>

<h4 id="实例二-删除特定字符串">实例二：删除特定字符串</h4>

<p>s这个字符串都会被删掉</p>

<pre><code>[root@ken ~]# cat test
6 this:is:ke3
2 this:is:ke4
2 this:is:ke4
2 this:is:ke4
2 this:is:ke4
5 this:is:ke2
6 this:is:ke1
1 this:is:ke6
8 this:is:ke7
[root@ken ~]# cat test | tr -d 's'
6 thi:i:ke3
2 thi:i:ke4
2 thi:i:ke4
2 thi:i:ke4
2 thi:i:ke4
5 thi:i:ke2
6 thi:i:ke1
1 thi:i:ke6
8 thi:i:ke7
</code></pre>

<h2 id="课后作业">课后作业</h2>

<p>作业1. 获取主机IP地址，获取结果仅显示IP，例如：172.20.10.2（使用尽可能多的方法）</p>

<p>作业2. 有如下一个文件，文件内容如下。</p>

<p>请把下方的内容复制到你的一个文件中，并完成如下需求</p>

<p>需求1. 统计出各个网址出现的次数</p>

<p>需求2. 按照出现次数排序（升序）</p>

<p>需求3. 取出出现次数排名前两名的网址</p>

<pre><code>[root@ken ~]# cat ken.sh
http://www.baidu.com
http://www.baidu.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.sina.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.qq.com
http://www.qq.com
http://www.qq.com
http://www.qq.com
http://www.qq.com
http://www.qq.com
http://www.qq.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.taobao.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
http://www.baidu.com
</code></pre>

<h2 id="课后作业答案">课后作业答案</h2>

<p>作业1：</p>

<p>第一种方法：</p>

<pre><code>[root@ken ~]# ip a | grep global | cut -d &quot; &quot; -f 6 | cut -d &quot;/&quot; -f1
172.20.10.6
</code></pre>

<p>第二种方法：</p>

<p>[root@ken ~]# ip a | grep global | cut -d &ldquo;b&rdquo; -f 1 | tr -d [a-z] | cut -d &ldquo;/&rdquo;
-f 1 | tr -d &ldquo; &rdquo;<br />
172.20.10.6</p>

<p>第三种方法：</p>

<pre><code>[root@ken ~]# ip a | grep global | tr -d [a-z] | tr -d &quot; &quot; | cut -d &quot;/&quot; -f1
172.20.10.6
</code></pre>

<p>方法有很多，大家尽可能的自己多思考哦！</p>

<p>作业2：</p>

<p>1. 统计出各个网址出现的次数</p>

<pre><code>[root@ken ~]# cat ken.sh  | cut -d '/' -f3 | sort | uniq -c
     19 www.baidu.com
      7 www.qq.com
     12 www.sina.com
     10 www.taobao.com
</code></pre>

<p>2. 按照出现次数排序（升序）</p>

<pre><code>[root@ken ~]# cat ken.sh  | cut -d '/' -f3 | sort | uniq -c | sort -n
      7 www.qq.com
     10 www.taobao.com
     12 www.sina.com
     19 www.baidu.com
</code></pre>

<p>3. 取出出现次数排名前两名的网址</p>

<pre><code>[root@ken ~]# cat ken.sh  | cut -d '/' -f3 | sort | uniq -c | sort -n -r | head -2
     19 www.baidu.com
     12 www.sina.com
</code></pre>

<p><strong>思考：还有更多的办法吗？</strong></p>

<p>转载于:<a href="https://www.cnblogs.com/kenken2018/p/10222451.html">https://www.cnblogs.com/kenken2018/p/10222451.html</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>