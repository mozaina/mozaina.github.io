<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>常见经典排序算法学习总结插入shell冒泡选择归并快排等 | 开发者问答集锦</title>
    <meta property="og:title" content="常见经典排序算法学习总结插入shell冒泡选择归并快排等 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="常见经典排序算法学习总结插入shell冒泡选择归并快排等">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E6%8F%92%E5%85%A5shell%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E5%BD%92%E5%B9%B6%E5%BF%AB%E6%8E%92%E7%AD%89/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">常见经典排序算法学习总结插入shell冒泡选择归并快排等</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>###
博主在学习过程中深感基础的重要，经典排序算法是数据结构与算法学习过程中重要的一环，这里对笔试面试最常涉及到的7种排序算法(包括插入排序、希尔排序、选择排序、冒泡排序、快速排序、堆排序、归并排序)进行了详解。每一种算法都有基本介绍、算法原理分析、算法代码。</p>

<h3 id="插入排序"><strong>插入排序</strong></h3>

<h4 id="1-算法简介"><strong>1）算法简介</strong></h4>

<p>插入排序（Insertion
Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-
place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>

<h4 id="2-算法描述和分析"><strong>2）算法描述和分析</strong></h4>

<p>具体算法描述如下：</p>

<p>1. 从第一个元素开始，该元素可以认为已经被排序</p>

<p>2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</p>

<p>3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</p>

<p>4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p>

<p>5. 将新元素插入到该位置后</p>

<p>6. 重复步骤2~5</p>

<p>如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1)次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(n^2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>

<h4 id="3-算法代码"><strong>3）算法代码</strong></h4>

<pre><code>void InsertSort(int a[], int n)
{
    //循环变量
    int i,j;
    //中间变量
    int temp;
    for (i=1; i=0&amp;&amp;a[j]&gt;temp; j--)
            a[j+1]=a[j];
        //将temp放入合适位置
        a[j+1]=temp;
    }
}
</code></pre>

<h3 id="希尔排序"><strong>希尔排序</strong></h3>

<h4 id="1-算法简介-1">1）算法简介</h4>

<p>希尔排序，也称缩小增量排序算法，名称源于它的发明者Donald Shell，是插入排序的一种高速而稳定的改进版本。</p>

<h4 id="2-算法描述">2）算法描述</h4>

<p>1、先取一个增量把元素分割成若干个子序列，对各子序列分别进行直接插入排序。</p>

<p>2、依次缩减增量再进行排序。</p>

<p>3、直至所取的增量足够小时，再进行一次直接插入排序。</p>

<p>希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n^2)，而Hibbard增量的希尔排序的时间复杂度为O(N^(<sup>3</sup>&frasl;<sub>2</sub>))，但是现今仍然没有人能找出希尔排序的精确下界。</p>

<h4 id="3-算法代码-1"><strong>3）算法代码</strong></h4>

<pre><code>void ShellSort(int a[], int n)
{
    //循环变量
    int i,j;
    //增量
    int increment;
    //中间变量
    int temp;
    for (increment=n/2; increment&gt;0; increment/=2)
    {
        //在增量分割的子序列中进行插入排序
        for (i=increment; i=0&amp;&amp;a[j]&gt;temp; j-=increment)
            {
                //右移
                a[j+increment]=a[j];
            }
            a[j+increment]=temp;
        }
    }
}
</code></pre>

<h3 id="冒泡排序"><strong>冒泡排序</strong></h3>

<h4 id="1-算法简介-2"><strong>1）算法简介</strong></h4>

<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>

<h4 id="2-算法描述-1"><strong>2）算法描述</strong></h4>

<p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>

<p>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>

<p>3、针对所有的元素重复以上的步骤，除了最后一个。</p>

<p>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>

<p>冒泡排序是与插入排序拥有相等的执行时间，但是两种法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地执行（O(n^2)），而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次执行时，使用一个旗标来表示有无需要交换的可能，也有可能把最好的复杂度降低到O(n)。在这个情况，在已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序和比较大小反过来，也可以稍微地改进效率。有时候称为往返排序，因为算法会从数列的一端到另一端之间穿梭往返。</p>

<p>最差时间复杂度 O(n^2)</p>

<p>最优时间复杂度 O(n)</p>

<p>平均时间复杂度 O(n^2)</p>

<p>最差空间复杂度 总共O(n)，需要辅助空间O(1)</p>

<h4 id="3-算法代码-2"><strong>3）算法代码</strong></h4>

<pre><code>void BubbleSort(int a[], int n)
{
    int i,j;
    //中间变量
    int temp;
    for (i=0; i
</code></pre>

<h3 id="选择排序"><strong>选择排序</strong></h3>

<h4 id="1-算法简介-3"><strong>1）算法简介</strong></h4>

<p>选择排序（Selection
sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法。</p>

<h4 id="2-算法描述和分析-1">2）算法描述和分析</h4>

<p>1、初始状态：无序区为R[1..n]，有序区为空，令i=0。</p>

<p>2、在无序区R[i..n-1]中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R[i]交换，交换之后R[0…i]就形成了一个有序区。</p>

<p>3、i++并重复第二步，直到i==n-1，数组有序化了。</p>

<h4 id="3-算法代码-3"><strong>3）算法代码</strong></h4>

<pre><code>void SelectSort(int a[], int n)
{
    //循环变量
    int i,j;
    //最小元素的下标
    int mindex;
    //中间变量
    int temp;
    for (i=0; i
</code></pre>

<h3 id="归并排序">归并排序</h3>

<h4 id="1-算法简介-4">1）算法简介</h4>

<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and
Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。</p>

<p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>

<h4 id="2-算法描述和分析-2">2）算法描述和分析</h4>

<p>归并排序具体算法描述如下(递归版本)：</p>

<p>1、Divide: 把长度为n的输入序列分成两个长度为n/2的子序列。</p>

<p>2、Conquer: 对这两个子序列分别采用归并排序。</p>

<p>3、Combine: 将两个排序好的子序列合并成一个最终的排序序列。</p>

<p>归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。</p>

<h4 id="3-算法代码-4"><strong>3）算法代码</strong></h4>

<pre><code>//将两个有序数列a[first~mid]和a[mid+1~last]合并
void merge(int a[], int pTemp[], int first, int mid, int last)
{
    int i=first,j=mid+1,k=first;
    while(i&lt;=mid&amp;&amp;j&lt;=last)
    {
        if (a[i]
</code></pre>

<h3 id="堆排序">堆排序</h3>

<h4 id="1-算法简介-5">1）算法简介</h4>

<p>堆排序（HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>

<p>堆排序方法对记录数较少的文件并不值得提倡，但对n较大的文件还是很有效的。因为其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。</p>

<p>堆排序在最坏的情况下，其时间复杂度也为O(nlogn)。相对于快速排序来说，这是堆排序的最大优点。此外，堆排序仅需一个记录大小的供交换用的辅助存储空间。</p>

<h4 id="2-堆的定义"><strong>2）堆的定义</strong></h4>

<p>n个元素的序列{k1，k2，…,kn}当且仅当满足下列关系之一时，称之为堆。</p>

<p>情形1：ki &lt;= k2i 且ki &lt;= k2i+1 （最小化堆或小顶堆）</p>

<p>情形2：ki &gt;= k2i 且ki &gt;= k2i+1 （最大化堆或大顶堆）</p>

<p>其中i=1,2,…,n/2向下取整;</p>

<p>若将和此序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。</p>

<p>由此，若序列{k1，k2，…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。</p>

<p>若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。</p>

<h4 id="3-堆的存储"><strong>3）堆的存储</strong></h4>

<p>一般用数组来表示堆，若根结点存在序号0处，
i结点的父结点下标就为(i-1)/2。i结点的左右子结点下标分别为2*i+1和2*i+2。（注：如果根结点是从1开始，则左右孩子结点分别是2i和2i+1。）</p>

<h4 id="4-堆排序的实现"><strong>4）堆排序的实现</strong></h4>

<p>实现堆排序需要解决两个问题：</p>

<p>1.如何由一个无序序列建成一个堆？</p>

<p>2.如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p>

<p>先考虑第二个问题，一般在输出堆顶元素之后，视为将这个元素排除，然后用表中最后一个元素填补它的位置，自上向下进行调整：首先将堆顶元素和它的左右子树的根结点进行比较，把最小的元素交换到堆顶；然后顺着被破坏的路径一路调整下去，直至叶子结点，就得到新的堆。</p>

<p>我们称这个自堆顶至叶子的调整过程为“筛选”。从无序序列建立堆的过程就是一个反复“筛选”的过程。</p>

<h4 id="5-构造初始堆"><strong>5）构造初始堆</strong></h4>

<p>初始化堆的时候是对所有的非叶子结点进行筛选。最后一个非终端元素的下标是[n/2]向下取整，所以筛选只需要从第[n/2]向下取整个元素开始，从后往前进行调整。</p>

<p>比如，给定一个数组，首先根据该数组元素构造一个完全二叉树。然后从最后一个非叶子结点开始，每次都是从父结点、左孩子、右孩子中进行比较交换，交换可能会引起孩子结点不满足堆的性质，所以每次交换之后需要重新对被交换的孩子结点进行调整。</p>

<h4 id="6-进行堆排序"><strong>6）进行堆排序</strong></h4>

<p>堆排序是一种选择排序。建立的初始堆为初始的无序区。</p>

<p>排序开始，首先输出堆顶元素（因为它是最值），将堆顶元素和最后一个元素交换，这样，第n个位置（即最后一个位置）作为有序区，前n-1个位置仍是无序区，对无序区进行调整，得到堆之后，再交换堆顶和最后一个元素，这样有序区长度变为2。</p>

<p>不断进行此操作，将剩下的元素重新调整为堆，然后输出堆顶元素到有序区。每次交换都导致无序区-1，有序区+1。不断重复此过程直到有序区长度增长为n-1，排序完成。</p>

<p>由排序过程可见，若想得到升序，则建立大顶堆，若想得到降序，则建立小顶堆。</p>

<h4 id="7-算法代码"><strong>7）算法代码</strong></h4>

<pre><code>// 输入数组A，堆的长度len，以及需要调整的节点i,调堆
void HeapAdjust(int A[], int len, int i)
{
    int left=2*i+1;//结点i的左孩子
    int right=2*i+2;//结点i的右孩子
    int largest=i;
    int temp;
    while(leftA[largest])
        {
            largest=left;
        }
        if (rightA[largest])
        {
            largest=right;
        }
        //如果最大值不是父结点
        if (i!=largest)
        {
            //交换父结点和拥有最大值的子结点
            temp=A[i];
            A[i]=A[largest];
            A[largest]=temp;
            //新的父结点，以备迭代调堆
            i=largest;
            //新的子结点
            left=2*i+1;
            right=2*i+2;
        }
        else
            break;
    }
}

//建堆
void BuildHeap(int A[], int len)
{
    //最后一个非叶子结点
    int begin=len/2-1;
    for (int i=begin; i&gt;=0; i--)
    {
        HeapAdjust(A,len,i);
    }
}

//堆排序
void HeapSort(int A[], int n)
{
    int temp;
    //建堆
    BuildHeap(A,n);
    while(n&gt;1)
    {
        //交换堆的第一个元素和最后一个元素
        temp=A[n-1];
        A[n-1]=A[0];
        A[0]=temp;
        n--;
        //调堆
        HeapAdjust(A,n,0);
    }
}
</code></pre>

<h3 id="快速排序"><strong>快速排序</strong></h3>

<p>快速排序是各种笔试面试最爱考的排序算法之一，且排序思想在很多算法题里面被广泛使用。是需要重点掌握的排序算法。</p>

<h4 id="1-算法简介-6"><strong>1）算法简介</strong></h4>

<p>快速排序是由东尼·霍尔所发展的一种排序算法。其基本思想是，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>

<h4 id="2-算法描述和分析-3"><strong>2）算法描述和分析</strong></h4>

<p>快速排序使用分治法来把一个串（list）分为两个子串行（sub-lists）。</p>

<p>步骤为：</p>

<p>1、从数列中挑出一个元素，称为 &ldquo;基准&rdquo;（pivot），</p>

<p>2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>

<p>3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>

<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>

<p>在平均状况下，排序n个项目要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log
n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>

<p>最差时间复杂度 O(n^2)</p>

<p>最优时间复杂度 O(n log n)</p>

<p>平均时间复杂度 O(n log n)</p>

<p>最差空间复杂度 根据实现的方式不同而不同</p>

<p>我们选取数组的第一个元素作为主元，每一轮都是和第一个元素比较大小，通过交换，分成大于和小于它的前后两部分，再递归处理。</p>

<h4 id="3-算法代码-5"><strong>3）算法代码</strong></h4>

<pre><code>void QuickSort(int a[], int left, int right)
{
    int i,j,v;
    if (leftv&amp;&amp;i
</code></pre>

<h3 id="总结"><strong>总结</strong></h3>

<p>总结一下各种排序算法如下：</p>

<p>名称</p>

<p>|</p>

<p>时间复杂度</p>

<p>|</p>

<p>额外空间</p>

<p>|</p>

<p>稳定性</p>

<p>|</p>

<p>考点</p>

<p>&mdash;|&mdash;|&mdash;|&mdash;|&mdash;</p>

<p>插入排序</p>

<p>|</p>

<p>平均O(n^2)</p>

<p>最优O(n)</p>

<p>最差O(n^2)</p>

<p>|</p>

<p>O(1)</p>

<p>|</p>

<p>稳定</p>

<p>|</p>

<p>选择填空</p>

<p>各种时间复杂度</p>

<p>移动元素个数</p>

<p>希尔排序</p>

<p>|</p>

<p>最差O(n log n)</p>

<p>最优 O(n)</p>

<p>|</p>

<p>O(n)</p>

<p>|</p>

<p>不稳定</p>

<p>|</p>

<p>时间复杂度</p>

<p>比较次数</p>

<p>选择排序</p>

<p>|</p>

<p>O(n^2)</p>

<p>|</p>

<p>O(1)</p>

<p>|</p>

<p>不稳定</p>

<p>|</p>

<p>同插入排序</p>

<p>冒泡排序</p>

<p>|</p>

<p>O(n^2)</p>

<p>最优O(n)</p>

<p>最差O(n^2)</p>

<p>|</p>

<p>O(1)</p>

<p>|</p>

<p>稳定</p>

<p>|</p>

<p>时间复杂度</p>

<p>比较次数</p>

<p>单轮冒泡</p>

<p>快速排序</p>

<p>|</p>

<p>O(n log n)</p>

<p>|</p>

<p>O(1)</p>

<p>|</p>

<p>不稳定</p>

<p>|</p>

<p>时间复杂度</p>

<p>快排partition算法</p>

<p>堆排序</p>

<p>|</p>

<p>O(n log n)</p>

<p>|</p>

<p>O(n)</p>

<p>|</p>

<p>不稳定</p>

<p>|</p>

<p>时间复杂度</p>

<p>堆调整，建堆，堆排序，Top K问题</p>

<p>归并排序</p>

<p>|</p>

<p>平均O(nlogn)</p>

<p>最差O(nlogn)</p>

<p>最优O(n)</p>

<p>|</p>

<p>O(n)</p>

<p>|</p>

<hr />

<p>作者：hao_09</p>

<p>时间：2015/8/4</p>

<p>文章地址：<a href="http://blog.csdn.net/lsh_2013/article/details/47280135">http://blog.csdn.net/lsh_2013/article/details/47280135</a></p>

<hr />

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>