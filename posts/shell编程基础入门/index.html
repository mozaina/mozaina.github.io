<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell编程基础入门 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell编程基础入门 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell编程基础入门">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell编程基础入门</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="1-什么是shell"><strong>【1】什么是Shell</strong></h2>

<h3 id="①-shell定义">① shell定义</h3>

<p>下面是从百度百科摘取的定义。</p>

<blockquote>
<p>在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。</p>

<p>同时它又是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。</p>
</blockquote>

<p><strong>在Linux/Unix中示意图如下：</strong><br />
<a href="https://img.it610.com/image/info8/fc3439e3bb6b49f2a21118038e02ab16.jpg"><img src="https://img.it610.com/image/info8/fc3439e3bb6b49f2a21118038e02ab16.jpg" alt="Shell编程基础入门_第1张图片" /></a></p>

<h3 id="②-shell的分类">② shell的分类</h3>

<table>
<thead>
<tr>
<th>shell类别</th>
<th>易学性</th>
<th>可移植性</th>
<th>编辑性</th>
<th>快捷性</th>
</tr>
</thead>

<tbody>
<tr>
<td>Bourne shell (sh)</td>
<td>容易</td>
<td>好</td>
<td>较差</td>
<td>较差</td>
</tr>

<tr>
<td>Korn shell ( ksh)</td>
<td>较难</td>
<td>较好</td>
<td>好</td>
<td>较好</td>
</tr>

<tr>
<td>Bourne Again shell ( bash)</td>
<td>难</td>
<td>较好</td>
<td>好</td>
<td>好</td>
</tr>

<tr>
<td>POSIX shell ( psh)</td>
<td>较难</td>
<td>好</td>
<td>好</td>
<td>较好</td>
</tr>

<tr>
<td>C shell ( csh)</td>
<td>较难</td>
<td>差</td>
<td>较好</td>
<td>较好</td>
</tr>

<tr>
<td>TENEX/TOPS C shell ( tcsh)</td>
<td>难</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
</tbody>
</table>

<p>Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括<code>sh、ksh、Bash、psh、zsh</code>；C家族主要包括：<code>csh、tcsh</code>
（Bash和zsh在不同程度上支持csh 的语法）。</p>

<p>我们可以通过/etc/shells文件来查询Linux支持的Shell。命令如下：<code>vim /etc/shells</code></p>

<pre><code>/bin/sh
/bin/bash
/usr/bin/sh
/usr/bin/bash
/bin/tcsh
/bin/csh
</code></pre>

<h3 id="③-shell脚本执行的两种方式">③ shell脚本执行的两种方式</h3>

<p>编写一个测试脚本hello.sh:</p>

<pre><code>echo &quot;this is test&quot;
</code></pre>

<p>Shell脚本写好了，那么这个脚本该如何运行呢？在Linux中脚本的执行主要有这样两种种方法：</p>

<ul>
<li>赋予执行权限，直接运行</li>
</ul>

<p>这种方法是最常用的Shell脚本运行方法，也最为直接简单。就是赋予执行权限之后，直接运行。当然运行时可以使用绝对路径，也可以使用相对路径运行。命令如下：</p>

<pre><code>#赋予执行权限
[root@localhost sh]# chmod 755 hello.sh
#使用绝对路径运行
[root@localhost sh]# /root/sh/hello.sh
this is test
#使用相对路径运行
[root@localhost sh]# ./hello.sh
</code></pre>

<ul>
<li>通过Bash调用执行脚本</li>
</ul>

<p>这种方法也非常简单，命令如下：</p>

<pre><code>[root@localhost sh]# bash hello.sh
this is test
</code></pre>

<p>脚本中通常可以看到第一行有如下所示，这是定义该脚本为/bin/bash这种shell。也是Linux下默认的shell。</p>

<pre><code>#! /bin/bash
//...
</code></pre>

<hr />

<h2 id="2-bash的基本功能"><strong>【2】Bash的基本功能</strong></h2>

<h3 id="①-命令别名">① 命令别名</h3>

<p>查询命令别名：<code>alias</code>:</p>

<pre><code>[root@bogon init.d]# alias
alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
</code></pre>

<p>如上所示，当我们平时使用rm命令时，其自动给我们附加了<code>-i</code>参数。</p>

<p>设定命令别名：<code>alias 别名='原命令'</code></p>

<pre><code>[root@bogon init.d]# alias vi='vim'
#定义vim命令的别名是vi
</code></pre>

<p><strong><code>既然我们说别名的优先级比命令高，那么命令执行时具体的顺序是什么呢？</code></strong> 命令执行时的顺序是这样的：</p>

<blockquote>
<ul>
<li>第一顺位执行用绝对路径或相对路径执行的命令。</li>
<li>第二顺位执行别名。</li>
<li>第三顺位执行Bash的内部命令。</li>
<li>第四顺位执行按照<code>$PATH</code>环境变量定义的目录查找顺序找到的第一个命令。</li>
</ul>
</blockquote>

<p>为了让这个别名永久生效，可以把别名写入环境变量配置文件“<code>~/.bashrc</code>”。命令如下：</p>

<pre><code>[root@localhost ~]# vi /root/.bashrc
source /root/.bashrc
#使配置文件的环境变量生效而不用重新登录
</code></pre>

<hr />

<h3 id="②-bash常用快捷键">② Bash常用快捷键</h3>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作 用</th>
</tr>
</thead>

<tbody>
<tr>
<td>ctrl+A</td>
<td>把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。</td>
</tr>

<tr>
<td>ctrl+E</td>
<td>把光标移动到命令行结尾。</td>
</tr>

<tr>
<td>ctrl+C</td>
<td>强制终止当前的命令。</td>
</tr>

<tr>
<td>ctrl+L</td>
<td>清屏，相当于clear命令。</td>
</tr>

<tr>
<td>ctrl+U</td>
<td>删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便</td>
</tr>

<tr>
<td>ctrl+K</td>
<td>删除或剪切光标之后的内容。</td>
</tr>

<tr>
<td>ctrl+Y</td>
<td>粘贴ctrl+U或ctrl+K剪切的内容。</td>
</tr>

<tr>
<td>ctrl+R</td>
<td>在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索。</td>
</tr>

<tr>
<td>ctrl+D</td>
<td>退出当前终端</td>
</tr>

<tr>
<td>ctrl+Z</td>
<td>暂停，并放入后台</td>
</tr>

<tr>
<td>ctrl+S</td>
<td>暂停屏幕输出</td>
</tr>

<tr>
<td>ctrl+Q</td>
<td>恢复屏幕输出</td>
</tr>
</tbody>
</table>

<hr />

<h3 id="③-输入输出重定向">③ 输入输出重定向</h3>

<p><strong>3.1 Bash的标准输入输出</strong></p>

<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>键盘</td>
<td>/dev/stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>

<tr>
<td>显示器</td>
<td>/dev/stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>

<tr>
<td>显示器</td>
<td>/dev/stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>

<p><strong>3.2 输出重定向</strong></p>

<table>
<thead>
<tr>
<th>类 型</th>
<th>符 号</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>标准输出重定向</code></td>
<td>命令 &gt; 文件</td>
<td>以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。</td>
</tr>

<tr>
<td>标准输出重定向</td>
<td>命令 &gt;&gt; 文件</td>
<td>以追加的方式，把命令的正确输出输出到指定的文件或设备当中。</td>
</tr>

<tr>
<td><code>标准错误输出重定向</code></td>
<td>错误命令 2&gt;文件</td>
<td>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</td>
</tr>

<tr>
<td>标准错误输出重定向</td>
<td>错误命令 2&gt;&gt;文件</td>
<td>以追加的方式，把命令的错误输出输出到指定的文件或设备当中。</td>
</tr>

<tr>
<td><code>正确输出和错误输出同时保存</code></td>
<td>命令 &gt; 文件 2&gt;&amp;1</td>
<td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。</td>
</tr>

<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1</td>
<td>以追加的方式，把正确输出和错误输出都保存到同一个文件当中。</td>
</tr>

<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &amp;&gt;文件</td>
<td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。</td>
</tr>

<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令 &amp;&gt;&gt;文件</td>
<td>以追加的方式，把正确输出和错误输出都保存到同一个文件当中。</td>
</tr>

<tr>
<td>正确输出和错误输出同时保存</td>
<td>命令&gt;&gt;文件1 2&gt;&gt;文件2</td>
<td>把正确的输出追加到文件1中，把错误的输出追加到文件2中。</td>
</tr>
</tbody>
</table>

<p><code>命令 &gt;&gt; 文件 2&gt;&amp;1</code>可以解释为：把命令正确输出保存到文件中，错误输出保存到正确输出里。</p>

<p>如果错误输出不想保存到文件，可以使用如下命令：<code>命令&gt;&gt;文件 2&gt;&gt;/dev/null</code> 就会丢弃错误输出。</p>

<p><strong>3.3 输入重定向</strong></p>

<p>输入重定向即改变默认从键盘输入，而从某个文件进行读取，通常是<code>&lt;</code>号。如下以wc命令实例说明。</p>

<p>语法格式：</p>

<pre><code>wc [选项] [文件名]
</code></pre>

<p>选项：</p>

<pre><code>-c 统计字节数
-w 统计单词数
-l 统计行数



#具体实例如下
[root@bogon init.d]# wc -l abc
15 abc
[root@bogon init.d]# wc &lt; abc
 15  27 199
[root@bogon init.d]# wc abc
 15  27 199 abc
</code></pre>

<hr />

<h3 id="④-多命令顺序执行">④ 多命令顺序执行</h3>

<table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作 用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>；</code></td>
<td>命令1 ；命令2</td>
<td>多个命令顺序执行，命令之间没有任何逻辑联系</td>
</tr>

<tr>
<td><code>&amp;&amp;</code></td>
<td>命令1 &amp;&amp; 命令2</td>
<td>当命令1正确执行（<code>$?=0</code>），则命令2才会执行</td>
</tr>
</tbody>
</table>

<p>当命令1执行不正确（<code>$?≠0</code>），则命令2不会执行<br />
<code>||</code> | <code>命令1 || 命令2</code> | 当命令1 执行不正确（<code>$?≠0</code>），则命令2才会执行<br />
当命令1正确执行（<code>$?=0</code>），则命令2不会执行</p>

<h3 id="⑤-bash中的特殊符号">⑤ Bash中的特殊符号</h3>

<p><strong>5.1 通配符</strong></p>

<table>
<thead>
<tr>
<th>通配符</th>
<th>作 用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>?</code></td>
<td>匹配一个任意字符</td>
</tr>

<tr>
<td><code>*</code></td>
<td>匹配0个或任意多个任意字符，也就是可以匹配任何内容</td>
</tr>

<tr>
<td><code>[]</code></td>
<td>匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c。</td>
</tr>

<tr>
<td><code>[-]</code></td>
<td>匹配中括号中任意一个字符，-代表一个范围。例如：[a-z]代表匹配一个小写字母。</td>
</tr>

<tr>
<td><code>[^]</code></td>
<td>逻辑非，表示匹配不是中括号内的一个字符。例如：[^0-9]代表匹配一个不是数字的字符。</td>
</tr>
</tbody>
</table>

<pre><code>[root@localhost tmp]# ls *
012 0abc abc abcd
#“*”代表所有的文件

[root@localhost tmp]# ls ?abc
0abc
#“?”匹配任意一个字符，所以会匹配0abc
#但是不能匹配abc，因为“?”不能匹配空

[root@localhost tmp]# ls [0-9]*
012 0abc
#匹配任何以数字开头的文件

[root@localhost tmp]# ls [^0-9]*
abc abcd
#匹配不已数字开头的文件
</code></pre>

<p><strong>5.2 其他特殊符号</strong></p>

<table>
<thead>
<tr>
<th>符 号</th>
<th>作 用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>''</code></td>
<td>单引号。在单引号中所有的特殊符号，如“$”和“`”(反引号)都没有特殊含义。</td>
</tr>

<tr>
<td><code>&quot;&quot;</code></td>
<td>双引号。在双引号中特殊符号都没有特殊含义，但是“$”、“`”和“\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。</td>
</tr>

<tr>
<td>``</td>
<td>反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和<code>$()</code>作用一样，不过推荐使用$()，因为反引号非常容易看错。</td>
</tr>

<tr>
<td>$()</td>
<td>和反引号作用一样，用来引用系统命令。</td>
</tr>

<tr>
<td>()</td>
<td>用于一串命令执行时，()中的命令会在子Shell中运行</td>
</tr>

<tr>
<td>{}</td>
<td>用于一串命令执行时，{}中的命令会在当前Shell中执行。也可以用于变量变形与替换。</td>
</tr>

<tr>
<td>[]</td>
<td>用于变量的测试。</td>
</tr>

<tr>
<td>#</td>
<td>在Shell脚本中，#开头的行代表注释。</td>
</tr>

<tr>
<td>$</td>
<td>用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。</td>
</tr>

<tr>
<td></td>
<td>转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如<code>\$</code>将输出<code>“$”</code>符号，而不当做是变量引用。</td>
</tr>
</tbody>
</table>

<pre><code>#定义变量
[root@bogon dev]# name=jane
#输出变量值
[root@bogon dev]# echo $name
jane

#先执行date命令结果赋值给a
[root@bogon dev]# a=$(date)
[root@bogon dev]# echo $a
Tue Jul 14 16:08:45 CST 2020
#使用反引号
[root@bogon dev]# a=`date`
[root@bogon dev]# echo $a
Tue Jul 14 16:10:36 CST 2020
</code></pre>

<p><strong>5.3 小括号()与大括号{}</strong></p>

<p>如果是用于一串命令的执行，那么小括号和大括号的主要区别在于：</p>

<ul>
<li>()执行一串命令时，需要重新开一个子shell进行执行</li>
<li>{}执行一串命令时，是在当前shell执行；</li>
<li>()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开；</li>
<li>()最后一个命令可以不用分号；</li>
<li>{}最后一个命令要用分号；</li>
<li>{}的第一个命令和左括号之间必须要有一个空格；</li>
<li>()里的各命令不必和括号有空格；</li>
<li>()和{}括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令。</li>
</ul>

<hr />

<h2 id="3-bash的变量"><strong>【3】Bash的变量</strong></h2>

<h3 id="①-bash中的变量">① Bash中的变量</h3>

<p>在定义变量时，有一些规则需要遵守：</p>

<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是“2name”则是错误的。</li>
<li>在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必修指定变量类型为数值型。</li>
<li>变量用等号连接值，等号左右两侧不能有空格。</li>
<li>变量的值如果有空格，需要使用单引号或双引号包括。如：“test=“hello world!””。其中双引号括起来的内容<code>“$”、“\”和反引号</code>都拥有特殊含义，而单引号括起来的内容都是普通字符。</li>
<li>在变量的值中，可以使用<code>“\”</code>转义符。</li>
<li>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用<code>双引号</code>包含<code>&quot;$变量名&quot;</code>或用<code>${变量名}</code>包含变量名</li>
<li>如果是把命令的结果作为变量值赋予变量，则需要使用反引号或<code>$()</code>包含命令</li>
<li>环境变量名建议大写，便于区分</li>
</ul>

<p>变量叠加实例如下：</p>

<pre><code>[root@localhost ~]# test=123
[root@localhost ~]# test=&quot;$test&quot;456
[root@localhost ~]# echo $test
123456
#叠加变量test，变量值变成了123456
[root@localhost ~]# test=${test}789
[root@localhost ~]# echo $test
123456789
#再叠加变量test，变量值编程了123456789
</code></pre>

<hr />

<h3 id="②-变量的分类">② 变量的分类</h3>

<ul>
<li>用户自定义变量：这种变量是最常见的变量，由用户自由定义变量名和变量的值。</li>
<li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据，比如当前登录用户，用户的家目录，命令的提示符等。环境变量的变量名可以自由定义，但是一般对系统起作用的环境变量的变量名是系统预先设定好的。</li>
<li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li>
<li>预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li>
</ul>

<p><strong>2.1 变量查看</strong></p>

<p>语法格式：<code>set 选项</code>，直接使用set命令，会查询系统中所有的变量，包含用户自定义变量和环境变量。<br />
选项：</p>

<pre><code>-u： 如果设定此选项，调用未声明变量时会报错（默认无任何提示）
-x: 如果设定此选项，在命令执行之前，会把命令先输出一次
</code></pre>

<p>set -u可以用来测试变量是否存在。变量值为空与变量是否存在是两个概念。</p>

<pre><code>[root@bogon shell]# set -u
[root@bogon shell]# echo $y
-bash: y: unbound variable
</code></pre>

<p><strong>2.2 变量删除</strong></p>

<p>语法格式：<code>unset 变量名</code></p>

<pre><code>#定义变量
[root@bogon dev]# name=jane
#输出值
[root@bogon dev]# echo $name
jane
#删除变量
[root@bogon dev]# unset name
[root@bogon dev]# echo $name

#这里为空，表示变量已经不存在
</code></pre>

<hr />

<h3 id="③-环境变量">③ 环境变量</h3>

<p><strong>3.1 设置环境变量</strong></p>

<pre><code>#使用export声明的变量即是环境变量
export age=&quot;18&quot;
</code></pre>

<p><strong>3.2 环境变量的查询和删除</strong></p>

<p>env命令和set命令的区别是，set命令可以查看所有变量，而env命令只能查看环境变量。<br />
<a href="https://img.it610.com/image/info8/13d36f6f9e3048df90cacaf2a0abeb5e.jpg"><img src="https://img.it610.com/image/info8/13d36f6f9e3048df90cacaf2a0abeb5e.jpg" alt="Shell编程基础入门_第2张图片" /></a><br />
常见变量说明：</p>

<pre><code>BASH=/bin/bash  #Bash的位置
BASH_VERSINFO=([0]=&quot;4&quot; [1]=&quot;1&quot; [2]=&quot;2&quot; [3]=&quot;1&quot; [4]=&quot;release&quot;
[5]=&quot;i386-redhat-linux-gnu&quot;)    #Bash版本
BASH_VERSION='4.1.2(1)-release'     #bash的版本
COLORS=/etc/DIR_COLORS  #颜色记录文件
HISTFILE=/root/.bash_history    #历史命令保存文件
HISTFILESIZE=1000   #在文件当中记录的历史命令最大条数
HISTSIZE=1000   #在缓存中记录的历史命令最大条数
LANG=zh_CN.UTF-8    #语系环境
MACHTYPE=i386-redhat-linux-gnu  #软件类型是i386兼容类型
MAILCHECK=60    #每60秒去扫描新邮件
PPID=2166   #父shell的PID。我们当前Shell是一个子shell
PS1='[\u@\h \W]\$ '     #命令提示符
PS2='&gt; '    #如果命令一行没有输入完成，第二行命令的提示符
UID=0   #当前用户的UID
</code></pre>

<hr />

<h3 id="④-path变量">④ PATH变量</h3>

<p>PATH是系统查找命令的路径。
PATH变量的值是用<code>“：”</code>分割的路径，这些路径就是系统查找命令的路径。也就是说当我们输入了一个程序名，如果没有写入路径，系统就会到PATH变量定义的路径中去寻找，是否有可以执行的程序。如果找到则执行，否则会报“命令没有发现”的错误。</p>

<p>如果我们把自己的脚本拷贝到PATH变量定义的路径中，我们自己写的脚本也可以不输入路径而直接运行。当然也可以选择修改PATH变量的值，而不是把程序脚本复制到/bin/目录中</p>

<pre><code>#查看PATH值
[root@bogon dev]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
#修改PATH值
[root@bogon dev]# PATH=&quot;$PATH&quot;:/root/sh
#查看修改后的PATH值
[root@bogon dev]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/sh
</code></pre>

<p>当然我们这样定义的PATH变量只是临时生效，一旦重启或注销就会消失，如果想要永久生效，需要写入环境变量配置文件。</p>

<hr />

<h3 id="⑤-位置参数变量">⑤ 位置参数变量</h3>

<table>
<thead>
<tr>
<th>位置参数变量</th>
<th>作 用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>$n</code></td>
<td>n为数字，<code>$0</code>代表命令本身，<code>$1-$9</code>代表第一到第九个参数，十以上的参数需要用大括号包含，如<code>${10}</code>.</td>
</tr>

<tr>
<td><code>$*</code></td>
<td>这个变量代表命令行中所有的参数，<code>$*</code>把所有的参数看成一个整体</td>
</tr>

<tr>
<td><code>$@</code></td>
<td>这个变量也代表命令行中所有的参数，不过<code>$@</code>把每个参数区分对待</td>
</tr>

<tr>
<td><code>$#</code></td>
<td>这个变量代表命令行中所有参数的个数</td>
</tr>
</tbody>
</table>

<p><strong>5.1<code>$n</code>参数实例count.sh</strong></p>

<pre><code>[root@bogon shell]# vim count.sh
#!/bin/bash
num1=$1
#给num1变量赋值是第一个参数
num2=$2
#给num2变量赋值是第二个参数
sum=$(( num1 + num2))
#变量sum的和是num1加num2
echo $sum
#打印变量sum的值
</code></pre>

<blockquote>
<p>需要告诉shell是数字变量进行相加，所以需要用到<code>$(())</code>，注意非<code>$()</code></p>
</blockquote>

<p>测试count.sh:</p>

<pre><code>[root@bogon shell]# ./count.sh 11 22
33
</code></pre>

<p><strong>5.2 参数实例parameter.sh</strong></p>

<pre><code>#!/bin/bash
echo &quot;A total of $# parameters&quot;
#使用$#代表所有参数的个数
echo &quot;The parameters is: $*&quot;
#使用$*代表所有的参数
echo &quot;The parameters is: $@&quot;
#使用$@也代表所有参数
</code></pre>

<p>parameter.sh测试实例：</p>

<pre><code>[root@bogon shell]# ./parameter.sh 11 22 33
A total of 3 parameters
The parameters is: 11 22 33
The parameters is: 11 22 33
</code></pre>

<p>那么<code>“$*”和“$@”</code>有区别吗？还是有区别的，<code>$*</code>会把接收的所有参数当成一个整体对待，而<code>$@</code>则会区分对待接收到的所有参数。</p>

<p><strong>5.3 参数实例parameter2.sh</strong></p>

<pre><code>[root@localhost sh]# vi parameter2.sh
#!/bin/bash
for i in &quot;$*&quot;
#定义for循环，in后面有几个值，for会循环多少次，注意“$*”要用双引号括起来
#每次循环会把in后面的值赋予变量i
#Shell把$*中的所有参数看成是一个整体，所以这个for循环只会循环一次
do
echo &quot;The parameters is: $i&quot;
#打印变量$i的值
done

x=1
#定义变量x的值为1
for y in &quot;$@&quot;
#同样in后面的有几个值，for循环几次，每次都把值赋予变量y
#可是Shell中把“$@”中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次
do
echo &quot;The parameter$x is: $y&quot;
#输出变量y的值
x=$(( $x +1 ))
#然变量x每次循环都加1，为了输出时看的更清楚
done
</code></pre>

<p>脚本测试如下：</p>

<pre><code>[root@bogon shell]# ./parameter2.sh 11 22 33
The parameters is: 11 22 33
The parameter1 is: 11
The parameter2 is: 22
The parameter3 is: 33
</code></pre>

<hr />

<h3 id="⑥-预定义变量">⑥ 预定义变量</h3>

<table>
<thead>
<tr>
<th>预定义变量</th>
<th>作 用</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>$？</code></td>
<td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；</td>
</tr>
</tbody>
</table>

<p>如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。<br />
<code>$$</code> | 当前进程的进程号（PID）<br />
<code>|$!</code> | 后台运行的最后一个进程的进程号（PID）</p>

<p><code>$?</code>命令测试如下：</p>

<pre><code>[root@bogon shell]# ls
count.sh  parameter2.sh  parameter.sh  test1.txt
[root@bogon shell]# echo $?
0
#预定义变量“$?”的值是0，证明上一个命令执行正确

[root@bogon shell]# lks
bash: lks: command not found...
[root@bogon shell]# echo $?
127
#变量“$?”返回一个非0的值，证明上一个命令没有正确执行
#至于错误的返回值到底是多少，是在编写ls命令时定义好的，
</code></pre>

<p>接下来我们来说明下<code>“$$”和“$!”</code>这两个预定义变量</p>

<pre><code>[root@localhost sh]# vi variable.sh
#!/bin/bash
echo &quot;The current process is $$&quot;
#输出当前进程的PID。
#这个PID就是variable.sh这个脚本执行时，生成的进程的PID

find /root -name hello.sh &amp;
#使用find命令在root目录下查找hello.sh文件
#符号&amp;的意思是把命令放入后台执行，工作管理我们在系统管理章节会详细介绍
echo &quot;The last one Daemon process is $!&quot;
#输出这个后台执行命令的进程的PID，也就是输出find命令的PID号
</code></pre>

<p>variable.sh脚本测试实例如下：</p>

<pre><code>[root@bogon shell]# ./variable.sh
The current process is 5139
The last one Daemon process is 5140
</code></pre>

<hr />

<h3 id="⑦-接收键盘输入">⑦ 接收键盘输入</h3>

<p><strong>语法格式</strong> ：<code>read [选项] [变量名]</code></p>

<p>选项：</p>

<pre><code>-p “提示信息”： 在等待read输入时，输出提示信息
-t 秒数： read命令会一直等待用户输入，使用此选项可以指定等待时间
-n 字符数： read命令只接受指定的字符数，就会执行
-s： 隐藏输入的数据，适用于机密信息的输入
</code></pre>

<p>变量名：</p>

<ul>
<li>变量名可以自定义，如果不指定变量名，会把输入保存入默认变量REPLY</li>
<li>如果只提供了一个变量名，则整个输入行赋予该变量</li>
<li>如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字</li>
</ul>

<p>测试脚本如下：</p>

<pre><code>[root@bogon shell]# vim read.sh

#!/bin/bash
read -t 30 -p &quot;Please input your name: &quot; name
#提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中

echo &quot;Name is $name&quot;
#看看变量“$name”中是否保存了你的输入

read -s -t 30 -p &quot;Please enter your age: &quot; age
#提示“请输入年龄”并等待30秒，把用户的输入保存入变量age中
#年龄是隐私，所以我们用“-s”选项隐藏输入
echo -e &quot;\n&quot;
#调整输出格式，如果不输出换行，一会的年龄输出不会换行
echo &quot;Age is $age&quot;

read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender
#提示“请选择性别”并等待30秒，把用户的输入保存入变量gender
#使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车）
echo -e &quot;\n&quot;
echo &quot;Sex is $gender&quot;
</code></pre>

<p>测试实例如下：</p>

<pre><code>[root@bogon shell]# ./read.sh
Please input your name: jane
Name is jane
Please enter your age:

Age is 18
Please select your gender[M/F]: M

Sex is M
</code></pre>

<hr />

<h3 id="⑧-变量的测试与内容置换">⑧ 变量的测试与内容置换</h3>

<p>这个主要用来对变量进行测试，如根据X的值间接判断Y的情况。</p>

<table>
<thead>
<tr>
<th>变量置换方式</th>
<th>变量y没有设置</th>
<th>变量y为空值</th>
<th>变量y设置值</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>x=${y-新值}</code></td>
<td>x=新值</td>
<td>x为空</td>
<td><code>x=$y</code></td>
</tr>

<tr>
<td><code>x=${y:-新值}</code></td>
<td>x=新值</td>
<td>x=新值</td>
<td><code>x=$y</code></td>
</tr>

<tr>
<td><code>x=${y+新值}</code></td>
<td>x为空</td>
<td>x=新值</td>
<td>x=新值</td>
</tr>

<tr>
<td><code>x=${y:+新值}</code></td>
<td>x为空</td>
<td>x为空</td>
<td>x=新值</td>
</tr>

<tr>
<td><code>x=${y=新值}</code></td>
<td>x=新值 y=新值</td>
<td>x为空 y值不变</td>
<td>x=$y y值不变</td>
</tr>

<tr>
<td><code>x=${y:=新值}</code></td>
<td>x=新值 y=新值</td>
<td>x=新值 y=新值</td>
<td>x=$y y值不变</td>
</tr>

<tr>
<td><code>x=${y?新值}</code></td>
<td>新值输出到标准错误输出（就是屏幕）</td>
<td>x为空</td>
<td>x=$y</td>
</tr>

<tr>
<td><code>x=${y:?新值}</code></td>
<td>新值输出到标准错误输出</td>
<td>新值输出到标准错误输出</td>
<td>x=$y</td>
</tr>
</tbody>
</table>

<ul>
<li>如果大括号内没有“：”，则变量y是为空，还是没有设置，处理方法是不同的；</li>
<li>如果大括号内有“：”，则变量y不论是为空，还是没有没有设置，处理方法是一样的。</li>
<li>如果大括号内是“-”或“+”，则在改变变量x值的时候，变量y是不改变的；</li>
<li>如果大括号内是“=”，则在改变变量x值的同时，变量y的值也会改变。</li>
<li>如果大括号内是“？”，则当变量y不存在或为空时，会把“新值”当成报错输出到屏幕上。</li>
</ul>

<p>测试实例如下：</p>

<pre><code>[root@localhost ~]# unset y
#删除变量y
[root@localhost ~]# x=${y-new}
#进行测试
[root@localhost ~]# echo $x
new
#因为变量y不存在，所以x=new
[root@localhost ~]# echo $y
#但是变量y还是不存在的
</code></pre>

<hr />

<h2 id="4-shell的运算符">【4】 Shell的运算符</h2>

<p>进行数值运算，可以采用以下三种方法中的任意一种：</p>

<ul>
<li>使用declare声明变量类型</li>
<li>使用expr或let数值运算工具</li>
<li>使用<code>“$((运算式))”或“$[运算式]”</code>方式运算</li>
</ul>

<h3 id="①-使用declare声明变量类型">① 使用declare声明变量类型</h3>

<p>既然所有变量的默认类型是字符串型，那么只要我们把变量声明为整数型不就可以运算了吗？使用declare命令就可以实现声明变量的类型。命令如下：<code>declare
[+/-][选项] 变量名</code></p>

<p><strong>选项：</strong></p>

<p>-： 给变量设定类型属性<br />
+： 取消变量的类型属性<br />
-a： 将变量声明为数组型<br />
-i： 将变量声明为整数型（integer）<br />
-r： 将变量声明为只读变量。注意，一旦设置为只读变量，既不能修改变量的值，也不能删除变量，甚至不能通过+r取消只读属性<br />
-x： 将变量声明为环境变量<br />
-p： 显示指定变量的被声明的类型</p>

<p><strong>将变量声明为整数类型实例如下：</strong></p>

<pre><code>#定义变量
[root@bogon shell]# a=1
[root@bogon shell]# b=2
#如下进行遍历值相加
[root@bogon shell]# declare -i c=a+b
[root@bogon shell]# echo $c
3
#如下进行遍历值相加
[root@bogon shell]# declare -i d=$a+$b
[root@bogon shell]# echo $d
3
</code></pre>

<p><strong>数组变量类型实例如下：</strong></p>

<pre><code>[root@bogon shell]# name[0]=jane
[root@bogon shell]# name[1]=lucy
[root@bogon shell]# name[2]=lily
[root@bogon shell]# echo $name
jane
[root@bogon shell]# echo ${name[*]}
jane lucy lily
</code></pre>

<blockquote>
<p>在定义变量时采用了“变量名[下标]”的格式，这个变量就会被系统认为是数组型。数组的下标是从0开始的，在调用数组值时，需要使用<code>${数组[下标]}</code>的方式来读取。输出数组的内容，如果只写数组名，那么只会输出第一个下标变量</p>
</blockquote>

<p><strong>变量属性的查看与修改：</strong></p>

<pre><code>#将变量声明为环境变量
[root@bogon shell]# declare -x test
#查看变量属性
[root@bogon shell]# declare -p test
declare -x test=&quot;1&quot;

#将变量声明为只读变量
[root@bogon shell]# declare -r test
[root@bogon shell]# declare -p test
declare -rx test=&quot;1&quot;

#取消test变量的环境变量属性
[root@bogon shell]# declare +x test
[root@bogon shell]# declare -p test
declare -r test=&quot;1&quot;
</code></pre>

<hr />

<h3 id="②-使用expr或let数值运算工具">② 使用expr或let数值运算工具</h3>

<p><strong>2.1 使用expr命令</strong></p>

<p>要想进行数值运算的第二种方法是使用expr命令，这种命令就没有declare命令复杂。使用expr命令进行运算时，<code>要注意“+”号左右两侧必须有空格</code>，否则运算不执行。命令实例如下：</p>

<pre><code>[root@bogon shell]# a=1
[root@bogon shell]# b=2
[root@bogon shell]# c=$(expr $a + $b)
[root@bogon shell]# echo $c
3
</code></pre>

<p><strong>2.2 使用let命令</strong></p>

<p>let命令对格式要求要比expr命令宽松，所以推荐使用let命令进行数值运算。</p>

<pre><code>[root@bogon shell]# a=1
[root@bogon shell]# b=2
[root@bogon shell]# let c=$a+$b+1
[root@bogon shell]# echo $c
4
</code></pre>

<h3 id="③-使用-运算式-或-运算式-方式运算-推荐">③ 使用<code>“$((运算式))”</code>或<code>“$[运算式]”</code>方式运算-推荐</h3>

<p><strong>实例如下：</strong></p>

<pre><code>[root@bogon shell]# a=1
[root@bogon shell]# b=2
[root@bogon shell]# c=$(($a+$b))
[root@bogon shell]# echo $c
3
[root@bogon shell]# d=$[$a+$b]
[root@bogon shell]# echo $d
3
</code></pre>

<hr />

<h3 id="④-shell常用运算符">④ Shell常用运算符</h3>

<p>运算符优先级表明在每个表达式或子表达式中哪一个运算对象首先被求值，数值越大优先级越高，具有较高优先级级别的运算符先于较低级别的运算符进行求值运算。</p>

<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>13</td>
<td><code>-, +</code></td>
<td>单目负、单目正</td>
</tr>

<tr>
<td>12</td>
<td><code>!, ~</code></td>
<td>逻辑非、按位取反或补码</td>
</tr>

<tr>
<td>11</td>
<td><code>* , / , %</code></td>
<td>乘、除、取模</td>
</tr>

<tr>
<td>10</td>
<td><code>+, -</code></td>
<td>加、减</td>
</tr>

<tr>
<td>9</td>
<td><code>&lt;&lt; , &gt;&gt;</code></td>
<td>按位左移、按位右移</td>
</tr>

<tr>
<td>8</td>
<td><code>&lt; =, &gt; =, &lt; , &gt;</code></td>
<td>小于或等于、大于或等于、小于、大于</td>
</tr>

<tr>
<td>7</td>
<td><code>== , !=</code></td>
<td>等于、不等于</td>
</tr>

<tr>
<td>6</td>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>

<tr>
<td>5</td>
<td><code>^</code></td>
<td>按位异或</td>
</tr>

<tr>
<td>4</td>
<td>`</td>
<td>`</td>
</tr>

<tr>
<td>3</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>

<tr>
<td>2</td>
<td>`</td>
<td></td>
</tr>

<tr>
<td>1</td>
<td>`=,+=,-=,*=,/=,%=,&amp;=, ^=,</td>
<td>=, &lt;&lt;=, &gt;&gt;=`</td>
</tr>
</tbody>
</table>

<p><strong>四则运算脚本实例：</strong></p>

<pre><code>#!/bin/bash

read -t 30 -p &quot;please input num1: &quot; num1
read -t 30 -p &quot;please input num2: &quot; num2
read -n1 -t 30 -p &quot;please input operato[+-*/]: &quot; oper
echo -e &quot;\n&quot;

[ &quot;$oper&quot; == &quot;+&quot; ] &amp;&amp; echo &quot;$(( $num1 + $num2 ))&quot; &amp;&amp; exit
[ &quot;$oper&quot; == &quot;-&quot; ] &amp;&amp; echo &quot;$(( $num1 - $num2 ))&quot; &amp;&amp; exit
[ &quot;$oper&quot; == &quot;*&quot; ] &amp;&amp; echo &quot;$(( $num1 * $num2 ))&quot; &amp;&amp; exit
[ &quot;$oper&quot; == &quot;/&quot; ] &amp;&amp; echo &quot;$(( $num1 / $num2 ))&quot; &amp;&amp; exit

echo &quot;qing shu ru zhengque yunsuanfu &quot;
</code></pre>

<p>测试实例如下：</p>

<pre><code>[root@bogon shell]# ./count4.sh
please input num1: 1
please input num2: 2
please input operato[+-*/]: +

3
</code></pre>

<blockquote>
<p>这里第一次用到了中括号[]，在这里表示测试判断的意思，首先判断操作符是什么，然后执行后续命令。</p>
</blockquote>

<hr />

<h2 id="5-环境变量配置文件"><strong>【5】环境变量配置文件</strong></h2>

<p>使配置文件生效：</p>

<pre><code>[root@localhost ~]# source 配置文件
或
[root@localhost ~]# . 配置文件
</code></pre>

<h3 id="①-登录时生效的环境变量配置文件">① 登录时生效的环境变量配置文件</h3>

<p>在Linux系统登录时主要生效的环境变量配置文件有以下五个：</p>

<ul>
<li>/etc/profile</li>
<li>/etc/profile.d/*.sh</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
</ul>

<p><strong>环境变量配置文件调用过程：</strong></p>

<p><a href="https://img.it610.com/image/info8/57b25f51d118431a82928a543b88b812.jpg"><img src="https://img.it610.com/image/info8/57b25f51d118431a82928a543b88b812.jpg" alt="Shell编程基础入门_第3张图片" /></a><br />
<strong>1.1 在用户登录过程先调用/etc/profile文件</strong></p>

<p>在这个环境变量配置文件中会定义这些默认环境变量：</p>

<ul>
<li>USER变量：根据登录的用户，给这个变量赋值（就是让USER变量的值是当前用户）。</li>
<li>LOGNAME变量：根据USER变量的值，给这个变量赋值。</li>
<li>MAIL变量：根据登录的用户，定义用户的邮箱为/var/spool/mail/用户名。</li>
<li>PATH变量：根据登录用户的UID是否为0，判断PATH变量是否包含/sbin、/usr/sbin和/usr/local/sbin这三个系统命令目录。</li>
<li>HOSTNAME变量：主机名，给这个变量赋值。</li>
<li>HISTSIZE变量：定义历史命令的保存条数。</li>
<li>umask：定义umask默认权限。注意/etc/profile文件中的umask权限是在“有用户登录过程（也就是输入了用户名和密码）”时才会生效。</li>
<li>调用<code>/etc/profile.d/*.sh</code>文件，也就是调用<code>/etc/profile.d/</code>目录下所有以<code>.sh</code>结尾的文件。</li>
</ul>

<p><strong>1.2 由/etc/profile文件调用<code>/etc/profile.d/*.sh</code>文件</strong></p>

<p>这个目录中所有以.sh结尾的文件都会被/etc/profile文件调用，这里最常用的就是lang.sh文件，而这个文件又会调用/etc/sysconfig/i18n文件。/etc/sysconfig/i18n这个文件眼熟吗？就是默认语系配置文件。</p>

<p><strong>1.3 由/etc/profile文件调用<code>~/.bash_profile</code>文件</strong></p>

<p><code>~/.bash_profile</code>文件就没有那么复杂了，这个文件主要实现了两个功能：</p>

<ul>
<li>调用了<code>~/.bashrc</code>文件。</li>
<li>在PATH变量后面加入了<code>“:$HOME/bin”</code>这个目录。那也就是说，如果我们在自己的家目录中建立bin目录，然后把自己的脚本放入<code>“~/bin”</code>目录，就可以直接执行脚本，而不用通过目录执行了。</li>
</ul>

<p><strong>1.4 由<code>~/.bash_profile</code>文件调用<code>~/.bashrc</code>文件</strong></p>

<p>在~/.bashrc文件中主要实现了：</p>

<ul>
<li>定义默认别名</li>
<li>调用/etc/bashrc</li>
</ul>

<p><strong>1.5 由<code>~/.bashrc</code>调用了<code>/etc/bashrc</code>文件</strong></p>

<p>在/etc/bashrc文件中主要定义了这些内容：</p>

<ul>
<li>PS1变量：也就是用户的提示符，如果我们想要永久修改提示符，就要在这个文件中修改</li>
<li>umask：定义umask默认权限。这个文件中定义的umask是针对“没有登录过程（也就是不需要输入用户名和密码时，比如从一个终端切换到另一个终端，或进入子Shell）”时生效的。如果是“有用户登录过程”，则是/etc/profile文件中的umask生效。</li>
<li>PATH变量：会给PATH变量追加值，当然也是在“没有登录过程”时才生效。</li>
<li>调用<code>/etc/profile.d/*.sh</code>文件，这也是在“没有用户登录过程”是才调用。在“有用户登录过程”时，<code>/etc/profile.d/*.sh</code>文件已经被<code>/etc/profile</code>文件调用过了。</li>
</ul>

<p>这样这五个环境变量配置文件会被依次调用，那么如果是我们自己定义的环境变量应该放入哪个文件呢？如果你的修改是打算对所有用户生效的，那么可以放入<code>/etc/profile</code>环境变量配置文件；如果你的修改只是给自己使用的，那么可以放入<code>~/.bash_profile或~/.bashrc</code>这两个配置文件中的任一个。</p>

<p>可是如果我们误删除了这些环境变量，比如删除了<code>/etc/bashrc</code>文件，或删除了<code>~/.bashrc</code>文件，那么这些文件中配置就会失效（<code>~/.bashrc文件会调用/etc/bashrc文件</code>）。那么我们的提示符就会变成：<code>-bash-4.1#</code></p>

<hr />

<h3 id="②-注销时生效的环境变量配置文件">② 注销时生效的环境变量配置文件</h3>

<p>在用户退出登录时，只会调用一个环境变量配置文件，就是<code>~/.bash_logout</code>。这个文件默认没有写入任何内容，可是如果我们希望再退出登录时执行一些操作，比如清除历史命令，备份某些数据，就可以把命令写入这个文件。</p>

<h3 id="③-其他配置文件">③ 其他配置文件</h3>

<p>还有一些环节变量配置文件，最常见的就是<code>~/.bash_history</code>文件，也就是历史命令保存文件。</p>

<hr />

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>