<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell编程实验 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell编程实验 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell编程实验">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell编程实验</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><strong>Shell 编程实验</strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

<h3 id="一-实验目的">一、实验目的</h3>

<blockquote>
<p>了解 Shell 的作用和主要分类。<br />
 了解 Bash 的一般语法规则。<br />
 练习编写简单的 shell 程序。</p>
</blockquote>

<h3 id="二-实验内容">二、实验内容</h3>

<blockquote>
<p>1.Shell 变量的定义及其使用。<br />
 2.位置参数和环境变量。<br />
 3.Shell 中的特殊字符。<br />
 4.条件判断结构与循环结构<br />
 5.函数的定义和使用</p>
</blockquote>

<h3 id="三-预备知识">三、预备知识</h3>

<blockquote>
<p>1、LINUX 环境下常用命令和 VI 编辑器的操作。<br />
 2、了解 Shell 作用和主要分类等基础知识。</p>
</blockquote>

<h3 id="四-实验设备及工具">四、实验设备及工具</h3>

<blockquote>
<p>软件:PC 机操作系统 REDHAT ELAS4 环境</p>
</blockquote>

<h3 id="五-实验原理及说明">五、实验原理及说明</h3>

<blockquote>
<p>Shell 是 Linux 系统中一个重要的层次,它是用户与系统交互作用的界面。在介绍 Linux命令时,Shell
都作为命令解释程序出现:它接收用户打入的命令,进行分析,创建子进程实现命令所规定的功能,等子进程终止工作后,发出提示符。这是 Shell
最常见的使用方式。Shell 除了作为命令解释程序以外,还是一种高级程序设计语言,它有变量,关键字,有各种控制语句,如 if, case, while,
for 等语句,有自己的语法结构。利用 Shell 程序设计语言可以编写出功能很强、但代码简单的程序,特别是它把相关的 Linux
命令有机地组合在一起,可大大提高编程的效率,充分利用 Linux 系统的开放性能,设计出适合自己要求的命令。</p>
</blockquote>

<h3 id="六-实验步骤">六、实验步骤</h3>

<blockquote>
<h3 id="1-语法练习">1.语法练习</h3>

<h5 id="1-shell-变量">(1) Shell 变量</h5>

<p>Shell 有两种变量:环境变量和临时变量。在 Shell 脚本中临时变量又分为两类:用户定<br />
 义的变量和位置参数。<br />
 � 用户定义的变量<br />
 用户定义的变量是最普遍的 Shell 变量,变量名是以字母或下化线打头的字母、数字和<br />
 下线符序列,并且大小写字母意义不同。变量名的长度不受限制。定义变量并赋值的一般形<br />
 式是: 变量名=字符串 例如,<br />
 MYFILE=/usr/meng/ff/m1.c<br />
 a. 定义并显示变量的值<br />
 在程序中使用变量的值时,要在变量名前面加上一个符号“$”<br />
 。这个符号告诉 Shell,<br />
 要读取该变量的值。</p>

<p>练习 1.1<br />
 1.1:<br />
 $ dir=/usr/mengqc/file1<br />
 $ echo $dir<br />
 /usr/mengqc/file1<br />
 $ echo dir<br />
 dir<br />
 $ today=Sunday<br />
 $ echo $today $Today<br />
 Sunday<br />
 $ str=&ldquo;Happy New Year ! &rdquo;<br />
 $ echo &ldquo;Wish You $str&rdquo;<br />
 Wish You Happy New Year !</p>

<p>b.read 命令<br />
 作为交互式输入手段,可以利用 read 命令由标准输入(即键盘)上读取数据,然后赋<br />
 给指定的变量。其一般格式是:read 变量 1 [变量 2&hellip;]</p>

<p>练习 1.2<br />
 1.2:<br />
 $ read name &mdash;&ndash;输入 read 命令<br />
 mengqc &mdash;&ndash;输入 name 的值<br />
 $ echo &ldquo;Your Name is $ name.&rdquo;<br />
 Your Name is mengqc &mdash;&ndash;显示输出的结果<br />
 $ read a b c &mdash;&ndash;read 命令有三个参数<br />
 crtvu cn edu &mdash;&ndash;输入三个字符串,中间以空格隔开<br />
 $ echo &ldquo;Email : $a. $c. $b&rdquo;<br />
 Email : crtvu.edu.cn &mdash;&ndash;显示输出结果</p>
</blockquote>

<p>利用 read 命令可交互式的为变量两赋值。输入数据时,数据间以空格或制表符作为分隔符。</p>

<p>注意以下情况:</p>

<blockquote>
<p>*若变量个数与给定数据个数相同,则依次对应赋值,如上面例子所示。<br />
 *若变量数少于数据个数,则从左至右依次给变量赋值,而最后一个变量取得所有余下<br />
 数据的值。<br />
 *若变量个数多余给定数据个数,则从左到右依次给变量赋值,后面的变量没有输入数<br />
 据与之对应时,其值就为空串。<br />
 � 位置参数<br />
 执行 Shell 脚本时可以使用参数。由出现命令行上的位置确定的参数称做位置参数。<br />
 在<br />
 sh 中总共有十个位置参数,其对应的名称依次是 $0,$1,$2,&hellip;$9。其中$0 始终表示命令名或<br />
 Shell 脚本名,对于一个命令行,必然有命令名,也就必定有$0;而其它位置参数依据实际<br />
 需求,可有可无。</p>

<p>练习 1.3 位置参数的作用。<br />
 a.在你的计算机上建立以下三个文件(设建立在目录/usr/username 之下,其中 username<br />
 表示你的主目录名)<br />
 :<br />
 文件 m1.c:<br />
 #include<br />
 main( )<br />
 {<br />
 printf(&ldquo;Begin \n&rdquo;);<br />
 }<br />
 文件 m2.c:<br />
 # include &lt; stdio.h &gt;<br />
 main( )<br />
 {<br />
 printf(&ldquo;OK! \n&rdquo;);<br />
 }<br />
文件 ex3:<br />
 # ex3: shell script to combine files and count lines<br />
 cat $1 $2 $3 $4 $5 $6 $7 $8 $9 | wc -l<br />
 # end<br />
 b.将 ex3 改为具有执行权限:<br />
 $ chmod +x ex3<br />
 c.利用 env 命令查看在环境变量 PATH 中是否包含你的当前工作目录<br />
 (即/usr/username)<br />
 。<br />
 如果没有包含在其中,则利用以下语句改变 PATH 的值:<br />
 $ PATH=$PATH:/usr/username<br />
 d.执行脚本 ex3:<br />
 $ ./ex3 m1.c m2.c<br />
 10</p>

<p>练习 1.4 利用位置参数给定变量赋值。<br />
 a.建立脚本 ex5,如下所示:<br />
 n1=$1<br />
 n2=$2<br />
 n3=$3<br />
 cat $n1 $n2 $n3 | wc -l<br />
 b.将 ex5 改为具有执行权限:<br />
 $ chmod +x ex5<br />
 c.执行脚本 ex5:<br />
 $ ./ex5 m1.c m2.c<br />
 10</p>
</blockquote>

<h5 id="2-shell-中的特殊字符">(2) Shell 中的特殊字符</h5>

<blockquote>
<p>� 通配符<br />
 通常的通配符有三种:<br />
 * 星号,它匹配任意字符的 0 次或多次出现。但注意,文件名前面的圆点(.)和路径<br />
 名中的斜线(/)必须显示匹配。<br />
 ? 问号,它匹配任意一个字符。<br />
 [] 一对方括号,其中有一个字符组。其作用是匹配该字符组所限定的任意一个字符。<br />
 应该注意:字符 * 和 ?在一对方括号外面是通配符,若出现在其内部,它们就失去通<br />
 配符的能力了。<br />
 ! 叹号,若它紧跟在一对方括号的左方括号[之后,则表示不在一对方括号中所列出的<br />
 字符。</p>

<p>� 引号<br />
 在 Shell 中引号分为三种:单引号、双引号、和倒引号。<br />
 � 双引号<br />
 由双引号括起来的字符,除$、倒引号和反斜线(\)仍保留其功能外,其余字符通常作<br />
 为普通字符对待。</p>

<p>练习 1.5<br />
 a.建立以下文件 ex8:<br />
 echo &ldquo;current directory is<code>pwd</code>&rdquo;<br />
 echo &ldquo;home directory is $ HOME&rdquo;<br />
 echo &ldquo;file&rdquo; * . ?<br />
 echo &ldquo; directory &lsquo; $ HOME &rsquo; &rdquo;<br />
 b.执行 ex8:<br />
$sh ex8</p>

<p>� 单引号<br />
 由单引号括起来的字符都作为普通字符出现。<br />
 � 倒引号</p>

<p>练习 1.6<br />
 1.6:<br />
 $ today=<code>date</code><br />
 $echo Today is $today<br />
 Today is Thu May 04 10 :56 :20 CST 2000<br />
 $<br />
 又:<br />
 $ users=<code>who | wc -l</code><br />
 $ echo The number of users is $ users<br />
 The number of users is 5</p>

<p>� 反斜线<br />
 转义字符,若想在字符串中使用反斜线本身,则必须采用(\\)的形式,其中第一个反<br />
 斜线作为转义字符,而把第二个反斜线变为普通字符。</p>
</blockquote>

<h5 id="3-条件判断与循环结构">(3) 条件判断与循环结构</h5>

<blockquote>
<p>� if 语句<br />
 练习 1.7<br />
 a.建立脚本 ex9:<br />
 echo &ldquo;The current directory is <code>pwd</code>&rdquo;<br />
 if test - f &ldquo; $1&rdquo;<br />
 then echo &ldquo; $1 is an ordinary file.&rdquo;<br />
 else echo &ldquo; $ 1 is not anordinary file.&rdquo;<br />
 fi<br />
 b.执行 ex9:<br />
 $sh ex9 ex1<br />
 The current directory is /usr/mengqc<br />
 ex1 is not anordinary file.<br />
 if 语句的 else 部分还可以是 else-if 结构。 (wj14)<br />
 if test -f &ldquo; $1&rdquo;<br />
 then cat $1<br />
 else if test -d $1&rdquo;<br />
 then ( cd $1 ;cat * )<br />
 else echo &ldquo;$1 is neither a file nor a directory.&rdquo;<br />
 fi<br />
 fi<br />
 如上例改写成为:<br />
 if test -f &ldquo; $1&rdquo;<br />
 then cat $1<br />
 elif test -d &ldquo; $1&rdquo;<br />
 then ( cd $1 ; cat * )<br />
 else echo &ldquo; $1 is neither afile nor adirectory.&rdquo;<br />
 fi</p>

<p>� 测试语句:</p>

<p>有两种常用形式:一种是用 test 命令,如上所示。另一种是用一对方括号将测试条件括</p>

<p>起来。两种形式完全等价。例如,测试位置参数$1 是否是已存在的普通文件,可写成:test<br />
 -f &ldquo; $1&rdquo;,也完全可写成:[ -f $ l ]<br />
 在格式上应注意,如果在 test 语句中使用 shell 变量,为表示完整、避免造成歧异起见<br />
 最好用双引号将变量括起来。利用一对方括号表示条件测试时,在左方括号[之后、右方括<br />
 号]之前各应有空格。<br />
 练习 1.8<br />
 a.建立脚本文件 ex10<br />
 echo &ldquo;Enter your filename&rdquo;<br />
 read filenane<br />
 if [ -f &ldquo;$filename&rdquo;]<br />
 then cat $filename<br />
 else if [ -d &ldquo;$filename&rdquo;]<br />
 then cd $filename<br />
 ls -l *<br />
 else echo &ldquo;$filename:bad filename&rdquo;<br />
 fi<br />
 fi<br />
 b.执行 ex10<br />
 $sh ex10</p>

<p>� while 语句<br />
 练习 1.9<br />
 a.建立脚本 ex11:<br />
 while [ $1 ]<br />
 do<br />
 if [ -f $1 ]<br />
 then echo &ldquo;display : $1&rdquo;<br />
 cat $1<br />
 else echo &ldquo; $1 is not a file name.&rdquo;<br />
 fi<br />
 shift<br />
 done<br />
 b.执行 ex11<br />
 练习 1.10<br />
 a.建立脚本 ex12:<br />
 echo&rdquo;ley in file-&gt;\c&rdquo;<br />
 read filename<br />
 echo&rdquo;key in data:&rdquo;<br />
 while [\n $x]<br />
 do<br />
 read x<br />
 echo $x&gt;&gt;$filename<br />
 done<br />
 cat $ filename<br />
 b.执行 ex12,并分析结果。</p>

<p>� for 语句<br />
 练习 1.11<br />
 for day in Monday Wednesday Friday Sunday<br />
 do<br />
 echo $ day<br />
 done<br />
 例如: (wj20)<br />
 for file in m*.c<br />
 do<br />
 cat $ file | more<br />
 done</p>

<p>练习 1.12<br />
 a.建立脚本 ex13:<br />
 # display files under a given directory<br />
 # $1-the nameof the diectory<br />
 # $2-the of files<br />
 dir=$1;shift<br />
 if [ - d $ dir ]<br />
 then<br />
 cd $dir<br />
 for name<br />
 do<br />
 if [ -f $name ]<br />
 then cat $name<br />
 echo &ldquo;End of $ {dir} / $name&rdquo;<br />
 else echo &ldquo;Invalid file name: $ {dir} / $name&rdquo;<br />
 fi<br />
 done<br />
 else echo &ldquo;Bad directory name : $dir&rdquo;<br />
 fi<br />
 $<br />
 b.执行 ex13,并分析运行结果。</p>
</blockquote>

<h5 id="4-函数的定义与调用">(4) 函数的定义与调用</h5>

<p>同其他高级语言一样,shell 也提供了函数功能。</p>

<blockquote>
<p>其定义格式如下:<br />
 funcname()<br />
 {<br />
 command<br />
 &hellip;<br />
 command;<br />
 }<br />
 #分号<br />
 定义函数之后,可以在 shell 中对此函数进行调用<br />
 如下所示:<br />
 iscontinue()<br />
 {<br />
 while true<br />
 do<br />
 echo -n &ldquo;Continue?(Y/N)&rdquo;<br />
 read ANSWER<br />
 case $ANSWER in<br />
 [Yy])<br />
 return 0;;<br />
 [Nn])<br />
 return 1;;<br />
 *) echo &ldquo;Answer Y or N&rdquo;;;<br />
 esac<br />
 done<br />
 }<br />
 这样可以在 shell 编程中调用 iscontinue 确定是否继续执行:<br />
 if iscontinue<br />
 then<br />
 continue<br />
 else<br />
 break<br />
 fi</p>
</blockquote>

<h3 id="2-综合实验一-清除-var-log-下的-log-文件">2.综合实验一:清除/var/log 下的 log 文件</h3>

<h4 id="练习-2-1-cleanlog-sh-版本-1">练习 2.1 cleanlog.sh 版本 1</h4>

<blockquote>
<p>在一个最简单的例子中,一个 shell 脚本其实就是将一堆系统命令列在一个文件中。好<br />
 处就是把所有命令都放在一个脚本中,不用每次都敲它们.这样的话,对于特定的应用来说,<br />
 这个脚本就很容易被修改或定制。<br />
 在这次练习中,我们编写一个最简单的脚本,其内容是用两条命令清除/var/log/message<br />
 和/var/log/wtmp 中的内容。<br />
 cd /var/log<br />
 cat /dev/null &gt; messages<br />
 cat /dev/null &gt; wtmp<br />
 echo &ldquo;Logs cleaned up.&rdquo;</p>
</blockquote>

<h4 id="练习-2-2-cleanlog-sh-版本-2">练习 2.2 cleanlog.sh 版本 2</h4>

<blockquote>
<p>下面按照 Shell 编程的一些规则进行改良:<br />
 在第一行添加一个 Bash 脚本的正确的开头部分,指定解释器为 bash。<br />
 使用变量指定/var/log 目录,在后面使用这个变量。<br />
 最后用 exit 退出。<br />
 使用注释说明各部分的用法。<br />
 #!/bin/bash<br />
 # 一个 Bash 脚本的正确的开头部分.<br />
 # Cleanup, 版本 2<br />
 # 当然要使用 root 身份来运行.<br />
 # 在此处插入代码,来打印错误消息,并且在不是 root 身份的时候退出.<br />
 LOG_DIR=/var/log<br />
 # 如果使用变量,当然比把代码写死的好.<br />
 cd $LOG_DIR<br />
 cat /dev/null &gt; messages<br />
 cat /dev/null &gt; wtmp<br />
 echo &ldquo;Logs cleaned up.&rdquo;<br />
 exit # 这个命令是一种正确并且合适的退出脚本的方法.</p>
</blockquote>

<h4 id="练习-2-3-cleanlog-sh-版本-3">练习 2.3 cleanlog.sh 版本 3</h4>

<blockquote>
<p>现在,让我们来编写有真正意义的脚本:<br />
 添加权限有关语句,判断执行脚本的是否根用户,如果不是则输出出错信息,退出。<br />
 添加语句,判断是否有命令行参数,如果有,假设是 n,在后面的清除 log 的时候保留<br />
 最后的 n 行;如果没有,设 n=50。<br />
 你可以不断地找到新的方法来完善这个脚本,并提高效率。<br />
 #!/bin/bash<br />
 ###############################################################<br />
 # 说明:删除 logfile 的脚本<br />
 ###############################################################<br />
 LOG_DIR=/var/log<br />
 ROOT_UID=0<br />
 # $UID 为 0 的用户才具有根用户的权限<br />
 LINES=50<br />
 # 默认的保存行数<br />
 E_XCD=66<br />
 # 不能修改目录,与下面的 E_NOTROOT 相似,用于本脚本退出返回<br />
 E_NOTROOT=67<br />
 # 非根用户<br />
 # 一定要使用根用户来运行<br />
 if [ &ldquo;$UID&rdquo; -ne &ldquo;$ROOT_UID&rdquo; ]<br />
 then<br />
 echo &ldquo;Must be root to run this script.&rdquo;<br />
 exit $E_NOTROOT</p>

<p>fi<br />
 if [ -n &ldquo;$1&rdquo; ] # 测试是否有命令行参数(非空).<br />
 then<br />
 lines=$1<br />
 else<br />
 lines=$LINES # 如果不在命令行中指定,使用默认<br />
 fi<br />
 #<br />
 #<br />
 #<br />
 #<br />
 #<br />
 #<br />
 #<br />
 #<br />
 #<br />
 #</p>

<p>可以使用下边的更好方法来检测命令行参数.<br />
 其使用了 case 结构<br />
 E_WRONGARGS=65<br />
 # Non-numerical argument (bad arg format)<br />
 case &ldquo;$1&rdquo; in<br />
 &ldquo;&rdquo;<br />
 ) lines=50;;<br />
 <em>[!0-9]</em>) echo &ldquo;Usage: <code>basename $0</code> file-to-cleanup&rdquo;; exit $E_WRONGARGS;;<br />
 *<br />
 ) lines=$1;;<br />
 esac<br />
 #<br />
 cd $LOG_DIR<br />
 if [ <code>pwd</code> != &ldquo;$LOG_DIR&rdquo; ]<br />
 # 也可以用<br />
 if [ &ldquo;$PWD&rdquo; != &ldquo;$LOG_DIR&rdquo; ]<br />
 # 查看是否在 /var/log 目录中<br />
 then<br />
 echo &ldquo;Can&rsquo;t change to $LOG_DIR.&rdquo;<br />
 exit $E_XCD<br />
 fi # 在处理 log file 之前,再确认一遍当前目录是否正确.<br />
 # 更有效率的做法是:<br />
 #<br />
 # cd /var/log || {<br />
 #<br />
 echo &ldquo;Cannot change to necessary directory.&rdquo; &gt;&amp;2<br />
 #<br />
 exit $E_XCD;<br />
 #}<br />
 tail -$lines messages &gt; mesg.temp # 保存 log file 消息的最后部分.<br />
 mv mesg.temp messages<br />
 # 变为新的 log 目录.<br />
 cat /dev/null &gt; wtmp<br />
 echo &ldquo;Logs cleaned up.&rdquo;<br />
 exit 0<br />
 # 退出之前返回 0,表示成功.</p>
</blockquote>

<h3 id="3-综合实验二-找出死链接文件">3.综合实验二:找出死链接文件</h3>

<p>执行流程:<br />
1.判断是否有命令行参数,如果没有,那么就使用当前目录,否则就使用传递进来的<br />
参数作为目录来搜索。<br />
2.建立函数 linkchk,用来检查传进来的目录或文件是否是链接和是否链接到不存在的<br />
路径,即死链接。<br />
如果是死链,打印出它们的路径。<br />
如果传进来的目录有子目录,<br />
那么把子目录也发送到 linkchk 函数中处理,也就是递归目<br />
录。<br />
3.对每个从脚本传递进来的参数,都调用 linkchk 函数去处理,如果有参数不是目录,<br />
那就打印出错误消息和使用信息。<br />
4.Exit 退出。<br />
#!/bin/bash</p>

<h1 id="broken-link-sh">broken-link.sh</h1>

<h1 id="written-by-lee-bigelow">Written by Lee bigelow</h1>

<h1 id="modified-and-commented-by-oyxin">Modified and commented by oyxin</h1>

<h1 id="used-with-permission">Used with permission.</h1>

<h1 id="说明-用来找出死链接文件并且输出它们的路径">说明:用来找出死链接文件并且输出它们的路径</h1>

<p>###############################################################</p>

<h1 id="如果没对这个脚本传递参数-那么就使用当前目录">如果没对这个脚本传递参数,那么就使用当前目录.</h1>

<h1 id="否则就使用传递进来的参数作为目录来搜索">否则就使用传递进来的参数作为目录来搜索.</h1>

<p>[ $# -eq 0 ] &amp;&amp; directorys=<code>pwd</code> || directorys=$@<br />
linkchk () {<br />
for element in $1/*; do<br />
[ -h &ldquo;$element&rdquo; -a ! -e &ldquo;$element&rdquo; ] &amp;&amp; echo \&ldquo;$element\&rdquo;<br />
[ -d &ldquo;$element&rdquo; ] &amp;&amp; linkchk $element</p>

<h1 id="h-是测试链接-d-是测试目录">&rsquo;-h&rsquo;是测试链接,&lsquo;-d&rsquo;是测试目录.</h1>

<p>done<br />
}<br />
for directory in $directorys; do<br />
if [ -d $directory ]<br />
then linkchk $directory<br />
else<br />
echo &ldquo;$directory is not a directory&rdquo;<br />
echo &ldquo;Usage: $0 dir1 dir2 &hellip;&rdquo;<br />
fi<br />
done<br />
exit 0</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>