<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linuxshell脚本编程基础篇二 | 开发者问答集锦</title>
    <meta property="og:title" content="Linuxshell脚本编程基础篇二 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linuxshell脚本编程基础篇二">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linuxshell脚本编程基础篇二</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>继 Linux shell 脚本编程-基础篇 （一）</p>

<p>2. 使用结构化命令</p>

<hr />

<p>许多程序要求对 shell 脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured
command）。结构化命令允许改变程序执行的顺序。</p>

<p>2.1 使用 if-then 语句<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
最基本的结构化命令就是 if-then 语句。if-then语句有如下格式：</p>

<p>if command<br />
then<br />
commands<br />
fi</p>

<p>在其他编程语言中，if 语句之后的对象是一个等式，这个等式的求值结果为 TRUE 或 FALSE。但 bash shell 的 if
语句并不是这么做的。bash shell 的<br />
if 语句会运行 if 后面的那个命令。如果该命令的退出状态码是 0 （该命令成功运行），位于 then 部分的命令就会被执行。如果该命令的退出状态码是<br />
其他值， then 部分的命令就不会被执行，bash shell 会继续执行脚本中的下一个命令。fi 语句用来表示 if-then 语句到此结束。</p>

<p>示例：<br />
[devalone@devalone 12]$ cat test1.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-if-statement">testing the if statement</h1>

<p>if pwd<br />
then<br />
echo &ldquo;It worked&rdquo;<br />
fi</p>

<p>这个脚本在 if 行采用了 pwd 命令。如果命令成功结束，echo 语句就会显示该文本字符串。</p>

<p>运行：<br />
[devalone@devalone 12]$ test1.sh<br />
/home/devalone/study/shell-script<br />
It worked<br />
[devalone@devalone 12]$</p>

<p>shell 执行了 if 行中的 pwd 命令。由于退出状态码是 0，它就又执行了 then 部分的 echo语句。</p>

<p>示例：<br />
[devalone@devalone 12]$ cat test2.sh<br />
#!/bin/bash</p>

<h1 id="testing-a-bad-command">testing a bad command</h1>

<p>if IamNotaCommand<br />
then<br />
echo &ldquo;It worked&rdquo;<br />
fi<br />
echo &ldquo;We are outside the if statement&rdquo;</p>

<p>运行：<br />
[devalone@devalone 12]$ test2.sh<br />
./test2.sh:行4: IamNotaCommand: 未找到命令<br />
We are outside the if statement</p>

<p>在这个例子中，if 语句行故意放了一个不能工作的命令。由于这是个错误的命令，所以它会产生一个非零的退出状态码，且 bash shell 会跳过 then
部分<br />
的 echo 语句。还要注意，运行if语句中的那个错误命令所生成的错误消息依然会显示在脚本的输出中。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
可能在有些脚本中看到过 if-then 语句的另一种形式：</p>

<p>if command; then<br />
commands<br />
fi</p>

<p>通过把分号放在待求值的命令尾部，就可以将 then 语句放在同一行上了，这样看起来更像其他编程语言中的 if-then 语句。</p>

<p>在 then 部分，可以使用不止一条命令。可以像在脚本中的其他地方一样在这里列出多条命令。bash shell 会将这些命令当成一个块，如果 if 语句行的<br />
命令的退出状态值为 0，所有的命令都会被执行；如果 if 语句行的命令的退出状态不为 0，所有的命令都会被跳过。</p>

<p>[devalone@devalone 12]$ cat test3.sh<br />
#!/bin/bash</p>

<h1 id="testing-multiple-commands-in-the-then-section">testing multiple commands in the then section</h1>

<p>Devalone=devalone</p>

<p>if grep $Devalone /etc/passwd; then<br />
echo &ldquo;This is my first command&rdquo;<br />
echo &ldquo;This is my second command&rdquo;<br />
echo &ldquo;I can even put in other commands besides echo:&rdquo;<br />
ls -al /home/$Devalone/.b*<br />
fi</p>

<p>if 语句行使用 grep 命令在 /etc/passwd
文件中查找某个用户名当前是否在系统上使用。如果有用户使用了那个登录名，脚本会显示一些文本信息并列出<br />
该用户 HOME 目录的 bash文件。</p>

<p>运行：<br />
[devalone@devalone 12]$ test3.sh<br />
devalone:x:1000:1000:MichaelY.:/home/devalone:/bin/bash<br />
This is my first command<br />
This is my second command<br />
I can even put in other commands besides echo:<br />
-rw&mdash;&mdash;-. 1 devalone devalone 16190 7月 4 20:31 /home/devalone/.bash_history<br />
-rw-r&ndash;r&ndash;. 1 devalone devalone 18 5月 17 2016 /home/devalone/.bash_logout<br />
-rw-r&ndash;r&ndash;. 1 devalone devalone 425 2月 26 15:24 /home/devalone/.bash_profile<br />
-rw-r&ndash;r&ndash;. 1 devalone devalone 301 12月 17 2017 /home/devalone/.bashrc</p>

<p>2.2 if-then-else 语句<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在 if-then 语句中，不管命令是否成功执行，都只有一种选择。如果命令返回一个非零退出状态码，bash shell 会继续执行脚本中的下一条命令。在这种<br />
情况下，如果能够执行另一组命令就好了。这正是 if-then-else 语句的作用。</p>

<p>if-then-else 语句在语句中提供了另外一组命令：</p>

<p>if command<br />
then<br />
commands<br />
else<br />
commands<br />
fi</p>

<p>当 if 语句中的命令返回退出状态码 0 时，then 部分中的命令会被执行，这跟普通的 if-then 语句一样。当 if
语句中的命令返回非零退出状态码时，<br />
bash shell 会执行 else 部分中的命令。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test4.sh<br />
#!/bin/bash</p>

<h1 id="testing-multiple-commands-in-the-then-section-1">testing multiple commands in the then section</h1>

<p>testuser=NoSuchUser</p>

<p>if grep $testuser /etc/passwd; then<br />
echo &ldquo;The bash files for user $testuser&rdquo;<br />
ls -al /home/$testuser/.b*<br />
echo<br />
else<br />
echo &ldquo;The user $testuser does not exist on this system&rdquo;<br />
echo<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test4.sh<br />
The user NoSuchUser does not exist on this system</p>

<p>跟 then 部分一样，else 部分可以包含多条命令。fi 语句说明 else 部分结束了。</p>

<p>2.3 嵌套 if<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
要检查脚本代码中的多种条件。对此，可以使用嵌套的 if-then 语句。</p>

<p>要检查 /etc/passwd 文件中是否存在某个用户名以及该用户的目录是否尚在，可以使用嵌套的 if-then 语句。嵌套的 if-then 语句位于主
if-then-else<br />
语句的 else 代码块中。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ ll -d /home/test<br />
drwx&mdash;&mdash;. 3 test test 4096 7月 4 16:05 /home/test</p>

<p>[devalone@devalone 12]$ cat test5.sh<br />
#!/bin/bash</p>

<h1 id="testing-nested-ifs">Testing nested ifs</h1>

<p>testuser=test</p>

<p>if grep $testuser /etc/passwd<br />
then<br />
echo &ldquo;The user $testuser exists on this system&rdquo;<br />
else<br />
echo &ldquo;The user $testuser does not exist on this system&rdquo;<br />
if ls -d /home/$testuser/<br />
then<br />
echo &ldquo;However, $testuser has a directory&rdquo;<br />
fi<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test5.sh<br />
The user test does not exist on this system<br />
/home/test/<br />
However, test has a directory</p>

<p>脚本准确地发现，尽管登录名已经从 /etc/passwd 中删除了，但是该用户的目录仍然存在。在脚本中使用这种嵌套 if-then
语句的问题在于代码不易阅读，<br />
很难理清逻辑流程。</p>

<p>可以使用 else 部分的另一种形式：elif。这样就不用再书写多个 if-then 语句了。elif 使用另一个 if-then 语句延续 else
部分。格式如下：</p>

<p>if command1<br />
then<br />
commands<br />
elif command2<br />
then<br />
more commands<br />
fi</p>

<p>elif 语句行提供了另一个要测试的命令，这类似于原始的 if 语句行。如果 elif 后命令的退出状态码是 0，则 bash 会执行第二个 then
语句部分的命令。<br />
使用这种嵌套方法，代码更清晰，逻辑更易懂。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test5-1.sh<br />
#!/bin/bash</p>

<h1 id="testing-nested-ifs-use-elif">Testing nested ifs - use elif</h1>

<p>testuser=test</p>

<p>if grep $testuser /etc/passwd<br />
then<br />
echo &ldquo;The user $testuser exists on this system&rdquo;<br />
elif ls -d /home/$testuser/<br />
then<br />
echo &ldquo;The user $testuser does not exist on this system&rdquo;<br />
echo &ldquo;However, $testuser has a directory&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test5-1.sh<br />
/home/test/<br />
The user test does not exist on this system<br />
However, test has a directory</p>

<p>可以更进一步，让脚本检查拥有目录的不存在用户以及没有拥有目录的不存在用户。这可以通过在嵌套 elif 中加入一个 else 语句来实现。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test5-2.sh<br />
#!/bin/bash</p>

<h1 id="testing-nested-ifs-use-elif-1">Testing nested ifs - use elif</h1>

<p>testuser=test</p>

<p>if grep $testuser /etc/passwd<br />
then<br />
echo &ldquo;The user $testuser exists on this system&rdquo;<br />
elif ls -d /home/$testuser/<br />
then<br />
echo &ldquo;The user $testuser does not exist on this system&rdquo;<br />
echo &ldquo;However, $testuser has a directory&rdquo;<br />
else<br />
echo &ldquo;The use $testuser does not exist on this system&rdquo;<br />
echo &ldquo;And, $testuser does not have a directory&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test5-2.sh<br />
/home/test/<br />
The user test does not exist on this system<br />
However, test has a directory</p>

<p>运行：<br />
[devalone@devalone 12]$ sudo rm -rf /home/test</p>

<p>[devalone@devalone 12]$ test5-2.sh<br />
ls: 无法访问&rsquo;/home/test/&rsquo;: No such file or directory<br />
The use test does not exist on this system<br />
And, test does not have a directory</p>

<p>在 /home/test 目录被删除之前，这个测试脚本执行的是 elif 语句，返回零值的退出状态。因此 elif 的 then
代码块中的语句得以执行。删除了<br />
/home/test 目录之后，elif 语句返回的是非零值的退出状态。这使得 elif 块中的 else 代码块得以执行。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
记住，在 elif 语句中，紧跟其后的 else 语句属于 elif 代码块。它们并不属于之前的 if-then 代码块。</p>

<p>可以继续将多个 elif 语句串起来，形成一个大的 if-then-elif 嵌套组合:</p>

<p>if command1<br />
then<br />
command set 1<br />
elif command2<br />
then<br />
command set 2<br />
elif command3<br />
then<br />
command set 3<br />
elif command4<br />
then<br />
command set 4<br />
fi</p>

<p>每块命令都会根据命令是否会返回退出状态码 0 来执行。bash shell 会依次执行 if语句，只有第一个返回退出状态码 0 的语句中的 then
部分会被执行。</p>

<p>2.4 test 命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
到目前为止，在 if 语句中看到的都是普通 shell命令。if-then 语句是否能测试命令退出状态码之外的条件。答案是不能。</p>

<p>但在 bash shell 中有个好用的工具可以帮通过 if-then 语句测试其他条件。</p>

<p>test 命令提供了在 if-then 语句中测试不同条件的途径。如果 test 命令中列出的条件成立，test 命令就会退出并返回退出状态码 0。这样
if-then 语句<br />
就与其他编程语言中的 if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-
then语句不会再被执行。</p>

<p>test命令的格式：</p>

<p>test condition</p>

<p>condition 是 test 命令要测试的一系列参数和值。当用在 if-then 语句中时，test 命令看起来是这样的。</p>

<p>if test condition<br />
then<br />
commands<br />
fi</p>

<p>如果不写 test 命令的 condition 部分，它会以非零的退出状态码退出，并执行 else 语句块。</p>

<p>示例：<br />
[devalone@devalone 12]$ cat test6.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-test-command">Testing the test command</h1>

<p>if test<br />
then<br />
echo &ldquo;No expression returns a True&rdquo;<br />
else<br />
echo &ldquo;No expression resturn a False&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test6.sh<br />
No expression resturn a False</p>

<p>当加入一个条件时，test 命令会测试该条件。例如，可以使用 test 命令确定变量中是否有内容。这只需要一个简单的条件表达式。</p>

<p>[devalone@devalone 12]$ cat test6-1.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-test-command-1">Testing the test command</h1>

<p>my_variable=&ldquo;Full&rdquo;</p>

<p>if test $my_variable<br />
then<br />
echo &ldquo;The $my_variable expression returns a True&rdquo;<br />
else<br />
echo &ldquo;The $my_variable expression resturn a False&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test6-1.sh<br />
The Full expression returns a True</p>

<p>变量 my_variable 中包含有内容（Full），因此当 test 命令测试条件时，返回的退出状态为 0。这使得 then 语句块中的语句得以执行。</p>

<p>如果该变量中没有包含内容，就会出现相反的情况：</p>

<p>[devalone@devalone 12]$ cat test6-2.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-test-command-2">Testing the test command</h1>

<p>my_variable=&ldquo;&rdquo;</p>

<p>if test $my_variable<br />
then<br />
echo &ldquo;The $my_variable expression returns a True&rdquo;<br />
else<br />
echo &ldquo;The $my_variable expression resturn a False&rdquo;<br />
fi<br />
[devalone@devalone 12]$ cat test6-2.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-test-command-3">Testing the test command</h1>

<p>my_variable=&ldquo;&rdquo;</p>

<p>if test $my_variable<br />
then<br />
echo &ldquo;The $my_variable expression returns a True&rdquo;<br />
else<br />
echo &ldquo;The $my_variable expression resturn a False&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test6-2.sh<br />
The expression resturn a False</p>

<p>bash shell提供了另一种条件测试方法，无需在 if-then 语句中声明 test 命令：</p>

<p>if [ condition ]<br />
then<br />
commands<br />
fi</p>

<p>方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则会报错。</p>

<p>test 命令可以判断三类条件：</p>

<p>□ 数值比较<br />
□ 字符串比较<br />
□ 文件比较</p>

<p>2.4.1 数值比较<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
使用 test 命令最常见的情形是对两个数值进行比较。下表列出了测试两个值时可用的条件参数。</p>

<p>test 命令的数值比较功能<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| 比 较 | 描 述<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| n1 -eq n2 | 检查n1是否与n2相等<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| n1 -ge n2 | 检查n1是否大于或等于n2<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| n1 -gt n2 | 检查n1是否大于n2<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| n1 -le n2 | 检查n1是否小于或等于n2<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| n1 -lt n2 | 检查n1是否小于n2<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| n1 -ne n2 | 检查n1是否不等于n2<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>数值条件测试可以用在数字和变量上：</p>

<p>[devalone@devalone 12]$ cat numeric_test.sh<br />
#!/bin/bash</p>

<h1 id="using-numeric-test-evaluations">Using numeric test evaluations</h1>

<p>value1=10<br />
value2=11</p>

<p>if [ $value1 -gt 5 ]<br />
then<br />
echo &ldquo;The test value $value1 is greater than 5&rdquo;<br />
fi</p>

<p>if [ $value1 -eq $value2 ]<br />
then<br />
echo &ldquo;The values are equal&rdquo;<br />
else<br />
echo &ldquo;The values are different&rdquo;<br />
fi<br />
#</p>

<p>运行：<br />
[devalone@devalone 12]$ numeric_test.sh<br />
The test value 10 is greater than 5<br />
The values are different</p>

<p>但是涉及浮点值时，数值条件测试会有一个限制。</p>

<p>[devalone@devalone 12]$ cat floating_poing_test.sh<br />
#!/bin/bash</p>

<h1 id="using-floating-point-numbers-in-test-evaluations">Using floating point numbers in test evaluations</h1>

<p>value1=5.555</p>

<p>echo &ldquo;The test value is $value1&rdquo;</p>

<p>if [ $value1 -gt 5 ]<br />
then<br />
echo &ldquo;The test value $value1 is greater than 5&rdquo;<br />
fi<br />
#</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ floating_poing_test.sh<br />
The test value is 5.555<br />
./floating_poing_test.sh: 第 8 行:[: 5.555: 需要整数表达式</p>

<p>变量 value1 中存储的是浮点值。接着，脚本对这个值进行了测试。显然这里出错了。</p>

<p>记住，bash shell 只能处理整数。如果只是要通过 echo 语句来显示这个结果，那没问题。但在基于数字的函数中就不行了，例如数值测试条件。最后<br />
一行就说明不能在 test 命令中使用浮点值。</p>

<p>2.4.2 字符串比较<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
条件测试还允许比较字符串值。下表列出可用的字符串比较功能。</p>

<p>字符串比较测试<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| 比 较 | 描 述<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| str1 = str2 | 检查str1是否和str2相同<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| str1 != str2 | 检查str1是否和str2不同<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| str1 &lt; str2 | 检查str1是否比str2小<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| str1 &gt; str2 | 检查str1是否比str2大<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -n str1 | 检查str1的长度是否非0<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -z str1 | 检查str1的长度是否为0<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>● 字符串相等性<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
很容易看出两个字符串值是否相同：</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test7.sh<br />
#!/bin/bash</p>

<h1 id="testing-string-equality">Testing string equality</h1>

<p>testuser=devalone</p>

<p>if [ $USER = $testuser ]<br />
then<br />
echo &ldquo;Welcome $testuser&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test7.sh<br />
Welcome devalone</p>

<p>字符串不等条件也可以判断两个字符串是否有相同的值。</p>

<p>示例：<br />
[devalone@devalone 12]$ cat test8.sh<br />
#!/bin/bash</p>

<h1 id="testing-string-equality-1">Testing string equality</h1>

<p>testuser=baduser</p>

<p>if [ $USER != $testuser ]<br />
then<br />
echo &ldquo;This is not $testuser&rdquo;<br />
else<br />
echo &ldquo;Welcome $testuser&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test8.sh<br />
This is not baduser</p>

<p>在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内。</p>

<p>● 字符串顺序<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
要测试一个字符串是否比另一个字符串大就是麻烦的开始。当要开始使用测试条件的大于或小于功能时，就会出现两个经常困扰 shell 程序员的问题：</p>

<p>□ 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名；<br />
□ 大于和小于顺序和 sort 命令所采用的不同</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat badtest.sh<br />
#!/bin/bash</p>

<h1 id="mis-using-string-comparisons">mis-using string comparisons</h1>

<p>val1=baseball<br />
val2=hockey</p>

<p>if [ $val1 &gt; $val2 ]<br />
then<br />
echo &ldquo;$val1 is greater than $val2&rdquo;<br />
else<br />
echo &ldquo;$val1 is less than $val2&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ badtest.sh<br />
baseball is greater than hockey</p>

<p>[devalone@devalone 12]$ ll hockey<br />
-rw-rw-r&ndash;. 1 devalone devalone 0 7月 5 17:17 hockey</p>

<p>这个脚本中只用了大于号，没有出现错误，但结果是错的。脚本把大于号解释成了输出重定向。因此，它创建了一个名为 hockey 的文件。由于重定向的<br />
顺利完成，test 命令返回了退出状态码 0，if 语句便以为所有命令都成功结束了。</p>

<p>要解决这个问题，就需要正确转义大于号：</p>

<p>[devalone@devalone 12]$ cat test9.sh<br />
#!/bin/bash</p>

<h1 id="mis-using-string-comparisons-1">mis-using string comparisons</h1>

<p>value1=baseball<br />
value2=hockey</p>

<p>if [ $value1 &gt; $value2 ]<br />
then<br />
echo &ldquo;$value1 is greater than $value2&rdquo;<br />
else<br />
echo &ldquo;$value1 is less than $value2&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test9.sh<br />
baseball is less than hockey</p>

<p>第二个问题更细微，除非经常处理大小写字母，否则几乎遇不到。sort 命令处理大写字母的方法刚好跟 test 命令相反：</p>

<p>[devalone@devalone 12]$ cat test9b.sh<br />
#!/bin/bash</p>

<h1 id="testing-string-sort-order">testing string sort order</h1>

<p>value1=Testing<br />
value2=testing</p>

<p>if [ $value1 &gt; $value2 ]<br />
then<br />
echo &ldquo;$value1 is greater than $value2&rdquo;<br />
else<br />
echo &ldquo;$value1 is less than $value2&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test9b.sh<br />
Testing is less than testing</p>

<p>[devalone@devalone 12]$ sort testfile<br />
testing<br />
Testing</p>

<p>在比较测试中，大写字母被认为是小于小写字母的。但 sort 命令恰好相反。当将同样的字符串放进文件中并用 sort 命令排序时，小写字母会先出现。这<br />
是由各个命令使用的排序技术不同造成的。</p>

<p>比较测试中使用的是标准的 ASCII 顺序，根据每个字符的 ASCII 数值来决定排序结果。sort 命令使用的是系统的本地化语言设置中定义的排序顺序。对于<br />
英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
test 命令和测试表达式使用标准的数学比较符号来表示字符串比较，而用文本代码来表示数值比较。这个细微的特性被很多程序员理解反了。如果对<br />
数值使用了数学运算符号，shell 会将它们当成字符串值，可能无法得到正确的结果。</p>

<p>● 字符串大小<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-n 和 -z 可以检查一个变量是否含有数据。</p>

<p>[devalone@devalone 12]$ cat test10.sh<br />
#!/bin/bash</p>

<h1 id="testing-string-length">testing string length</h1>

<p>val1=testing<br />
val2=&rdquo;</p>

<p>if [ -n val1 ]<br />
then<br />
echo &ldquo;The string &lsquo;$val1&rsquo; is not empty&rdquo;<br />
else<br />
echo &ldquo;The string &lsquo;$val1&rsquo; is empty&rdquo;<br />
fi</p>

<p>if [ -z $val2 ]<br />
then<br />
echo &ldquo;The string &lsquo;$val2&rsquo; is empty&rdquo;<br />
else<br />
echo &ldquo;The string &lsquo;$val2&rsquo; is not empty&rdquo;<br />
fi</p>

<p>if [ -z $val3 ]<br />
then<br />
echo &ldquo;The string &lsquo;$val3&rsquo; is empty&rdquo;<br />
else<br />
echo &ldquo;The string &lsquo;$val3&rsquo; is not empty&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test10.sh<br />
The string &lsquo;testing&rsquo; is not empty<br />
The string &ldquo; is empty<br />
The string &ldquo; is empty</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
空的和未初始化的变量会对 shell 脚本测试造成灾难性的影响。如果不是很确定一个变量的内容，最好在将其用于数值或字符串比较之前先通过 -n 或<br />
-z 来测试一下变量是否含有值。</p>

<p>2.4.3 文件比较<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
文件比较很有可能是 shell 编程中最为强大、也是用得最多的比较形式。它允许测试 Linux 文件系统上文件和目录的状态。</p>

<p>test 命令的文件比较功能<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 比 较 | 描 述<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -d file | 检查file是否存在并是一个目录<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -e file | 检查file是否存在<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -f file | 检查file是否存在并是一个文件<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -h file | 检查 file exists and is a symbolic link (same as -L)<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -r file | 检查file是否存在并可读<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -s file | 检查file是否存在并非空<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -w file | 检查file是否存在并可写<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -x file | 检查file是否存在并可执行<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -O file | 检查file是否存在并属当前用户所有<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -G file | 检查file是否存在并且默认组与当前用户相同<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| file1 -nt file2 | 检查file1是否比file2新<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| file1 -ot file2 | 检查file1是否比file2旧<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>这些测试条件使能够在 shell 脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中。</p>

<p>Except for -h and -L, all FILE-related tests dereference symbolic links.
Beware that parentheses need to be escaped (e.g., by<br />
backslashes) for shells. INTEGER may also be -l STRING, which evaluates to the
length of STRING.</p>

<p>● 检查目录<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-d 测试会检查指定的目录是否存在于系统中。如果打算将文件写入目录或是准备切换到某个目录中，先进行测试总是件好事情。</p>

<p>示例：<br />
[devalone@devalone 12]$ cat test11.sh<br />
#!/bin/bash</p>

<h1 id="look-before-you-leap">Look before you leap</h1>

<p>jump_directory=/home/arthur</p>

<p>if [ -d $jump_directory ]<br />
then<br />
echo &ldquo;The $jump_directory directory exists&rdquo;<br />
cd $jump_directort<br />
ls<br />
else<br />
echo &ldquo;The $jump_directory directory does not exist&rdquo;<br />
fi<br />
#</p>

<p>运行：<br />
[devalone@devalone 12]$ test11.sh<br />
The /home/arthur directory does not exist</p>

<p>示例代码中使用了 -d 测试条件来检查 jump_directory 变量中的目录是否存在：若存在，就使用 cd
命令切换到该目录并列出目录中的内容；若不存在，<br />
脚本就输出一条警告信息，然后退出。</p>

<p>● 检查对象是否存在<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-e 比较允许脚本代码在使用文件或目录前先检查它们是否存在。</p>

<p>[devalone@devalone 12]$ cat test12.sh<br />
#!/bin/bash</p>

<h1 id="check-if-eithera-directory-or-file-exist">Check if eithera directory or file exist</h1>

<p>location=$HOME<br />
file_name=&ldquo;sentinel&rdquo;</p>

<p>if [ -e $location ]<br />
then #Diretory does exist<br />
echo &ldquo;OK on the $location diretory&rdquo;<br />
echo &ldquo;Now checking on the file, $file_name&rdquo;</p>

<p>if [ -e $location/$file_name ]<br />
then #File does exist<br />
echo &ldquo;OK on the filename&rdquo;<br />
echo &ldquo;Updating current date&hellip;&rdquo;<br />
date &gt;&gt; $location/$file_name</p>

<p>else #File does not exist<br />
echo &ldquo;File does not exist&rdquo;<br />
echo &ldquo;Noting to update&rdquo;<br />
fi<br />
else #Directory does not exist<br />
echo &ldquo;The $location directory does not exist&rdquo;<br />
echo &ldquo;Nothing to update&rdquo;<br />
fi<br />
#</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test12.sh<br />
OK on the /home/devalone diretory<br />
Now checking on the file, sentinel<br />
File does not exist<br />
Noting to update</p>

<p>[devalone@devalone 12]$ touch ~/sentinel<br />
[devalone@devalone 12]$ test12.sh<br />
OK on the /home/devalone diretory<br />
Now checking on the file, sentinel<br />
OK on the filename<br />
Updating current date&hellip;<br />
[devalone@devalone 12]$</p>

<p>第一次检查用 -e 比较来判断用户是否有 $HOME 目录。如果有，接下来的 -e 比较会检查 sentinel 文件是否存在于 $HOME
目录中。如果不存在，shell<br />
脚本就会提示该文件不存在，不需要进行更新。</p>

<p>为确保更新操作能够正常进行，我们创建了 sentinel 文件，然后重新运行这个 shell 脚本。这一次在进行条件测试时，$HOME 和 sentinel
文件都存在，<br />
因此当前日期和时间就被追加到了文件中。</p>

<p>● 检查文件<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-e 比较可用于文件和目录。要确定指定对象为文件，必须用 -f 比较。</p>

<p>[devalone@devalone 12]$ cat test13.sh<br />
#!/bin/bash</p>

<h1 id="check-if-either-a-directory-or-file-exist">check if either a directory or file exist</h1>

<p>item_name=$HOME<br />
echo<br />
echo &ldquo;The item being checked: $item_name&rdquo;<br />
echo</p>

<p>if [ -e $item_name ]<br />
then #item does exist<br />
echo &ldquo;The item, $item_name, does exist&rdquo;<br />
echo &ldquo;But is it a file ?&rdquo;<br />
echo</p>

<p>if [ -f $item_name ]<br />
then #item is a file<br />
echo &ldquo;Yes, $item_name is a file&rdquo;</p>

<p>else #item is not a file<br />
echo &ldquo;No, $item_name is not a file&rdquo;<br />
fi</p>

<p>else #item does not exist<br />
echo &ldquo;The item, $item_name, does not exist&rdquo;<br />
echo &ldquo;Nothing to update&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test13.sh</p>

<p>The item being checked: /home/devalone</p>

<p>The item, /home/devalone, does exist<br />
But is it a file ?</p>

<p>No, /home/devalone is not a file</p>

<p>这一小段脚本进行了大量的检查！它首先使用 -e 比较测试$HOME是否存在。如果存在，继续用 -f 来测试它是不是一个文件。如果它不是文件（当然不会<br />
是了），就会显示一条消息，表明这不是一个文件。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test13b.sh<br />
#!/bin/bash</p>

<h1 id="check-if-either-a-directory-or-file-exist-1">check if either a directory or file exist</h1>

<p>item_name=$HOME/sentinel<br />
echo<br />
echo &ldquo;The item being checked: $item_name&rdquo;<br />
echo</p>

<p>if [ -e $item_name ]<br />
then #item does exist<br />
echo &ldquo;The item, $item_name, does exist&rdquo;<br />
echo &ldquo;But is it a file ?&rdquo;<br />
echo</p>

<p>if [ -f $item_name ]<br />
then #item is a file<br />
echo &ldquo;Yes, $item_name is a file&rdquo;</p>

<p>else #item is not a file<br />
echo &ldquo;No, $item_name is not a file&rdquo;<br />
fi</p>

<p>else #item does not exist<br />
echo &ldquo;The item, $item_name, does not exist&rdquo;<br />
echo &ldquo;Nothing to update&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test13b.sh</p>

<p>The item being checked: /home/devalone/sentinel</p>

<p>The item, /home/devalone/sentinel, does exist<br />
But is it a file ?</p>

<p>Yes, /home/devalone/sentinel is a file</p>

<p>当运行这个脚本时，对 $HOME/sentinel 进行的 -f 测试所返回的退出状态码为 0，then 语句得以执行，然后输出消息。</p>

<p>● 检查文件是否可读<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在尝试从文件中读取数据之前，最好先测试一下文件是否可读。可以使用 -r 比较测试：</p>

<p>[devalone@devalone 12]$ cat test14.sh<br />
#!/bin/bash</p>

<h1 id="test-if-you-can-read-a-file">test if you can read a file</h1>

<p>pwfile=/etc/shadow</p>

<p>#firt, test if the file exist, and is a file<br />
if [ -f $pwfile ]<br />
then</p>

<h1 id="now-test-if-you-can-read-it">now test if you can read it</h1>

<p>if [ -r $pwfile ]<br />
then<br />
tail $pwfile<br />
else<br />
echo &ldquo;Sorry, I am unable to read the $pwfile&rdquo;<br />
fi<br />
else<br />
echo &ldquo;Sorry, the file $pwfile does not exist&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test14.sh<br />
Sorry, I am unable to read the /etc/shadow</p>

<p>/etc/shadow 文件含有系统用户加密后的密码，所以它对系统上的普通用户来说是不可读的。-r 比较确定该文件不允许进行读取，因此测试失败，<br />
bash shell执行了 if-then 语句的 else 部分。</p>

<p>● 检查空文件<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
应该用 -s 比较来检查文件是否为空，尤其是在不想删除非空文件的时候。要留心的是，当 -s 比较成功时，说明文件中有数据。</p>

<p>[devalone@devalone 12]$ cat test15.sh<br />
#!/bin/bash</p>

<h1 id="testing-if-a-file-is-empty">testing if a file is empty</h1>

<p>filename=$HOME/sentinel</p>

<p>if [ -f $filename ]<br />
then<br />
if [ -s $filename ]<br />
then<br />
echo &ldquo;The $filename file exists and has data in it.&rdquo;<br />
echo &ldquo;will not remove this file&rdquo;<br />
else<br />
echo &ldquo;The $filename file exists, but is empty&rdquo;<br />
echo &ldquo;Deleting empty file&hellip;&rdquo;<br />
fi<br />
else<br />
echo &ldquo;File, $filename, does not exist&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ ls -l ~/sentinel<br />
-rw-rw-r&ndash;. 1 devalone devalone 43 7月 5 18:36 /home/devalone/sentinel</p>

<p>[devalone@devalone 12]$ test15.sh<br />
The /home/devalone/sentinel file exists and has data in it.<br />
will not remove this file</p>

<p>● 检查文件是否可写<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-w 比较会判断对文件是否有可写权限：</p>

<p>[devalone@devalone 12]$ cat test16.sh<br />
#!/bin/bash</p>

<h1 id="check-if-either-a-file-writable">check if either a file writable</h1>

<p>item_name=$HOME/sentinel<br />
echo<br />
echo &ldquo;The item being checked: $item_name&rdquo;<br />
echo</p>

<p>if [ -e $item_name ]<br />
then #item does exist<br />
echo &ldquo;The item, $item_name, does exist&rdquo;<br />
echo &ldquo;But is it a file ?&rdquo;<br />
echo</p>

<p>if [ -f $item_name ]<br />
then #item is a file<br />
echo &ldquo;Yes, $item_name is a file&rdquo;<br />
echo &ldquo;But is it writable?&rdquo;</p>

<p>if [ -w $item_name ]<br />
then<br />
echo &ldquo;writing current time to $item_name&rdquo;<br />
date +%H%M &gt;&gt; $item_name<br />
else<br />
echo &ldquo;Unable to write to $item_name&rdquo;<br />
fi</p>

<p>else #item is not a file<br />
echo &ldquo;No, $item_name is not a file&rdquo;<br />
fi</p>

<p>else #item does not exist<br />
echo &ldquo;The item, $item_name, does not exist&rdquo;<br />
echo &ldquo;Nothing to update&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test16.sh</p>

<p>The item being checked: /home/devalone/sentinel</p>

<p>The item, /home/devalone/sentinel, does exist<br />
But is it a file ?</p>

<p>Yes, /home/devalone/sentinel is a file<br />
But is it writable?<br />
writing current time to /home/devalone/sentinel</p>

<p>[devalone@devalone 12]$ cat /home/devalone/sentinel<br />
2018年 07月 05日 星期四 18:36:25 CST<br />
1845</p>

<p>变量 item_name 被设置成 $HOME/sentinel，该文件允许用户进行写入。因此当脚本运行时，-w 测试表达式会返回退出状态码 0，然后执行
then 代码块，<br />
将时间戳写入文件 sentinel 中。</p>

<p>如果使用 chmod 关闭文件 sentinel 的用户 写入权限，-w 测试表达式会返回非零的退出状态码，时间戳不会被写入文件：</p>

<p>[devalone@devalone 12]$ chmod u-w ~/sentinel<br />
[devalone@devalone 12]$ test16.sh</p>

<p>The item being checked: /home/devalone/sentinel</p>

<p>The item, /home/devalone/sentinel, does exist<br />
But is it a file ?</p>

<p>Yes, /home/devalone/sentinel is a file<br />
But is it writable?<br />
Unable to write to /home/devalone/sentinel</p>

<p>● 检查文件是否可以执行<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-x 比较是判断特定文件是否有执行权限。</p>

<p>[devalone@devalone 12]$ cat test17.sh<br />
#!/bin/bash</p>

<h1 id="testing-file-execution">testing file execution</h1>

<p>if [ -x test16.sh ]<br />
then<br />
echo &ldquo;you can run the script:&rdquo;<br />
./test16.sh<br />
else<br />
echo &ldquo;Sorry, you are unable to execute the script&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test17.sh<br />
you can run the script:</p>

<p>The item being checked: /home/devalone/sentinel</p>

<p>The item, /home/devalone/sentinel, does exist<br />
But is it a file ?</p>

<p>Yes, /home/devalone/sentinel is a file<br />
But is it writable?<br />
Unable to write to /home/devalone/sentinel</p>

<p>[devalone@devalone 12]$ chmod u-x test16.sh<br />
[devalone@devalone 12]$ test17.sh<br />
Sorry, you are unable to execute the script</p>

<p>这段示例 shell 脚本用 -x 比较来测试是否有权限执行 test16.sh 脚本。如果有权限，它会运行这个脚本。在首次成功运行 test16.sh
脚本后，更改文件<br />
的权限。这次，-x 比较失败了，因为已经没有 test16.sh 脚本的执行权限了。</p>

<p>● 检查所属关系<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-O 比较可以测试出当前用户是否是文件的属主：</p>

<p>[devalone@devalone 12]$ cat test18.sh<br />
#/bin/bash</p>

<h1 id="check-file-ownership">check file ownership</h1>

<p>if [ -O /etc/passwd ]<br />
then<br />
echo &ldquo;You are the owner of /etc/passwd file&rdquo;<br />
else<br />
echo &ldquo;You are not the owner of /etc/passwd file&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test18.sh<br />
You are not the owner of /etc/passwd file</p>

<p>● 检查默认属组关系<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
-G 比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功。-G 比较只会检查默认组而非用户所属的所有组。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test19.sh<br />
#!/bin/bash</p>

<h1 id="check-file-group-test">check file group test</h1>

<p>if [ -G $HOME/testing ]<br />
then<br />
echo &ldquo;You are in the same group as the file&rdquo;<br />
else<br />
echo &ldquo;The file is not owned by your group&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ touch ~/testing<br />
[devalone@devalone 12]$ ll ~/testing<br />
-rw-rw-r&ndash;. 1 devalone devalone 0 7月 5 19:33 /home/devalone/testing</p>

<p>[devalone@devalone 12]$ test19.sh<br />
You are in the same group as the file</p>

<p>[devalone@devalone 12]$ sudo chgrp sharing ~/testing<br />
[devalone@devalone 12]$ ll ~/testing<br />
-rw-rw-r&ndash;. 1 devalone sharing 0 7月 5 19:33 /home/devalone/testing<br />
[devalone@devalone 12]$ test19.sh<br />
The file is not owned by your group</p>

<p>● 检查文件日期<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
最后一组方法用来对两个文件的创建日期进行比较。这在编写软件安装脚本时非常有用。人们不会愿意安装一个比系统上已有文件还要旧的文件。</p>

<p>-nt 比较会判定一个文件是否比另一个文件新。如果文件较新，那意味着它的文件创建日期更近。<br />
-ot 比较会判定一个文件是否比另一个文件旧。如果文件较旧，意味着它的创建日期更早。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test20.sh<br />
#!/bin/bash</p>

<h1 id="testing-file-dates">testing file dates</h1>

<p>if [ test19.sh -nt test18.sh ]<br />
then<br />
echo &ldquo;The test19.sh file is newer than test18.sh&rdquo;<br />
else<br />
echo &ldquo;The test18.sh file is newer than test19.sh&rdquo;<br />
fi</p>

<p>if [ test17.sh -ot test19.sh ]<br />
then<br />
echo &ldquo;The test17.sh file is older than test19.sh file&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test20.sh<br />
The test19.sh file is newer than test18.sh<br />
The test17.sh file is older than test19.sh file</p>

<p>用于比较文件路径是相对于运行该脚本的目录而言的。如果要检查的文件已经移走，就会出现问题。另一个问题是，这些比较都不会先检查文件是否存在。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test21.sh<br />
#!/bin/bash</p>

<h1 id="testing-file-dates-1">testing file dates</h1>

<p>if [ badfile1 -nt badfile2 ]<br />
then<br />
echo &ldquo;The badfile1 file is newer than badfile2&rdquo;<br />
else<br />
echo &ldquo;The badfile2 file is newer than badfile1&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test21.sh<br />
The badfile2 file is newer than badfile1</p>

<p>例子演示了如果文件不存在，-nt 比较会返回一个错误的结果。在尝试使用 -nt 或 -ot 比较文件之前，必须先确认文件是存在的。</p>

<p>2.4.4 test 复合条件功能<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>test 命令的复合条件功能<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 比 较 | 描 述<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -a | (and) 两个条件同时成立，返回 true。例如 test -r file -a -x file，则<br />
| | file 同时具有 r 不 x 权限时，才返回 true。<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -o | (or) 两个条件有一个成立，即返回 true。例如 test -r file -o -x file，<br />
| | 则 file 具有 r 或 x 权限时，就返回 true。<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| ! | 取反测试，如 test !-x file, 当 file 不具有 x 权限时，返回 true<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>2.5 复合条件测试<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
if-then 语句允许使用布尔逻辑来组合测试。有两种布尔运算符可用：</p>

<p>□ [ condition1 ] &amp;&amp; [ condition2 ] ：等同于 -a<br />
□ [ condition1 ] || [ condition2 ] : 等同于 -o</p>

<p>第一种布尔运算使用 AND 布尔运算符来组合两个条件。要让 then 部分的命令执行，两个条件都必须满足。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
布尔逻辑是一种能够将可能的返回值简化为 TRUE 或 FALSE 的方法。</p>

<p>第二种布尔运算使用 OR 布尔运算符来组合两个条件。如果任意条件为 TRUE，then 部分的命令就会执行。</p>

<p>下例展示了AND布尔运算符的使用：</p>

<p>[devalone@devalone 12]$ cat test22.sh<br />
#!/bin/bash</p>

<h1 id="testing-compound-comparisions">testing compound comparisions</h1>

<p>if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ]<br />
then<br />
echo &ldquo;The file exists and you can write to it&rdquo;<br />
else<br />
echo &ldquo;I cannot write to the file&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test22.sh<br />
The file exists and you can write to it</p>

<p>[devalone@devalone 12]$ rm ~/testing<br />
[devalone@devalone 12]$ test22.sh<br />
I cannot write to the file</p>

<p>2.6 if-then 的高级特性<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
bash shell 提供了两项可在 if-then 语句中使用的高级特性：</p>

<p>□ 用于数学表达式的双括号<br />
□ 用于高级字符串处理功能的双方括号</p>

<p>2.6.1 使用双括号 (())<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
双括号命令允许在比较过程中使用高级数学表达式。test 命令只能在比较中使用简单的算术操作。双括号命令提供了更多的数学符号，这些符号对于用过<br />
其他编程语言的程序员而言并不陌生。双括号命令的格式如下：</p>

<p>(( expression ))</p>

<p>expression 可以是任意的数学赋值或比较表达式。除了 test 命令使用的标准数学运算符，下表列出了双括号命令中会用到的其他运算符。</p>

<p>双括号命令符号<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| 符 号 | 描 述<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| val++ | 后增<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| val&ndash; | 后减<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| ++val | 先增<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| &ndash;val | 先减<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| ! | 逻辑求反<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| ~ | 位求反<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| ** | 幂运算<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| &lt; +&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| &gt;&gt; | 右位移<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| &amp; | 位布尔和<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| | | 位布尔或<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| &amp;&amp; | 逻辑和<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| || | 逻辑或<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>可以在 if 语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值。</p>

<p>示例：<br />
[devalone@devalone 12]$ cat test23.sh<br />
#!/bin/bash</p>

<h1 id="using-double-parenthesis">using double parenthesis</h1>

<p>val1=10</p>

<p>if (( $val1 ** 2 &gt; 90 ))<br />
then<br />
(( val2=$val1 ** 2 ))<br />
echo &ldquo;The square of $val1 is $val2&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test23.sh<br />
The square of 10 is 100</p>

<p>2.6.2 使用双括号 [[]]<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：</p>

<p>[[ expression ]]</p>

<p>双方括号里的 expression 使用了 test 命令中采用的标准字符串比较。但它提供了 test 命令未提供的另一个特性——模式匹配（pattern
matching）。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
双方括号在 bash shell中工作良好。不过要小心，不是所有的 shell 都支持双方括号。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test24.sh<br />
#!/bin/bash</p>

<h1 id="using-pattern-matching">using pattern matching</h1>

<p>if [[ $USER == d* ]]<br />
then<br />
echo &ldquo;Hello $USER&rdquo;<br />
else<br />
echo &ldquo;Sorry, I do not know you&rdquo;<br />
fi</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test24.sh<br />
Hello devalone</p>

<p>在上面的脚本中，使用了双等号（==）。双等号将右边的字符串（d*）视为一个模式，并应用模式匹配规则。双方括号命令让 $USER 环境变量与模式进行<br />
匹配，看它是否以字母 d 开头。如果是的话，比较通过，shell 会执行 then 部分的命令。</p>

<p>2.7 case 命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
经常发现自己在尝试计算一个变量的值，在一组可能的值中寻找特定值。在这种情形下，不得不写出很长的 if-then-else 语句，就像下面这样:</p>

<p>[devalone@devalone 12]$ cat test25.sh<br />
#!/bin/bash</p>

<h1 id="looking-for-a-possible-value">looking for a possible value</h1>

<p>if [ $USER = &ldquo;devalone&rdquo; ]<br />
then<br />
echo &ldquo;Welcome $USER&rdquo;<br />
echo &ldquo;Please enjoy your visit&rdquo;<br />
elif [ $USER = &ldquo;barbara&rdquo; ]<br />
then<br />
echo &ldquo;Welcome $USER&rdquo;<br />
echo &ldquo;Please enjoy you visit&rdquo;<br />
elif [ $USER = &ldquo;testing&rdquo; ]<br />
then<br />
echo &ldquo;Special testing account&rdquo;<br />
elif [ $USER = &ldquo;jessica&rdquo; ]<br />
then<br />
echo &ldquo;Do not forget to logout when you&rsquo;re done&rdquo;<br />
else<br />
echo &ldquo;Sorry, you are not allowed here&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 12]$ test25.sh<br />
Welcome devalone<br />
Please enjoy your visit</p>

<p>elif 语句继续 if-then 检查，为比较变量寻找特定的值。</p>

<p>有了 case 命令，就不需要再写出所有的 elif 语句来不停地检查同一个变量的值了。case 命令会采用列表格式来检查单个变量的多个值。</p>

<p>case 格式如下：</p>

<p>case variable in<br />
pattern1 | pattern2) commands1;;<br />
pattern3) commands2;;<br />
*) default commands;;<br />
esac</p>

<p>case 命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么 shell 会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出<br />
多个模式。星号会捕获所有与已知模式不匹配的值。</p>

<p>示例：</p>

<p>[devalone@devalone 12]$ cat test26.sh<br />
#!/bin/bash</p>

<h1 id="using-the-case-command">using the case command</h1>

<p>case $USER in<br />
devalone | barbara)<br />
echo &ldquo;Welcome, $USER&rdquo;<br />
echo &ldquo;Please enjoy your visit&rdquo;;;<br />
testing)<br />
echo &ldquo;Special testing account&rdquo;;;<br />
jessica)<br />
echo &ldquo;Do not forget to log off when you&rsquo;re done&rdquo;;;<br />
*)<br />
echo &ldquo;Sorry, you are not allowed here&rdquo;;;<br />
esac</p>

<p>运行：</p>

<p>[devalone@devalone 12]$ test26.sh<br />
Welcome, devalone<br />
Please enjoy your visit</p>

<p>case 命令提供了一个更清晰的方法来为变量每个可能的值指定不同的选项。</p>

<p>系列目录：</p>

<p>Linux shell 脚本编程-基础篇 （一）</p>

<p>Linux shell 脚本编程-基础篇 （二）</p>

<p>Linux shell 脚本编程-基础篇 （三）</p>

<p>Linux shell 脚本编程-基础篇 （四）</p>

<p>Linux shell 脚本编程-基础篇 （五）</p>

<p>Linux shell 脚本编程-基础篇 （六）</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>参考：</p>

<p>《Linux 命令行与 shell 脚本编程大全》 第 3 版 —— 2016.8（美）Richard Blum Cristine Bresnahan</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>