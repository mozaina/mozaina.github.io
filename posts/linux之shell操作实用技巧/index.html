<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux之Shell操作实用技巧 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux之Shell操作实用技巧 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux之Shell操作实用技巧">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux之Shell操作实用技巧</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><strong>目录</strong></p>

<p>1.Shell 操作日期时间</p>

<p>1.1. 显示系统当前日期时间</p>

<p>1.2.设置系统日期时间</p>

<p>1.3.日期计算</p>

<p>1.4.自定义日期格式</p>

<p>1.5. 有用小技巧</p>

<p>2.高级文本处理命令</p>

<p>2.1.wc</p>

<p>2.2.sort</p>

<p>2.3.uniq</p>

<p>2.4.cut</p>

<p>2.5.grep（文本生成器）</p>

<p>2.6.sed（流编辑器）</p>

<p>2.7.awk（报表生成器）</p>

<p>2.8.find</p>

<p>3.Shell 操作字符串</p>

<p>3.1.字符串截取</p>

<p>3.2.字符串替换</p>

<p>3.3.获取字符串长度</p>

<p>4. Shell脚本自动安装MySQL</p>

<hr />

<h1 id="1-shell-操作日期时间">1.Shell 操作日期时间</h1>

<p>linux 系统为我们提供了一个命令 date，专门用来显示或者设置系统日期时间的。</p>

<p>语法格式：date [option]&hellip; [+format] 或者 date [-u | -utc | -universal]
[MMDDhhmm[[CC]YY][.ss]]</p>

<p>常用的可选项有：</p>

<p>--help：显示辅助信息</p>

<p>--version：显示date命令版本信息</p>

<p>-u：显示目前的格林威治时间</p>

<p>-d：做日期时间相关的运算</p>

<p>--date=&lsquo;-dateStr&rsquo;：做日期时间的相关运算</p>

<h2 id="1-1-显示系统当前日期时间">1.1. 显示系统当前日期时间</h2>

<p>[root@hadoop ~]# date</p>

<p>[root@hadoop ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<h2 id="1-2-设置系统日期时间">1.2.设置系统日期时间</h2>

<p>[root@hadoop ~]# date -s &ldquo;2017-01-01 01:01&rdquo;</p>

<p>[root@hadoop ~]# date &ndash;set=&ldquo;2017-01-01 01:01&rdquo;</p>

<h2 id="1-3-日期计算">1.3.日期计算</h2>

<p>有时候，我们操作日期时间，经常会要获取前几天或后几天的时间，那么date命令给我们提供了实现这个功能的可选项 &lsquo;-d&rsquo; 和 &lsquo;&ndash;date&rsquo;
，请看下面的例子：</p>

<p>先看 <strong>&rsquo;-d&rsquo;</strong> ：</p>

<p>##获取下一天的时间</p>

<p>##获取上一天的时间</p>

<p>##获取下一月的时间</p>

<p>##获取上一月的时间</p>

<p>##获取下一年的时间</p>

<p>##获取上一年的时间</p>

<p>##获取下一周、下周一、下周四的日期时间</p>

<hr />

<p>##获取下一天的时间</p>

<p>[root@hdp1 ~]# date -d next-day &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>2017-05-07 02:11:13</p>

<p>[root@hdp1 ~]# date -d &lsquo;next day&rsquo; &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>2017-05-07 02:19:24</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo; -d tomorrow</p>

<p>2017-05-07 02:20:28</p>

<p>##获取上一天的时间</p>

<p>[root@hdp1 ~]# date -d last-day &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>2017-05-05 02:22:34</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo; -d yesterday</p>

<p>2017-05-05 02:22:59</p>

<p>##获取下一月的时间</p>

<p>[root@hadoop ~]# date -d next-month &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>##获取上一月的时间</p>

<p>[root@hadoop ~]# date -d last-month &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>##获取下一年的时间</p>

<p>[root@hadoop ~]# date -d next-year &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>##获取上一年的时间</p>

<p>[root@hadoop ~]# date -d last-year &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>##获取下一周、下周一、下周四的日期时间</p>

<p>[root@hadoop ~]# date -d next-week &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>[root@hadoop ~]# date -d next-monday &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>[root@hadoop ~]# date -d next-thursday &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>那么类似的，其实，last-year，last-month，last-day，last-week，last-hour，last-minute，last-
second都有对应的实现。相反的，last对应next，自己可以根据实际情况灵活组织</p>

<p>接下来，我们来看 <strong>&rsquo;&ndash;date&rsquo;</strong> ，它帮我实现任意时间前后的计算，来看具体的例子：</p>

<p>##获取一天以后的日期时间</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo; &ndash;date=&lsquo;1 day&rsquo;</p>

<p>2017-05-07 02:27:57</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo; &ndash;date=&lsquo;-1 day ago&rsquo;</p>

<p>2017-05-07 02:28:06</p>

<p>##获取一天以前的日期时间</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo; &ndash;date=&lsquo;-1 day&rsquo;</p>

<p>2017-05-05 02:28:38</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo; &ndash;date=&lsquo;1 day ago&rsquo;</p>

<p>2017-05-05 02:28:50</p>

<p>上面的例子显示出来了使用的格式，使用精髓在于改变前面的字符串显示格式，改变数据，改变要操作的日期对应字段，除了天也有对应的其他实现：year，month，week，day，hour，minute，second，monday（星期，七天都可）</p>

<h2 id="1-4-自定义日期格式">1.4.自定义日期格式</h2>

<p>date 能用来显示或设定系统的日期和时间，在显示方面，使用者能设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下：</p>

<p>使用范例如下：</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>2018-10-31 23:49:00</p>

<p><strong>日期方面</strong> ：</p>

<p>%a : 星期几 (Sun..Sat)</p>

<p>%A : 星期几 (Sunday..Saturday)</p>

<p>%b : 月份 (Jan..Dec)</p>

<p>%B : 月份 (January..December)</p>

<p>%c : 直接显示日期和时间</p>

<p>%d : 日 (01..31)</p>

<p>%D : 直接显示日期 (mm/dd/yy)</p>

<p>%h : 同 %b</p>

<p>%j : 一年中的第几天 (001..366)</p>

<p>%m : 月份 (01..12)</p>

<p>%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</p>

<p>%w : 一周中的第几天 (0..6)</p>

<p>%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</p>

<p>%x : 直接显示日期 (mm/dd/yyyy)</p>

<p>%y : 年份的最后两位数字 (00.99)</p>

<p>%Y : 完整年份 (0000..9999)</p>

<p><strong>时间方面</strong> ：</p>

<p>%%: 打印出%</p>

<p>%n : 下一行</p>

<p>%t : 跳格</p>

<p>%H : 小时(00..23)</p>

<p>%k : 小时(0..23)</p>

<p>%l : 小时(1..12)</p>

<p>%M : 分钟(00..59)</p>

<p>%p : 显示本地AM或PM</p>

<p>%P : 显示本地am或pm</p>

<p>%r : 直接显示时间(12 小时制，格式为 hh:mm:ss [AP]M)</p>

<p>%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数</p>

<p>%S : 秒(00..61)</p>

<p>%T : 直接显示时间(24小时制)</p>

<p>%X : 相当于%H:%M:%S %p</p>

<p>%Z : 显示时区</p>

<p><strong>若是不以加号作为开头，则表示要设定时间</strong> ，而时间格式为 MMDDhhmm[[CC]YY][.ss]</p>

<p>MM 为月份</p>

<p>DD 为日</p>

<p>hh 为小时</p>

<p>mm 为分钟</p>

<p>CC 为年份前两位数字</p>

<p>YY 为年份后两为数字</p>

<p>ss 为秒数</p>

<p>例子：</p>

<p>[root@hdp1 ~]# date &ldquo;050602032017.55&rdquo;</p>

<p>Sat May 6 02:03:55 CST 2017</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo;</p>

<p>2018-10-31 23:49:00</p>

<h2 id="1-5-有用小技巧">1.5. 有用小技巧</h2>

<p>##获取相对某个日期前后的日期</p>

<p>##把时间中无用的0去掉，比如01:02:25 变成 1:2:25</p>

<p>##显示文件最后被更改的时间</p>

<p>##求两个字符串日期之间的相隔的天数</p>

<p>##shell 中加减指定时间单位</p>

<hr />

<p>##获取相对某个日期前后的日期</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %H:%M:%S&rsquo; -d &lsquo;2018-11-1 -2 week&rsquo;</p>

<p>2018-10-18 00:00:00</p>

<p>##把时间中无用的0去掉，比如01:02:25 变成 1:2:25</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %-H:%-M:%-S&rsquo; -d &lsquo;2018-11-1 01:02:03 -1 day&rsquo;</p>

<p>2018-11-02 10:2:3</p>

<p>##显示文件最后被更改的时间</p>

<p>[root@hdp1 ~]# date &lsquo;+%Y-%m-%d %-H:%-M:%-S&rsquo; -r ./a.sh</p>

<p>2018-10-31 23:0:53</p>

<p>##求两个字符串日期之间的相隔的天数</p>

<p>[root@hdp1 ~]# echo &ldquo;($(date +%s)-$(date +%s -d &lsquo;1994-02-06&rsquo;))/60/60/24&rdquo; | bc</p>

<p>9034</p>

<p>##shell 中加减指定时间单位</p>

<p>[root@hdp1 ~]# A=$(date &lsquo;+%Y-%m-%d&rsquo;)</p>

<p>[root@hdp1 ~]# B=$(date &lsquo;+%Y-%m-%d&rsquo; -d &lsquo;A +48 hours&rsquo;)</p>

<p>[root@hdp1 ~]# echo $B</p>

<p>2018-11-04</p>

<p>[root@hdp1 ~]# B=<code>date +%Y-%m-%d -d &quot;A +48 hours&quot;</code></p>

<p>[root@hdp1 ~]# echo $B</p>

<p>2018-11-04</p>

<p>[root@hdp1 ~]# B=<code>date +%Y-%m-%d -d &quot;$A +48 hours&quot;</code></p>

<p>[root@hdp1 ~]# echo $B</p>

<p>2018-11-03</p>

<h1 id="2-高级文本处理命令">2.高级文本处理命令</h1>

<h2 id="2-1-wc">2.1.wc</h2>

<p>功能：统计文件行数、字节、字符数</p>

<p>常用选项：</p>

<p>-l：统计多少行</p>

<p>-w：统计字数</p>

<p>-c：统计文件字节数，一个英文字母1字节，一个汉字占2-4字节（根据编码）</p>

<p>-m：统计文件字符数，一个英文字母1个字符，一个汉字占1字节</p>

<p>-L：统计最长行的长度，也可以统计字符串长度</p>

<p>--help：显示帮助信息</p>

<p>--version：显示版本信息</p>

<p>一个汉字到底占几个字节？</p>

<p>占2个字节：〇</p>

<p>占3个字节：基本等同于GBK，含21000多个汉字</p>

<p>占4个字节：中日韩超大字符集里面的汉字，有5万多个</p>

<p>一个utf8数字占1个字节</p>

<p>一个utf8英文字母占1个字节</p>

<p>示例：</p>

<p>##统计文件信息</p>

<p>##统计字符串长度</p>

<p>##统计文件行数</p>

<p>##统计文件字数</p>

<hr />

<p>##统计文件信息</p>

<p>[root@hdp1 ~]# wc wc.txt</p>

<p>9 9 65 wc.txt</p>

<p>分别是：行数、单词数、字节数、文件名</p>

<p>##统计字符串长度</p>

<p>[root@hdp1 ~]# echo &ldquo;dafasdfa&rdquo; | wc -L</p>

<p>8</p>

<p>##统计文件行数</p>

<p>[root@hdp1 ~]# wc -l wc.txt</p>

<p>9 wc.txt</p>

<p>##统计文件字数</p>

<p>[root@hdp1 ~]# wc -w wc.txt</p>

<p>9 wc.txt</p>

<h2 id="2-2-sort">2.2.sort</h2>

<p>功能：排序文本，默认对整列有效</p>

<p>常用可选项：</p>

<p>-f：忽略字母大小写，就是将小写字母视为大写字母排序</p>

<p>-M：根据月份比较，比如JAN、DEC</p>

<p>-h：根据易读的单位大小比较，比如2K、1G</p>

<p>-g：按照常规数值排序</p>

<p>-n：按照字符串数值比较</p>

<p>-r：倒序排序</p>

<p>-k:pos1,pos2 根据关键字排序，在从第位置1开始，位置2结束</p>

<p>-t：指定分割符</p>

<p>-u：去重重复行</p>

<p>-o：将结果写入文件</p>

<p>准备数据：</p>

<p>aaa:10:1.1</p>

<p>ccc:20:3.3</p>

<p>bbb:40:4.4</p>

<p>eee:40:5.5</p>

<p>ddd:30:3.3</p>

<p>bbb:40:4.4</p>

<p>fff:30:2.2</p>

<p>示例：</p>

<p>[linux@linux ~]$ cat sort.txt ## 准备排序文件，查看该内容</p>

<p>aaa:10:1.1</p>

<p>ccc:20:3.3</p>

<p>bbb:40:4.4</p>

<p>eee:40:5.5</p>

<p>ddd:30:3.3</p>

<p>bbb:40:4.4</p>

<p>fff:30:2.2</p>

<p>[linux@linux ~]$ sort sort.txt ## 直接排序，把整行当做一列字符串，字典顺序</p>

<p>aaa:10:1.1</p>

<p>bbb:40:4.4</p>

<p>bbb:40:4.4</p>

<p>ccc:20:3.3</p>

<p>ddd:30:3.3</p>

<p>eee:40:5.5</p>

<p>fff:30:2.2</p>

<p>[linux@linux ~]$ sort -nk 2 -t : sort.txt ## 以:作为分隔符，取第二个字段按照数值进行排序</p>

<p>aaa:10:1.1</p>

<p>ccc:20:3.3</p>

<p>fff:30:2.2</p>

<p>ddd:30:3.3</p>

<p>bbb:40:4.4</p>

<p>bbb:40:4.4</p>

<p>eee:40:5.5</p>

<p>[linux@linux ~]$ sort -nk 2 -u -t : sort.txt ## 和上一个不一样的是-u为了去重，根据排序列去重的</p>

<p>aaa:10:1.1</p>

<p>ccc:20:3.3</p>

<p>ddd:30:3.3</p>

<p>bbb:40:4.4</p>

<p>多列排序：以:分隔，按第二列数值排倒序，第三列正序</p>

<p>[linux@linux ~]$ sort -n -t: -k2,2r -k3 sort.txt ????</p>

<p>bbb:40:4.4</p>

<p>bbb:40:4.4</p>

<p>eee:40:5.5</p>

<p>fff:30:2.2</p>

<p>ddd:30:3.3</p>

<p>ccc:20:3.3</p>

<p>aaa:10:1.1</p>

<h2 id="2-3-uniq">2.3.uniq</h2>

<p>取出重复行，只会统计相邻。</p>

<p>常用选项：</p>

<p>-c：打印出现次数</p>

<p>-d：只打印重复行</p>

<p>-u：只打印不重复行</p>

<p>-D：只打印重复行，并且把所有重复行打印出来</p>

<p>-f N：比较时跳过前N列</p>

<p>-i：忽略大小写</p>

<p>-s N：比较式跳过前N个字符</p>

<p>-w N：对每行第N个字符以后内容不做比较</p>

<p>准备数据：</p>

<p>abc</p>

<p>xyz</p>

<p>cde</p>

<p>cde</p>

<p>xyz</p>

<p>abd</p>

<p>示例1：</p>

<p>[linux@linux ~]$ uniq uniq.txt ## 直接去重，只能在相邻行去重</p>

<p>abc</p>

<p>xyz</p>

<p>cde</p>

<p>xyz</p>

<p>abd</p>

<p>[linux@linux ~]$ sort uniq.txt | uniq ## 先给文件排序，然后去重</p>

<p>abc</p>

<p>abd</p>

<p>cde</p>

<p>xyz</p>

<p>[linux@linux ~]$ sort uniq.txt | uniq -c ## 打印每行重复次数</p>

<p>1 abc</p>

<p>1 abd</p>

<p>2 cde</p>

<p>2 xyz</p>

<p>[linux@linux ~]$ sort uniq.txt | uniq -u -c ## 打印不重复行，并给出次数</p>

<p>1 abc</p>

<p>1 abd</p>

<p>[linux@linux ~]$ sort uniq.txt | uniq -d -c ## 打印重复行，并给出次数</p>

<p>2 cde</p>

<p>2 xyz</p>

<p>[linux@linux ~]$ sort uniq.txt | uniq -w 2 ## 以开头前两个字符为判断标准去重</p>

<p>abc</p>

<p>cde</p>

<p>xyz</p>

<p>示例2：</p>

<p>先准备两个文件：a.txt 和 b.txt</p>

<p>文件内容分别为：</p>

<p>[root@hdp1 ~]# cat a.txt</p>

<p>a</p>

<p>b</p>

<p>c</p>

<p>d</p>

<p>[root@hdp1 ~]# cat b.txt</p>

<p>b</p>

<p>c</p>

<p>d</p>

<p>e</p>

<p>f</p>

<p>需求：</p>

<p>##求两个文件的交集：</p>

<p>[root@hdp1 ~]# cat a.txt b.txt | sort | uniq -d -c</p>

<p>##求两个文件的并集：</p>

<p>[root@hdp1 ~]# cat a.txt b.txt | sort | uniq</p>

<p>##求a.txt和b.txt的差集</p>

<p>[root@hdp1 ~]# cat a.txt b.txt b.txt | sort | uniq -u</p>

<p>##求b.txt和a.txt的差集</p>

<p>[root@hdp1 ~]# cat b.txt a.txt a.txt | sort | uniq -u</p>

<h2 id="2-4-cut">2.4.cut</h2>

<p>cut命令可以从一个文本文件或文本流中提取文本列。</p>

<p>cut语法：</p>

<p>cut -d&rsquo;分隔字符&rsquo; -f fields ##用于有特定分分隔字符</p>

<p>cut -c 字符区间 ##用于排列整齐的信息</p>

<p>选项与参数：</p>

<p>-d：后面接分隔符，与-f一起使用</p>

<p>-f：依据-d的分隔符将一段信息分割成为字段，用-f取出第几段的意思</p>

<p>-c：按照字符截取</p>

<p>-b：按照字节截取</p>

<p>例子1：</p>

<p>首先看PATH变量：</p>

<p>[root@localhost ~]# echo $PATH</p>

<p>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</p>

<p>##将PATH变量取出，找出第五个路径</p>

<p>[root@localhost ~]# echo $PATH | cut -d &lsquo;:&rsquo; -f 5</p>

<p>/usr/sbin</p>

<p>##将PATH变量取出，找出第三和第五个路径，以下三种方式都OK</p>

<p>[root@localhost ~]# echo $PATH | cut -d &lsquo;:&rsquo; -f 3,5</p>

<p>[root@localhost ~]# echo $PATH | cut -d : -f 3,5</p>

<p>[root@localhost ~]# echo $PATH | cut -d: -f3,5</p>

<p>/sbin:/usr/sbin</p>

<p>##将PATH变量取出，找出第三到最后一个路径</p>

<p>[root@localhost ~]# echo $PATH | cut -d &lsquo;:&rsquo; -f 3-</p>

<p>/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</p>

<p>##将PATH变量取出，找出第一到第三，还有第五个路径</p>

<p>[root@localhost ~]# echo $PATH | cut -d &lsquo;:&rsquo; -f 1-3,5</p>

<p>/usr/local/sbin:/usr/local/bin:/sbin:/usr/sbin</p>

<p>例子2：</p>

<p>##先准备已空格分开的这么段数据：</p>

<p>黄渤 huangbo 18 jiangxi</p>

<p>徐峥 xuzheng 22 hunan</p>

<p>王宝强 wangbaoqiang 44 liujiayao</p>

<p>##获取中间的年龄：</p>

<p>[root@localhost ~]# cut -f 3 -d &lsquo; &rsquo; cut.txt</p>

<p>18</p>

<p>22</p>

<p>44</p>

<p>##获取第二个字符到第五个字符之间的字符：</p>

<p>[root@localhost ~]# cut -c 2-5 cut.txt</p>

<p>渤 hu</p>

<p>峥 xu</p>

<p>宝强 w</p>

<p>##获取第四个字节到第六个字节中的字符：</p>

<p>[root@hadoop ~]# cut -b 4-6 cut.txt</p>

<p>渤</p>

<p>峥</p>

<p>宝</p>

<h2 id="2-5-grep-文本生成器">2.5.grep（文本生成器）</h2>

<p>grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行统计出来。</p>

<p>命令：grep [选项] [-color=auto] &ldquo;搜索字符串&rdquo; filename</p>

<p>常用选项：</p>

<p>-c：统计符合条件的字符串出现的总行数</p>

<p>-E：支持扩展正则表达式</p>

<p>-i：忽略大小写</p>

<p>-n：在显示匹配到的字符串前面加上行号</p>

<p>-v：显示没有“搜索字符串”内容的那一行</p>

<p>-l：列出文件内容中有搜索字符串的文件名称</p>

<p>-o：只输出文件中匹配到的部分</p>

<p>-color=auto：将匹配到的字符串高亮起来</p>

<p>基本使用：</p>

<p>##查询包含hadoop的行</p>

<p>[root@localhost ~]# grep hadoop /etc/passwd</p>

<p>hadoop:x:500:504:hadoop01:/home/hadoop:/bin/bash</p>

<h2 id="寻找当前路径下所有txt当中内容那些是带了huangbo字符串的">寻找当前路径下所有txt当中内容那些是带了huangbo字符串的</h2>

<p>[root@localhost ~]# grep huangbo ./*.txt</p>

<p>./mazhonghua.txt:my name is huangbo is is huangbo</p>

<p>./sutdent.txt:huangbo 18 jiangxi</p>

<p>高级使用：</p>

<p>准备数据：</p>

<p>[root@hdp1 ~]# cat grep.txt</p>

<p>huangbo is shuaige</p>

<p>huangxiaoming is shuaige</p>

<p>liuyifei is meinv</p>

<p>hello world hello tom hello kitty</p>

<p>#how old are you</p>

<p>#one two three four five six seven eight nine ten</p>

<p>##统计出现某个字符串的行的总行数</p>

<p>[root@hdp1 ~]# grep -c &lsquo;hello&rsquo; grep.txt</p>

<p>1</p>

<p>[root@hdp1 ~]# grep -c &lsquo;is&rsquo; grep.txt</p>

<p>3</p>

<p>[root@hdp1 ~]# grep -c hello grep.txt</p>

<p>1</p>

<p>[root@hdp1 ~]# grep -c is grep.txt</p>

<p>3</p>

<p>##查询不包含is的行</p>

<p>[root@hdp1 ~]# grep -v &lsquo;is&rsquo; grep.txt</p>

<p>hello world hello tom hello kitty</p>

<p>#how old are you</p>

<p>#one two three four five six seven eight nine ten</p>

<p>##正则表达包含huang</p>

<p>[root@hdp1 ~]# grep &lsquo;.<em>huang.</em>&rsquo; grep.txt</p>

<p>huangbo is shuaige</p>

<p>huangxiaoming is shuaige</p>

<p>##输出匹配行的前后N行（会包括匹配行）</p>

<p>使用-A参数输出匹配行的后一行：grep -A 1 &ldquo;huangxiaoming&rdquo; grep.txt</p>

<p>使用-B参数输出匹配行的前一行：grep -B 1 &ldquo;huangxiaoming&rdquo; grep.txt</p>

<p>使用-C参数输出匹配行的前后各一行：grep -C 1 &ldquo;huangxiaoming&rdquo; grep.txt</p>

<p>正则表达式：</p>

<p>#正则表达式：点代表任意一个字符</p>

<p>[root@hdp1 ~]# grep &lsquo;h.*p&rsquo; /etc/passwd</p>

<p>#正则表达式：以hadoop开头</p>

<p>[root@hdp1 ~]# grep &lsquo;^hdp01&rsquo; /etc/passwd</p>

<p>#正则表达式：以hadoop结尾</p>

<p>[root@hdp1 ~]# grep &lsquo;hdp01$&rsquo; /etc/passwd</p>

<p>#正则表达式：以h或r开头</p>

<p>[root@hdp1 ~]# grep &lsquo;<sup class="footnote-ref" id="fnref:hr"><a href="#fn:hr">1</a></sup>&rsquo; /etc/passwd</p>

<p>#不以h和r开头</p>

<p>[root@hdp1 ~]# grep &lsquo;^[^hr]&rsquo; /etc/passwd</p>

<p>#不以h到r开头</p>

<p>[root@hdp1 ~]# grep &lsquo;^[^h-r]&rsquo; /etc/passwd</p>

<p>正则表达式的简单规则：</p>

<p>. : 任意一个字符</p>

<p>a* : 任意多个a(零个或多个a)</p>

<p>a? : 零个或一个a</p>

<p>a+ : 一个或多个a</p>

<p>.* : 任意多个任意字符</p>

<p>\. : 转义.</p>

<p>o\{2\} : o重复两次</p>

<p>[A-Z]：A-Z任意一个字符</p>

<p>[ABC]：ABC中任意一个字符</p>

<p>##查找不是以#开头的行</p>

<p>[root@localhost ~]# grep -v &lsquo;^#&rsquo; grep.txt</p>

<p>[root@localhost ~]# grep -v &lsquo;^#&rsquo; grep.txt | grep -v &lsquo;^$&rsquo;</p>

<h2 id="2-6-sed-流编辑器">2.6.sed（流编辑器）</h2>

<p>sed叫做流编辑器，在shell脚本和Makefile中作为过滤——使用非常普遍，也就是把前一个程序的输出引入sed的输入，经过一些列编辑命令转换成另一种格式输出。sed是一种在线编辑器，它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为模式空间，接着用sed命令处理缓冲区中的内容，处理完成后，把缓存区的内容送我屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件的内容并没有改变，除非你使用重定向存储输出。</p>

<p>选项：</p>

<p>-n：一般sed命令会把所有数据输出到屏幕，如果加入-n选项的话，则只会把经过sed命令处理的行输出到屏幕。</p>

<p>-e：多点编辑，允许对输入数据应用多条sed命令编辑</p>

<p>-i：用sed的修改结果直接修改读取数据的文件，而不会由屏幕输出。</p>

<p>动作：</p>

<p>a：追加，在当前行后添加一行或多行</p>

<p>c：行替换，用c后面的字符串填好原数据行</p>

<p>d：行删除命令，前面跟数字指定删除的行</p>

<p>i：插入，在当前行前插入一行或多行</p>

<p>p：打印，输出指定的行</p>

<p>s：字符串替换，用一个字符串替换另一个字符串。格式为 &lsquo;行范围 s/旧字符串/新字符串/g&rsquo; （如果不加g的话，则表示只替换每行第一个匹配的字符串）</p>

<p>1、删除：d命令</p>

<p>#删除sed.txt文件的第二行。</p>

<p>sed &lsquo;2d&rsquo; sed.txt</p>

<p>#删除sed.txt文件的第二行到末尾所有行。</p>

<p>sed &lsquo;2,$d&rsquo; sed.txt</p>

<p>#删除sed.txt文件的最后一行。</p>

<p>sed &lsquo;$d&rsquo; sed.txt</p>

<p>删除sed.txt文件所有包含test的行。</p>

<p>sed &lsquo;/test/d &rsquo; sed.txt</p>

<p>删除sed.txt文件所有包含字母的行。</p>

<p>sed &lsquo;/[A-Za-z]/d &lsquo; sed.txt</p>

<p>2、整行替换：c命令</p>

<p>#将第二行替换成hello world</p>

<p>sed &lsquo;2c hello world&rsquo; sed.txt</p>

<p>3、字符串替换：s命令</p>

<h2 id="如果没有g标记-则只有每行第一个匹配的hello被替换成hi">如果没有g标记，则只有每行第一个匹配的hello被替换成hi。</h2>

<p>sed &rsquo;s/hello/hi/g&rsquo; sed.txt</p>

<h2 id="此种写法表示只替换每行的第2个hello为hi">此种写法表示只替换每行的第2个hello为hi</h2>

<p>sed &rsquo;s/hello/hi/2&rsquo; sed.txt</p>

<h2 id="此种写法表示只替换每行的第2个以后的hello为hi-包括第2个">此种写法表示只替换每行的第2个以后的hello为hi（包括第2个）</h2>

<p>sed &rsquo;s/hello/hi/2g&rsquo; sed.txt</p>

<h2 id="n选项和p表示只打印那些发生替换的行-如果某一行开头的hello被替换成hi就打印它">-n选项和p表示只打印那些发生替换的行。如果某一行开头的hello被替换成hi就打印它。</h2>

<p>sed -n &rsquo;s/^hello/hi/p&rsquo; sed.txt</p>

<h2 id="打印输出sed-txt中的第2行和第4行">打印输出sed.txt中的第2行和第4行</h2>

<p>sed -n &lsquo;2,4p&rsquo; sed.txt</p>

<h2 id="符号表示追加一个串到找到的串后-所有以192-168-0-1开头的行都会被替换成它自已加">&amp;符号表示追加一个串到找到的串后。所有以192.168.0.1开头的行都会被替换成它自已加</h2>

<p>-localhost，变成192.168.0.1-localhost。第三句表示给IP地址添加中括号</p>

<p>sed -n &rsquo;s/hello/&amp;-hi/gp&rsquo; sed.txt</p>

<p>sed &rsquo;s/^192.168.0.1/&amp;-localhost/&rsquo; sed.txt</p>

<p>sed &rsquo;s/^192.168.0.1/[&amp;]/&rsquo; sed.txt</p>

<h2 id="liu被标记为-1-所以liu会被保留下来-1-liu">liu被标记为\1，所以liu会被保留下来（\1 == liu）</h2>

<h2 id="ling被标记为-2-所以ling也会被保留下来-2-ling">ling被标记为\2，所以ling也会被保留下来（\2 == ling）</h2>

<h2 id="所以最后的结果就是-1tao-2ss-liu-tao-ling-ss">所以最后的结果就是\1tao\2ss == &ldquo;liu&rdquo; + &ldquo;tao&rdquo; + &ldquo;ling&rdquo; + &ldquo;ss&rdquo;</h2>

<p>此处切记：\1代表的是被第一个()包含的内容，\1代表的是被第一个()包含的内容，……</p>

<p>上面命令的意思就是：被括号包含的字符串会保留下来，然后跟其他的字符串比如tao和ss组成新的字符串liutaolingss</p>

<p>sed -n &rsquo;s/\(liu\)jialing/\1tao/p&rsquo; sed.txt</p>

<p>sed -n &rsquo;s/\(liu\)jia\(ling\)/\1tao\2ss/p&rsquo; sed.txt</p>

<h2 id="不论什么字符-紧跟着s命令的都被认为是新的分隔符-所以-在这里是分隔符-代替了默认的-分隔符-表示把所有hello替换成hi">不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，&rdquo;#&ldquo;在这里是分隔符，代替了默认的&rdquo;/&ldquo;分隔符。表示把所有hello替换成hi。</h2>

<p>sed &rsquo;s#hello#hi#g&rsquo; sed.txt</p>

<h2 id="所有在模板today和hello所确定的范围内的行都被打印-都找第一个-也就是说-从第一个today到第一个hello">所有在模板today和hello所确定的范围内的行都被打印。都找第一个，也就是说，从第一个today到第一个hello</h2>

<p>sed -n &lsquo;/today/,/hello/p&rsquo; sed.txt</p>

<h2 id="打印从第五行开始到第一个包含以hello开始的行之间的所有行">打印从第五行开始到第一个包含以hello开始的行之间的所有行。</h2>

<p>sed -n &lsquo;5,/^hello/p&rsquo; sed.txt</p>

<p>sed -n &lsquo;/^hello/,8p&rsquo; sed.txt</p>

<h2 id="对于模板today和hello之间的行-每行的末尾用字符串www替换">对于模板today和hello之间的行，每行的末尾用字符串www替换。</h2>

<p>sed &lsquo;/today/,/hello/s/$/www/&rsquo; sed.txt</p>

<h2 id="对于模板today和hello之间的行-每行的开头用字符串www替换">对于模板today和hello之间的行，每行的开头用字符串www替换。</h2>

<p>sed &lsquo;/today/,/hello/s/^/www/&rsquo; sed.txt</p>

<h2 id="将以字母开头的行中的数字5替换成five">将以字母开头的行中的数字5替换成five</h2>

<p>sed &lsquo;/<sup class="footnote-ref" id="fnref:A-Za-z"><a href="#fn:A-Za-z">2</a></sup>/s/5/five/g&rsquo; sed.txt</p>

<p>4、多点编辑：e命令</p>

<h2 id="e允许在同一行里执行多条命令">-e允许在同一行里执行多条命令。</h2>

<h2 id="如例子所示-第一条命令删除1至5行-第二条命令用hello替换hi">如例子所示，第一条命令删除1至5行，第二条命令用hello替换hi。</h2>

<h2 id="命令的执行顺序对结果有影响-如果两个命令都是替换命令-那么第一个替换命令将影响第二个替换命令的结果">命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</h2>

<p>sed -e &lsquo;1,5d&rsquo; -e &rsquo;s/hello/hi/&rsquo; sed.txt</p>

<h2 id="一个比-e更好的命令是-expression-它能给sed表达式赋值">一个比-e更好的命令是&ndash;expression。它能给sed表达式赋值。</h2>

<p>sed &ndash;expression=&rsquo;s/hello/hi/&rsquo; &ndash;expression=&lsquo;/today/d&rsquo; sed.txt</p>

<p>5、从文件读入：r命令</p>

<h2 id="file里的内容被读进来-显示在与hello匹配的行下面-如果匹配多行-则file的内容将显示在所有匹配行的下面">file里的内容被读进来，显示在与hello匹配的行下面，如果匹配多行，则file的内容将显示在所有匹配行的下面。</h2>

<p>sed &lsquo;/hello/r file&rsquo; sed.txt</p>

<p>6、写入文件：w命令</p>

<h2 id="在huangbo-txt中所有包含hello的行都被写入file里">在huangbo.txt中所有包含hello的行都被写入file里。</h2>

<p>sed -n &lsquo;/hello/w file&rsquo; sed.txt</p>

<p>7、追加命令：a命令</p>

<h2 id="this-is-a-example-被追加到以hello开头的行-另起一行-后面-sed要求命令a后面有一个反斜杠">&rsquo;&mdash;&gt;this is a example&rsquo;被追加到以hello开头的行(另起一行)后面，sed要求命令a后面有一个反斜杠。</h2>

<p>sed &lsquo;/^hello/a\\&mdash;&gt;this is a example&rsquo; sed.txt</p>

<p>8、插入：i命令</p>

<h2 id="如果test被匹配-则把反斜杠后面的文本插入到匹配行的前面">如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。</h2>

<p>sed &lsquo;/test/i\\some thing new &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rsquo; sed.txt</p>

<p>9、下一个：n命令</p>

<h2 id="如果hello被匹配-则移动到匹配行的下一行-替换这一行的aa-变为bb-并打印该行">如果hello被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行</h2>

<h2 id="替换下一行的第一个aa">替换下一行的第一个aa</h2>

<p>sed &lsquo;/hello/{n; s/aa/bb/;}&rsquo; sed.txt</p>

<h2 id="替换下一行的全部aa">替换下一行的全部aa</h2>

<p>sed &lsquo;/hello/{n; s/aa/bb/g;}&rsquo; sed.txt</p>

<p>10、退出：q命令</p>

<p>sed &lsquo;10q&rsquo; sed.txt</p>

<h2 id="打印完第10行后-退出sed">打印完第10行后，退出sed。</h2>

<h2 id="同样的写法">同样的写法：</h2>

<p>sed -n &lsquo;1,10p &rsquo; sed.txt</p>

<h2 id="2-7-awk-报表生成器">2.7.awk（报表生成器）</h2>

<p>Awk是一个强大的处理文本的编程语言工具，其名称得自于它的创始人Alfred Aho、Peter Weinberger和Brian Kernighan
姓氏的首个字母，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。AWK
提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。简单来说awk就是扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。</p>

<p>1、假设last -n 5的输出如下:</p>

<p>[root@localhost ~]# last -n 5</p>

<p>root pts/0 192.168.123.1 Wed Dec 28 01:55 still logged in</p>

<p>reboot system boot 2.6.32-573.el6.x Tue Dec 27 04:25 - 03:11 (22:46)</p>

<p>root pts/1 192.168.123.1 Tue Dec 27 02:00 - 02:00 (00:00)</p>

<p>root pts/1 192.168.123.1 Tue Dec 27 01:59 - 02:00 (00:00)</p>

<p>root pts/0 192.168.123.1 Tue Dec 27 01:59 - down (00:16)</p>

<p>2、只显示五个最近登录的账号：</p>

<p>[root@localhost ~]# last -n 5 | awk &lsquo;{print $1}&rsquo;</p>

<p>root</p>

<p>reboot</p>

<p>root</p>

<p>root</p>

<p>root</p>

<p>awk工作流程是这样的：读入有&rsquo;\n&rsquo;换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&rdquo;空白键&rdquo;
或 &ldquo;[tab]键&rdquo;,所以$1表示登录用户，$3表示登录用户ip,以此类推</p>

<p>3、显示/etc/passwd的账户：</p>

<p>[root@localhost ~]# cat /etc/passwd |awk -F &lsquo;:&rsquo; &lsquo;{print $1}&rsquo;</p>

<p>root</p>

<p>bin</p>

<p>daemon</p>

<p>adm</p>

<p>lp</p>

<p>这种是awk+action的示例，每行都会执行action{print $1}。-F指定域分隔符为&rsquo;:&rsquo;</p>

<p>4、显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割</p>

<p>[root@localhost ~]# cat /etc/passwd |awk -F &lsquo;:&rsquo; &lsquo;{print $1&rdquo;\t&rdquo;$7}&rsquo;</p>

<p>root /bin/bash</p>

<p>bin /sbin/nologin</p>

<p>daemon /sbin/nologin</p>

<p>adm /sbin/nologin</p>

<p>lp /sbin/nologin</p>

<p>5、BEGIN and END 关键字</p>

<p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加&rdquo;blue,/bin/nosh&rdquo;。</p>

<p>cat /etc/passwd |awk -F &lsquo;:&rsquo; &lsquo;BEGIN {print &ldquo;name,shell&rdquo;} {print $1&rdquo;,&ldquo;$7} END
{print &ldquo;blue,/bin/nosh&rdquo;}&rsquo;</p>

<p>cat /etc/passwd | awk -F &lsquo;:&rsquo; &lsquo;BEGIN {print &ldquo;name \t shell&rdquo;} {print$1&rdquo;\t&rdquo;$7}
END {print &ldquo;blue,/bin/bash&rdquo;}&rsquo;</p>

<p>name,shell</p>

<p>root,/bin/bash</p>

<p>daemon,/bin/sh</p>

<p>&hellip;.</p>

<p>blue,/bin/nosh</p>

<p>awk工作流程是这样的：先执行BEGIN，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录••••••直到所有的记录都读完，最后执行END操作。</p>

<p>6、搜索/etc/passwd有root关键字的所有行</p>

<p>awk -F: &lsquo;/root/&rsquo; /etc/passwd</p>

<p>root:x:0:0:root:/root:/bin/bash</p>

<p>这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。</p>

<p>搜索支持正则，例如找root开头的: awk -F: &lsquo;/^root/&rsquo; /etc/passwd</p>

<p>搜索/etc/passwd有root关键字的所有行，并显示对应的shell</p>

<p>awk -F &lsquo;:&rsquo; &lsquo;/root/{print $7}&rsquo; /etc/passwd</p>

<p>/bin/bash</p>

<p>这里指定了action{print $7}</p>

<p>6、awk常见内置变量</p>

<p>FILENAME：awk浏览的文件名</p>

<p>FNR：浏览文件的记录数，也就是行数。awk是以行为单位处理的，所以每行就是一个记录</p>

<p>NR：awk读取文件每行内容时的行号</p>

<p>NF：浏览记录的域的个数。可以用它来输出最后一个域</p>

<p>FS：设置输入域分隔符，等价于命令行-F选项</p>

<p>OFS：输出域分隔符</p>

<p>统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容</p>

<p>awk -F &lsquo;:&rsquo; &lsquo;{print &ldquo;filename:&rdquo; FILENAME &ldquo;,linenumber:&rdquo; NR &ldquo;,columns:&rdquo; NF
&ldquo;,linecontent:&ldquo;$0}&rsquo; /etc/passwd</p>

<p>awk -F&rsquo;:&rsquo; &lsquo;{print &ldquo;filename:&rdquo; FILENAME &ldquo;,linenumber:&rdquo; NR &ldquo;,colums:&rdquo; NF
&ldquo;linecotent:&rdquo; $0}&rsquo; /etc/passwd</p>

<p>filename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/sh</p>

<p>filename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh</p>

<p>使用printf替代print,可以让代码更加简洁，易读</p>

<p>awk -F &lsquo;:&rsquo;
&lsquo;{printf(&ldquo;filename:%s,linenumber:%s,columns:%s,linecontent:%s\n&rdquo;,FILENAME,NR,NF,$0)}&rsquo;
/etc/passwd</p>

<p>指定输入分隔符，指定输出分隔符：</p>

<p>awk &lsquo;BEGIN {FS=&rdquo;:&ldquo;; OFS=&rdquo;\t&rdquo;} {print $1, $2}&rsquo; /etc/passwd</p>

<p>sshd x</p>

<p>tcpdump x</p>

<p>linux x</p>

<p>8、实用例子</p>

<p>A：打印最后一列：</p>

<p>awk -F: &lsquo;{print $NF}&rsquo; /etc/passwd</p>

<p>awk -F: &lsquo;{printf(&ldquo;%s\n&rdquo;,$NF);}&rsquo; /etc/passwd</p>

<p>B：统计文件行数：</p>

<p>awk &lsquo;BEGIN {x=0} {x++} END {print x}&rsquo; /etc/passwd</p>

<p>C：打印9*9乘法表：</p>

<p>awk &lsquo;BEGIN{for(n=0;n++&lt;9;){for(i=0;i++</p>

<p>awk &lsquo;BEGIN {for(i=1;i&lt;=9;i++){for(j=1;j&lt;=i;j++){printf i&rdquo;*&ldquo;j&rdquo;=&ldquo;i*j&rdquo; &ldquo;;}print
&ldquo;&rdquo;}}&rsquo;</p>

<p>awk &lsquo;BEGIN {for(i=9;i&gt;=1;i&ndash;){for(j=i;j&gt;=1;j&ndash;){printf i&rdquo;*&ldquo;j&rdquo;=&ldquo;i*j&rdquo; &ldquo;;}print
&ldquo;&rdquo;}}&rsquo;</p>

<p>D：计算1-100之和：</p>

<p>echo &ldquo;sum&rdquo; | awk &lsquo;BEGIN {sum=0;} {i=0;while(i&lt;101){sum+=i;i++}} END {print
sum}&rsquo;</p>

<p>9、更多详细用法参见官网：<a href="http://www.gnu.org/software/gawk/manual/gawk.html">http://www.gnu.org/software/gawk/manual/gawk.html</a></p>

<h2 id="2-8-find">2.8.find</h2>

<p>功能： 搜索文件目录层次结构</p>

<p>格式： find path -option actions</p>

<p>find [表达式]</p>

<p>常用可选项：</p>

<p>-name 根据文件名查找，支持(&rsquo;* &lsquo; , &lsquo;? &lsquo;)</p>

<p>-type 根据文件类型查找(f-普通文件，c-字符设备文件，b-块设备文件，l-链接文件，d-目录)</p>

<p>-perm 根据文件的权限查找，比如 755</p>

<p>-user 根据文件拥有者查找</p>

<p>-group 根据文件所属组寻找文件</p>

<p>-size 根据文件小大寻找文件</p>

<p>-o 表达式 或</p>

<p>-a 表达式 与</p>

<p>-not 表达式 非</p>

<p>示例：</p>

<h2 id="准备的测试文件">准备的测试文件</h2>

<p>[linux@linux txt]$ ll</p>

<p>total 248</p>

<p>-rw-rw-r&ndash;. 1 linux linux 235373 Apr 18 00:10 hw.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 0 Apr 22 05:43 LINUX.pdf</p>

<p>-rw-rw-r&ndash;. 1 linux linux 3 Apr 22 05:50 liujialing.jpg</p>

<p>-rw-rw-r&ndash;. 1 linux linux 0 Apr 22 05:43 mingxing.pdf</p>

<p>-rw-rw-r&ndash;. 1 linux linux 57 Apr 22 04:40 mingxing.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 66 Apr 22 05:15 sort.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 214 Apr 18 10:08 test.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 24 Apr 22 05:27 uniq.txt</p>

<h2 id="查找文件名txt结尾的文件">查找文件名txt结尾的文件</h2>

<p>[linux@linux txt]$ find /home/linux/txt/ -name &ldquo;*.txt&rdquo;</p>

<p>/home/linux/txt/uniq.txt</p>

<p>/home/linux/txt/mingxing.txt</p>

<p>/home/linux/txt/test.txt</p>

<p>/home/linux/txt/hw.txt</p>

<p>/home/linux/txt/sort.txt</p>

<h2 id="忽略大小写查找文件名包含linux">忽略大小写查找文件名包含linux</h2>

<p>[linux@linux txt]$ find /home/linux/txt -iname &ldquo;<em>linux</em>&ldquo;</p>

<p>/home/linux/txt/LINUX.pdf</p>

<h2 id="查找文件名结尾是-txt或者-jpg的文件">查找文件名结尾是.txt或者.jpg的文件</h2>

<p>[linux@linux txt]$ find /home/linux/txt/ \( -name &ldquo;<em>.txt&rdquo; -o -name &ldquo;</em>.jpg&rdquo;
\)</p>

<p>/home/linux/txt/liujialing.jpg</p>

<p>/home/linux/txt/uniq.txt</p>

<p>/home/linux/txt/mingxing.txt</p>

<p>/home/linux/txt/test.txt</p>

<p>/home/linux/txt/hw.txt</p>

<p>/home/linux/txt/sort.txt</p>

<p>另一种写法：find /home/linux/txt/ -name &ldquo;<em>.txt&rdquo; -o -name &ldquo;</em>.jpg&rdquo;</p>

<p>使用正则表达式的方式去查找上面条件的文件：</p>

<p>[linux@linux txt]$ find /home/linux/txt/ -regex &ldquo;.*\(\.txt|\.jpg\)$&rdquo;</p>

<p>/home/linux/txt/liujialing.jpg</p>

<p>/home/linux/txt/uniq.txt</p>

<p>/home/linux/txt/mingxing.txt</p>

<p>/home/linux/txt/test.txt</p>

<p>/home/linux/txt/hw.txt</p>

<p>/home/linux/txt/sort.txt</p>

<h2 id="查找-jpg结尾的文件-然后删掉">查找.jpg结尾的文件，然后删掉</h2>

<p>[linux@linux txt]$ find /home/linux/txt -type f -name &ldquo;*.jpg&rdquo; -delete</p>

<p>[linux@linux txt]$ ll</p>

<p>total 248</p>

<p>-rw-rw-r&ndash;. 1 linux linux 235373 Apr 18 00:10 hw.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 0 Apr 22 05:43 LINUX.pdf</p>

<p>-rw-rw-r&ndash;. 1 linux linux 0 Apr 22 05:43 mingxing.pdf</p>

<p>-rw-rw-r&ndash;. 1 linux linux 57 Apr 22 04:40 mingxing.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 66 Apr 22 05:15 sort.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 214 Apr 18 10:08 test.txt</p>

<p>-rw-rw-r&ndash;. 1 linux linux 24 Apr 22 05:27 uniq.txt</p>

<h1 id="3-shell-操作字符串">3.Shell 操作字符串</h1>

<h2 id="3-1-字符串截取">3.1.字符串截取</h2>

<p>Linux中操作字符串，也是一项必备的技能。其中尤以截取字符串更加频繁，下面为大家介绍几种常用方式，截取字符串。</p>

<p>1、#截取，删除左边字符串（包括制定的分隔符），保留右边字符串</p>

<p>预先定义一个变量：WEBSITE=&lsquo;<a href="http://hadoop//centos/huangbo.html'">http://hadoop//centos/huangbo.html'</a></p>

<p>[root@hadoop ~]# echo ${WEBSITE##*//}</p>

<p>结果：centos/huangbo.html</p>

<p>2、##截取，删除左边字符串（包括指定的分隔符），保留右边字符串，和上边一个#不同的是，它一直找到最后，而不是像一个#那样找到一个就满足条件退出了。</p>

<p>[root@hadoop ~]# echo ${WEBSITE##*//}</p>

<p>结果：centos/huangbo.html</p>

<p>3、%截取，删除右边字符串（包括制定的分隔符），保留左边字符串</p>

<p>[root@hadoop ~]# echo ${WEBSITE%//*}</p>

<p>结果：<a href="http://hadoop">http://hadoop</a></p>

<p>4、%%截取，删除右边字符串（包括指定的分隔符），保留左边字符串，和上边一个%不同的是，它一直找到最前，而不是像一个%那样找到一个就满足条件退出了。</p>

<p>[root@hadoop ~]# echo ${WEBSITE%%//*}</p>

<p>结果：http:</p>

<p>总结以上四种方式：</p>

<h1 id="去掉左边-最短匹配模式-最长匹配模式">去掉左边，最短匹配模式， ##最长匹配模式。</h1>

<p>% 去掉右边，最短匹配模式， %%最长匹配模式</p>

<p>5、从左边第几个字符开始，以及截取的字符的个数</p>

<p>[root@hadoop ~]# echo ${WEBSITE:2:2}</p>

<p>结果：tp</p>

<p>6、从左边第几个字符开始，一直到结束</p>

<p>[root@hadoop ~]# echo ${WEBSITE:2}</p>

<p>结果：tp://hadoop//centos//huangbo.html</p>

<p>7、从右边第几个字符开始，以及字符的个数</p>

<p>[root@hadoop ~]# echo ${WEBSITE:0-4:2}</p>

<p>结果：ht</p>

<p>8、从右边第几个字符开始，一直到结束</p>

<p>[root@hadoop ~]# echo ${WEBSITE:0-4}</p>

<p>结果：html</p>

<p>9、利用awk进行字符串截取</p>

<p>[root@hadoop ~]# echo $WEBSITE | awk &lsquo;{print substr($1,2,6)}&rsquo;</p>

<p>结果：ttp://</p>

<p>10、利用cut进行字符串截取</p>

<p>[root@hadoop ~]# echo $WEBSITE | cut -b 1-4</p>

<p>http</p>

<p>[root@hadoop ~]# echo $WEBSITE | cut -c 1-4</p>

<p>http</p>

<p>[root@hadoop ~]# echo $WEBSITE | cut -b 1,4</p>

<p>hp</p>

<p>[root@hadoop ~]# echo $WEBSITE | cut -c 1,4</p>

<p>hp</p>

<p>11、获取最后几个字符</p>

<p>[root@hadoop ~]# echo ${WEBSITE:(-3)}</p>

<p>结果：tml</p>

<p>12、截取从倒数第3个字符后的2个字符</p>

<p>[root@hadoop ~]# echo ${WEBSITE:(-3):2}</p>

<p>结果：tm</p>

<h2 id="3-2-字符串替换">3.2.字符串替换</h2>

<p>使用格式：${parameter/pattern/string}</p>

<p>例子：</p>

<p>##定义变量VAR：</p>

<p>[linux@linux ~]$ VAR=&ldquo;hello tom, hello kitty, hello xiaoming&rdquo;</p>

<p>##替换第一个hello：</p>

<p>[linux@linux ~]$ echo ${VAR/hello/hi}</p>

<p>hi tom, hello kitty, hello xiaoming</p>

<p>##替换所有hello：</p>

<p>[linux@linux ~]$ echo ${VAR//hello/hi}</p>

<p>hi tom, hi kitty, hi xiaoming</p>

<h2 id="3-3-获取字符串长度">3.3.获取字符串长度</h2>

<p>在此为大家提供五种方式获取某字符串的长度。</p>

<p>1、使用wc -L命令</p>

<p>[root@hadoop ~]# echo ${WEBSITE} |wc -L</p>

<p>35</p>

<p>2、使用expr的方式去计算</p>

<p>[root@hadoop ~]# expr length ${WEBSITE}</p>

<p>35</p>

<p>3、通过awk + length的方式获取字符串长度</p>

<p>[root@hadoop ~]# echo ${WEBSITE} | awk &lsquo;{print length($0)}&rsquo;</p>

<p>35</p>

<p>4、通过awk的方式计算以&rdquo;&ldquo;分隔的字段个数</p>

<p>[root@hadoop ~]# echo ${WEBSITE} |awk -F &ldquo;&rdquo; &lsquo;{print NF}&rsquo;</p>

<p>35</p>

<p>5、通过#的方式获取字符串（最简单，最常用）</p>

<p>[root@hadoop ~]# echo ${#WEBSITE}</p>

<p>35</p>

<h1 id="4-shell脚本自动安装mysql">4. Shell脚本自动安装MySQL</h1>

<p>安装mysql脚本：</p>

<p>#!/bin/bash</p>

<h2 id="auto-install-mysql">auto install mysql</h2>

<h2 id="假如是第二次装-那么要先停掉服务-并且卸载之前的mysql">假如是第二次装，那么要先停掉服务，并且卸载之前的mysql</h2>

<p>service mysql stop</p>

<p>EXISTS_RPMS=<code>rpm -qa | grep -i mysql</code></p>

<p>echo ${EXISTS_RPMS}</p>

<p>for RPM in ${EXISTS_RPMS}</p>

<p>do</p>

<p>rpm -e &ndash;nodeps ${RPM}</p>

<p>done</p>

<h2 id="删除残留文件">删除残留文件</h2>

<p>rm -fr /usr/lib/mysql</p>

<p>rm -fr /usr/include/mysql</p>

<p>rm -f /etc/my.cnf</p>

<p>rm -fr /var/lib/mysql</p>

<h2 id="从服务器获取安装mysql的rpm包">从服务器获取安装mysql的rpm包</h2>

<p>wget <a href="http://linux/soft/MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm">http://linux/soft/MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm</a></p>

<p>wget <a href="http://linux/soft/MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm">http://linux/soft/MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm</a></p>

<h2 id="删除之前的密码文件-以免产生干扰">删除之前的密码文件，以免产生干扰</h2>

<p>rm -rf /root/.mysql_secret</p>

<h2 id="安装服务器">安装服务器</h2>

<p>rpm -ivh MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm</p>

<h2 id="获取到生成的随机密码">获取到生成的随机密码</h2>

<p>##PSWD=<code>cat /root/.mysql_secret | awk -F ':' '{print substr($4,2,16)}'</code></p>

<p>PSWD=<code>grep -v '^$' /root/.mysql_secret | awk -F ':' '{print
substr($4,2,16)}'</code></p>

<p>##PSWD=${PWD:1:16}</p>

<h2 id="安装客户端">安装客户端</h2>

<p>rpm -ivh MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm</p>

<h2 id="然后删除刚刚下下来的rpm包">然后删除刚刚下下来的rpm包</h2>

<p>rm -rf MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm</p>

<p>rm -rf MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm</p>

<h2 id="提示安装的步骤都完成了">提示安装的步骤都完成了。</h2>

<p>echo &ldquo;install mysql server and client is done .!!!!!!&rdquo;</p>

<h2 id="打印出来刚刚生成的mysql初始密码">打印出来刚刚生成的mysql初始密码</h2>

<p>echo &ldquo;random password is:${PSWD}&rdquo;</p>

<h2 id="开启mysql服务">开启mysql服务</h2>

<p>service mysql start</p>

<p>手动第一次登陆，然后改掉密码：</p>

<p>[root@hadoop bin]# mysql -uroot -pZjVIWvOGD18bT7oX</p>

<p>mysql&gt; set PASSWORD=PASSWORD(&lsquo;root&rsquo;);</p>

<p><a href="https://img.it610.com/image/info8/98a5074de70a4405b73990317915535c.jpg"><img src="https://img.it610.com/image/info8/98a5074de70a4405b73990317915535c.jpg" alt="Linux之Shell
操作实用技巧_第1张图片" /></a></p>

<p>现在就可以写脚本链接mysql进行操作了</p>

<p>[root@hadoop bin]# vi initMysql.sh</p>

<p>#!/bin/bash</p>

<p>mysql -uroot -proot &lt;&lt; EOF</p>

<p>GRANT ALL PRIVILEGES ON <em>.</em> TO &lsquo;root&rsquo;@&lsquo;%&rsquo; IDENTIFIED BY &lsquo;root&rsquo; WITH GRANT
OPTION;</p>

<p>FLUSH PRIVILEGES;</p>

<p>use mysql;</p>

<p>select host, user, password from user;</p>

<p>EOF</p>

<p><a href="https://img.it610.com/image/info8/667923a4b7fd4f3fa94de56a007a6d0d.jpg"><img src="https://img.it610.com/image/info8/667923a4b7fd4f3fa94de56a007a6d0d.jpg" alt="Linux之Shell
操作实用技巧_第2张图片" /></a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:hr">hr <a class="footnote-return" href="#fnref:hr"><sup>[return]</sup></a></li>
<li id="fn:A-Za-z">A-Za-z <a class="footnote-return" href="#fnref:A-Za-z"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>