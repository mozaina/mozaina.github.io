<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>BASHSHELL程序设计简介ZZ | 开发者问答集锦</title>
    <meta property="og:title" content="BASHSHELL程序设计简介ZZ - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="BASHSHELL程序设计简介ZZ">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/bashshell%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8Bzz/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">BASHSHELL程序设计简介ZZ</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>标 题: BASH SHELL 程序设计简介(ZZ)<br />
发信站: 郁金香BBS站 (Wed Apr 18 21:05:52 2007) , 站内信件</p>

<p>BASH SHELL 程序设计简介</p>

<p>译者 : calebjiang mailto:caleb@yamnet.net<br />
作者 : X_console mailto:shellscope@yahoo.com<br />
出处 : <a href="http://www.linuxnewbie.org/nhf/intel/programming/introbashscript.html">http://www.linuxnewbie.org/nhf/intel/programming/introbashscript.html</a></p>

<p>如同在 Linux 中其它的 shell，Bourne Again SHell 不只是一个优秀的指令行式的 she<br />
ll，同时也提供 scripting 语言。Shell scripting 允许你完全利用 shell 的功能，将<br />
需要许多指令执行的多项工作自动化。在你的 Linux 机器上有许多程序是 shell 程序。<br />
如果你对学习他们如何运作，或修改他们感兴趣，基本要素是你必须了解 bash 的语法和语意。除此之外，了解<br />
bash 语言，你能够撰写你个人专属的程序，来完成你要做的事情。<br />
PROGRAMMING OR SCRIPTING?<br />
对于刚开始接触程序设计的新手，常会对于 programming 和 scripting 语言间的差异感<br />
到困惑。Programming 语言通常比 Scripting 语言功能更强大，也更快速。例如：C, C+<br />
+, 和 Java 都是 Programming 语言。Programming 语言通常是从原始码 (一个包含最终<br />
程序如何执行的指令集合文字文件) 开始，经过编译 (建立) 成为一个可执行档。这个可执行档不容易移植到不同<br />
的操作系统中。举例来说，如果你曾在 Linux 上写过 C 的程序，你将不能够在窗口 98<br />
系统上执行这个 C 的程序。要这样做，你必须在窗口 98 系统之下，重新编译原始的程序<br />
代码。Scripting 语言也是从原始码开始，但不需编译成可执行档。而是由一个直译器读入原始码档案里的那<br />
些指令，再执行每个指令。不幸地，直译的程序通常比编译的程序慢，因为直译器必须读<br />
入每个指令。主要的优点是，你能轻松地转换原始码档案到任何的操作系统，并且立刻以<br />
直译的方式执行。bash 是一种 scripting 语言。它对撰写小程序而言是不错的，但如果你打算开发大型的应用程<br />
序，programming 语言可能对你比较有益。其它的 scripting 语言有 Perl, Lisp 和 Tc<br />
l 等等。<br />
WHAT DO YOU NEED TO KNOW? / 那些是你需要知道的？<br />
撰写你自己的 shell 程序，需要知道最基本的 Linux 指令。举例来说，你应该知道要如<br />
何拷贝，移动，产生新档案等等。还有一件事你必须知道，该如何使用文书编辑程序。在<br />
Linux 里有三个主要的文字文件编辑程序 - vi, emacs 和 pico。如果对 vi 或 emacs<br />
并不熟悉，可用 pico 或一些其它容易使用文字文件编辑程序。<br />
WARNING!!! / 警告！！！<br />
别以 root 的身份来练习！任何情况都可能发生！若你在撰写程序时发生意外的错误，导<br />
致系统当掉，我并不负责。你已被警告过了！一定要使用没有 root 权限的一般使用者账<br />
户。你甚至可以产生一个新的使用者，专门来练习 shell 程序设计。这样，最糟的情况只<br />
是这个使用者的目录不见了。<br />
YOUR FIRST BASH PROGRAM / 第一个 BASH 程序<br />
我们的第一个程序会是典型的 &ldquo;Hello World&rdquo; 程序。不要怀疑，若你已有程序设计的经验<br />
，你现在又必须头疼了。然而，这是传统，我何德何能改变传统呢？&rdquo;Hello World&rdquo; 程序<br />
只是将 &ldquo;Hello World&rdquo; 这字眼打印到屏幕上。所以赶快打开你的文字文件编辑程序，键入<br />
下列的内容：<br />
#!/bin/bash<br />
echo &ldquo;Hello World&rdquo;<br />
第一行是告诉 Linux 用 bash 直译器来执行这个程序。在这个范例，bash 是位在 /bin<br />
目录下。如果在你的系统上，bash 是在不同的目录，请对这行做适当的更改。另外，要特<br />
别说明的是，这个直译器是非常重要，所以请确定目录正确否，它告诉 Linux 哪一个直译<br />
器用来执行程序中的那些指令。下一步是把将程序存盘。称它做 hello.sh 好了。完成后，你需要让此程序可以<br />
执行：<br />
xconsole$ chmod 700 ./hello.sh<br />
如果你不知道该如何更改档案的权限，就参考 chmod 的手册(manual page)。一旦更改完<br />
成后，你仅需输入程序的名字，就能执行了：<br />
xconsole$ ./hello.sh<br />
Hello World<br />
就是这个光！就是这个光！你的第一个程序完成了！真的就是这样无聊，没用，然而每个<br />
人都是这样开始的。只需记得这个程序。撰写程序代码，存成档案，再用 chmod 让它可执<br />
行。<br />
COMMANDS, COMMANDS, COMMANDS / 指令，指令，指令<br />
你的第一个程序要做什么呢？打印 &ldquo;Hello World&rdquo; 这两个字到屏幕上。但要怎样做呢？使<br />
用指令。在程序中写的唯一一行程序代码是 echo &ldquo;Hello World&rdquo;。好吧，那一个是指令？<br />
echo。echo 程序带有一个参数，并将此参数打印到屏幕。<br />
所谓参数是指在你所键入的程序名称之后的任何东西。在这个案例中，&rdquo;Hello World&rdquo; 是<br />
参数，它传进 echo 指令中。若你输入这样的指令 ls /home/root ，那么对 ls 而言，<br />
/home/root 是参数。就竟这代表什么呢？代表如果你有一支程序，可将参数打印到屏幕上<br />
，你就不需使用 echo 程序。我们假定有支称为 foo 的程序，能传入一个参数，一个字符串，并且将其打印到屏<br />
幕上。我们能同样地重写我们的程序：<br />
#!/bin/bash<br />
foo &ldquo;Hello World&rdquo;<br />
把它存盘及更改存取模式(chmod)，然后执行：<br />
xconsole$ ./hello<br />
Hello World<br />
结果完全一样。究竟有唯一的程序代码吗？没有。你真的能写任何程序？除非你是 echo<br />
程序的作者。你所做的，是将 echo 程序放在你的 shell 程序内，并给一个参数。在现实<br />
的世界中，例子中 echo 指令的另一选择是 printf 指令。printf 提供比较多的控制，如<br />
果你熟悉 C 语言的程序设计就会明了。事实上，要得到完全相同的结果不必写一个 shell 程序：<br />
xconsole$ echo &ldquo;Hello World&rdquo;<br />
Hello World<br />
bash shell 程序设计提供了多样的控制方式，而且容易学习。就如你刚看到一样，你用<br />
Linux 指令来写你的 shell 程序了。你的 shell 程序是将其它的程序聚集在一起，来执<br />
行特定的任务。<br />
A MORE USEFUL PROGRAM / 更有用的程序<br />
我们将撰写一个程序，功能是移动所有的档案到一个目录内，然后删除此目录及其内容，<br />
然后再产生此目录。这可由下列的指令来完成：<br />
xconsole$ mkdir trash<br />
xconsole$ mv * trash<br />
xconsole$ rm -rf trash<br />
xconsole$ mkdir trash<br />
不需在交谈式的 shell 上敲进所有指令，改用撰写个 shell 程序：<br />
#!/bin/bash<br />
mkdir trash<br />
mv * trash<br />
rm -rf trash<br />
mkdir trash<br />
echo &ldquo;Deleted all files!&rdquo;<br />
把它以 clean.sh 存档，现在你所要做的是执行 clean.sh，它会移动所有的档案到一个目<br />
录，删除他们，再产生目录，而且打印一个讯息告诉你，它已成功地删除所有的档案。所<br />
以记得，如果你发现要做的某些事，要一而再，再而做三地做下去，考虑用个 shell 程序<br />
来自动执行。<br />
COMMENTS / 批注<br />
批注可让你的程序更容易明了，这样并不影响程序的输出结果。目的就是来特别帮你明了<br />
程序。所有在 bash 里的批注，第一个字符都是用井字符号(hash symbol)：&rdquo;#&ldquo;，除了第<br />
一个行 (#!/bin/bash) 外。 第一行并不是批注。在第一行之后，其余以 &ldquo;#&rdquo; 开始的任何<br />
一行都是批注。看下列的程序片段：<br />
#!/bin/bash</p>

<h1 id="这个程序从-1-记录到-10">这个程序从 1 记录到 10：</h1>

<p>for i in 1 2 3 4 5 6 7 8 9 10; do<br />
echo $i<br />
done<br />
即使你不知道 bash 的程序设计，因为批注的关系，也能立刻知道上述的程序在做什么事<br />
。使用批注是很好的习惯。你将发现若未来需要维护你的程序，有批注会比较容易。<br />
VARIABLES / 变数<br />
变量基本上是储存数值的 &ldquo;箱子(boxes)&rdquo; 。有许多理由需要产生变量。做为储存使用者输<br />
入，参数或数字的数值。举下列的程序代码来说：<br />
#!/bin/bash<br />
x=12<br />
echo &ldquo;The value of variable x is $x&rdquo;<br />
刚才所做的，是给 x 变数一个数值 12，而 echo &ldquo;The value of variable x is $x&rdquo; 这<br />
行则是打印出目前变量 x 的值。当你定义一个变量时，不能有任何的空白在设定操作数：<br />
&rdquo;=&rdquo; 之间。语法为：<br />
variable_name=this_value<br />
存取变数的数值藉由变量名称前加一个钱字符号： &ldquo;$&rdquo; 进行。如同上面的例子，我们用<br />
echo $x 来存取变量 x 的数值。<br />
变量有二种类型。区域变量，和环境变量。环境变量是由系统设定的，通常藉由使用 env<br />
指令来运用。环境变量保有特别的数值。举例来说，如果你键入：<br />
xconsole$ echo $SHELL<br />
/bin/bash<br />
你会取得到目前执行 shell 的名字。环境变量被定义在 /etc/profile 和 ~/.bash_prof<br />
ile 中。echo 指令适合用来检查目前区域和环境变量的数值。若你对为何需要使用变量仍<br />
有疑问，在这里有个相当好的例子：<br />
#!/bin/bash<br />
echo &ldquo;The value of x is 12.&rdquo;<br />
echo &ldquo;I have 12 pencils.&rdquo;<br />
echo &ldquo;He told me that the value of x is 12.&rdquo;<br />
echo &ldquo;I am 12 years old.&rdquo;<br />
echo &ldquo;How come the value of x is 12?&rdquo;<br />
好，现在假设你决定要将 x 的数值用 8 代替 12，你要怎么做？你必须改变所有的程序代<br />
码中有 x is 12 的那几行。等等&hellip; 程序代码中也有其它行有数字 12。你也应该改变吗<br />
？不，因为他们与 x 无关。感到困惑了？现在，在这里有相同的例子，但它使用变量：</p>

<p>#!/bin/bash<br />
x=12 # 设定变量 x 的值为 12<br />
echo &ldquo;The value of x is $x.&rdquo;<br />
echo &ldquo;I have 12 pencils.&rdquo;<br />
echo &ldquo;He told me that the value of x is $x.&rdquo;<br />
echo &ldquo;I am 12 years old.&rdquo; echo &ldquo;How come the value of x is $x?&rdquo;<br />
在这里，我们看见 $x 会打印出变量 x 目前的数值 12。所以现在，如果你要改变 x 的数<br />
值为 8，必须做的是将 x=12 这行改成 x=8，程序会自动地将所有有 $x 那几行显示成 8<br />
，代替原本的 12。其它行并不受影响。变量也有其它重要的用途，稍后会看得到。<br />
CONTROL STRUCTURES / 控制性结构<br />
控制性结构让你的程序可做判断而且使他们更紧凑。更重要的是，它让我们可做错误的检<br />
查。到目前为止，我们所写的程序是从头到尾执行，直到没有指令为止。举例来说：<br />
#!/bin/bash<br />
cp /etc/foo .<br />
echo &ldquo;Done.&rdquo;<br />
这个短短的 shell 程序，称它 bar.sh 好了，拷贝一个名为 /etc/foo 的档案到目前的目<br />
录内，并打印 &ldquo;Done&rdquo; 到屏幕上。这个程序只在一个条件之下可运作，就是你必须有个名<br />
为 /etc/foo 的档案，否则会发生什么：<br />
xconsole$ ./bar.sh<br />
cp: /etc/foo: No such file or directory<br />
Done.<br />
就像你看到的，有问题。并不是执行你的程序的每个人，他们的系统里有 /etc/foo 这个<br />
档。如果你的程序能检查是否有 /etc/foo 档案存在，然后若真的存在，再着手进行拷贝<br />
，否则，就离开。这样或许会是比较好的。在虚拟的程序代码中，将会是像这样：<br />
if /etc/code exists, then<br />
copy /etc/code to the current directory<br />
print &ldquo;Done.&rdquo; to the screen.<br />
otherwise,<br />
print &ldquo;This file does not exist.&rdquo; to the screen<br />
exit<br />
能在 bash 中实作吗？当然可以！bash 的控制性结构计有，if, while, until, for 和<br />
case。每个结构都是成对的，意思是起始用个 &ldquo;标签&rdquo;，终止也用个 &ldquo;标签&rdquo;。举例来说，<br />
if 结构开始为 if，结束时为 fi。控制性结构并不是在你系统上的程序，他们是在 bash<br />
中的一项功能(feature)。这意谓着，你将可写自己的程序代码，并不只是将其它程序包在 shell 程序中。<br />
if &hellip; else &hellip; elif &hellip; fi<br />
最常用的结构之一就是 if 结构。它允许你的程序下判断，就像是 &ldquo;如果这条件存在，执<br />
行它，其余的，执行其它的东西&rdquo;。要发挥 if 结构的功效，我们就必须使用 test 指令。<br />
test 检查条件的状况，也就是说，存在的档案，权限，或类似和不同等状况。以下为重写<br />
过的 bar.sh：<br />
#!/bin/bash<br />
if test -f /etc/foo<br />
then</p>

<h1 id="档案存在-则拷贝档案然后打印出一个讯息">档案存在，则拷贝档案然后打印出一个讯息</h1>

<p>cp /etc/foo .<br />
echo &ldquo;Done.&rdquo;<br />
else</p>

<h1 id="档案不存在-则打印出一个讯息然后离开">档案不存在，则打印出一个讯息然后离开</h1>

<p>echo &ldquo;This file does not exist.&rdquo;<br />
exit<br />
fi<br />
注意我们在 then 和 else 之后的叙述用锯齿状排列。锯齿状排列是选择性的，但这样感<br />
觉上容易明了，哪些叙述在哪一条件下被执行。现在执行这个程序。如果你有 /etc/foo<br />
这个档案，那么它将会拷贝档案，否则，它将会打印错误讯息。test 检查是否档案 /etc<br />
/foo 存在。选项 -f 检查参数是否是一般性的档案。以下是 test 的选项：<br />
-d 检查此 file 是否是一个目录<br />
-e 检查此 file 是否存在<br />
-f 检查此 file 是否为一般的档案<br />
-g 检查此 file 是否有 SGID 权限<br />
-r 检查此 file 是否可以读取<br />
-s 检查此 file 大小是否不为 0<br />
-u 检查此 file 是否有 SUID 权限<br />
-w 检查此 file 是否可以写入<br />
-x 检查此 file 是否可以执行<br />
else 是用在若第一个条件不匹配时，还要你的程序做别的东西。另有个 elif，可用在 i<br />
f 结构中还有另一个 if 的时候。基本上 elif 代表 &ldquo;else if&rdquo;，当第一个条件不匹配，<br />
而你想要测试另外的条件时，可用它。<br />
若你认为下列 if 和 test 的格式不易阅读：<br />
if test -f /etc/foo<br />
then<br />
然后，你可以像这样做：<br />
if [ -f /etc/foo ]; then<br />
用中括号形式的 test。若你有 C 语言的程序设计经验，这种语法可能感觉更亲切。需注<br />
意必须用空白(white space)围住两个中括号。分号 &ldquo;;&rdquo; 是用来告诉 shell 指令到此为止<br />
。分号后的所有叙述会被当成新的一行叙述处理。基本上这样做比较容易阅读，当然啰，<br />
也可以不这样做；若你喜欢，可把 then 放在下一行上。<br />
当变数和 test 一起时，最好的作法是用双引号将变数围住。例如：<br />
if [ &ldquo;$name&rdquo; -eq 5 ]; then<br />
while &hellip; do &hellip; done<br />
while 语法结构是一个递归结构。基本上它的运作是 &ldquo;当这个条件为真的时候，做这直到<br />
条件不再为真时&rdquo;。让我们看这个例子：<br />
#!/bin/bash<br />
while true; do<br />
echo &ldquo;Press CTRL-C to quit.&rdquo;<br />
done<br />
true 实际上是支程序。它所做的是不断地让回路不会停止。使用 true 是为了让程序慢一<br />
些，因 shell 程序必须先呼叫它起来然后在执行它。也可用另外一个选择 - 冒号 &ldquo;:&rdquo; 指<br />
令：<br />
#!/bin/bash<br />
while :; do<br />
echo &ldquo;Press CTRL-C to quit.&rdquo;<br />
done<br />
这样也可达到相同的结果，但是会比较快些，因它是内建在 bash 的一项功能(feature)。<br />
唯一的不同是你为了速度而牺牲了可读性。选一个你感觉较亲切的用吧。或许这里有一个<br />
更有用的例子，使用变量：<br />
#!/bin/bash<br />
x=0; # 设定 x 初值为 0<br />
while [ &ldquo;$x&rdquo; -le 10 ]; do<br />
echo &ldquo;Current value of x: $x&rdquo;</p>

<h1 id="增加-x-的数值">增加 x 的数值：</h1>

<p>x=$(expr $x + 1)<br />
sleep 1<br />
done<br />
就如你所见的，我们正在这儿使用 test (用中括号的形式) 检查变量 x 的状态。选项 -<br />
le 检查是否 x 小于，或等于与数值 10。上面的程序代码换做口语来说，即 &ldquo;当 x 小于<br />
10 或与 10相同时，打印出 x 目前的数值，然后将 x 目前的数值增加 1 。&rdquo; 。sleep<br />
1 的作用只是把程序暂停一秒，你也可以移除这行。在此，你可发现我们在这里所做的是测试相等状况。检查是<br />
否变量等于某一数值，若是如此，则执行动作。以下列出相等状况的测试：<br />
检查在数目之间的相等：<br />
x -eq y 检查是否 x 和 y 相等<br />
x -ne y 检查是否 x 和 y 不相等<br />
x -gt y 检查是否 x 大于 y<br />
x -lt y 检查是否 x 小于 y<br />
检查在字符串之间的相等：<br />
x = y 检查是否 x 与 y 相同<br />
x != y 检查是否 x 与 y 不相同<br />
-n x 若 x 不是空字符串(null)则为真<br />
-z x 若 x 是空字符串(null)则为真<br />
上面我们写的递归叙述应该不难了解，除了这一行：<br />
x=$(expr $x + 1)<br />
上面的批注告诉我们，那是让 x 每次增加 1。但 $(&hellip;) 是什么意思呢？它是变数吗？事<br />
实上，它是告诉 shell 你要执行指令 expr $x + 1，而且要将结果设定到 x。任何包含在<br />
$(&hellip;) 的指令将会被执行：<br />
#!/bin/bash<br />
me=$(whoami)<br />
echo &ldquo;I am $me.&rdquo;<br />
去试试，你会了解我的意思。上述的程序代码能用下列的叙述，获得相同的结果：<br />
#!/bin/bash<br />
echo &ldquo;I am $(whoami).&rdquo;<br />
你可自行决定哪一个对你是比较容易的阅读。有另外的方法也可以执行指令或将指令的结<br />
果设给变量。这稍后再详细解释。现在，先使用 $(&hellip;)。<br />
until &hellip; do &hellip; done<br />
until 的语法结构与 while 的语法结构是非常相似的。唯一的不同是条件判断相反。whi<br />
le 语法结构，当条件为真的时候才执行循环。until 语法结构，执行循环直到条件为真的<br />
时候停止。所以基本上它是 &ldquo;执行它，直到这个条件是真的&rdquo;。这里有个例子：<br />
#!/bin/bash<br />
x=0<br />
until [ &ldquo;$x&rdquo; -ge 10 ]; then<br />
echo &ldquo;Current value of x: $x&rdquo;<br />
x=$(expr $x + 1)<br />
sleep 1<br />
done<br />
这段程序代码可能看起来很熟悉。试一试，看看结果为何。基本上，until 会继续循环，<br />
一直到 x 大于或等于 10。当到达数值 10 的时候，回路将停止。因此，最后一次打印出<br />
x 的数值将会是 9。<br />
for &hellip; in &hellip; do &hellip; done<br />
for 的语法结构是，当你须透过变量的范围执行循环时所使用。举例来说，你可写个小程<br />
序于每秒打印出 10 点：<br />
#!/bin/bash<br />
echo -n &ldquo;Checking system for errors&rdquo;<br />
for dots in 1 2 3 4 5 6 7 8 9 10; do<br />
echo -n &ldquo;.&rdquo;<br />
echo &ldquo;System clean.&rdquo;<br />
done<br />
此例中，你可能不知道，-n 选项是让 echo 自动地加一行。试一试，一次有 -n 选项，一<br />
次没有，就会了解我的意思。变量 dots 从 1 循环到 10，而且在每个数值印出一个点。<br />
再试下面这个例子，看看我所谓的变量透过这些值执行循环的涵义：<br />
#!/bin/bash<br />
for x in paper pencil pen; do<br />
echo &ldquo;The value of variable x is: $x&rdquo;<br />
sleep 1<br />
done<br />
当你执行这个程序时，会看见 x 的数值首先是 paper，然后变为下一个数值 pencil， 然<br />
后再下一个数值 pen。当发现没有数值时，循环就结束。<br />
这里有个更实用的例子。下面的程序加扩展名 .html 到目前目录里的所有档案：<br />
#!/bin/bash<br />
for file in *; do<br />
echo &ldquo;Adding .html extension to $file&hellip;&rdquo;<br />
mv $file $file.html<br />
sleep 1<br />
done<br />
* 是个万用字符。它代表 &ldquo;在目前目录的所有东西&rdquo;，在这个例子中，是指目前目录里的所<br />
有档案。目前目录里的所有档案会加入 .html 的扩展名。回想变量 file 会递归过所有的<br />
数值，即目前目录里的所有档案。然后用 mv 来重新命名变量 file，增加 .html 扩展名<br />
。<br />
case &hellip; in &hellip; done<br />
case 的语法结构是非常相似于 if 的语法结构。基本上它是有许多条件被检查，而你不想<br />
一而再地使用 if 时用的。看下面这段程序：<br />
#!/bin/bash<br />
x=5 # 设定 x 初值为 5</p>

<h1 id="现在检查-x-的数值">现在检查 x 的数值：</h1>

<p>case $x in<br />
0) echo &ldquo;Value of x is 0.&rdquo;<br />
;;<br />
5) echo &ldquo;Value of x is 5.&rdquo;<br />
;;<br />
9) echo &ldquo;Value of x is 9.&rdquo;<br />
;;<br />
<em>) echo &ldquo;Unrecognized value.&rdquo;<br />
esac<br />
这个 case 语法结构将检查 x 数值 3 种可能性。此例中，首先它检查是否 x 有数值为<br />
0，然后检查数值是否是 5，再检查数值是否是 9。最后，如果所有的检查失败，它会产生<br />
讯息 &ldquo;Unrecognized value.&ldquo;。记得 &ldquo;</em>&rdquo; 表示 &ldquo;每件事物&rdquo;，而在这里代表 &ldquo;除了被叙述<br />
的东西之外，任何其它的数值&rdquo;。如果 x 是任何其它的数值而非 0， 5，或 9，这数值会落进入 * 类别中。当使<br />
用 case 的时候，每个条件必须以二个分号结束。当你能使用 if 的时候，为什么要烦恼<br />
使用 case 呢？这里有相同结果的程序，是以 if 写成。看哪一个写得比较快，比较容易<br />
阅读：<br />
#!/bin/bash<br />
x=5 # # 设定 x 初值为 5<br />
if [ &ldquo;$x&rdquo; -eq 0 ]; then<br />
echo &ldquo;Value of x is 0.&rdquo;<br />
elif [ &ldquo;$x&rdquo; -eq 5 ]; then<br />
echo &ldquo;Value of x is 5.&rdquo;<br />
elif [ &ldquo;$x&rdquo; -eq 9 ]; then<br />
echo &ldquo;Value of x is 9.&rdquo;<br />
else<br />
echo &ldquo;Unrecognized value.&rdquo;<br />
fi<br />
QUOTATIONS / 引号<br />
引号在 shell 程序设计中扮演一个重要的角色，总共有三种形式的引号。他们分别是双引<br />
号(double quote)： &ldquo;，单引号(forward quote)： &lsquo;，和反单引号(back quote)： `。每<br />
一种都有不同的涵义吗？答案是对的。<br />
双引号主要被用来保有一串字并留住空白。举例来说，&rdquo;This string contains whitespa<br />
ce.&rdquo; - 这个字符串包含空白，被两个双引号所围住的字符串，会被当做一个自变量处理。<br />
例如下面这些例子：<br />
xconsole$ mkdir hello world<br />
xconsole$ ls -F<br />
hello/ world/<br />
在这里我们产生二个新的目录。mkdir 将字符串 hello 和 world 当做两个自变量，因此<br />
产生二个新的目录。现在，你如下这样做，看看会发生什么事：<br />
xconsole$ mkdir &ldquo;hello world&rdquo;<br />
xconsole$ ls -F<br />
hello/ hello world/ world/<br />
它产生了一个有二个字的新目录。双引号将二个字成为一个自变量。没有双引号，mkdir<br />
认为 hello 是第一个自变量，world 是第二个。<br />
单引号主要被用来处理变量。如果一个变量被围在双引号中，它的数值将会被解释出。如<br />
果它是被单引号围住，它的数值将不会被解释。想弄得更清处些，试试下面的例子：<br />
#!/bin/bash<br />
x=5 # 设定 x 初值为 5</p>

<h1 id="使用双引号">使用双引号</h1>

<p>echo &ldquo;Using double quotes, the value of x is: $x&rdquo;</p>

<h1 id="使用单引号">使用单引号</h1>

<p>echo &lsquo;Using forward quotes, the value of x is: $x&rsquo;<br />
看见不同了吗？若你不打算在一字符串中使用变量，可用双引号围住字符串。此例中你是<br />
否觉得奇怪呢？对的，单引号能用来保留住空白，如同双引号一般：<br />
xconsole$ mkdir &lsquo;hello world&rsquo;<br />
xconsole$ ls -F<br />
hello world/<br />
反单引号与双引号及单引号是完全地不同，它们不是用来保护空白。若你回想起在之前我<br />
们用的这个叙述：<br />
x=$(expr $x + 1)<br />
就如你所知的，指令 expr $x + 1 的结果被指定为变量 x。相同的结果能用反单引号来完<br />
成：<br />
x=<code>expr $x + 1</code><br />
你应该使用哪一个呢？无论那一个你较喜欢。会发现反单引号用得比较 $(&hellip;) 还多。然<br />
而，我发现 $(&hellip;) 比较容易阅读，尤其是有如这样的一个例子时：<br />
$!/bin/bash<br />
echo &ldquo;I am <code>whoami</code>&rdquo;<br />
ARITHMETIC WITH BASH / 用 BASH 算术<br />
bash 允许你执行算术语法。如你所见，算术以 expr 指令方式执行。然而，这就像 true<br />
的指令，执行速度较慢。原因是为了要执行 true 和 expr，shell 必须去启动他们。比<br />
较好的方法是使用 shell 内建功能(feature)，会较快。如同之前所见，true 指令的另一<br />
选择是 &ldquo;:&rdquo; 指令。而 expr 指令的另一选择是将算数表达式围在 $((&hellip;)) 之内。这不同于 $(&hellip;)，括号的数<br />
目已告诉你了。让我们试试：<br />
#!/bin/bash<br />
x=8 # 设定 x 初值为 8<br />
y=4 # 设定 y 初值为 4</p>

<h1 id="现在我们将-x-和-y-的总合之值设定到-z">现在我们将 x 和 y 的总合之值设定到 z：</h1>

<p>z=$(($x + $y))<br />
echo &ldquo;The sum of $x + $y is $z&rdquo;<br />
如同以往，无论你选择那一个，纯粹地是由你决定。如果你感觉使用 expr 比 $((&hellip;))<br />
亲切，就使用它吧。<br />
bash 能够执行加减乘除和余数运算。每个动作有相对应的操作数：<br />
ACTION / 动作 OPERATOR / 操作数<br />
Addition /加 +<br />
Subtraction / 减 -<br />
Multiplication / 乘 *<br />
Division / 除 /<br />
Modulus / 余数 %<br />
每个人应该很熟悉前面的四则运算。你不知道余数是什么？就是当二个数值相除时，所剩<br />
余的数值。这里有个在 bash 中算数的例子：<br />
#!/bin/bash<br />
x=5 # 设定 x 初值为 5<br />
y=3 # 设定 y 初值为 3<br />
add=$(($x + $y)) # 将 x 和 y 相加，并将其和设定到变量 add<br />
sub=$(($x - $y)) # 将 x 数值减 y 数值，并将其差设定到变量 sub<br />
mul=$(($x * $y)) # 将 x 和 y 相乘，并将其积设定到变量 mul<br />
div=$(($x / $y)) # 将 x 数值除以 y 数值，并将其商数设定到变量 div<br />
mod=$(($x % $y)) # 将 x 数值除以 y 数值，并将其余数设定到变量 mod</p>

<h1 id="印出这些答案">印出这些答案：</h1>

<p>echo &ldquo;Sum: $add&rdquo;<br />
echo &ldquo;Difference: $sub&rdquo;<br />
echo &ldquo;Product: $mul&rdquo;<br />
echo &ldquo;Quotient: $div&rdquo;<br />
echo &ldquo;Remainder: $mod&rdquo;<br />
上面的程序代码也能够改用 expr。例如，你可用 add=$(expr $x + $y) 或 add=<code>expr $  
x + $y</code> 来代替 add=$(($x + $y))。<br />
READING USER INPUT / 读取使用者输入<br />
现在我们已进入有趣的部份了。你可让程序与使用者产生互动，而取得使用者输入的指令<br />
为 read。read 是内建在 bash 的指令，需要使用变量，如下面范例一样：<br />
#!/bin/bash</p>

<h1 id="取得到使用者的名字-印出问候语">取得到使用者的名字，印出问候语</h1>

<p>echo -n &ldquo;Enter your name: &ldquo;<br />
read user_name<br />
echo &ldquo;Hello $user_name!&rdquo;<br />
在这里变量为 user_name。当然啰，你能换成你想要的。read 会等待使用者输入一些东西<br />
，然后按 ENTER。如果使用者不输入任何东西，read 会继续等候直到 ENTER 键被按下。<br />
如果 ENTER 键被按下时并没有任何东西被输入，read 仍会执行下一行程序代码。试一试<br />
。这里有个相同的例子，只是这次我们检查看看是否使用者有输入任何东西：<br />
#!/bin/bash</p>

<h1 id="取得到使用者的名字-印出问候语-1">取得到使用者的名字，印出问候语</h1>

<p>echo -n &ldquo;Enter your name: &ldquo;<br />
read user_name</p>

<h1 id="使用者没有输入任何东西">使用者没有输入任何东西：</h1>

<p>if [ -z &ldquo;$user_name&rdquo; ]; then<br />
echo &ldquo;You did not tell me your name!&rdquo;<br />
exit<br />
fi<br />
echo &ldquo;Hello $user_name!&rdquo;<br />
在这程序中，如果使用者没有输入任何东西就按下 Enter键，我们的程序会抱怨而且退出<br />
。否则，它会打印出问候语。取得使用者输入，对需要使用者输入某事物的交谈式程序而<br />
言，是非常有用的。举例来说，你能够建立简单的数据库，并且让使用者输入数据加入到<br />
你的数据库中。<br />
FUNCTIONS / 函式<br />
函式能让程序撰写变得更容易，也较容易维护。基本上它是将程序打散成多个小段落。一<br />
个函式执行一项你所定义的功能，若你想要它传回一个值也行。在我继续介绍之前，这里<br />
有个 shell 程序使用函式的例子：<br />
#!/bin/bash</p>

<h1 id="函式-hello-只是打印出一个讯息">函式 hello() 只是打印出一个讯息</h1>

<p>hello()<br />
{<br />
echo &ldquo;You are in function hello()&rdquo;<br />
}<br />
echo &ldquo;Calling function hello()&hellip;&rdquo;</p>

<h1 id="呼叫-hello-函式">呼叫 hello() 函式：</h1>

<p>hello<br />
echo &ldquo;You are now out of function hello()&rdquo;<br />
试试去执行上述程序。函式 hello() 只有一个目的，那就是打印一个讯息。函式当然是拿<br />
来做比较复杂的工作。在上述的例子中，我们像下面那行藉由函式名称来呼叫 hello() 函<br />
式：<br />
hello<br />
当这行被执行时，bash 会搜寻程序中 hello() 这行。发现它在程序上端，然后执行它的<br />
内容。<br />
函式总藉由它的名字来呼叫，就如我们在上述程序中看到的一样。当撰写函式时，你可用<br />
function_name() 开始，如我们在上面范例所做的一样，或者用更清楚的表示方式 func<br />
tion function_name()。这里是函式 hello() 的另一种写法：<br />
function hello()<br />
{<br />
echo &ldquo;You are in function hello()&rdquo;<br />
}<br />
函式总有一组空的左右小括号： &ldquo;()&ldquo;，再接一组大括号： &ldquo;{&hellip;}&ldquo;。这组大括号标示此函<br />
式的开始与结束。包括在这组大括号中的任何程序代码都会被执行，而且只属于此函式。<br />
函式在被呼叫之前，应该先被定义。让我们再次看看上述的程序，只是这次在函式被定义<br />
之前，我们先呼叫它：<br />
#!/bin/bash<br />
echo &ldquo;Calling function hello()&hellip;&rdquo;</p>

<h1 id="呼叫-hello-函式-1">呼叫 hello() 函式：</h1>

<p>hello echo &ldquo;You are now out of function hello()&rdquo;</p>

<h1 id="函式-hello-只是打印出一个讯息-1">函式 hello() 只是打印出一个讯息</h1>

<p>hello()<br />
{<br />
echo &ldquo;You are in function hello()&rdquo;<br />
}<br />
以下是我们试着执行它所得的结果：<br />
xconsole$ ./hello.sh<br />
Calling function hello()&hellip;<br />
./hello.sh: hello: command not found<br />
You are now out of function hello()<br />
就如你所见的，我们得到一个错误讯息。因此，你的函式会在你的程序代码的开始，或者<br />
至少在你呼叫函式之前。这里有另一个使用函式的例子：<br />
#!/bin/bash</p>

<h1 id="admin-sh-administrative-tool">admin.sh - administrative tool</h1>

<h1 id="函式-new-user-建立一个新的使用者账号">函式 new_user() 建立一个新的使用者账号</h1>

<p>new_user()<br />
{<br />
echo &ldquo;Preparing to add a new user&hellip;&rdquo;<br />
sleep 2<br />
adduser # 执行 adduser 程序<br />
}<br />
echo &ldquo;1. Add user&rdquo;<br />
echo &ldquo;2. Exit&rdquo;<br />
echo &ldquo;Enter your choice: &ldquo;<br />
read choice<br />
case $choice in<br />
1) adduser # 呼叫 adduser() 函式<br />
;;<br />
*) exit<br />
;;<br />
esac<br />
为了要能正常的执行，你需要登入成 root 使用者，因为 adduser 只有 root 才能执行。<br />
希望这个例子 (虽然很短) 能展现出函式的功用。<br />
TRAPPING<br />
你可以在程序中使用内建的 trap 指令捕捉信号。这是优美地退出程序的好方法。举例来<br />
说，如果你有个程序正在执行，按下 CTRL-C 将会送给程序一个岔断信号，因而砍掉此程<br />
序。trap 允许你去抓取这个信号，并且让你有机会让程序继续，或告诉使用者，程序将要<br />
离开。trap 使用下列的语法：<br />
trap action signal<br />
action 为当信号被启动时你所要做的动作，而 signal 是你要寻找的信号。信号的列表能<br />
藉由使用指令 trap -l 取得。当在 shell 程序使用信号的时候，会省略信号最前面的三<br />
个字母，通常是 SIG。举例来说，岔断信号(interrupt signal) 是 SIGINT。而在 shell<br />
程序，只使用 INT。也可使用伴随着信号名称旁的信号编号。举例来说，SIGINT 数字型式信号的数值为 2。试<br />
试下列的程序：<br />
#!/bin/bash</p>

<h1 id="使用-trap-指令">使用 trap 指令</h1>

<h1 id="trap-ctrl-c-执行-sorry-函式">trap CTRL-C 执行 sorry() 函式：</h1>

<p>trap sorry INT</p>

<h1 id="函式-sorry-打印出一个讯息">函式 sorry() 打印出一个讯息</h1>

<p>sorry()<br />
{<br />
echo &ldquo;I&rsquo;m sorry Dave. I can&rsquo;t do that.&rdquo;<br />
sleep 3<br />
}</p>

<h1 id="从-10-数到-1">从 10 数到 1：</h1>

<p>for i in 10 9 8 7 6 5 4 3 2 1; do<br />
$i seconds until system failure.&rdquo;<br />
sleep 1<br />
done<br />
echo &ldquo;System failure.&rdquo;<br />
现在，当程序正在执行并且往下数的时候，按 CTRL-C，将会送一个岔断信号给程序。然而<br />
，此信号将会被 trap 指令捕捉，而执行 sorry() 函式。你可用 &ldquo;&rdquo;&rdquo; 置换动作，来忽略<br />
信号。也可用减号： &ldquo;-&ldquo;，让 trap 重新设定。举例来说：</p>

<h1 id="如果-sigint-被捕捉-执行-sorry-函式">如果 SIGINT 被捕捉﹐执行 sorry() 函式：</h1>

<p>trap sorry INT</p>

<h1 id="重新设定-trap">重新设定 trap：</h1>

<p>trap - INT</p>

<h1 id="当-sigint-被捕捉时-什么也不做">当 SIGINT 被捕捉时，什么也不做：</h1>

<p>trap &ldquo; INT<br />
当你重新设定 trap 的时候，内定值为最初的动作，即中断程序而且砍掉它。当你设成什<br />
么也不做的时候，就是这样，什么事也不做。程序将继续执行，忽略讯号。<br />
AND &amp; OR<br />
我们已看过控制性结构的使用，和他们的妙用。还有二件额外的东西要来探讨。那就是 A<br />
ND： &ldquo;&amp;&amp;&rdquo; 及 OR： &ldquo;||&rdquo; 叙述。AND 叙述看起来像这样：<br />
condition_1 &amp;&amp; condition_2<br />
AND 叙述首先检查最左边的条件。如果它是真的，然后检查第二个条件。如果也是真的，<br />
那么其余的程序代码会被执行。如果 condition_1 响应是错的，那么 condition_2 将不<br />
会被执行。换句话说：<br />
if(如果) condition_1 是真的，AND(而且) if(如果) condition_2 是真的，then(然后)<br />
&hellip;<br />
在这里有使用 AND 叙述的例子：<br />
#!/bin/bash<br />
x=5<br />
y=10<br />
if [ &ldquo;$x&rdquo; -eq 5 ] &amp;&amp; [ &ldquo;$y&rdquo; -eq 10 ]; then<br />
echo &ldquo;Both conditions are true.&rdquo;<br />
else<br />
echo &ldquo;The conditions are not true.&rdquo;<br />
fi<br />
我们发现 x 和 y 两者的值都是我们要检查的，所以这些条件都是真的。假如果改变 x=5<br />
的数值为 x=12，然后重新执行程序，会发现条件现在是错的。<br />
OR 叙述的用法相似。唯一的不同就是它检查是否最左边的叙述是错的，如果是错的，然后<br />
到下一个叙述，再继续下一个：<br />
condition_1 || condition_2<br />
在虚拟的程序代码(pseudo code)中，这将翻成下列叙述：<br />
if(如果) condition_1 是真的，OR(或者) if(如果) condition_2 是真的，then(然后).<br />
..<br />
因此，至少其中一个测试条件是真的，后面的程序代码就会被执行：<br />
#!/bin/bash<br />
x=3<br />
y=2<br />
if [ &ldquo;$x&rdquo; -eq 5 ] || [ &ldquo;$y&rdquo; -eq 2 ]; then<br />
echo &ldquo;One of the conditions is true.&rdquo;<br />
else<br />
echo &ldquo;None of the conditions are true.&rdquo;<br />
fi<br />
在这里，你看到其中一个条件是真的。然而，改变 y 的数值再执行程序，你会看见没有条<br />
件是真的。<br />
想想看，若 if 的结构能用来代替 AND 及 OR，将需要用巢状的叙述。巢状的意思是 if<br />
结构中还有另一个 if 结构。巢状的情况当然也可能是在其它的控制性结构上。这里有个<br />
巢状 if 结构的例子，同之前的 AND 程序代码：<br />
#!/bin/bash<br />
x=5<br />
y=10<br />
if [ &ldquo;$x&rdquo; -eq 5 ]; then<br />
if [ &ldquo;$y&rdquo; -eq 10 ]; then<br />
echo &ldquo;Both conditions are true.&rdquo;<br />
else<br />
echo &ldquo;The conditions are not true.&rdquo;<br />
fi<br />
fi<br />
也可达成与 AND 叙述相同的目的，但比较难以了解，且需写较多的程序代码。省点力气吧<br />
，去用 AND 及 OR 叙述。<br />
USING ARGUMENTS<br />
你可能已经注意到 Linux 里的大部分程序都不是交互式的。你需要键入参数，否则会得到<br />
&ldquo;usage&rdquo; 的讯息。拿 more 指令来说，如果你不输入文件名称在它之后，会响应一个 &ldquo;u<br />
sage&rdquo; 的讯息。你的 shell 程序有可能运用到参数，因此，你需要知道 &ldquo;$#&rdquo; 变量。这个<br />
变量代表这个程序的参数个数。举例来说，执行一个程序如下：<br />
xconsole$ foo argument<br />
$# 的数值是 1，因为程序只有一个参数。若有二个参数，那么 $# 的数值是 2。除此之外<br />
，命令列上的每个字，即程序的名称 (在此例为 foo)，和参数，能被参考成 shell 程序<br />
中的变量。foo 会是 $0，argument 会是 $1，最多可达 9 个变数，接在 $0 (为程序名称<br />
) 之后，$1 到 $9 对应每个参数。让我们瞧瞧这个动作：<br />
#!/bin/bash</p>

<h1 id="打印第一个参数">打印第一个参数</h1>

<h1 id="首先检查是否有一个参数">首先检查是否有一个参数：</h1>

<p>if [ &ldquo;$#&rdquo; -ne 1 ]; then<br />
echo &ldquo;usage: $0 &ldquo;<br />
fi<br />
echo &ldquo;The argument is $1&rdquo;<br />
这个程序预期在执行时有一个，而且是只有一个参数。如果输入少于一个参数，或多过一<br />
个，程序会打印用法讯息。否则，会有一个参数传进程序，而这 shell 程序会印出你传进<br />
的参数。回想一下，$0 是程序的名称。这就是它为什么被用在 &ldquo;usage&rdquo; 讯息的原因。最<br />
后一行使用到 $1。再回想一下，$1 的数值是传进此程序的参数。<br />
REDIRECTION AND PIPING / 转向及管线<br />
一般来说，当你执行指令的时候，它的输出被打印到屏幕上头。举例来说：<br />
xconsole$ echo &ldquo;Hello World&rdquo;<br />
Hello World<br />
转向允许将输出结果转到别处，通常像是档案。&rdquo;&gt;&rdquo; 操作数用来做转向输出。想想它就像<br />
个箭头，告诉输出该往哪里去。这里有个重新转向输出到档案的例子：<br />
xconsole$ echo &ldquo;Hello World&rdquo;&gt; foo.file<br />
xconsole$ cat foo.file<br />
Hello World<br />
这里， echo &ldquo;Hello World&rdquo; 的输出会被重新转向到 foo.file 的档案。我们读取档案的<br />
内容时候，看到了原本的输出。 &ldquo;&gt;&rdquo; 操作数有个问题，它将会覆盖任何的档案内容。若你<br />
要用附加的方式该怎么做？你就必须使用附加操作数： &ldquo;&gt;&gt;&ldquo;。用法与转向操作数相同，但<br />
它将不会覆盖档案的内容，而是附加于后。<br />
最后，是有关管线。管线允许你将一个程序的输出结果，当做另外一个程序的输入。管线<br />
的运作是靠使用管线操作数： &ldquo;|&ldquo;。注意这不是 &ldquo;L&rdquo; 的小写字母。管线符号的输入是按下<br />
SHIFT- 这个组合键。下面有个管线的例子：<br />
xconsole$ cat /etc/passwd | grep xconsole<br />
xconsole:x:1002:100:X_console,,,:/home/xconsole:/bin/bash<br />
此处，我们读入整个 /etc/passwd 然后将输出用管线送到 grep，grep 依次搜寻有包含字<br />
符串 xconsole 的那一整行，然后将其结果打印到屏幕。你也能混用转向的功能，将最后<br />
的输出存成一个档案：<br />
xconsole$ cat /etc/passwd | grep xconsole &gt; foo.file<br />
xconsole$ cat foo.file<br />
xconsole:x:1002:100:X_console,,,:/home/xconsole:/bin/bash<br />
成功了。/etc/passwd 被读取，然后整个的输出被管线送进 grep 搜寻字符串 xconsole。<br />
最后的输出被转向储存进 foo.file 档案内。将来你会发现转向及管线对写自己的 shell<br />
程序来说，是相当有用的工具。<br />
TEMPORARY FILES / 暂存档<br />
通常，你会有需要产生临时文件的时候。这个档案可能是暂时保存一些数据，或只是与程<br />
序一起运作。一旦程序的目的被完成，此档案通常会被删除。当产生档案的时候，必须给<br />
它一个档名。问题是，你产生的档案，不能是在所要产生档案的目录中已存在。否则，有<br />
可能会覆盖掉重要的数据。为了要产生唯一档名的暂时档案，你需要使用 &ldquo;$$&rdquo; 符号接在文件名的前缀或字尾。举<br />
例来说，你要用 hello 这个名称产生暂时的档案。而此时刚好有个使用者执行你的程序，<br />
而有个名为 hello 的档案，所以会与你的程序临时文件相冲突。藉由产生一个称为 hell<br />
o.$$ 或 $$hello 的档案，将会产生出唯一档名的档案。试试：<br />
xconsole$ touch hello<br />
xconsole$ ls<br />
hello<br />
xconsole$ touch hello.$$<br />
xconsole$ ls<br />
hello hello.689<br />
你的暂存档就在那里。<br />
RETURN VALUES / 传回数值<br />
大多数的程序会依他们如何结束离开而传回一个数值。举例来说，如果你仔细看 grep 的<br />
手册，它会告诉我们如果搜寻字符串有被找到，grep 会传回一 0 值，没被找到，则传回<br />
一 1 的值。我们为什么要关切程序的传回值呢？有各种不同的理由。假设我们要检查是否<br />
系统上存在个特定的使用者。方法之一是在 /etc/passwd 檔中 grep 此位使用者的名字。让我们假设使用者的名<br />
字是 foobar：<br />
xconsole$ grep &ldquo;foobar&rdquo; /etc/passwd<br />
xconsole$<br />
没有输出。这表示 grep 没有发现匹配的字符串。然而若有个讯息印出说没有找到匹配的<br />
字符串，会更有帮助的。这就是你需要抓取程序的传回值的时候。有个特别的变量保存程<br />
序的传回值。这个变量就是 $?。看看下列一段程序代码：<br />
#!/bin/bash</p>

<h1 id="grep-使用者-foobar-并用导引所有输出到-dev-null">grep 使用者 foobar，并用导引所有输出到 /dev/null：</h1>

<p>grep &ldquo;foobar&rdquo; &gt; /dev/null 2&gt;&amp;1</p>

<h1 id="抓取传回值-并且做些动作">抓取传回值，并且做些动作：</h1>

<p>if [ &ldquo;$?&rdquo; -eq 0 ]; then<br />
echo &ldquo;Match found.&rdquo;<br />
exit<br />
else<br />
echo &ldquo;No match found.&rdquo;<br />
fi<br />
现在当你执行此程序时，它会抓取 grep 的传回值。如果值等于 0，那么有匹配的字符串<br />
被找到，而且适当的讯息会被列出。否则，它将会列出没有匹配的字符串被找到。这是个<br />
从程序取得传回值非常基本的使用范例。当你继续练习的时候，会发现有很多时候你会需<br />
要用程序的传回值来做你所要的。<br />
现在，如果你的 shell 程序要离开时，要传回什么数值呢？ exit 指令可带一个参数，一<br />
个数字传回。一般来说，数字 0 用来指成功地离开，没有错误发生。其它高于或低于 0<br />
的数字表示有错误发生。这是由你，程序设计者决定的。让我们来看这个程序：<br />
#!/bin/bash<br />
if [ -f &ldquo;/etc/passwd&rdquo; ]; then<br />
echo &ldquo;Password file exists.&rdquo;<br />
exit 0<br />
else<br />
echo &ldquo;No such file.&rdquo;<br />
exit 1<br />
fi<br />
藉由于离开时指定的传回值，其它你所写的 shell 程序若有用到此程序，将可抓取它的传<br />
回值。<br />
函式也可传回数值。是利用 return 的指令来施行，可传回一个参数，数字。除了它只适<br />
用于函式以外，用法就如同 exit 一样。如以下的例子：<br />
check_passwd()<br />
{</p>

<h1 id="检查是否-passwd-档案存在">检查是否 passwd 档案存在：</h1>

<p>if [ -f &ldquo;/etc/passwd&rdquo; ]; then<br />
echo &ldquo;Password file exists.&rdquo;</p>

<h1 id="有找到-传回一个-0-值">有找到，传回一个 0 值：</h1>

<p>return 0<br />
else</p>

<h1 id="找不到-传回一个-1-值">找不到，传回一个 1 值：</h1>

<p>echo &ldquo;No such file.&rdquo;<br />
return 1<br />
fi<br />
}</p>

<h1 id="从函式-check-passwd-取得传回值">从函式 check_passwd 取得传回值：</h1>

<p>foo=check_passwd</p>

<h1 id="检查数值">检查数值：</h1>

<p>if [ &ldquo;$foo&rdquo; -eq 0 ]; then<br />
echo &ldquo;File exists.&rdquo;<br />
exit 0<br />
else<br />
echo &ldquo;No such file.&rdquo;<br />
exit 1<br />
fi<br />
注意看这程序代码，应不难了解。我们于一开始时，使用一个叫做 foo 的变量，来储存函<br />
式 check_passwd() 的传回值。函式 check_passwd()，用来检查看看是否 /etc/passwd<br />
档案存在。如果存在，我们返回一 0 值，否则返回一 1 值。现在，如果档案存在而且一<br />
0 值被传回，那么变数 foo 的数值会是 0。如果一 1 值被传回，那么变数 foo 的数值将会是 1。接下来的动<br />
作是检查变量 foo 的数值，打印出适当的讯息，然后离开，并传回一数值 0 (成功) 或<br />
1 (失败) 。<br />
CONCLUSION / 结论<br />
虽然已读完了本篇 bash 程序设计的简介，但你的程序设计研习并未完成，还有很多要学<br />
习。如我所言，这只是个简介。然而，这足以让你开始修改并且撰写属于你自己的 shell<br />
程序。如果你真地要精通 shell 程序，我推荐买本 O&rsquo;Reilly &amp; Associates, Inc. 出版<br />
的 Learning the bash shell, 2nd Edition。bash 程序对日常的管理使用相当好用，但是若你用在大型的计划<br />
上，用更强大的语言像 C 或 Perl 较适当。祝好运。<br />
X_console shellscope@yahoo.com</p>

<p>--</p>

<p>※ 修改:·xpmo 於 04月18日21:08:14 修改本文·[FROM: 郁金香BBS站]<br />
※ 来源:．郁金香BBS站 <a href="http://bbs.stu.edu.cn[FROM:">http://bbs.stu.edu.cn[FROM:</a> 10.^_^.8.11]<br />
--<br />
※ 来源:·郁金香BBS站 bbs.stu.edu.cn·[FROM: 郁金香BBS站]</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
[转寄][转贴][删除文章][修改文章][本讨论区][上一篇][下一篇][回文章][同主题阅读]</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>