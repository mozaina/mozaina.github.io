<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Vim编辑器与Shell命令脚本 | 开发者问答集锦</title>
    <meta property="og:title" content="Vim编辑器与Shell命令脚本 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Vim编辑器与Shell命令脚本">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8Eshell%E5%91%BD%E4%BB%A4%E8%84%9A%E6%9C%AC/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Vim编辑器与Shell命令脚本</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>1 Vim文本编辑器</p>

<p>如何使用Vim编辑器来编写、修改文档，然后通过逐个配置主机名称、系统网卡以及Yum软件仓库参数文件等</p>

<p>在Linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数”。而且在日常工作中大家也肯定免不了要编写文档，这些工作都是通过文本编辑器来完成的.</p>

<p>Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了三种模式—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这三种模式的操作区别以及模式之间的切换方法。</p>

<p>Ø 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p>

<p>Ø 输入模式：正常的文本录入。</p>

<p>Ø 末行模式：保存或退出文档，以及设置编辑环境。</p>

<p><a href="https://img.it610.com/image/info8/14125e0a546b4ee69d02fe81ffc18ca3.jpg"><img src="https://img.it610.com/image/info8/14125e0a546b4ee69d02fe81ffc18ca3.jpg" alt="Vim编辑器与Shell命令脚本_第1张图片" /></a></p>

<p>在每次运行Vim编辑器时，默认进入命令模式，此时需要先切换到输入模式后再进行文档编写工作，而每次在编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档的保存或退出操作。在Vim中，无法直接从输入模式切换到末行模式。Vim编辑器中内置的命令有成百上千种用法，能够帮助更快地掌握Vim编辑器，总结了在命令模式中最常用的一些命令。</p>

<p>Vim中常用的命令</p>

<p>命令</p>

<p>|</p>

<p>作用</p>

<p>&mdash;|&mdash;</p>

<p>dd</p>

<p>|</p>

<p>删除（剪切）光标所在整行</p>

<p>5dd</p>

<p>|</p>

<p>删除（剪切）从光标处开始的5行</p>

<p>yy</p>

<p>|</p>

<p>复制光标所在整行</p>

<p>5yy</p>

<p>|</p>

<p>复制从光标处开始的5行</p>

<p>n</p>

<p>|</p>

<p>显示搜索命令定位到的下一个字符串</p>

<p>N</p>

<p>|</p>

<p>显示搜索命令定位到的上一个字符串</p>

<p>u</p>

<p>|</p>

<p>撤销上一步的操作</p>

<p>p</p>

<p>|</p>

<p>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</p>

<p>末行模式主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了。末行模式中可用的命令如表4-2所示。</p>

<p>表4-2 末行模式中可用的命令</p>

<p>命令</p>

<p>|</p>

<p>作用</p>

<p>&mdash;|&mdash;</p>

<p>:w</p>

<p>|</p>

<p>保存</p>

<p>:q</p>

<p>|</p>

<p>退出</p>

<p>:q!</p>

<p>|</p>

<p>强制退出（放弃对文档的修改内容）</p>

<p>:wq!</p>

<p>|</p>

<p>强制保存退出</p>

<p>:set nu</p>

<p>|</p>

<p>显示行号</p>

<p>:set nonu</p>

<p>|</p>

<p>不显示行号</p>

<p>:命令</p>

<p>|</p>

<p>执行该命令</p>

<p>:整数</p>

<p>|</p>

<p>跳转到该行</p>

<p>续表</p>

<p>命令</p>

<p>|</p>

<p>作用</p>

<p>&mdash;|&mdash;</p>

<p>:s/one/two</p>

<p>|</p>

<p>将当前光标所在行的第一个one替换成two</p>

<p>:s/one/two/g</p>

<p>|</p>

<p>将当前光标所在行的所有one替换成two</p>

<p>:%s/one/two/g</p>

<p>|</p>

<p>将全文中的所有one替换成two</p>

<p>?字符串</p>

<p>|</p>

<p>在文本中从下至上搜索该字符串</p>

<p>/字符串</p>

<p>|</p>

<p>在文本中从上至下搜索该字符串</p>

<p>1、 编写简单文档</p>

<p>编写脚本文档的第1步就是给文档取个名字，这里将其命名为practice.txt。如果存在该文档，则是打开它。如果不存在，则是创建一个临时的输入文件</p>

<p><a href="https://img.it610.com/image/info8/d838fa71ed6b4e89bd58a0676cc4725b.jpg"><img src="https://img.it610.com/image/info8/d838fa71ed6b4e89bd58a0676cc4725b.jpg" alt="Vim编辑器与Shell命令脚本_第2张图片" /></a></p>

<p>开practice.txt文档后，默认进入的是Vim编辑器的命令模式。此时只能执行该模式下的命令，而不能随意输入文本内容，我们需要切换到输入模式才可以编写文档。</p>

<p>在图4-1中提到，可以分别使用a、i、o三个键从命令模式切换到输入模式。其中，a键与i键分别是在光标后面一位和光标当前位置切换到输入模式，而o键则是在光标的下面再创建一个空行，此时可敲击a键进入到编辑器的输入模式，如图所示</p>

<p><a href="https://img.it610.com/image/info8/bc1b2839bcf74b96ba9bdfd96c834e84.jpg"><img src="https://img.it610.com/image/info8/bc1b2839bcf74b96ba9bdfd96c834e84.jpg" alt="Vim编辑器与Shell命令脚本_第3张图片" /></a></p>

<p>进入输入模式后，可以随意输入文本内容，Vim编辑器不会把您输入的文本内容当作命令而执行，如图4-4所示。</p>

<p><a href="https://img.it610.com/image/info8/85bf9f2c3776437f8f7398d60ded545a.jpg"><img src="https://img.it610.com/image/info8/85bf9f2c3776437f8f7398d60ded545a.jpg" alt="Vim编辑器与Shell命令脚本_第4张图片" /></a></p>

<p>图切换至编辑器的输入模式</p>

<p><a href="https://img.it610.com/image/info8/f4773073e2664a6497ec59cadcf841d2.jpg"><img src="https://img.it610.com/image/info8/f4773073e2664a6497ec59cadcf841d2.jpg" alt="Vim编辑器与Shell命令脚本_第5张图片" /></a></p>

<p>图在编辑器中输入文本内容</p>

<p>Vim编辑器的命令模式</p>

<p>在编写完之后，想要保存并退出，必须先敲击键盘Esc键从输入模式返回命令模式，如图4-5所示。然后再输入:wq!切换到末行模式才能完成保存退出操作，如图4-6所示。</p>

<p><a href="https://img.it610.com/image/info8/f20c1b0400cc4db1a5c17559d6dd2ac6.jpg"><img src="https://img.it610.com/image/info8/f20c1b0400cc4db1a5c17559d6dd2ac6.jpg" alt="Vim编辑器与Shell命令脚本_第6张图片" /></a></p>

<p>图4-6 Vim编辑器的末行模式</p>

<p>当在末行模式中输入:wq!命令时，就意味着强制保存并退出文档。然后便可以用cat命令查看保存后的文档内容了，如图4-7所示。</p>

<p><a href="https://img.it610.com/image/info8/f00b60ce5026448e84bc5bb62ddb81ee.jpg"><img src="https://img.it610.com/image/info8/f00b60ce5026448e84bc5bb62ddb81ee.jpg" alt="Vim编辑器与Shell命令脚本_第7张图片" /></a></p>

<p>图4-7 查看文档的内容</p>

<p>是不是很简单？！继续编辑这个文档。因为要在原有文本内容的下面追加内容，所以在命令模式中敲击o键进入输入模式更会高效，操作如图4-8、图4-9与图4-10所示。</p>

<p>图4-8 再次通过Vim编辑器编写文档</p>

<p><a href="https://img.it610.com/image/info8/15c785f8ec5a46e088048add18abe9fc.jpg"><img src="https://img.it610.com/image/info8/15c785f8ec5a46e088048add18abe9fc.jpg" alt="Vim编辑器与Shell命令脚本_第8张图片" /></a></p>

<p>图4-9 进入Vim编辑器的输入模式</p>

<p><a href="https://img.it610.com/image/info8/9cfdb323deaa4940bd479d7716725e44.jpg"><img src="https://img.it610.com/image/info8/9cfdb323deaa4940bd479d7716725e44.jpg" alt="Vim编辑器与Shell命令脚本_第9张图片" /></a></p>

<p>图4-10 追加写入一行文本内容</p>

<p><a href="https://img.it610.com/image/info8/15a0879280e64f42aea1b16dc227e4ec.jpg"><img src="https://img.it610.com/image/info8/15a0879280e64f42aea1b16dc227e4ec.jpg" alt="Vim编辑器与Shell命令脚本_第10张图片" /></a></p>

<p>因为此时已经修改了文本内容，所以Vim编辑器在我们尝试直接退出文档而不保存的时候就会拒绝我们的操作了。此时只能强制退出才可以结束本次输入操作，如图4-11、图4-12和图4-13所示。</p>

<p>图4-11 尝试退出文本编辑器</p>

<p><a href="https://img.it610.com/image/info8/72ef9f5ff0f640a3bceee4b6c8e15739.jpg"><img src="https://img.it610.com/image/info8/72ef9f5ff0f640a3bceee4b6c8e15739.jpg" alt="Vim编辑器与Shell命令脚本_第11张图片" /></a></p>

<p>图4-12 因文件已被修改而拒绝退出操作</p>

<p><a href="https://img.it610.com/image/info8/8a5fb69fa52b4203a25fd34e54dc47ee.jpg"><img src="https://img.it610.com/image/info8/8a5fb69fa52b4203a25fd34e54dc47ee.jpg" alt="Vim编辑器与Shell命令脚本_第12张图片" /></a></p>

<p>现在大家也算是具有了一些Vim编辑器的实战经验了，应该也感觉没有想象中那么难吧。现在查看文本的内容，果然发现追加输入的内容并没有被保存下来，如图4-14
所示。可强制退出</p>

<p><a href="https://img.it610.com/image/info8/924fe0e3fe3b4bf3aef93b5632922ebb.jpg"><img src="https://img.it610.com/image/info8/924fe0e3fe3b4bf3aef93b5632922ebb.jpg" alt="Vim编辑器与Shell命令脚本_第13张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/ba0f1bab3c5048ffa620835aa6c49bdb.jpg"><img src="https://img.it610.com/image/info8/ba0f1bab3c5048ffa620835aa6c49bdb.jpg" alt="Vim编辑器与Shell命令脚本_第14张图片" /></a></p>

<h3 id="配置主机名称">配置主机名称</h3>

<p>为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有IP地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在Linux系统中，主机名大多保存在/etc/hostname文件中，接下来将/etc/hostname文件的内容修改为“linuxprobe.com”，步骤如下。</p>

<p><strong>第1步</strong> ：使用Vim编辑器修改“/etc/hostname”主机名称文件。</p>

<p><strong>第2步</strong>
：把原始主机名称删除后追加“linuxprobe.com”。注意，使用Vim编辑器修改主机名称文件后，要在末行模式下执行:wq!命令才能保存并退出文档。</p>

<p><strong>第3步</strong> ：保存并退出文档，然后使用hostname命令检查是否修改成功。</p>

<p>[root@linuxprobe ~]# vim /etc/hostname</p>

<p>linuxprobe.com</p>

<p>hostname命令用于查看当前的主机名称，但有时主机名称的改变不会立即同步到系统中，所以如果发现修改完成后还显示原来的主机名称，可重启虚拟机后再行查看：</p>

<p>[root@linuxprobe ~]# hostname</p>

<p>linuxprobe.com</p>

<h3 id="4-1-3-配置网卡信息">4.1.3 配置网卡信息</h3>

<p>网卡IP地址配置的是否正确是两台服务器是否可以相互通信的前提。在Linux系统中，一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件，因此这个小任务不仅可以帮助您练习使用Vim编辑器，而且也为您后面学习Linux中的各种服务配置打下了坚实的基础。</p>

<p>如果您具备一定的运维经验或者熟悉早期的Linux系统，则在学习本书时会遇到一些不容易接受的差异变化。在RHEL 5、RHEL
6中，网卡配置文件的前缀为eth，第1块网卡为eth0，第2块网卡为eth1；以此类推。而在RHEL
7中，网卡配置文件的前缀则以ifcfg开始，加上网卡名称共同组成了网卡配置文件的名字，例如ifcfg-
eno16777736；好在除了文件名变化外也没有其他大的区别。</p>

<p>现在有一个名称为ifcfg-eno16777736的网卡设备，我们将其配置为开机自启动，并且IP地址、子网、网关等信息由人工指定，其步骤应该如下所示。</p>

<p><strong>第1步</strong> ：首先切换到/etc/sysconfig/network-scripts目录中（存放着网卡的配置文件）。</p>

<p><strong>第2步</strong> ：使用Vim编辑器修改网卡文件ifcfg-
eno16777736，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用ifconfig命令自行确认各自网卡的默认名称。</p>

<p>Ø 设备类型：TYPE=Ethernet</p>

<p>Ø 地址分配模式：BOOTPROTO=static</p>

<p>Ø 网卡名称：NAME=eno16777736</p>

<p>Ø 是否启动：ONBOOT=yes</p>

<p>Ø  IP地址：IPADDR=192.168.10.10</p>

<p>Ø 子网掩码：NETMASK=255.255.255.0</p>

<p>Ø  网关地址：GATEWAY=192.168.10.1</p>

<p>Ø DNS地址：DNS1=192.168.10.1</p>

<p><strong>第3步</strong> ：重启网络服务并测试网络是否联通。</p>

<p>进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：</p>

<p>[root@linuxprobe ~]# cd /etc/sysconfig/network-scripts/</p>

<p>[root@linuxprobe network-scripts]# vim ifcfg-eno16777736</p>

<p>TYPE=Ethernet</p>

<p>BOOTPROTO=static</p>

<p>NAME=eno16777736</p>

<p>ONBOOT=yes</p>

<p>IPADDR=192.168.10.10</p>

<p>NETMASK=255.255.255.0</p>

<p>GATEWAY=192.168.10.1</p>

<p>DNS1=192.168.10.1</p>

<p>执行重启网卡设备的命令（在正常情况下不会有提示信息），然后通过ping命令测试网络能否联通。由于在Linux系统中ping命令不会自动终止，因此需要手动按下Ctrl-
c键来强行结束进程。</p>

<p>[root@linuxprobe network-scripts]# systemctl restart network</p>

<p>[root@linuxprobe network-scripts]# ping 192.168.10.10</p>

<p>PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.</p>

<p>64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.081 ms</p>

<p>64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.083 ms</p>

<p>64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.059 ms</p>

<p>64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.097 ms</p>

<p>^C</p>

<p>-&ndash; 192.168.10.10 ping statistics &mdash;</p>

<p>4 packets transmitted, 4 received, 0% packet loss, time 2999ms</p>

<p>rtt min/avg/max/mdev = 0.059/0.080/0.097/0.013 ms</p>

<h3 id="配置yum软件仓库">配置Yum软件仓库</h3>

<p>本书前面讲到，Yum软件仓库的作用是为了进一步简化RPM管理软件的难度以及自动分析所需软件包及其依赖关系的技术。可以把Yum想象成是一个硕大的软件仓库，里面保存有几乎所有常用的工具，而且只需要说出所需的软件包名称，系统就会自动为您搞定一切。</p>

<p>既然要使用Yum软件仓库，就要先把它搭建起来，然后将其配置规则确定好才行。搭建并配置Yum软件仓库的大致步骤如下所示。</p>

<p><strong>第1步</strong> ：进入到/etc/yum.repos.d/目录中（因为该目录存放着Yum软件仓库的配置文件）。</p>

<p><strong>第2步</strong>
：使用Vim编辑器创建一个名为rhel7.repo的新配置文件（文件名称可随意，但后缀必须为.repo），逐项写入下面加粗的配置参数并保存退出（不要写后面的中文注释）。</p>

<p>Ø <strong>[rhel-media]</strong> ：Yum软件仓库唯一标识符，避免与其他仓库冲突。</p>

<p>Ø <strong>name=linuxprobe</strong> ：Yum软件仓库的名称描述，易于识别仓库用处。</p>

<p>Ø <strong>baseurl=file:///media/cdrom</strong>
：提供的方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..）。</p>

<p>Ø <strong>enabled=1</strong> ：设置此源是否可用；1为可用，0为禁用。</p>

<p>Ø <strong>gpgcheck=1</strong> ：设置此源是否校验文件；1为校验，0为不校验。</p>

<p>Ø <strong>gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release</strong>
：若上面参数开启校验，那么请指定公钥文件地址。</p>

<p><strong>第3步</strong> ：按配置参数的路径挂载光盘，并把光盘挂载信息写入到/etc/fstab文件中。</p>

<p><strong>第4步</strong> ：使用“yum install httpd -y”命令检查Yum软件仓库是否已经可用。</p>

<p>进入/etc/yum.repos.d目录中后创建Yum配置文件：</p>

<p>[root@linuxprobe ~]# cd /etc/yum.repos.d/</p>

<p>[root@linuxprobe yum.repos.d]# vim rhel7.repo</p>

<p>[rhel7]</p>

<p>name=rhel7</p>

<p>baseurl=file:///media/cdrom</p>

<p>enabled=1</p>

<p>gpgcheck=0</p>

<p>创建挂载点后进行挂载操作，并设置成开机自动挂载。尝试使用Yum软件仓库来安装Web服务，出现 <strong>Complete</strong> ！则代表配置正确：</p>

<p>[root@linuxprobe yum.repos.d]# mkdir -p /media/cdrom</p>

<p>[root@linuxprobe yum.repos.d]# mount /dev/cdrom /media/cdrom</p>

<p>mount: /dev/sr0 is write-protected, mounting read-only</p>

<p>[root@linuxprobe yum.repos.d]# vim /etc/fstab</p>

<p>/dev/cdrom /media/cdrom iso9660 defaults 0 0</p>

<p>[root@linuxprobe ~]# yum install httpd</p>

<p>Loaded plugins: langpacks, product-id, subscription-manager</p>

<p>………………省略部分输出信息………………</p>

<p>Dependencies Resolved</p>

<p>===============================================================================</p>

<p>Package Arch Version Repository Size</p>

<p>===============================================================================</p>

<p>Installing:</p>

<p>httpd x86_64 2.4.6-17.el7 rhel 1.2 M</p>

<p>Installing for dependencies:</p>

<p>apr x86_64 1.4.8-3.el7 rhel 103 k</p>

<p>apr-util x86_64 1.5.2-6.el7 rhel 92 k</p>

<p>httpd-tools x86_64 2.4.6-17.el7 rhel 77 k</p>

<p>mailcap noarch 2.1.41-2.el7 rhel 31 k</p>

<p>Transaction Summary</p>

<p>===============================================================================</p>

<p>Install 1 Package (+4 Dependent packages)</p>

<p>Total download size: 1.5 M</p>

<p>Installed size: 4.3 M</p>

<p>Is this ok [y/d/N]: <strong>y</strong></p>

<p>Downloading packages:</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>………………省略部分输出信息………………</p>

<p><strong>Complete!</strong></p>

<h2 id="2-编写shell脚本">2 . 编写Shell脚本</h2>

<hr />

<p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有两种：交互式和批处理。</p>

<p>Ø 交互式（Interactive）：用户每输入一条命令就立即执行。</p>

<p>Ø 批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p>

<p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p>

<p>查看SHELL变量可以发现当前系统已经默认使用Bash作为命令行终端解释器了：</p>

<p>[root@linuxprobe ~]# echo $SHELL</p>

<p>/bin/bash</p>

<h3 id="编写简单的脚本">编写简单的脚本</h3>

<p>估计读者在看完上文中有关Shell脚本的复杂描述后，会累觉不爱吧。但是，上文指的是一个高级Shell脚本的编写原则，其实使用Vim编辑器把Linux命令按照顺序依次写入到一个文件中，这就是一个简单的脚本了。</p>

<p>例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：</p>

<p>[root@linuxprobe ~]# vim example.sh</p>

<p>#!/bin/bash</p>

<p>#For Example BY linuxprobe.com</p>

<p>pwd</p>

<p>ls -al</p>

<p>Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上，以表示是一个脚本文件。在上面的这个example.sh脚本中实际上出现了三种不同的元素：第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本；第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的Linux命令了。什么？！你们不相信这么简单就编写出来了一个脚本程序，那我们来执行一下看看结果：</p>

<p>[root@linuxprobe ~]# bash example.sh</p>

<p>/root/Desktop</p>

<p>total 8</p>

<p>drwxr-xr-x. 2 root root 23 Jul 23 17:31 .</p>

<p>dr-xr-x&mdash;. 14 root root 4096 Jul 23 17:31 ..</p>

<p>-rwxr&ndash;r&ndash;. 1 root root 55 Jul 23 17:31 example.sh</p>

<p>除了上面用bash解释器命令直接运行Shell脚本文件外，第二种运行脚本程序的方法是通过输入完整路径的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚本文件增加执行权限即可。</p>

<p>[root@linuxprobe ~]# ./example.sh</p>

<p>bash: ./Example.sh: Permission denied</p>

<p>[root@linuxprobe ~]# chmod u+x example.sh</p>

<p>[root@linuxprobe ~]# ./example.sh</p>

<p>/root/Desktop</p>

<p>total 8</p>

<p>drwxr-xr-x. 2 root root 23 Jul 23 17:31 .</p>

<p>dr-xr-x&mdash;. 14 root root 4096 Jul 23 17:31 ..</p>

<p>-rwxr&ndash;r&ndash;. 1 root root 55 Jul 23 17:31 example.sh</p>

<h3 id="接收用户的参数">接收用户的参数</h3>

<p>但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板了。为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。</p>

<p>其实，Linux系统中的Shell脚本语言早就考虑到了这些，已经内设了用于接收参数的变量，变量之间可以使用空格间隔。例如$0对应的是当前Shell脚本程序的名称，$#对应的是总共有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第N个位置的参数值，如图4-15所示。</p>

<p><a href="https://img.it610.com/image/info8/63d800ffafd241b9a82fc1488e60e89c.jpg"><img src="https://img.it610.com/image/info8/63d800ffafd241b9a82fc1488e60e89c.jpg" alt="" /></a></p>

<p>图4-15 Shell脚本程序中的参数位置变量</p>

<p>理论过后我们来练习一下。尝试编写一个脚本程序示例，通过引用上面的变量参数来看下真实效果：</p>

<p>[root@linuxprobe ~]# vim example.sh</p>

<p>#!/bin/bash</p>

<p>echo &ldquo;当前脚本名称为$0&rdquo;</p>

<p>echo &ldquo;总共有$#个参数，分别是$*。&rdquo;</p>

<p>echo &ldquo;第1个参数为$1，第5个为$5。&rdquo;</p>

<p>[root@linuxprobe ~]# sh example.sh one two three four five six</p>

<p>当前脚本名称为example.sh</p>

<p>总共有6个参数，分别是one two three four five six。</p>

<p>第1个参数为one，第5个为five。</p>

<h3 id="判断用户的参数">判断用户的参数</h3>

<p>学习是一个登堂入室、由浅入深的过程。在学习完Linux命令、掌握Shell脚本语法变量和接收用户输入的信息之后，就要踏上新的高度—能够进一步处理接收到的用户参数。</p>

<p>系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。条件测试语法的执行格式如图所示。切记，条件表达式两边均应有一个空格。</p>

<p><a href="https://img.it610.com/image/info8/a60e74dbd3c7442a81e9277b963cd988.jpg"><img src="https://img.it610.com/image/info8/a60e74dbd3c7442a81e9277b963cd988.jpg" alt="" /></a></p>

<p>图4-16 条件测试语句的执行格式</p>

<p>按照测试对象来划分，条件测试语句可以分为4种：</p>

<p>Ø 文件测试语句；</p>

<p>Ø 逻辑测试语句；</p>

<p>Ø 整数值比较语句；</p>

<p>Ø 字符串比较语句。</p>

<p>文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表4-3所示。</p>

<p>表4-3 文件测试所用的参数</p>

<p>运算符</p>

<p>|</p>

<p>作用</p>

<p>&mdash;|&mdash;</p>

<p>-d</p>

<p>|</p>

<p>测试文件是否为目录类型</p>

<p>-e</p>

<p>|</p>

<p>测试文件是否存在</p>

<p>-f</p>

<p>|</p>

<p>判断是否为一般文件</p>

<p>-r</p>

<p>|</p>

<p>测试当前用户是否有权限读取</p>

<p>-w</p>

<p>|</p>

<p>测试当前用户是否有权限写入</p>

<p>-x</p>

<p>|</p>

<p>测试当前用户是否有权限执行</p>

<p>下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着目录不存在：</p>

<p>[root@linuxprobe ~]# [ -d /etc/fstab ]</p>

<p>[root@linuxprobe ~]# echo $?</p>

<p>1</p>

<p>再使用文件测试语句来判断/etc/fstab是否为一般文件，如果返回值为0，则代表文件存在，且为一般文件：</p>

<p>[root@linuxprobe ~]# [ -f /etc/fstab ]</p>

<p>[root@linuxprobe ~]# echo $?</p>

<p>0</p>

<p>逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&amp;&amp;，它表示当前面的命令执行成功后才会执行它后面的命令，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。</p>

<p>[root@linuxprobe ~]# [ -e /dev/cdrom ] &amp;&amp; echo &ldquo;Exist&rdquo;</p>

<p>Exist</p>

<p>除了逻辑“与”外，还有逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的命令执行失败后才会执行它后面的命令，因此可以用来结合系统环境变量USER来判断当前登录的用户是否为非管理员身份：</p>

<p>[root@linuxprobe ~]# echo $USER</p>

<p>root</p>

<p>[root@linuxprobe ~]# [ $USER = root ] || echo &ldquo;user&rdquo;</p>

<p>[root@linuxprobe ~]# su - linuxprobe</p>

<p>[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo &ldquo;user&rdquo;</p>

<p>user</p>

<p>第三种逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果则将其变成正确的。</p>

<p>我们现在切换回到root管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：</p>

<p>[linuxprobe@linuxprobe ~]$ exit</p>

<p>logout</p>

<p>[root@linuxprobe root]# [ ! $USER = root ] || echo &ldquo;administrator&rdquo;</p>

<p>administrator</p>

<p>就技术图书的写作来讲，一般有两种套路：让读者真正搞懂技术了；让读者觉得自己搞懂技术了。因此市面上很多浅显的图书会让读者在学完之后感觉进步特别快，这基本上是作者有意为之，目的就是让您觉得“图书很有料，自己收获很大”，但是在步入工作岗位后就露出短板吃大亏。增加一个综合的示例，一方面作为前述知识的总结，另一方面帮助读者夯实基础，能够在今后工作中更灵活地使用逻辑符号。</p>

<p>当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的USER变量名称是否等于root，然后用逻辑运算符“非”进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运算符输出user字样；或条件不满足则会通过逻辑“或”运算符输出root字样，而如果前面的&amp;&amp;不成立才会执行后面的||符号。</p>

<p>[root@linuxprobe ~]# [ ! $USER = root ] &amp;&amp; echo &ldquo;user&rdquo; || echo &ldquo;root&rdquo;</p>

<p>root</p>

<p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表所示。</p>

<p>可用的整数比较运算符</p>

<p>运算符</p>

<p>|</p>

<p>作用</p>

<p>&mdash;|&mdash;</p>

<p>-eq</p>

<p>|</p>

<p>是否等于</p>

<p>-ne</p>

<p>|</p>

<p>是否不等于</p>

<p>-gt</p>

<p>|</p>

<p>是否大于</p>

<p>-lt</p>

<p>|</p>

<p>是否小于</p>

<p>-le</p>

<p>|</p>

<p>是否等于或小于</p>

<p>-ge</p>

<p>|</p>

<p>是否大于或等于</p>

<p>接下来小试牛刀。我们先测试一下10是否大于10以及10是否等于10（通过输出的返回值内容来判断）：</p>

<p>[root@linuxprobe ~]# [ 10 -gt 10 ]</p>

<p>[root@linuxprobe ~]# echo $?</p>

<p><strong>1</strong></p>

<p>[root@linuxprobe ~]# [ 10 -eq 10 ]</p>

<p>[root@linuxprobe ~]# echo $?</p>

<p><strong>0</strong></p>

<p>曾经讲过free命令，它可以用来获取当前系统正在使用及可用的内存量信息。接下来先使用free-m命令查看内存使用量情况（单位为MB），然后通过grep
Mem:命令过滤出剩余内存量的行，再用awk&rsquo;{print $4}&lsquo;命令只保留第四列，最后用FreeMem=<code>语句</code>的方式把语句内执行的结果赋值给变量。</p>

<p>这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。</p>

<p>[root@linuxprobe ~]# free -m</p>

<p>total used free shared buffers cached</p>

<p><strong>Mem:</strong> 1826 1244 <strong>582</strong> 9 1 413</p>

<p>-/+ buffers/cache: 830 996</p>

<p>Swap: 2047 0 2047</p>

<p>[root@linuxprobe ~]# free -m | grep Mem:</p>

<p>Mem: 1826 1244 582 9</p>

<p>[root@linuxprobe ~]# free -m | grep Mem: | awk &lsquo;{print $4}&rsquo;</p>

<p>582</p>

<p>[root@linuxprobe ~]# FreeMem=<code>free -m | grep Mem: | awk '{print $4}'</code></p>

<p>[root@linuxprobe ~]# echo $FreeMem</p>

<p>582</p>

<p>上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于1024，若小于则会提示“InsufficientMemory”（内存不足）的字样：</p>

<p>[root@linuxprobe ~]# [ $FreeMem -lt 1024 ] &amp;&amp; echo &ldquo;Insufficient Memory&rdquo;</p>

<p>Insufficient Memory</p>

<p>字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表4-5所示。</p>

<p>表4-5 常见的字符串比较运算符</p>

<p>运算符</p>

<p>|</p>

<p>作用</p>

<p>&mdash;|&mdash;</p>

<p>=</p>

<p>|</p>

<p>比较字符串内容是否相同</p>

<p>!=</p>

<p>|</p>

<p>比较字符串内容是否不同</p>

<p>-z</p>

<p>|</p>

<p>判断字符串内容是否为空</p>

<p>接下来通过判断String变量是否为空值，进而判断是否定义了这个变量：</p>

<p>[root@linuxprobe ~]# [ -z $String]</p>

<p>[root@linuxprobe ~]# echo $?</p>

<p><strong>0</strong></p>

<p>再尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值LANG不是英语（en.US）时，则会满足逻辑测试条件并输出“Not
en.US”（非英语）的字样：</p>

<p>[root@linuxprobe ~]# echo $LANG</p>

<p>en_US.UTF-8</p>

<p>[root@linuxprobe ~]# [ $LANG != &ldquo;en.US&rdquo; ] &amp;&amp; echo &ldquo;Not en.US&rdquo;</p>

<p>Not en.US</p>

<h2 id="3-流程控制语句">3 流程控制语句</h2>

<hr />

<p>尽管此时可以通过使用Linux命令、管道符、重定向以及条件测试语句来编写最基本的Shell脚本，但是这种脚本并不适用于生产环境。原因是它不能根据真实的工作需求来调整具体的执行命令，也不能根据某些条件实现自动循环执行。例如，我们需要批量创建1000位用户，首先要判断这些用户是否已经存在；若不存在，则通过循环语句让脚本自动且依次创建他们。</p>

<p>接下来我们通过if、for、while、case这4种流程控制语句来学习编写难度更大、功能更强的Shell脚本。为了保证下文的实用性和趣味性，做到寓教于乐，我会尽可能多地讲解各种不同功能的Shell脚本示例，而不是逮住一个脚本不放，在它原有内容的基础上修修补补。尽管这种修补式的示例教学也可以让读者明白理论知识，但是却无法开放思路，不利于日后的工作。</p>

<h3 id="4-3-1-if条件测试语句">4.3.1 if条件测试语句</h3>

<p>if条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。</p>

<p>if条件语句的单分支结构由if、then、fi关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的if语句属于最简单的一种条件判断结构，语法格式如图4-17所示。</p>

<p><a href="https://img.it610.com/image/info8/6073c79c85d243fcb141e5a845a60587.jpg"><img src="https://img.it610.com/image/info8/6073c79c85d243fcb141e5a845a60587.jpg" alt="" /></a></p>

<p>图4-17 单分支的if语句</p>

<p>下面使用单分支的if条件语句来判断/media/cdrom文件是否存在，若存在就结束条件判断和整个Shell脚本，反之则去创建这个目录：</p>

<p>[root@linuxprobe ~]# vim mkcdrom.sh</p>

<p>#!/bin/bash</p>

<p>DIR=&ldquo;/media/cdrom&rdquo;</p>

<p>if [ ! -e $DIR ]</p>

<p>then</p>

<p>mkdir -p $DIR</p>

<p>fi</p>

<p>由于第5章才讲解用户身份与权限，因此这里继续用“bash脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用ls命令验证/media/cdrom目录是否已经成功创建：</p>

<p>[root@linuxprobe ~]# bash mkcdrom.sh</p>

<p>[root@linuxprobe ~]# ls -d /media/cdrom</p>

<p>/media/cdrom</p>

<p>if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if条件语句的双分支结构也是一种很简单的判断结构，语法格式如图4-18所示。</p>

<p><a href="https://img.it610.com/image/info8/79bf80aff47442ba892ad8236d7bd0a7.jpg"><img src="https://img.it610.com/image/info8/79bf80aff47442ba892ad8236d7bd0a7.jpg" alt="" /></a>图4-18
双分支的if语句</p>

<p>下面使用双分支的if条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用ping命令来测试与对方主机的网络联通性，而Linux系统中的ping命令不像Windows一样尝试4次就结束，因此为了避免用户等待时间过长，需要通过-
c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。</p>

<p>[root@linuxprobe ~]# vim chkhost.sh</p>

<p>#!/bin/bash</p>

<p>ping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/null</p>

<p>if [ $? -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;Host $1 is On-line.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Host $1 is Off-line.&rdquo;</p>

<p>fi</p>

<p>我们在用过$?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则$?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为0，从而获知那条语句的最终判断情况。这里的服务器IP地址为192.168.10.10，我们来验证一下脚本的效果：</p>

<p>[root@linuxprobe ~]# bash chkhost.sh 192.168.10.10</p>

<p>Host 192.168.10.10 is On-line.</p>

<p>[root@linuxprobe ~]# bash chkhost.sh 192.168.10.20</p>

<p>Host 192.168.10.20 is Off-line.</p>

<p>if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图4-19所示。</p>

<p><a href="https://img.it610.com/image/info8/a8dc0431216248fc92c56ec729bb7f68.jpg"><img src="https://img.it610.com/image/info8/a8dc0431216248fc92c56ec729bb7f68.jpg" alt="Vim编辑器与Shell命令脚本_第15张图片" /></a></p>

<p>图4-19 多分支的if语句</p>

<p>下面使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如Excellent、Pass、Fail等提示信息。在Linux系统中，read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于向用户显示一定的提示信息。在下面的脚本示例中，只有当用户输入的分数大于等于85分且小于等于100分，才输出Excellent字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于70分且小于等于84分，如果是，则输出Pass字样；若两次都落空（即两次的匹配操作都失败了），则输出Fail字样：</p>

<p>[root@linuxprobe ~]# vim chkscore.sh</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;Enter your score（0-100）：&rdquo; GRADE</p>

<p>if [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ] ; then</p>

<p>echo &ldquo;$GRADE is Excellent&rdquo;</p>

<p>elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -le 84 ] ; then</p>

<p>echo &ldquo;$GRADE is Pass&rdquo;</p>

<p>else</p>

<p>echo &ldquo;$GRADE is Fail&rdquo;</p>

<p>fi</p>

<p>[root@linuxprobe ~]# bash chkscore.sh</p>

<p>Enter your score（0-100）：88</p>

<p>88 is Excellent</p>

<p>[root@linuxprobe ~]# bash chkscore.sh</p>

<p>Enter your score（0-100）：80</p>

<p>80 is Pass</p>

<p>下面执行该脚本。当用户输入的分数分别为30和200时，其结果如下：</p>

<p>[root@linuxprobe ~]# bash chkscore.sh</p>

<p>Enter your score（0-100）：30</p>

<p>30 is Fail</p>

<p>[root@linuxprobe ~]# bash chkscore.sh</p>

<p>Enter your score（0-100）：200</p>

<p>200 is Fail</p>

<p>为什么输入的分数为200时，依然显示Fail呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于100或小于0的分数时，给予Error报错字样的提示。</p>

<h3 id="4-3-2-for条件循环语句">4.3.2 for条件循环语句</h3>

<p>for循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用for循环语句再适合不过了。for循环语句的语法格式如图4-20所示。</p>

<p><a href="https://img.it610.com/image/info8/f7d4b776dded443ab3f0ab8cd9b420d7.jpg"><img src="https://img.it610.com/image/info8/f7d4b776dded443ab3f0ab8cd9b420d7.jpg" alt="" /></a></p>

<p>图4-20 for循环语句的语法格式</p>

<p>下面使用for循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数：</p>

<p>[root@linuxprobe ~]# vim users.txt</p>

<p>andy</p>

<p>barry</p>

<p>carl</p>

<p>duke</p>

<p>eric</p>

<p>george</p>

<p>接下来编写Shell脚本Example.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-
p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id
用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。</p>

<p>需要多说一句，/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁</p>

<p>[root@linuxprobe ~]# vim Example.sh</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;Enter The Users Password : &ldquo; PASSWD</p>

<p>for UNAME in <code>cat users.txt</code></p>

<p>do</p>

<p>id $UNAME &amp;&gt; /dev/null</p>

<p>if [ $? -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;Already exists&rdquo;</p>

<p>else</p>

<p>useradd $UNAME &amp;&gt; /dev/null</p>

<p>echo &ldquo;$PASSWD&rdquo; | passwd &ndash;stdin $UNAME &amp;&gt; /dev/null</p>

<p>if [ $? -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;$UNAME , Create success&rdquo;</p>

<p>else</p>

<p>echo &ldquo;$UNAME , Create failure&rdquo;</p>

<p>fi</p>

<p>fi</p>

<p>done</p>

<p>执行批量创建用户的Shell脚本Example.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create
success）的提示后不会有其他内容。</p>

<p>在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。</p>

<p>[root@linuxprobe ~]# bash Example.sh</p>

<p>Enter The Users Password : linuxprobe</p>

<p>andy , Create success</p>

<p>barry , Create success</p>

<p>carl , Create success</p>

<p>duke , Create success</p>

<p>eric , Create success</p>

<p>george , Create success</p>

<p>[root@linuxprobe ~]# tail -6 /etc/passwd</p>

<p>andy:x:1001:1001::/home/andy:/bin/bash</p>

<p>barry:x:1002:1002::/home/barry:/bin/bash</p>

<p>carl:x:1003:1003::/home/carl:/bin/bash</p>

<p>duke:x:1004:1004::/home/duke:/bin/bash</p>

<p>eric:x:1005:1005::/home/eric:/bin/bash</p>

<p>george:x:1006:1006::/home/george:/bin/bash</p>

<p>您还记得在学习双分支if条件语句时，用到的那个测试主机是否在线的脚本么？既然我们现在已经掌握了for循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。</p>

<p>首先创建一个主机列表文件ipadds.txt：</p>

<p>[root@linuxprobe ~]# vim ipadds.txt</p>

<p>192.168.10.10</p>

<p>192.168.10.11</p>

<p>192.168.10.12</p>

<p>然后前面的双分支if条件语句与for循环语句相结合，让脚本从主机列表文件ipadds.txt中自动读取IP地址（用来表示主机）并将其赋值给HLIST变量，从而通过判断ping命令执行后的返回值来逐个测试主机是否在线。脚本中出现的$（命令）是一种完全类似于第3章的转义字符中反引号<code>命令</code>的Shell操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手</p>

<p>[root@linuxprobe ~]# vim CheckHosts.sh</p>

<p>#!/bin/bash</p>

<p>HLIST=$(cat ~/ipadds.txt)</p>

<p>for IP in $HLIST</p>

<p>do</p>

<p>ping -c 3 -i 0.2 -W 3 $IP &amp;&gt; /dev/null</p>

<p>if [ $? -eq 0 ] ; then</p>

<p>echo &ldquo;Host $IP is On-line.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Host $IP is Off-line.&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>[root@linuxprobe ~]# ./CheckHosts.sh</p>

<p>Host 192.168.10.10 is On-line.</p>

<p>Host 192.168.10.11 is Off-line.</p>

<p>Host 192.168.10.12 is Off-line.</p>

<h3 id="3-3-while条件循环语句">3.3 while条件循环语句</h3>

<p>while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while语句的语法格式如图4-21所示。</p>

<p><a href="https://img.it610.com/image/info8/d81ed5c030764d40bd27bae3c034d442.jpg"><img src="https://img.it610.com/image/info8/d81ed5c030764d40bd27bae3c034d442.jpg" alt="" /></a></p>

<p>图4-21 while循环语句的语法格式</p>

<p>接下来结合使用多分支的if条件测试语句与while条件循环语句，编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们当前要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，这两者相等之后才运行exit
0命令，终止脚本的执行。</p>

<p>[root@linuxprobe ~]# vim Guess.sh</p>

<p>#!/bin/bash</p>

<p>PRICE=$(expr $RANDOM % 1000)</p>

<p>TIMES=0</p>

<p>echo &ldquo;商品实际价格为0-999之间，猜猜看是多少？&rdquo;</p>

<p>while true</p>

<p>do</p>

<p>read -p &ldquo;请输入您猜测的价格数目：&rdquo; INT</p>

<p>let TIMES++</p>

<p>if [ $INT -eq $PRICE ] ; then</p>

<p>echo &ldquo;恭喜您答对了，实际价格是 $PRICE&rdquo;</p>

<p>echo &ldquo;您总共猜g $TIMES 次&rdquo;</p>

<p>exit 0</p>

<p>elif [ $INT -gt $PRICE ] ; then</p>

<p>echo &ldquo;太高了！&rdquo;</p>

<p>else</p>

<p>echo &ldquo;太低了！&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>在这个Guess.sh脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到let
TIMES++命令时都会让TIMES变量内的数值加1，用来统计循环总计执行了多少次。这可以让用户得知总共猜测了多少次之后，才猜对价格。</p>

<p>[root@linuxprobe ~]# bash Guess.sh</p>

<p>商品实际价格为0-999之间，猜猜看是多少？</p>

<p>请输入您猜测的价格数目：500</p>

<p>太低了！</p>

<p>请输入您猜测的价格数目：800</p>

<p>太高了！</p>

<p>请输入您猜测的价格数目：650</p>

<p>太低了！</p>

<p>请输入您猜测的价格数目：720</p>

<p>太高了！</p>

<p>请输入您猜测的价格数目：690</p>

<p>太低了！</p>

<p>请输入您猜测的价格数目：700</p>

<p>太高了！</p>

<p>请输入您猜测的价格数目：695</p>

<p>太高了！</p>

<p>请输入您猜测的价格数目：692</p>

<p>太高了！</p>

<p>请输入您猜测的价格数目：691</p>

<p>恭喜您答对了，实际价格是 691</p>

<p>您总共猜测了 9 次</p>

<h3 id="4-3-4-case条件测试语句">4.3.4 case条件测试语句</h3>

<p>如果您之前学习过C语言，看到这一小节的标题肯定会会心一笑“这不就是switch语句嘛！”是的，case条件测试语句和switch语句的功能非常相似！case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。case语句的语法结构如图4-22所示。</p>

<p><a href="https://img.it610.com/image/info8/d9ae06bcecad4de59ccc69ef92bbf25f.jpg"><img src="https://img.it610.com/image/info8/d9ae06bcecad4de59ccc69ef92bbf25f.jpg" alt="Vim编辑器与Shell命令脚本_第16张图片" /></a></p>

<p>图4-22 case条件测试语句的语法结构</p>

<p>在前文介绍的Guess.sh脚本中有一个致命的弱点—只能接受数字！您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a是否大于等于3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。</p>

<p>通过在脚本中组合使用case条件测试语句和通配符（详见第3章），完全可以满足这里的需求。接下来我们编写脚本Checkkeys.sh，提示用户输入一个字符并将其赋值给变量KEY，然后根据变量KEY的值向用户显示其值是字母、数字还是其他字符。</p>

<p>[root@linuxprobe ~]# vim Checkkeys.sh</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;请输入一个字符，并按Enter键确认：&rdquo; KEY</p>

<p>case &ldquo;$KEY&rdquo; in</p>

<p>[a-z]|[A-Z])</p>

<p>echo &ldquo;您输入的是 字母。&rdquo;</p>

<p>;;</p>

<p>[0-9])</p>

<p>echo &ldquo;您输入的是 数字。&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;您输入的是 空格、功能键或其他控制字符。&rdquo;</p>

<p>esac</p>

<p>[root@linuxprobe ~]# bash Checkkeys.sh</p>

<p>请输入一个字符，并按Enter键确认：6</p>

<p>您输入的是 数字。</p>

<p>[root@linuxprobe ~]# bash Checkkeys.sh</p>

<p>请输入一个字符，并按Enter键确认：p</p>

<p>您输入的是 字母。</p>

<p>[root@linuxprobe ~]# bash Checkkeys.sh</p>

<p>请输入一个字符，并按Enter键确认：^[[15~</p>

<p>您输入的是 空格、功能键或其他控制字符。</p>

<h2 id="4-计划任务服务程序">4 计划任务服务程序</h2>

<hr />

<p>经验丰富的系统运维工程师可以使得Linux在无需人为介入的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把周期性、规律性的工作交给系统自动完成。</p>

<p>计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。</p>

<p>Ø 一次性计划任务：今晚11点30分开启网站服务。</p>

<p>Ø 长期性计划任务：每周一的凌晨3点25分把/home/wwwroot目录打包备份为backup.tar.gz。</p>

<p>顾名思义，一次性计划任务只执行一次，一般用于满足临时的工作需求。我们可以用at命令实现这种功能，只需要写成“at
时间”的形式就可以。如果想要查看已设置好但还未执行的一次性计划任务，可以使用“at-l”命令；要想将其删除，可以用“atrm任务序号”。在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。例如，使用下述命令将系统设置为在今晚23:30分自动重启网站服务。</p>

<p>[root@linuxprobe ~]# at 23:30</p>

<p>at &gt; systemctl restart httpd</p>

<p>at &gt; 此处请同时按下Ctrl + D组合键来结束编写计划任务</p>

<p>job 3 at Mon Apr 27 23:30:00 2017</p>

<p>[root@linuxprobe ~]# at -l</p>

<p>3 Mon Apr 27 23:30:00 2017 **** a root</p>

<p>如果读者想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。</p>

<p>[root@linuxprobe ~]# echo &ldquo;systemctl restart httpd&rdquo; | at 23:30</p>

<p>job 4 at Mon Apr 27 23:30:00 2017</p>

<p>[root@linuxprobe ~]# at -l</p>

<p>3 Mon Apr 27 23:30:00 2017 a root</p>

<p>4 Mon Apr 27 23:30:00 2017 a root</p>

<p>如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松删除其中一个：</p>

<p>[root@linuxprobe ~]# atrm 3</p>

<p>[root@linuxprobe ~]# at -l</p>

<p>4 Mon Apr 27 23:30:00 2017 a root</p>

<p>如果我们希望Linux系统能够周期性地、有规律地执行某些具体的任务，那么Linux系统中默认启用的crond服务简直再适合不过了。创建、编辑计划任务的命令为“crontab
-e”，查看当前计划任务的命令为“crontab -l”，删除某条计划任务的命令为“crontab
-r”。另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务。</p>

<p>在正式部署计划任务前，请先跟刘遄老师念一下口诀“分、时、日、月、星期
命令”。这是使用crond服务设置任务的参数格式（其格式见表4-6）。需要注意的是，如果有些字段没有设置，则需要使用星号（ *****
）占位，如图4-23所示。</p>

<p><a href="https://img.it610.com/image/info8/36e020edce2e422d82e32a63dec95f0b.jpg"><img src="https://img.it610.com/image/info8/36e020edce2e422d82e32a63dec95f0b.jpg" alt="" /></a></p>

<p>图4-23 使用crond设置任务的参数格式</p>

<p>表4-6 使用crond设置任务的参数字段说明</p>

<p>字段</p>

<p>|</p>

<p>说明</p>

<p>&mdash;|&mdash;</p>

<p>分</p>

<p>|</p>

<p>取值为0～59的整数</p>

<p>时</p>

<p>|</p>

<p>取值为0～23的任意整数</p>

<p>日</p>

<p>|</p>

<p>取值为1～31的任意整数</p>

<p>月</p>

<p>|</p>

<p>取值为1～12的任意整数</p>

<p>星期</p>

<p>|</p>

<p>取值为0～7的任意整数，其中0与7均为星期日</p>

<p>命令</p>

<p>|</p>

<p>要执行的命令或程序脚本</p>

<p>假设在每周一、三、五的凌晨3点25分，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用crontab-
e命令来创建计划任务。为自己创建计划任务无需使用-u参数，具体的实现效果的参数如crontab -l命令结果所示：</p>

<p>[root@linuxprobe ~]# crontab -e</p>

<p>no crontab for root - using an empty one</p>

<p>crontab: installing new crontab</p>

<p>[root@linuxprobe ~]# crontab -l</p>

<p><strong>25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</strong></p>

<p>需要说明的是，除了用逗号（,）来分别表示多个时间段，例如“8,9,12”表示8月、9月和12月。还可以用减号（-）来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。以及用除号（/）表示执行任务的间隔时间（例如“*/2”表示每隔2分钟执行一次任务）。</p>

<p>如果在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再添加一条计划任务，它的功能是每周一至周五的凌晨1点钟自动清空/tmp目录内的所有文件。尤其需要注意的是，在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询，rm命令路径为下面输出信息中加粗部分。</p>

<p>[root@linuxprobe ~]# whereis rm</p>

<p>rm: <strong>/usr/bin/rm</strong> /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz</p>

<p>[root@linuxprobe ~]# crontab -e</p>

<p>crontab: installing new crontab</p>

<p>[root@linuxprobe ~]# crontab -l</p>

<p>25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</p>

<p><strong>0 1 * * 1-5 /usr/bin/rm -rf /tmp/</strong>*</p>

<p>在本节最后，刘遄老师再来啰嗦几句在工作中使用计划服务的注意事项。</p>

<p>Ø
在crond服务的配置参数中，可以像Shell脚本那样以#号开头写上注释信息，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。</p>

<p>Ø 计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用，否则就会发生冲突。</p>

<p>最后再啰嗦一句，想必读者也已经发现了，诸如crond在内的很多服务默认调用的是Vim编辑器，相信大家现在能进一步体会到在Linux系统中掌握Vim文本编辑器的好处了吧。所以请大家一定要在彻底掌握Vim编码器之后再学习下一章。</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>