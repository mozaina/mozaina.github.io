<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell编程初步学习 | 开发者问答集锦</title>
    <meta property="og:title" content="shell编程初步学习 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell编程初步学习">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell编程初步学习</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="第十三章-总结">第十三章 总结</h1>

<p><strong>shellscript</strong></p>

<p>shell
script是利用shell的功能所写的一个“程序”（program），这个程序是使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式，管道命令与数据流重定向等功能，以达到我们所想要的处理目的。</p>

<p>shell
script就像早期DOS年代的批处理文件（.bat），最简单的功能就是将许多命令写在一起，让用户轻易就能够一下子处理复杂的操作（执行一个文件“shell
script”，就能够一次执行多个命令）。而且shell
script更提供数组、循环、条件与逻辑判断等重要功能，让用户也可以直接以shell来编写程序，而不必使用类似C程序语言等传统程序编写的语法。</p>

<p>shell
script可以简单被看成是批处理文件，也可以被说成是一个程序语言，且这个程序语言由于都是利用shell与相关工具命令，所以不需要编译即可执行，且拥有不错的排错工具，所以它可以帮助系统管理员快速管理好主机。</p>

<p><strong>学习shellscript的原因</strong></p>

<p>² <strong>自动化管理的重要依据</strong></p>

<p>² <strong>追踪与管理系统的重要工作</strong></p>

<p>² <strong>简单入侵检测功能</strong></p>

<p>² <strong>连续命令单一化</strong></p>

<p>² <strong>简易的数据处理</strong></p>

<p>² <strong>跨平台支持与学习历程较短</strong></p>

<p><strong>shellscript用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上，就不够好了，因为shell
script的速度较慢，且使用的CPU资源较多，造成主机资源的分配不良。</strong></p>

<p><strong>script的编写与执行</strong></p>

<p>shell
script是纯文本文件，可以编辑这个文件，然后让这个文件来帮我们一次执行多个命令，或者是利用一些运算与逻辑判断来帮助我们达成某些功能。故要编辑这个文件的内容时，就需要具备bash命令执行的相关知识。</p>

<p>在shell script的编写中，需要注意以下事项：</p>

<p>² 命令的执行是从上而下的、从左而右地分析与执行</p>

<p>² 命令的执行就如同前面提到的：命令，参数间的多个空白都会被忽略掉</p>

<p>² 空白行也将被忽略掉，并且[Tab]按键所得到的空白同样视为空格键</p>

<p>² 如果读取到一个Enter符号（CR），就尝试开始执行该行（或该串）命令</p>

<p>² 至于如果一行的内容太多，则可以使用”\Enter“来扩展至下一行</p>

<p>² “#”可作为批注。任何加在#后面的数据将全部被视为批注文件而忽略。</p>

<p>综上，在script内所编写的程序就会被一行一行执行。那么shell如何执行，其实很简单（以/home/dmtsai/shell.sh为例）：</p>

<p>² <strong>直接命令执行：shell.sh文件必须具备可读与可执行（rx）的权限，然后：</strong></p>

<p>n <strong>绝对路径：使用/home/dmtsai/shell.sh来执行命令</strong></p>

<p>n <strong>相对路径：假设工作目录在/home/dmtsai/，则使用./shell.sh来执行</strong></p>

<p>n <strong>变量PATH功能：将shell.sh放在PATH指定的目录内，如~:/bin/。</strong></p>

<p>² <strong>以bash进程来执行：通过bashshell.sh或sh shell.sh来执行</strong></p>

<p><strong>重点是让那个shell.sh内的命令可以被执行。若shell.sh在~/bin内具有rx的权限，那就直接输入shell.sh即可执行该脚本程序。</strong></p>

<p>sh
shell.sh可以执行原因：/bin/sh其实就是/bin/bash（连接文件），使用shshell.sh即告诉系统，要直接以bash的功能来执行shell.sh这个文件内的相关命令，故此时shell.sh只要有r的权限即可被执行。也可以利用sh的参数，如-n及-
x来检查与追踪shell.sh的语法是否正确。</p>

<pre><code>编写第一个script
mkdir scripts;
cd scripts
vi sh01.sh
输入内容如下：
#!/bin/bash
# Program:
#       This program shows &quot;hello world!&quot; in your screen.
# History:
# 2016/07/03    yzhang   First Release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH
echo -e &quot;hello world! \a \n&quot;
exit 0
</code></pre>

<p>将所编写的scripts放置在主文件的~/scripts目录下，便于管理。下面对程序分段进行说明：</p>

<p>² <strong>第一行#!/bin/bash声明这个script使用的shell命令</strong></p>

<p>因为使用的是bash，故必须要以”#!/bin/bash”来声明这个文件内的语法使用bash的语法。当程序被执行时，他就能够加载bash的相关环境配置文件（一般来说就是non-
login
shell的~/.bashrc），并且执行bash来使下面的命令能够执行。这很重要（在很多情况中，如果没有设置好这一行，那么改程序很可能无法执行，因为系统可能无法判断改程序需要使用什么shell来执行）。</p>

<p>² <strong>程序内容的说明</strong></p>

<p>在scripts中，除了第一行的#!是用来声明shell的之外，其他的#都是批注的用途。上面程序中，第二行以下使用来说明整个程序的基本数据。一般来说，建议一定要养成说明该script的内容与功能，版本信息，作者与联系方式，建立日期，历史记录等习惯。这有助于将来程序的改写与调试。</p>

<p>² <strong>主要环境变量的声明</strong></p>

<p>建议务必要将一些重要的环境变量设置好。PATH与LANG是其中最重要的。如此，程序在进行时可以直接执行一些外部命令，而不必写绝对路径。</p>

<p>² <strong>主要程序部分</strong></p>

<p>就是主要的程序。</p>

<p>² <strong>告知执行结果</strong></p>

<p>可以使用$?来查看命令是否正确执行。也可以利用exit这个命令来让程序中断，并且回传一个数值给系统。在scripts中，可以使用exit回传一个数值给系统。利用exit
n（n是数字）的功能，可以自定义错误信息，让程序变得更加聪明。</p>

<p>执行shell脚本，可以使用sh sh01.sh来实现。此外，也可以使用chmod a+x sh01.sh; ./sh01.sh来执行。</p>

<p><strong>编写shellscript的良好习惯</strong></p>

<p>在每个script的文件头处记录好：</p>

<p>² Script的功能</p>

<p>² Script的版本信息</p>

<p>² Script的作者与联系方式</p>

<p>² Script的版权声明方式</p>

<p>² Script的History（历史记录）</p>

<p>² Script内较特殊的命令，使用绝对路径的方式来执行</p>

<p>² Script执行时需要的环境变量预先声明与设置。</p>

<p>²
此外，建议特殊的程序代码，加上批注信息。程序编写最好使用嵌套方式，最好能以tab按键的空格缩排，这样程序代码会漂亮有条理。此外，编写script的工具最好使用vim而不是vi，因为vim会有额外的语法检查机制，能够在第一阶段编写时就发现语法方面的问题。</p>

<p><strong>简单shell编写</strong></p>

<p><strong>交互式脚本：变量内容由用户决定</strong></p>

<p>很多时候需要用户输入一些内容，好让程序可以顺利执行。这就体现了交互式编程。下面以read命令的用途，编写一个script，它可以让用户输入first
name与last name，并且在屏幕上显示“”Your full name is:”的内容：</p>

<pre><code>!#/bin/bash
# program:
#       user inputs his first name and last name. Program shows his full name.
# History:
# 2016/07/03    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

read -p &quot;please input your first name: &quot; firstname  #提示用户输入
read -p &quot;Please input your last name:  &quot; lastname   #提示用户输入
echo -e &quot;\nYour full name is: $firstname $lastname&quot; #结果由屏幕输出
</code></pre>

<p>执行上面脚本，就能够发现用户自己输入的变量可以让程序所使用，并且显示到屏幕上。</p>

<p><strong>随日期变化：利用日期进行文件的创建</strong></p>

<p>假设服务器内有数据库，数据库每天的数据都不太一样，备份时，希望将每天的数据都备份成不同的文件名，此时利用日期保存文件很重要。举例如下：假设想创建三个空的文件（通过touch）文件名最开头由用户输入决定，假定用户输入filename好了，那今天的日期是2016/7/3，想以前天，昨天，今天的日期来创建这些文件，即filename_20160702，filename_21-0160703，filename_2016/07/04，其实现如下：</p>

<pre><code>#!/bin/bash
# Program:
#    Program creates three files, which named by user's input and data commond.
# History:
# 2016/07/03    Yzhang     First Release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

# 1.让用户输入文件名，并取得fileuser这个变量
echo -e &quot;I will user 'touch' command to create 3 files.&quot;  #纯粹显示信息
read -p &quot;Please input your filename: &quot; fileuser           #提示用户输入

# 2.为了避免用户随意按Enter，利用变量功能分析文件是否由设置
filename=${fileuser:-&quot;filename&quot;}       #开始判断有否配置文件名

# 3.开始利用date命令来取得所需要的文件名
date1=$(date --date='2 days ago' +%Y%m%d)   #前两天的日期
date2=$(date --date='1 days ago' +%Y%m%d)   #前一天的日期
date3=$(date +%Y%m%d)                       #今天的日期
file1=${filename}${date1}
file2=${filename}${date2}
file3=${filename}${date3}

# 4.创建文件名
touch &quot;$file1&quot;
touch &quot;$file2&quot;
touch &quot;$file3&quot;
</code></pre>

<p>上面的script中用到了命令$（command）取得信息、变量的设置功能，变量的累加以及利用touch命令辅助等。</p>

<p><strong>数值运算：简单的减少乘除</strong></p>

<p>可以使用declare来定义变量的类型。当变量定义成为整数后才能够进行加减运算。此外，可以用$((计算式))来进行数值运算。bash
shell里头默认仅支持到整数的数据而已。下面，通过用户输入两个变量，然后对其进行相乘输出，实现如下：</p>

<pre><code>#!/bin/bash
#program:
#    User inputs 2 integer numbers; program will cross these two numbers.
# History:
# 20160703    Yzhang    First Release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH
echo -e &quot;You should input 2 numbers, I will cross them! \n&quot;
read -p &quot;first number: &quot; firstnu
read -p &quot;second number: &quot; secnu
total=$(($firstnu*$secnu))
echo -e &quot;\nThe result of $firstnu * $secnu is ==&gt; $total&quot;
</code></pre>

<p><strong>可以使用”declare–I
total=$firstnu*secnu”，也可以使用上面的方式进行。不过建议使用var=$((运算内容))，原因是容易记忆，也较方便。计算13与3的余数：echo
$((13%3))</strong></p>

<p><strong>Script的执行方式区别</strong></p>

<p>不同的script执行方式会造成不一样的结果，脚本的执行除了上面介绍的，还可以用source或小数点( . )来执行。</p>

<p><strong>利用直接执行的方式来执行script</strong></p>

<p>当使用前面提到的直接命令执行（不论是绝对路径/相对路径还是$PATH内），或者是利用bash（或sh）来执行脚本时，该script都会使用一个新的bash环境来执行脚本内的命令。即使用这种执行方式时，其实script是在子进程的bash内执行的。
<strong>当子进程完后，子进程内的各项变量或操作将会结束而不会传回到父进程中。</strong></p>

<p>上面运行sh02.sh时，用到的变量firstname和lastname，在父进程中不能执行，如执行echo
$firstname和$lastname将显示两个变量不存在。 ****</p>

<p><strong>利用source来执行脚本：在父进程中执行</strong></p>

<p>如果用source执行命令，则不一样。</p>

<p>如source sh02.sh</p>

<p>此时如输入用户名，当执行完成后，在shell下执行echo $firname $lastname则有数据产生，为输入的名字值。</p>

<p><strong>当不注销系统而要让某些写入~/.bashrc设置生效时，需要使用source ~/.bashrc而不能使用bash~/.bashrc。</strong></p>

<p><strong>善用判断式</strong></p>

<p>可以使用S?等来进行判断，但是可以通过test进行更简单的判断。</p>

<p><strong>利用test命令的测试功能</strong></p>

<p>当要检测系统上面某些文件或者是相关的属性时，利用test这个命令来工作真是好用得不得了，如检查/dmtsai是否存在时，使用：test –e /dmtsai</p>

<p>上面的执行结果并不会显示任何信息，但最后可以通过$?或&amp;&amp;及||来显示整个结果。</p>

<p>test –e /dmtsai &amp;&amp; echo “exist” ||echo “Not exist”</p>

<p>最终结果可以显示exist还是not exist。-e是测试一个东西存在不存在。常用的测试命令如下：</p>

<p>测试的标志</p>

<p>|</p>

<p>代表意义</p>

<p>&mdash;|&mdash;</p>

<p><strong>关于某个文件名的“文件类型”判断，如test – e filename表示存在否</strong></p>

<p><strong>-e</strong></p>

<p>|</p>

<p><strong>该文件名是否存在</strong></p>

<p><strong>-f</strong></p>

<p>|</p>

<p><strong>该文件名是否存在且为文件（file）</strong></p>

<p><strong>-d</strong></p>

<p>|</p>

<p><strong>该文件名是否存在且为目录（directory）</strong></p>

<p>-b</p>

<p>|</p>

<p>该文件名是否存在且为一个block device设备</p>

<p>-c</p>

<p>|</p>

<p>该文件名是否存在且为一个character device设备</p>

<p>-S</p>

<p>|</p>

<p>该文件名是否存在且为一个Socket文件</p>

<p>-p</p>

<p>|</p>

<p>该文件名是否存在且为一个FIFO（pipe）文件</p>

<p>-L</p>

<p>|</p>

<p>该文件名是否存在且为一个连接文件</p>

<p><strong>关于文件的权限检测，如test –r filename表示可读否（但root权限常有例外）</strong></p>

<p>-r</p>

<p>|</p>

<p>检测该文件名是否存在且具有“可读”的权限</p>

<p>-w</p>

<p>|</p>

<p>检测该文件名是否存在且具有“可写”的权限</p>

<p>-x</p>

<p>|</p>

<p>检测该文件名是否存在且具有“可执行”的权限</p>

<p>-u</p>

<p>|</p>

<p>检测该文件名是否存在且具有“SUID”的属性</p>

<p>-g</p>

<p>|</p>

<p>检测该文件名是否存在且具有“SGID“的属性</p>

<p>-k</p>

<p>|</p>

<p>检测该文件名是否存在且具有“Sticky bit”的属性</p>

<p>-s</p>

<p>|</p>

<p>检测该文件名是否存在且具有“非空白文件”</p>

<p><strong>两个文件之间的比较，如test file1 –nt file2</strong></p>

<p>-nt</p>

<p>|</p>

<p>（newer than）判断file1是否比file2新</p>

<p>-ot</p>

<p>|</p>

<p>（older than）判断file1是否比file2旧</p>

<p>-ef</p>

<p>|</p>

<p>判断file1与file2是否为同一文件，可用在判断hard link的判定上。主要意义在于判定两个文件是否均指向同一个inode</p>

<p><strong>关于两个整数之间的判定吗，如test n1 –eq n2</strong></p>

<p>-eq</p>

<p>|</p>

<p>两数值相等（equal）</p>

<p>-ne</p>

<p>|</p>

<p>两数值不等（not equal）</p>

<p>-gt</p>

<p>|</p>

<p>N1大于n2（greate than）</p>

<p>-lt</p>

<p>|</p>

<p>N1小于n2（less than）</p>

<p>-ge</p>

<p>|</p>

<p>N1大于等于n2（greater than or equal）</p>

<p>-le</p>

<p>|</p>

<p>N1小于等于n2（less than or equal）</p>

<p><strong>判定字符串的数据</strong></p>

<p>test –z string</p>

<p>|</p>

<p>判定字符串是否为0，若string为空字符串，则为true</p>

<p>test –n string</p>

<p>|</p>

<p>判定字符串是否非为0，若string为空字符串，则为false</p>

<p>test str1 = str2</p>

<p>|</p>

<p>判定str1是否等于str2，若相等，则回传true</p>

<p>test str1 != str2</p>

<p>|</p>

<p>判定str1是否不等于str2，若相等，则回传false</p>

<p><strong>多重条件判定，若test –r filename –a –x filename</strong></p>

<p>-a</p>

<p>|</p>

<p>两个条件同时成立！如test –r file –a –x file，则file同时具有r与x权限时，才回传true</p>

<p>-o</p>

<p>|</p>

<p>任何一个条件成立！如test –r file –o –x file，则file具有r或x权限时，就可回传true</p>

<p>！</p>

<p>|</p>

<p>反向状态，如test ! –x file，但file不具有x时，回传true</p>

<p>下面利用test编写简单例子。首先判断一下，让用户输入一个文件名，判断如下：</p>

<p>² 这个文件是否存在，若不存在则给予一个“Filename does not exist”的信息，并中断程序</p>

<p>² 若文件存在，则判断它是个文件或目录，结果输出“Filename isregular file”或“Filename is directory”</p>

<p>² 判断一下，执行者的身份对这个文件或目录所拥有的权限，并输出权限数据。</p>

<pre><code>#!/bin/bash
# Program:
#    User input a filename, program will check the following:
#    1) exist? 2) file/directory? 3) file permissions
# History:
# 2016/07/03    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

# 1.让用户输入文件名，并且判断用户是否真的输入字符串
echo -e &quot;Please input a filename, I will check the filename's type and permission. \n\n&quot;
read -p &quot;Input a filename: &quot; filename
test -z $filename &amp;&amp; echo &quot;You Must input a filename.&quot; &amp;&amp; exit 0

# 2.判断文件是否存在，若不存在则显示信息并结束脚本
test ! -e $filename &amp;&amp; echo &quot;The filename '$filename' DO NOT exist&quot; &amp;&amp; exit 0

# 3.开始判断文件类型和属性
test -f $filename &amp;&amp; filetype='regulare file'
test -d $filename &amp;&amp; filetype='directory'

test -r $filename &amp;&amp; perm=&quot;readable&quot;
test -w $filename &amp;&amp; perm=&quot;$perm writable&quot;
test -x $filename &amp;&amp; perm=&quot;$perm executable&quot;

# 4.开始输出信息
echo &quot;The filename: $filename is $filetype&quot;
echo &quot;And the permissions are : $perm&quot;
</code></pre>

<p><strong>注意：由于root在很多权限的限制上面都是无效的，所以使用root执行这个脚本时，常常会发现与ls
–l观察到的结果并不相同。建议使用一般用户执行此脚本。</strong></p>

<p><strong>利用判断符号[]</strong></p>

<p>除了利用test外，还可以使用判断符号[]来进行数据的判断。例如想知道$HOME这个变量是否为空，可以执行如下命令：</p>

<p>[ -z &ldquo;$HOME&rdquo; ] ; echo $?</p>

<p>使用中括号必须要特别注意，因为中括号用在很多地方，包括统配符和正则表达式等，所以如果要在bash的语法当中使用中括号作为shell的判断式时，必须要注意
<strong>中括号的两端需要有空格符来分割。</strong></p>

<p><strong>在bash当中，=号与==号的结果一样。</strong></p>

<p>判断两个字符串是否相等，可以使用如下命令</p>

<p>[ “$HOME” == “$MAIL” ] 相当于test$HOME=SMAIL。如果没有空格，则bash将会显示错误信息。故注意如下：</p>

<p>² 在中括号[]没的每个组件都需要有空格键来分割；</p>

<p>² 在中括号内的变量，最好都以双引号括起来</p>

<p>² 在中括号内的变量，最好都以单或双引号括起来。</p>

<p>中括号使用的方法与test几乎一模一样。只是中括号比较常用在条件表达式if then fi的情况中。举例如下：</p>

<p>² 执行一个程序时，程序让用户选择Y或N</p>

<p>² 如果用户输入Y或y时，显示“OK， continue”</p>

<p>² 如果用户输出N或n时，显示“Ok, interrupt!”</p>

<p>² 如果用户输入不是Y，y，N，n之内的其他字符，显示“Idon’t know“，利用中括号，&amp;&amp;和||实现。</p>

<pre><code>#!/bin/bash
# Program:
#    This programs shows the user's choice
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH 

read -p &quot;Please input (Y/N) :&quot; yn
[ &quot;$yn&quot; == &quot;Y&quot; -o &quot;$yn&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;OK, continue.&quot; &amp;&amp; exit 0
[ &quot;$yn&quot; == &quot;N&quot; -o &quot;$yn&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh, interrupt!&quot; &amp;&amp; exit 0
echo &quot;I don't know what your choice is&quot; &amp;&amp; exit 0
</code></pre>

<p><strong>其中的-o（或）连接两个判断。</strong></p>

<p><strong>Shellscript的默认变量（$0, $1, …）</strong></p>

<p>重新启动系统注册表文件的功能，使用如下命令</p>

<p>file /etc/init.d/syslog 使用file来查询后，系统告知这个文件是个bash的可执行script、</p>

<p>/etc/init.d/syslog restart</p>

<p>上面中，restart是重新启动之意，可以重新启动/etc/init.d/syslog这个程序。</p>

<p>script针对参数设置好的一些变量名称如下：</p>

<p>/path/to/scriptname opt1 opt2 opt3 opt4</p>

<p>$0 $1 $2 $3 $4</p>

<p>执行的脚本名为$0这个变量，第一个参数接的就是$1。在script中善用$1，就可以简单执行某些命令的功能。此外，还有一些较为特殊的变量可以在script内使用来调用这些参数。</p>

<p>² <strong>$#：代表后接的参数“个数”</strong></p>

<p>² <strong>$@：代表”$1” “$2” “$3” “$4”之意，每个变量是独立的（用双引号括起来）</strong></p>

<p>² <strong>$*：代表“”$1c$2c$3c$4“”，其中c为分割字符，默认为空格键，所以本例代表““$1 $2 $3 $4””之意。</strong></p>

<p>其中，$@与$*基本上还是有所不同。不过，一般情况下可以直接记忆$@即可。举例：假设执行一个可以携带参数的script，执行该脚本后屏幕显示如下数据：</p>

<p>² 程序的文件名</p>

<p>² 共有几个参数</p>

<p>² 若参数的个数小于2则告知用户参数太少</p>

<p>² 全部的参数内容</p>

<p>² 第一个参数</p>

<p>² 第二个参数</p>

<pre><code>#!/bin/bash
# Program:
#    Program shows the script name, parameters...
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

echo &quot;The script name is  ===&gt; $0&quot;
echo &quot;Total paramter number is  ===&gt; $#&quot;
[ &quot;$#&quot; -lt 2 ] &amp;&amp; echo &quot;The number of parameter is less than 2. Stop here.&quot; &amp;&amp; exit 0
echo &quot;Your whole parameter is  ===&gt; '$@'&quot;
echo &quot;The 1st parameter  ===&gt; $1&quot;
echo &quot;The 2st parameter  ===&gt; $2&quot;
</code></pre>

<p><strong>脚本执行如下：</strong></p>

<p><strong>shsh07.sh theone haha quot</strong></p>

<p><strong>shift：造成参数变量号码偏移</strong></p>

<p>改上面程序如下：</p>

<pre><code>#!/bin/bash
# Program:
#    Program shows the script name, parameters...
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

echo &quot;Total paramter number is  ===&gt; $#&quot;
echo &quot;Your whole parameter number is  ===&gt; '$@'&quot;
shift  #进行第一次“一个变量的shift”

echo &quot;Total paramter number is  ===&gt; $#&quot;
echo &quot;Your whole parameter number is  ===&gt; '$@'&quot;
shift 3  #进行第二次“三个变量的shift”
echo &quot;Total paramter number is  ===&gt; $#&quot;
echo &quot;Your whole parameter is  ===&gt; '$@'&quot;
</code></pre>

<p><strong>程序执行如下：</strong></p>

<p><strong>shsh07.sh one two three four five six</strong></p>

<p><strong>shift会移动变量，而且shift后面可以接数字，代表拿掉最前面的几个参数。</strong> 执行结果，第一次shift后，显示情况是twothree four
fix six，第二次拿掉三个后，显示为five six。</p>

<p><strong>条件判断式</strong></p>

<p><strong>利用if…then</strong></p>

<p>这个if…then是最常见的条件判断式。简单说，就是当符合某个条件判断的时候，就进行某些工作。If…then的判断还有多层次的情况。分别如下：</p>

<p><strong>单层、简单条件判断式</strong></p>

<p>如果只有一个判断式要进行，则可以简单这样：</p>

<p>if [条件判断式]; then</p>

<p>当条件判断成立时，可以进行的命令功能内容</p>

<p>fi 结束if之意。</p>

<p>其中条件判断的方法与上面介绍的相同。当有多个判断时，多个条件写入一个中括号内，也可以多个中括号，括号之间则以&amp;&amp;或||来隔开，意义：</p>

<p><strong>&amp; &amp;代表AND</strong></p>

<p><strong>||代表or</strong></p>

<p>如[ “$yn” == ”Y” –o “$yn” == ”y”] 可以写成 [ “$yn == ”Y”]|| [ “$yn” == ”y”]</p>

<p>使用条件实现程序如下：</p>

<pre><code>#!/bin/bash
# Program:
#    This programs shows the user's choice
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH 

read -p &quot;Please input (Y/N) :&quot; yn
if [ &quot;$yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]; then
        echo &quot;OK&quot;
        exit 0
fi
if [ &quot;$yn&quot; == &quot;N&quot; ] ||[ &quot;$yn&quot; == &quot;n&quot; ]; then
        echo &quot;Oh interrupt&quot;
        exit 0
fi
echo &quot;I don't know what your choice is&quot; &amp;&amp; exit 0
</code></pre>

<p><strong>多重、复杂条件判断式</strong></p>

<p>在一个程序中，如果使用多重条件判断，可以使用如下语法：</p>

<p>#一个条件判断</p>

<p>if [ 条件判断式 ]; then</p>

<p>当条件判断式成立时，可以进行的命令工作内容；</p>

<p>else</p>

<p>当条件判断式不成立时，可以进行的命令工作内容；</p>

<p>fi</p>

<p>#多个条件判断（if … elif …else）分多种不同情况执行</p>

<p>if [条件判断式一 ]; then</p>

<p>当条件判断式一成立时，可以进行的命令工作内容</p>

<p>elif [ 条件判断式二 ] ; then</p>

<p>当条件判断式二成立时，可以进行的命令工作内容</p>

<p>else</p>

<p>当条件判断式一与二均不成立时，可以进行的命令工作内容；</p>

<p>fi</p>

<p><strong>注意：elif也是个判断式，因此出现elif后面都接then来处理。但是else已经是最后的没有成立的结果了，所以else后面并没有then。</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This programs shows the user's choice
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH 

read -p &quot;Please input (Y/N) :&quot; yn
if [ &quot;$yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]; then
        echo &quot;OK&quot;
elif [ &quot;$yn&quot; == &quot;N&quot; ] ||[ &quot;$yn&quot; == &quot;n&quot; ]; then
        echo &quot;Oh interrupt&quot;
else
        echo &quot;I don't know what your choice is&quot; &amp;&amp; exit 0
fi
</code></pre>

<p>上面程序变得简单，且依序判断，可以避免掉重复判断的状况，且容易设计程序。</p>

<p>如果不希望用户由键盘输入额外的数据时，可以使用上一节提到的参数功能（$1）让用户在执行命令时就将参数代进去。现想让用户输入hello这个关键字，利用参数的方法可以这样依序设计：</p>

<p>1） 判断$1是否为hello，如果是的话，显示“hello”</p>

<p>2） 如果没有加任何参数，就提示用户必须要使用的参数；</p>

<p>3） 而如果加入的参数不是hello，就提醒用户仅能使用hello为参数。</p>

<p>整个程序的编写可以如下：</p>

<pre><code>#!/bin/bash
# Program:
#    Check $1 is equal to &quot;hello&quot;
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

if [ &quot;$1&quot; == &quot;hello&quot; ]; then
        echo &quot;hello&quot;
elif [ &quot;$1&quot; == &quot;&quot; ]; then
        echo &quot;Your must input parameters, ex&gt; {$0 someword}&quot;
else
        echo &quot;The only parameter is ‘hello', ex&gt; {$0 hello}&quot;
fi
</code></pre>

<p>netstat命令，可以查询到目前主机打开的网络服务端口（service ports），可以使用netstat –tuln来取得目前主机有启动的服务。</p>

<p>IP地址为127.0.0.1是针对本机开放，而0.0.0.0则代表对整个Internet开发。每个端口（port）都有其特定的网络服务，常见的port现骨干网络服务关系如下：</p>

<p>80：www</p>

<p>22：ssh</p>

<p>21：ftp</p>

<p>25：mail</p>

<p>111：RPC（远程过程调用）</p>

<p>631：CUPS（打印服务功能）</p>

<p>编写脚本，实现检测常见的端口（21,22,80）服务开启情况。具体如下：</p>

<pre><code>#!/bin/bash
# Program:
#    Using netstat and grep to detect www,ssh,ftp and mail services.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

# 1. 先做一些告知的操作而已～
echo &quot;Now, I will detect your Linux server's services&quot;
echo -e &quot;The www, ftp, ssh, and mail will be detect! \n&quot;

# 2. 开始进行一些测试的工作，并且输出一些信息
testing=$(netstat -tuln | grep &quot;:80 &quot;)
if [ &quot;$testing&quot; != &quot;&quot; ]; then
        echo &quot;www is running&quot;
fi
testing=$(netstat -tuln | grep &quot;:22&quot;)
if [ &quot;$testing&quot; != &quot;&quot; ]; then
        echo &quot;ssh is running&quot;
fi
testing=$(netstat -tunl | grep &quot;:21&quot;)
if [ &quot;$testing&quot; != &quot;&quot; ]; then
        echo &quot;ftp is running&quot;
fi
</code></pre>

<p>中国当兵时公民应尽的义务，不过，在当兵的是否总想退伍，可以编写脚本计算退伍时间.</p>

<p>1） 想让用户输入退伍时间</p>

<p>2） 在由现在日期对比退伍日期</p>

<p>计算所需天数。</p>

<pre><code>#!/bin/bash
# Program:
#    You input demobilization date, I calculate how many days before you demobilize.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/urs/local/sbin:~/bin
export PATH

# 1 告知用户程序的用途，并且告知应该如何输入日期格式
echo &quot;This program will try to calculate :&quot;
echo &quot;How many days before your demobilization date...&quot;
read -p &quot;Please input your demobolization date (YYYYMMDD ex&gt;20160704): &quot; date2

# 2 利用正则表达式测试一下这个输入内容是否正确
date_d=$(echo $date2 | grep '[0-9]\{8\}')
if [ &quot;$date_d&quot; == &quot;&quot; ]; then
        echo &quot;input wrong&quot;
        exit 1
fi

# 3 开始计算日期
declare -i date_dem=`date --date=&quot;$date2&quot; +%s`
declare -i date_now=`date +%s`
declare -i date_total_s=$(($date_dem - $date_now))
declare -i date_d=$(($date_total_s/60/60/24))
if [ &quot;$date_total_s&quot; -lt &quot;0&quot; ]; then
echo &quot;you need demobilization before $((-1*$date_d)) ageo&quot;
else
        declare -i date_h=$(($(($date_total_s-$date_d*60*60*24))/60/60))
        echo &quot;you will demobilize after $date_d days and $date_h hours.&quot;
fi
</code></pre>

<p><strong>利用case…esac判断</strong></p>

<p><strong>case是针对两个变量，多种情况进行的判断，其语法如下：</strong></p>

<p>case $环境名称 in &lt; == 关键字符为case，还有变量前有$</p>

<p>“第一个变量内容”) &lt; == 每个变量内容建议用双引号括起来，关键字则为小括号)</p>

<p>程序段</p>

<p>;; &lt; == 每个类型结尾使用两个连续的分号来处理</p>

<p>“第二个变量内容“”)</p>

<p>程序段</p>

<p>;;</p>

<p>*） &lt; == 最后一个变量内容都会用*来代表所有其他值</p>

<p>不包含第一个变量内容与第二个变量内容的其他程序程序执行段</p>

<p>exit1</p>

<p>;;</p>

<p>esac</p>

<p>注意：case语法中，是以case为开头的，而其结束为esac（反写）。此外，对每个变量内容的程度段最后都需要两个分号（;;）来代表该程序段落的结束。至于这个变量内容的最后使用*，是因为如果用户输入第一个或第二个变量内容时，可以告知用户相关信息。</p>

<p>举例如下：</p>

<pre><code>#!/bin/bash
# Program:
#    Show &quot;Hello&quot; from $1... by using case ... esac
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

case $1 in
        &quot;hello&quot;)
                echo &quot;Hello, how are you?&quot;
                ;;
        &quot;&quot;)
                echo &quot;You must input parameters, ex&gt; {$0 someword}&quot;
                ;;
        *)
                echo &quot;Usage $0 {hello}&quot;
                ;;
esac
</code></pre>

<p>上面的程序编写很简单明了， <strong>系统的很多服务的启动script都是使用这种写法的。</strong>
例如/etc/init.d中的syslog服务，重启这个服务使用下列命令：/etc/init.d/syslog
restart，其中重点是restart，可以使用less/etc/init.d/syslog来查阅，其中就用到了case的语法，并且规定某些既定的变量内容，可以直接执行/etc/init.d/syslog，此script就会告知后续变量可以使用情况。</p>

<p>一般来说，使用“case $变量in”这个语法中，当中的那个”$变量”大致有两种取得的方式：</p>

<p>² 直接执行式：如上面的就直接使用$1这个变量的内容，这也是在/etc/init.d目录下大多数程序的设计方式。</p>

<p>² 交互式：通过read这个命令来让用户输入变量的内容。举例如下：</p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

echo &quot;This program will print your selection!&quot;
# read -p &quot;Input your choice:&quot; choice
# case $choice in
case $1 in
  &quot;one&quot;)
        echo &quot;Your choice is one&quot;
        ;;
  &quot;two&quot;)
        echo &quot;Your choice is two&quot;
        ;;
  &quot;three&quot;)
        echo &quot;Your choice is three&quot;
        ;;
  *)
        echo &quot;Usage $0 {one | two | three}&quot;
        ;;
esac
</code></pre>

<p>上面程序使用的是非交互式，要使用交互式，则把其中#取消，把下面的case $1 in进行注释，即可实现。</p>

<p><strong>利用function功能</strong></p>

<p>什么是函数（function）功能？简单地说，其实，函数就是可以在shell
script当中做出一个类似自定义命令的东西，最大的功能是，可以简化很多程序代码。Function的语法如下：</p>

<p>function fname()</p>

<p>{</p>

<p>程序段</p>

<p>}</p>

<p>fname是自定义的执行命令名称，程序段是要执行的内容。注意： <strong>因为shell script的执行方式是由上而下、由左而右，因此在shell
script当中的function的设置一定要在程序的最前面，这样才能够在执行时被找到可用的程序段。</strong> 下面是程序的编写：</p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

function printit()
{
        echo -n &quot;Your choice is &quot;
}
echo &quot;This program will print your selection!&quot;
case $1 in
  &quot;one&quot;)
        printit; echo $1 | tr 'a-z' 'A-Z'
        ;;
  &quot;two&quot;)
        printit; echo $1 | tr 'a-z' 'A-Z'
        ;;
  &quot;three&quot;)
        printit; echo $1 | tr 'a-z' 'A-Z'
        ;;
  *)
        echo &quot;Usage $0 {one | two | three}&quot;
        ;;
esac
</code></pre>

<p>上面的程序执行中，在case的one，two，three情况下，调用printit函数。</p>

<p><strong>另外，function也是拥有内置变量的。它的内置变量与shell script很类似，函数名称表示$0,而后续接的变量也是以$1,$2…来替代的。</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

function printit()
{
        echo -n &quot;Your choice is $1 &quot;   #这个$1必须要参数下面命令的执行
}
echo &quot;This program will print your selection!&quot;
case $1 in
  &quot;one&quot;)
        printit 1    #请注意，printit命令后面还有接参数 
        ;;
  &quot;two&quot;)
        printit 2
        ;;
  &quot;three&quot;)
        printit 3
        ;;
  *)
        echo &quot;Usage $0 {one | two | three}&quot;
        ;;
esac
</code></pre>

<p><strong>循环（loop）</strong></p>

<p>循环可以不断地执行某个程序段落，直到用户设置的条件达成为止。其重点是条件的完成是什么。除了这种依据判断式达成与否的不定循环之外，还有另外一种已经固定要跑多少次的循环，可称为固定循环状态。</p>

<p><strong>whiledo done, until do done（不定循环）</strong></p>

<p>一般来说，补丁循环最常见的状态就是下面两种：</p>

<p>while [condition] &lt; === 中括号内的状态就是判断式</p>

<p>do &lt; === 循环的开始</p>

<p>程序段落</p>

<p>done &lt; === 循环的结束</p>

<p>这种循环，当condition条件成立时，就进行循环，直到condition的条件不成立才停止。</p>

<p>不定循环</p>

<p>until [condition]</p>

<p>do</p>

<p>程序段</p>

<p>done</p>

<p>这种方式与while相反，当condition条件成立时，就终止循环，否则就持续进行循环的程序段。</p>

<p><strong>while循环</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

while [ &quot;$yn&quot; != &quot;yes&quot; -a &quot;$yn&quot; != &quot;YES&quot; ]
do
        read -p &quot;Please input yes/YES to stop this program: &quot; yn
done
echo &quot;OK! you input the correct answer.&quot;
</code></pre>

<p><strong>until循环</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

until [ &quot;$yn&quot; == &quot;yes&quot; -o &quot;$yn&quot; == &quot;YES&quot; ]
do
        read -p &quot;Please input yes/YES to stop this program: &quot; yn
done
echo &quot;OK! you input the correct answer.&quot;
</code></pre>

<p><strong>计算1+2+…+100</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

s=0
i=0
while [ &quot;$i&quot; != &quot;100&quot; ]
do
        i=$(($i+1))
        s=$(($s+$i))
done
echo &quot;The result of '1+2+3+...+100' is ===&gt; $s&quot;
</code></pre>

<p><strong>for…do…done（固定循环）</strong></p>

<p>相对于while，until的循环方式是必须要“符合某个条件”的状态，for这种语法则是“已经知道要进行几次循环”的状态。语法如下：</p>

<p>for var in con1 con2 con3…</p>

<p>do</p>

<p>程序段</p>

<p>done</p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

for animal in dog cat elephant
do
        echo &quot;Three are ${animal}s...&quot;
done
</code></pre>

<p><strong>利用循环处理获取/etc/passwd并使用循环处理的方法。</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

users=$(cut -d ':' -f1 /etc/passwd)
for username in $users
do
        id $usrname
        echo $username
done
</code></pre>

<p><strong>使用ping命令，判断网络状态。进行网络状态的实际检测时，要检测的域是本机所在的</strong>
192.168.1.1~192.168.1.100，由于有100台主机，可以利用循环来实现，具体如下：</p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

network=&quot;192.168.1&quot;
for sitenu in $(seq 1 100)
do
        ping -c 1 -w 1 ${network}.${sitenu} &amp;&gt; /dev/null &amp;&amp; result=0 || result=1
        if [ &quot;$result&quot; == 0 ]; then
                echo &quot;Server ${network}.${sitenu} is UP.&quot;
        else
                echo &quot;Server ${network}.${sitenu} is Down.&quot;
        fi
done
</code></pre>

<p><strong>实现判断式上循环功能。让用户输入某个目录文件名，然后找出某目录内的文件名的权限，其实现如下：</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

# 1 先看看这个目录是否存在
read -p &quot;Please input a directory: &quot; dir
if [ &quot;$dir&quot; == &quot;&quot; -o ! -d &quot;$dir&quot; ]; then
        echo &quot;The $dir is NOT exist in your system.&quot;
        exit 1
fi

# 2 开始测试文件
filelist=$(ls $dir)
for filename in $filelist
do
        perm=&quot;&quot;
        test -r &quot;$dir/$filename&quot; &amp;&amp; perm=&quot;$perm readable&quot;
        test -w &quot;$dir/$filename&quot; &amp;&amp; perm=&quot;$perm writable&quot;
        test -e &quot;$dir/$filename&quot; &amp;&amp; perm=&quot;$perm executable&quot;
        echo &quot;The file $dir/$filename's permission is $perm&quot;
done
</code></pre>

<p><strong>for…do…done的数值处理</strong></p>

<p>for ((初始值; 限制值; 执行步长))</p>

<p>do</p>

<p>程序段</p>

<p>done</p>

<p>这种语法适合于数值方式的运算当中，在for后面的括号内的三串内容意义为：</p>

<p>² <strong>初始值：某个变量在循环当中的初始值，直接以类似i=1设置好；</strong></p>

<p>² <strong>限制值：当变量的值在这个限制值的范围内，就继续进行循环，例如，i &lt;=100；</strong></p>

<p>² <strong>执行步长：没做一次循环时变量的变化量。如i=i+1。</strong></p>

<pre><code>#!/bin/bash
# Program:
#    This script only accept the flowing parameter: one two or three.
# History:
# 2016/07/04    Yzhang    First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

read -p &quot;Please input a number, I will count for 1+2+...+your_input: &quot; nu
s=0
for((i=1; i&lt;=$nu; i++))
do
        s=$(($s+$i))
done
echo &quot;The result of '1+2+3+...+$nu' is ====&gt; $s&quot; 
</code></pre>

<p><strong>shellscript的追踪与调试</strong></p>

<p>script在执行之前，最怕的就是出现语法错误问题。可以使用bash相关的参数进行判断语法问题。</p>

<p>sh [-nvx] scripts.sh</p>

<p>参数：</p>

<p>-n：不要执行script，仅查询语法的问题；</p>

<p>-v：在执行script前，先将script的内容输出到屏幕上</p>

<p>-x：将使用到的script内容显示到屏幕上，这是很有用的信息。</p>

<p>测试是否存在语法问题，可以使用如下命令：</p>

<p>sh –n sh16.sh</p>

<p>将sh15.sh的执行过程全部列出来</p>

<p>sh –x sh15.sh</p>

<p>执行上述命令后，输出信息中， <strong>在加号后面的数据其实都是命令串，由sh
–x的方式来将命令执行过程也显示出来，如此用户可以判断程序代码执行到哪一段时会出现相关的信息。</strong></p>

<p><strong>重点</strong></p>

<p>² <strong>shell
script是利用shell的功能所写的一个程序（program），这个程序使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式、管道命令与数据流重定向等功能，以达到我们所想要的处理目的。</strong></p>

<p>² <strong>shell script用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上就不够好了，因为shell
script的速度较慢，且使用的CPU资源较多，造成主机资源的分配不良。</strong></p>

<p>² <strong>在shell script的文件中，命令是从上而下、从左而右地分析与执行。</strong></p>

<p>² <strong>shell script的执行至少需要有r的权限，若需要直接命令执行，则需要拥有r和x的权限。</strong></p>

<p>² <strong>在良好的编程习惯中，第一行要声明shell（#!/bin/bash），第二行以后则声明程序用途、版本、作者等。</strong></p>

<p>² <strong>对交互式脚本可以read命令达成</strong></p>

<p>² <strong>要创建每次执行脚本都有不同结果的数据，可使用date命令利用日期达成。</strong></p>

<p>² <strong>script的执行若以source来执行时，代表在父进程的bash内执行之意。</strong></p>

<p>² <strong>若需要进行判断式，可以使用test或中括号([])来处理。</strong></p>

<p>² <strong>在script内，$0, $1, $2,…, $@是有特殊意义的。</strong></p>

<p>² <strong>条件判断式可使用if…then来判断，若是固定变量内容的情况下，可使用case $var in easc来处理。</strong></p>

<p>² <strong>循环主要分为不定循环（while， until）以及固定循环（for），配合do，done来达成所需任务。</strong></p>

<p>² <strong>可以使用sh –x script.sh来进行程序的调试。</strong></p>

<p>参考文献： 鸟哥的Linux私房菜</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>