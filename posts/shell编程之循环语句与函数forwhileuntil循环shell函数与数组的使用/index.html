<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell编程之循环语句与函数forwhileuntil循环shell函数与数组的使用 | 开发者问答集锦</title>
    <meta property="og:title" content="shell编程之循环语句与函数forwhileuntil循环shell函数与数组的使用 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell编程之循环语句与函数forwhileuntil循环shell函数与数组的使用">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%8E%E5%87%BD%E6%95%B0forwhileuntil%E5%BE%AA%E7%8E%AFshell%E5%87%BD%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell编程之循环语句与函数forwhileuntil循环shell函数与数组的使用</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="文章目录">文章目录</h3>

<ul>
<li>一、循环语句

<ul>
<li>1.1 for循环语句

<ul>
<li>1.1.1 for语句结构</li>
<li>1.1.2 for语句应用示例</li>
<li>1.1.3 shell中let命令</li>
</ul></li>
<li>1.2 while 循环语句

<ul>
<li>1.2.1 while语句结构</li>
<li>1.2.2 while语句应用示例</li>
<li>continue和break</li>
</ul></li>
<li>1.3 until循环语句

<ul>
<li>1.3.1 until语句的结构</li>
<li>1.3.2 until语句应用示例</li>
</ul></li>
</ul></li>
<li>二、shell函数

<ul>
<li>2.1 shell函数概述</li>
<li>2.1.1 函数应用示例</li>
<li>2.2 函数的作用范围</li>
<li>2.3 函数的参数</li>
<li>2.4 递归函数</li>
</ul></li>
<li>三、shell数组

<ul>
<li>3.1 shell数组概述</li>
<li>3.2 shell数组定义方法

<ul>
<li>方法一</li>
<li>方法二</li>
<li>方法三</li>
<li>方法四</li>
</ul></li>
<li>3.3 数组包括的数据类型

<ul>
<li>数值类型</li>
<li>字符类型</li>
</ul></li>
<li>3.4 shell数组应用示例</li>
<li>3.4 shell数组操作

<ul>
<li>获取数组长度</li>
<li>读取某下标赋值</li>
<li>数组遍历</li>
<li>数组切片</li>
<li>数组替换</li>
<li>数组删除</li>
</ul></li>
</ul></li>
<li>四、shell脚本调试

<ul>
<li>echo命令</li>
<li>bash命令</li>
<li>set命令</li>
</ul></li>
</ul>

<h1 id="一-循环语句">一、循环语句</h1>

<h2 id="1-1-for循环语句">1.1 for循环语句</h2>

<h3 id="1-1-1-for语句结构">1.1.1 for语句结构</h3>

<ul>
<li><p>读取不同的变量值，用来逐个执行同一组命令</p>

<p>语句结构
for 变量名 in 取值列表
do
    命令序列
done</p>

<p>语句结构举例
for 收件人 in 邮件地址列表
do
    发送邮件
done</p></li>
</ul>

<p><a href="https://img.it610.com/image/info8/7daa24f88e1f4fb8becd448453569419.jpg"><img src="https://img.it610.com/image/info8/7daa24f88e1f4fb8becd448453569419.jpg" alt="shell编程之循环语句与函数（for、while、until循环、shell函数与数组的使用）_第1张图片" /></a><br />
<strong>for循环</strong></p>

<ul>
<li>指定次数循环，</li>
<li>遍历，把集合中的每个元素挨个读取一遍</li>
</ul>

<h3 id="1-1-2-for语句应用示例">1.1.2 for语句应用示例</h3>

<p><strong>示例1</strong></p>

<ul>
<li><p>批量添加用户</p>

<ul>
<li>用户名存放在users.txt文件中，每行一个</li>
<li>初始密码均设为19961207</li>
<li>验证脚本

<br />
<br /></li>
</ul>

<p>[root@localhost opt]# vim user.txt
zhangsan
lisi
wangermazi
zhaoliu
tianji
wangba
[root@localhost opt]# vim useradd.sh
#!/bin/bash
Lists=$(cat /opt/user.txt)
for bb in $Lists
do
        useradd $bb
        echo &ldquo;19961207&rdquo; | passwd &ndash;stdin $bb
        echo &ldquo;$bb添加成功&rdquo;
done
[root@localhost opt]# chmod +x useradd.sh
[root@localhost opt]# ./useradd.sh
Changing password for user zhangsan.
passwd: all authentication tokens updated successfully.
zhangsan添加成功
&hellip;&hellip;</p>

<p>批量删除用户：在刚刚的基础上修改
[root@localhost opt]# vim useradd.sh
#!/bin/bash
Lists=$(cat /opt/user.txt)
for bb in $Lists
do
        userdel -r $bb  &lsquo;-r 删除家目录&rsquo;
        #echo &ldquo;123456&rdquo; | passwd &ndash;stdin $bb &amp;&gt; /dev/null
        echo &ldquo;$bb删除成功&rdquo;
done</p>

<p>[root@localhost opt]# ./useradd.sh
zhangsan删除成功
lisi删除成功
wangermazi删除成功
zhaoliu删除成功
tianji删除成功
wangba删除成功
[root@localhost opt]# cat /etc/passwd | grep &ldquo;bash&rdquo;
root:x:0:0:root:/root:/bin/bash
dd:x:1000:1000:cn-tangzheng:/home/cn-tangzheng:/bin/bash</p></li>
</ul>

<p><strong>示例2</strong></p>

<ul>
<li><p>根据主机IP地址检查主机状态</p>

<ul>
<li>IP地址存放在ipadds.txt文件中，每行一个</li>
<li>使用ping命令检测煮鸡蛋连通性

<br />
<br /></li>
</ul>

<p>[root@localhost opt]# vim ipcheck.sh
#!/bin/bash
List=$(cat /opt/ipadds.txt)
for IP in $List
do
  ping -c 3 -i 0.2 -W 3 $IP &gt; /dev/null
  if [ $? -eq 0 ];then
    echo &ldquo;${IP} is up&rdquo;
  else
    echo &ldquo;${IP} is down&rdquo;
  fi
done</p>

<p>[root@localhost opt]# sh ipcheck.sh
192.168.100.100 is down
192.168.1.112 is up
14.0.0.14 is up</p></li>
</ul>

<p><strong>示例三：</strong></p>

<ul>
<li>输出1-10的数</li>
</ul>

<p>法一：</p>

<pre><code>#!/bin/bash
for ((i=1;i&lt;=10;i++))
do
        echo &quot;$i&quot;
done
</code></pre>

<p>法二：</p>

<pre><code>#!/bin/bash
i=1
for ((;i&lt;=10;i++))
do
        echo &quot;$i&quot;
done
</code></pre>

<p>法三：</p>

<pre><code>#!/bin/bash
i=1
for ((;i&lt;=10;))
do
        echo &quot;$i&quot;
        let i++
done
</code></pre>

<p>法四：</p>

<pre><code>#!/bin/bash
i=1
for ((;;))
do
  if [ $i -le 10 ]
        then
        echo &quot;$i&quot;
        let i++
  else
        exit 0
  fi
done
</code></pre>

<p>运行结果：</p>

<pre><code>[root@localhost opt]# ./number.sh 
1
2
3
4
5
6
7
8
9
10
</code></pre>

<h3 id="1-1-3-shell中let命令">1.1.3 shell中let命令</h3>

<ul>
<li><p>let 对整数进行数学运算</p></li>

<li><p>let和双小括号 (( )) 一样，let 命令也只能进行整数运算，不能对小数（浮点数）或者字符串进行运算。</p></li>

<li><p>语法格式</p>

<p>let 表达式
或
let &ldquo;表达式&rdquo;
或
let &lsquo;表达式&rsquo;
以上方式都等价于 ((表达式))</p></li>

<li><p>当表达式中含有 Shell 特殊字符（例如 |）时，需要用双引号&rdquo; &ldquo;或者单引号’ &lsquo;将表达式包围起来。</p></li>

<li><p>和 (( )) 类似，let 命令也支持一次性计算多个表达式，并且以最后一个表达式的值作为整个 let 命令的执行结果</p></li>
</ul>

<h2 id="1-2-while-循环语句">1.2 while 循环语句</h2>

<h3 id="1-2-1-while语句结构">1.2.1 while语句结构</h3>

<ul>
<li><p>重复测试某个条件，只要条件成立则反复执行</p>

<p>语句结构
while 条件测试操作
do
    命令序列
done</p>

<p>语句结构示例
while 未猜中正确的价格
do
    反复猜测商品价格
done</p></li>
</ul>

<p>流程图：<br />
<a href="https://img.it610.com/image/info8/144a0bf149994f7397dc5c8658b6afb4.jpg"><img src="https://img.it610.com/image/info8/144a0bf149994f7397dc5c8658b6afb4.jpg" alt="shell编程之循环语句与函数（for、while、until循环、shell函数与数组的使用）_第2张图片" /></a></p>

<h3 id="1-2-2-while语句应用示例">1.2.2 while语句应用示例</h3>

<p><strong>示例1</strong></p>

<ul>
<li><p>1-100不能被三整除的数</p>

<p>[root@localhost opt]# cat bunengchu3.sh
#!/bin/bash</p>

<p>i=1
while [ $i -lt 100 ]
do
  if [ <code>expr $i % 3</code> -ne 0 ];then
    echo $i
  fi
  let i++
done
[root@localhost opt]# sh bunengchu3.sh
1
2
4
5
7
8
10
11
13
14
16
17
19
20
22
23
25
26
28
29
31
32
34
35
37
38
40
41
43
44
46
47
49
50
52
53
55
56
58
59
61
62
64
65
67
68
70
71
73
74
76
77
79
80
82
83
85
86
88
89
91
92
94
95
97
98</p></li>
</ul>

<p><strong>示例2</strong></p>

<ul>
<li><p>while死循环<br />
while true：死循环有时候也有奇效，可与用户交互</p>

<p>#!/bin/bash
while true
do
  read -p &ldquo;请输入yes退出：&rdquo; KEY
  if [ $KEY = yes ]
        then
          break
  fi
done
echo &ldquo;正常退出&rdquo;</p>

<p>[root@localhost opt]# ./sixunhuan.sh
请输入yes退出：no
请输入yes退出：1
请输入yes退出：d
请输入yes退出：！
请输入yes退出：a
请输入yes退出：yes
正常退出</p></li>
</ul>

<p><strong>示例3</strong></p>

<ul>
<li><p>猜商品价格游戏</p>

<ul>
<li><p>通过变量RANDOM获得随机数</p></li>

<li><p>提示用户猜测并记录次数，猜中后退出循环</p></li>
</ul>

<p>#!/bin/bash
A=<code>expr $RANDOM % 1000</code>
i=0
echo &ldquo;商品的实际价格为0-999之间，猜猜看是多少？&rdquo;
read -p &ldquo;请输入你猜测的价格数目：&rdquo; num
while [ $num -le 999 ] &amp;&amp; [ $num -ge 1 ]
do
        let i++
     if [ $num -eq $A ]
        then
        echo &ldquo;恭喜你答对了，实际价格是$A&rdquo;
        echo &ldquo;你一共猜测了$i 次&rdquo;
        exit 0
     elif [ $num -lt $A ]
        then
        echo &ldquo;太低了&rdquo;
        read -p &ldquo;请输入你猜测的价格数目：&rdquo; num
     else
        echo &ldquo;太高了&rdquo;
        read -p &ldquo;请输入你猜测的价格数目：&rdquo; num
     fi
  done</p></li>
</ul>

<h3 id="continue和break">continue和break</h3>

<p><strong>continue</strong></p>

<pre><code>命令格式
continue n

n 表示循环的层数：
如果省略 n，则表示 continue 只对当前层次的循环语句有效，遇到 continue 会跳过本次循环，忽略本次循环的剩余代码，直接进入下一次循环。
如果带上 n，比如 n 的值为 2，那么 continue 对内层和外层循环语句都有效，不但内层会跳过本次循环，外层也会跳过本次循环，其效果相当于内层循环和外层循环同时执行了不带 n 的 continue。这么说可能有点难以理解，稍后我们通过代码来演示。
continue 关键字也通常和 if 语句一起使用，即满足条件时便跳出循环。 
</code></pre>

<p>流程图：<br />
<a href="https://img.it610.com/image/info8/b66264ca3d0a4e72a2cb75f14be8bf0a.jpg"><img src="https://img.it610.com/image/info8/b66264ca3d0a4e72a2cb75f14be8bf0a.jpg" alt="shell编程之循环语句与函数（for、while、until循环、shell函数与数组的使用）_第3张图片" /></a><br />
<strong>break</strong></p>

<pre><code>命令格式
break n
n 表示跳出循环的层数，如果省略 n，则表示跳出当前的整个循环。
break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。
</code></pre>

<p>流程图：<br />
<a href="https://img.it610.com/image/info8/13b83fd7d44d477293e4a4f8ee0a1749.jpg"><img src="https://img.it610.com/image/info8/13b83fd7d44d477293e4a4f8ee0a1749.jpg" alt="shell编程之循环语句与函数（for、while、until循环、shell函数与数组的使用）_第4张图片" /></a></p>

<ul>
<li><strong>break和continue的区别</strong><br />
break 用来结束所有循环，循环语句不再有执行的机会；continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。</li>
</ul>

<h2 id="1-3-until循环语句">1.3 until循环语句</h2>

<h3 id="1-3-1-until语句的结构">1.3.1 until语句的结构</h3>

<ul>
<li><p>重复测试某个条件，只要条件不成立则反复执行</p>

<p>until 条件测试操作
do
 命令序列
done</p>

<p>while 未超过10
do
 数字依次增加
done</p></li>
</ul>

<p>流程图：<br />
<a href="https://img.it610.com/image/info8/60fc21fc8f564cac937b3f13b0da17c4.jpg"><img src="https://img.it610.com/image/info8/60fc21fc8f564cac937b3f13b0da17c4.jpg" alt="shell编程之循环语句与函数（for、while、until循环、shell函数与数组的使用）_第5张图片" /></a></p>

<h3 id="1-3-2-until语句应用示例">1.3.2 until语句应用示例</h3>

<ul>
<li><p>计算1–50的和</p></li>

<li><p>通过循环累加的方式计算1–50的和</p>

<p>#!/bin/bash
i=1
sum=0
until [ $i -eq 51 ]
do
  echo &ldquo;$i&rdquo;
  let sum+=$i
  let i++
done
echo &ldquo;和：$sum&rdquo;
[root@localhost opt]# ./jisuan.sh
1275</p></li>
</ul>

<p><strong>示例2</strong></p>

<ul>
<li><p>为指定用户发送在线消息</p>

<ul>
<li>若指定用户不在线（未登陆系统），则每5S试一次，直至用户登录系统后再发送信息</li>
</ul></li>

<li><p>用户名与消息通过为止参数传递给脚本</p></li>
</ul>

<p>条件：<br />
1、位置参数个数大于1<br />
2、姓名属于系统用户 /etc/passwd<br />
3、用户是否在线 until who<br />
4、发送消息 echo ”消息“ | write 用户名</p>

<pre><code>[root@localhost opt]# vim usertalk.sh
#!/bin/bash
username=$1
#格式参数不能为空
if [ $# -lt 1 ];then
  echo &quot;Usage:`basename $0`  []&quot;
  exit 1  #异常退出
fi
#验证是否属于系统用户
if grep &quot;^$username&quot; /etc/passwd &gt; /dev/null;then :  
#后面加冒号就可以不用&gt;接着写了
else
  echo &quot;no user&quot;
  exit  2
fi
#测试用户是否在线，如果不在线，每5s联系一次
until who | grep &quot;$username&quot; &gt; /dev/null;do
  echo &quot;user not login&quot;
  sleep 5
done
#发送消息
echo &quot;$2&quot; | write &quot;$username&quot;
echo &quot;${username}发送成功&quot;
</code></pre>

<h1 id="二-shell函数">二、shell函数</h1>

<h2 id="2-1-shell函数概述">2.1 shell函数概述</h2>

<ul>
<li>将命令序列按格式写在一起</li>
<li>可方便重复使用命令序列</li>

<li><p>Shell函数定义</p>

<p>[function] fun_name () {
命令序列
[retrun n]    ########返回的是状态码
[echo n]    ######返回的是值
}
fun_name    #########调用函数</p></li>

<li><p>其中，return返回的是状态码，需要使用$?调取</p>

<ul>
<li><p>echo 返回的是值，使用变量调用</p></li>

<li><p>传参：指位置变量</p></li>

<li><p>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</p></li>

<li><p>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</p></li>
</ul>

<p>函数名 [参数1] [参数2]</p></li>

<li><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p></li>

<li><p>10不能获取第十个参数，获取第十个参数需要10 不能获取第十个参数，获取第十个参数需要10不能获取第十个参数，获取第十个参数需要{10}。当n&gt;=10时，需要使用${n}来获取参数。</p></li>
</ul>

<h2 id="2-1-1-函数应用示例">2.1.1 函数应用示例</h2>

<p><strong>示例1</strong></p>

<ul>
<li><p>两个数字求和</p>

<ul>
<li>通过sum(){}定义函数</li>
<li>使用read命令交互输入两个数并求和

<br />
<br /></li>
</ul>

<p>[root@localhost opt]# vim hanshu1.sh
#!/bin/bash
function sum(){
  read -p &ldquo;请输入加数：&rdquo; num1
  read -p &ldquo;请输入被加数：&rdquo; num2
  sum=$(expr $num1 + $num2)
  [return abc]   #####中括号表示可有可无
  [echo $sum]
}
sum
#函数返回值在调用该函数后通过 $? 来获得
echo &ldquo;返回值是：$?&rdquo;
echo &ldquo;和是：$sum&rdquo;</p>

<p>[root@localhost opt]# sh hanshu1.sh
请输入加数：45
请输入被加数：54
hanshu1.sh: 第 6 行:return: abc: 需要数字参数
返回值是：255  ####说明返回值是错的
和是：99
由于shell状态码最大是255，所以当返回值大于255时会出错</p></li>
</ul>

<p><strong>示例2</strong></p>

<ul>
<li><p>全局声明函数</p>

<ul>
<li>如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用

<br />
<br /></li>
</ul>

<p>[root@localhost ~]# vim .bashrc （局部声明）
[root@localhost ~]# source .bashrc （更新）
[root@localhost ~]# vim /etc/profile
pathmunge () {
    case &ldquo;:${PATH}:&rdquo; in
        <em>:&ldquo;$1&rdquo;:</em>)
            ;;
        *)
            if [ &ldquo;$2&rdquo; = &ldquo;after&rdquo; ] ; then
                PATH=$PATH:$1
            else
                PATH=$1:$PATH
            fi
    esac
}
[root@localhost ~]# source /etc/profile</p></li>
</ul>

<p><strong>两个环境变量：<br />
.bashrc 用户环境变量文件<br />
/etc/profile 系统环境变量</strong></p>

<h2 id="2-2-函数的作用范围">2.2 函数的作用范围</h2>

<ul>
<li>函数在shell脚本中仅在当前shell环境中有效</li>
<li>shell脚本中变量默认全局有效</li>
<li>将变量限定在函数内部使用local命令</li>

<li><p>示例</p>

<p>[root@localhost ~]# vim fun_scope.sh
myfun ()
{
local i i=8 echo $i
}
i=9 myfun echo $i
[root@localhost ~]# chmod +x fun_scope.sh
[root@localhost ~]# ./fun_scope.sh
8
9</p></li>

<li><p>上述脚本中，myfun 函数内部使用了 local 命令设置变量 i，其作用是将变量 i 限定在函数内部。myfun 函数外部同样定义了变量 i，内部变量 i 和全局变量 i 互不影响。脚本执行时先调用了函数 myfun，函数内部变量 i 为 8，所以输出结果是 8。调用完函数之后，给变量i 赋值为 9，再打印外部变量 i，所以又输出 9。</p></li>
</ul>

<h2 id="2-3-函数的参数">2.3 函数的参数</h2>

<p><strong>参数的用法</strong></p>

<pre><code>函数名称 参数 1 参数 2 参数 3 ......
</code></pre>

<p><strong>参数的表示方法</strong><br />
$1、$2、$3…… ${10} ${11}</p>

<h2 id="2-4-递归函数">2.4 递归函数</h2>

<ul>
<li><p>调用自己本身的函数</p></li>

<li><p>示例</p>

<ul>
<li>递归遍历目录，读取/var/log目录及其子目录</li>
<li>通过定义递归函数list_files来实现

<br />
<br /></li>
</ul>

<p>[root@localhost opt]# vim digui.sh</p>

<p>#!/bin/bash
function list_files(){
  for f in <code>ls $1</code>
  do
    #判断是否为目录
    if [ -d &ldquo;$1/$f&rdquo; ]
    then
      echo &ldquo;$2$f&rdquo;
      #递归调用
      list_files &ldquo;$1/$f&rdquo; &ldquo;  $2&rdquo;      ##递归自己调自己，又变成$1了
    else
      echo &ldquo;$2$f&rdquo;
    fi
  done
}
list_files &ldquo;/var/log&rdquo; &ldquo;&rdquo;</p>

<p>[root@localhost opt]# sh digui.sh
anaconda
  anaconda.log
  ifcfg.log
  journal.log
  ks-script-MdTpNR.log
  packaging.log
  program.log
  storage.log
  syslog
  X.log
audit
  audit.log
boot.log
boot.log-20200716
boot.log-20200719
boot.log-20200720
btmp
chrony
cron
cron-20200719
cups
  access_log
  access_log-20200719
  error_log
  page_log
dmesg
dmesg.old
firewalld
gdm
  :0-greeter.log
  :0-greeter.log.1
  :0-greeter.log.2
  :0-greeter.log.3
  :0-greeter.log.4
  :0.log
  :0.log.1
  :0.log.2
  :0.log.3
  :0.log.4
  :1-greeter.log
  :1.log
glusterfs
grubby_prune_debug
lastlog
libvirt
  qemu
maillog
maillog-20200719
messages
messages-20200719
ntpstats
pluto
  peer
ppp
qemu-ga
rhsm
sa
  sa15
  sa16
  sa17
  sa18
  sa19
  sa20
  sar16
  sar17
  sar18
  sar19
samba
  old
secure
secure-20200719
speech-dispatcher
spooler
spooler-20200719
sssd
swtpm
  libvirt
    qemu
tallylog
tuned
  tuned.log
vmware-network.1.log
vmware-network.2.log
vmware-network.3.log
vmware-network.4.log
vmware-network.5.log
vmware-network.6.log
vmware-network.log
vmware-vgauthsvc.log.0
vmware-vmsvc.log
vmware-vmusr.log
wpa_supplicant.log
wtmp
xferlog
Xorg.0.log
Xorg.0.log.old
Xorg.1.log
Xorg.9.log
yum.log</p></li>
</ul>

<h1 id="三-shell数组">三、shell数组</h1>

<h2 id="3-1-shell数组概述">3.1 shell数组概述</h2>

<ul>
<li>在 Shell 脚本中，数组是一种常见的数据结构，主要的 <strong>应用场景包括：获取数组长度、获取元素长度、遍历元素、元素切片、元素替换、元素删除等等</strong> 。</li>
<li>Shell 中的数组与 Java、C、Python 不同，只有一维数组，没有二维数组。</li>
<li>数组元素的大小与限制，也不需要事先定义。Shell 数组用括号（）来表示，元素用空格分隔，元素的下标与大部分编程语言类似从 0 开始。</li>
</ul>

<h2 id="3-2-shell数组定义方法">3.2 shell数组定义方法</h2>

<h3 id="方法一">方法一</h3>

<p>数组名=（value0 value1 value2 …）</p>

<pre><code>[root@localhost opt]# num=(11 22 33 44)
[root@localhost opt]# echo $num     ###这样调不出来
11
[root@localhost opt]# echo ${num[*]}       ###*代表全部，[]代表元素的下标
11 22 33 44
[root@localhost opt]# echo ${num[2]}          
33
</code></pre>

<h3 id="方法二">方法二</h3>

<p>数组名=（[0]=value [1]=value [2]=value …）</p>

<pre><code>[root@localhost opt]# num=([0]=55 [1]=66 [2]=77 [3]=88)
[root@localhost opt]# echo ${num[@]}          ########@和*都表示所有
55 66 77 88
[root@localhost opt]# echo ${num[*]}
55 66 77 88
</code></pre>

<h3 id="方法三">方法三</h3>

<p>列表名=”value0 value1 value2 …”<br />
数组名=（$列表名）</p>

<pre><code>[root@localhost opt]# list=&quot;11 12 13 14&quot;      ####先定义列表，列表再赋值给数组
[root@localhost opt]# num=($list)
[root@localhost opt]# echo ${num[*]}
11 12 13 14
</code></pre>

<h3 id="方法四">方法四</h3>

<p>数组名[0]=”value” 数组名[1]=”value” 数组名[2]=”value”</p>

<pre><code>方法四一般用来作替换，替换掉某一个元素
[root@localhost opt]# echo ${num[*]}
11 12 13 14
[root@localhost opt]# num[1]=88
[root@localhost opt]# echo ${num[*]}
11 88 13 14
</code></pre>

<h2 id="3-3-数组包括的数据类型">3.3 数组包括的数据类型</h2>

<h3 id="数值类型">数值类型</h3>

<h3 id="字符类型">字符类型</h3>

<ul>
<li><p>使用**“” <strong>或</strong> ’’**定义（双引号或单引号）</p>

<p>如：[11，22，33，44]    在内存中开辟了连续的空间
  配合着循环使用</p>

<p>数组名称：arr                                    arr=（11,22,33,44）      索引
数组元素：如11                                             0   1   2   3
数组长度 ：4 （元素的个数）
数组下标：33元素的下标值是2</p></li>
</ul>

<h2 id="3-4-shell数组应用示例">3.4 shell数组应用示例</h2>

<p><strong>需求：创建一个1-100的数组</strong></p>

<pre><code>[root@localhost opt]# vim arr.sh
#!/bin/bash
for ((i=0;i&lt;=99;i++));do
  arr[$i]=$[$i+1]
done
echo ${arr[*]}
</code></pre>

<p><strong>创建存放（1-100）奇数的数组：</strong><br />
分析：</p>

<pre><code>下标     元素        增量
0         1           1
1         3           2
2         5           3
3         7           4
$i        $k          $j
k=$i+$j



[root@localhost opt]# vim arr02.sh
#!/bin/bash
#创建存放（1-100)奇数的数组
k=0  #元素
j=1  #增量
for ((i=0;i&lt;=99;i++))
do
  k=$[$i+$j]
  let j++
  #最大元素不能超过100
  if [ $k -le 100 ]
  then
    arr[$i]=$k
  fi
done
echo ${arr[*]}
[root@localhost opt]# sh arr02.sh
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99
</code></pre>

<p><strong>创建任意数字及长度的数组，根据客户需求加入元素：</strong><br />
分析：</p>

<pre><code>利用好死循环和break

while 条件始终成立
do
  if 判断成立
    break
done



[root@localhost opt]# vim arr03.sh

#!/bin/bash
#创建任意数字及长度的数组，根据客户需求
i=0 #数组下标
while true
do
  read -p &quot;是否存入元素（yes/no）：&quot; doing
  if [ $doing == &quot;no&quot; ];then
    break
  fi
  read -p &quot;请输入第$[$i+1]个元素：&quot; key
  arr[$i]=$key
  let i++
done
echo ${arr[*]}
echo ${#arr[@]}    ##数组长度

[root@localhost opt]# sh arr03.sh
是否存入元素（yes/no）：yes
请输入第1个元素：33
是否存入元素（yes/no）：yes
请输入第2个元素：66
是否存入元素（yes/no）：yes
请输入第3个元素：99
是否存入元素（yes/no）：no
33 66 99
</code></pre>

<h2 id="3-4-shell数组操作">3.4 shell数组操作</h2>

<h3 id="获取数组长度">获取数组长度</h3>

<pre><code>[root@localhost ~]# arr_number=(1 2 3 4 5) 
[root@localhost ~]# arr_length=${#arr_number[*]} 
[root@localhost ~]# echo $arr_length
5
[root@localhost ~]# arr_length_1=${#arr_number[@]}
[root@localhost ~]# echo $arr_length_1
5
</code></pre>

<h3 id="读取某下标赋值">读取某下标赋值</h3>

<pre><code>[root@localhost ~]# arr_index2=${arr_number[2]} //第三个元素
[root@localhost ~]# echo $arr_index2
3
</code></pre>

<h3 id="数组遍历">数组遍历</h3>

<pre><code>[root@localhost ~]# vim array_traverse.sh
#!/bin/bash 
arr_number=(1 2 3 4 5) 
for v in ${arr_number[@]} 
do
  echo $v 
done

[root@localhost ~]# chmod +x array_traverse.sh
[root@localhost ~]# ./array_traverse.sh
1
2
3
4
5
</code></pre>

<h3 id="数组切片">数组切片</h3>

<pre><code>[root@centos-7 ~]# arr=(1 2 3 4 5)
[root@centos-7 ~]# echo ${arr[@]}   //输出整个数组
1 2 3 4 5
[root@centos-7 ~]# echo ${arr[@]:0:2}   //${数组名[@或*]:起始位置:长度} 
1 2
[root@centos-7 ~]# echo ${arr[@]:2:3}
3 4 5
</code></pre>

<p>将数组切片之后，返回的是字符串，以空格作为分隔符。</p>

<h3 id="数组替换">数组替换</h3>

<pre><code>[root@centos-7 ~]# arr=(1 2 3 4 5)
[root@centos-7 ~]# echo ${arr[@]/4/66}  //${数组名[@或*]/查找字符/替换字符} 
1 2 3 66 5
[root@centos-7 ~]# echo ${arr[@]}   //并不会替换数组原有内容
1 2 3 4 5
[root@centos-7 ~]# arr=(${arr[@]/4/66}) //要实现改变原有数组，可通过重新赋值实现
[root@centos-7 ~]# echo ${arr[@]}
1 2 3 66 5
</code></pre>

<p>只是临时的更改输出，把原来的一份复制到缓冲区中，原来的没变<br />
永久修改就把原来内容的覆盖掉<br />
num=(${num[*]/44/88})</p>

<h3 id="数组删除">数组删除</h3>

<pre><code>[root@centos-7 ~]# arr=(1 2 3 4 5)
[root@centos-7 ~]# unset arr    //删除数组
[root@centos-7 ~]# echo ${arr[*]}

[root@centos-7 ~]# arr=(1 2 3 4 5)
[root@centos-7 ~]# unset arr[2] //删除第三个元素
[root@centos-7 ~]# echo ${arr[*]}
1 2 4 5
</code></pre>

<p><strong>示例</strong><br />
删除低于数组中低于60分的成绩：</p>

<pre><code>[root@localhost opt]# vim chengji04.sh

#!/bin/bash
score=(77 88 55 33 99 44)
i=0
for v in ${score[@]};do
  if [ ${score[$i]} -lt 60 ];then
    unset score[$i]
  fi
  let i++
done
echo ${score[@]} 
[root@localhost opt]# sh chengji04.sh
77 88 99
</code></pre>

<h1 id="四-shell脚本调试">四、shell脚本调试</h1>

<h2 id="echo命令">echo命令</h2>

<p>echo 命令是最有用的调试脚本工具之一，一般在可能出现问题的脚本中加入 echo 命令，采用的是分段排查的方式</p>

<h2 id="bash命令">bash命令</h2>

<p>命令的语法为</p>

<pre><code>sh [-nvx] 脚本名
</code></pre>

<p><strong>常用参数的具体含义为：</strong></p>

<ul>
<li>-n：不会执行该脚本，仅查询脚本语法是否有问题，如果没有语法问题就不显示任 何内容，如果有问题会提示报错。</li>
<li>-v：在执行脚本时，先将脚本的内容输出到屏幕上然后执行脚本，如果有错误，也 会给出错误提示。</li>
<li>-x：将执行的脚本内容输出到屏幕上，这个是对调试很有用的参数。</li>
</ul>

<h2 id="set命令">set命令</h2>

<pre><code>set -x  //开启调试模式
set +x  //关闭调试模式



#!/bin/bash
set -x  //开启调试模式
read -p &quot;请输入您的分数(0-100):&quot; GRADE
if [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ]  
then
echo &quot;$GRADE 分!优秀&quot;
set +x  //关闭调试模式
elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -le 84 ]  
then
  echo &quot;$GRADE 分,合格&quot;
else 
  echo &quot;$GRADE 分？不合格&quot;
fi
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>