<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>9Shell脚本基础变量数值运算条件判断if和case语句等 | 开发者问答集锦</title>
    <meta property="og:title" content="9Shell脚本基础变量数值运算条件判断if和case语句等 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="9Shell脚本基础变量数值运算条件判断if和case语句等">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/9shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E5%8F%98%E9%87%8F%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADif%E5%92%8Ccase%E8%AF%AD%E5%8F%A5%E7%AD%89/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">9Shell脚本基础变量数值运算条件判断if和case语句等</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="一些基础知识">一些基础知识</h3>

<h4 id="程序">程序</h4>

<p>程序：算法+数据结构<br />
数据：是程序的核心<br />
数据结构：数据在计算机中的类型和组织方式<br />
算法：处理数据的方式</p>

<h4 id="程序编程风格">程序编程风格：</h4>

<p>过程式：以指令为中心，数据服务于指令<br />
对象式：以数据为中心，指令服务于数据</p>

<ul>
<li>shell程序：提供了编程能力，解释执行</li>
</ul>

<h4 id="程序的执行方式">程序的执行方式</h4>

<p>计算机：运行二进制指令<br />
编程语言：人与计算机之间交互的语言<br />
低级编程语言：<br />
机器：二进制的0和1的序列，称为机器指令。与自然语言差异太大，难懂、难写<br />
汇编：用一些助记符号替代机器指令，称为汇编语言<br />
如：ADD A,B 将寄存器A的数与寄存器B的数相加得到的数放到寄存器A中<br />
汇编语言写好的程序需要汇编程序转换成机器指令<br />
汇编语言稍微好理解，即机器指令对应的助记符，助记符更接近自然语言<br />
高级编程语言：<br />
编译：高级语言&ndash;&gt;编译器&ndash;&gt;机器代码&ndash;&gt;执行<br />
C，C++<br />
解释：高级语言&ndash;&gt;执行&ndash;&gt;解释器&ndash;&gt;机器代码<br />
shell，python，php，JavaScript，perl</p>

<hr />

<p><a href="https://img.it610.com/image/info8/14fb1576905e4999ad33147e25416f08.jpg"><img src="https://img.it610.com/image/info8/14fb1576905e4999ad33147e25416f08.jpg" alt="9.Shell脚本基础，变量，数值运算，条件判断，if和case语句等_第1张图片" /></a></p>

<hr />

<h4 id="编程逻辑处理方式">编程逻辑处理方式：</h4>

<p>顺序执行<br />
循环执行<br />
选择执行</p>

<h4 id="shell编程-过程式-解释执行">shell编程：过程式、解释执行</h4>

<p>编程语言的基本结构：<br />
各种系统命令的组合<br />
数据存储：变量、数组<br />
表达式：例如 a + b<br />
语句：例如if ，for</p>

<h3 id="shell脚本">SHELL脚本</h3>

<h4 id="shell脚本-1">shell脚本:</h4>

<p>包含一些命令或声明，并符合一定格式的文本文件<br />
格式要求：首行shebang机制<br />
#!/bin/bash<br />
#!/usr/bin/python<br />
#!/usr/bin/perl</p>

<h4 id="shell脚本的用途有">shell脚本的用途有：</h4>

<p>自动化常用命令<br />
执行系统管理和故障排除<br />
创建简单的应用程序<br />
处理文本或文件</p>

<h4 id="创建shell脚本">创建shell脚本</h4>

<ol>
<li><p>第一步：使用文本编辑器来创建文本文件<br />
第一行必须包括shell声明序列：#!<br />
示例：#!/bin/bash :centos7 里面/bin 和/user/bin相同，/bin就是一个软链接<br />
添加注释<br />
注释以#开头</p></li>

<li><p>第二步：运行脚本<br />
给予执行权限，在命令行上指定脚本的绝对或相对路径<br />
直接运行解释器，将脚本作为解释器程序的参数运行</p>

<ul>
<li>注意：写脚本后缀虽然没有要求（linux不看后缀），但尽量写成sh，容易分辨，同时脚本名称要与功能相关</li>
<li>加了执行权限之后，因为它既不在PATH中，也没有存入hash表中，因此想要执行这个脚本，有下面几种方式：</li>
</ul></li>

<li><p>直接写绝对路径</p></li>

<li><p>把当前目录加入PATH路径中 PATH=./:$PATH，用这个方法执行时脚本要在当前目录</p></li>

<li><p>把脚本存放的目录的绝对路径存放到PATH中 PATH=/dir:$PATH</p>

<ul>
<li>注意：如果只在shell里修改，则退出无法保存，因此要写到文件中，文件家目录为/etc/profile.d/####.sh ,可以仍然写在之前定义的evn.sh中</li>
</ul></li>

<li><p>即使脚本没有执行权限，也可以用 bash 脚本路径 的方式来执行它，就相当于是运行解释器执行了脚本</p></li>

<li><p>上面方法的变种: cat 脚本 | bash ,它可以用在浏览器上来进行远程执行，许多安装程序就是这样做的.<br />
例子：</p>

<p>#后缀改为txt打开192.168.0.2/hello.txt路径则可以在网站上直接查看，后缀为sh则会把它下载下来<br />
scp /data/script/hello.sh 192.168.0.2:/var/www/html
输入口令：
curl <a href="http://192.168.0.2/hello.sh">http://192.168.0.2/hello.sh</a> |bash
#这样就可远程直接运行这个脚本了</p></li>
</ol>

<ul>
<li>如果想要脚本中命令输出带颜色，则例如 echo -e &ldquo;\e[1;33mhello world\e[0m&rdquo;,而更多命令查看转义帮助</li>
<li>注意：想要cat文本显示颜色，则在VIM插入模式下，ctrl+v快捷键[1;33m文本ctrl+v快捷键[0m ,则会显示为×××</li>
</ul>

<h5 id="容易错的部分">容易错的部分：</h5>

<ol>
<li>一定要在insert模式下按ctrl+v，不然会进入visual block模式</li>
<li>注意^[[1;33m文本^[[0m ,注意快捷键会加上一个托字符加[ ,相当于echo里面的\033或者\e ，后面还得再加[</li>
<li>注意中间的分隔符是;分号，不是逗号</li>
</ol>

<h3 id="脚本规范">脚本规范</h3>

<ul>
<li>脚本代码开头约定<br />
1、第一行一般为调用使用的语言<br />
2、程序名，避免更改文件名为无法找到正确的文件<br />
3、版本号<br />
4、更改后的时间<br />
5、作者相关信息<br />
6、该程序的作用，及注意事项<br />
7、最后是各版本的更新简要说明</li>
</ul>

<h3 id="脚本的基本结构">脚本的基本结构</h3>

<p>#!SHEBANG<br />
CONFIGURATION_VARIABLES<br />
FUNCTION_DEFINITIONS<br />
MAIN_CODE</p>

<h3 id="脚本调试">脚本调试</h3>

<h4 id="检测脚本中的语法错误">检测脚本中的语法错误</h4>

<p>bash -n /path/to/some_script</p>

<ul>
<li>注意：脚本中如果有语法错误，当运行它的时候会把语法错误前面的命令全部执行，所以一定要提前检测脚本中的语法错误</li>
</ul>

<h4 id="调试执行">调试执行</h4>

<p>bash -x /path/to/some_script</p>

<ul>
<li>脚本中如果有命令错误，则这一条命令可以不执行，脚本仍然会执行到最后,可以用这个命令来检测每条命令的执行结果</li>
</ul>

<h3 id="变量">变量</h3>

<h4 id="变量相关知识">变量相关知识</h4>

<ul>
<li>静态编译语言：使用变量前，先声明变量类型，之后类型不能改变，在编译时检查，如：java，c</li>
<li>动态编译语言：不用事先声明，可随时改变类型，如bash，Python<br />
-强类型语言：不同类型数据操作，必须经过强制转换才同一类型才能运算，如java ， c# ，python<br />
如：以下python代码<br />
print(‘magedu’+ 10) 提示出错，不会自动转换类型<br />
print(‘magedu’+str(10)) 结果为magedu10，需要显示转换类型<br />
-弱类型语言：语言的运行时会隐式做数据类型转换。无须指定类型，默认均为字符型；参与运算会自动进行隐式类型转换；变量无须事先定义可直接调用<br />
如：bash 不支持浮点数，php，javascript</li>
</ul>

<h4 id="变量基本">变量基本</h4>

<ul>
<li>变量：命名的内存空间</li>

<li><p>变量：变量类型<br />
作用：</p>

<ol>
<li>数据存储方式</li>
<li>参与的运算</li>
<li>表示的数据范围<br />
类型：<br />
字符型<br />
数值型：整型、浮点型</li>
</ol></li>
</ul>

<h4 id="shell中变量命名法则">Shell中变量命名法则：</h4>

<p>1、不能使程序中的保留字：例如if, for<br />
2、只能使用数字、字母及下划线，且不能以数字开头<br />
3、见名知义<br />
4、统一命名规则：驼峰命名法 ：利用下划线或者每个名称开头都大写等等</p>

<h4 id="shell中命名建议规则">Shell中命名建议规则：</h4>

<p>1、变量名大写<br />
2、局部变量小写<br />
3、函数名小写<br />
4、用英文名字，并体现出实际作用</p>

<h3 id="bash中变量的种类">bash中变量的种类</h3>

<ul>
<li><p>根据变量的生效范围等标准划分下面变量类型<br />
局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程，包括当前shell的子shell进程均无效<br />
环境变量：生效范围为当前shell进程及其子进程<br />
本地变量：生效范围为当前shell进程中某代码片断，通常指函数<br />
位置变量：$1, $2, &hellip;来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数<br />
特殊变量：$?, $0, $*, $@, $#,$$</p></li>

<li><p>$$:当前的shell进程编号PID :可用echo $$显示，或者echo $BASHPID; 上一级bashPID可以用 echo $PPID</p></li>
</ul>

<h3 id="局部变量">局部变量</h3>

<ul>
<li>变量赋值：name=‘value’</li>

<li><p>可以使用引用value<br />
(1) 可以是直接字串：name=“root&rdquo;<br />
(2) 变量引用：name=&ldquo;$USER&rdquo;<br />
(3) 命令引用：name=<code>COMMAND</code> ,name=$(COMMAND)</p></li>

<li><p>注意：之前也总结过，变量的引用用$或者${} ,而命令的引用用 ``或者$(),注意括号的区别. 一个是变量，一个是命令.<br />
变量引用：${name} 或者 $name<br />
&rdquo; &ldquo; 弱引用，其中的变量引用会被替换为变量值<br />
&rsquo; &lsquo; 强引用，其中的变量引用不会被替换为变量值，而保持原字符串</p></li>

<li><p>显示已定义的所有变量：set 注意set显示的不仅仅是变量，还有函数等</p></li>

<li><p>删除变量：unset name<br />
<strong>- pstree ：进程树状结构 -p 可以显示PID</strong></p>

<p>18:26[root@centos7 /data]# which init
/usr/sbin/init
18:26[root@centos7 /data]# ll /usr/sbin/init
lrwxrwxrwx. 1 root root 22 Mar  5 21:16 /usr/sbin/init -&gt; ../lib/systemd/systemd</p></li>
</ul>

<h3 id="环境变量">环境变量</h3>

<ul>
<li><p>变量声明、赋值：<br />
export name=VALUE<br />
declare -x name=VALUE<br />
export name<br />
declare -x name</p></li>

<li><p>变量引用：<br />
$name, ${name}</p></li>

<li><p>显示所有环境变量：<br />
env<br />
printenv<br />
export<br />
declare -x</p></li>

<li><p>删除变量：<br />
unset name</p></li>

<li><p>()自动开启子进程</p></li>
</ul>

<h3 id="注意点">注意点：</h3>

<ol>
<li>变量赋值的时候 变量=所附的值 ，它们之间不能有任何的空格，如果想要所附的值与=之前有空格，需使用&rdquo; &ldquo;&rdquo; `` 等括起来才可（原因是会把空格当做分隔符，变量= 会看做命令从而找不到出现错误）.最好方式就是都加上双引号，不要省略默认的双引号，避免空格（被看做分隔符）引起的错误。</li>
<li>变量赋值如果后面的字符串不加上双引号，则以空格为分隔符）因此，如果是一个整参数但其中有空格，必须加上双引号包住</li>
<li>很多命令后面的参数也是这样，空格会把他们分成多个参数，比如 mkdir &ldquo; /data/backup/<code>date &quot;+%F %T&quot;</code>&rdquo; ,date后面的两个参数得加上双引号包住，同时又因为date后面两个参数之间有空格，如果mkdir后面整体不加上双引号，则会看作是两个文件夹并给它创建上了,一个在backup文件夹内，另一个在当前文件夹内.</li>
<li>可以用echo $变量$变量 同时显示两个变量 ，但不可echo $变量变量 ，这样会把变量变量看做一个变量， 同上面前两条相同的逻辑，都是以空格为分隔符.</li>
<li>$名字 ，如果不以数字开头的名字这个变量并不存在，则echo $名字 则会输出空行</li>
<li>$#.<em>,如果以数字开头，则会把$#这个看作是一个变量（参考$#当做引用参的特殊变量），echo $#.</em> 输出它的值（若为空值就是输出空），然后输出后面的.*里的字符内容。注意原本的变量规定不能以数字开头。</li>
<li>$###,如果要原封不动书画粗，则 echo $### ，要么用&rdquo;单引号包含，要么用转义字符\ ，例如echo \$100</li>
<li>如果要输出转义字符，则需要写成\\，若要输出两个\，则要 echo \\\\ ,</li>
<li>NUM=1 ,可以输出 echo No$NUM ,不可输出 echo $NUMNo ,必须 echo ${NUM}No 或者echo &ldquo;$NUM&rdquo;No .注意：花括号是包含在变量外面的 ，双引号是包含在变量外加$字符整体外面的</li>
<li>M=10 ，N=$M ,则 echo $N 结果为10 ，但是如果这时候修改M的赋值， 比如M=20 ，则echo $N 结果仍然为10 .</li>
<li>主要是因为当创建N的时候虽然引用的是M的值，但是N变量会开创一个新的数据空间，存入一个10的数据，N和M指向的并不是同一个数据空间，只是内部的数值相同而已. 此时更改M的值，只是把M的数据空间内的值改掉，N指向的数据控件的值仍然是10，已经和M无关了.(疑问：到底是M的指向在赋值的时候重新更改了，N创建的时候和M指向的是同一个现在仍然没有变化；还是说N创建的时候指向的就是新开辟的数据空间，只是引用了M的数据把10这个数值存入进去而已？)</li>

<li><p>变量赋值的时候不仅可以引用别的变量的内容（第9个注意点，它只是省略了双引号），也可以引用命令的输出结果，不过注意要用反向双引号；当用echo显示变量内容时如果想要保留命令输出结果中的各种换行符等等，需要在$变量外加双引号，注意双引号是加在echo命令后面的$变量整体外面的。原因经过例子也可看出例如：</p>

<p>18:02[root@centos7 /data]# Userinfo=&rdquo;     &ndash;1  <code>who</code>  &ldquo;
18:03[root@centos7 /data]# echo $Userinfo
&ndash;1 root pts/0 2019-03-16 08:56 (gateway) root pts/1 2019-03-16 17:58 (gateway)
18:03[root@centos7 /data]# echo &ldquo;$Userinfo&rdquo;
     &ndash;1  root     pts/0        2019-03-16 08:56 (gateway)
root     pts/1        2019-03-16 17:58 (gateway)</p></li>

<li><p>所有变量都是字符，例子：</p>

<p>18:03[root@centos7 /data]# Num1=10
18:06[root@centos7 /data]# Num2=20
18:06[root@centos7 /data]# Num3=Num1+Num2
18:06[root@centos7 /data]# echo $Num3
Num1+Num2
18:06[root@centos7 /data]# Num3=$Num1+$Num2
18:07[root@centos7 /data]# echo $Num3
10+20</p></li>

<li><p>变量用完最好删除，注意删除的时候直接就unset 变量名 ，不需要加$</p></li>

<li><p>定义的普通变量只能在1当前终端.2当前shell.3不能关机 中使用，不能在其它终端（或者窗口），子shell或者父shell,或则重启后（会消失）使用。</p></li>

<li><p>bash是一个后台持续运行的程序，可以在bash中再开bash子进程，用exit退出</p></li>

<li><p>定义的环境变量也是只能在当前shell和子shell中使用， <strong>不能</strong> 在父进程或者 <strong>重启后使用</strong></p></li>

<li><p>想要自己定义的环境变量开机存在，可以在/etc/profile.d/evn.sh 中写入export name=VALUE即可，不过这个值也只能开机时就是这个值，关机之前最后的值必须手动写入才可。可以自己写一个脚本让环境变量的值关机时保留存入这里。</p></li>

<li><p>set命令不仅可以看普通变量，还可以看环境变量，还可以看其他的函数，等等。PATH是环境变量，PS1不是。</p></li>

<li><p>()自动开启子进程，里面命名的变量不会影响到父进程看例子：</p>

<p>19:49[root@centos7 /data/lintst]# (name=zhang;echo $name)
zhang
19:50[root@centos7 /data/lintst]# echo $name</p>

<p>19:50[root@centos7 /data/lintst]# (name=zhang;echo $name);echo $name
zhang</p>

<p>19:51[root@centos7 /data/lintst]# name=duan;(name=zhang;echo $name);echo $name
zhang
duan
但是如果
19:52[root@centos7 /data/lintst]# name=duan;(echo $name);echo $name
duan
duan
详细一点：
19:56[root@centos7 /data/lintst]# name=duan;echo 1$name;(name=zhang;echo 2$name);echo 3$name
1duan
2zhang
3duan
19:57[root@centos7 /data/lintst]# name=duan;echo 1$name;(echo 2$name);echo 3$name
1duan
2duan
3duan
19:57[root@centos7 /data/lintst]#
更详细一点：
19:57[root@centos7 /data/lintst]# echo $name
duan
19:58[root@centos7 /data/lintst]# (echo $name)
duan
19:58[root@centos7 /data/lintst]# (name=zhang; echo $name)
zhang
19:59[root@centos7 /data/lintst]# echo $name
duan
19:59[root@centos7 /data/lintst]# (echo $name)
duan
经过测试发现，当不进行变量写入（赋值）的时候，并未开启子进程
20:06[root@centos7 /data/lintst]# echo $name;echo a$$;(echo b$$;echo $name);echo $name;echo c$$;sleep 200
duan
a16131
b16131
duan
duan
c16131
但是这样的话：
echo $name;echo a$BASHPID;(echo b$BASHPID;echo $name;);echo $name;echo c$$;sleep 200
duan
a16131
b40122
duan
duan
c16131</p></li>
</ol>

<h3 id="bash内建的环境变量">bash内建的环境变量</h3>

<p>PATH<br />
SHELL<br />
USER<br />
UID<br />
HOME<br />
PWD<br />
SHLVL ：shell嵌套的深度，也就是开了几个shell<br />
LANG<br />
MAIL<br />
HOSTNAME<br />
HISTSIZE<br />
_ 下划线 ：上一个命令的最后一个字符串（或参数，以空格为分隔符来判断）</p>

<ul>
<li><p>附加：</p>

<p>echo ###### | passwd &ndash;stdin zhang
scp -r zhang@###.###.##.### /data/scripts /data/cpdir/</p></li>
</ul>

<h3 id="只读变量-只能声明-但不能修改和删除">只读变量：只能声明，但不能修改和删除</h3>

<ul>
<li><p>声明只读变量：<br />
readonly name<br />
declare -r name</p></li>

<li><p>查看只读变量：<br />
readonly [-p]</p></li>

<li><p>declare -r只读 -x全局 -i数字型</p></li>

<li><p>注意：它删不掉也改不了，只能退出的时候才能去掉</p></li>
</ul>

<h3 id="位置变量-在脚本代码中调用通过命令行传递给脚本的参数">位置变量：在脚本代码中调用通过命令行传递给脚本的参数</h3>

<p>$1, $2, &hellip; 对应第1、第2等参数，shift [n]换位置<br />
$0 命令本身<br />
$* 传递给脚本的所有参数，全部参数合为一个字符串<br />
$@ 传递给脚本的所有参数，每个参数为独立字符串<br />
$# 传递给脚本的参数的个数</p>

<h3 id="注意点-1">注意点：</h3>

<ol>
<li>注意：$@ $* 只在被 <strong>双引号包起来</strong> 的时候才会有差异,类似前面的 变量=<code>who</code> ; echo &ldquo;$变量&rdquo; 需要用双引号引起来

<ul>
<li>想要看出它两个的区别，需要在脚本中的次级脚本中的命令再次进行引用的时候才能看出来。比如初级脚本用$* ，但次级脚本用 &ldquo;$*&rdquo; 和用 $@就会有区别。</li>
</ul></li>
<li>set &ndash; 清空所有位置变量</li>
<li>注意，在history中 !n:m 第n行历史的m个参数 ， *所有 ^第一个 $最后一个</li>
<li>$0命令本身如果用 bash 脚本名的方式来执行，则不会显示路径，只显示名称。但如果直接执行脚本的话会把路径也给显示出来，所以要用basename.(复习：bash 脚本名不需要执行权限，直接执行脚本需要执行权限x)</li>
<li>$#传递参数的时候如果#数字超过10个则必须用{}给括起来不然会当做两个数字.</li>
<li>$0 如果有软链接指向脚本，则运行这个软连接的时候，$0就是这个软链接的名字，但是执行的却是脚本的代码，因此在脚本里面进行判断过后可以输出不同的功能</li>
<li>在脚本里面用shift命令，可以让$1参数去掉，让$2变成$1,后面依次前进1位。当然也可以shift n, 可以一次移位多个。</li>
</ol>

<h3 id="进程使用退出状态来报告成功或失败">进程使用退出状态来报告成功或失败</h3>

<p>0 代表成功，1－255代表失败<br />
$? 变量保存最近的命令退出状态</p>

<ul>
<li>例如：<br />
ping -c1 -W1 hostdown &amp;&gt; /dev/null<br />
echo $?</li>
</ul>

<h3 id="bash自定义退出状态码">bash自定义退出状态码</h3>

<p>exit [n]：可以自定义退出状态码</p>

<ul>
<li>注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字</li>
<li>注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码</li>

<li><p>例子：可以用它来判断命令执行错误与否</p>

<p>ping -c1 -w1 ###.###.###.### &amp;&gt;/dev/null
echo $?</p></li>
</ul>

<h3 id="算术运算">算术运算</h3>

<ul>
<li><p>bash中的算术运算:help let<br />
+, -, *, /, %取模（取余）, **（乘方），乘法符号有些场景中需要转义<br />
实现算术运算：<br />
(1) let var=算术表达式<br />
(2) var=$<a href="3">算术表达式</a> var=$((算术表达式))<br />
(4) var=$(expr arg1 arg2 arg3 &hellip;)
，expr本身具有计算功能，但是后面的参数注意要用空格符分开用来区分,参数只能是数字，可以用$var的方式把变量内的数字当做参数，同时乘号之前要加\需要转义，不然会当做通配符<br />
(5) declare –i var = 数值 , 比如 declare -i N ; N=x+y
便可以直接运算，x,y前不需要再加$等其他符号；或者说赋值和计算同时进行也可以。</p></li>

<li><p>注意：如果将已经定义了数字型的变量赋值字符串，则它的结果为0 ，有问题。<br />
(6) echo ‘算术表达式’ | bc</p></li>

<li><p>注意：上面的算术表达式里面的数值变量（中括号里，小括号里和let后面的）已经不再需要前面加上$符号了，因为已经指定它后面的是数值，既然不是数值就可以判断出它是变量，但是加上也不会错</p>

<p>18:07[root@centos7 /data]# W=$[X*Y]
18:08[root@centos7 /data]# echo $W
12
18:08[root@centos7 /data]# W=$[$X-$Y]
18:09[root@centos7 /data]# echo $W
-1</p></li>

<li><p>bash有内建的随机数生成器变量：$RANDOM（0-32767）<br />
示例：生成 0 - 49 之间随机数<br />
echo $[$RANDOM%50]<br />
例子：随机打印彩色字符$[RANDOM%7+31]或者$[$RANDOM%7+31]或者 CNUM=$[RANDOM%7+31]</p>

<p>echo -e &ldquo;\033[$[RANDOM%7+31]mCOLOR\033[0m&rdquo;
或者 echo -e &ldquo;\033[${NCUM}mCOLOR\033[0m&rdquo;</p></li>
</ul>

<h3 id="赋值">赋值</h3>

<ul>
<li><p>增强型赋值：<br />
+=, -=, *=, /=, %=</p></li>

<li><p>let varOPERvalue<br />
例如:let count+=3<br />
自加3后自赋值</p></li>

<li><p>自增，自减：<br />
let var+=1<br />
let var++<br />
let var++<br />
let var-=1<br />
let var&ndash; ：先赋值再计算<br />
let &ndash;var :先计算再赋值 比如 let j=i++ 和let j=++i ,结果就不同。</p></li>

<li><p>注意：只能用let命令来控制上面的这些</p></li>
</ul>

<h3 id="逻辑运算">逻辑运算</h3>

<ul>
<li><p>true, false<br />
1, 0</p></li>

<li><p>与 &amp;<br />
1 与 1 = 1<br />
1 与 0 = 0<br />
0 与 1 = 0<br />
0 与 0 = 0</p></li>

<li><p>或 |<br />
1 或 1 = 1<br />
1 或 0 = 1<br />
0 或 1 = 1<br />
0 或 0 = 0</p></li>

<li><p>非：！<br />
! 1 = 0 ! true<br />
! 0 = 1 ! false</p></li>

<li><p>短路运算<br />
短路与 &amp;&amp; ： cmd1 &amp;&amp; cmd2</p></li>

<li><p>注：它先判断cmd1,根据它的结果真假，再判断cmd2是否需要执行；最后它整体也会输出一个判断值，下同。<br />
第一个为0，结果必定为0<br />
第一个为1，第二个必须要参与运算<br />
短路或 ||<br />
第一个为1，结果必定为1<br />
第一个为0，第二个必须要参与运算</p></li>

<li><p>注意： 可以 ###### &amp;&amp; ###### || ###### ,能够有判断效果</p></li>

<li><p>在某种情况下也可以 ##### || ##### &amp;&amp; ##### ,这样的时候需要仔细判断</p></li>

<li><p>注意，想要##### 作为一个整体，不能用小括号，它开了一个子进程，要用中括号。</p></li>

<li><p>异或：^<br />
异或的两个值，相同为假，不同为真</p></li>

<li><p>附加：根据异或的特性，两个值异或出来的结果，再与其中一个值异或，得到的是另外一个值，可以将两个函数的值对调，例子：</p>

<p>18:10[root@centos7 /data]# x=10;y=8;x=$[x^y];let y=x^y;x=$((x^y));echo $x $y
8 10
18:31[root@centos7 /data]# x=10;y=8;temp=$x;x=$y;y=$temp;echo $x $y
8 10</p></li>
</ul>

<h2 id="条件测试">条件测试</h2>

<ul>
<li>判断某需求是否满足，需要由测试机制来实现，专用的测试表达式需要由测试命令辅助完成测试过程</li>

<li><p>评估布尔声明，以便用在条件性执行中<br />
若真，则返回0<br />
若假，则返回1</p></li>

<li><p>测试命令：</p></li>
</ul>

<p>test EXPRESSION ： test $name1 = $name2<br />
[ EXPRESSION ] ：和上面相同， <strong>精确匹配</strong> ，不支持正则表达式和通配符<br />
[[ EXPRESSION ]] ：支持扩展正则表达式和通配符， <strong>可以模糊匹配</strong></p>

<ul>
<li>注意：EXPRESSION前后必须有空白字符（不带空格变成了变量赋值），还要注意它与前面的数值运算的区别：数字运算的中括号前面有$,括号里面的表达式不需要与边上有空格。</li>
<li>双中括号正则表达式不能加双引号，否则会变成字符匹配，但是前面的变量引用要加上双引号，为了避免空字符错误</li>
<li>双中括号还可以用 （EXPRESSION） ； !EXPRESSION ; $$ ;|| 的用法，但是不支持后面的单中括号的-a -o这种用法来代表$$ ||.</li>
<li>更多区别可查看他人总结的各种括号的区别以及内部帮助</li>
</ul>

<h3 id="数值">数值</h3>

<p>-v VAR<br />
变量VAR是否设置 ：这个就是用来判断变量是否存在，比如var=&ldquo;&rdquo;, 虽然它是空值，但是它仍然赋值设置过已经存在了，[ -v var ] ,echo $?
=0 结果为真</p>

<ul>
<li>注意这个里面判断的时候直接跟变量名，不需要加$符号</li>
<li>注意它和-n的区别，-n如果变量不存在或者变量为空都返回1false,而-v只关心变量存不存在，不管里面的值是什么，变量只要存在就为0true</li>
</ul>

<p>数值测试：<br />
-gt 是否大于<br />
-ge 是否大于等于<br />
-eq 是否等于<br />
-ne 是否不等于<br />
-lt 是否小于<br />
-le 是否小于等于</p>

<ul>
<li>注意：当用数值比较的时候，前面的变量最好要提前先做一次判断，判断它是否非空且为一个数值，然后再进行比较判断。这样可以避免报错以及数值变量两边不需要加双引号。</li>
</ul>

<h3 id="字符串测试">字符串测试：</h3>

<p>= 是否等于<br />
&gt; ascii码是否大于ascii码，字符串从左往右一个一个比较<br />
&lt; 是否小于</p>

<ul>
<li><p>注意：上面两个比较在单中括号[]里面都需要转义，不然看做重定向，但是在[[]]里面不需要转义可以直接用，但也因此导致了 <strong>词首词尾锚定不能用</strong> 了，往下看有例子会解释。</p>

<p>13:58[root@centos7 /data]# AAA=&ldquo;abc$&rdquo;
13:58[root@centos7 /data]# BBB=&ldquo;abc#&rdquo;
13:58[root@centos7 /data]# [ $AAA &gt; $BBB ]
13:58[root@centos7 /data]# echo $?
0
13:58[root@centos7 /data]# BBB=&ldquo;abc%&rdquo;
13:58[root@centos7 /data]# [ $AAA &lt; $BBB ]
13:58[root@centos7 /data]# echo $?
0</p></li>
</ul>

<p>!= 是否不等于<br />
== 或者!= ，后面匹配的是partern通配符，而不是正则表达式<br />
=~ 左侧字符串是否能够被右侧的正则表达式ReExPression所匹配</p>

<ul>
<li>注意它的匹配只要能匹配到即可，包含什么东西，带什么东西都行，并非要完全匹配，比如匹配以 .sh结尾的 [[ &ldquo;$var&rdquo; =~ \.sh$ ]]</li>
<li>注意: 此表达式一般用于[[]]中；扩展的正则表达式<br />
例如：str=abc ; [[ $str =~ ^a ].</li>
</ul>

<p>-z &ldquo;STRING“ 字符串是否为空，空为真，不空为假 ：<a href="[-z $str]也可使用，但最好不要这样写">-z &ldquo;$str&rdquo;</a><br />
-n &ldquo;STRING“ 字符串是否不空，不空为真，空为假 : [ $awdfc ] ,echo $?=1 （awdfc没赋值和定义）</p>

<ul>
<li>注意：[] 中间省略了-n,只要里面有内容，字符串或者数字等等不为空，他的结果就为真，$?就为0，反之随便跟一个没定义赋值的变量，因为里面是空的，所以它的结果就为假，$?为1.</li>
<li>例如： [ -n &ldquo;&rdquo; ] ,echo $?=1</li>
</ul>

<ol>
<li>但是注意，如果 [ -n $var ],如果var没有定义，它也显示为真的，因为var两边没有加上“$var&rdquo;, 必须加上双引号并且var没有定义或者为空，结果才为假的.</li>
<li>同时注意这里面不写-n的时候双引号加上不加上都可以没有影响,除非是判断空格，得把空格级两边加上双引号

<ul>
<li>还有个技巧 [ &ldquo;x$var&rdquo; = &ldquo;x&rdquo;] 也可以判断var里面是否为空 ，为空结果为真。</li>
<li>注意空格也算是字符，只有任何字符没有才是空</li>
</ul></li>
</ol>

<ul>
<li><p>注意：用于字符串比较时的用到的操作和变量都应该使用 <strong>双引号</strong> 括起来，（单引号会强引用，注意场合使用它），这样是为了避免 <strong>空变量或者空字符</strong> 在判断中因其错误，比如下面例子：</p>

<p>如果两个变量都是空的
[ $wadc = $wvaf ] ；echo &amp;?=0
[ &ldquo;$wadc&rdquo; = &ldquo;$wvaf&rdquo; ] ；echo &amp;?=0
但是如果一个变量是空的，一个变量是非空的则会报错
[ &ldquo;$wadc&rdquo; = &ldquo;$wvaf&rdquo; ] ；
-bash: [: wad: unary operator expected
echo &amp;?=2
因此字符串比较都要加上引号</p></li>

<li><p>注意：如果把数字看做字符串来进行比较，也可以用 [ &ldquo;##&rdquo; = &ldquo;##&rdquo; ], 但此时需要注意两边都要加上引号变为字符串, 但加上引号之后就不能再用 -eq等命令了。</p></li>

<li><p>判断一个变量是否为数字：<br />
[[ &ldquo;$n&rdquo; =~ <sup class="footnote-ref" id="fnref:0-9"><a href="#fn:0-9">1</a></sup>+$ ]]<br />
注意用词首词尾不能判断,原因是它把</p>

<p>12:44[root@centos7 /data]# num=&rdquo;<123>&ldquo;
12:44[root@centos7 /data]# [[ &ldquo;$num&rdquo; =~ \ ]]
12:44[root@centos7 /data]# echo $?
0
12:46[root@centos7 /data]# num=/123/
12:46[root@centos7 /data]# [[ &ldquo;$num&rdquo; =~ \ ]]
12:46[root@centos7 /data]# echo $?
1
12:48[root@centos7 /data]# num=&ldquo;123&gt;&rdquo;
12:48[root@centos7 /data]# [[ &ldquo;$num&rdquo; =~ \ ]]
12:48[root@centos7 /data]# echo $?
1
12:52[root@centos7 /data]# num=&rdquo;&lt;123&gt;&ldquo;
12:52[root@centos7 /data]# [[ &ldquo;$num&rdquo; =~ \\ ]]
12:52[root@centos7 /data]# echo $?
0
反斜杠\b也用不了：
13:01[root@centos7 /data]# [[ <code>echo 123</code> =~ \b[0-9]+\b  ]]
13:03[root@centos7 /data]# echo $?
1
13:03[root@centos7 /data]# [[ <code>echo b123</code> =~ \b[0-9]+\b  ]]
13:03[root@centos7 /data]# echo $?
1
13:03[root@centos7 /data]# [[ <code>echo b123b</code> =~ \b[0-9]+\b  ]]
13:03[root@centos7 /data]# echo $?
0
13:03[root@centos7 /data]# [[ <code>echo \b123\b</code> =~ \b[0-9]+\b  ]]
13:04[root@centos7 /data]# echo $?
0</p>

<p>13:16[root@centos7 /data]# [[ <code>echo b123rb</code> =~ \b[0-9]+\b  ]]
13:17[root@centos7 /data]# echo $?
1
13:17[root@centos7 /data]# [[ <code>echo b123\b</code> =~ \b[0-9]+\b  ]]
13:17[root@centos7 /data]# echo $?
0</p></li>
</ul>

<p>但是用grep命令可以，看下面的例子：</p>

<pre><code>11:58[root@centos7 /data/scriptest]# num=123; [[ $num =~ ^[0-9]+$ ]]
11:59[root@centos7 /data/scriptest]# echo $?
0
11:59[root@centos7 /data/scriptest]# num=123; [[ $num =~ \ ]]
11:59[root@centos7 /data/scriptest]# echo $?
1
但是用grep命令可以：
12:19[root@centos7 /data]# echo /123/ |egrep &quot;\&quot;
/123/
12:19[root@centos7 /data]# echo 123/ |egrep &quot;\&quot;
123/
12:19[root@centos7 /data]# echo a123b | egrep &quot;\&quot;
12:20[root@centos7 /data]# echo 123b | egrep &quot;\&quot;
12:20[root@centos7 /data]# num=123
12:20[root@centos7 /data]# [[ &quot;$num&quot; =~ &quot;\&quot; ]]
12:20[root@centos7 /data]# echo $?
1
12:21[root@centos7 /data]# echo $num
123
</code></pre>

<ul>
<li><p>判断一个变量内容是否是以sh后缀：<br />
[[ &ldquo;$variable&rdquo; =~ \.sh$ ]]</p></li>

<li><p>注意后面的正则表达式 <strong>不能再加双引号了</strong> ，不然会把双引号里面的看作是字符串，就不再是正则表达式了，当然单引号或者反向双引号了也不能加。<br />
例子：</p>

<p>12:56[root@centos7 /data]# [[ <code>echo &quot;123&quot;</code> =~ &ldquo;.<em>&rdquo; ]]
12:57[root@centos7 /data]# echo $?
1
12:57[root@centos7 /data]# [[ `echo &ldquo;.</em>&ldquo;<code>=~ &quot;.*&quot; ]]
12:59[root@centos7 /data]# echo $?
0
12:59[root@centos7 /data]# [[</code>echo &ldquo;&rdquo;.<em>&rdquo;&rdquo;<code>=~ &quot;.*&quot; ]]
12:59[root@centos7 /data]# echo $?
1
12:59[root@centos7 /data]# [[</code>echo &ldquo;&rdquo;.</em>&rdquo;&rdquo;` =~ &ldquo;&rdquo;.*&ldquo;&rdquo; ]]
13:00[root@centos7 /data]# echo $?
0</p></li>

<li><p>但是前面的最好用上双引号，虽然不用也不会报错，但结果可能会出问题。还有，这种匹配都是匹配了字符，因此前面即使是数字的变量也要加上双引号。</p>

<p>num=123
12:26[root@centos7 /data]# [[ &ldquo;$num&rdquo; =~ &ldquo;<sup class="footnote-ref" id="fnref:0-9"><a href="#fn:0-9">2</a></sup>+$&rdquo; ]]
12:26[root@centos7 /data]# echo $?
1
12:26[root@centos7 /data]# [[ &ldquo;$num&rdquo; =~ <sup class="footnote-ref" id="fnref:0-9"><a href="#fn:0-9">3</a></sup>+$ ]]
12:26[root@centos7 /data]# echo $?
0
同时还需要注意，不论怎样都无法用次首词尾来判断：
12:28[root@centos7 /data]# num=/123/
12:28[root@centos7 /data]# [[ &ldquo;$num&rdquo; =~ \ ]]
12:28[root@centos7 /data]# echo $?
1
但是grep中可以，但注意grep后面判断部分是最好加引号，否则无法将反斜杠\，以及&lt;&gt;重定向符号转义来来进行判断，因为会把它看作是新的一行来输入：
12:29[root@centos7 /data]# echo $num | egrep <br />
12:31[root@centos7 /data]# echo $num | egrep &ldquo;\&rdquo;
/123/
12:31[root@centos7 /data]# echo $num | egrep [0-9]+
/123/
但可以转义它，不过太过于复杂，所以还是加上引号比较好：
12:36[root@centos7 /data]# echo $num | egrep \<br />
/123/</p></li>

<li><p>短路或后面的语句如果是两条命令想要同时执行的，并且不开启子进程，必须得使用花括号括起来，并且它与每条命令之间要有空格分开，每条命令后面也要加上分号</p></li>
</ul>

<h3 id="bash的文件测试">Bash的文件测试</h3>

<h4 id="存在性测试">存在性测试</h4>

<p>-a FILE：同-e<br />
-e FILE: 文件存在性测试，存在为真，否则为假</p>

<h4 id="存在性及类别测试">存在性及类别测试</h4>

<p>-b FILE：是否存在且为块设备文件<br />
-c FILE：是否存在且为字符设备文件<br />
-d FILE：是否存在且为目录文件<br />
-f FILE：是否存在且为普通文件<br />
-h FILE 或 -L FILE：存在且为符号链接文件<br />
-p FILE：是否存在且为命名管道文件<br />
-S FILE：是否存在且为套接字文件</p>

<ul>
<li>注意：用-d判断是否是文件夹的时候，如果一个软链接指向一个文件夹，它也会把这个软连接当做一个文件夹返回正确的结果，因此，判断是否是文件夹之前，应先用-h或者-L判断是否是软链接</li>
<li>因此我们知道判断软连接的时候都是判断它指向的目标的文件的类型，应该需要提前判断是否为软链接再判断其它的。</li>
<li>或者两个条件同时判断:[ ! -h &ldquo;file&rdquo; ] &amp;&amp; [ -d &ldquo;file&rdquo;] 或者 [ ! -h &ldquo;file&rdquo; -a -d &ldquo;file&rdquo;]</li>
</ul>

<h4 id="文件权限测试">文件权限测试：</h4>

<p>-r FILE：是否存在且可读<br />
-w FILE: 是否存在且可写<br />
-x FILE: 是否存在且可执行</p>

<ul>
<li>注意：它是针对当前用户而言的真实权限，并不是完全按照ll列表中显示的来判断的。就比如root账号什么权限都有。</li>
</ul>

<h4 id="文件特殊权限测试">文件特殊权限测试：</h4>

<p>-u FILE：是否存在且拥有suid权限<br />
-g FILE：是否存在且拥有sgid权限<br />
-k FILE：是否存在且拥有sticky权限</p>

<h4 id="文件大小测试">文件大小测试：</h4>

<p>-s FILE: 是否存在且非空</p>

<h4 id="文件是否打开">文件是否打开：</h4>

<p>-t fd: fd 文件描述符是否在某终端已经打开<br />
-N FILE：文件自从上一次被读取之后是否被修改过<br />
-O FILE：当前有效用户是否为文件属主<br />
-G FILE：当前有效用户是否为文件属组</p>

<h4 id="双目测试">双目测试：</h4>

<p>FILE1 -ef FILE2: FILE1是否是FILE2的硬链接<br />
FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）<br />
FILE1 -ot FILE2: FILE1是否旧于FILE2</p>

<h3 id="bash的组合测试条件">Bash的组合测试条件</h3>

<h4 id="第一种方式">第一种方式：</h4>

<p>[ EXPRESSION1 -a EXPRESSION2 ] 并且<br />
[ EXPRESSION1 -o EXPRESSION2 ] 或者<br />
[ ! EXPRESSION ]</p>

<ul>
<li>注意：必须使用测试命令进行，[[ ]] 不支持 -a -o ，只支持符号的&amp;&amp; || !</li>
<li>但是 -a代表文件存在的表达式则在[[]]中可以使用</li>
</ul>

<h4 id="第二种方式">第二种方式：</h4>

<p>COMMAND1 &amp;&amp; COMMAND2 并且，短路与，代表条件性的AND THEN<br />
COMMAND1 || COMMAND2 或者，短路或，代表条件性的OR ELSE<br />
! COMMAND 非<br />
如：[ -f “$FILE” ] &amp;&amp; [[ “$FILE”=~ .*\.sh$ ]]</p>

<ul>
<li><p>注意：这种符号表示的可以在[[]]中使用。<br />
举例：</p>

<p>判断有没有用户：
grep -q no_such_user /etc/passwd || echo &lsquo;No such user
No such user
判断一个IP是否连通：
ping -c1 -W2 station1 &amp;&gt; /dev/null  &amp;&amp; echo &ldquo;station1 is up&rdquo;  || (echo &lsquo;station1 is unreachable&rsquo;; exit 1)
station1 is up</p></li>

<li><p>注意：这里小括号虽然开启了子进程，但是exit的输出值仍然会继承，就和之前echo $name (echo $name) 一样，只要变量并未再次进行赋值，便可继承。</p>

<p>13:31[root@centos7 /data/scriptest]# ( hostname ; exit 101 )
centos7.6test
15:09[root@centos7 /data/scriptest]# echo $?
101</p></li>

<li><p>可以用小括号临时创建不同文件权限的文件等操作</p>

<p>(umask 066 ;touch f1)</p></li>
</ul>

<h3 id="附加-禁止普通用户登录可以创建一个普通文件-etc-nologin即可-删除它便可以解除-对root登陆没有影响">附加：禁止普通用户登录可以创建一个普通文件/etc/nologin即可，删除它便可以解除。对root登陆没有影响。</h3>

<h2 id="read命令接收输入">read命令接收输入</h2>

<ul>
<li>使用read来把输入值分配给一个或多个shell变量<br />
-p 指定要显示的提示wall<br />
-s 静默输入，一般用于密码</li>
<li><strong>ctrl+s ,ctrl+q | stty -echo ,stty echo</strong></li>
</ul>

<p>-n N 指定输入的字符长度N:只要达到这个长度，命令就退出了<br />
-d ‘字符’ 输入结束符：只要输入这个字符，命令也就退出了<br />
-t N TIMEOUT为N秒</p>

<ul>
<li>read 从标准输入中读取值，给每个单词分配一个变量</li>
<li>所有剩余单词都被分配给最后一个变量</li>
</ul>

<p>例子：<br />
read -p “Enter a filename: “ FILE</p>

<h4 id="注意点-2">注意点：</h4>

<ol>
<li>如果不指定要接收的变量名，则默认赋值输入给 REPLY 这个变量。</li>
<li>read后面直接跟变量名，不需要加$</li>
<li>read命令赋值参数如果用管道传给它的话，并不是说不可以，只不过管道会开批一个子shell，会让赋的值无法在当前shell中使用，例子：</li>
<li>如果只有n个变量，但却输入了N个值（用空格隔开的），N&gt;n, 前n-1个变量正常赋值，第n个变量会把剩下的字符包括空格全部赋值进去。</li>

<li><p>同理如果有M个变量，但是输入了m个值（用空格隔开），M&gt;m,则前面的m个变量正常赋值，后面的变量为空。</p>

<p>15:09[root@centos7 /data/scriptest]# echo a b c | read x y z
15:29[root@centos7 /data/scriptest]# echo $x $y $z</p>

<p>15:34[root@centos7 /data/scriptest]# echo a b c | (read x y z;echo $x $y $z;)
a b c
15:30[root@centos7 /data/scriptest]# echo a b c | { read x y z;echo $x $y $z; }
a b c</p></li>
</ol>

<ul>
<li>注意例子中小括号中括号都可以，分别是小括号代表一个子进程中的命令， 以及中括号看作是管道自己开启的子进程中的整体命令，略有不同。需要注意中括号两边必须要有空格，小括号不需要。</li>
</ul>

<h2 id="条件选择语句if">条件选择语句if</h2>

<ul>
<li><p>选择执行：<br />
注意：if语句可嵌套</p></li>

<li><p>单分支<br />
if 判断条件;then<br />
条件为真的分支代码;<br />
fi</p></li>

<li><p>双分支<br />
if 判断条件; then<br />
条件为真的分支代码;<br />
else<br />
条件为假的分支代码;<br />
fi<br />
-多分支<br />
if 判断条件1; then<br />
条件1为真的分支代码;<br />
elif 判断条件2; then<br />
条件2为真的分支代码;<br />
elif 判断条件3; then<br />
条件3为真的分支代码;<br />
else<br />
以上条件都为假的分支代码;<br />
fi</p></li>

<li><p>注意：逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句</p></li>
</ul>

<h2 id="条件判断case">条件判断case</h2>

<p>case 变量引用(word) in<br />
PAT1)<br />
分支1<br />
;;<br />
PAT2)<br />
分支2<br />
;;<br />
&hellip;<br />
*)<br />
默认分支<br />
;;<br />
esac</p>

<h3 id="case支持glob风格的通配符">case支持glob风格的通配符：</h3>

<p>*: 任意长度任意字符<br />
?: 任意单个字符<br />
[]：指定范围内的任意单个字符<br />
a|b: a或b</p>

<p>转载于:<a href="https://blog.51cto.com/14228129/2366162">https://blog.51cto.com/14228129/2366162</a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:0-9">0-9 <a class="footnote-return" href="#fnref:0-9"><sup>[return]</sup></a></li>
<li id="fn:0-9">0-9 <a class="footnote-return" href="#fnref:0-9"><sup>[return]</sup></a></li>
<li id="fn:0-9">0-9 <a class="footnote-return" href="#fnref:0-9"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>