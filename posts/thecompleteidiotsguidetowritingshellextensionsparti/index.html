<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>TheCompleteIdiotsGuidetoWritingShellExtensionsPartI | 开发者问答集锦</title>
    <meta property="og:title" content="TheCompleteIdiotsGuidetoWritingShellExtensionsPartI - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="TheCompleteIdiotsGuidetoWritingShellExtensionsPartI">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/thecompleteidiotsguidetowritingshellextensionsparti/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">TheCompleteIdiotsGuidetoWritingShellExtensionsPartI</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><a href="http://www.codeproject.com/shell/shellextguide1.asp">http://www.codeproject.com/shell/shellextguide1.asp</a></p>

<h2 id="contents">Contents</h2>

<ul>
<li>README.TXT</li>
<li>Introduction to the Series</li>
<li>Introduction to Part I</li>
<li>Using AppWizard to Get Started</li>
<li>The Initialization Interface</li>
<li>The Interface for Interacting with the Context Menu

<ul>
<li>Modifying the context menu</li>
<li>Showing fly-by help in the status bar</li>
<li>Carrying out the user&rsquo;s selection</li>
<li>Other code details</li>
</ul></li>
<li>Registering the Shell Extension</li>
<li>Debugging the shell extension</li>
<li>What Does It All Look Like?</li>
<li>Copyright and license</li>
<li>Revision History</li>
</ul>

<h2 id="readme-txt">README.TXT</h2>

<p>This is the stuff I want you to read first, before proceeding on or posting
messages to this article&rsquo;s discussion board.</p>

<p>This series of articles was originally written for VC 6 users. Now that VC 8
is out, I felt it was about time to update the articles to cover VC 7.1. ;)
(Also, the automatic 6-to-7 conversion done by VC 7.1 doesn&rsquo;t always go
smoothly so VC 7.1 users could get stuck when trying to use the demo source
code.) So as I go through and update this series, the articles will be updated
to reflect new VC 7.1 features, and I&rsquo;ll have VC 7.1 projects in the source
downloads.</p>

<p><strong>Important note for VC 2005 users</strong> : The Express edition of VC 2005 does
<strong>not</strong> come with ATL or MFC. Since the articles in this series use ATL, and
some use MFC, you won&rsquo;t be able to use the Express editions with the articles&rsquo;
sample code.</p>

<p>If you are using VC 6, you should get an updated Platform SDK. You can use the
web install version, or download the CAB files or an ISO image and run the
setup locally. Be sure you use the utility to add the SDK include and lib
directories to the VC search path. You can find this in the <em>Visual Studio
Registration</em> folder in the Platform SDK program group. It&rsquo;s a good idea to
get the latest Platform SDK even if you&rsquo;re using VC 7 or 8 so you have the
latest headers and libs.</p>

<p><strong>Important note for VC 7 users</strong> : You <strong>must</strong> make a change to the default
include path if you haven&rsquo;t updated your Platform SDK. Make sure that
<code>$(VCInstallDir)PlatformSDK/include</code> is first in the list, above
<code>($VCInstallDir)include</code>, as shown here:</p>

<p>Since I haven&rsquo;t used VC 8 yet, I don&rsquo;t know if the sample code will compile on
8. Hopefully the 7-to-8 upgrade process will work better than the 6-to-7
process did. Please post on this article&rsquo;s forum if you have any trouble with
VC 8.</p>

<h2 id="introduction-to-the-series">Introduction to the Series</h2>

<p>A shell extension is a COM object that adds some kind of functionality to the
Windows shell (Explorer). There are all kinds of extensions out there, but
very little easy-to-follow documentation about what they are. (Although I bet
the situation has improved during the six years since I originally wrote
that!) I highly recommend Dino Esposito&rsquo;s great book Visual C++ Windows Shell
Programming (ISBN 1861001843) if you want an in-depth look into lots of
aspects of the shell, but for folks who don&rsquo;t have the book, or only care
about shell extensions, I&rsquo;ve written up this tutorial that will astound and
amaze you, or failing that, get you well on your way to understanding how to
write your own extensions. This guide assumes you are familiar with the basics
of COM and ATL. If you need a refresher on COM basics, check out my Intro to
COM article.</p>

<p>Part I contains a general introduction to shell extensions, and a simple
context menu extension to whet your appetite for the following parts.</p>

<p>There are two parts in the term &ldquo;shell extension.&rdquo; <em>Shell</em> refers to Explorer,
and <em>extension</em> refers to code you write that gets run by Explorer when a
predetermined event happens (e.g., a right-click on a .DOC file). So a shell
extension is <em>a COM object that adds features to Explorer</em>.</p>

<p>A shell extension is an in-process server that implements some interfaces that
handle the communication with Explorer. ATL is the easiest way to get an
extension up and running quickly, since without it you&rsquo;d be stuck writing
<code>QueryInterface()</code> and <code>AddRef()</code> code over and over. It is also <em>much</em> easier
to debug extensions on Windows NT-based OSes, as I will explain later.</p>

<p>There are many types of shell extensions, each type being invoked when
different events happen. Here are a few of the more common types, and the
situations in which they are invoked:</p>

<p>Type</p>

<p>|</p>

<p>When it&rsquo;s invoked</p>

<p>|</p>

<p>What it does</p>

<p>&mdash;|&mdash;|&mdash;</p>

<p>Context menu handler</p>

<p>|</p>

<p>User right-clicks on a file or folder. In shell versions 4.71+, also invoked
on a right-click in the background of a directory window.</p>

<p>|</p>

<p>Adds items to the context menu.</p>

<p>Property sheet handler</p>

<p>|</p>

<p>Properties dialog displayed for a file.</p>

<p>|</p>

<p>Adds pages to the property sheet.</p>

<p>Drag and drop handler</p>

<p>|</p>

<p>User right-drags items and drops them on a directory window or the desktop.</p>

<p>|</p>

<p>Adds items to the context menu.</p>

<p>Drop handler</p>

<p>|</p>

<p>User drags items and drops them on a file.</p>

<p>|</p>

<p>Any desired action.</p>

<p>QueryInfo handler (shell version 4.71+)</p>

<p>|</p>

<p>User hovers the mouse over a file or other shell object like My Computer.</p>

<p>|</p>

<p>Returns a string that Explorer displays in a tooltip.</p>

<h2 id="introduction-to-part-i">Introduction to Part I</h2>

<p>By now you many be wondering what an extension looks like in Explorer. One
example is WinZip - it contains many types of extensions, one of them being a
context menu handler. Here some commands that WinZip adds to the context menu
for compressed files:</p>

<p>WinZip contains the code that adds the menu items, provides fly-by help (text
that appears in Explorer&rsquo;s status bar), and carries out the appropriate
actions when the user chooses one of the WinZip commands.</p>

<p>WinZip also contains a drag and drop handler. This type is very similar to a
context menu extension, but it is invoked when the user drags a file using the
right mouse button. Here is what WinZip&rsquo;s drag and drop handler adds to the
context menu:</p>

<p>There are many other types (and Microsoft keeps adding more in each version of
Windows!). For now, we&rsquo;ll just look at context menu extensions, since they are
pretty simple to write and the results are easy to see (instant
gratification!).</p>

<p>Before we begin coding, there are some tips that will make the job easier.
When you cause a shell extension to be loaded by Explorer, it will stay in
memory for a while, making it impossible to rebuild the DLL. To have Explorer
unload extensions more often, create this registry key:</p>

<p><code>HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Explorer/AlwaysUnloadDLL</code></p>

<p>and set the default value to &ldquo;1&rdquo;. On 9x, that&rsquo;s the best you can do. On NT, go
to this key:</p>

<p><code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Explorer</code></p>

<p>and create a <code>DWORD</code> called <em>DesktopProcess</em> with a value of 1. This makes the
desktop and Taskbar run in one process, and subsequent Explorer windows each
run in its own process. This means that you can do your debugging with a
single Explorer window, and when you close it, your DLL is automatically
unloaded, avoiding any problems with the file being in use. You will need to
log off and back on for these changes to take effect.</p>

<p>I will explain how to debug on 9x a little later.</p>

<h2 id="using-appwizard-to-get-started">Using AppWizard to Get Started</h2>

<p>Let&rsquo;s start simple, and make an extension that just pops up a message box to
show that it&rsquo;s working. We&rsquo;ll hook the extension up to .TXT files, so our
extension will be called when the user right-clicks a text file.</p>

<p>OK, it&rsquo;s time to get started! What&rsquo;s that? I haven&rsquo;t told you how to use the
mysterious shell extension interfaces yet? Don&rsquo;t worry, I&rsquo;ll be explaining as
I go along. I find that it&rsquo;s easier to follow along with examples if the
concepts are explained, and followed immediately by sample code. I could
explain everything first, then get to the code, but I find that harder to
absorb. Anyway, fire up VC and we&rsquo;ll get started.</p>

<p>Run the AppWizard and make a new ATL COM program. We&rsquo;ll call it &ldquo;SimpleExt&rdquo;.
Keep all the default settings in the AppWizard, and click <em>Finish</em>. We now
have an empty ATL project that will build a DLL, but we need to add our shell
extension&rsquo;s COM object. In the ClassView tree, right-click the <em>SimpleExt
classes</em> item, and pick <em>New ATL Object</em>. (In VC 7, right-click the item and
pick <em>Add|Add Class</em>.)</p>

<p>In the ATL Object Wizard, the first panel already has <em>Simple Object</em>
selected, so just click <em>Next</em>. On the second panel, enter &ldquo;SimpleShlExt&rdquo; in
the <em>Short Name</em> edit box (the other edit boxes on the panel will be filled in
automatically):</p>

<p>By default, the wizard creates a COM object that can be used from C and
script-based clients through OLE Automation. Our extension will only be used
by Explorer, so we can change some settings to remove the Automation features.
Go to the <em>Attributes</em> page, and change the <em>Interface</em> type to <em>Custom</em> , and
change the <em>Aggregation</em> setting to <em>No</em> :</p>

<p>When you click OK, the wizard creates a class called <code>CSimpleShlExt</code> that
contains the basic code for implementing a COM object, and adds this class to
the project. We will add our code to this class.</p>

<h2 id="the-initialization-interface">The Initialization Interface</h2>

<p>When our shell extension is loaded, Explorer calls our <code>QueryInterface()</code>
function to get a pointer to an <code>IShellExtInit</code> interface. This interface has
only one method, <code>Initialize()</code>, whose prototype is:</p>

<pre><code>HRESULT IShellExtInit::Initialize (
  LPCITEMIDLIST pidlFolder,
  LPDATAOBJECT pDataObj,
  HKEY hProgID )
</code></pre>

<p>Explorer uses this method to give us various information. <code>pidlFolder</code> is the
PIDL of the folder containing the files being acted upon. (A PIDL [ <strong>p</strong>
ointer to an <strong>ID</strong> <strong>l</strong> ist] is a data structure that uniquely identifies
any object in the shell, whether it&rsquo;s a file system object or not.) <code>pDataObj</code>
is an <code>IDataObject</code> interface pointer through which we retrieve the names of
the files being acted upon. <code>hProgID</code> is an open <code>HKEY</code> which we can use to
access the registry key containing our DLL&rsquo;s registration data. For this
simple extension, we&rsquo;ll only need to use the <code>pDataObj</code> parameter.</p>

<p>To add this to our COM object, open the <em>SimpleShlExt.h</em> file, and add the
lines listed below in bold. Some of the COM-related code generated by the
wizard isn&rsquo;t needed, since we&rsquo;re not implementing our own interface, so I&rsquo;ve
indicated the code that can be removed with strikeout type:</p>

<pre><code>**#include
#include 

class ATL_NO_VTABLE CSimpleShlExt :
  public CComObjectRootEx,
  public CComCoClass,




    ~~ public ISimpleShlExt,



    ~~
  **public IShellExtInit**
{
  BEGIN_COM_MAP(CSimpleShlExt)




    ~~COM_INTERFACE_ENTRY(ISimpleShlExt)~~
    **COM_INTERFACE_ENTRY(IShellExtInit)**
  END_COM_MAP()**
</code></pre>

<p>The <code>COM_MAP</code> is how ATL implements <code>QueryInterface()</code>. It tells ATL what
interfaces other programs can retrieve from our COM objects.</p>

<p>Inside the class declaration, add the prototype for <code>Initialize()</code>. We&rsquo;ll also
need a buffer to hold a filename:</p>

<pre><code>protected:
  TCHAR m_szFile[MAX_PATH];

public:
  // IShellExtInit
  STDMETHODIMP Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY);
</code></pre>

<p>Then, in the <em>SimpleShlExt.cpp</em> file, add the definition of the function:</p>

<pre><code>STDMETHODIMP CSimpleShlExt::Initialize ( 
  LPCITEMIDLIST pidlFolder,
  LPDATAOBJECT pDataObj,
  HKEY hProgID )
</code></pre>

<p>What we&rsquo;ll do is get the name of the file that was right-clicked, and show
that name in a message box. If there is more than one selected file, you could
access them all through the <code>pDataObj</code> interface pointer, but since we&rsquo;re
keeping this simple, we&rsquo;ll only look at the first filename.</p>

<p>The filename is stored in the same format as the one used when you drag and
drop files on a window with the <code>WS_EX_ACCEPTFILES</code> style. That means we get
the filenames using the same API: <code>DragQueryFile()</code>. We&rsquo;ll begin the function
by getting a handle to the data contained in the <code>IDataObject</code>:</p>

<pre><code>HRESULT CSimpleShlExt::Initialize(...)
{
FORMATETC fmt = { CF_HDROP, NULL, DVASPECT_CONTENT,
                  -1, TYMED_HGLOBAL };
STGMEDIUM stg = { TYMED_HGLOBAL };
HDROP     hDrop;

  // Look for CF_HDROP data in the data object. If there
  // is no such data, return an error back to Explorer.
  if ( FAILED( pDataObj-&gt;GetData ( &amp;fmt, &amp;stg ) ))
    return E_INVALIDARG;

  // Get a pointer to the actual data.
  hDrop = (HDROP) GlobalLock ( stg.hGlobal );

  // Make sure it worked.
  if ( NULL == hDrop )
    return E_INVALIDARG;
</code></pre>

<p>Note that it&rsquo;s vitally important to error-check everything, especially
pointers. Since our extension runs in Explorer&rsquo;s process space, if our code
crashes, we take down Explorer too. On 9x, such a crash might necessitate
rebooting the computer.</p>

<p>Now that we have an <code>HDROP</code> handle, we can get the filename we need.</p>

<pre><code>  // Sanity check – make sure there is at least one filename.
UINT uNumFiles = DragQueryFile ( hDrop, 0xFFFFFFFF, NULL, 0 );
HRESULT hr = S_OK;

  if ( 0 == uNumFiles )
    {
    GlobalUnlock ( stg.hGlobal );
    ReleaseStgMedium ( &amp;stg );
    return E_INVALIDARG;
    }

  // Get the name of the first file and store it in our
  // member variable m_szFile.
  if ( 0 == DragQueryFile ( hDrop, 0, m_szFile, MAX_PATH ) )
    hr = E_INVALIDARG;

  GlobalUnlock ( stg.hGlobal );
  ReleaseStgMedium ( &amp;stg );

  return hr;
}
</code></pre>

<p>If we return <code>E_INVALIDARG</code>, Explorer will not call our extension for this
right-click event again. If we return <code>S_OK</code>, then Explorer will call
<code>QueryInterface()</code> again and get a pointer to another interface:
<code>IContextMenu</code>.</p>

<h2 id="the-interface-for-interacting-with-the-context-menu">The Interface for Interacting with the Context Menu</h2>

<p>Once Explorer has initialized our extension, it will call the <code>IContextMenu</code>
methods to let us add menu items, provide fly-by help, and carry out the
user&rsquo;s selection.</p>

<p>Adding <code>IContextMenu</code> to our shell extension is similar to adding
<code>IShellExtInit</code>. Open up <em>SimpleShlExt.h</em> and add the lines listed here in
bold:</p>

<pre><code>class ATL_NO_VTABLE CSimpleShlExt : 
    public CComObjectRootEx,
    public CComCoClass,
    public IShellExtInit,
    **public IContextMenu**
{
  BEGIN_COM_MAP(CSimpleShlExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
    **COM_INTERFACE_ENTRY(IContextMenu)**
  END_COM_MAP()
</code></pre>

<p>And then add the prototypes for the <code>IContextMenu</code> methods:</p>

<pre><code>public:
  // IContextMenu
  STDMETHODIMP GetCommandString(UINT, UINT, UINT*, LPSTR, UINT);
  STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO);
  STDMETHODIMP QueryContextMenu(HMENU, UINT, UINT, UINT, UINT);
</code></pre>

<h3 id="modifying-the-context-menu">Modifying the context menu</h3>

<p><code>IContextMenu</code> has three methods. The first one, <code>QueryContextMenu()</code>, lets us
modify the menu. The prototype of <code>QueryContextMenu()</code> is:</p>

<pre><code>HRESULT IContextMenu::QueryContextMenu (
  HMENU hmenu, UINT uMenuIndex, UINT uidFirstCmd,
  UINT uidLastCmd, UINT uFlags );
</code></pre>

<p><code>hmenu</code> is a handle to the context menu. <code>uMenuIndex</code> is the position in which
we should start adding our items. <code>uidFirstCmd</code> and <code>uidLastCmd</code> are the range
of command ID values we can use for our menu items. <code>uFlags</code> indicates why
Explorer is calling <code>QueryContextMenu()</code>, and I&rsquo;ll get to this later.</p>

<p>The return value is documented differently depending on who you ask. Dino
Esposito&rsquo;s book says it&rsquo;s the number of menu items added by
<code>QueryContextMenu()</code>. The MSDN docs from VC 6 says it&rsquo;s the command ID of the
last menu item we add, plus 1. The online MSDN says this:</p>

<blockquote>
<p>If successful, returns an HRESULT value that has its severity value set to
SEVERITY_SUCCESS and its code value set to the offset of the largest command
identifier that was assigned, plus one. For example, assume that idCmdFirst
is set to 5 and you add three items to the menu with command identifiers of
5, 7, and 8. The return value should be MAKE_HRESULT(SEVERITY_SUCCESS, 0, 8
- 5 + 1). Otherwise, it returns an OLE error value.</p>
</blockquote>

<p>I&rsquo;ve been following Dino&rsquo;s explanation so far in the code I&rsquo;ve written, and
it&rsquo;s worked fine. Actually, his method of making the return value is
equivalent to the online MSDN method, as long as you start numbering your menu
items with <code>uidFirstCmd</code> and increment it by 1 for each item.</p>

<p>Our simple extension will have just one item, so the <code>QueryContextMenu()</code>
function is quite simple:</p>

<pre><code>HRESULT CSimpleShlExt::QueryContextMenu (
  HMENU hmenu, UINT uMenuIndex, UINT uidFirstCmd,
  UINT uidLastCmd, UINT uFlags )
{
  // If the flags include CMF_DEFAULTONLY then we shouldn't do anything.
  if ( uFlags &amp; CMF_DEFAULTONLY )
    return MAKE_HRESULT ( SEVERITY_SUCCESS, FACILITY_NULL, 0 );

  InsertMenu ( hmenu, uMenuIndex, MF_BYPOSITION,
               uidFirstCmd, _T(&quot;SimpleShlExt Test Item&quot;) );

  return MAKE_HRESULT ( SEVERITY_SUCCESS, FACILITY_NULL, 1 );
}
</code></pre>

<p>The first thing we do is check <code>uFlags</code>. You can look up the full list of
flags in MSDN, but for context menu extensions, only one value is important:
<code>CMF_DEFAULTONLY</code>. This flag tells namespace extensions to add only the
default menu item. Shell extensions should not add any items when this flag is
present. That&rsquo;s why we return 0 immediately if the <code>CMF_DEFAULTONLY</code> flag is
present. If that flag isn&rsquo;t present, we modify the menu (using the <code>hmenu</code>
handle), and return 1 to tell the shell that we added 1 menu item.</p>

<h3 id="showing-fly-by-help-in-the-status-bar">Showing fly-by help in the status bar</h3>

<p>The next <code>IContextMenu</code> that can be called is <code>GetCommandString()</code>. If the
user right-clicks a text file in an Explorer window, or selects a text file
and then clicks the <em>File</em> menu, the status bar will show fly-by help when our
menu item is highlighted. Our <code>GetCommandString()</code> function will return the
string that we want Explorer to show.</p>

<p>The prototype for <code>GetCommandString()</code> is:</p>

<pre><code>HRESULT IContextMenu::GetCommandString (
  UINT idCmd, UINT uFlags, UINT* pwReserved,
  LPSTR pszName, UINT cchMax );
</code></pre>

<p><code>idCmd</code> is a zero-based counter that indicates which menu item is selected.
Since we have just one menu item, <code>idCmd</code> will always be zero. But if we had
added, say, 3 menu items, <code>idCmd</code> could be 0, 1, or 2. <code>uFlags</code> is another
group of flags that I&rsquo;ll describe later. We can ignore <code>pwReserved</code>. <code>pszName</code>
is a pointer to a buffer owned by the shell where we will store the help
string to be displayed. <code>cchMax</code> is the size of the buffer. The return value
is one of the usual HRESULT constants, such as <code>S_OK</code> or <code>E_FAIL</code>.</p>

<p><code>GetCommandString()</code> can also be called to retrieve a &ldquo;verb&rdquo; for a menu item.
A verb is a language-independent string that identifies an action that can be
taken on a file. The docs for <code>ShellExecute()</code> have more to say, and the
subject of verbs is best suited for another article, but the short version is
that verbs can be either listed in the registry (such as &ldquo;open&rdquo; and &ldquo;print&rdquo;),
or created dynamically by context menu extensions. This lets an action
implemented in a shell extension be invoked by a call to <code>ShellExecute()</code>.</p>

<p>Anyway, the reason I mentioned all that is we have to determine why
<code>GetCommandString()</code> is being called. If Explorer wants a fly-by help string,
we provide it. If Explorer is asking for a verb, we&rsquo;ll just ignore the
request. This is where the <code>uFlags</code> parameter comes into play. If <code>uFlags</code> has
the <code>GCS_HELPTEXT</code> bit set, then Explorer is asking for fly-by help.
Additionally, if the <code>GCS_UNICODE</code> bit is set, we must return a Unicode
string.</p>

<p>The code for our <code>GetCommandString()</code> looks like this:</p>

<pre><code>#include   // for ATL string conversion macros

HRESULT CSimpleShlExt::GetCommandString (
  UINT idCmd, UINT uFlags, UINT* pwReserved,
  LPSTR pszName, UINT cchMax )
{
USES_CONVERSION;

  // Check idCmd, it must be 0 since we have only one menu item.
  if ( 0 != idCmd )
    return E_INVALIDARG;

  // If Explorer is asking for a help string, copy our string into the
  // supplied buffer.
  if ( uFlags &amp; GCS_HELPTEXT )
    {
    LPCTSTR szText = _T(&quot;This is the simple shell extension's help&quot;);

    if ( uFlags &amp; GCS_UNICODE )
      {
      // We need to cast pszName to a Unicode string, and then use the
      // Unicode string copy API.
      lstrcpynW ( (LPWSTR) pszName, T2CW(szText), cchMax );
      }
    else
      {
      // Use the ANSI string copy API to return the help string.
      lstrcpynA ( pszName, T2CA(szText), cchMax );
      }

    return S_OK;
    }

  return E_INVALIDARG;
}
</code></pre>

<p>Nothing fancy here; I just have the string hard-coded and convert it to the
appropriate character set. If you have never used the ATL conversion macros,
check out Nish and my article on string wrapper classes; they make life a lot
easier when having to pass Unicode strings to COM methods and OLE functions.</p>

<p>One important thing to note is that the <code>lstrcpyn()</code> API guarantees that the
destination string will be null-terminated. This is different from the CRT
function <code>strncpy()</code>, which does not add a terminating null if the source
string&rsquo;s length is greater than or equal to <code>cchMax</code>. I suggest always using
<code>lstrcpyn()</code>, so you don&rsquo;t have to insert checks after every <code>strncpy()</code> call
to make sure the strings end up null-terminated.</p>

<h3 id="carrying-out-the-user-s-selection">Carrying out the user&rsquo;s selection</h3>

<p>The last method in <code>IContextMenu</code> is <code>InvokeCommand()</code>. This method is called
if the user clicks on the menu item we added. The prototype for
<code>InvokeCommand()</code> is:</p>

<pre><code>HRESULT IContextMenu::InvokeCommand (
  LPCMINVOKECOMMANDINFO pCmdInfo );
</code></pre>

<p>The <code>CMINVOKECOMMANDINFO</code> struct has a ton of info in it, but for our
purposes, we only care about <code>lpVerb</code> and <code>hwnd</code>. <code>lpVerb</code> performs double
duty - it can be either the name of the verb that was invoked, or it can be an
index telling us which of our menu items was clicked on. <code>hwnd</code> is the handle
of the Explorer window where the user invoked our extension; we can use this
window as the parent window for any UI that we show.</p>

<p>Since we have just one menu item, we&rsquo;ll check <code>lpVerb</code>, and if it&rsquo;s zero, we
know our menu item was clicked. The simplest thing I could think to do is pop
up a message box, so that&rsquo;s just what this code does. The message box shows
the filename of the selected file, to prove that it&rsquo;s really working.</p>

<pre><code>HRESULT CSimpleShlExt::InvokeCommand (
  LPCMINVOKECOMMANDINFO pCmdInfo )
{
  // If lpVerb really points to a string, ignore this function call and bail out.
  if ( 0 != HIWORD( pCmdInfo-&gt;lpVerb ) )
    return E_INVALIDARG;

  // Get the command index - the only valid one is 0.
  switch ( LOWORD( pCmdInfo-&gt;lpVerb ) )
    {
    case 0:
      {
      TCHAR szMsg[MAX_PATH + 32];

      wsprintf ( szMsg, _T(&quot;The selected file was:/n/n%s&quot;), m_szFile );

      MessageBox ( pCmdInfo-&gt;hwnd, szMsg, _T(&quot;SimpleShlExt&quot;),
                   MB_ICONINFORMATION );

      return S_OK;
      }
    break;

    default:
      return E_INVALIDARG;
    break;
    }
}
</code></pre>

<h3 id="other-code-details">Other code details</h3>

<p>There are a couple more tweaks we can make to the wizard-generated code to
remove OLE Automation features that we don&rsquo;t need. First, we can remove some
registry entries from the <em>SimpleShlExt.rgs</em> file (the purpose of this file is
explained in the next section):</p>

<pre><code>HKCR
{




   ~~SimpleExt.SimpleShlExt. 1 = s 'SimpleShlExt Class'



   ~~




   ~~{~~




   ~~CLSID = s '{5E2121EE- 0300-11D4-8D3B-



    444553540000}'



   ~~




   ~~}~~




   ~~SimpleExt.SimpleShlExt = s 'SimpleShlExt Class'~~




   ~~{~~




   ~~CLSID = s '{5E2121EE- 0300-11D4-8D3B-



    444553540000}'



   ~~




   ~~CurVer = s 'SimpleExt.SimpleShlExt. 1'



   ~~




   ~~}~~
  NoRemove CLSID
  {
    ForceRemove {5E2121EE-0300-11D4-8D3B-444553540000} = s 'SimpleShlExt Class'
    {




   ~~ProgID = s 'SimpleExt.SimpleShlExt. 1'



   ~~




   ~~VersionIndependentProgID = s 'SimpleExt.SimpleShlExt'~~
      InprocServer32 = s '%MODULE%'
      {
        val ThreadingModel = s 'Apartment'
      }




   ~~'TypeLib' = s '{73738B1C-A43E-47F9-98F0-A07032F2C558}'~~
    }
  }
}
</code></pre>

<p>We can also remove the type library from the DLL&rsquo;s resources. Click
<em>View|Resource Includes</em>. In the <em>Compile-time directives</em> box, you&rsquo;ll see a
line that includes the type library:</p>

<p>Remove that line, then click OK when VC warns about modifying the includes.</p>

<p>In VC 7, the command is in a different location. On the <em>Resource View</em> tab,
right-click the <em>SimpleExt.rc</em> folder, and pick <em>Resource Includes</em> on the
menu.</p>

<p>Now that we&rsquo;ve removed the type library, we need to change two lines of code
and tell ATL that it shouldn&rsquo;t do anything with the type library. Open
<em>SimpleExt.cpp</em> , go to the <code>DllRegisterServer()</code> function, and change the
<code>RegisterServer()</code> parameter to <code>FALSE</code>:</p>

<pre><code>STDAPI DllRegisterServer()
{
//...
  return _Module.RegisterServer(



   ~~TRUE~~ FALSE);
}
</code></pre>

<p><code>DllUnregisterServer()</code> needs a similar change:</p>

<pre><code>STDAPI DllUnregisterServer()
{
//...
  return _Module.UnregisterServer(



   ~~TRUE~~ FALSE);
}
</code></pre>

<h2 id="registering-the-shell-extension">Registering the Shell Extension</h2>

<p>So now we have all of the COM interfaces implemented. But&hellip; how do we get
Explorer to use our extension? ATL automatically generates code that registers
our DLL as a COM server, but that just lets other apps use our DLL. In order
to tell Explorer our extension exists, we need to register it under the key
that holds info about text files:</p>

<p><code>HKEY_CLASSES_ROOT/txtfile</code></p>

<p>Under that key, a key called <code>ShellEx</code> holds a list of shell extensions that
will be invoked on text files. Under <code>ShellEx</code>, the <code>ContextMenuHandlers</code> key
holds a list of context menu extensions. Each extension creates a subkey under
<code>ContextMenuHandlers</code> and sets the default value of that key to its GUID. So,
for our simple extension, we&rsquo;ll create this key:</p>

<p><code>HKEY_CLASSES_ROOT/txtfile/ShellEx/ContextMenuHandlers/SimpleShlExt</code></p>

<p>and set the default value to our GUID:
&ldquo;{5E2121EE-0300-11D4-8D3B-444553540000}&rdquo;.</p>

<p>You don&rsquo;t have to write any code to do this, however. If you look at the list
of files on the FileView tab, you&rsquo;ll see <em>SimpleShlExt.rgs</em>. This is a text
file that is parsed by ATL, and tells ATL what registry entries to add when
the server is registered, and which ones to delete when the server is
unregistered. Here&rsquo;s how we specify the registry entries to add so Explorer
knows about our extension:</p>

<pre><code>HKCR
{
  NoRemove txtfile
  {
    NoRemove ShellEx
    {
      NoRemove ContextMenuHandlers
      {
        ForceRemove SimpleShlExt = s '{5E2121EE-0300-11D4-8D3B-444553540000}'
      }
    }
  }
}
</code></pre>

<p>Each line is a registry key name, with &ldquo;HKCR&rdquo; being an abbreviation for
<code>HKEY_CLASSES_ROOT</code>. The <code>NoRemove</code> keyword means that the key should not be
deleted when the server is unregistered. The last line has another keyword,
<code>ForceRemove</code>, which means that if the key exists, it will be deleted before
the new key is written. The rest of the line specifies a string (that&rsquo;s what
the &ldquo;s&rdquo; means) that will be stored in the default value of the <code>SimpleShlExt</code>
key.</p>

<p>I need to editorialize a bit here. The key we register our extension under is
<code>HKEY_CLASSES_ROOT/txtfile</code>. However, the name &ldquo;txtfile&rdquo; isn&rsquo;t a permanent or
pre-determined name. If you look in <code>HKEY_CLASSES_ROOT/.txt</code>, the default
value of <em>that</em> key is where the name is stored. This has a couple of side
effects:</p>

<ul>
<li>We can&rsquo;t reliably use an RGS script since &ldquo;txtfile&rdquo; may not be the correct key name.</li>
<li>Some other text editor may be installed that associates itself with .TXT files. If it changes the default value of the <code>HKEY_CLASSES_ROOT/.txt</code> key, all existing shell extensions will stop working.</li>
</ul>

<p>This sure seems like a design flaw to me. I think Microsoft thinks the same
way, since recently-created extensions, like the QueryInfo extension, are
registered under the key that&rsquo;s named after the file extension.</p>

<p>OK, end of editorial. There&rsquo;s one final registration detail. On NT, it&rsquo;s
advisable to put our extension in a list of &ldquo;approved&rdquo; extensions. There is a
system policy that can be set to prevent extensions from being loaded if they
are not on the approved list. The list is stored in:</p>

<p><code>HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Shell
Extensions/Approved</code></p>

<p>In this key, we create a string value whose name is our GUID. The contents of
the string can be anything. The code to do this goes in our
<code>DllRegisterServer()</code> and <code>DllUnregisterServer()</code> functions. I won&rsquo;t show the
code here, since it&rsquo;s just simple registry access, but you can find the code
in the article&rsquo;s sample project.</p>

<h2 id="debugging-the-shell-extension">Debugging the shell extension</h2>

<p>Eventually, you&rsquo;ll be writing an extension that isn&rsquo;t quite so simple, and
you&rsquo;ll have to debug it. Open up your project settings, and on the Debug tab,
enter the full path to Explorer in the &ldquo;Executable for debug session&rdquo; edit
box, for example &ldquo;C:/windows/explorer.exe&rdquo;. If you&rsquo;re using NT, and you&rsquo;ve set
the <code>DesktopProcess</code> registry entry described earlier, a new Explorer window
will open when you press F5 to start debugging. As long as you do all your
work in that window, you&rsquo;ll have no problem rebuilding the DLL later, since
when you close that window, your extension will be unloaded.</p>

<p>On Windows 9x, you will have to shut down the shell before running the
debugger. Click Start, and then Shut Down. Hold down Ctrl+Alt+Shift and click
Cancel. That will shut down Explorer, and you&rsquo;ll see the Taskbar disappear.
You can then go back to MSVC and press F5 to start debugging. To stop the
debugging session, press Shift+F5 to shut down Explorer. When you&rsquo;re done
debugging, you can run Explorer from a command prompt to restart the shell
normally.</p>

<h2 id="what-does-it-all-look-like">What Does It All Look Like?</h2>

<p>Here&rsquo;s what the context menu looks like after we add our item:</p>

<p>Our menu item is there!</p>

<p>Here&rsquo;s what Explorer&rsquo;s status bar looks like with our fly-by help displayed:</p>

<p>And here&rsquo;s what the message box looks like, showing the name of the file that
was selected:</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>