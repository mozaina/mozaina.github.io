<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux命令行与shell脚本编程大全第三版读书笔记 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux命令行与shell脚本编程大全第三版读书笔记 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux命令行与shell脚本编程大全第三版读书笔记">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E7%AC%AC%E4%B8%89%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux命令行与shell脚本编程大全第三版读书笔记</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="第一部分-linux命令行">第一部分 Linux命令行</h1>

<h2 id="第三章-基本的bash-shell命令">第三章、基本的bash shell命令</h2>

<h3 id="bash手册">bash手册</h3>

<h5 id="man-命令">man 命令</h5>

<p>例子：</p>

<pre><code>man cat
空格翻页、回车下一行、左右键看右侧（左侧）内容、q退出
</code></pre>

<h5 id="info">info</h5>

<pre><code>info info
展示info页面，没看出有什么特别的
</code></pre>

<h5 id="hostname">hostname</h5>

<p>设置hostname</p>

<pre><code>hostname mycomputer
</code></pre>

<h3 id="浏览文件系统">浏览文件系统</h3>

<h4 id="遍历目录">遍历目录</h4>

<h5 id="cd">cd</h5>

<p>切换目录</p>

<pre><code>cd /home/a  切换到/home/a目录，绝对路径
cd b    切换到当前目录下的b目录
cd .. 切换到上级目录
cd ../../ 切换到上级目录的上级目录
cd ~ 切换到用户家目录
cd 切换到用户家目录
cd - 切换到上次切换的目录
</code></pre>

<h5 id="pwd">pwd</h5>

<p>打印当前目录</p>

<h3 id="文件和目录列表">文件和目录列表</h3>

<h5 id="ls">ls</h5>

<p>列出当前目录下的文件和目录</p>

<pre><code>ls 输出当前目录下文件和目录
ls -F 同上，目录名后会有/方便区分
ls -a 同ls，同时展示隐藏文件
ls -R 递归显示子目录
ls -l 显示长列表，会有更多文件相关的信息
ls myscript 展示名字为myscript的文件或目录
ls myscri?t 过滤展示内容,问号代表一个任意字符
ls mysc* 过滤展示内容，星号代表多个任意字符
ls -l --time=atime 展示文件，时间列展示内容改为访问时间（默认是修改时间）
</code></pre>

<h3 id="处理文件">处理文件</h3>

<h4 id="创建文件">创建文件</h4>

<h5 id="touch">touch</h5>

<pre><code>touch a.log 创建a.log文件，如果该文件存在，更新该文件的修改时间
touch -a a.log 更新该文件的访问时间而非修改时间
</code></pre>

<h4 id="复制文件">复制文件</h4>

<h5 id="cp">cp</h5>

<pre><code>cp test_1 test_2 把当前目录下的test_1复制到test_2
cp -i test_1 test_2 复制时如果有文件已经存在，会询问是否覆盖
cp ../test_3 . 复制上级目录的test_3到当前目录
cp ../test_3/*.log . 把上级目录中的test_3目录下的所有以.log结尾的文件复制到当前目录
cp -R test_1 test_2 拷贝时递归拷贝子文件夹
</code></pre>

<h4 id="自动补全">自动补全</h4>

<p>在输入命令、目录名、文件名时制表符可以自动补全</p>

<h4 id="链接文件">链接文件</h4>

<h5 id="ln">ln</h5>

<p>创建链接</p>

<pre><code>ln -s test.log s1_test.log 创建test.log的软链接（符号链接）s1_test.log
ln test.log h1_test.log 创建test.log的硬链接h1_test.log
</code></pre>

<h5 id="readlink">readlink</h5>

<pre><code>readlink -f /usr/bin/python 如果/usr/bin/python是个链接文件，读取他的原始文件
</code></pre>

<h4 id="重命名文件">重命名文件</h4>

<h5 id="mv">mv</h5>

<p>移动文件或重命名文件</p>

<pre><code>mv a.log b.log 重命名a.log文件，改为b.log
mv ../a.log . 将上级目录中的a.log移动到当前目录
</code></pre>

<h4 id="删除文件">删除文件</h4>

<h5 id="rm">rm</h5>

<p>删除文件或目录</p>

<pre><code>rm a.log 删除a.log
rm -i a.log 删除a.log，删除前询问是否删除
rm -f a.log 强制删除a.log，不询问
rm -r somedir 递归删除somedir中的内容
</code></pre>

<h3 id="处理目录">处理目录</h3>

<h4 id="创建目录">创建目录</h4>

<h5 id="mkdir">mkdir</h5>

<p>创建目录</p>

<pre><code>mkdir adir 创建adir目录
mkdir -p adir/bdir/cdir 递归创建目录（不存在的父级目录会自动创建）
</code></pre>

<h4 id="删除目录">删除目录</h4>

<h5 id="rmdir">rmdir</h5>

<p>删除目录，只有目录为空时才会删除，所以要先删除目录中的内容再删除目录</p>

<pre><code>rmdir adir 删除adir目录
</code></pre>

<h4 id="查看目录树">查看目录树</h4>

<h5 id="tree">tree</h5>

<p>打印目录树，默认可能没有安装</p>

<pre><code>tree . 打印当前目录的树状结构
</code></pre>

<h3 id="查看文件内容">查看文件内容</h3>

<h4 id="查看文件类型">查看文件类型</h4>

<h5 id="file">file</h5>

<p>查看文件类型（文本、目录、链接、可执行文件等）</p>

<pre><code>file a.log 查看a.log的文件类型
</code></pre>

<h4 id="查看整个文件">查看整个文件</h4>

<h5 id="cat">cat</h5>

<p>查看整个文件</p>

<pre><code>cat a.log 查看a.log文件的内容
cat -n a.log 查看a.log文件内容，带行号
cat -b a.log 查看a.log文件内容，非空行带行号
cat -T a.log 查看a.log文件内容，不显示制表符（用^I代替）
</code></pre>

<h5 id="more">more</h5>

<p>逐页查看文件内容</p>

<pre><code>more a.log 逐页查看a.log的文件内容，翻页方法和man相同
</code></pre>

<h5 id="less">less</h5>

<p>逐页查看文件内容，可以倒退</p>

<pre><code>less a.log 逐页查看a.log的文件内容，翻页方法和more相同，但是在原有基础上增加了上下翻页的功能键（PgUp和PgDn）
</code></pre>

<h4 id="查看部分文件">查看部分文件</h4>

<h5 id="tail">tail</h5>

<p>查看文件末尾（默认10行）的内容</p>

<pre><code>tail a.log 查看a.log末尾的内容
tail -n 20 a.log 查看a.log末尾20行的内容
tail -f a.log 动态查看a.log末尾的内容（即如果其他程序写入了a.log，这里会实时显示出来）
</code></pre>

<h5 id="head">head</h5>

<p>查看文件开始（默认10行）的内容</p>

<pre><code>head a.log 查看a.log文件开头的内容
head -n 20 a.log 查看a.log文件开头20行的内容
</code></pre>

<h2 id="第四章-更多的bash-shell命令">第四章、更多的bash shell命令</h2>

<h3 id="监测程序">监测程序</h3>

<h4 id="探查进程">探查进程</h4>

<h5 id="ps">ps</h5>

<p>ps的基本输出显示了程序的进程id（PID）、运行在哪个终端（TTY）、以及进程已用的CPU时间</p>

<p>完成输出格式中，UID:启动进程的用户，PID：进程ID，PPID：父进程ID，C：进程生命周期中的CPU利用率，STIME:进程启动时的系统时间，TTY：进程启动时的终端设备，TIME:累积CPU时间，CMD:启动的程序名称</p>

<pre><code>ps 显示运行在当前控制台下的属于当前用户的进程
ps -e 显示所有进程
ps -f 显示完整格式的输出
Ps -l 显示长列表（不常用）
ps --forest 显示进程层级
ps -ef --forest 前几个的组合使用
</code></pre>

<h4 id="实时监测进程">实时监测进程</h4>

<h5 id="top">top</h5>

<p>实时监测进程，q退出，d修改轮询间隔，f选择显示哪些字段字段d，F选择按哪个字段排序</p>

<pre><code>top 实时监测进程
</code></pre>

<h4 id="结束进程">结束进程</h4>

<h5 id="linux信号">linux信号</h5>

<table>
<thead>
<tr>
<th>信号</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>HUP</td>
<td>挂起</td>
</tr>

<tr>
<td>2</td>
<td>INT</td>
<td>中断</td>
</tr>

<tr>
<td>3</td>
<td>QUIT</td>
<td>结束运行</td>
</tr>

<tr>
<td>9</td>
<td>KILL</td>
<td>无条件终止</td>
</tr>

<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误</td>
</tr>

<tr>
<td>15</td>
<td>TERM</td>
<td>尽可能终止</td>
</tr>

<tr>
<td>17</td>
<td>STOP</td>
<td>无条件停止运行，但不终止</td>
</tr>

<tr>
<td>18</td>
<td>TSTP</td>
<td>停止或暂停，但继续在后台运行</td>
</tr>

<tr>
<td>19</td>
<td>CONT</td>
<td>在STOP或TSTP之后恢复执行</td>
</tr>
</tbody>
</table>

<h5 id="kill">kill</h5>

<p>kill命令通过进程id给进程发信号。默认情况发送TERM信号</p>

<pre><code>kill 123 尽可能杀死pid是123的进程
kill -9 123 无条件杀死pid是123的进程
</code></pre>

<h5 id="killall">killall</h5>

<p>通过进程名而不是PID来结束进程，支持通配符</p>

<pre><code>killall http* 杀死所有以http开头的进程
</code></pre>

<h3 id="监测磁盘空间">监测磁盘空间</h3>

<h4 id="挂载存储媒体">挂载存储媒体</h4>

<h5 id="mount">mount</h5>

<p>给出两个简单例子</p>

<pre><code>mount 输出当前系统上挂载的设备列表，每行展示：媒体设备文件名、虚拟目录挂载点、文件系统类型、已挂载媒体的访问状态
mount -t vfat /dev/sdb1 /media/disk  将vfat格式的u盘/dev/sdb1挂载到/dev/sdb1目录
</code></pre>

<h5 id="umount">umount</h5>

<pre><code>umount [directory|device] 这个命令可以通过设备文件或挂载点来指定要卸载的设备
</code></pre>

<h4 id="使用df命令">使用df命令</h4>

<h5 id="df">df</h5>

<p>显示设备上还有多少磁盘空间</p>

<pre><code>df 显示每个有数据的已挂载文件系统使用情况
df -h 同上，但是按照用户易读的形式显示数值
</code></pre>

<h4 id="使用du命令">使用du命令</h4>

<h5 id="du">du</h5>

<p>du显示某个特定目录的磁盘使用情况</p>

<pre><code>du 当前目录下所有文件、目录、子目录的磁盘使用情况
</code></pre>

<h3 id="处理数据文件">处理数据文件</h3>

<h4 id="排序数据">排序数据</h4>

<h5 id="sort">sort</h5>

<pre><code>sort a.log 排序输出a.log内容，默认按照字典顺序
sort -n a.log 排序输出a.log的内容，将他们识别成数字排序
sort -M a.log 如果a.log以Jan等形式的三字符月份名开头，可以按照月份排序
sort -t ':' -k 3 -n /etc/passwd 排序/etc/passwd文件，按冒号分段，然后按第三段排序，并且将其作为数字进行排序
du -sh * | sort -nr 这里用了管道，查看当前目录下所有子文件、子文件夹的大小，然后当做数字倒排序（-r为倒排序）
</code></pre>

<h4 id="搜索数据">搜索数据</h4>

<h5 id="grep">grep</h5>

<p>查找文件内容</p>

<pre><code>grep [options] pattern [file] 查找某个文件中匹配pattern模式的字符的行
grep three a.log 查找a.log文件中包含three的行
grep -v three a.log 查找a.log文件中不包含three的行
grep -n three a.log 查找a.log文件中包含three的行，并添加行号
grep -c three a.log 统计a.log文件中包含three的有多少行
grep -e three -e two a.log 查找a.log中包含three或two的行，-e可以用来指定多个匹配模块
grep [tf] a.log 查找a.log中包含t或包含f的行
</code></pre>

<h5 id="egrep">egrep</h5>

<p>grep的衍生，支持POSIX扩展正则表达式</p>

<h5 id="fgrep">fgrep</h5>

<p>grep的衍生，支持将匹配模式指定为用换行符分割的一列固定长度的字符串</p>

<h4 id="压缩数据">压缩数据</h4>

<h5 id="gzip">gzip</h5>

<p>用来压缩文件</p>

<pre><code>gzip a.log 压缩a.log文件
gzip my* 压缩my开头的所有文件（不压缩目录）
</code></pre>

<h5 id="gzcat">gzcat</h5>

<p>用来查看压缩过的文本文件的内容</p>

<h5 id="gunzip">gunzip</h5>

<p>用来解压文件</p>

<h4 id="归档数据">归档数据</h4>

<h5 id="tar">tar</h5>

<pre><code>tar -cvf test.tar test/ test2/ 创建test.tar的归档文件，还有test和test2目录内容
tar -tf test.jar 列出test.jar的内容
tar -xvf test.jar 从test.tar中提取内容
</code></pre>

<h2 id="第五章-理解shell">第五章 理解shell</h2>

<h3 id="shell的父子关系">shell的父子关系</h3>

<pre><code>bash 从当前shell启动一个shell 
bash 从刚启动的shell再启动一个shell
ps --forest 展示进程树，可以看出父子关系
</code></pre>

<h4 id="进程列表">进程列表</h4>

<h5 id="echo-bash-subshell">echo $BASH_SUBSHELL</h5>

<pre><code>pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL 这是一个命令列表，最后一行显示0，表示没有生产子shell
(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL) 这是一个进程列表，最后一行显示1，表示生产了一个子shell
(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; (echo $BASH_SUBSHELL)) 这是一个进程列表，最后一行显示2，表示生产了两个子shell
</code></pre>

<h4 id="别出心裁的子shell用法">别出心裁的子shell用法</h4>

<h5 id="sleep">sleep</h5>

<pre><code>sleep 10 休息10秒
sleep 10 &amp; 在后台休息10秒，马上输入后台作业号和进程id
</code></pre>

<h5 id="jobs">jobs</h5>

<pre><code>jobs 显示当前运行在后台模式中的所有用户的进程
jobs -l 显示当前运行在后台模式中的所有用户的进程以及它们的pid
</code></pre>

<h5 id="coproc">coproc</h5>

<p>协成可以同时做两件事：在后台生产子shell，并在这个子shell中执行命令</p>

<pre><code>coproc sleep 10 在后台创建shell并执行休眠10秒
coproc My_Job { sleep 1000; } 在后台创建shell并执行休眠1000秒,为这个后台程序起名为My_Job，注意，格式要求严格，空格和分号需要严格按照格式
</code></pre>

<h3 id="理解shell的內建命令">理解shell的內建命令</h3>

<h4 id="外部命令">外部命令</h4>

<p>外部命令也被称为文件系统命令，是存在于bash shell之外的程序。执行他们时回创建出一个子进程，这种操作被称为衍生（forking）。</p>

<pre><code>ps -f 命令可以很清楚的看出，他创建了一个子进程，ps是一个外部命令
</code></pre>

<h5 id="which">which</h5>

<p>这个命令可以找出可执行命令的位置</p>

<pre><code>which ps 可以找出ps命令的位置（一般情况下是在/bin/ps）
</code></pre>

<h4 id="內建命令">內建命令</h4>

<p>內建命令和shell编译在一起，不需要子进程执行，效率更高。</p>

<h5 id="type">type</h5>

<p>內建命令，可以查看命令的类型</p>

<pre><code>type cd 显示可执行命令cd的类型（会显示类似于shell builtin，说明是內建命令）
type -a echo 显示可执行命令echo的类型，如果有多个，全部列出
</code></pre>

<h5 id="history">history</h5>

<p>內建命令，bash shell会记录用过的命令，可以唤回并重新使用</p>

<pre><code>history 显示最近用过的命令列表
!! 执行理事列表中最近的命令
history -a 强制将理事记录写入.bash_history文件，默认情况下退出时才会写入
!1082 执行命令历史记录编号为1082的命令
</code></pre>

<h5 id="alias">alias</h5>

<p>內建命令，可以为长远命令及其参数创建别名，减少输入量。别名仅在它所被定义的shell进程中才有效</p>

<pre><code>alias -p 查看当前可用别名
alias li='ls -li' 为ls -li 命令创建别名li,以后直接执行li即可
</code></pre>

<h2 id="第六章-使用linux环境变量">第六章 使用Linux环境变量</h2>

<h3 id="什么是环境变量">什么是环境变量</h3>

<h4 id="全局环境变量">全局环境变量</h4>

<p>全局环境变量会对shell会话和所有生成的子shell都是可见的。</p>

<h5 id="printenv-或-env">printenv 或 env</h5>

<pre><code>printenv 打印全局环境变量
env 打印全局环境变量
printenv HOME 打印名为HOME的全局变量
echo $HOME 打印名为HOME的全局变量
cd $HOME 进入HOME所指的目录
</code></pre>

<h4 id="局部环境变量">局部环境变量</h4>

<p>局部环境变量只能在定义他们的进程中可见。</p>

<h5 id="set">set</h5>

<pre><code>set 输出局部变量、全局变量及用户定义变量（比env、printenv更详细）
</code></pre>

<h3 id="设置用户定义变量">设置用户定义变量</h3>

<p>用户定义变量需要用小写，避免重新定义系统环境变量（系统环境变量都是大写）带来的灾难</p>

<pre><code>my_var=Hello 定义my_var变量的值Hello;注意不能有空格
my_var2='hello world' 定义my_var2变量的值为hello world;注意不能有空格，值中若有空格，用单引号括起来
</code></pre>

<h4 id="设置全局环境变量">设置全局环境变量</h4>

<p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。</p>

<h5 id="export">export</h5>

<p>使用export将用户已经定义好的局部环境变量导出到全局环境中。</p>

<pre><code>my_var=hello 创建局部环境变量my_var
export my_var 将my_var导出到全局环境中
</code></pre>

<h3 id="删除环境变量">删除环境变量</h3>

<h5 id="unset">unset</h5>

<pre><code>unset my_var 删除名为my_var的环境变量
</code></pre>

<h3 id="设置path环境变量">设置PATH环境变量</h3>

<pre><code>PATH=$PATH:/home/raul/Scripts 把PATH环境变量加上/home/raul/Scripts(PATH环境变量中用冒号分割)
PATH=$PATH:. 把PATH环境变量加上当前目录
</code></pre>

<h3 id="定位系统环境变量">定位系统环境变量</h3>

<h4 id="登录shell">登录shell</h4>

<pre><code>/etc/profile 系统默认的主启动文件，每个用户登录时都会执行这个启动文件
$HOME/.bash_profile 用户专属启动文件
$HOME/.bashrc 用户专属启动文件
$HOME/bash_login 用户专属启动文件
$HOME/.profile 用户专属启动文件
</code></pre>

<h4 id="交互式shell进程">交互式shell进程</h4>

<p>如果bash
shell不是登录系统时启动的（比如是在命令行提示符下敲bash时启动），那么启动的这个shell叫做交互式shell。它不会访问/etc/profile,只会检查$HOME/.bashrc文件</p>

<h4 id="非交互式shell">非交互式shell</h4>

<p>通过BASH_ENV环境变量来配置需要执行的启动文件</p>

<h4 id="环境变量持久化">环境变量持久化</h4>

<pre><code>全局性的环境变量可以在/etc/profile.d目录中创建一个以.sh结尾的文件，将全局环境变量设置放入其中
个人环境变量放到$HOME/.bashrc中
非交互式shell的设置文件配置到BASH_ENV环境中
</code></pre>

<h4 id="数组变量">数组变量</h4>

<p>环境变量可以作为数组使用</p>

<pre><code>mytest=(one two three four five) 把一个数组存入mytest环境变量中
echo $mytest 只会显示第一个值one
echo ${mytest[2]} 显示数组的第三个值
echo ${mytest[*]} 显示数组的所有值
mytest[2]=seven 修改数组第三个值，改为seven
unset mytest[2] 去掉数组第三个值（数组长度并未改变，该位置存放了‘空’）
unset mytest 删除整个数组
</code></pre>

<h2 id="第七章-理解linux的安全性">第七章、理解Linux的安全性</h2>

<h3 id="linux的安全性">Linux的安全性</h3>

<p>用户账户存在/etc/passwd文件,展示：用户登录名、用户密码、用户账户的UID、用户账户的组ID(GID)、用户账户的文本描述、用户HOME目录的位置、用户的默认shell</p>

<p>用户密码存在/etc/shadow文件，暂时：用户登录名、加密后的密码、自上次修改密码后过去的天数（自1970.1.1开始计算）、多少天后才能更改密码、多少天后必须更改密码、密码过期前提前多少天提醒用户更改密码、密码过期后多少天禁用用户账户、用户账户被禁用的日期（自1970.1.1到当天的天数）、预留字段给将来使用</p>

<h4 id="添加新用户">添加新用户</h4>

<h5 id="useradd">useradd</h5>

<pre><code>useradd -D 查看添加新用户的默认配置
useradd test 添加test用户
useradd -D -s /bin/tsch 修改添加新用户时shell的默认值为/bin/tsch
</code></pre>

<h4 id="删除用户">删除用户</h4>

<h5 id="userdel">userdel</h5>

<pre><code>userdel test 删除test用户
userdel -r test 删除test用户，并且删除他的home目录和邮件目录
</code></pre>

<h4 id="修改用户">修改用户</h4>

<h5 id="usermod">usermod</h5>

<p>修改用户账户的字段</p>

<pre><code>参数有
-l 修改用户账户的登录名
-L 锁定账户，使用户无法登录
-p 修改账户的密码
-U 解除锁定，使用户能够登录
</code></pre>

<h5 id="passwd">passwd</h5>

<pre><code>passwd 修改自己的密码
passwd test 修改test账户的密码
</code></pre>

<h5 id="chpasswd">chpasswd</h5>

<pre><code>chpasswd &lt; users.txt 用users.txt中的内容来修改密码，该文件中的内容应该是userid:passwd的键值对
</code></pre>

<h5 id="chsh">chsh</h5>

<pre><code>chsh -s /bin/csh test 修改test用户的默认shell为/bin/csh
</code></pre>

<h5 id="chfn">chfn</h5>

<p>修改用户在/etc/passwd文件中的备注字段中的存储信息</p>

<pre><code>chfn test 修改test的备注信息，会提示输入
</code></pre>

<h5 id="finger">finger</h5>

<pre><code>finger test 查看test用户的信息
</code></pre>

<h5 id="chage">chage</h5>

<p>用来帮助管理用户账户的有效期</p>

<h3 id="使用linux组">使用Linux组</h3>

<p>组存在/etc/group文件下，分别展示：组名、组密码、GUID、属于该组的用户列表</p>

<h4 id="创建新租">创建新租</h4>

<h5 id="groupadd">groupadd</h5>

<pre><code>groupadd shared 创建名为shared的组
usermod -G shared test 将test用户添加到shared组中
</code></pre>

<h4 id="修改组">修改组</h4>

<h5 id="groupmod">groupmod</h5>

<pre><code>groupmod -n sharing shared 修改组shared的名字，改为sharing
</code></pre>

<h3 id="理解文件权限">理解文件权限</h3>

<h4 id="默认文件权限">默认文件权限</h4>

<h5 id="umask">umask</h5>

<p>默认权限由umask设置，比较复杂</p>

<pre><code>umask 展示创建文件时的默认权限
umask 026 设置创建文件时的默认权限为640（666-026），创建目录时的默认权限751(777-026)
</code></pre>

<h3 id="改变安全性设置">改变安全性设置</h3>

<h4 id="改变权限">改变权限</h4>

<h5 id="chmod">chmod</h5>

<p>两种方式，8进制权限码或符号模式</p>

<pre><code>chmod 760 newfile 设置newfile的权限为 -rwxrw----
chmod [ugoa...][+-=][rwxXstugo...]
其中第一组定义了权限作用的对象：u代表用户、g代表组、o代表其他、a代表上述所有
第二组定义了是想 在现有权限上增加权限（+），还是现有权限上移除权限（-），或是将权限设置成后面指定的值（=）
第三组代表作用到设置上的权限：
X：如果对象是目录或者它已有执行权限，赋予执行权限
s：运行时重新设置UID或GID
t：保留文件或目录
u：将权限设置为跟属主一样
g：将权限设置为跟属组一样
o：将权限设置为跟其他用户一样

chmod o+r newfile 给newfile的其他用户增加读权限
chmod u-x newfile 移除newfile的属主的执行权限
</code></pre>

<h4 id="改变所属关系">改变所属关系</h4>

<h5 id="chown">chown</h5>

<pre><code>chown raul newfile 改变newfile的属主为raul
chown raul.shared newfile 改变newfile的属主为raul，属组为shared
chown .rich newfile 改变newfile的属组为rich
chown raul. newfile 将newfile的属主和属组都改为raul
chown -R raul newdir 递归的将newdir下的所有文件和目录的属主都改为raul
</code></pre>

<h5 id="chgrp">chgrp</h5>

<pre><code>chgrp shared newfile 修改newfile的属组为chgrp
</code></pre>

<h3 id="共享文件">共享文件</h3>

<p>可以创建共享文件夹，如果有需要了解细节再仔细学习，下面给出方法</p>

<pre><code>mkdir testdir 创建共享目录
chgrp shared testdir    将属组改为需要共享文件的组shared
chmod g+s testdir 修改权限
umask 002 所有用户的umask都需要改成002
cd testdir  进入目录
touch testfile  创建文件，这个文件的属组会是shared
</code></pre>

<h2 id="第八章-管理文件系统">第八章、管理文件系统</h2>

<h3 id="操作文件系统">操作文件系统</h3>

<h4 id="创建分区">创建分区</h4>

<h5 id="fdisk">fdisk</h5>

<pre><code>fdisk /dev/sdb 给存储设备/dev/sdb分区
进入后，有如下有用的操作
p 显示这个存储设备的详细信息
n 创建新分区
w 保存更改
</code></pre>

<h4 id="创建文件系统">创建文件系统</h4>

<p>分区数据使用前，应先用某种文件系统对其进行格式化，每个文件系统相对应的格式化工具不同。</p>

<pre><code>mkefs   创建一个ext文件系统
mke2fs  创建一个ext2文件系统
mkfs.ext3   创建一个ext3文件系统
mkfs.ext4   创建一个ext4文件系统
mkreiserfs  创建一个ReiserFS文件系统
jfs_mkfs    创建一个JFS文件系统
mkfs.xfs    创建一个XFS文件系统
mkfs.zfs    创建一个ZFS文件系统
mkfs.btrfs  创建一个Btrfs文件系统
</code></pre>

<p>示例</p>

<pre><code>sudo mkfs.ext4 /dev/sdb1 在/dev/sdb1分区上创建一个ext4文件系统
</code></pre>

<p>格式化后，需要将这个文件系统挂载到虚拟目录中才能使用</p>

<pre><code>ls /mnt
sudo mkdir /mnt/my_partition
ls -al /mnt/my_partition/
ls -dF /mnt/my_partition
sudo mount -t ext4 /dev/sdb1 /mnt/my_partition
ls -al /mnt/my_partition
</code></pre>

<p>这种挂载方式是临时的，如果想linux启动时自动挂载，可以将其添加到/etc/fstab文件中</p>

<h4 id="文件系统的检查与修复">文件系统的检查与修复</h4>

<h5 id="fsck">fsck</h5>

<p>fsck可以检查和修复大部分类型的Linux文件系统（包含ext、ext2、ext3、ext4、ReiserFS、JFS、XFS）。需要先卸载目录再检查，检查完后再挂载。</p>

<pre><code>fsck options filesystem 对文件系统进行fsck命令
-a 如果检测遇到错误，自动修复
-A 检查/etc/fstab/文件中列出的所有文件系统
-C 如果支持进度条功能，显示进度条
-N 不进行检查，只显示哪些检查会执行
-r 出现错误时提示
-R 使用-A选项时跳过根文件系统
-s 检查多个文件系统时，依次进行检查
-t 指定要检查的文件系统类型
-T 启动时不显示头部信息
-V 在检查时产生详细输出
-y 检测到错误时自动修复文件系统
</code></pre>

<h3 id="逻辑卷管理">逻辑卷管理</h3>

<h4 id="使用linux-lvm">使用Linux LVM</h4>

<p>fsdisk中分区类型8e即表示这个粪污将会被用作Linux LVM系统的一部分，而不是一个直接的文件系统。</p>

<pre><code>fsdisk 命令，输入t，然后输入8e
</code></pre>

<p>下一步是用分区创建实际的物理卷</p>

<pre><code>sudo pvcreate /dev/sdb1 创建实际的物理卷
sudo pvdisplay /dev/sdb1 查看创建进度
sudo vgcreate Vol1 /dev/sdb1 创建卷组
sudo vgdisplay Vol1 查看刚创建的卷组的细节
sudo lvcreate -l 100%FREE -n lvtest Vol1 创建逻辑卷lvtest（参数细节查看lvcreate --help或man lvcreate）
sudo lvdisplay Vol1 查看刚创建的逻辑卷的详细情况
</code></pre>

<p>逻辑卷创建后，还需要创建文件系统，挂载到虚拟目录中</p>

<pre><code>sudo mkfs.ext4 /dev/Vol1/lvtest 为逻辑卷创建ext4文件系统
sudo mount /dev/Vol1/lvtest /mnt/my_partition 把逻辑卷挂载到/mnt/my_partition目录下
</code></pre>

<p>其他命令</p>

<pre><code>vgchange 激活和禁用卷组
vgremove 删除卷组
vgextend 将物理卷加到卷组中
vgreduce 从卷组中删除物理卷
lvextend 增加逻辑卷的大小
lvreduce 减小逻辑卷的大小
</code></pre>

<h2 id="第九章-安装软件程序">第九章、安装软件程序</h2>

<h3 id="基于debian的系统">基于Debian的系统</h3>

<h4 id="用aptitude管理软件包">用aptitude管理软件包</h4>

<p>aptitude工具本质上是apt工具和dpkg的前端，使用它有助于避免常见的软件安装问题，如软件依赖关系缺失、系统环境不稳定及其他一些不必要的麻烦。</p>

<h5 id="aptitude">aptitude</h5>

<pre><code>aptitude 进入aptitude的全屏模式
aptitude show mysql-client 显示mysql-client的详情（以及是否已经安装等信息）
</code></pre>

<h5 id="dpkg">dpkg</h5>

<pre><code>dpkg -L vim-common 列出vim-common软件包所安装的全部文件
dpkg --search /user/bin/xxd 查找某个特定文件属于哪个软件包
</code></pre>

<h4 id="用aptitude安装软件包">用aptitude安装软件包</h4>

<pre><code>aptitude search wine 查找所有名字中包含wine的软件包（如果行首显示i u则表示已经安装，显示p v说明这个包可用，但还没安装）
sudo aptitude install wine 安装名字包含wine的软件包
</code></pre>

<h4 id="用aptitude更新软件">用aptitude更新软件</h4>

<pre><code>sudo aptitude safe-upgrade 将所有已安装的包更新到软件仓库中的最新版本，会检查包之间的依赖关系，有利于系统稳定。
aptitude full-upgrade 同safe-upgrade，但不会检查包与包之间的依赖关系。
aptitude dist-upgrade 同safe-upgrade，但不会检查包与包之间的依赖关系。
</code></pre>

<h4 id="用aptitude卸载软件">用aptitude卸载软件</h4>

<pre><code>sudo aptitude remove wine 只删除软件包而不删除数据和配置文件
sudo aptitude purge wine 同时删除软件包以及相关的数据和配置文件
</code></pre>

<h4 id="aptitude仓库">aptitude仓库</h4>

<pre><code>/etc/apt/sources.list aptitude默认的软件仓库配置文件，如果需要自定义，修改这里（最好不要自定义，原始配置中的软件包版本不会互相冲突）
</code></pre>

<h3 id="基于red-hat的系统">基于Red Hat的系统</h3>

<h4 id="列出已安装包">列出已安装包</h4>

<h5 id="yum">yum</h5>

<pre><code>yum list installed 查看系统上已经安装的包
yum list xterm 查看xterm软件包的详细信息
yum list installed xterm 查看xterm软件包是否已经安装
yum provides /etc/yum.conf 查看/etc/yum.conf文件是属于哪个软件包
</code></pre>

<h4 id="用yum安装软件">用yum安装软件</h4>

<pre><code>yum install xterm 安装xterm软件包
yum localinstall package_name.rpm 手动安装下载好的package_name.rpm文件
</code></pre>

<h5 id="su">su</h5>

<pre><code>su hadoop 切换hadoop用户
su - hadoop 切换hadoop用户，并进入hadoop的家目录
su - 切换到root用户，并进入root的家目录
</code></pre>

<h4 id="用yum更新软件">用yum更新软件</h4>

<pre><code>yum list updates 列出所有已安装包的可用更新
yum update package_name 更新指定的软件包
yum update 更新所有可更新的包
</code></pre>

<h4 id="用yum卸载软件">用yum卸载软件</h4>

<pre><code>yum remove package_name 只删除软件包而保留配置文件和数据
yum erase package_name 同时删除软件包和相关的配置和数据
</code></pre>

<h4 id="处理损坏的包依赖关系">处理损坏的包依赖关系</h4>

<p>有时在安装多个软件包时，某个软件包的依赖关系可能会被另一个包的安装覆盖，这叫做损坏的包依赖关系。解决办法如下</p>

<p>首先尝试</p>

<pre><code>yum clean all
yum update
</code></pre>

<p>如果不行</p>

<pre><code>yum deplist package_name 可以查看这个软件包所需要的库由那些软件提供，然后可以安装他们。
</code></pre>

<p>如果还是不行</p>

<pre><code>yum update --skip-broken 更新所有软件包，忽略依赖关系损坏的那个包。这个虽然不能解决问题，但至少可以减少影响。
</code></pre>

<h4 id="yum软件仓库">yum软件仓库</h4>

<p>软件仓库的配置文件在/etc/yum.repos.d目录下</p>

<pre><code>yum repolist 查看现有软件仓库
</code></pre>

<h3 id="从源码安装">从源码安装</h3>

<p>首先下载源码包</p>

<pre><code>tar -zxvf name.tar.gz 解压缩软件包
cd name 进入刚刚解压的软件包目录，查看README文件或AAAREADME文件。该文件中包含了软件安装所需要的操作
</code></pre>

<p>下面三条为常用的从源码安装的步骤</p>

<pre><code>./configure 这个命令检查Linux系统，确保有合适的编译器可以编译源代码，另外确保有正确的库依赖关系
make 编译源码，创建可执行文件
make install 安装编译好的可执行文件到系统中
</code></pre>

<h2 id="第十章-使用编辑器">第十章、使用编辑器</h2>

<h3 id="vim编辑器">vim编辑器</h3>

<h4 id="vim基础">vim基础</h4>

<pre><code>vim myprog.c 打开文件，如果文件不存在，则打开临时文件
</code></pre>

<p>进入vim后有两种模式：普通模式和插入模式。刚打开时vim编辑器会进入普通模式。普通模式中，vim编辑器会将案件解释成命令。在插入模式下，vim会将在当前光标位置的输入插入到缓冲区。</p>

<pre><code>i 进入插入模式，若要退出插入模式回到普通模式，按下退出键（ESC）
h 左移一个字符
j 下移一行
k 上移一行
l 右移一个字符
PageDown（或Ctrl+F） 下翻一屏
PageUp（或Ctrl+B）上翻一屏
G 移动到缓冲区的最后一行
num G 移动到缓冲区中的第num行
gg 移动到缓冲区的第一行
</code></pre>

<p>在普通模式下输入冒号，会进入普通模式下的一个特别功能：命令行模式。在命令行模式中有如下命令：</p>

<pre><code>q 如果未修改缓冲区数据，退出
q! 取消所有对缓冲区的修改并退出
w filename 将文件保存到另一个文件中
wq 将缓冲区数据保存到文件中并退出
</code></pre>

<h4 id="编辑数据">编辑数据</h4>

<p>在普通模式下，vim编辑器提供了一些命令来编辑缓冲区中的数据。</p>

<pre><code>x 删除当前光标所在位置的字符
2x 删除从当前光标所在位置开始的2个字符
dd 删除当前光标所在行
5dd 删除从当前光标所在行开始的5行数据
dw 删除当前光标所在位置的单词
d$ 删除当前光标所在位置至行尾的内容
J 删除当前光标所在行行尾的换行符（拼接行）
u 撤销前一编辑命令
a 在当前光标后追加数据
A 在当前光标所在行行尾追加数据
r char 用char替换当前光标所在位置的单个字符
R text 用text覆盖当前光标所在位置的数据，直到按下esc键
</code></pre>

<h4 id="复制和粘贴">复制和粘贴</h4>

<pre><code>删除命令默认都会把删除内容放到一个单独的寄存器中，类似于剪切。
p 取出寄存器中的数据并追加到当前光标位置
yw复制一个单词
y$复制到行尾
v 移动光标到要开始复制的位置，按下v，光标所在位置已经高亮，这时可以移动光标覆盖想要复制的区域，最后按y来激活复制命令。
</code></pre>

<h4 id="查找和替换">查找和替换</h4>

<pre><code>/ 在普通模式下按斜线，就是查找命令，输入查找的命令后按回车。如果没有找到，会报错，如果找到了，会显示光标后第一个（如果光标后没有，则从缓冲区第一行开始搜索），如果要查看下一个，键入n或者键入/后键入回车。
:s/old/new/ 命令行模式中使用，vim编辑器会调到old第一次出现的地方，并用new替换
:s/old/new/g 将当前行的所有old替换成new
:n,ms/old/new/g 替换行号n和m之间的所有old
:%s/old/new/g 替换整个文件中的所有old
:%s/old/new/gc 替换整个文件中的所有old，但在每次出现时提示
</code></pre>

<h3 id="nano编辑器">nano编辑器</h3>

<p>nano编辑器窗口的地步显示了各种命令及简要描述。脱字符（^）表示Ctrl键，组合键大小写不敏感。</p>

<pre><code>CTRL+C 显示光标在文本编辑缓冲区中的位置
CTRL+G 显示nano的主帮助窗口
CTRL+J 调整当前文本段落
CTRL+K 剪切文本行，并将其保存在剪切缓冲区
CTRL+O 将当前文本编辑缓冲区的内容写入文件
CTRL+R 将文件读入当前文本编辑缓冲区
CTRL+T 启动可用的拼写检查器
CTRL+U 将剪切缓冲区中的内容放入当前行
CTRL+V 翻动到文本编辑缓冲区中的下一页内容
CTRL+W 在文本编辑缓冲区中所搜单词或短语
CTRL+X 关闭当前文本编辑缓冲区，退出nano，返回shell
CTRL+Y 翻动到文本编辑缓冲区中的上一页内容
</code></pre>

<h3 id="emacs编辑器">emacs编辑器</h3>

<p>emacs编辑器使用包括控制键（PC键盘上的Ctrl键）和Meta键的按键组合。Meta一般被映射到Alt键。emacs官方文档将Ctrl键缩写为C-，而Meta键缩写为M-。</p>

<h4 id="在控制台中使用emacs">在控制台中使用emacs</h4>

<pre><code>C-p 上移一行
C-b 左移一字符
C-f 右移一字符
C-n 下移一行
M-f 右移到下一个单词
M-b 左移到上一个单词
C-a 移至行首
C-e 移至行尾
M-a 移至当前句首
M-e 移至当前句尾
M-v 上翻一屏
C-v 下翻一屏
M-&lt; 移至文本的首行
M-&gt; 移至文本的尾行
C-x C-s 保存当前缓冲区到文件
C-z 退出emacs并保持在这个会话中继续运行，以便切回
C-x C-c 退出emacs并停止该程序
M-Backspace 剪切光标当前所在位置之前的单词
M-d 剪切光标当前所在位置之后的单词
C-k 剪切光标当前所在位置至行尾的文本
M-k 剪切光标当前所在位置至句尾的文本
C-@或C-Spacebar 移动到待剪切区域的起始位置键入C-@或C-Spacebar，然后移动到结束位置按下C-w命令，两个位置间的内容将被剪切
C-/ 撤销剪切命令
C-y 粘贴
C-s 向下查找，可以直接输入文字（默认是渐进式查找，每输入一个字符都会从新触发查找并高亮结果），也可以输入回车，在查找前输入完整的待查找文本
C-r 向上查找，可以直接输入文字（默认是渐进式查找，每输入一个字符都会从新触发查找并高亮结果），也可以输入回车，在查找前输入完整的待查找文本
M-x replace-string 替换
C-x C-f 将新的文件加载到缓冲区
C-x C-b 列出工作缓冲区
C-x o 切换到缓冲区列表窗口
C-x b 输入你要切换到的缓冲区的名字
C-x 2 将窗口水平拆分成两个窗口
C-x 3 将窗口竖向拆分成两个窗口
C-x o 移动到另一个窗口
C-x 0 关闭当前窗口
C-x 1 关闭除当前窗口外的其他所有窗口
</code></pre>

<h1 id="第二部分-shell脚本编程基础">第二部分 shell脚本编程基础</h1>

<h2 id="构建基本脚本">构建基本脚本</h2>

<h3 id="使用多个命令">使用多个命令</h3>

<pre><code>date ; who 先显示系统时间，再显示当前登录系统的用户
</code></pre>

<h5 id="date">date</h5>

<p>显示系统时间</p>

<h5 id="who">who</h5>

<p>显示当前登录系统的用户</p>

<h3 id="创建shell脚本">创建shell脚本</h3>

<p>创建shell脚本文件时，必须在文件的第一行指定要使用的shell，其格式为</p>

<pre><code>#!/bin/bash 在通常的shell脚本中井号用作注释行，但是第一行例外，它告诉shell用哪个shell来运行脚本
</code></pre>

<p>在shell中，可以在文件的每一行输入命令，也可以使用分号分隔命令，例如：</p>

<pre><code>#!/bin/bash
# This script displays the date and who's logged on
date
who
</code></pre>

<p>脚本建立后，需要赋予用户执行的权限才可以执行</p>

<h3 id="显示消息">显示消息</h3>

<h5 id="echo">echo</h5>

<pre><code>echo This is a test 在控制台显示器上显示“This is a test”，并换行
echo -n &quot;this is a test&quot; 在控制台显示器上显示“This is a test”,但不换行
</code></pre>

<h3 id="使用变量">使用变量</h3>

<h4 id="环境变量">环境变量</h4>

<p>在脚本中，可以在环境变量名称前加上美元符来使用这些环境变量</p>

<pre><code>echo HOME: $HOME 输出用户的$HOME环境变量
echo &quot;HOME: $HOME&quot; 同上
echo &quot;HOME: ${HOME}&quot; 同上，${HOME}是另一种写法
echo &quot;HOME: \$HOME&quot; 反斜杠使$表示他本身，这句的输出结果就是&quot;HOME: HOME&quot;，而没有输出环境变量$HOME的值
</code></pre>

<h4 id="用户变量">用户变量</h4>

<p>给变量赋值时，等号左右不能有空格。使用时也是用$符号引用</p>

<pre><code>#!/bin/bash
days=10
guest=&quot;Eatie&quot;
echo &quot;$guest checked in $days days ago&quot;
</code></pre>

<h4 id="命令替换">命令替换</h4>

<p>shell脚本中最有用的特性之一就是可以从命令行输出中提取信息，并将其赋给变量。有两种方法可以将命令输出赋给变量：反引号字符（`）或$()格式</p>

<p>以下是一个例子，将date命令的输出赋予testing变量，然后再echo出来</p>

<pre><code>#!/bin/bash
testing=$(date)
echo &quot;The date and time are: &quot; $testing
</code></pre>

<p>同样的，也可以使用反引号来做命令替换</p>

<pre><code>#!/bin/bash
testing=`date`
echo &quot;The date and time are &quot; $testing
</code></pre>

<h3 id="重定向输入和输出">重定向输入和输出</h3>

<h4 id="输出重定向">输出重定向</h4>

<pre><code>date &gt; date.log 将date命令的结果输出到date.log文件中，如果date.log文件已存在，则覆盖它
date &gt;&gt; date.log 将date命令的结果输出到date.log文件中，如果date.log文件已存在，则追加写到它的末尾
</code></pre>

<h4 id="输入重定向">输入重定向</h4>

<h5 id="wc">wc</h5>

<p>wc命令可以对数据中的文本进行计数，默认情况下，输出3个值：行数、词数、字节数</p>

<pre><code>wc &lt; date.log 将文件内容重定向到wc命令中，统计行数、词数等信息
</code></pre>

<p>还有一种输入重定向的方法，称为内联输入重定向。这种方法无需使用文件进行重定向，只需要在命令行中输入用于重定向的数据就可以了。</p>

<pre><code>wc &lt;&lt; eof 使用用户输入的数据作为wc的输入，直到用户输入“eof”这个词的时候才结束输入并执行wc的命令
</code></pre>

<h3 id="管道">管道</h3>

<p>使用|符号，将前一个命令的输出作为后一个命令的输入。管道两边都是命令，而重定向的两边有一边是文件。</p>

<pre><code>ls -l | more 执行ls -l命令列出文件列表，并将输出当做more的输入，使我们可以更方便的查看输出结果
</code></pre>

<h3 id="执行数学运算">执行数学运算</h3>

<h4 id="expr命令">expr命令</h4>

<p>这个命令笔记笨拙，一般不使用</p>

<h5 id="expr">expr</h5>

<pre><code>expr 1 + 5 计算1+5的值，结果为6，空格要严格
expr 1 \* 5 计算1乘以5，\*用来代表乘以，因为*在shell中有其他的意义
</code></pre>

<h4 id="使用方括号">使用方括号</h4>

<p>这个是更简单的执行数学表达式的方法：使用美元符和方括号将数学表达式围起来</p>

<pre><code>echo $[1*5] 输出1乘以5
</code></pre>

<p>使用在脚本中的例子：</p>

<pre><code>#!/bin/bash
var1=100
var2=50
var3=45
var4=$[$var1 * ($var2 - $var3)]
echo The final result is $var4
</code></pre>

<h4 id="浮点解决方案">浮点解决方案</h4>

<p>bash shell数学运算符只支持整数运算。要克服这个限制，有几种解决方案。</p>

<p>最常见的方案是使用內建的bash计算器，叫做bc</p>

<pre><code>bc 进入bc计算器，在其中可以执行数学计算。
scale=4 进入bc后输入scale=4，可以让除法的运算结果保留4位小数
</code></pre>

<p>两个在脚本中使用bc的例子，第一个使用管道：</p>

<pre><code>#!/bin/bash
var1=20
var2=3.14159
var3=$(echo &quot;scale=4; $var1 * $var1&quot; | bc)
var4=$(echo &quot;scale=4; $var3 * $var2&quot; | bc)
echo The final result is $var4
</code></pre>

<p>下面是使用内联输入重定向的方法：</p>

<pre><code>#!/bin/bash
var1=10.46
var2=43.67
var3=33.2
var4=71
var5=$(bc &lt;&lt; EOF
scale = 4
a1 = ($var1 * $var2)
b1 = ($var3 * $var4)
a1 + b1
EOF
)
echo The final answer for this mess is $var5
</code></pre>

<h3 id="退出脚本">退出脚本</h3>

<h4 id="查看退出状态码">查看退出状态码</h4>

<p>Linux提供了一个专门的变量$?来报错上个已执行命令的退出状态码</p>

<pre><code>echo $? 查看上一个命令的退出状态码，0是成结束。
</code></pre>

<p>退出状态码参考</p>

<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>命令成功结束</td>
</tr>

<tr>
<td>1</td>
<td>一般性未知错误，如提供了无效参数</td>
</tr>

<tr>
<td>2</td>
<td>不适合的shell命令</td>
</tr>

<tr>
<td>126</td>
<td>命令不可执行，如没有权限</td>
</tr>

<tr>
<td>127</td>
<td>没找到命令</td>
</tr>

<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>

<tr>
<td>128+x</td>
<td>与Linux信号x相关的严重错误</td>
</tr>

<tr>
<td>130</td>
<td>通过Ctrl+c终止的命令</td>
</tr>

<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody>
</table>

<h4 id="exit命令">exit命令</h4>

<pre><code>exit 5 退出命令，指定退出状态码为5（正常的脚本退出时退出状态码是0）
</code></pre>

<h2 id="第十二章-使用结构化命令">第十二章、使用结构化命令</h2>

<h3 id="使用if-then语句">使用if-then语句</h3>

<p>格式如下，会执行if后的command命令，如果command命令的退出码为0，则执行then部分的命令，如果不为0则跳过，fi为if语句的结束</p>

<pre><code>if command
then
    commands
fi
</code></pre>

<p>或者将if和then放在同一行</p>

<pre><code>if command; then
    commands
fi
</code></pre>

<p>举一个例子,then部分可以使用不止一条命令</p>

<pre><code>#!/bin/bash
if pwd
then
    echo It worked
    echo It worked2
fi
</code></pre>

<h3 id="if-then-else语句">if-then-else语句</h3>

<p>格式如下，会执行if后的command命令，如果command命令的退出码为0，则执行then部分的命令，如果不为0则执行else部分的命令，fi为if语句的结束</p>

<pre><code>if command
then
    commands
else
    commands
fi
</code></pre>

<h3 id="嵌套if">嵌套if</h3>

<p>if语句可以嵌套</p>

<p>另外可以使用elif语句</p>

<pre><code>if command1
then
    commands1
elif command2
then
    commands2
fi
</code></pre>

<p>可以在elif后接一个else</p>

<pre><code>if command1
then
    commands1
elif command2
then
    commands2
esle
    commands3
fi
</code></pre>

<p>也可以使用多个elif</p>

<pre><code>if command1
then
    commands1
elif command2
then
    commands2
elif command3
then
    commands3
esle
    commands4
fi
</code></pre>

<h3 id="test命令">test命令</h3>

<p>如果test命令中列出的条件成立，test命令就会退出并返回状态码0，如果不成立，就会退出并返回非零的退出状态码，格式非常简单</p>

<pre><code>test condition
</code></pre>

<p>包含在if语句中的写法，如果不写condition部分，test会以非零的退出码退出</p>

<pre><code>if test condition
then
    commands
fi
</code></pre>

<p>bash shell提供了另一种条件测试方法，无需在if-then语句中生命test命令，格式如下，空格严格</p>

<pre><code>if [ condition ]
then
    commands
fi
</code></pre>

<h4 id="数值比较">数值比较</h4>

<p>数值比较功能的参数</p>

<table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>n1 -eq n2</td>
<td>检查n1是否与n2相等</td>
</tr>

<tr>
<td>n1 -ge n2</td>
<td>检查n1是否大于或等于n2</td>
</tr>

<tr>
<td>n1 -gt n2</td>
<td>检查n1是否大于n2</td>
</tr>

<tr>
<td>n1 -le n2</td>
<td>检查n1是否小于或等于n2</td>
</tr>

<tr>
<td>n1 -lt n2</td>
<td>检查n1是否小于n2</td>
</tr>

<tr>
<td>n1 -ne n2</td>
<td>检查n1是否不等于n2</td>
</tr>
</tbody>
</table>

<h4 id="字符串比较">字符串比较</h4>

<p>字符串比较功能的参数</p>

<table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>str1 = str2</td>
<td>检查str1是否和str2相同</td>
</tr>

<tr>
<td>str2 != str2</td>
<td>检查str1是否和str2不同</td>
</tr>

<tr>
<td>str1 &lt; str2</td>
<td>检查str1是否比str2小</td>
</tr>

<tr>
<td>str1 &gt; str2</td>
<td>检查str1是否比str2大</td>
</tr>

<tr>
<td>-n str1</td>
<td>检查str1的长度是否非0</td>
</tr>

<tr>
<td>-z str1</td>
<td>检查str1的长度是否为0</td>
</tr>
</tbody>
</table>

<p>在使用比较字符串大小时，必须对进行转义，否则会被shell当做重定向符号</p>

<pre><code>#!/bin/bash
val1=baseball
val2=hockey
if [ $val1 \&gt; $val2 ]
then
    echo &quot;$val1 is greater than $val2&quot;
else
    echo &quot;$val1 is less than $val2&quot;
fi
</code></pre>

<h4 id="文件比较">文件比较</h4>

<p>文件比较功能的参数</p>

<table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-d file</td>
<td>检查file是否存在并是一个目录</td>
</tr>

<tr>
<td>-e file</td>
<td>检查file是否存在</td>
</tr>

<tr>
<td>-f file</td>
<td>检查file是否存在并是一个文件</td>
</tr>

<tr>
<td>-r file</td>
<td>检查file是否存在并可读</td>
</tr>

<tr>
<td>-s file</td>
<td>检查file是否存在并非空</td>
</tr>

<tr>
<td>-w file</td>
<td>检查file是否存在并可写</td>
</tr>

<tr>
<td>-x file</td>
<td>检查file是否存在并可执行</td>
</tr>

<tr>
<td>-O file</td>
<td>检查file是否存在并属于当前用户所有</td>
</tr>

<tr>
<td>-G file</td>
<td>检查file是否存在并且默认组与当前用户相同</td>
</tr>

<tr>
<td>file1 -nt file2</td>
<td>检查file1是否比file2新</td>
</tr>

<tr>
<td>file1 -ot file2</td>
<td>检查file1是否比file2旧</td>
</tr>
</tbody>
</table>

<h3 id="符合条件测试">符合条件测试</h3>

<p>if-then语句允许使用布尔逻辑来组合测试。主要有两种布尔运算符可用：</p>

<pre><code>[ condition1 ] &amp;&amp; [ condition2 ]
[ condition1 ] || [ condition2 ]
</code></pre>

<h3 id="if-then的高级特性">if-then的高级特性</h3>

<h4 id="使用双括号">使用双括号</h4>

<p>双括号允许你在比较过程中使用高级数学表达式，格式如下</p>

<pre><code>(( expression ))
</code></pre>

<p>一些双括号命令符号列举</p>

<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>val++</td>
<td>后增</td>
</tr>

<tr>
<td>val–</td>
<td>后减</td>
</tr>

<tr>
<td>++val</td>
<td>先增</td>
</tr>

<tr>
<td>–val</td>
<td>先减</td>
</tr>

<tr>
<td>!</td>
<td>逻辑求反</td>
</tr>

<tr>
<td>~</td>
<td>位求反</td>
</tr>

<tr>
<td>**</td>
<td>幂运算</td>
</tr>

<tr>
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
</tbody>
</table>

<blockquote>
<blockquote>
</blockquote>
</blockquote>

<p>| 右位移<br />
&amp; | 位布尔和<br />
| | 位布尔或<br />
&amp;&amp; | 逻辑和<br />
|| | 逻辑或</p>

<p>可以在if语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值，举例来说</p>

<pre><code>#!/bin/bash
val1=10
if (( $val1 ** 2 &gt; 90 ))
then
    (( val2 = $val1 ** 2 ))
    echo &quot;The square of $val1 is $val2&quot;
fi
</code></pre>

<h4 id="使用双方括号">使用双方括号</h4>

<p>双方括号命令提供了针对字符串比较的高级特性，格式如下：</p>

<pre><code>[[ expression ]]
</code></pre>

<p>他提供了test命令未提供的另一个特性：模式匹配。</p>

<p>使用双等号（==）将右边的字符串视为一个模式，举例如下</p>

<pre><code>#!/bin/bash
if [[ $USER == r* ]]
then
    echo &quot;Hello $USER&quot;
else
    echo &quot;Sorry, I do not know you&quot;
fi
</code></pre>

<h3 id="case命令">case命令</h3>

<p>使用case命令就不需要再写出很多elif语句来不同检查同一个变量的值了。格式如下</p>

<pre><code>case variable in
pattern1 | pattern2） commands1;;
pattern3) commands2;;
*) defaultCommands;;
esac
</code></pre>

<p>举例如下</p>

<pre><code>#!/bin/bash
case $USER in
rich | barbara)
    echo &quot;welcome, $USER&quot;
    echo &quot;Please enjoy your visit&quot;;;
testing)
    echo &quot;Special testing account&quot;;;
jessica)
    echo &quot;Do not forget to log off when you're done&quot;;;
*)
    echo &quot;Sorry, you are not allowed here&quot;;;
esac
</code></pre>

<h2 id="第十三章-更多的结构化命令">第十三章、更多的结构化命令</h2>

<h3 id="for命令">for命令</h3>

<p>基本格式如下：</p>

<pre><code>for var in list
do
    commands
done
</code></pre>

<p>或者：</p>

<pre><code>for var in list; do
    commands
done
</code></pre>

<h4 id="读取列表中的值">读取列表中的值</h4>

<p>最后一次迭代的变量会在遍历结束后一直有效，除非修改它的值：</p>

<pre><code>#!/bin/bash
for test in Alabama Alaska Arizona
do
    echo &quot;The next state is $test&quot;
done
echo &quot;The last stage we visited was $test&quot;
</code></pre>

<h4 id="读取列表中的复杂值">读取列表中的复杂值</h4>

<p>如果列表中有单引号，则需要转义或用双引号扩起来；如果有值同时包含多个词，需要用双引号将多个词括起来</p>

<h4 id="从变量读取列表">从变量读取列表</h4>

<p>下面第三行代码可以向已有值的列表中拼接一个值</p>

<pre><code>#!/bin/bash
list=&quot;Alabama Alaska Arizona&quot;
list=$list&quot; Connecticut&quot;
for state in $list
do
    echo &quot;Have you ever visited $state?&quot;
done
</code></pre>

<h4 id="从命令读取值">从命令读取值</h4>

<pre><code>#!/bin/bash
file=&quot;states&quot;
for state in $(cat $file)
do
    echo &quot;Visit beautiful $state&quot;
done
</code></pre>

<h4 id="更改字段分隔符">更改字段分隔符</h4>

<p>默认情况下，bash shell的IFS（内部字段分隔符）包括空格、制表符、换行符</p>

<p>修改IFS，让它只识别换行</p>

<pre><code>IFS=$'\n'
</code></pre>

<p>如果需要多个值，串起来就行</p>

<pre><code>IFS=$'\n':;&quot;
</code></pre>

<h4 id="用通配符读取目录">用通配符读取目录</h4>

<pre><code>#!/bin/bash
for file in /home/rich/test/*
do
    commands
done
</code></pre>

<h3 id="c语言风格的for命令">C语言风格的for命令</h3>

<h4 id="c语言风格的for命令-1">C语言风格的for命令</h4>

<p>c语言风格的for命令不需要遵守bash shell标准的for命令：变量赋值可以用空格；条件中的变量不以美元符开头；迭代过程的算式未用expr命令格式。</p>

<p>命令格式：</p>

<pre><code>for (( variable assignment ; condition ; iteration process ))
</code></pre>

<p>示例：</p>

<pre><code>#!/bin/bash
for (( i=1; i &lt;= 10; i++ ))
do
    echo &quot;The next number is $i&quot;
done
</code></pre>

<h4 id="使用多个变量">使用多个变量</h4>

<p>示例：</p>

<pre><code>#!/bin/bash
for (( a=1, b=10; a &lt;= 10; a++, b--))
do
    echo &quot;$a - $b&quot;
done
</code></pre>

<h3 id="while命令">while命令</h3>

<h4 id="while命令的基本格式">while命令的基本格式</h4>

<p>只有测试命令的退出状态码不为0，才执行循环中的命令，否则退出循环。</p>

<p>格式：</p>

<pre><code>while test commands
do
    other commands
done
</code></pre>

<p>例子：</p>

<pre><code>#!/bin/bash
var1=10
while [ $var1 -gt 0 ]
do
    echo $var1
    var1=$[ $var1 - 1 ]
done
</code></pre>

<h4 id="使用多个测试命令">使用多个测试命令</h4>

<p>例子：</p>

<pre><code>#!/bin/bash
var1=10
while echo $var1
        [ $var1 -ge 0 ]
do
    echo &quot;This is inside the loop&quot;
    var1=$[ $var1 - 1 ]
done
</code></pre>

<h3 id="until命令">until命令</h3>

<p>until命令和while命令方式相反，只有测试命令的退出状态码不为0，才执行循环中的命令。</p>

<p>基本格式：</p>

<pre><code>until test commands
do
    other commands
done
</code></pre>

<h3 id="循环处理文件数据">循环处理文件数据</h3>

<p>示例为查看/etc/passwd文件每一个词的例子，其中使用了嵌套循环，和修改IFS环境变量</p>

<pre><code>#!/bin/bash
IFS.OLD=$IFS
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
    echo &quot;Values in $entry -&quot;
    IFS=:
    for value in $entry
    do
        echo &quot;  $value&quot;
    done
done
IFS=$IFS.OLD
</code></pre>

<h3 id="控制循环">控制循环</h3>

<p>有两个命令：break、continue</p>

<h4 id="break命令">break命令</h4>

<p>可以用break命令退出任意类型的循环</p>

<h5 id="跳出单个循环">跳出单个循环</h5>

<p>示例：</p>

<pre><code>#!/bin/bash
for var1 in 1 2 3 4 5 6 7 8
do
    if [ $var1 -eq 5 ]
    then
        break
    fi
    echo &quot;Iteration number: $var1&quot;
done
echo &quot;The for loop is completed&quot;
</code></pre>

<h5 id="跳出多个循环">跳出多个循环</h5>

<p>break接受一个参数，指定从内至外跳出几层循环，默认为1。如果跳出多个循环时，可以使用这个参数，格式为：</p>

<pre><code>break n
</code></pre>

<h4 id="continue命令">continue命令</h4>

<p>continue命令提前终止某次循环中的命令，但不会完全终止整个循环。</p>

<p>continue用法格式和break类似，也可以接收参数n。</p>

<h3 id="处理循环的输出">处理循环的输出</h3>

<p>可以对循环的输出使用管道或进行重定向</p>

<p>重定向示例：</p>

<pre><code>#!/bin/bash
for file in /home/rich/*
do
    if [ -d &quot;$file&quot; ]
    then
        echo &quot;$file is a directory&quot;
    elif
        echo &quot;$file is a file&quot;
    fi
done &gt; output.txt
</code></pre>

<p>管道示例：</p>

<pre><code>...
done | sort
</code></pre>

<h3 id="实例">实例</h3>

<h4 id="创建多个用户账户">创建多个用户账户</h4>

<p>这个例子使用了read命令，read命令可以自动读取.csv文件的下一行，没有下一行时返回FALSE</p>

<p>示例：</p>

<pre><code>#!/bin/bash
input=&quot;users.csv&quot;
while IFS=',' read -r userid name
do
    echo &quot;adding $userid&quot;
    useradd -c &quot;$name&quot; -m $userid
done &lt; &quot;$input&quot;
</code></pre>

<h2 id="第十四章-处理用户输入">第十四章、处理用户输入</h2>

<h3 id="命令行参数">命令行参数</h3>

<p>命令行参数以空格分隔，如果参数本身带有空格，则需要用单引号或双引号括起来</p>

<h4 id="读取参数">读取参数</h4>

<p>bash shell会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数。位置参数变量是标准的数字： 0是程序名， 1是第一个参数，
2是第二个参数，直到第九个参数 9</p>

<h4 id="读取脚本名">读取脚本名</h4>

<p>读取脚本名时，如果使用全路径，路径也会在$0变量中，可以使用basename命令返回不包含路径的脚本名，示例如下：</p>

<pre><code>#!/bin/bash
name=$(basename $0)
echo 
echo The scripte name is: $name
</code></pre>

<h4 id="测试参数">测试参数</h4>

<p>测试参数是否存在数据，示例：</p>

<pre><code>#!/bin/bash
if [ -n &quot;$1&quot; ]
then
    echo Hello $1
else
    echo &quot;Sorry, you did not identify yourself.&quot;
fi
</code></pre>

<h3 id="特殊参数变量">特殊参数变量</h3>

<h4 id="参数统计">参数统计</h4>

<pre><code>$# 特殊变量，含有脚本运行时携带的命令行参数的个数
${!#} 特殊变量，表示参数列表的最后一个参数
</code></pre>

<h4 id="抓取所有数据">抓取所有数据</h4>

<p>∗和 @都是存储所有变量，但是前者把所有变量存放成单个参数，而后者可以遍历</p>

<h3 id="移动遍历">移动遍历</h3>

<p>shift命令能够用来操作命令行参数，会根据他们的相对位置来移动命令行参数。默认情况下它会将每个参数变量向左移动一个位置。 3移到 2, 2移到 1，
1被删除，而 0存的是程序名，不会改变。在不知道参数有多少，又要遍历参数列表时很方便，示例如下：</p>

<pre><code>#!/bin/bash
count=1
while [ -n &quot;$1&quot; ]
do
    echo &quot;Parameter #$count = $1&quot;
    count=$[ $count + 1 ]
    shift
done
</code></pre>

<p>另外也可以一次性移动多个位置，只需要提供一个参数，格式：</p>

<pre><code>shift n
</code></pre>

<h3 id="处理选项">处理选项</h3>

<h4 id="查找选项">查找选项</h4>

<p>可以简单的在shell脚本中做判断，不推荐</p>

<h4 id="使用getopt命令">使用getopt命令</h4>

<p>getopt可以接受一系列任意形式的命令行选项和参数，并将他们转换成适当的格式,。命令格式如下：</p>

<pre><code>getopt optstring parameters 
</code></pre>

<p>其中，optstring定义了格式（在optstring中列出要在脚本中用到的每个命令行选项字母，在每个需要参数值的选项字母后加一个冒号），parameters是需要解析的参数列表。示例如下：</p>

<pre><code>getopt ab:cd -a -b test1 -cd test2 test3
</code></pre>

<p>上面例子定义了4个有效选项字母：a、b、c、d。冒号放在b后面，因为b需要一个参数值。</p>

<p>如果要去掉错误信息，可以在optstring前面加-q，举例如下：</p>

<pre><code>getopt -q ab:cd -a -b test1 -cde test2 test3
</code></pre>

<p>在脚本中使用时，需要使用set命令将命令行参数替换成set命令的命令行值使用举例：</p>

<pre><code>#!/bin/bash
set -- $(getopt -q ab:cd &quot;$@&quot;)
while [ -n &quot;$1&quot; ]
do
    case &quot;$1&quot; in
    -a) echo &quot;Found the -a option&quot; ;;
    -b) param=&quot;$2&quot;
        echo &quot;Fountd the -b option, with parameter value $param&quot;
        shift ;;
    -c) echo &quot;Found the -c option&quot; ;;
    --) shift
        break ;;
    *) echo &quot;$1 is not an option&quot; ;;
    esac
    shift
done
#
count=1
for param in &quot;$@&quot;
do
    echo &quot;Parameter #$count: $param&quot;
    count=$[ $count + 1 ]
done
</code></pre>

<p>getopt无法识别带空格和引号的参数值</p>

<h4 id="使用更高级的getopts">使用更高级的getopts</h4>

<p>getopts一次只处理命令行上检测到的一个参数，处理完所有参数后，会退出并返回一个大于0的退出状态码，非常适合用于解析所有参数的循环中</p>

<p>命令格式如下：</p>

<pre><code>getopts optstring variable
</code></pre>

<p>optstring类似getopt的那个，有效选项字母都在optstring中，如果选项有参数，在后面加个冒号。如果要去掉错误消息，可以在optstring之前加一个冒号。当前参数保存在命令行中定义的variable中</p>

<p>getopts命令会用到两个环节变量，如果选项需要跟一个参数值，OPTARG环境变量会保存这个值，OPTIND环境变量保存了参数列表中getopts正在处理的参数位置，以便在处理完选项之后继续处理其他命令行参数。</p>

<p>使用示例如下：</p>

<pre><code>#!/bin/bash
echo
while getopts :ab:c opt
do
    case &quot;$opt&quot; in
        a) echo &quot;Found -a option&quot; ;;
        b) echo &quot;Found -b option, with value $OPTART&quot; ;;
        c) echo &quot;Found -c option&quot; ;;
        *) echo &quot;Unknown option: $opt&quot;;;
    esac
done
#
shift $[ $OPTIND -1 ]
#
echo
count=1
for param in &quot;$@&quot;
do
    echo &quot;Parameter $count: $param&quot;
    count=$[ $count + 1 ]
done
</code></pre>

<p>上面例子中，使用$OPTIND和shift将前面选项部分的参数移除，只剩下后面的参数部分</p>

<p>getopts的优势，可以在参数中使用空格，可以将字母和参数值放在一起使用，例如：</p>

<pre><code>./test19.sh -abtest1
</code></pre>

<h3 id="将选项标准化">将选项标准化</h3>

<p>有些选项有约定俗成的用法</p>

<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-a</td>
<td>显示所有对象</td>
</tr>

<tr>
<td>-c</td>
<td>生成一个计数</td>
</tr>

<tr>
<td>-d</td>
<td>指定目录</td>
</tr>

<tr>
<td>-e</td>
<td>扩展一个对象</td>
</tr>

<tr>
<td>-f</td>
<td>指定读入数据的文件</td>
</tr>

<tr>
<td>-h</td>
<td>显示命令的帮助信息</td>
</tr>

<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>

<tr>
<td>-l</td>
<td>产生输出的长格式版本</td>
</tr>

<tr>
<td>-n</td>
<td>使用非交互模式（批处理）</td>
</tr>

<tr>
<td>-o</td>
<td>将所有输出重定向到指定的输出文件</td>
</tr>

<tr>
<td>-q</td>
<td>安静模式运行</td>
</tr>

<tr>
<td>-r</td>
<td>递归处理</td>
</tr>

<tr>
<td>-s</td>
<td>安静模式运行</td>
</tr>

<tr>
<td>-v</td>
<td>生成详细输出</td>
</tr>

<tr>
<td>-x</td>
<td>排除某个对象</td>
</tr>

<tr>
<td>-y</td>
<td>对所有问题回答yes</td>
</tr>
</tbody>
</table>

<h3 id="获得用户输入">获得用户输入</h3>

<p>获得用户输入可以使用read命令</p>

<h4 id="基本的读取">基本的读取</h4>

<p>read命令从标准输入或另一个文件描述符中接受输入，在收到输入后，会将数据放入一个变量</p>

<p>示例：</p>

<pre><code>#!/bin/bash
echo -n &quot;Enter your name: &quot;
read name
echo &quot;Hello $name, welcome to my program.&quot;
</code></pre>

<p>read可以使用-p选项，允许指定提示符，示例：</p>

<pre><code>read -p &quot;Please enter your age: &quot; age
</code></pre>

<p>read可以指定多个变量，示例：</p>

<pre><code>read -p &quot;Enter your name: &quot; first last
</code></pre>

<p>read可以不指定变量，这样会将输入存放到特殊环境变量REPLY中,示例：</p>

<pre><code>#!/bin/bash
read -p &quot;Enter your name: &quot;
echo
echo Hello $REPLY, welcome!
</code></pre>

<h4 id="超时">超时</h4>

<p>可以使用-t来指定一个计时器</p>

<pre><code>#!/bin/bash
if read -t 5 -p &quot;Please enter your name: &quot; name
then
    ...
else
    ...
fi
</code></pre>

<p>也可以使用-n来指定接受几个字符，例如-n1，read命令会在接受到一个字符后自动退出，示例：</p>

<pre><code>#!/bin/bash
read -n1 -p &quot;Do you want to continue [Y/N]? &quot; answer
case $answer in
Y | y)  echo
        echo &quot;fine,continue on...&quot;;;
N | n)  echo
        echo OK, goodbye
        exit;;
esca
</code></pre>

<h4 id="隐藏方式读取">隐藏方式读取</h4>

<p>-s选项可以避免read命令中输入的数据出现在显示器上，示例如下：</p>

<pre><code>read -s -p &quot;Enter your password: &quot; pass
</code></pre>

<h4 id="从文件中读取">从文件中读取</h4>

<p>示例如下：</p>

<pre><code>#!/bin/bash
count=1
cat test | while read line
do
    ...
    count=$[ $count + 1 ]
done
</code></pre>

<h2 id="第十五章-呈现数据">第十五章、呈现数据</h2>

<h3 id="理解输入和输出">理解输入和输出</h3>

<h4 id="标准文件描述符">标准文件描述符</h4>

<p>每个进程一次最多可以有9个文件描述符，bash shell保留了前三个文件描述符（0、1和2），见下表</p>

<table>
<thead>
<tr>
<th>文件描述符</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>

<tr>
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>

<tr>
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody>
</table>

<p>使用重定向符号（</p>

<pre><code>cat &lt; testfile.log
</code></pre>

<p>使用重定向符号（&gt;）时，Linux会用重定向指定的文件来替换标准输出文件描述符，示例：</p>

<pre><code>ls -l &gt; test.log        标准输出文件描述符替换成test.log，并且是重写模式
ls -l &gt;&gt; test.log       标准输出文件描述符替换成test.log，并且是追加模式
</code></pre>

<h4 id="重定向错误">重定向错误</h4>

<p>只重定向错误，可以这样(STDERR的文件描述符是2，该值必须紧紧地放在重定向符号前)：</p>

<pre><code>ls -al badfile 2&gt; test4
</code></pre>

<p>重定向错误和输出(2&gt;是标准错误流重定向，1&gt;是标准输出流重定向)，示例：</p>

<pre><code>ls -al test test2 badtest 2&gt; test1.log 1&gt; test2.log
</code></pre>

<p>将错误流和输出流同时重定向到一个文件，可以使用特殊的重定向符号&amp;&gt;,示例如下：</p>

<pre><code>ls -al test test2 badtest &amp;&gt; test.log
</code></pre>

<h3 id="在脚本中重定向输出">在脚本中重定向输出</h3>

<p>在脚本中重定向输出有两种方式：临时重定向，永久重定向</p>

<h4 id="临时重定向">临时重定向</h4>

<p>示例：</p>

<pre><code>#!/bin/bash
echo &quot;This is an error&quot; &gt;&amp;2
echo &quot;This is normal output&quot;
</code></pre>

<p>上述脚本将第一行重定向到了错误流，如果在执行该脚本时重定向错误流，即可看到该行是错误流的输出（执行脚本时重定向错误流的原因是默认情况下STDERR会导向STDOUT）</p>

<h4 id="永久重定向">永久重定向</h4>

<p>可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，示例：</p>

<pre><code>#!/bin/bash
exec 1&gt;testout.log
ecec 2&gt;testerror.log
echo &quot;This should go to the testout.log file&quot;
echo &quot;this should go to the testerror.log file&quot; &gt;&amp;2
</code></pre>

<h3 id="在脚本中重定向输入">在脚本中重定向输入</h3>

<p>可以使用exec命令将STDIN从键盘重定向到其他位置,示例：</p>

<pre><code>exec 0&lt; testfile.log
</code></pre>

<h3 id="创建自己的重定向">创建自己的重定向</h3>

<p>shell中最多可以有9个文件描述符，3~8均可用作输入或输出重定向</p>

<h4 id="创建输出文件描述符">创建输出文件描述符</h4>

<p>示例：</p>

<pre><code>#!/bin/bash
exec 3&gt;test3out.log
echo &quot;This should display on the monitor&quot;
echo &quot;This should be stored in the file&quot; &gt;&amp;3
</code></pre>

<h4 id="重定向文件描述符">重定向文件描述符</h4>

<p>示例，注意看示例中的文本：</p>

<pre><code>#!/bin/bash
exec 3&gt;&amp;1
exec 1&gt;test4out
echo &quot;This should store in the output file&quot;
exec 1&gt;&amp;3
echo &quot;Now things should be back to normal&quot;
</code></pre>

<p>这个例子首先将文件描述符3重定向到文件描述符1，也就是STDOUT，这样所有发送给3的输出都将出现在显示器上。第二个exec命令将STDOUT重定向到文件（但是文件描述符3仍然指向STDOUT原来的位置），所以第一个echo的句子会存入文件中，第三个exec将STDOUT重定向到文件描述符3的当前位置（现在仍然是显示器）。这意味着现在STDOUT又指向了它原来的位置：显示器。</p>

<h4 id="创建输入文件描述符">创建输入文件描述符</h4>

<p>可以用和上一节通用的办法重定向输入文件描述符，示例如下，注意看其中的文本：</p>

<pre><code>#!/bin/bash
exec 6
</code></pre>

<p>上个例子先用6来保存STDIN的位置，然后将STDIN重定向到文件，读完文件后又将STDIN重定向到文件描述符6也就是最初STDIN的位置</p>

<h4 id="创建读写文件描述符">创建读写文件描述符</h4>

<p>可以对同一个文件进行数据读写，shell会维护一个内部指针，知名在文件中的当前位置，任何读写都会从文件指针上次的位置开始，示例：</p>

<pre><code>#!/bin/bash
exec 3&lt;&gt; testfile
read line &amp;3
</code></pre>

<p>脚本执行前testfile内容：</p>

<pre><code>this is the first line.
this is the second line.
this is the third line
</code></pre>

<p>执行后testfile内容：</p>

<pre><code>this is the first line.
this is a test line.
this is the third line.
</code></pre>

<h4 id="关闭文件描述符">关闭文件描述符</h4>

<p>shell脚本退出时回自动关闭文件描述符，但是也可以手动关闭，格式如下：</p>

<pre><code>exec 3&gt;&amp;-
</code></pre>

<p>如果调用已经关闭的文件描述符，会得到Bad file
descriptor的错误信息。如果在关闭文件描述符后又在脚本中打开了同一个输出文件，这个文件会被替换。</p>

<h3 id="列出打开的文件描述符">列出打开的文件描述符</h3>

<p>lsof命令会显示当前Linux系统上打开的每个文件的有关信息，包括后台运行的所有进程以及登录到系统的任何用户。</p>

<p>选项-p可以指定进程ID（即PID，可以使用特殊环境变量$$表示当前PID），选项-d运行指定要显示的文件描述符编号，选项-
a用来对其他两个选项的结果执行布尔AND运算，示例：</p>

<pre><code>lsof -a -p $$ -d 0,1,2
</code></pre>

<p>上栗显示了当前进程（bash shell）的默认文件描述符（0、1和2）。lsof的默认输出信息见下表</p>

<table>
<thead>
<tr>
<th>列</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>COMMAND</td>
<td>正在运行的命令名的前9个字符</td>
</tr>

<tr>
<td>PID</td>
<td>进程的PID</td>
</tr>

<tr>
<td>USER</td>
<td>进程属主的登录名</td>
</tr>

<tr>
<td>FD</td>
<td>文件描述符号以及访问类型（r读，w写，u读写）</td>
</tr>

<tr>
<td>TYPE</td>
<td>文件类型（CHR字符型，BLK块型，DIR目录，REG常规文件）</td>
</tr>

<tr>
<td>DEVICE</td>
<td>设备的设备号（主设备号和从设备号）</td>
</tr>

<tr>
<td>SIZE</td>
<td>如果有的话，表示文件大小</td>
</tr>

<tr>
<td>NODE</td>
<td>本地文件的节点号</td>
</tr>

<tr>
<td>NAME</td>
<td>文件名</td>
</tr>
</tbody>
</table>

<h3 id="阻止命令输出">阻止命令输出</h3>

<p>/dev/null不存在也不保存任何内容，可以使用他来重定向输入输出流</p>

<p>避免输出错误消息示例：</p>

<pre><code>ls -al badfile test1 2&gt; /dev/null
</code></pre>

<p>也可以用它删除文件中的数据：</p>

<pre><code>cat /dev/null &gt; testfile.log
</code></pre>

<h3 id="创建临时文件">创建临时文件</h3>

<p>可以使用mktemp命令创建只有自己可以访问的临时文件，只需要指定文件名，并在文件名末尾加上几个X即可（需要大于3个），ketemp命令会用随机字符替换这几个X，并且确保它在该目录下是唯一的</p>

<h4 id="创建本地临时文件">创建本地临时文件</h4>

<p>格式如下：</p>

<pre><code>mktemp test.XXXXXX
</code></pre>

<p>因为它会返回创建的文件名，所以可以在shell中使用，并将创建的文件名存入变量中，示例如下：</p>

<pre><code>#!/bin/bash
tempfile=$(mktemp test.XXXXXX)
exec 3&gt;$tempfile
echo &quot;This script writes to temp file $tempfile&quot;
echo &quot;This is the first line&quot; &gt;&amp;3
echo &quot;This is the second line&quot; &gt;&amp;3
exec 3&gt;&amp;-
rm -f $tempfile 2&gt; /dev/null
</code></pre>

<h4 id="在-tmp目录创建临时文件">在/tmp目录创建临时文件</h4>

<p>可以使用-t选项来强制mktemp命令在系统的临时目录来创建该文件，这时这个命令返回临时文件的全路径，示例如下：</p>

<pre><code>mktemp -t test.XXXXXX
</code></pre>

<h4 id="创建临时目录">创建临时目录</h4>

<p>可以使用-d选项告诉mktemp命令来创建一个临时目录而不是临时文件，示例如下：</p>

<pre><code>mktemp -d dir.XXXXX
</code></pre>

<h3 id="记录消息">记录消息</h3>

<p>tee命令相当于管道的一个T型接头。它将从STDIN过来的数据同时发往两处，一处是STDOUT,另一处是tee命令行所指定的文件名，格式如下：</p>

<pre><code>tee filename
</code></pre>

<p>默认情况tee命令会覆盖文件，如果需要追加，则需要使用-a选项，示例如下：</p>

<pre><code>date | tee -a testfile.log
</code></pre>

<h3 id="实例-1">实例</h3>

<p>读取.csv文件，并输出sql语句到文本文件中，脚本如下：</p>

<pre><code>#!/bin/bash
outfile='members.sql'
IFS=','
while read lname fname address city state zip
do
    cat &gt;&gt; $outfile &lt;&lt; EOF
    INSERT INTO members (lname,fname,address,city,state,zip) VALUES ('$lname','$fname','$address','$city','$state','$zip');
EOF
done &lt; ${1}
</code></pre>

<p>共有3个重定向，done后面的重定向知名了待读取数据的文件；cat &gt;&gt; outfile&lt;&lt;EOF则指定了cat命令的输出重定向到了
outfile,而EOF符号标记了追加到文件中的数据的起止</p>

<h2 id="第十六章-控制脚本">第十六章、控制脚本</h2>

<h3 id="处理信号">处理信号</h3>

<h4 id="生成信号">生成信号</h4>

<p>Ctrl+C组合键会生成SIGINT信号，中断进程</p>

<p>Ctrl+Z组合键会生成SIGTSTP信号，暂停进程</p>

<p>ps命令将已暂停作业的状态显示为T</p>

<h4 id="捕获信号">捕获信号</h4>

<p>可以使用trap命令捕获信号，格式如下：</p>

<pre><code>trap commands signals
</code></pre>

<p>使用示例，可以检测到传入的信号并做处理，这个例子中，捕获到中断信号，但并不退出：</p>

<pre><code>#!/bin/bash
trap &quot;echo ' Sorry! I have trapped Ctrl-c'&quot; SIGINT
other commands
</code></pre>

<h4 id="捕获脚本退出">捕获脚本退出</h4>

<p>要在脚本退出时进行捕获，可以捕获EXIT信号，示例：</p>

<pre><code>#!/bin/bash
trap &quot;echo bye!&quot; EXIT
other commands
</code></pre>

<h4 id="修改或移除捕获">修改或移除捕获</h4>

<p>修改捕获,只需要重新进行捕获：</p>

<pre><code>#!/bin/bash
trap &quot;echo ' Sorry! I have trapped Ctrl-c'&quot; SIGINT
other commands
trap &quot;echo ' I modified the trap '&quot; SIGINT
other commands
</code></pre>

<p>删除捕获，只需要在trap与信号列表间加两个破折号（单破折号也可以）：</p>

<pre><code>#!/bin/bash
trap &quot;echo ' Sorry! I have trapped Ctrl-c'&quot; SIGINT&quot;
other commands
trap -- SIGINT
other commands
</code></pre>

<h3 id="以后台模式运行脚本">以后台模式运行脚本</h3>

<p>只需要在命令后加个&amp;符号即可，示例：</p>

<pre><code>./test4.sh &amp;
</code></pre>

<h3 id="在非控制台下运行脚本">在非控制台下运行脚本</h3>

<p>如果想在终端结束后依然运行命令，可以使用nohup命令，示例：</p>

<pre><code>nohup ./test1.sh &amp;
</code></pre>

<h3 id="作业控制">作业控制</h3>

<h4 id="查看作业">查看作业</h4>

<p>脚本可以使用$$变量来显示系统分配给该脚本的PID，示例：</p>

<pre><code>#!/bin/bash
echo &quot;Script Process ID: $$&quot;
</code></pre>

<p>jobs命令可以查看分配给shell的后台作业，它有一些参数，例如jobs -l可以显示命令的PID，其他参数如下表：</p>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-l</td>
<td>列出进程的PID及作业号</td>
</tr>

<tr>
<td>-n</td>
<td>只列出上次shell发出通知后改变了状态的作业</td>
</tr>

<tr>
<td>-p</td>
<td>只列出作业的PID</td>
</tr>

<tr>
<td>-r</td>
<td>只列出运行中的作业</td>
</tr>

<tr>
<td>-s</td>
<td>只列出已停止的作业</td>
</tr>
</tbody>
</table>

<p>jobs命令输出中的加号会被当做默认作业，在使用控制命令时，如果未指定作业号，则该默认作业会被当做控制命令的操作对象，默认作业完成处理后，带减号的作业成为下一个默认作业。</p>

<h4 id="重启停止的作业">重启停止的作业</h4>

<p>可以使用bg命令将停止的作业从后台启动，示例：</p>

<pre><code>bg      从后台启动默认作业
bg 2    从后台启动作业号为2的作业
</code></pre>

<p>可以使用fg命令将停止的作业从前台启动，使用方法和bg相同</p>

<h3 id="调整谦让度">调整谦让度</h3>

<p>调度优先级是个正数值，从-20（最高优先级）到+19（最低优先级），默认情况下bash shell以优先级0来启动所有进程</p>

<h4 id="nice命令">nice命令</h4>

<p>nice命令可以指定命令启动时的调度优先级，示例如下：</p>

<pre><code>nice -n 10 ./test.sh
</code></pre>

<h4 id="renice命令">renice命令</h4>

<p>renice命令可以改变已经运行的命令的优先级，示例如下：</p>

<pre><code>renice -n 10 -p 1234
</code></pre>

<h3 id="定时运行作业">定时运行作业</h3>

<h4 id="用at命令来计划执行作业">用at命令来计划执行作业</h4>

<p>默认情况下，at命令将STDIN的输入放到待执行队列中，但是可以用-f来指定用于读取命令的文件名，格式如下：</p>

<pre><code>at [-f filename] time
</code></pre>

<p>time参数指定了系统何时运行该作业，如果指定的时间已经错过，at命令会在第二天的那个时间运行该命令。at可以识别多种不同的时间格式，例如：</p>

<pre><code>标准的小时和分钟格式，如10：15
AM/PM指示符，如10：15PM
特定可命名时间，如now、noon、midnight、teatime等
标准日期格式，如MMDDYY、MM/DD/YY或DD.MM.YY
文本日期，如Jul 4或Dec 25，加不加年份均可
你也可以指定时间增量如  +25min
</code></pre>

<h4 id="列出等待的作业">列出等待的作业</h4>

<p>使用atq命令可以查看系统中有哪些作业在等待</p>

<h4 id="删除作业">删除作业</h4>

<p>可以使用atrm删除等待中的作业(需要指定队列中的位置，所以要配合atq命令使用)，例如：</p>

<pre><code>atrm 18
</code></pre>

<h3 id="安排需要定期执行的脚本">安排需要定期执行的脚本</h3>

<p>可以使用cron命令来安排需要定期执行的脚本，格式如下：</p>

<pre><code>min hour dayofmonth month dayofweek command
</code></pre>

<p>cron时间表允许你用特定值，取值范围（如1~5）或者是通配符（星号*）来指定条目。例如，如果想在每天的10：15允许一个命令，可以用cron时间表条目：</p>

<pre><code>15 10 * * * command
</code></pre>

<h4 id="构建cron时间表">构建cron时间表</h4>

<p>可以使用crontab -l来列出已有的cron时间表</p>

<p>可以使用crontab -e来修改已有的cron时间表（如果时间表不存在则是一个空文件）</p>

<p>如果脚本对精确的执行时间要求不高，可以用预配置的cron脚本目录，有四个基本目录：/etc/hourly,/etc/daily,/etc/monthly,/etc/weekly，直接把脚本放到相关目录中即可</p>

<h4 id="anacron程序">anacron程序</h4>

<p>cron程序是假定系统7*24小时运行的。如果程序关机，则关机过程中会错过一些命令的执行。</p>

<p>anacron之道某个作业错过执行时间时，会尽快运行该作业，如果系统关机了几天，再次开机时，anacron会自动运行在关机期间应该运行的作业。anacron只会处理位于cron目录中的程序，例如/etc/cron.monthly（不会处理时间需求小于一天的脚本，即/etc/cron.hourly）。它用时间戳来确定作业是否执行过，时间戳文件位于/var/spool/anacron。</p>

<p>格式：</p>

<pre><code>period delay identifier command
period指定作业多久运行一次，单位是天
delay指定系统启动后anacron需要等待多少分钟再开始运行错过的脚本
</code></pre>

<h1 id="第三部分-高级shell脚本编程">第三部分、高级shell脚本编程</h1>

<h2 id="第十七章-创建函数">第十七章、创建函数</h2>

<h3 id="基本的脚本函数">基本的脚本函数</h3>

<p>创建函数格式：</p>

<pre><code>function name {
    commands
}
</code></pre>

<p>或者：</p>

<pre><code>name() {
    commands   
}    
</code></pre>

<p>使用函数示例：</p>

<pre><code>#!/bin/bash
function func1 {
    echo &quot;hello&quot;  
}    
func1
</code></pre>

<p>注意：函数要先定义才可以使用；函数重复定义的话后面会把前面覆盖。</p>

<h3 id="返回值">返回值</h3>

<h4 id="默认退出状态码">默认退出状态码</h4>

<p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码(即使中间有命令失败也不影响)。在函数执行结束后，可以使用$?变量来确定函数的退出状态码，示例如下：</p>

<pre><code>#!/bin/bash
func() {
    echo &quot;hello&quot;
}
func
echo &quot;The exit status is : $?&quot;
</code></pre>

<h4 id="使用return命令">使用return命令</h4>

<p>return命令可以指定一个退出状态码，但是必须在0~255之间，否则会产生一个错误值（不会报错）</p>

<h4 id="使用函数输出">使用函数输出</h4>

<p>打破return的限制，可以把函数的输出保存到变量中使用，例如：</p>

<pre><code>#!/bin/bash
function something {
    echo 500
}
result=${something}
echo &quot;The value is $result&quot;
</code></pre>

<h3 id="在函数中使用变量">在函数中使用变量</h3>

<h4 id="向函数传递参数">向函数传递参数</h4>

<p>bash
shell会将函数当做小型脚本对待，所以可以像向普通脚本传递参数一样操作。函数不能直接使用所在脚本的参数（即外部调用脚本时传入的参数），如果要使用必须手动传入。</p>

<h4 id="在函数中处理变量">在函数中处理变量</h4>

<p>变量有两种，全局变量和局部变量。默认情况下在脚本中定义的变量都是全局变量，即使在函数中也可以访问。如果函数中需要自己的局部变量，需要在声明变量时加上local关键字，例如：</p>

<pre><code>local temp=&quot;hello&quot;
</code></pre>

<h3 id="数组变量和函数">数组变量和函数</h3>

<h4 id="向函数传递数组">向函数传递数组</h4>

<p>将数组变量当做单个参数传递的话不会起作用，函数会只取数组变量的第一个值，解决办法是把他们分解成单个值传入，函数中再将其组合，例如：</p>

<pre><code>#!/bin/bash
#
function testit {
    local newarray
    newarray=(;'echo &quot;$@&quot;')
    echo &quot;The new array value is : ${newarray[*]}&quot;
}
myarray=(1 2 3 4 5)
echo &quot;The original array is ${myarray[*]}&quot;
testit ${myarray[*]}
</code></pre>

<h4 id="从函数返回数组">从函数返回数组</h4>

<p>从函数里向shell脚本传回数组变量也需要用类似的方法。</p>

<h3 id="创建库">创建库</h3>

<p>首先要创建库文件myfuncs，例如：</p>

<pre><code>#!/bin/bash
function addem {
    echo $[ $1 + $2 ]
}
</code></pre>

<p>在其他脚本中使用则需要用source命令（source命令有个快捷的别名，称作点操作符），例如：</p>

<pre><code>#!/bin/bash
. ./myfuncs
addem 1 4
</code></pre>

<p>其中的.可以替换成source命令，是一样的。</p>

<p>source命令是在当前shell上下文中执行命令，而不是创建一个新shell</p>

<h3 id="在命令行上使用函数">在命令行上使用函数</h3>

<h4 id="在命令行上创建函数">在命令行上创建函数</h4>

<p>可以直接在命令行创建函数，但是退出shell就会消失</p>

<h4 id="在-bashrc文件中定义函数">在.bashrc文件中定义函数</h4>

<p>两种方式，一是直接在这个文件中创建函数，二是在这个文件中读取其他函数文件（也就是source创建好的函数库文件）</p>

<h2 id="第十八章-图形化桌面环境中的脚本编程">第十八章、图形化桌面环境中的脚本编程</h2>

<p>这章并不太感兴趣，没有做笔记，只零散记录了命令</p>

<h5 id="clear">clear</h5>

<p>clear命令用于清除屏幕</p>

<h2 id="第十九章-初识sed和gawk">第十九章、初识sed和gawk</h2>

<h3 id="文本处理">文本处理</h3>

<h4 id="sed编辑器">sed编辑器</h4>

<p>sed编辑器被称作流编辑器，和普通的交互式文本编辑器恰好相反。流编辑器基于预先提供的一组规则来编辑数据流。sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在文件中。sed编辑器会执行下列操作：</p>

<pre><code>1、一次从输入中读取一行数据
2、根据所提供的编辑器命令匹配数据
3、按照命令修改流中的数据
4、将新的数据输出到STDOUT
</code></pre>

<p>sed格式如下：</p>

<pre><code>sed options script file
</code></pre>

<p>options选项允许修改sed命令的行为，可使用的选项见下表：</p>

<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-e script</td>
<td>在处理输入时，将script中指定的命令添加到已有的命令中</td>
</tr>

<tr>
<td>-f file</td>
<td>在处理输入时，将file中指定的命令添加到已有的命令中</td>
</tr>

<tr>
<td>-n</td>
<td>不产生命令输出，使用print命令来完成输出</td>
</tr>
</tbody>
</table>

<h5 id="在命令行定义编辑器命令">在命令行定义编辑器命令</h5>

<p>简单示例，将输入流中的test修改成big test，示例：</p>

<pre><code>echo &quot;This is a test&quot; | sed 's/test/big test/'
</code></pre>

<p>上述例子使用了s命令，该命令会用斜线间指定的第二个文本字符串来替换第一个文本字符串。</p>

<p>对整个文件执行sed命令的例子：</p>

<pre><code>sed 's/dog/cat/' data1.txt
</code></pre>

<h5 id="在命令行使用多个编辑器命令">在命令行使用多个编辑器命令</h5>

<p>要在sed命令行上执行多个命令时，只要用-e选项即可，命令间需要用分号隔开，示例：</p>

<pre><code>sed -e 's/brown/green/; s/dog/cat/' data1.txt
</code></pre>

<p>如果不想用分号，也可以使用bash
shell中的次提示符来分隔命令。只要输入第一个单引号标示出sed程序的起始，bash会继续提示你输入更多命令，直到输入了标示结束的单引号。</p>

<h5 id="从文件中读取编辑器命令">从文件中读取编辑器命令</h5>

<p>如果有大量要处理的sed命令，可以将它们放进一个单独的文件中更方便一些，可以使用-f选项来指定文件，例子如下：</p>

<pre><code>cat script1.sed
s/brown/green/
s/fox/elephant/
s/dog/cat/

sed -f script1.sed data1.txt
</code></pre>

<h4 id="gawk程序">gawk程序</h4>

<p>gawk让流编辑迈上了一个新的台阶，它提供了一种编程语言而不只是编辑器命令，在gawk编程语言中，你可以做下面的事情：</p>

<pre><code>定义变量来保存数据
使用算术和字符串操作符来处理数据
使用结构化编程概念（比如if-then语句和循环）来为数据处理增加处理逻辑
通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告
</code></pre>

<h5 id="gawk命令格式">gawk命令格式</h5>

<p>基本格式如下：</p>

<pre><code>gawk options program file
</code></pre>

<p>可用选项如下表：</p>

<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-F fs</td>
<td>指定行中划分数据字段的字段分隔符</td>
</tr>

<tr>
<td>-f file</td>
<td>从指定的文件中读取程序</td>
</tr>

<tr>
<td>-v var=value</td>
<td>定义gawk程序中的一个变量及其默认值</td>
</tr>

<tr>
<td>-mf N</td>
<td>指定要处理的数据文件中的最大字段数</td>
</tr>

<tr>
<td>-mr N</td>
<td>指定数据文件中最大数据行数</td>
</tr>

<tr>
<td>-W keyword</td>
<td>指定gawk的兼容模式或警告登记</td>
</tr>
</tbody>
</table>

<h5 id="从命令行读取程序脚本">从命令行读取程序脚本</h5>

<p>gawk程序脚本用一对花括号来定义，并且还必须将脚本放在单引号中，示例：</p>

<pre><code>gawk '{print &quot;Hello world&quot;}'
</code></pre>

<p>执行这个命令后，无论在命令行输入什么，都会输出Hello world，停止程序需要使用Ctrl+D来生成一个EOF字符</p>

<h5 id="使用数据字段变量">使用数据字段变量</h5>

<p>gawk会自动给一行中的每个数据元素分配一个变量：</p>

<pre><code>$0代表整个文本行
$1代表文本行中的第1个数据字段
$2代表文本行中的第2个数据字段
$n代表文本行中的第n个数据字段
</code></pre>

<p>gawk在读取一行文本时，默认的字段分隔符是任意的空白字符（空格或制表符等），示例：</p>

<pre><code>gawk '{print $1}' data2.txt
</code></pre>

<p>上例子会读取data2.txt文件每行的第一个单词</p>

<p>可以使用-F选项指定分隔符，例如指定冒号为分隔符，示例：</p>

<pre><code>gawk -F: '{print $1}' /etc/passwd
</code></pre>

<h5 id="在程序脚本中使用多个命令">在程序脚本中使用多个命令</h5>

<p>要在命令行上的程序脚本中使用多条命令，只要在命令之间放歌分号即可，示例：</p>

<pre><code>echo &quot;My name is Rich&quot; | gawk '{$4=&quot;Christine&quot;; print $0}'
</code></pre>

<h5 id="从文件中读取程序">从文件中读取程序</h5>

<p>和sed一样，gawk也可以将程序存储到文件中，在命令行引用，示例：</p>

<pre><code>cat script2.gawk
{
text = &quot;'s home directory is &quot;
print $1 text $6
}

gawk -F: -f script2.gawk /etc/passwd
</code></pre>

<p>另外，上例子使用了变量来存放字符串，而引用时并未像shell脚本一样使用美元符。</p>

<h5 id="在处理数据前运行脚本">在处理数据前运行脚本</h5>

<p>可以使用BEGIN指定读取数据前预先执行的脚本，示例如下：</p>

<pre><code>gawk 'BEGIN {print &quot;The data3 File Contents:&quot;}{print $0}' data3.txt
</code></pre>

<p>上例第一段代码块在读取文件前执行，第二段代码块在读取每一行数据时执行</p>

<h5 id="在处理数据后运行脚本">在处理数据后运行脚本</h5>

<p>和BEGIN关键字类似，END关键字指定在读完数据后执行的脚本，示例如下：</p>

<pre><code>gawk 'BEGIN {print &quot;Start of File&quot;}
{print $0}
END {print &quot;End of File&quot;}' data3.text
</code></pre>

<h3 id="sed编辑器基础">sed编辑器基础</h3>

<h4 id="更多的替换选项">更多的替换选项</h4>

<h5 id="替换标记">替换标记</h5>

<p>替换命令默认情况下只会替换每行中出现的第一处，要让其可以替换一行中不同地方的文本需要使用替换标记，格式如下：</p>

<pre><code>s/pattern/replacement/flags
有四种可用的替换标记（flag）：
数字，表示替换匹配到的第几处
g，表明替换所有匹配的文本
p，打印出来
w file,将替换的结果写到文件中
</code></pre>

<p>举例如下：</p>

<pre><code>sed 's/test/trial/2' data4.txt          将data4.txt的第二个test字符串替换成trial
sed 's/test/trial/g' data4.txt          将data4.txt的所有test都替换成trial
sed -n 's/test/trial/p' data4.txt       这将会只输出被修改过的行，因为-n将禁止sed编辑器输出，但p会输出修改过的行
sed 's/test/trial/w test.txt' data5.txt 将会把修改过的行保存在test.txt文件中
</code></pre>

<h5 id="替换命令中的字符串分隔符">替换命令中的字符串分隔符</h5>

<p>如果文本中本身包含正斜线，则命令会很混乱，因为命令的字符串间的分隔符也是正斜线，我们可以更改命令中的分隔符，比如改成！，示例如下：</p>

<pre><code>sed 's!/bin/bash!/bin/csh!' /etc/passwd
</code></pre>

<h4 id="使用地址">使用地址</h4>

<p>sed命令默认作用于文本的所有行，如果只想作用于某些特定行货某些行，则必须使用行寻址，行寻址有两种：以数字形式表示行区间；用文本模式过滤。两种模式都使用相同的格式来指定地址：</p>

<pre><code>[address]command
</code></pre>

<p>也可以将特定地址的多个命令分组：</p>

<pre><code>address {
    command1
    command2
    ...
}
</code></pre>

<h5 id="数字方式的行寻址">数字方式的行寻址</h5>

<p>sed会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号，示例：</p>

<pre><code>sed '2s/dog/cat/' data1.txt          修改第二行
sed '2,3s/dog/cat/' data1.txt        修改第二行至第三行
sed '2,$s/dog/cat/' data1.txt       修改第二行到最后一行，美元符用来代表到最后一行
</code></pre>

<h5 id="使用文本模式过滤器">使用文本模式过滤器</h5>

<p>必须用正斜线将要知道的正则表达式pattern封起来，格式如下：</p>

<pre><code>/pattern/command
</code></pre>

<p>示例：</p>

<pre><code>sed '/Samantha/s/bash/csh/' /etc/passwd     把包含Samantha的行的bash改成csh
</code></pre>

<h5 id="命令组合">命令组合</h5>

<p>如果需要执行多条命令，可以用花括号将多条命令扩起来，示例：</p>

<pre><code>sed '3,${
s/brown/green/
s/lazy/active/
}' data1.txt
</code></pre>

<h4 id="删除行">删除行</h4>

<p>删除行可以使用d命令，示例如下：</p>

<pre><code>sed 'd' data1.txt       全部删除
sed '3d' data1.txt      删除第三行
sed '2,3d' data1.txt    删除第二行到第三行
sed '2,$d' data1.txt    删除第二行到最后一行
sed '/number/d' data1.txt   删除包含number字符串的行
</code></pre>

<p>也可以使用两个文本模式来删除某个区间内的行，第一次匹配到第一个模式时会打卡删除功能，直到匹配到第二个模式才关闭删除功能，如果后续的行再次匹配到第一个模式，则会再次打卡删除功能，直到再匹配到第二个模式才会关闭，示例如下：</p>

<pre><code>例如我们有一个文件data3.txt如下：
line 1
line 2
line 3
line 4
line 5
line 1
line 2
line 6
然后我们使用命令：
sed '/1/,/3/d' data3.txt
输出如下：
line 4
line 5
因为第一行满足了第一个模式，打开了删除功能，一直删除到第三行，满足了第二个模式于是关闭了删除功能，第4、5行正常输出，第六行又满足了第一个模式，于是打开了删除功能，直到文本结束都没有满足第二个模式，所以后续的行全部被删除。
</code></pre>

<h4 id="插入和附加文本">插入和附加文本</h4>

<p>插入和附加的区别：</p>

<pre><code>插入（insert）命令（i）会在指定行前增加一个新行
附加（append）命令（a）会在指定行后增加一个新行
</code></pre>

<p>命令格式如下：</p>

<pre><code>sed '[address]command\new line'
</code></pre>

<p>示例如下：</p>

<pre><code>echo &quot;Test line 2&quot; | sed 'i\Test line 1'  在给定行(Test line 2)的前面加入新行Test line 1
echo &quot;Test line 2&quot; | sed 'a\Test line 1'  在给定行的后面加入新行
sed '3i\this is an inserted line.' data5.txt 在给定文件的第三行前插入新行
sed '3a\this is an appended line.' data5.txt 在给定文件的第三行后加入新行
sed '$a\this is an appended line.' data5.txt 在给定文件的最后加入新行
sed '1i\this is an inserted line.' data5.txt 在给定文件的最开始插入新行
</code></pre>

<p>再提示一下，sed所有操作不会作用于原始文本，只会作用于输出</p>

<h4 id="修改行">修改行</h4>

<p>修改（change）命令（c）允许修改数据流中整行文本的内容，它和插入、附加命令的机制一样，必须在sed命令中指定新行，示例如下：</p>

<pre><code>sed '3c\this is a changed line of text.' data.txt   修改data.txt文件的第三行为指定的行
sed '/number/c\this is a changed line of text.' data.txt    修改匹配到numbe的行为指定的行
sed '2,3c\this is a new line of text.' data.txt     将第二行至第三行删除掉，替换成给定的一行（注意不会生成多个指定的行，而只会有一个）
</code></pre>

<h4 id="转换命令">转换命令</h4>

<p>转换命令（y）是唯一可以处理单个字符的sed编辑器命令，格式如下：</p>

<pre><code>[address]y/inchars/outchars/
</code></pre>

<p>转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转换成outchars中的第一个字符，inchars中的第2个字符会被转换成outchars中的第2个字符，这个过程一直持续到处理完所有映射。使用示例：</p>

<pre><code>sed 'y/123/789/' data.txt 把所有1改成7，所有2改成8，所有3改成9
</code></pre>

<h4 id="回顾打印">回顾打印</h4>

<p>还有3个命令可以用来打印数据流中的信息：</p>

<pre><code>p命令用来打印文本行
等号（=）用来打印行号
l（小写的L）命令用来列出行
</code></pre>

<p>示例：</p>

<pre><code>sed -n '/number/p' data.txt     配合-n，只打印有number的行
sed -n '2,3p' data.txt  配合-n，只打印2~3行的数据
sed '=' data.txt 打印data.txt每一行前打印行号
sed -n 'l' data.txt 可以打印出数据流中的文本和不可打印的ASCII字符（例如\t，转义字符等）
</code></pre>

<h4 id="使用sed处理文件">使用sed处理文件</h4>

<h5 id="写入文件">写入文件</h5>

<p>格式如下：</p>

<pre><code>[address]w filename
</code></pre>

<p>示例：</p>

<pre><code>sed '1,2w test.text' data.txt 将data.txt文件中的1~2行数据写入test.test文件中
</code></pre>

<h5 id="从文件中读取-1">从文件中读取</h5>

<p>读取命令（r）允许将一根独立文件中的数据插入到数据流中，格式如下：</p>

<pre><code>[address]r filename
</code></pre>

<p>示例：</p>

<pre><code>sed '3r data1.txt' data2.txt 在读到data2.txt的第三行后，插入data1.txt的所有内容，再继续读data2.txt的内容
</code></pre>

<h2 id="第二十章-正则表达式">第二十章、正则表达式</h2>

<h3 id="正则表达式类型">正则表达式类型</h3>

<p>Linux中有两种正则表达式类型：</p>

<pre><code>POSIX基础正则表达式（basic regular expression, BRE）引擎
POSIX扩展正则表达式（extended regular expression，ERE）引擎
</code></pre>

<p>其中，sed使用BRE，gawk使用ERE</p>

<h3 id="bre模式">BRE模式</h3>

<p>数字、英文字母等非特殊字符都是纯文本，区分大小写。特殊字符需要用反斜杠转义</p>

<h4 id="锚字符">锚字符</h4>

<h5 id="锁定行首">锁定行首</h5>

<p>^ 以^开始的正则表达式必须匹配在行首,例如：</p>

<pre><code>sed -n '/^book/p' 匹配以book开始的行
</code></pre>

<h5 id="锁定行尾">锁定行尾</h5>

<p>以 结尾的正则表达式必须匹配在行尾，例如：</p>

<pre><code>sed -n '/book$/p' 匹配以book结束的行
</code></pre>

<h5 id="组合锚点">组合锚点</h5>

<p>组合以^开始以$结尾的正则表达式必须恰好匹配整行，例如：</p>

<pre><code>sed -n '/^this is a test$/p' data4.txt  匹配文本中内容恰好是this is a test的行
</code></pre>

<h4 id="点号字符">点号字符</h4>

<p>. 特殊字符点号用来匹配除换行外的任意单个字符，例如：</p>

<pre><code>sed -n '/.at/p' data6.txt   匹配data6.txt中所有包含【例如cat，hat，eat等以at结尾的模式】的行
</code></pre>

<h4 id="字符组">字符组</h4>

<p>使用方括号来定义一个字符组，使用中只要字符组中的任意一个字符匹配即可，例如：</p>

<pre><code>sed -n '/[ch]at/p' data.txt 匹配data.txt中所有包含cat或hat的行
</code></pre>

<h4 id="排除型字符组">排除型字符组</h4>

<p>脱字符^可以翻转字符组的作用，即寻找组中没有的字符，而不是去寻找组中有的字符，例如：</p>

<pre><code>sed -n '/[^ch]at/p' data.txt    匹配data.txt中所有不包含cat不包含hat的行
</code></pre>

<h4 id="区间">区间</h4>

<p>字符组中冶可以使用区间，只需要指定区间的第一个字符、单破折号以及区间的最后一个字符，例如：</p>

<pre><code>[0-9]   匹配0~9区间中的数字
[a-z]   匹配a~z区间中的字母
[a-ch-m] 匹配a~c区间的字母或h~m区间的字母
</code></pre>

<h4 id="特殊字符组">特殊字符组</h4>

<p>BRE还包含了一些特殊的字符组，可以匹配特定类型的字符，列举如下：</p>

<table>
<thead>
<tr>
<th>组</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>[[:alpha:]]</td>
<td>匹配任意字母字符，不管是大写还是小写</td>
</tr>

<tr>
<td>[[:alnum:]]</td>
<td>匹配任意字母或数字字符</td>
</tr>

<tr>
<td>[[:blank:]]</td>
<td>匹配空格或制表符</td>
</tr>

<tr>
<td>[[:digit:]]</td>
<td>匹配0~9直接的数字</td>
</tr>

<tr>
<td>[[:lower:]]</td>
<td>匹配小写字母字符</td>
</tr>

<tr>
<td>[[:print:]]</td>
<td>匹配任意可打印字符</td>
</tr>

<tr>
<td>[[:punct:]]</td>
<td>匹配标点符号</td>
</tr>

<tr>
<td>[[:space:]]</td>
<td>匹配任意空白字符：空格、制表符、NL、FF、VT和CR</td>
</tr>

<tr>
<td>[[:upper:]]</td>
<td>匹配任意大写字母字符</td>
</tr>
</tbody>
</table>

<h4 id="星号">星号</h4>

<p>星号表示该字符在匹配模式的文本中出现0次或多次</p>

<h3 id="ere-扩展正则表达式">ERE 扩展正则表达式</h3>

<h4 id="问号">问号</h4>

<p>前面的字符出现0次或1次</p>

<h4 id="加号">加号</h4>

<p>前面的字符出现1次或多次</p>

<h4 id="使用花括号">使用花括号</h4>

<p>ERE中的花括号允许为可重复的正则表达式指定一个上限。通常称为间隔（interval）。可以用两种格式来指定区间：</p>

<pre><code>m: 正则表达式准确出现m次
m，n：正则表达式至少出现m次，至多n次
</code></pre>

<p>示例：</p>

<pre><code>echo &quot;bet&quot; | gawk --re-interval '/be{1}t/{print $0}'    匹配bet；gawk必须使用--re-interval才可以支持花括号的模式
echo &quot;bet&quot; | gawk --re-interval '/be{1,2}t/{print $0}'    匹配bet或beet；gawk必须使用--re-interval才可以支持花括号的模式
</code></pre>

<h4 id="管道符号">管道符号</h4>

<p>管道符号可以在检查数据流时用逻辑OR的方式指定正则表达式引擎要用的多个模式，如果任何一个模式匹配，文本就通过测试，示例如下：</p>

<pre><code>echo &quot;The cat is asleep&quot; | gawk '/cat|dog/{print $0}'       匹配cat模式或dog模式
</code></pre>

<h4 id="表达式分组">表达式分组</h4>

<p>正则表达式模式也可以用圆括号进行分组。将正则表达式模式分组时，该组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符，例如：</p>

<pre><code>echo &quot;Sat&quot; | gawk '/Sat(urday)?/{print $0}'   会将urday当做一个字符来使用特殊字符？，即urday出现0次或1次，也就是匹配Sat或Saturday
</code></pre>

<h2 id="第二十一章-sed进阶">第二十一章、sed进阶</h2>

<h3 id="多行命令">多行命令</h3>

<p>所有的sed编辑器命令都是针对单行数据执行操作的。sed编辑器包含了三个可用来处理多行文本的特殊命令：</p>

<pre><code>N:将数据流中的下一行加进来创建一个多行组来处理
D:删除多行组中的一行
P:打印多行组中的一行
</code></pre>

<h4 id="next-命令">next 命令</h4>

<h5 id="单行的next命令">单行的next命令</h5>

<p>小写的n命令会告诉sed编辑器移动到数据流中的下一行文本，例如：</p>

<pre><code>sed '/header/{n ; d}' data.txt  查找含有单词header的那行，找到之后，n命令会让sed编辑器移动到文本的下一行，然后删除那一行。也就是说这个命令删除包含header那行的下一行数据
</code></pre>

<h5 id="合并文本行">合并文本行</h5>

<p>单行next命令会将数据流中的下一文本行移动到sed编辑器的工作空间（称为模式空间）。多行版本的next命令（N）会将下一文本行添加到模式空间中已有的文本后。这样的作用是将数据流中的两个文本行合并到同一个模式空间中。示例：</p>

<pre><code>sed '/first/{ N ; s/\n/ / }' data2.txt 查找含有first的哪行文本，找到后，用N命令将下一行合并到那行，然后用替换命令s将换行符替换成为空格。
</code></pre>

<p>另一个例子：</p>

<pre><code>sed 'N ; s/system.administrator/desktop user/' data.txt 替换命令在system和administrator之间使用了通配符模式（.）来匹配空格和换行符
</code></pre>

<p>上面例子中，当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫sed编辑器停止。要解决这个办法，可以将单行命令放到N命令前面，并将多行命令放到N命令后面，例如：</p>

<pre><code>sed '
s/system administrator/desktop user/
N
s/system\nadministrator/desktop\nuser/
' data4.txt
</code></pre>

<h4 id="多行删除命令">多行删除命令</h4>

<pre><code>sed 'N ; /systme\n/administrator/d' data4.txt   删除命令会在不同的行中查找单词System和administrator，然后再模式空间中将两行都删掉。
</code></pre>

<p>sed为编辑器提供了多行删除命令D，它只删除模式空间中的第一行，例如：</p>

<pre><code>sed 'N ; /systme\n/administrator/D' data4.txt   删除命令会在不同的行中查找单词System和administrator，然后再模式空间中删除第一行。
</code></pre>

<h4 id="多行打印命令">多行打印命令</h4>

<p>多行打印命令（P)沿用了同样的方法。它只打印多行模式空间中的第一行。这包括模式空间中直到换行符为止的所有字符。例如：</p>

<pre><code>sed -n 'N ; /System\nAdministrator/P' data3.txt     当多行匹配出现时，P命令只会打印模式空间中的第一行
</code></pre>

<h3 id="保持空间">保持空间</h3>

<p>模式空间（pattern
space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检测的文本。但它并不是sed编辑器保存文本的唯一空间。sed编辑器有另一块称作保持空间（hold
space）的缓冲区域。在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。有5条命令可用来操作保持空间，见下表：</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>h</td>
<td>将模式空间复制到保持空间</td>
</tr>

<tr>
<td>H</td>
<td>将模式空间附加到保持空间</td>
</tr>

<tr>
<td>g</td>
<td>将保持空间复制到模式空间</td>
</tr>

<tr>
<td>G</td>
<td>将保持空间附加到模式空间</td>
</tr>

<tr>
<td>x</td>
<td>交换模式空间和保持空间的内容</td>
</tr>
</tbody>
</table>

<p>给出一个例子，有文件data2.txt:</p>

<pre><code>This is the header line.
this is the first data line.
this is the second data line.
this is the last line.
</code></pre>

<p>使用命令：</p>

<pre><code>sed -n '/first/ {h ; p ; n ; p ; g ; p}'
</code></pre>

<p>输出为：</p>

<pre><code>this is the first data line.
this is the second data line.
this is the first data line.
</code></pre>

<p>具体过程为，将含有first的行用h命令放到保持空间，并打印该行，读取下一行并打印，用g命令取回保持空间的行并打印</p>

<h3 id="排除命令">排除命令</h3>

<p>感叹号命令（!）用来排除命令，也就是让原本会起作用的命令不起作用。例如：</p>

<pre><code>sed -n '/header/!p' data2.txt   除了包含header那一行外，文件中其他所有的行都被打印出来了
</code></pre>

<p>倒序打印文件的例子：</p>

<pre><code>sed -n '{1!G ; h ; $p }' data2.txt  如果不是第一行，则把保持空间的内容追加到模式空间，然后将模式空间内容保存到保持空间，如果是最后一行，则输出模式空间
</code></pre>

<h3 id="改变流">改变流</h3>

<h4 id="分支">分支</h4>

<p>sed编辑器提供了一种方法，可以基于地址、地址模式或地址区间排除一整块命令。这允许你只对数据流中的特定行执行一组命令。</p>

<p>分支（branch）命令b的格式如下：</p>

<pre><code>[address]b [label]
</code></pre>

<p>address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如果没有加label参数，跳转命令会跳转到脚本的结尾。示例：</p>

<pre><code>sed '{2,3b ; s/This is /Is this/ ; s/line./test?/}' data2.txt   分支命令在数据流中的第二行和第三行处跳过了两个替换命令
</code></pre>

<p>带有label的例子：</p>

<pre><code>sed '{/first/b jump1 ; s/This is the/No jump on/
:jump1
s/This is the/Jump here on/}' data2.txt
</code></pre>

<p>上例中跳转命令指定如果文本行中出现了first，程序应该调到标签为jump1的脚本行。</p>

<p>再来一个循环的例子，这个例子循环地删除句子中的逗号：</p>

<pre><code>echo &quot;this, is, a, test, to, remove, commas.&quot; | sed -n '{
:start
s/,//1p
b start
}'
</code></pre>

<p>这个例子每次迭代都会删除文本中的一个逗号，并打印字符串，但是这个例子不会结束，因为他一直在循环。</p>

<h4 id="测试">测试</h4>

<p>测试（test）命令（t）会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令未能匹配指定的模式，测试命令就不会跳转，格式如下：</p>

<pre><code>[address]t [label]
</code></pre>

<p>例子如下：</p>

<pre><code>sed '{
s/first/matched/
t
s/this is the/no match on/
}' data2.txt
</code></pre>

<p>第一个替换命令会查找模式文本first。如果匹配了并且替换了文本，测试命令会跳过后续的替换命令。</p>

<p>上一节会无限循环的例子可以使用测试来使其能够退出：</p>

<pre><code>echo &quot;this, is, a, test, to, remove, commas.&quot; | sed -n '{
:start
s/,//1p
t start
}'
</code></pre>

<h3 id="模式替代">模式替代</h3>

<h4 id="符号">&amp;符号</h4>

<p>&amp;符号可以用来替换命令行中的匹配的模式，例如：</p>

<pre><code>echo &quot;the cat sleeps in his hat.&quot; | sed 's/.at/&quot;&amp;&quot;/g'
输出为：
the &quot;cat&quot; sleeps in his &quot;hat&quot;.
</code></pre>

<h4 id="替代单独的单词">替代单独的单词</h4>

<p>&amp;会提前模式匹配到的整个字符串，有时我们只想提取这个字符串的一部分。</p>

<p>sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成。数字说明子模式的位置。sed编辑器会给第一个子模式分配字符\1，给第二个子模式分配字符\2，依次类推。</p>

<pre><code>当在替换命令中使用圆括号时，必须用转义字符将它们表示为分组字符而不是普通的圆括号。这跟转义其他特殊字符正好相反。
</code></pre>

<p>例子：</p>

<pre><code>echo &quot;the system administrator mannul&quot; | sed '
s/\(system\) administrator/\1 user/'
输出：
the system user mannul
</code></pre>

<p>这个替换命令用一对圆括号将单词system扩起来，将其表示为一个子模式。然后再替代模式中使用\1来提取第一个匹配的子模式。</p>

<h3 id="创建sed实用工具">创建sed实用工具</h3>

<h4 id="加倍行间距">加倍行间距</h4>

<pre><code>sed 'G' /etc/passwd 加倍行间距
sed '$!G' /etc/passwd 除最后一行外，加倍行间距
</code></pre>

<p>G命令会简单地将保持空间内容附加到模式空间内容后。当启动sed编辑器时，保持空间只有一个空行。</p>

<h4 id="对可能含有空白行的文件加倍行间距">对可能含有空白行的文件加倍行间距</h4>

<pre><code>sed '/^$/d ; $!G' /etc/passwd 在上一个例子的基础上，增加了删除空白行/^$/d
</code></pre>

<h4 id="给文件中的行编号">给文件中的行编号</h4>

<pre><code>sed '=' /etc/passwd | sed 'N; s/\n/ /'
</code></pre>

<p>有些bash shell命令也可以添加行号，例如：</p>

<pre><code>nl /etc/passwd
cat -n /etc/passwd
</code></pre>

<h4 id="打印末尾行">打印末尾行</h4>

<pre><code>sed -n '$p' /etc/passwd
</code></pre>

<p>下面是输出末尾10行的例子：</p>

<pre><code>sed '{
:start
$q ; N ; 11,$D
b start
}' /etc/passwd
</code></pre>

<p>这个脚本首先检查这行是不是数据流中最后一行，如果是，退出循环。N命令将下一行附加到模式空间中当前行之后。如果当前行在第10行后面，11,$D命令会删除模式空间中的第一行。这就会在模式空间中创建出滑动窗口效果。因此这个程序只显示最后10行。</p>

<h4 id="删除行-1">删除行</h4>

<h5 id="删除连续的空白行">删除连续的空白行</h5>

<pre><code>sed '/./,/^$/!d' data.txt   区间是/./到/^$/。区间的开始地址会匹配任何含有至少一个字符的行。区间的结束地址会匹配一个空行。在这个区间内的行不会被删除。
</code></pre>

<h5 id="删除开头的空白行">删除开头的空白行</h5>

<pre><code>sed '/./,$!d' data.txt    这个区间从含有字符的行开始，一直到数据流结束。在这个区间内的任何行都不会从输出中删除
</code></pre>

<h5 id="删除结尾的空白行">删除结尾的空白行</h5>

<pre><code>sed '{
:start
/^\n*$/{$d; N; b start }
}' test.log
</code></pre>

<p>在正常的花括号里还有花括号。这允许你在整个命令脚本中将一些命令分组。地址模式匹配只含有换行符的行。如果找到了这样的行，而且还是最后一行，删除命令会删掉它，如果不是最后一行，N命令将下一行附加到它后面，分支命令会调到循环起始位置重新开始。</p>

<h4 id="删除html标签">删除HTML标签</h4>

<pre><code>sed 's/]*&gt;//g ; /^$/d' data.txt
</code></pre>

<h2 id="gawk进阶">gawk进阶</h2>

<h3 id="使用变量-1">使用变量</h3>

<p>gawk编程语言支持两种不同类型的变量：内建变量 ;自定义变量</p>

<h4 id="内建变量">内建变量</h4>

<p>gawk程序使用内建变量来引用程序数据里的一些特殊功能。</p>

<h5 id="字段和记录分隔符变量">字段和记录分隔符变量</h5>

<p>数据字段变量。数据字段变量允许你使用美元符号（ ）和字段在该记录中的位置值来引用记录对应的字段。因此，要引用记录中的第一个数据字段，就用变量
1；要引用第二个字段，就用$2，依次类推。</p>

<p>数据字段是由字段分隔符来划定的。默认情况下，字段分隔符是一个空白字符，也就是空格符或者制表符。</p>

<p>下面这组变量用于控制gawk如何处理输入输出数据中的字段和记录：</p>

<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>FIELDWIDTHS</td>
<td>由空格分隔的一列数字，定义了每个数据字段确切宽度</td>
</tr>

<tr>
<td>FS</td>
<td>输入字段分隔符</td>
</tr>

<tr>
<td>RS</td>
<td>输入记录分隔符</td>
</tr>

<tr>
<td>OFS</td>
<td>输出字段分隔符</td>
</tr>

<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
</tbody>
</table>

<p>默认情况下，gawk将OFS 设成一个空格，例如：</p>

<pre><code>$ cat data1 
data11,data12,data13,data14,data15 
data21,data22,data23,data24,data25 
data31,data32,data33,data34,data35 
$ gawk 'BEGIN{FS=&quot;,&quot;} {print $1,$2,$3}' data1 
data11 data12 data13 
data21 data22 data23 
data31 data32 data33
</code></pre>

<p>可以修改OFS，例如：</p>

<pre><code>$ gawk 'BEGIN{FS=&quot;,&quot;; OFS=&quot;-&quot;} {print $1,$2,$3}' data1 
data11-data12-data13 
data21-data22-data23 
</code></pre>

<p>一旦设置了FIELDWIDTH变量，gawk就会忽略FS变量，并根据提供的字段宽度来计算字段。例如：</p>

<pre><code>$ cat data1b 
1005.3247596.37 
115-2.349194.00 
05810.1298100.1 
$ gawk 'BEGIN{FIELDWIDTHS=&quot;3 5 2 5&quot;}{print $1,$2,$3,$4}' data1b 
100 5.324 75 96.37 
115 -2.34 91 94.00 
058 10.12 98 100.1
</code></pre>

<p>一旦设定了FIELDWIDTHS 变量的值，就不能再改变了。这种方法并不适用于变长的字段。</p>

<h5 id="数据变量">数据变量</h5>

<p>gawk中的其他内建变量：</p>

<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>ARGC</td>
<td>当前命令行参数个数</td>
</tr>

<tr>
<td>ARGIND</td>
<td>当前文件在ARGV中的位置</td>
</tr>

<tr>
<td>ARGV</td>
<td>包含命令行参数的数组</td>
</tr>

<tr>
<td>CONVFMT</td>
<td>数字的转换格式（参见printf语句），默认值为%.6 g</td>
</tr>

<tr>
<td>ENVIRON</td>
<td>当前shell 环境变量及其值组成的关联数组</td>
</tr>

<tr>
<td>ERRNO</td>
<td>当读取或关闭输入文件发生错误时的系统错误号</td>
</tr>

<tr>
<td>FILENAME</td>
<td>用作gawk输入数据的数据文件的文件名</td>
</tr>

<tr>
<td>FNR</td>
<td>当前数据文件中的数据行数</td>
</tr>

<tr>
<td>IGNORECASE</td>
<td>设成非零值时，忽略gawk命令中出现的字符串的字符大小写</td>
</tr>

<tr>
<td>NF</td>
<td>数据文件中的字段总数</td>
</tr>

<tr>
<td>NR</td>
<td>已处理的输入记录数</td>
</tr>

<tr>
<td>OFMT</td>
<td>数字的输出格式，默认值为%.6 g</td>
</tr>

<tr>
<td>RLENGTH</td>
<td>由match 函数所匹配的子字符串的长度</td>
</tr>

<tr>
<td>RSTART</td>
<td>由match 函数所匹配的子字符串的起始位置</td>
</tr>
</tbody>
</table>

<h4 id="自定义变量">自定义变量</h4>

<p>gawk自定义变量名可以是任意数目的字母、数字和下划线，但不能以数字开头。重要的是，要记住gawk变量名区分大小写。</p>

<h5 id="在脚本中给变量赋值">在脚本中给变量赋值</h5>

<pre><code>$ gawk ' 
&gt; BEGIN{ 
&gt; testing=&quot;This is a test&quot; 
&gt; print testing 
&gt; }'
</code></pre>

<p>赋值语句还可以包含数学算式来处理数字值,例如：</p>

<pre><code>gawk 'BEGIN{x=4; x= x * 2 + 3; print x}' 
</code></pre>

<h5 id="在命令行上给变量赋值">在命令行上给变量赋值</h5>

<pre><code>$ cat script1 
BEGIN{FS=&quot;,&quot;} 
{print $n} 
$ gawk -f script1 n=2 data1 
data12 
data22 
data32 
$ gawk -f script1 n=3 data1 
data13 
data23 
data33
</code></pre>

<p>使用命令行参数来定义变量值会有一个问题。在你设置了变量后，这个值在代码的BEGIN部分不可用。可以用-v命令行参数来解决这个问题。它允许你在BEGIN
代码之前设定变量，例如：</p>

<pre><code>gawk -v n=3 -f script2 data1
</code></pre>

<h3 id="处理数组">处理数组</h3>

<p>gawk编程语言使用关联数组提供数组功能。
关联数组跟数字数组不同之处在于它的索引值可以是任意文本字符串。如果你熟悉其他编程语言的话，就知道这跟散列表和字典是同一个概念。</p>

<h4 id="定义数组变量">定义数组变量</h4>

<p>数组变量赋值的格式如下：</p>

<pre><code>var[index] = element
</code></pre>

<p>其中var 是变量名，index是关联数组的索引值，element是数据元素值。下面是一些gawk中数组变量的例子：</p>

<pre><code>capital[&quot;Illinois&quot;] = &quot;Springfield&quot; 
capital[&quot;Indiana&quot;] = &quot;Indianapolis&quot;
</code></pre>

<p>引用数组变量例子：</p>

<pre><code>$ gawk 'BEGIN{ 
&gt; capital[&quot;Illinois&quot;] = &quot;Springfield&quot; 
&gt; print capital[&quot;Illinois&quot;] 
&gt; }'
</code></pre>

<h4 id="遍历数组变量">遍历数组变量</h4>

<pre><code>for (var in array) 
{ 
  statements 
} 
</code></pre>

<h4 id="删除数组变量">删除数组变量</h4>

<p>格式如下：</p>

<pre><code>delete array[ index] 
</code></pre>

<p>例如：</p>

<pre><code>delete var[&quot;g&quot;]
</code></pre>

<h3 id="使用模式">使用模式</h3>

<h4 id="正则表达式">正则表达式</h4>

<p>在使用正则表达式时，正则表达式必须出现在它要控制的程序脚本的左花括号前，例如：</p>

<pre><code>gawk 'BEGIN{FS=&quot;,&quot;} /11/{print $1}' data1
</code></pre>

<h4 id="匹配操作符">匹配操作符</h4>

<p>匹配操作符（matching operator）允许将正则表达式限定在记录中的特定数据字段。匹配操作符是波浪线（~）。示例如下：</p>

<pre><code>gawk 'BEGIN{FS=&quot;,&quot;} $2 ~ /^data2/{print $0}' data1
</code></pre>

<p>上例中，匹配操作符会用正则表达式/^data2/ 来比较第二个数据字段，该正则表达式指明字符串要以文本data2开头。</p>

<p>你也可以用!符号来排除正则表达式的匹配，例如：</p>

<pre><code>gawk –F: '$1 !~ /rich/{print $1,$NF}' /etc/passwd
</code></pre>

<h4 id="数学表达式">数学表达式</h4>

<p>除了正则表达式，你也可以在匹配模式中用数学表达式，例如：</p>

<pre><code>gawk -F: '$4 == 0{print $1}' /etc/passwd 
</code></pre>

<p>可以使用任何常见的数学比较表达式：</p>

<pre><code>x == y ：值x等于y。 
x &lt;= y ：值x小于等于y。 
x &lt; y：值x小于y。 
x &gt;= y ：值x大于等于y。 
x &gt; y：值x大于y。 
</code></pre>

<p>也可以对文本数据使用表达式，但必须小心。跟正则表达式不同，表达式必须完全匹配。</p>

<h3 id="结构化命令">结构化命令</h3>

<h4 id="if语句">if语句</h4>

<p>你必须为if语句定义一个求值的条件，并将其用圆括号括起来。格式如下：</p>

<pre><code>if (condition) 
statement1 
</code></pre>

<p>或者也可以使用一行，例如：</p>

<pre><code>if (condition) statement1 
</code></pre>

<p>示例如下：</p>

<pre><code>gawk '{if ($1 &gt; 20) print $1}' data4
</code></pre>

<p>如果需要在if语句中执行多条语句，就必须用花括号将它们括起来。并且支持else语句，示例如下：</p>

<pre><code>$ gawk '{ 
&gt; if ($1 &gt; 20) 
&gt; { 
&gt;    x = $1 * 2 
&gt;    print x 
&gt; } else 
&gt; { 
&gt;    x = $1 / 2 
&gt;    print x 
&gt; }}' data4
</code></pre>

<p>可以在单行上使用else子句，但必须在if语句部分之后使用分号，格式如下：</p>

<pre><code>if (condition) statement1; else statement2 
</code></pre>

<h4 id="while-语句">while 语句</h4>

<pre><code>while (condition) 
{ 
  statements 
}
</code></pre>

<p>gawk编程语言支持在while 循环中使用break语句和continue 语句</p>

<h4 id="do-while-语句">do-while 语句</h4>

<pre><code>do 
{ 
  statements 
} while (condition) 
</code></pre>

<p>这种格式保证了语句会在条件被求值之前至少执行一次。</p>

<h4 id="for-语句">for 语句</h4>

<p>gawk编程语言支持C风格的for循环。格式如下：</p>

<pre><code>for( variable assignment; condition; iteration process)
</code></pre>

<p>示例如下：</p>

<pre><code>$ gawk '{ 
&gt; total = 0 
&gt; for (i = 1; i &lt; 4; i++) 
&gt; { 
&gt;    total += $i 
&gt; } 
&gt; avg = total / 3 
&gt; print &quot;Average:&quot;,avg 
&gt; }' data5
</code></pre>

<h3 id="格式化打印">格式化打印</h3>

<p>格式化打印命令，叫作printf，格式：</p>

<pre><code>printf &quot; format string &quot;,  var1, var2 . . .
</code></pre>

<p>格式化指定符采用如下格式：</p>

<pre><code>%[modifier ] control- letter  
</code></pre>

<p>其中control-
letter是一个单字符代码，用于指明显示什么类型的数据，而modifier则定义了可选的格式化特性。下表列出了可用在格式化指定符中的控制字母：</p>

<table>
<thead>
<tr>
<th>控制字母</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>c</td>
<td>将一个数作为ASCII字符显示</td>
</tr>

<tr>
<td>d</td>
<td>显示一个整数值</td>
</tr>

<tr>
<td>i</td>
<td>显示一个整数值（跟d一样）</td>
</tr>

<tr>
<td>e</td>
<td>用科学计数法显示一个数</td>
</tr>

<tr>
<td>f</td>
<td>显示一个浮点值</td>
</tr>

<tr>
<td>g</td>
<td>用科学计数法或浮点数显示（选择较短的格式）</td>
</tr>

<tr>
<td>o</td>
<td>显示一个八进制值</td>
</tr>

<tr>
<td>s</td>
<td>显示一个文本字符串</td>
</tr>

<tr>
<td>x</td>
<td>显示一个十六进制值</td>
</tr>

<tr>
<td>X</td>
<td>显示一个十六进制值，但用大写字母A~F</td>
</tr>
</tbody>
</table>

<p>使用示例：</p>

<pre><code>$ gawk 'BEGIN{ 
&gt; x = 10 * 100 
&gt; printf &quot;The answer is: %e\n&quot;, x 
&gt; }' 
The answer is: 1.000000e+03
</code></pre>

<p>除了控制字母外，还有3种修饰符可以用来进一步控制输出：</p>

<pre><code>width：指定了输出字段最小宽度的数字值。如果输出短于这个值，printf会将文本右对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际的长度输出。
prec：这是一个数字值，指定了浮点数中小数点后面位数，或者文本字符串中显示的最大字符数。 
- （减号）：指明在向格式化空间中放入数据时采用左对齐而不是右对齐。
</code></pre>

<p>下面给出一个例子，通过添加一个值为16的修饰符，我们强制第一个字符串的输出宽度为16个字符，再给修饰符加一个减号改成左对齐：</p>

<pre><code>gawk 'BEGIN{FS=&quot;\n&quot;; RS=&quot;&quot;} {printf &quot;%-16s  %s\n&quot;, $1, $4}' data2 
</code></pre>

<h3 id="内建函数">内建函数</h3>

<h4 id="数学函数">数学函数</h4>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>atan2(x, y)</td>
<td>x/y的反正切，x和y以弧度为单位</td>
</tr>

<tr>
<td>cos(x)</td>
<td>x的余弦，x以弧度为单位</td>
</tr>

<tr>
<td>exp(x)</td>
<td>x的指数函数</td>
</tr>

<tr>
<td>int(x)</td>
<td>x的整数部分，取靠近零一侧的值</td>
</tr>

<tr>
<td>log(x)</td>
<td>x的自然对数</td>
</tr>

<tr>
<td>rand( )</td>
<td>比0大比1 小的随机浮点值</td>
</tr>

<tr>
<td>sin(x)</td>
<td>x的正弦，x以弧度为单位</td>
</tr>

<tr>
<td>sqrt(x)</td>
<td>x的平方根</td>
</tr>

<tr>
<td>srand(x)</td>
<td>为计算随机数指定一个种子值</td>
</tr>
</tbody>
</table>

<p>除了标准数学函数外，gawk还支持一些按位操作数据的函数。</p>

<pre><code>and(v1, v2) ：执行值v1和v2的按位与运算。 
compl( val ) ：执行val 的补运算。 
lshift(val , count) ：将值val 左移count位。 
or( v1, v2) ：执行值v1和v2的按位或运算。 
rshift(val , count) ：将值val 右移count位。 
xor(v1, v2) ：执行值v1和v2的按位异或运算。 
</code></pre>

<h4 id="字符串函数">字符串函数</h4>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>asort( s [, d ])</td>
<td></td>
</tr>
</tbody>
</table>

<p>将数组s按数据元素值排序。索引值会被替换成表示新的排序顺序的连续数字。另外，如果指定了d，则排序后的数组会存储在数组d中<br />
asorti(s [, d ]) |
将数组s按索引值排序。生成的数组会将索引值作为数据元素值，用连续数字索引来表明排序顺序。另外如果指定了d，排序后的数组会存储在数组d中<br />
gensub(r , s , h [, t ]) | 查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果h是一个以g或G
开头的字符串，就用s替换掉匹配的文本。如果h是一个数字，它表示要替换掉第h处r匹配的地方<br />
gsub(r , s [, t ]) | 查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果找到了，就全部替换成字符串s<br />
index( s , t ) | 返回字符串t在字符串s中的索引值，如果没找到的话返回0<br />
length([ s ]) | 返回字符串s的长度；如果没有指定的话，返回$0的长度<br />
match( s , r [, a ]) | 返回字符串s中正则表达式r 出现位置的索引。如果指定了数组a，它会存储 s中匹配正则表达式的那部分<br />
split( s , a [, r ]) | 将s 用FS字符或正则表达式r （如果指定了的话）分开放到数组a中。返回字段的总数<br />
sprintf( format , variables) | 用提供的format和variables返回一个类似于printf输出的字符串<br />
sub(r , s [, t ]) | 在变量$0或目标字符串t 中查找正则表达式r 的匹配。如果找到了，就用字符串s 替换掉第一处匹配<br />
substr(s , i [, n ]) | 返回s 中从索引值i 开始的n 个字符组成的子字符串。如果未提供n ，则返回s 剩下的部分<br />
tolower( s ) | 将s中的所有字符转换成小写<br />
toupper( s ) | 将s中的所有字符转换成大写</p>

<h4 id="时间函数">时间函数</h4>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>mktime(datespec )</td>
<td>将一个按YYYY MM DD HH MM SS [DST]格式指定的日期转换成时间戳值</td>
</tr>

<tr>
<td>strftime(format [,timestamp])</td>
<td></td>
</tr>
</tbody>
</table>

<p>将当前时间的时间戳或timestamp（如果提供了的话）转化格式化日期(采用shell函数date()的格式)<br />
systime( ) | 返回当前时间的时间戳</p>

<h3 id="自定义函数">自定义函数</h3>

<h4 id="定义函数">定义函数</h4>

<pre><code>function name([variables]) 
{ 
    statements 
}
</code></pre>

<p>函数还能用return语句返回值：</p>

<pre><code>return value 
</code></pre>

<p>举例如下：</p>

<pre><code>function myrand(limit) 
{ 
   return int(limit * rand()) 
} 
</code></pre>

<h4 id="使用自定义函数">使用自定义函数</h4>

<p>在定义函数时，它必须出现在所有代码块之前（包括BEGIN代码块）。</p>

<h4 id="创建函数库">创建函数库</h4>

<p>首先，你需要创建一个存储所有gawk函数的文件。要使用库，只要创建一个含有你的gawk程序的文件，然后在命令行上同时指定库文件和程序文件就行了，例如：</p>

<pre><code>gawk -f funclib -f script4 data2
</code></pre>

<p>你要做的是当需要使用库中定义的函数时，将funclib 文件加到你的gawk命令行上就可以了。</p>

<h3 id="实例-2">实例</h3>

<p>比赛得分情况分析示例，我们有各队得分的文件：</p>

<pre><code>$ cat scores.txt 
Rich Blum,team1,100,115,95 
Barbara Blum,team1,110,115,100 
Christine Bresnahan,team2,120,115,118 
</code></pre>

<p>脚本如下：</p>

<pre><code>$ cat bowling.sh 
#!/bin/bash 
for team in $(gawk –F, '{print $2}' scores.txt | uniq) 
do 
   gawk –v team=$team 'BEGIN{FS=&quot;,&quot;; total=0} 
   { 
      if ($2==team) 
      { 
         total += $3 + $4 + $5; 
      } 
   } 
   END { 
      avg = total / 6; 
      print &quot;Total for&quot;, team, &quot;is&quot;, total, &quot;,the average is&quot;,avg 
   }' scores.txt 
done 
</code></pre>

<p>for 循环中的第一条语句过滤出数据文件中的队名，然后使用uniq命令返回不重复的队名。for循环再对每个队进行迭代。for
循环内部的gawk语句进行计算操作。对于每一条记录，首先确定队名是否和正在进行循环的队名相符。这是通过利用gawk的-
v选项来实现的，该选项允许我们在gawk程序中传递shell变量。如果队名相符，代码会对数据记录中的三场比赛得分求和，然后将每条记录的值再相加，只要数据记录属于同一队。
在循环迭代的结尾处，gawk代码会显示出总分以及平均分。</p>

<h1 id="第四部分-创建实用的脚本">第四部分、创建实用的脚本</h1>

<h2 id="第二十四章-编写简单的脚本使用工具">第二十四章、编写简单的脚本使用工具</h2>

<p>浏览后简单记录目录，如果以后有需要再细看</p>

<h3 id="文件归档">文件归档</h3>

<h3 id="管理用户账户">管理用户账户</h3>

<h3 id="监测磁盘空间-1">监测磁盘空间</h3>

<h2 id="第二十五章-创建与数据库-web及电子邮件相关的脚本">第二十五章、创建与数据库、Web及电子邮件相关的脚本</h2>

<h3 id="mysql数据库">MySQL数据库</h3>

<h4 id="在脚本中使用数据库">在脚本中使用数据库</h4>

<p>mysql程序使用$HOME/.my.cnf 文件来读取特定的启动命令和设置。其中一项设置就是用户启动的mysql会话的默认密码，可以先配置这个。</p>

<p>脚本示例1：</p>

<pre><code>$ cat mtest1 
#!/bin/bash 
# send a command to the MySQL server 

MYSQL=$(which mysql) 

$MYSQL mytest -u test -e 'select * from employees'
</code></pre>

<p>脚本示例2：</p>

<pre><code>$ cat mtest2 
#!/bin/bash 
# sending multiple commands to MySQL 

MYSQL=$(which mysql) 
$MYSQL mytest -u test &lt; 40000; 
EOF
</code></pre>

<p>脚本示例3：</p>

<pre><code>$ cat mtest3 
#!/bin/bash 
# send data to the table in the MySQL database 

MYSQL=$(which mysql) 

if [ $# -ne 4 ] 
then 
 echo &quot;Usage: mtest3 empid lastname firstname salary&quot; 
else 
 statement=&quot;INSERT INTO employees VALUES ($1, '$2', '$3', $4)&quot; 
 $MYSQL mytest -u test &lt;&lt; EOF 
 $statement 
EOF 
 if [ $? -eq 0 ] 
 then 
    echo Data successfully added 
 else 
    echo Problem adding data 
 fi 
fi
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>