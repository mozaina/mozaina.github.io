<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shellgrep正则匹配汉字 | 开发者问答集锦</title>
    <meta property="og:title" content="shellgrep正则匹配汉字 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shellgrep正则匹配汉字">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shellgrep%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%B1%89%E5%AD%97/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shellgrep正则匹配汉字</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="shell-grep正则匹配中文">Shell grep正则匹配中文</h1>

<p>测试文本 demo_exe.c，内容如下，需要注意保存的编码格式，对输出到终端有影响：</p>

<p>我们中文操作系统ASNI默认是GBK的。</p>

<pre><code> 1 #include
 2 #include
 3 #include &lt;string.h&gt;
 4 #include 
 5 #include 
 6 #include 
 7 
 8 /*
 9  * export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/data/local/tmp; /data/local/tmp/demo_exe
10  */
11 int main(int argc, char** argv) {
12 // 这个是中文
13     void *handle = NULL;
14     char* locname = setlocale(LC_ALL, &quot;&quot;);
15 // 这个是中文
16 //
17     if ((handle = dlopen(demo_dso_so, RTLD_NOW)) == NULL) {
18         printf(&quot;dlopen出错: %s\n&quot;, dlerror());
19     }
20     printf(&quot;@%s[%s]dlopen return handle = %#x.\n&quot;, __FILE__, __FUNCTION__, handle);
21 // 这个是
22 // 中文
23     return 0;
24 }
</code></pre>

<h3 id="1-匹配特定文字">1、匹配特定文字：</h3>

<p><strong>$ grep -nP &ldquo;\xE4\xB8\xAD\xE6\x96\x87|\xD6\xD0\xCE\xC4&rdquo; ./demo_exe.c</strong><br />
12:// 这个是中文<br />
15:// 这个是中文<br />
22:// 中文</p>

<table>
<thead>
<tr>
<th>编码</th>
<th>中</th>
<th>文</th>
<th>在线码表</th>
</tr>
</thead>

<tbody>
<tr>
<td>GBK</td>
<td>D6D0</td>
<td>CEC4</td>
<td></td>
</tr>
</tbody>
</table>

<p><a href="http://www.lhelper.org/tech/chinese_internal_code_specification_classified.txt">http://www.lhelper.org/tech/chinese_internal_code_specification_classified.txt</a><br />
Unicode | 4E2D | 6587 |<br />
UTF-8 | %E4%B8%AD | %E6%96%87 |
<a href="http://wenku.baidu.com/link?url=DfbzjKLcRaQ7yVIA_EHVP7mKdVbkggq4hwkCmmO9uR76Jib_5Y1Y_h616NnI21XY_x85YZqN1SQBAdCFQjklS_">http://wenku.baidu.com/link?url=DfbzjKLcRaQ7yVIA_EHVP7mKdVbkggq4hwkCmmO9uR76Jib_5Y1Y_h616NnI21XY_x85YZqN1SQBAdCFQjklS_</a></p>

<p>GBK码 ： 中=D6D0，文=CEC4</p>

<p>Unicode码：中=4E2D，文=6587</p>

<p>UTF-8码：中=%E4%B8%AD，文=%E6%96%87</p>

<h3 id="2-匹配特定范围文字">2、匹配特定范围文字</h3>

<p><strong>$ grep -nP &ldquo;[\xB0\xA1-\xF7\xFE]+&rdquo;
/home/fangss/c/dynamic_share_object_test/demo_exe.c</strong><br />
12:// 这个是中文<br />
15:// 这个是中文<br />
18: printf(&ldquo;dlopen出错: %s\n&rdquo;, dlerror());<br />
21:// 这个是<br />
22:// 中文</p>

<p>范围：</p>

<pre><code>● GBK/2: GB2312 汉字

B0 ０ １ ２ ３ ４ ５ ６ ７ ８ ９ Ａ Ｂ Ｃ Ｄ Ｅ Ｆ
Ａ 　 啊 阿 埃 挨 哎 唉 哀 皑 癌 蔼 矮 艾 碍 爱 隘
Ｂ 鞍 氨 安 俺 按 暗 岸 胺 案 肮 昂 盎 凹 敖 熬 翱
Ｃ 袄 傲 奥 懊 澳 芭 捌 扒 叭 吧 笆 八 疤 巴 拔 跋
Ｄ 靶 把 耙 坝 霸 罢 爸 白 柏 百 摆 佰 败 拜 稗 斑
Ｅ 班 搬 扳 般 颁 板 版 扮 拌 伴 瓣 半 办 绊 邦 帮
Ｆ 梆 榜 膀 绑 棒 磅 蚌 镑 傍 谤 苞 胞 包 褒 剥  

。。。


F7 ０ １ ２ ３ ４ ５ ６ ７ ８ ９ Ａ Ｂ Ｃ Ｄ Ｅ Ｆ
Ａ 　 鳌 鳍 鳎 鳏 鳐 鳓 鳔 鳕 鳗 鳘 鳙 鳜 鳝 鳟 鳢
Ｂ 靼 鞅 鞑 鞒 鞔 鞯 鞫 鞣 鞲 鞴 骱 骰 骷 鹘 骶 骺
Ｃ 骼 髁 髀 髅 髂 髋 髌 髑 魅 魃 魇 魉 魈 魍 魑 飨
Ｄ 餍 餮 饕 饔 髟 髡 髦 髯 髫 髻 髭 髹 鬈 鬏 鬓 鬟
Ｅ 鬣 麽 麾 縻 麂 麇 麈 麋 麒 鏖 麝 麟 黛 黜 黝 黠
Ｆ 黟 黢 黩 黧 黥 黪 黯 鼢 鼬 鼯 鼹 鼷 鼽 鼾 齄
</code></pre>

<p>2</p>

<p>正则表达式</p>

<h2 id="正则表达式30分钟入门教程">正则表达式30分钟入门教程</h2>

<p>转载来源 版本：v2.33 (2013-1-10) 作者：deerchao</p>

<p>首页 | 正则表达式30分钟入门教程 | 常用正则表达式| 正则表达式速查表 | 正则表达式测试工具 | 正则表达式 |
JavaScript正则在线测试工具 | 正则练习器在线</p>

<p>Get XRegExp 2.0: minified (3.5 KB gzipped), or with comments. Get the full
package or the latest development build at GitHub.</p>

<h2 id="java中正则-中链接-regular-expressions-of-java-tutorial">Java中正则，中链接 Regular Expressions of Java Tutorial</h2>

<blockquote>
<p>Java正则表达式教程</p>
</blockquote>

<p><img src="https://img.it610.com/image/info8/b8d97b5613f94ed2ba791cad57d0b2ed.gif" alt="" />
<img src="https://img.it610.com/image/info8/2f88dd3f1cd145f59c0e47b51acdbd4b.gif" alt="" /></p>

<pre><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
    &lt;title&gt;正则表达式在线测试 - 站长工具title&gt;
    &lt;meta name=&quot;keywords&quot; content=&quot;正则表达式在线测试,正则表达式测试工具&quot;&gt;
    &lt;meta name=&quot;description&quot; content=&quot;该工具主要针对程序开发人员，通过该工具可以快速准备的判断所写的正则是否能正确匹配相应的字符&quot;&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;http://tool.chinaz.com/Chinaz.ico&quot; type=&quot;image/x-icon&quot;&gt;



    &lt;script language=&quot;JavaScript&quot;&gt;
        //if (self != top) { top.location = self.location; }
    script&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        ul, ol, li, dl, dd, p, h1, h2, h3, h4, h5, h6, form, fieldset {
            margin: 0;
            padding: 0;
        }

        h1, h2, h3, h4, h5, h6 {
            font-size: 1em;
        }

        ul, ol {
            list-style: none;
        }

        img {
            vertical-align: middle;
            border: 0;
        }

        a {
            color: #0d8c21;
            text-decoration: none;
        }

            a:hover {
                color: red;
                text-decoration: underline;
            }

        select {
            font-size: 15px;
        }

        .blue {
            color: #3333ff;
        }

        .fl {
            float: left;
        }

        .fr {
            float: right;
        }

        .box h1 {
            line-height: 37px;
            height: 37px;
            padding-left: 20px;
            background: url(&quot;http://tool.chinaz.com/template/default/images/h1-bg.gif&quot;) repeat-x;
            color: #0066CC;
            border: 1px solid #c5e2f2;
            border-bottom: 0;
            font-size: 14px;
            font-weight: normal;
        }

            .box h1 span {
                float: right;
                background: url(&quot;http://tool.chinaz.com/template/default/images/h1.gif&quot;) no-repeat right;
                padding: 10px 12px 0 0;
                font-weight: normal;
            }

            .box h1 a {
                color: #3333ff;
            }

        .box .titright {
            float: right;
            padding-right: 10px;
        }

        .box .titleft {
            float: left;
        }

        .box .notice {
            color: red;
            margin-bottom: 5px;
            background: none repeat scroll 0% 0% transparent;
            border: 1px solid rgb(197, 226, 242);
        }

        .clear {
            clear: both;
            font-size: 0;
            line-height: 0;
            height: 10px;
        }

        .input {
            border: 1px solid #94c6e1;
            background: #fff;
            color: #22ac38;
            font-weight: bold;
            padding: 5px;
            margin-bottom: 5px;
        }

        .input {
            font-size: 13px;
        }

        .but {
            width: 90px;
            border: 1px solid #c5e2f2;
            background: #cde4f2 url('http://tool.chinaz.com/template/default/images/but.gif') repeat-x 50% top;
            height: 30px;
            margin-left: 5px;
            cursor: pointer;
            margin-bottom: 5px;
        }

        .but2 {
            border: 1px solid #c5e2f2;
            background: #cde4f2 url('http://tool.chinaz.com/template/default/images/but.gif') repeat-x 50% top;
            height: 30px;
            margin-left: 5px;
            cursor: pointer;
            margin-bottom: 5px;
            width: 90px;
        }

        .but3 {
            border: 1px solid #c5e2f2;
            background: #cde4f2 url('http://tool.chinaz.com/template/default/images/but.gif') repeat-x 50% top;
            height: 30px;
            margin-left: 5px;
            cursor: pointer;
            margin-bottom: 5px;
            width: 50px;
        }

        .but4 {
            border: 1px solid #c5e2f2;
            background: #cde4f2 url('http://tool.chinaz.com/template/default/images/but.gif') repeat-x 50% top;
            height: 30px;
            margin-left: 5px;
            cursor: pointer;
            margin-bottom: 5px;
            width: 120px;
        }

        .input1 {
            border: 1px solid #7f9db9;
            background: #fff;
            color: #333;
            font-weight: bold;
            padding: 3px 5px;
            margin-bottom: 5px;
        }

        .but1 {
            border: 1px solid #7f9db9;
            background: #f0f7fd;
            height: 23px;
            margin-left: 5px;
            cursor: pointer;
            overflow: visible;
            padding: 0 15px;
            margin-bottom: 5px;
        }
        /*w4648*/
        . {
            margin: auto;
            width: 900px;
            clear: both;
        }

        td, th {
            border: 1px solid #C0C0C0;
            border-collapse: collapse;
            padding: 5px;
        }

        table {
            border-collapse: collapse;
            border: 1px solid #C0C0C0;
            margin: 0 auto;
        }

        .menu-list {
            z-index: 5;
        }

        #mainbody {
            padding-top: 10px;
            padding-bottom: 10px;
        }

        #condition ul li {
            float: left;
        }

        #search {
            height: 180px;
            width: 99.75%;
        }

        #input {
            height: 375px;
            margin-top: 10px;
            width: 99.75%;
        }

        .smartField {
            border: 1px solid #CCCCCC;
            overflow: auto;
            position: relative;
        }

            .smartField pre, .smartField textarea {
                width: 100%;
                padding: 0;
                margin: 0;
                font: 100% &quot;courier new&quot;,monospace;
            }

            .smartField pre {
                text-align: left;
                color: #F9F9F9;
                z-index: 1;
            }

            .smartField textarea {
                background: none repeat scroll 0 0 transparent;
                border: 0 none;
                height: 100%;
                overflow: hidden;
                position: absolute;
                left: 0px;
                top: 0px;
                z-index: 2;
            }

        b, i, u {
            font-style: normal;
            font-weight: normal;
            text-decoration: none;
        }

        #input b {
            background: none repeat scroll 0 0 #FFF000;
            color: #FFF000;
        }

        #input i {
            background: none repeat scroll 0 0 #80C0FF;
            color: #80C0FF;
        }

        #search b {
            background: none repeat scroll 0 0 #AAD1F7;
            color: #AAD1F7;
        }

        #search i {
            background: none repeat scroll 0 0 #F9CA69;
            color: #F9CA69;
        }

            #search i b {
                background: none repeat scroll 0 0 #F7A700;
                color: #F7A700;
            }

            #search i u {
                background: none repeat scroll 0 0 #EFBA4A;
                color: #EFBA4A;
            }

        #search b.g1 {
            background: none repeat scroll 0 0 #D2F854;
            color: #D2F854;
        }

        #search b.g2 {
            background: none repeat scroll 0 0 #9EC70C;
            color: #9EC70C;
        }

        #search b.g3 {
            background: none repeat scroll 0 0 #ECC9F7;
            color: #ECC9F7;
        }

        #search b.g4 {
            background: none repeat scroll 0 0 #54B70B;
            color: #54B70B;
        }

        #search b.g5 {
            background: none repeat scroll 0 0 #B688CF;
            color: #B688CF;
        }

        #search b.err {
            background: none repeat scroll 0 0 #FF4300 !important;
            color: #FF4300 !important;
        }
    style&gt;
head&gt;
&lt;body&gt;
    &lt;div class=&quot;w4648&quot;&gt;

        &lt;div class=&quot;main&quot;&gt;
            &lt;div class=&quot;box&quot;&gt;
                &lt;div id=&quot;b_1&quot;&gt;
                    &lt;h1&gt;&lt;a style=&quot;color: #3333ff;&quot; href=&quot;http://tool.chinaz.com/regex/&quot;&gt;正则表达式在线测试a&gt;h1&gt;
                    &lt;div class=&quot;box1&quot; style=&quot;text-align:center;&quot;&gt;
                        &lt;div id=&quot;condition&quot;&gt;
                            &lt;ul&gt;
                                &lt;li style=&quot; display:none;&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;toolG&quot;&gt;&lt;label for=&quot;toolG&quot;&gt;全局label&gt;li&gt;
                                &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;toolI&quot;&gt;&lt;label for=&quot;toolI&quot;&gt;不区分大小写label&gt;li&gt;
                                &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;toolM&quot;&gt;&lt;label for=&quot;toolM&quot;&gt;对^$前后换行也支持label&gt;li&gt;
                                &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;toolS&quot;&gt;&lt;label for=&quot;toolS&quot;&gt;符号.匹配所有label&gt;li&gt;
                            ul&gt;
                            &lt;span&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;highSyntax&quot;&gt;&lt;label for=&quot;highSyntax&quot;&gt;对正则着色label&gt;span&gt;
                            &lt;span&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;highMatch&quot;&gt;&lt;label for=&quot;highMatch&quot;&gt;对匹配结果着色label&gt;span&gt;
                            &lt;span&gt;&lt;input type=&quot;checkbox&quot; id=&quot;invertMatch&quot;&gt;&lt;label for=&quot;invertMatch&quot;&gt;对无匹配结果着色label&gt;span&gt;
                        div&gt;
                        &lt;div id=&quot;mainbody&quot;&gt;
                            &lt;div class=&quot;smartField&quot; id=&quot;search&quot;&gt;
                                &lt;textarea spellcheck=&quot;false&quot; tabindex=&quot;1&quot; rows=&quot;3&quot; cols=&quot;100&quot; id=&quot;searchText&quot; style=&quot;height: 180px; margin-left: 0px; width: 856px;&quot;&gt;(\w+\.){2}\w+textarea&gt;
                            div&gt;
                            &lt;div class=&quot;smartField&quot; id=&quot;input&quot; style=&quot;height: 180px;&quot;&gt;
                                &lt;textarea spellcheck=&quot;false&quot; tabindex=&quot;2&quot; rows=&quot;10&quot; cols=&quot;100&quot; id=&quot;inputText&quot; style=&quot;height: 180px; margin-left: 0px; width: 856px;&quot;&gt;tool.chinaz.com|888|http://www.cnblogs.com/Fang3s/p/4338103.htmltextarea&gt;
                            div&gt;
                        div&gt;
                    div&gt;
                div&gt;
            div&gt;


            &lt;script type=&quot;text/javascript&quot;&gt;
                //http://tool.chinaz.com/template/default/js/regbase.js
                /*    
                    XRegExp 0.2.5
                    (c)Steven Levithan
                    MIT license

                    Provides an augmented, cross-browser implementation of regular
                    expressions, including support for additional flags.
                */
                (function () { if (window.XRegExp) return; var real = { RegExp: RegExp, exec: RegExp.prototype.exec, match: String.prototype.match, replace: String.prototype.replace }; var re = { extended: /(?:[^[#\s\\]+|\\(?:[\S\s]|$)|\[\^?]?(?:[^\\\]]+|\\(?:[\S\s]|$))*]?)+|(\s*#[^\n\r\u2028\u2029]*\s*|\s+)([?*+]|{[0-9]+(?:,[0-9]*)?})?/g, singleLine: /(?:[^[\\.]+|\\(?:[\S\s]|$)|\[\^?]?(?:[^\\\]]+|\\(?:[\S\s]|$))*]?)+|\./g, characterClass: /(?:[^\\[]+|\\(?:[\S\s]|$))+|\[\^?(]?)(?:[^\\\]]+|\\(?:[\S\s]|$))*]?/g, capturingGroup: /(?:[^[(\\]+|\\(?:[\S\s]|$)|\[\^?]?(?:[^\\\]]+|\\(?:[\S\s]|$))*]?|\((?=\?))+|(\()(?:)?/g, namedBackreference: /(?:[^\\[]+|\\(?:[^k]|$)|\[\^?]?(?:[^\\\]]+|\\(?:[\S\s]|$))*]?|\\k(?!))+|\\k([0-9]?)/g, replacementVariable: /(?:[^$]+|\$(?![1-9$&amp;`']|{[$\w]+}))+|\$(?:([1-9]\d*|[$&amp;`'])|{([$\w]+)})/g }; XRegExp = function (pattern, flags) { flags = flags || &quot;&quot;; if (flags.indexOf(&quot;x&quot;) &gt; -1) { pattern = real.replace.call(pattern, re.extended, function ($0, $1, $2) { return $1 ? ($2 || &quot;(?:)&quot;) : $0 }) }; var hasNamedCapture = false; if (flags.indexOf(&quot;k&quot;) &gt; -1) { var captureNames = []; pattern = real.replace.call(pattern, re.capturingGroup, function ($0, $1, $2) { if ($1) { if ($2) hasNamedCapture = true; captureNames.push($2 || null); return &quot;(&quot; } else { return $0 } }); if (hasNamedCapture) { pattern = real.replace.call(pattern, re.namedBackreference, function ($0, $1, $2) { var index = $1 ? captureNames.indexOf($1) : -1; return index &gt; -1 ? &quot;\\&quot; + (index + 1) + ($2 ? &quot;(?:)&quot; + $2 : &quot;&quot;) : $0 }) } }; pattern = real.replace.call(pattern, re.characterClass, function ($0, $1) { return $1 ? real.replace.call($0, &quot;]&quot;, &quot;\\]&quot;) : $0 }); if (flags.indexOf(&quot;s&quot;) &gt; -1) { pattern = real.replace.call(pattern, re.singleLine, function ($0) { return $0 === &quot;.&quot; ? &quot;[\\S\\s]&quot; : $0 }) }; var regex = real.RegExp(pattern, real.replace.call(flags, /[sxk]+/g, &quot;&quot;)); if (hasNamedCapture) regex._captureNames = captureNames; return regex }; RegExp.prototype.addFlags = function (flags) { flags = (flags || &quot;&quot;) + (this.global ? &quot;g&quot; : &quot;&quot;) + (this.ignoreCase ? &quot;i&quot; : &quot;&quot;) + (this.multiline ? &quot;m&quot; : &quot;&quot;); var regex = new XRegExp(this.source, flags); if (!regex._captureNames &amp;&amp; this._captureNames) regex._captureNames = this._captureNames.slice(0); return regex }; RegExp.prototype.exec = function (str) { var result = real.exec.call(this, str); if (!(this._captureNames &amp;&amp; result &amp;&amp; result.length &gt; 1)) return result; for (var i = 1; i &lt; result.length; i++) { var name = this._captureNames[i - 1]; if (name) result[name] = result[i] }; return result }; String.prototype.match = function (regex) { if (!regex._captureNames || regex.global) return real.match.call(this, regex); return regex.exec(this) }; String.prototype.replace = function (search, replacement) { if (!(search instanceof real.RegExp &amp;&amp; search._captureNames)) return real.replace.apply(this, arguments); if (typeof replacement === &quot;function&quot;) { return real.replace.call(this, search, function () { arguments[0] = new String(arguments[0]); for (var i = 0; i &lt; search._captureNames.length; i++) { if (search._captureNames[i]) arguments[0][search._captureNames[i]] = arguments[i + 1] }; return replacement.apply(window, arguments) }) } else { return real.replace.call(this, search, function () { var args = arguments; return real.replace.call(replacement, re.replacementVariable, function ($0, $1, $2) { if ($1) { switch ($1) { case &quot;$&quot;: return &quot;$&quot;; case &quot;&amp;&quot;: return args[0]; case &quot;`&quot;: return args[args.length - 1].slice(0, args[args.length - 2]); case &quot;'&quot;: return args[args.length - 1].slice(args[args.length - 2] + args[0].length); default: var literalNumbers = &quot;&quot;; $1 = +$1; while ($1 &gt; search._captureNames.length) { literalNumbers = $1.split(&quot;&quot;).pop() + literalNumbers; $1 = Math.floor($1 / 10) }; return ($1 ? args[$1] : &quot;$&quot;) + literalNumbers } } else if ($2) { var index = search._captureNames.indexOf($2); return index &gt; -1 ? args[index + 1] : $0 } else { return $0 } }) }) } } })(); XRegExp.cache = function (pattern, flags) { var key = &quot;/&quot; + pattern + &quot;/&quot; + (flags || &quot;&quot;); return XRegExp.cache[key] || (XRegExp.cache[key] = new XRegExp(pattern, flags)) }; XRegExp.overrideNative = function () { RegExp = XRegExp }; if (!Array.prototype.indexOf) { Array.prototype.indexOf = function (item, from) { var len = this.length; for (var i = (from &lt; 0) ? Math.max(0, len + from) : from || 0; i &lt; len; i++) { if (this[i] === item) return i }; return -1 } }

                // http://tool.chinaz.com/template/default/js/reg.js
                function $(el) { if (el.nodeName) return el; if (typeof el === &quot;string&quot;) return document.getElementById(el); return false }; var trim = function () { var lSpace = /^\s\s*/, rSpace = /\s\s*$/; return function (str) { return str.replace(lSpace, &quot;&quot;).replace(rSpace, &quot;&quot;) } }(); function replaceHtml(el, html) { var oldEl = $(el); var newEl = oldEl.cloneNode(false); newEl.innerHTML = html; oldEl.parentNode.replaceChild(newEl, oldEl); return newEl }; function replaceOuterHtml(el, html) { el = replaceHtml(el, &quot;&quot;); if (el.outerHTML) { var id = el.id, className = el.className, nodeName = el.nodeName; el.outerHTML = &quot;&lt;&quot; + nodeName + &quot; id=\&quot;&quot; + id + &quot;\&quot; class=\&quot;&quot; + className + &quot;\&quot;&gt;&quot; + html + &quot;&quot; + nodeName + &quot;&gt;&quot;; el = $(id) } else { el.innerHTML = html }; return el }; function getElementsByClassName(className, tagName, parentNode) { var els = ($(parentNode) || document).getElementsByTagName(tagName || &quot;*&quot;), results = []; for (var i = 0; i &lt; els.length; i++) { if (hasClass(className, els[i])) results.push(els[i]) }; return results }; function hasClass(className, el) { return XRegExp.cache(&quot;(?:^|\\s)&quot; + className + &quot;(?:\\s|$)&quot;).test($(el).className) }; function addClass(className, el) { el = $(el); if (!hasClass(className, el)) { el.className = trim(el.className + &quot; &quot; + className) } }; function removeClass(className, el) { el = $(el); el.className = trim(el.className.replace(XRegExp.cache(&quot;(?:^|\\s)&quot; + className + &quot;(?:\\s|$)&quot;, &quot;g&quot;), &quot; &quot;)) }; function toggleClass(className, el) { if (hasClass(className, el)) { removeClass(className, el) } else { addClass(className, el) } }; function swapClass(oldClass, newClass, el) { removeClass(oldClass, el); addClass(newClass, el) }; function replaceSelection(textbox, str) { if (textbox.setSelectionRange) { var start = textbox.selectionStart, end = textbox.selectionEnd, offset = (start + str.length); textbox.value = (textbox.value.substring(0, start) + str + textbox.value.substring(end)); textbox.setSelectionRange(offset, offset) } else if (document.selection) { var range = document.selection.createRange(); range.text = str; range.select() } }; function extend(to, from) { for (var property in from) to[property] = from[property]; return to }; function purge(d) { var a = d.attributes, i, l, n; if (a) { l = a.length; for (i = 0; i &lt; l; i += 1) { n = a[i].name; if (typeof d[n] === 'function') { d[n] = null } } }; a = d.childNodes; if (a) { l = a.length; for (i = 0; i &lt; l; i += 1) { purge(d.childNodes[i]) } } }; var isWebKit = navigator.userAgent.indexOf(&quot;WebKit&quot;) &gt; -1, isIE, isIE6 = isIE &amp;&amp; !window.XMLHttpRequest; var RegexPal = { fields: { search: new SmartField(&quot;search&quot;), input: new SmartField(&quot;input&quot;), options: { flags: { g: $(&quot;toolG&quot;), i: $(&quot;toolI&quot;), m: $(&quot;toolM&quot;), s: $(&quot;toolS&quot;) }, highlightSyntax: $(&quot;highSyntax&quot;), highlightMatches: $(&quot;highMatch&quot;), invertMatches: $(&quot;invertMatch&quot;) } } }; extend(RegexPal, function () { var f = RegexPal.fields, o = f.options; return { highlightMatches: function () { var re = { matchPair: /`~\{((?:[^}]+|\}(?!~`))*)\}~`((?:[^`]+|`(?!~\{(?:[^}]+|\}(?!~`))*\}~`))*)(?:`~\{((?:[^}]+|\}(?!~`))*)\}~`)?/g, sansTrailingAlternator: /^(?:[^\\|]+|\\[\S\s]?|\|(?=[\S\s]))*/ }; return function () { var search = String(f.search.textbox.value), input = String(f.input.textbox.value); if (XRegExp.cache('').test(f.search.bg.innerHTML) || (!search.length &amp;&amp; !o.invertMatches.checked) || !o.highlightMatches.checked) { f.input.clearBg(); return }; try { var searchRegex = new XRegExp(re.sansTrailingAlternator.exec(search)[0], (o.flags.g.checked ? &quot;g&quot; : &quot;&quot;) + (o.flags.i.checked ? &quot;i&quot; : &quot;&quot;) + (o.flags.m.checked ? &quot;m&quot; : &quot;&quot;) + (o.flags.s.checked ? &quot;s&quot; : &quot;&quot;)) } catch (err) { f.input.clearBg(); return }; if (o.invertMatches.checked) { var output = (&quot;`~{&quot; + input.replace(searchRegex, &quot;}~`$&amp;`~{&quot;) + &quot;}~`&quot;).replace(XRegExp.cache(&quot;`~\\{\\}~`|\\}~``~\\{&quot;, &quot;g&quot;), &quot;&quot;) } else { var output = input.replace(searchRegex, &quot;`~{$&amp;}~`&quot;) }; output = output.replace(XRegExp.cache(&quot;[]&quot;, &quot;g&quot;), &quot;_&quot;).replace(re.matchPair, &quot; **$1** $2 _$3_ &quot;); f.input.setBgHtml(output) } }(), highlightSearchSyntax: function () { if (o.highlightSyntax.checked) { f.search.setBgHtml(parseRegex(f.search.textbox.value)) } else { f.search.clearBg() } } } }()); var parseRegex = function () { var re = { regexToken: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, characterClassParts: /^(\[\^?)(]?(?:[^\\\]]+|\\[\S\s]?)*)(]?)$/.addFlags(&quot;k&quot;), characterClassToken: /[^\\-]+|-|\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)/g, quantifier: /^(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??$/ }, type = { NONE: 0, RANGE_HYPHEN: 1, METACLASS: 2, ALTERNATOR: 3 }; function errorStr(str) { return ' ****' + str + '' }; function getTokenCharCode(token) { if (token.length &gt; 1 &amp;&amp; token.charAt(0) === &quot;\\&quot;) { var t = token.slice(1); if (XRegExp.cache(&quot;^c[A-Za-z]$&quot;).test(t)) { return &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.indexOf(t.charAt(1).toUpperCase()) + 1 } else if (XRegExp.cache(&quot;^(?:x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})$&quot;).test(t)) { return parseInt(t.slice(1), 16) } else if (XRegExp.cache(&quot;^(?:[0-3][0-7]{0,2}|[4-7][0-7]?)$&quot;).test(t)) { return parseInt(t, 8) } else if (t.length === 1 &amp;&amp; &quot;cuxDdSsWw&quot;.indexOf(t) &gt; -1) { return false } else if (t.length === 1) { switch (t) { case &quot;b&quot;: return 8; case &quot;f&quot;: return 12; case &quot;n&quot;: return 10; case &quot;r&quot;: return 13; case &quot;t&quot;: return 9; case &quot;v&quot;: return 11; default: return t.charCodeAt(0) } } } else if (token !== &quot;\\&quot;) { return token.charCodeAt(0) }; return false }; function parseCharacterClass(value) { var output = &quot;&quot;, parts = re.characterClassParts.exec(value), parser = re.characterClassToken, lastToken = { rangeable: false, type: type.NONE }, match, m; output += parts.closing ? parts.opening : errorStr(parts.opening); while (match = parser.exec(parts.contents)) { m = match[0]; if (m.charAt(0) === &quot;\\&quot;) { if (XRegExp.cache(&quot;^\\\\[cux]$&quot;).test(m)) { output += errorStr(m); lastToken = { rangeable: lastToken.type !== type.RANGE_HYPHEN } } else if (XRegExp.cache(&quot;^\\\\[dsw]$&quot;, &quot;i&quot;).test(m)) { output += &quot; ****&quot; + m + &quot;&quot;; lastToken = { rangeable: lastToken.type !== type.RANGE_HYPHEN, type: type.METACLASS } } else if (m === &quot;\\&quot;) { output += errorStr(m) } else { output += &quot; ****&quot; + m.replace(XRegExp.cache(&quot;[]&quot;), &quot;_&quot;) + &quot;&quot;; lastToken = { rangeable: lastToken.type !== type.RANGE_HYPHEN, charCode: getTokenCharCode(m) } } } else if (m === &quot;-&quot;) { if (lastToken.rangeable) { var lastIndex = parser.lastIndex, nextToken = parser.exec(parts.contents); if (nextToken) { var nextTokenCharCode = getTokenCharCode(nextToken[0]); if ((nextTokenCharCode !== false &amp;&amp; lastToken.charCode &gt; nextTokenCharCode) || lastToken.type === type.METACLASS || XRegExp.cache(&quot;^\\\\[dsw]$&quot;, &quot;i&quot;).test(nextToken[0])) { output += errorStr(&quot;-&quot;) } else { output += &quot; _-_ &quot; }; lastToken = { rangeable: false, type: type.RANGE_HYPHEN } } else { if (parts.closing) { output += &quot;-&quot; } else { output += &quot; _-_ &quot;; break } }; parser.lastIndex = lastIndex } else { output += &quot;-&quot;; lastToken = { rangeable: lastToken.type !== type.RANGE_HYPHEN } } } else { output += m.replace(XRegExp.cache(&quot;[]&quot;, &quot;g&quot;), &quot;_&quot;); lastToken = { rangeable: (m.length &gt; 1 || lastToken.type !== type.RANGE_HYPHEN), charCode: m.charCodeAt(m.length - 1) } } }; return output + parts.closing }; return function (value) { var output = &quot;&quot;, capturingGroupCount = 0, groupStyleDepth = 0, openGroups = [], lastToken = { quantifiable: false, type: type.NONE }, match, m; function groupStyleStr(str) { return ' **'** + groupStyleDepth + '&quot;&gt;' + str + '' }; while (match = re.regexToken.exec(value)) { m = match[0]; switch (m.charAt(0)) { case &quot;[&quot;: output += &quot; __&quot; + parseCharacterClass(m) + &quot;&quot;; lastToken = { quantifiable: true }; break; case &quot;(&quot;: if (m.length === 2) { output += errorStr(m) } else { if (m.length === 1) capturingGroupCount++; groupStyleDepth = groupStyleDepth === 5 ? 1 : groupStyleDepth + 1; openGroups.push({ index: output.length + 14, opening: m }); output += groupStyleStr(m) }; lastToken = { quantifiable: false }; break; case &quot;)&quot;: if (!openGroups.length) { output += errorStr(&quot;)&quot;); lastToken = { quantifiable: false } } else { output += groupStyleStr(&quot;)&quot;); lastToken = { quantifiable: !XRegExp.cache(&quot;^[=!]&quot;).test(openGroups[openGroups.length - 1].opening.charAt(2)), style: &quot;g&quot; + groupStyleDepth }; groupStyleDepth = groupStyleDepth === 1 ? 5 : groupStyleDepth - 1; openGroups.pop() }; break; case &quot;\\&quot;: if (XRegExp.cache(&quot;^[1-9]&quot;).test(m.charAt(1))) { var nonBackrefDigits = &quot;&quot;, num = +m.slice(1); while (num &gt; capturingGroupCount) { nonBackrefDigits = XRegExp.cache(&quot;[0-9]$&quot;).exec(num)[0] + nonBackrefDigits; num = Math.floor(num / 10) }; if (num &gt; 0) { output += &quot; **\\** &quot; + num + &quot;&quot; + nonBackrefDigits } else { var parts = XRegExp.cache(&quot;^\\\\([0-3][0-7]{0,2}|[4-7][0-7]?|[89])([0-9]*)&quot;).exec(m); output += &quot; **\\** &quot; + parts[1] + &quot;&quot; + parts[2] } } else if (XRegExp.cache(&quot;^[0bBcdDfnrsStuvwWx]&quot;).test(m.charAt(1))) { if (XRegExp.cache(&quot;^\\\\[cux]$&quot;).test(m)) { output += errorStr(m); lastToken = { quantifiable: false }; break }; output += &quot; ****&quot; + m + &quot;&quot;; if (&quot;bB&quot;.indexOf(m.charAt(1)) &gt; -1) { lastToken = { quantifiable: false }; break } } else if (m === &quot;\\&quot;) { output += errorStr(m) } else { output += m.replace(XRegExp.cache(&quot;[]&quot;), &quot;_&quot;) }; lastToken = { quantifiable: true }; break; default: if (re.quantifier.test(m)) { if (lastToken.quantifiable) { var interval = XRegExp.cache(&quot;^\\{([0-9]+)(?:,([0-9]*))?&quot;).exec(m); if (interval &amp;&amp; ((interval[1] &gt; 65535) || (interval[2] &amp;&amp; ((interval[2] &gt; 65535) || (+interval[1] &gt; +interval[2]))))) { output += errorStr(m) } else { output += (lastToken.style ? ' **'** + lastToken.style + '&quot;&gt;' : ' ****' ) + m + '' } } else { output += errorStr(m) }; lastToken = { quantifiable: false } } else if (m === &quot;|&quot;) { if (lastToken.type === type.NONE || (lastToken.type === type.ALTERNATOR &amp;&amp; !openGroups.length)) { output += errorStr(m) } else { output += openGroups.length ? groupStyleStr(&quot;|&quot;) : &quot; **|** &quot; }; lastToken = { quantifiable: false, type: type.ALTERNATOR } } else if (&quot;^$&quot;.indexOf(m) &gt; -1) { output += &quot; ****&quot; + m + &quot;&quot;; lastToken = { quantifiable: false } } else if (m === &quot;.&quot;) { output += &quot; **.** &quot;; lastToken = { quantifiable: true } } else { output += m.replace(XRegExp.cache(&quot;[]&quot;, &quot;g&quot;), &quot;_&quot;); lastToken = { quantifiable: true } } } }; var numCharsAdded = 0; for (var i = 0; i &lt; openGroups.length; i++) { var errorIndex = openGroups[i].index + numCharsAdded; output = (output.slice(0, errorIndex) + errorStr(openGroups[i].opening) + output.slice(errorIndex + openGroups[i].opening.length)); numCharsAdded += errorStr(&quot;&quot;).length }; return output } }(); function SmartField(el) { el = $(el); var textboxEl = el.getElementsByTagName(&quot;textarea&quot;)[0], bgEl = document.createElement(&quot;pre&quot;); textboxEl.id = el.id + &quot;Text&quot;; bgEl.id = el.id + &quot;Bg&quot;; el.insertBefore(bgEl, textboxEl); textboxEl.onkeydown = function (e) { SmartField.prototype._onKeyDown(e) }; textboxEl.onkeyup = function (e) { SmartField.prototype._onKeyUp(e) }; if (isIE) el.style.overflowX = &quot;hidden&quot;; if (isWebKit) textboxEl.style.marginLeft = 0; this.field = el; this.textbox = textboxEl; this.bg = bgEl }; extend(SmartField.prototype, { setBgHtml: function (html) { html = html.replace(XRegExp.cache(&quot;^\\n&quot;), &quot;\n\n&quot;); this.bg = replaceOuterHtml(this.bg, html + &quot;  
 &quot;); this.setDimensions() }, clearBg: function () { this.setBgHtml(this.textbox.value.replace(XRegExp.cache(&quot;[]&quot;, &quot;g&quot;), &quot;_&quot;)) }, setDimensions: function () { this.textbox.style.width = &quot;&quot;; var scrollWidth = this.textbox.scrollWidth, offsetWidth = this.textbox.offsetWidth; this.textbox.style.width = (scrollWidth === offsetWidth ? offsetWidth - 1 : scrollWidth + 8) + &quot;px&quot;; this.textbox.style.height = Math.max(this.bg.offsetHeight, this.field.offsetHeight - 2) + &quot;px&quot; }, _onKeyDown: function (e) { e = e || event; if (!this._filterKeys(e)) return false; var srcEl = e.srcElement || e.target; switch (srcEl) { case RegexPal.fields.search.textbox: setTimeout(function () { RegexPal.highlightSearchSyntax.call(RegexPal) }, 0); break }; if (isWebKit &amp;&amp; srcEl.selectionEnd === srcEl.value.length) { srcEl.parentNode.scrollTop = srcEl.scrollHeight }; this._testKeyHold(e) }, _onKeyUp: function (e) { e = e || event; var srcEl = e.srcElement || e.target; this._keydownCount = 0; if (this._matchOnKeyUp) { this._matchOnKeyUp = false; switch (srcEl) { case RegexPal.fields.search.textbox: case RegexPal.fields.input.textbox: RegexPal.highlightMatches(); break } } }, _testKeyHold: function (e) { var srcEl = e.srcElement || e.target; this._keydownCount++; if (this._keydownCount &gt; 2) { RegexPal.fields.input.clearBg(); this._matchOnKeyUp = true } else { switch (srcEl) { case RegexPal.fields.search.textbox: case RegexPal.fields.input.textbox: setTimeout(function () { RegexPal.highlightMatches.call(RegexPal) }, 0); break } } }, _filterKeys: function (e) { var srcEl = e.srcElement || e.target, f = RegexPal.fields; if (this._deadKeys.indexOf(e.keyCode) &gt; -1) return false; if ((e.keyCode === 9) &amp;&amp; (srcEl === f.input.textbox || (srcEl === f.search.textbox &amp;&amp; !e.shiftKey))) { if (srcEl === f.input.textbox) { if (e.shiftKey) { f.search.textbox.focus() } else { replaceSelection(srcEl, &quot;\t&quot;); if (window.opera) setTimeout(function () { srcEl.focus() }, 0) } } else { f.input.textbox.focus() }; if (e.preventDefault) e.preventDefault(); else e.returnValue = false }; return true }, _matchOnKeyUp: false, _keydownCount: 0, _deadKeys: [16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 37, 38, 39, 40, 44, 45, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 144, 145] }); (function () { var f = RegexPal.fields, o = f.options; onresize = function (e) { var isIE1 = !!window.ActiveXObject; var isIE61 = isIE1 &amp;&amp; !window.XMLHttpRequest; if (isIE61) f.input.field.style.height = Math.max((window.innerHeight || document.documentElement.clientHeight) - 310, 180) + &quot;px&quot;; else f.input.field.style.height = Math.max((window.innerHeight || document.documentElement.clientHeight) - 610, 180) + &quot;px&quot;; f.search.setDimensions(); f.input.setDimensions() }; onresize(); RegexPal.highlightSearchSyntax(); RegexPal.highlightMatches(); for (var flag in o.flags) { o.flags[flag].onclick = RegexPal.highlightMatches }; o.highlightSyntax.onclick = RegexPal.highlightSearchSyntax; o.highlightMatches.onclick = RegexPal.highlightMatches; o.invertMatches.onclick = RegexPal.highlightMatches; function makeResetter(field) { return function () { field.clearBg(); field.textbox.value = &quot;&quot;; field.textbox.onfocus = null } }; if (f.search.textbox.value == &quot;(\\w+\\.){2}\\w+&quot;) { f.search.textbox.onfocus = makeResetter(f.search) }; if (f.input.textbox.value === &quot;tool.chinaz.com|888&quot;) { f.input.textbox.onfocus = makeResetter(f.input) } })();
            script&gt;

            &lt;div class=&quot;box&quot;&gt;
                &lt;div id=&quot;b_14&quot;&gt;
                    &lt;h1&gt;工具简介h1&gt;
                    &lt;div class=&quot;box1&quot;&gt;
                        &lt;span class=&quot;info2&quot; style=&quot; font-size: 14px; line-height: 24px; text-align: left;white-space:normal; width:860px;overflow:hidden;&quot;&gt;
                            &lt;span style=&quot; font-weight:bold; color:Red;&quot;&gt;正则表达式到底是什么东西？span&gt;&lt;br&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。&lt;br&gt;&lt;span style=&quot; font-weight:bold; color:Red;&quot;&gt;常用元字符span&gt;&lt;br&gt;&lt;table cellspacing=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;代码th&gt;&lt;th scope=&quot;col&quot;&gt;说明th&gt;tr&gt;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;.span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配除换行符以外的任意字符span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\wspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配字母或数字或下划线或汉字span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\sspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配任意的空白符span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\dspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配数字span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\bspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配单词的开始或结束span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;^span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配字符串的开始span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;$span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配字符串的结束span&gt;td&gt;tr&gt;tbody&gt;table&gt;&lt;br&gt;&lt;span style=&quot; font-weight:bold; color:Red;&quot;&gt;常用限定符span&gt;&lt;br&gt;&lt;table cellspacing=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;代码/语法th&gt;&lt;th scope=&quot;col&quot;&gt;说明th&gt;tr&gt;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;*span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;重复零次或更多次span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;+span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;重复一次或更多次span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;?span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;重复零次或一次span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;{n}span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;重复n次span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;{n,}span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;重复n次或更多次span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;{n,m}span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;重复n到m次span&gt;td&gt;tr&gt;tbody&gt;table&gt;&lt;br&gt;&lt;span style=&quot; font-weight:bold; color:Red;&quot;&gt;常用反义词span&gt;&lt;br&gt;&lt;table cellspacing=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;代码/语法th&gt;&lt;th scope=&quot;col&quot;&gt;说明th&gt;tr&gt;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\Wspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配任意不是字母，数字，下划线，汉字的字符span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\Sspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配任意不是空白符的字符span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\Dspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配任意非数字的字符span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;\Bspan&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配不是单词开头或结束的位置span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;[^x]span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配除了x以外的任意字符span&gt;td&gt;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=&quot;code&quot;&gt;[^aeiou]span&gt;td&gt;&lt;td&gt;&lt;span class=&quot;desc&quot;&gt;匹配除了aeiou这几个字母以外的任意字符span&gt;td&gt;tr&gt;tbody&gt;table&gt;&lt;br&gt;
                        span&gt;
                    div&gt;
                div&gt;
                &lt;div style=&quot; height:5px;&quot;&gt;div&gt;
            div&gt;
        div&gt;
    div&gt;
body&gt;
html&gt;--&gt;
</code></pre>

<p>正则表达式在线测试</p>

<pre><code>/* utf-8: 0xc0, 0xe0, 0xf0, 0xf8, 0xfc

char str[] = &quot;hello,中文字&quot;, len = strlen(str);
int utf8CharLen;
for (int i = 0, utf8CharLen; i &lt; len; i += utf8CharLen)
{
utf8CharLen = BYTE_WIDTH_UTF8(str[i]);
printf(&quot;str[%d] is a word character with %d bytes\n&quot;, i, utf8CharLen);
}
*/
unsigned char mblen_table_utf8[] =
{
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 1, 1
};

#define BYTE_WIDTH_UTF8(x)  mblen_table_utf8[(unsigned char)(x)]

int _tmain(int argc, _TCHAR* argv[])
{
    char str[] = &quot;hello,中文字&quot;, len = strlen(str);
    int utf8CharLen;
    for (int i = 0, utf8CharLen; i &lt; len; i += utf8CharLen)
    {
        utf8CharLen = BYTE_WIDTH_UTF8(str[i]);
        printf(&quot;str[%d] is a word character with %d bytes\n&quot;, i, utf8CharLen);
    }
    getchar();
}
</code></pre>

<p>下面</p>

<p>比如某二进制字节是UTF-8编码的字符串的实际字节，则作用和public String(byte bytes[], String
charsetName)取codePoint类似</p>

<pre><code>/* UTF8 utilities */

/* This parses a UTF8 string one character at a time. It is passed a pointer
 * to the string and the length of the string. It sets 'value' to the value of
 * the current character. It returns the number of characters read or a
 * negative error code:
 * -1 = string too short
 * -2 = illegal character
 * -3 = subsequent characters not of the form 10xxxxxx
 * -4 = character encoded incorrectly (not minimal length).
 */

int UTF8_getc(const unsigned char *str, int len, unsigned long *val)
{
    const unsigned char *p;
    unsigned long value;
    int ret;
    if(len &lt;= 0) return 0;
    p = str;

    /* Check syntax and work out the encoded value (if correct) */
    if((*p &amp; 0x80) == 0) {
        value = *p++ &amp; 0x7f;
        ret = 1;
    } else if((*p &amp; 0xe0) == 0xc0) {
        if(len &lt; 2) return -1;
        if((p[1] &amp; 0xc0) != 0x80) return -3;
        value = (*p++ &amp; 0x1f) &lt;&lt; 6;
        value |= *p++ &amp; 0x3f;
        if(value &lt; 0x80) return -4;
        ret = 2;
    } else if((*p &amp; 0xf0) == 0xe0) {
        if(len &lt; 3) return -1;
        if( ((p[1] &amp; 0xc0) != 0x80)
           || ((p[2] &amp; 0xc0) != 0x80) ) return -3;
        value = (*p++ &amp; 0xf) &lt;&lt; 12;
        value |= (*p++ &amp; 0x3f) &lt;&lt; 6;
        value |= *p++ &amp; 0x3f;
        if(value &lt; 0x800) return -4;
        ret = 3;
    } else if((*p &amp; 0xf8) == 0xf0) {
        if(len &lt; 4) return -1;
        if( ((p[1] &amp; 0xc0) != 0x80)
           || ((p[2] &amp; 0xc0) != 0x80)
           || ((p[3] &amp; 0xc0) != 0x80) ) return -3;
        value = ((unsigned long)(*p++ &amp; 0x7)) &lt;&lt; 18;
        value |= (*p++ &amp; 0x3f) &lt;&lt; 12;
        value |= (*p++ &amp; 0x3f) &lt;&lt; 6;
        value |= *p++ &amp; 0x3f;
        if(value &lt; 0x10000) return -4;
        ret = 4;
    } else if((*p &amp; 0xfc) == 0xf8) {
        if(len &lt; 5) return -1;
        if( ((p[1] &amp; 0xc0) != 0x80)
           || ((p[2] &amp; 0xc0) != 0x80)
           || ((p[3] &amp; 0xc0) != 0x80)
           || ((p[4] &amp; 0xc0) != 0x80) ) return -3;
        value = ((unsigned long)(*p++ &amp; 0x3)) &lt;&lt; 24;
        value |= ((unsigned long)(*p++ &amp; 0x3f)) &lt;&lt; 18;
        value |= ((unsigned long)(*p++ &amp; 0x3f)) &lt;&lt; 12;
        value |= (*p++ &amp; 0x3f) &lt;&lt; 6;
        value |= *p++ &amp; 0x3f;
        if(value &lt; 0x200000) return -4;
        ret = 5;
    } else if((*p &amp; 0xfe) == 0xfc) {
        if(len &lt; 6) return -1;
        if( ((p[1] &amp; 0xc0) != 0x80)
           || ((p[2] &amp; 0xc0) != 0x80)
           || ((p[3] &amp; 0xc0) != 0x80)
           || ((p[4] &amp; 0xc0) != 0x80)
           || ((p[5] &amp; 0xc0) != 0x80) ) return -3;
        value = ((unsigned long)(*p++ &amp; 0x1)) &lt;&lt; 30;
        value |= ((unsigned long)(*p++ &amp; 0x3f)) &lt;&lt; 24;
        value |= ((unsigned long)(*p++ &amp; 0x3f)) &lt;&lt; 18;
        value |= ((unsigned long)(*p++ &amp; 0x3f)) &lt;&lt; 12;
        value |= (*p++ &amp; 0x3f) &lt;&lt; 6;
        value |= *p++ &amp; 0x3f;
        if(value &lt; 0x4000000) return -4;
        ret = 6;
    } else return -2;
    *val = value;
    return ret;
}

/* This takes a character 'value' and writes the UTF8 encoded value in
 * 'str' where 'str' is a buffer containing 'len' characters. Returns
 * the number of characters written or -1 if 'len' is too small. 'str' can
 * be set to NULL in which case it just returns the number of characters.
 * It will need at most 6 characters.
 */

int UTF8_putc(unsigned char *str, int len, unsigned long value)
{
    if(!str) len = 6;    /* Maximum we will need */
    else if(len &lt;= 0) return -1;
    if(value &lt; 0x80) {
        if(str) *str = (unsigned char)value;
        return 1;
    }
    if(value &lt; 0x800) {
        if(len &lt; 2) return -1;
        if(str) {
            *str++ = (unsigned char)(((value &gt;&gt; 6) &amp; 0x1f) | 0xc0);
            *str = (unsigned char)((value &amp; 0x3f) | 0x80);
        }
        return 2;
    }
    if(value &lt; 0x10000) {
        if(len &lt; 3) return -1;
        if(str) {
            *str++ = (unsigned char)(((value &gt;&gt; 12) &amp; 0xf) | 0xe0);
            *str++ = (unsigned char)(((value &gt;&gt; 6) &amp; 0x3f) | 0x80);
            *str = (unsigned char)((value &amp; 0x3f) | 0x80);
        }
        return 3;
    }
    if(value &lt; 0x200000) {
        if(len &lt; 4) return -1;
        if(str) {
            *str++ = (unsigned char)(((value &gt;&gt; 18) &amp; 0x7) | 0xf0);
            *str++ = (unsigned char)(((value &gt;&gt; 12) &amp; 0x3f) | 0x80);
            *str++ = (unsigned char)(((value &gt;&gt; 6) &amp; 0x3f) | 0x80);
            *str = (unsigned char)((value &amp; 0x3f) | 0x80);
        }
        return 4;
    }
    if(value &lt; 0x4000000) {
        if(len &lt; 5) return -1;
        if(str) {
            *str++ = (unsigned char)(((value &gt;&gt; 24) &amp; 0x3) | 0xf8);
            *str++ = (unsigned char)(((value &gt;&gt; 18) &amp; 0x3f) | 0x80);
            *str++ = (unsigned char)(((value &gt;&gt; 12) &amp; 0x3f) | 0x80);
            *str++ = (unsigned char)(((value &gt;&gt; 6) &amp; 0x3f) | 0x80);
            *str = (unsigned char)((value &amp; 0x3f) | 0x80);
        }
        return 5;
    }
    if(len &lt; 6) return -1;
    if(str) {
        *str++ = (unsigned char)(((value &gt;&gt; 30) &amp; 0x1) | 0xfc);
        *str++ = (unsigned char)(((value &gt;&gt; 24) &amp; 0x3f) | 0x80);
        *str++ = (unsigned char)(((value &gt;&gt; 18) &amp; 0x3f) | 0x80);
        *str++ = (unsigned char)(((value &gt;&gt; 12) &amp; 0x3f) | 0x80);
        *str++ = (unsigned char)(((value &gt;&gt; 6) &amp; 0x3f) | 0x80);
        *str = (unsigned char)((value &amp; 0x3f) | 0x80);
    }
    return 6;
}
</code></pre>

<p><a href="http://www.leonerd.org.uk/code/libtickit/doc/">http://www.leonerd.org.uk/code/libtickit/doc/</a></p>

<p>tickit_string_putchar(3) | tickit_string_putchar - append a UTF-8 encoded
codepoint to a buffer<br />
&mdash;|&mdash;<br />
tickit_string_seqlen(3) | tickit_string_seqlen - determine the length of a
UTF-8 codepoint encoding</p>

<pre><code>static int next_utf8(const char *str, size_t len, uint32_t *cp)
{
  unsigned char b0 = (str++)[0];
  int nbytes;

  if(!len)
    return -1;

  if(!b0)
    return -1;
  else if(b0 &lt; 0x80) { // ASCII
    *cp = b0; return 1;
  }
  else if(b0 &lt; 0xc0) // C1 or continuation
    return -1;
  else if(b0 &lt; 0xe0) {
    nbytes = 2; *cp = b0 &amp; 0x1f;
  }
  else if(b0 &lt; 0xf0) {
    nbytes = 3; *cp = b0 &amp; 0x0f;
  }
  else if(b0 &lt; 0xf8) {
    nbytes = 4; *cp = b0 &amp; 0x07;
  }
  else
    return -1;

  if(len &lt; nbytes)
    return -1;

  for(int i = 1; i &lt; nbytes; i++) {
    b0 = (str++)[0];
    if(!b0)
      return -1;

    *cp &lt;&lt;= 6;
    *cp |= b0 &amp; 0x3f;
  }

  return nbytes;
}

int tickit_string_seqlen(long codepoint)
{
  if(codepoint &lt; 0x0000080) return 1;
  if(codepoint &lt; 0x0000800) return 2;
  if(codepoint &lt; 0x0010000) return 3;
  if(codepoint &lt; 0x0200000) return 4;
  if(codepoint &lt; 0x4000000) return 5;
  return 6;
}

size_t tickit_string_putchar(char *str, size_t len, long codepoint)
{
  int nbytes = tickit_string_seqlen(codepoint);
  if(!str)
    return nbytes;
  if(len &lt; nbytes)
    return -1;

  // This is easier done backwards
  int b = nbytes;
  while(b &gt; 1) {
    b--;
    str[b] = 0x80 | (codepoint &amp; 0x3f);
    codepoint &gt;&gt;= 6;
  }

  switch(nbytes) {
    case 1: str[0] =        (codepoint &amp; 0x7f); break;
    case 2: str[0] = 0xc0 | (codepoint &amp; 0x1f); break;
    case 3: str[0] = 0xe0 | (codepoint &amp; 0x0f); break;
    case 4: str[0] = 0xf0 | (codepoint &amp; 0x07); break;
    case 5: str[0] = 0xf8 | (codepoint &amp; 0x03); break;
    case 6: str[0] = 0xfc | (codepoint &amp; 0x01); break;
  }

  return nbytes;
}
</code></pre>

<p>由codePoint计算这个值转化为UTF8应该占几个字节</p>

<pre><code>/* The following functions copied and adapted from libtermkey
 *
 * http://www.leonerd.org.uk/code/libtermkey/
 */
static inline unsigned int utf8_seqlen(long codepoint)
{
  if(codepoint &lt; 0x0000080) return 1;
  if(codepoint &lt; 0x0000800) return 2;
  if(codepoint &lt; 0x0010000) return 3;
  if(codepoint &lt; 0x0200000) return 4;
  if(codepoint &lt; 0x4000000) return 5;
  return 6;
}

/* Does NOT NUL-terminate the buffer */
static int fill_utf8(long codepoint, char *str)
{
  int nbytes = utf8_seqlen(codepoint);

  // This is easier done backwards
  int b = nbytes;
  while(b &gt; 1) {
    b--;
    str[b] = 0x80 | (codepoint &amp; 0x3f);
    codepoint &gt;&gt;= 6;
  }

  switch(nbytes) {
    case 1: str[0] =        (codepoint &amp; 0x7f); break;
    case 2: str[0] = 0xc0 | (codepoint &amp; 0x1f); break;
    case 3: str[0] = 0xe0 | (codepoint &amp; 0x0f); break;
    case 4: str[0] = 0xf0 | (codepoint &amp; 0x07); break;
    case 5: str[0] = 0xf8 | (codepoint &amp; 0x03); break;
    case 6: str[0] = 0xfc | (codepoint &amp; 0x01); break;
  }

  return nbytes;
}
/* end copy */
</code></pre>

<p>liblinebreak-2.0 : Line breaking in a Unicode sequence. Designed to be used in
a generic text renderer.</p>

<pre><code>typedef unsigned char    utf8_t;        /**&lt; Type for UTF-8 data points */
typedef unsigned short    utf16_t;    /**&lt; Type for UTF-16 data points */
typedef unsigned int    utf32_t;    /**&lt; Type for UTF-32 data points */


/**
 * Gets the next Unicode character in a UTF-8 sequence.  The index will
 * be advanced to the next complete character, unless the end of string
 * is reached in the middle of a UTF-8 sequence.
 *
 * @param[in]     s        input UTF-8 string
 * @param[in]     len    length of the string in bytes
 * @param[in,out] ip    pointer to the index
 * @return                the Unicode character beginning at the index; or
 *                        #EOS if end of input is encountered
 */
utf32_t lb_get_next_char_utf8(
        const utf8_t *s,
        size_t len,
        size_t *ip)
{
    utf8_t ch;
    utf32_t res;

    assert(*ip &lt;= len);
    if (*ip == len)
        return EOS;
    ch = s[*ip];

    if (ch &lt; 0xC2 || ch &gt; 0xF4)
    {    /* One-byte sequence, tail (should not occur), or invalid */
        *ip += 1;
        return ch;
    }
    else if (ch &lt; 0xE0)
    {    /* Two-byte sequence */
        if (*ip + 2 &gt; len)
            return EOS;
        res = ((ch &amp; 0x1F) &lt;&lt; 6) + (s[*ip + 1] &amp; 0x3F);
        *ip += 2;
        return res;
    }
    else if (ch &lt; 0xF0)
    {    /* Three-byte sequence */
        if (*ip + 3 &gt; len)
            return EOS;
        res = ((ch &amp; 0x0F) &lt;&lt; 12) +
              ((s[*ip + 1] &amp; 0x3F) &lt;&lt; 6) +
              ((s[*ip + 2] &amp; 0x3F));
        *ip += 3;
        return res;
    }
    else
    {    /* Four-byte sequence */
        if (*ip + 4 &gt; len)
            return EOS;
        res = ((ch &amp; 0x07) &lt;&lt; 18) +
              ((s[*ip + 1] &amp; 0x3F) &lt;&lt; 12) +
              ((s[*ip + 2] &amp; 0x3F) &lt;&lt; 6) +
              ((s[*ip + 3] &amp; 0x3F));
        *ip += 4;
        return res;
    }
}

/**
 * Gets the next Unicode character in a UTF-16 sequence.  The index will
 * be advanced to the next complete character, unless the end of string
 * is reached in the middle of a UTF-16 surrogate pair.
 *
 * @param[in]     s        input UTF-16 string
 * @param[in]     len    length of the string in words
 * @param[in,out] ip    pointer to the index
 * @return                the Unicode character beginning at the index; or
 *                        #EOS if end of input is encountered
 */
utf32_t lb_get_next_char_utf16(
        const utf16_t *s,
        size_t len,
        size_t *ip)
{
    utf16_t ch;

    assert(*ip &lt;= len);
    if (*ip == len)
        return EOS;
    ch = s[(*ip)++];

    if (ch &lt; 0xD800 || ch &gt; 0xDBFF)
    {    /* If the character is not a high surrogate */
        return ch;
    }
    if (*ip == len)
    {    /* If the input ends here (an error) */
        --(*ip);
        return EOS;
    }
    if (s[*ip] &lt; 0xDC00 || s[*ip] &gt; 0xDFFF)
    {    /* If the next character is not the low surrogate (an error) */
        return ch;
    }
    /* Return the constructed character and advance the index again */
    return (((utf32_t)ch &amp; 0x3FF) &lt;&lt; 10) + (s[(*ip)++] &amp; 0x3FF) + 0x10000;
}

/**
 * Gets the next Unicode character in a UTF-32 sequence.  The index will
 * be advanced to the next character.
 *
 * @param[in]     s        input UTF-32 string
 * @param[in]     len    length of the string in dwords
 * @param[in,out] ip    pointer to the index
 * @return                the Unicode character beginning at the index; or
 *                        #EOS if end of input is encountered
 */
utf32_t lb_get_next_char_utf32(
        const utf32_t *s,
        size_t len,
        size_t *ip)
{
    assert(*ip &lt;= len);
    if (*ip == len)
        return EOS;
    return s[(*ip)++];
}
</code></pre>

<p>java String 的内部是char[]，char数组，char是16比特，2字节。，某字符，如汉字“中”，UTF-8编码时，字节数组为{-28,
-72, -83}。</p>

<p>在java中用String表示则内部char[]为{0x4e2d}，长度为1；而在c中用char[]或char*表示则直接为{-28, -72,
-83}，长度为3</p>

<pre><code>        String one = &quot;中&quot;;
        int unicodeCodeUnitCount = one.length();//
        String unicodeCodePointValue = Integer.toHexString(one.codePointAt(0));// Unicode编码值
        byte[] storedBytesUtf8 = one.getBytes();// 如果按UTF-8（默认）编码存储需要的字节存储情况
        char char16Bit = one.charAt(0);

        System.out.println(&quot;sizeof char = &quot; + Character.SIZE + &quot; (bytes in Java)&quot;);
        System.out.println(&quot;one.length() = &quot; + unicodeCodeUnitCount + &quot;, one.codePointAt(0) = &quot; + unicodeCodePointValue);
        System.out.println(&quot;one.getBytes().length() = &quot; + storedBytesUtf8.length + &quot; : &quot; + bytesToHexString(storedBytesUtf8)
                + &quot;, &quot; + Arrays.toString(storedBytesUtf8));
        System.out.println(&quot;one.charAt(0) = &quot; + char16Bit + &quot; = &quot; + Integer.toBinaryString(char16Bit) + &quot; = &quot;
                + Integer.toHexString(char16Bit));
        System.out.println(Character.charCount(char16Bit));

        System.out.println(Integer.toHexString(new String(new byte[] { -28, -72, -83 }).charAt(0)));

        // sizeof char = 16 (bytes in Java)
        // one.length() = 1, one.codePointAt(0) = 4e2d
        // one.getBytes().length() = 3 : e4b8ad, [-28, -72, -83]
        // one.charAt(0) = 中 = 100111000101101 = 4e2d
</code></pre>

<blockquote>
<p>Unicode符号范围 | UTF-8编码方式（变长编码）<br />
 (十六进制) | 字节数| 首字节范围 | 二进制</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
0000 0000 - 0000 007F | 单字节 [0x00, 0x7F] 0xxxxxxx<br />
0000 0080 - 0000 07FF | 两字节 [0xC0, 0xE0) 110xxxxx 10xxxxxx<br />
0000 0800 - 0000 FFFF | 三字节 [0xE0, 0xF0) 1110xxxx 10xxxxxx 10xxxxxx<br />
0001 0000 - 001F FFFF | 四字节 [0xF0, 0xF8) 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br />
0020 0000 - 03FF FFFF | 五字节 [0xF8, 0xFC) 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
10xxxxxx<br />
0400 0000 - 7FFF FFFF | 六字节 [0xFC, 0xFE) 1111110x 10xxxxxx 10xxxxxx 10xxxxxx
10xxxxxx 10xxxxxx</p>
</blockquote>

<p>2</p>

<p>Unicode符号范围</p>

<p>|</p>

<p>UTF-8编码方式（变长编码）</p>

<p>&mdash;|&mdash;</p>

<p>十六进制</p>

<p>|</p>

<p>Bytes</p>

<p>|</p>

<p>首字节范围</p>

<p>|</p>

<p>二进制</p>

<p>0000 0000 - 0000 007F</p>

<p>|</p>

<p>单字节</p>

<p>|</p>

<p>[0x00, 0x7F]</p>

<p>|</p>

<p>0xxxxxxx</p>

<p>0000 0080 - 0000 07FF</p>

<p>|</p>

<p>两字节</p>

<p>|</p>

<p>[0xC0, 0xE0)</p>

<p>|</p>

<p>110xxxxx 10xxxxxx</p>

<p>0000 0800 - 0000 FFFF</p>

<p>|</p>

<p>三字节</p>

<p>|</p>

<p>[0xE0, 0xF0)</p>

<p>|</p>

<p>1110xxxx 10xxxxxx 10xxxxxx</p>

<p>0001 0000 - 001F FFFF</p>

<p>|</p>

<p>四字节</p>

<p>|</p>

<p>[0xF0, 0xF8)</p>

<p>|</p>

<p>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>

<p>0020 0000 - 03FF FFFF</p>

<p>|</p>

<p>五字节</p>

<p>|</p>

<p>[0xF8, 0xFC)</p>

<p>|</p>

<p>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</p>

<p>0400 0000 - 7FFF FFFF</p>

<p>|</p>

<p>六字节</p>

<p>|</p>

<p>[0xFC, 0xFE)</p>

<p>|</p>

<p>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</p>

<p><a href="http://ideone.com/">http://ideone.com/</a></p>

<pre><code>#include 

typedef unsigned char    utf8_t;        //&lt; Type for UTF-8 data points
typedef unsigned short    utf16_t;    //&lt; Type for UTF-16 data points
typedef unsigned int    utf32_t;    //&lt; Type for UTF-32 data points

#define STRING_TOO_SHORT (-1)        //string too short
#define ILLEGAL_CHARACTER (-2)        //illegal character not starts with 0xxxxxxx, 110xxxxx, 1110xxxx, etc.
#define UNEXPECTED_CHARACTER (-3)    //subsequent characters not of the form 10xxxxxx
//- 4 = character encoded incorrectly(not minimal length).

//   Unicode符号范围    |  UTF-8编码方式（变长编码）
//      (十六进制)      | 字节数| 首字节范围 | 二进制
//----------------------+-------+------------+-----------------------------------------------------
//0000 0000 - 0000 007F | 单字节 [0x00, 0x7F] 0xxxxxxx
//0000 0080 - 0000 07FF | 两字节 [0xC0, 0xE0) 110xxxxx 10xxxxxx
//0000 0800 - 0000 FFFF | 三字节 [0xE0, 0xF0) 1110xxxx 10xxxxxx 10xxxxxx
//0001 0000 - 001F FFFF | 四字节 [0xF0, 0xF8) 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
//0020 0000 - 03FF FFFF | 五字节 [0xF8, 0xFC) 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
//0400 0000 - 7FFF FFFF | 六字节 [0xFC, 0xFE) 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

static inline size_t utf8_seqlen(utf32_t codepoint)
{
    if (codepoint &lt; 0x0000080) return 1;
    if (codepoint &lt; 0x0000800) return 2;
    if (codepoint &lt; 0x0010000) return 3;
    if (codepoint &lt; 0x0200000) return 4;
    if (codepoint &lt; 0x4000000) return 5;
    return 6;
}

static size_t utf8_putc(char *str, size_t len, utf32_t codepoint)
{
    int nbytes = utf8_seqlen(codepoint);
    if (!str)
        return nbytes;
    if (len &lt; nbytes)
        return -1;

    // This is easier done backwards
    int b = nbytes;
    while (b &gt; 1) {
        b--;
        str[b] = 0x80 | (codepoint &amp; 0x3f);
        codepoint &gt;&gt;= 6;
    }

    switch (nbytes) {
    case 1: str[0] = (codepoint &amp; 0x7f); break;
    case 2: str[0] = 0xc0 | (codepoint &amp; 0x1f); break;
    case 3: str[0] = 0xe0 | (codepoint &amp; 0x0f); break;
    case 4: str[0] = 0xf0 | (codepoint &amp; 0x07); break;
    case 5: str[0] = 0xf8 | (codepoint &amp; 0x03); break;
    case 6: str[0] = 0xfc | (codepoint &amp; 0x01); break;
    }

    return nbytes;
}

//static unsigned char utf8_b0masks[] = { 0x1f, 0x0f, 0x07, 0x03, 0x01};
//#define utf8_extra_first_byte(nbytes) utf8_b0masks[nbytes - 2]

//It returns the number of characters read or a negative error code
static size_t utf8_getc(const utf8_t *str, size_t len, utf32_t  *cp)
{
    unsigned char b0 = (str++)[0], b0mask;
    int nbytes;//UTF-8编码下一个字符占有多少字节

    if (b0 &lt; 0x80) { // ASCII
        //nbytes = 1;
        if (len &gt;= 1){
            *cp = b0; return 1;
        }
        return STRING_TOO_SHORT;
    }else if (b0 &lt; 0xc0){ // C1 or continuation
        return ILLEGAL_CHARACTER;
    }else if (b0 &lt; 0xe0) {
        nbytes = 2; b0mask = 0x1f;
    }else if (b0 &lt; 0xf0) {
        nbytes = 3; b0mask = 0x0f;
    }else if (b0 &lt; 0xf8) {
        nbytes = 4; b0mask = 0x07;
    }else if (b0 &lt; 0xfc){
        nbytes = 5; b0mask = 0x03;
    }else if (b0 &lt; 0xfe){
        nbytes = 6; b0mask = 0x01;
    }else
        return ILLEGAL_CHARACTER;

    if (len &lt; nbytes)
        return STRING_TOO_SHORT;

    *cp = b0 &amp; b0mask;
    for (int i = 1; i &lt; nbytes; i++) {
        b0 = (str++)[0];
        if ((b0 &amp; 0xc0) != 0x80) 
            return UNEXPECTED_CHARACTER;
        *cp &lt;&lt;= 6;
        *cp |= b0 &amp; 0x3f;
    }

    return nbytes;
}


int main(void) {
    // your code goes here
    utf32_t cp;
    size_t seqlen = utf8_getc(&quot;22&quot;, 2, &amp;cp);
    printf(&quot;%d, %d&quot;, seqlen, cp);
    return 0;
}
</code></pre>

<p>2</p>

<p>转载于:<a href="https://www.cnblogs.com/Fang3s/p/4414914.html">https://www.cnblogs.com/Fang3s/p/4414914.html</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>