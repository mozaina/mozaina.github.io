<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>2018814日预习笔记shell基础知识 | 开发者问答集锦</title>
    <meta property="og:title" content="2018814日预习笔记shell基础知识 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="2018814日预习笔记shell基础知识">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/2018814%E6%97%A5%E9%A2%84%E4%B9%A0%E7%AC%94%E8%AE%B0shell%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">2018814日预习笔记shell基础知识</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>笔记目录</p>

<ol>
<li>1.shell特殊符cut命令（上）</li>
<li>2.sortwcuniq命令</li>
<li>3.teetr_split命令</li>
<li>4.shell特殊符号（下）</li>
<li>关于PROMPT_COMMAND环境变量的含义</li>
<li>source exec 的区别</li>
<li>linux特殊符号大全</li>
<li>sort并未按ASCLL排序</li>
<li>简易审计系统</li>
</ol>

<p><strong>一.shell特殊符_cut命令（上）</strong></p>

<p><a href="https://img.it610.com/image/info8/a7d38bd3da004589a5c07496c4e433a9.jpg"><img src="https://img.it610.com/image/info8/a7d38bd3da004589a5c07496c4e433a9.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第1张图片" /></a></p>

<ul>
<li>*通配符，任意个任意字符</li>
<li>？任意一个字符</li>
<li>#注释字符，后面内容为解释说明</li>
<li>\脱义字符，取消掉他的原义</li>
<li>|管道符</li>
<li><strong>关于管道符的一些命令：</strong></li>
</ul>

<p><a href="https://img.it610.com/image/info8/c062adab6b314097b12f33362b296b1b.jpg"><img src="https://img.it610.com/image/info8/c062adab6b314097b12f33362b296b1b.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第2张图片" /></a></p>

<ul>
<li>cut分割</li>
</ul>

<p><a href="https://img.it610.com/image/info8/e6df8713d765457d9e275d3614781692.jpg"><img src="https://img.it610.com/image/info8/e6df8713d765457d9e275d3614781692.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第3张图片" /></a></p>

<ul>
<li>#cut -c 制定第几个字符</li>
</ul>

<p><a href="https://img.it610.com/image/info8/ee158bd7abb34ec09c2711f654d5ad90.jpg"><img src="https://img.it610.com/image/info8/ee158bd7abb34ec09c2711f654d5ad90.jpg" alt="8e34ac5c898dee8ef501d29d08c472829b8.jpg" /></a></p>

<p><strong>二.sort_ _wc__ uniq命令</strong></p>

<ul>
<li>#sort命令，用来排序</li>
</ul>

<p><img src="https://img.it610.com/image/info8/6692cde98a234fdca2f5e65371d6aa18.jpg" alt="66c63b0306af917f0922a448ac811896ad8.jpg" /></p>

<ul>
<li>#sort默认是阿斯玛排序</li>
</ul>

<p><a href="https://img.it610.com/image/info8/944b141d2cf746a0b17cd27c554d1dec.jpg"><img src="https://img.it610.com/image/info8/944b141d2cf746a0b17cd27c554d1dec.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第4张图片" /></a></p>

<ul>
<li>#sort -n 按照数字排序，字母会被认为是0，特殊字符在最前面</li>
</ul>

<p><a href="https://img.it610.com/image/info8/ee140fb0982f4ab298e6228ac9546176.jpg"><img src="https://img.it610.com/image/info8/ee140fb0982f4ab298e6228ac9546176.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第5张图片" /></a></p>

<ul>
<li>#sort -r 会反序排列</li>
</ul>

<p><a href="https://img.it610.com/image/info8/8cc1ae0ec79a41ada51f77ca2f0e07b2.jpg"><img src="https://img.it610.com/image/info8/8cc1ae0ec79a41ada51f77ca2f0e07b2.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第6张图片" /></a></p>

<ul>
<li>#sort -t 分隔符</li>
<li>#wc -l 用来统计行数</li>
</ul>

<p><img src="https://img.it610.com/image/info8/81bed2a99dca43cc8b97d6ef48fbea89.jpg" alt="9e6e068efeca921c6267aab071e88317168.jpg" /></p>

<ul>
<li>#wc -m 用来统计字符数</li>
</ul>

<p><a href="https://img.it610.com/image/info8/5e840fad8e0043298bb84935a0c67057.jpg"><img src="https://img.it610.com/image/info8/5e840fad8e0043298bb84935a0c67057.jpg" alt="eca1c555dca5b673551d134816529324d98.jpg" /></a></p>

<ul>
<li>#wc -w 用来统计词</li>
</ul>

<p><a href="https://img.it610.com/image/info8/455b130fc39c417c9656cdef950167a7.jpg"><img src="https://img.it610.com/image/info8/455b130fc39c417c9656cdef950167a7.jpg" alt="d3b26e3278bdd0f0761bd8c7608add29733.jpg" /></a></p>

<ul>
<li>#uniq 去重，但是要先排序才能去重，如下列：</li>
</ul>

<p><a href="https://img.it610.com/image/info8/b8a81409c1f4400383665d595936d4d1.jpg"><img src="https://img.it610.com/image/info8/b8a81409c1f4400383665d595936d4d1.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第7张图片" /></a></p>

<ul>
<li>多数用法如下：</li>
<li>先用#sort排序，再去重</li>
</ul>

<p><a href="https://img.it610.com/image/info8/a64377ca41664885a92ad7379b53b08a.jpg"><img src="https://img.it610.com/image/info8/a64377ca41664885a92ad7379b53b08a.jpg" alt="4ac5481bb22603ac0389534576d4eb112e9.jpg" /></a></p>

<ul>
<li>先用#sort排序，再统计行数</li>
</ul>

<p><a href="https://img.it610.com/image/info8/d0cdd69d40a342d99cf017cf2f131a3c.jpg"><img src="https://img.it610.com/image/info8/d0cdd69d40a342d99cf017cf2f131a3c.jpg" alt="ba69781ae6f03ff33c9a0f1edc8df1ff3f7.jpg" /></a></p>

<p><strong>三.tee_ _tr__ split命令</strong></p>

<ul>
<li>#tee 重定向并将内容打印到屏幕上</li>
</ul>

<p><a href="https://img.it610.com/image/info8/47401a3e9df748bbb9529ad1b1e673b2.jpg"><img src="https://img.it610.com/image/info8/47401a3e9df748bbb9529ad1b1e673b2.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第8张图片" /></a></p>

<ul>
<li>#tee -a 追加内容</li>
</ul>

<p><a href="https://img.it610.com/image/info8/d891a11612f1432caa67aae6a07ae9c1.jpg"><img src="https://img.it610.com/image/info8/d891a11612f1432caa67aae6a07ae9c1.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第9张图片" /></a></p>

<ul>
<li>#tr 用来替换字符</li>
</ul>

<p><a href="https://img.it610.com/image/info8/9c6fb82fce9d4b55940596a917dde6f2.jpg"><img src="https://img.it610.com/image/info8/9c6fb82fce9d4b55940596a917dde6f2.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第10张图片" /></a></p>

<ul>
<li>#split 切割文件，将大文件切割成小文件</li>
<li>split -b 指定它的大小，默认为字节</li>
</ul>

<p><a href="https://img.it610.com/image/info8/600c986d395b486f986ca5bb1ae69613.jpg"><img src="https://img.it610.com/image/info8/600c986d395b486f986ca5bb1ae69613.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第11张图片" /></a></p>

<ul>
<li>#split -l 指定它的行数</li>
</ul>

<p><a href="https://img.it610.com/image/info8/1ccd5586f78b4d61877405466166efde.jpg"><img src="https://img.it610.com/image/info8/1ccd5586f78b4d61877405466166efde.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第12张图片" /></a></p>

<ul>
<li>#split -b 100k a.txt abc 可以指定切割文件的前缀，默认是x开头</li>
</ul>

<p><a href="https://img.it610.com/image/info8/6fd14e47cb894915a3b45eab3e471575.jpg"><img src="https://img.it610.com/image/info8/6fd14e47cb894915a3b45eab3e471575.jpg" alt="d38ca519d9cfc6c006cd4f23df8769dddb0.jpg" /></a></p>

<p><strong>四.shell特殊符号（下）</strong></p>

<p><a href="https://img.it610.com/image/info8/42f1375d6b264411ab607cee707b7f9b.jpg"><img src="https://img.it610.com/image/info8/42f1375d6b264411ab607cee707b7f9b.jpg" alt="2018.8.14日，预习笔记，shell基础知识_第13张图片" /></a></p>

<ul>
<li>；多条命令写到一行，用分号分割</li>
</ul>

<p><a href="https://img.it610.com/image/info8/e64740b242674bbca8df69cbd823f173.jpg"><img src="https://img.it610.com/image/info8/e64740b242674bbca8df69cbd823f173.jpg" alt="ef6577558f0e0a01db5846d2f536c663c5b.jpg" /></a></p>

<ul>
<li>~表示用户的家目录，后面正则表达式表示匹配符</li>
<li>&amp;放到命令后面，会把命令丢到后台去</li>
<li>&gt; 正确输出重定向</li>
<li>&gt;&gt; 正确输出追加重定向</li>
<li>2&gt; 错误输出重定向</li>
<li>2&gt;&gt; 错误输出追加重定向</li>
<li>&amp;&gt; 正确和错误重定向</li>
<li>[]指定字符中的一个，[0-9][a-z][abc]</li>
<li>||在shell里表示或者，前面命令执行成功，则后面命令不执行；前面命令执行错误，则会继续执行后面的命令</li>
</ul>

<p><a href="https://img.it610.com/image/info8/e3dc991438774a68882df433ea2e6eb7.jpg"><img src="https://img.it610.com/image/info8/e3dc991438774a68882df433ea2e6eb7.jpg" alt="f75a669c12c2cd233ca941c7961d9c06b18.jpg" /></a></p>

<ul>
<li>&amp;&amp;表示或者，前面命令执行成功，则会继续执行后面命令；前面命令执行错误，则不会继续执行后面的命令</li>
</ul>

<p><a href="https://img.it610.com/image/info8/9746ca2cc3f84d54ad3ec9641cc15a25.jpg"><img src="https://img.it610.com/image/info8/9746ca2cc3f84d54ad3ec9641cc15a25.jpg" alt="6dc7d5f2a24bf7a926f534e2d446288326d.jpg" /></a></p>

<p><strong>试验一：</strong></p>

<p><a href="https://img.it610.com/image/info8/bdf2c23aaadb468187522dc47a5a9ca3.jpg"><img src="https://img.it610.com/image/info8/bdf2c23aaadb468187522dc47a5a9ca3.jpg" alt="0a80d612695ff782b444f9cafee9e2498f2.jpg" /></a></p>

<p><strong>五.关于PROMPT_COMMAND环境变量的含义</strong></p>

<ul>
<li><p>Bash 在显示 PS1 之前先执行 PROMPT_COMMAND 定义的内容：</p>

<p>ramesh@dev-db ~&gt; export PROMPT_COMMAND=&ldquo;date +%k:%m:%S&rdquo;</p></li>
</ul>

<p>22:08:42</p>

<pre><code>ramesh@dev-db ~&gt;
</code></pre>

<p>[注: PROMPT_COMMAND 和 PS1 在不同行显示]</p>

<ul>
<li><p>如果你想让 PROMPT_COMMAND 和PS1 在同一行显示，用 -n 参数即可：</p>

<p>ramesh@dev-db ~&gt;  export PROMPT_COMMAND=&ldquo;echo  -n [$(date+%k:%m:%S)]&rdquo;</p>

<p>[22:08:51]ramesh@dev-db ~&gt;</p></li>
</ul>

<p>[注: PROMPT_COMMAND 和 PS1 在同一行显示]</p>

<p><strong>六.</strong> <strong>source exec 的区别</strong></p>

<ul>
<li>fork ( /directory/script.sh) ：如果shell中包含执行命令，那么子命令并不影响父级的命令，在子命令执行完后再执行父级命令。子级的环境变量不会影响到父级。</li>
</ul>

<p>fork是最普通的, 就是直接在脚本里面用/directory/script.sh来调用script.sh这个脚本.</p>

<p>运行的时候开一个sub-shell执行调用的脚本，sub-shell执行的时候, parent-shell还在。</p>

<p>sub-shell执行完毕后返回parent-shell. sub-shell从parent-shell继承环境变量.但是sub-
shell中的环境变量不会带回parent-shell</p>

<ul>
<li>exec (exec /directory/script.sh)：执行子级的命令后，不再执行父级命令。</li>
</ul>

<p>exec与fork不同，不需要新开一个sub-shell来执行被调用的脚本.
被调用的脚本与父脚本在同一个shell内执行。但是使用exec调用一个新脚本以后,
父脚本中exec行之后的内容就不会再执行了。这是exec和source的区别</p>

<ul>
<li>source (source /directory/script.sh)：执行子级命令后继续执行父级命令，同时子级设置的环境变量会影响到父级的环境变量。</li>
</ul>

<p>与fork的区别是不新开一个sub-shell来执行被调用的脚本，而是在同一个shell中执行. 所以被调用的脚本中声明的变量和环境变量,
都可以在主脚本中得到和使用.</p>

<ul>
<li>可以通过下面这两个脚本来体会三种调用方式的不同:</li>
</ul>

<p><strong>1.sh</strong></p>

<p>#!/bin/bash</p>

<p>A=B</p>

<p>echo &ldquo;PID for 1.sh before exec/source/fork:$$&rdquo;</p>

<p>export A</p>

<p>echo &ldquo;1.sh: \$A is $A&rdquo;</p>

<p>case $1 in</p>

<p>exec)</p>

<p>echo &ldquo;using exec…&rdquo;</p>

<p>exec ./2.sh ;;</p>

<p>source)</p>

<p>echo &ldquo;using source…&rdquo;</p>

<p>. ./2.sh ;;</p>

<p>*)</p>

<p>echo &ldquo;using fork by default…&rdquo;</p>

<p>./2.sh ;;</p>

<p>esac</p>

<p>echo &ldquo;PID for 1.sh after exec/source/fork:$$&rdquo;</p>

<p>echo &ldquo;1.sh: \$A is $A&rdquo;</p>

<p><strong>2.sh</strong></p>

<p>#!/bin/bash</p>

<p>echo &ldquo;PID for 2.sh: $$&rdquo;</p>

<p>echo &ldquo;2.sh get \$A=$A from 1.sh&rdquo;</p>

<p>A=C</p>

<p>export A</p>

<p>echo &ldquo;2.sh: \$A is $A&rdquo;</p>

<p><strong>执行情况：</strong></p>

<p>$ ./1.sh</p>

<p>PID for 1.sh before exec/source/fork:5845364</p>

<p>1.sh: $A is B</p>

<p>using fork by default…</p>

<p>PID for 2.sh: 5242940</p>

<p>2.sh get $A=B from 1.sh</p>

<p>2.sh: $A is C</p>

<p>PID for 1.sh after exec/source/fork:5845364</p>

<p>1.sh: $A is B</p>

<p>$ ./1.sh exec</p>

<p>PID for 1.sh before exec/source/fork:5562668</p>

<p>1.sh: $A is B</p>

<p>using exec…</p>

<p>PID for 2.sh: 5562668</p>

<p>2.sh get $A=B from 1.sh</p>

<p>2.sh: $A is C</p>

<p>$ ./1.sh source</p>

<p>PID for 1.sh before exec/source/fork:5156894</p>

<p>1.sh: $A is B</p>

<p>using source…</p>

<p>PID for 2.sh: 5156894</p>

<p>2.sh get $A=B from 1.sh</p>

<p>2.sh: $A is C</p>

<p>PID for 1.sh after exec/source/fork:5156894</p>

<p>1.sh: $A is C</p>

<p>$</p>

<p>转自：<a href="http://blog.chinaunix.net/uid-22548820-id-3181798.html">http://blog.chinaunix.net/uid-22548820-id-3181798.html</a></p>

<p><strong>七.linux特殊符号大全</strong></p>

<p><strong>Linux特殊符号大全</strong></p>

<ul>
<li>在shell中常用的特殊符号罗列如下：

<br /></li>
</ul>

<h1 id="string-string-command">; ;; . , / \ &lsquo;string&rsquo;| ! $ ${} $? $$ $* &ldquo;string&rdquo;* ** ? : ^ $# $@ <code>command</code>{}</h1>

<p>[] [[]] () (()) || &amp;&amp; {xx,yy,zz,&hellip;}~ ~+ ~- &amp; &lt;&hellip;&gt; + - %= == !=</p>

<ul>
<li><strong># 井号 (comments)</strong></li>
</ul>

<p>这几乎是个满场都有的符号，除了先前已经提过的&rdquo;第一行&rdquo;<br />
#!/bin/bash<br />
井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。</p>

<h1 id="this-line-is-comments">This line is comments.</h1>

<p>echo &ldquo;a = $a&rdquo; # a = 0<br />
由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。<br />
#echo &ldquo;a = $a&rdquo; # a = 0<br />
如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。</p>

<ul>
<li><strong>~ 帐户的 home 目录</strong></li>
</ul>

<p>算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份：~/bin<br />
~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。</p>

<h1 id="echo-var-log">echo ~+/var/log</h1>

<p>~- 上次的工作目录，这个符号代表上次的工作目录。</p>

<h1 id="echo-etc-httpd-logs">echo ~-/etc/httpd/logs</h1>

<ul>
<li><strong>; 分号 (Command separator)</strong></li>
</ul>

<p>在 shell 中，担任&rdquo;连续指令&rdquo;功能的符号就是&rdquo;分号&rdquo;。譬如以下的例子：cd ~/backup ; mkdir startup ;cp ~/.*
startup/.</p>

<ul>
<li><strong>;; 连续分号 (Terminator)</strong></li>
</ul>

<p>专用在 case 的选项，担任 Terminator 的角色。<br />
case &ldquo;$fop&rdquo; inhelp) echo &ldquo;Usage: Command -help -version filename&rdquo;;;version)
echo &ldquo;version 0.1&rdquo; ;;esac</p>

<ul>
<li><strong>. 逗号 (dot,就是“点”)</strong></li>
</ul>

<p>在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。<br />
CDPATH=.:~:/home:/home/web:/var:/usr/local<br />
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。<br />
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regularexpression 中，一个
dot 代表匹配一个字元。</p>

<ul>
<li><strong>&lsquo;string&rsquo; 单引号 (single quote)</strong></li>
</ul>

<p>被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。<br />
heyyou=homeecho &lsquo;$heyyou&rsquo; # We get $heyyou</p>

<ul>
<li><strong>&ldquo;string&rdquo; 双引号 (double quote)</strong></li>
</ul>

<p>被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。<br />
heyyou=homeecho &ldquo;$heyyou&rdquo; # We get home</p>

<ul>
<li><strong><code>command</code> 倒引号 (backticks)</strong></li>
</ul>

<p>在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。<br />
fdv=<code>date +%F</code>echo &ldquo;Today $fdv&rdquo;<br />
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。</p>

<ul>
<li><strong>, 逗点 (comma，标点中的逗号)</strong></li>
</ul>

<p>这个符号常运用在运算当中当做&rdquo;区隔&rdquo;用途。如下例<br />
#!/bin/bashlet &ldquo;t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))&ldquo;echo &ldquo;t1= $t1, a =
$a, b = $b&rdquo;</p>

<ul>
<li><strong>/ 斜线 (forward slash)</strong></li>
</ul>

<p>在路径表示时，代表目录。<br />
cd /etc/rc.dcd ../..cd /<br />
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。<br />
let &ldquo;num1 = ((a = 10 / 2, b = 25 / 5))&rdquo;</p>

<ul>
<li><strong>\ 倒斜线</strong></li>
</ul>

<p>在交互模式下的escape 字元，有几个作用；放在指令前，有取消
aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。</p>

<h1 id="type-rmrm-is-aliased-to-rm-i-rm-log">type rmrm is aliased to `rm -i&rsquo;# \rm ./*.log</h1>

<p>上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。</p>

<h1 id="bkdir-home-echo-backup-dir-bkdir-bkdir-backup-dir-bkdir-home">bkdir=/home# echo &ldquo;Backup dir, \$bkdir = $bkdir&rdquo;Backup dir,$bkdir = /home</h1>

<p>上例 echo 内的 \$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容
/home。</p>

<ul>
<li><strong>| 管道 (pipeline)</strong></li>
</ul>

<p>pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。<br />
who | wc -l<br />
善用这个观念，对精简 script 有相当的帮助。</p>

<ul>
<li><strong>! 惊叹号(negate or reverse)</strong></li>
</ul>

<p>通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表&rdquo;不等于&rdquo;<br />
if [ &ldquo;$?&rdquo; != 0 ]thenecho &ldquo;Executes error&rdquo;exit 1fi<br />
在规则表达式中她担任 &ldquo;反逻辑&rdquo; 的角色<br />
ls a[!0-9]<br />
上例，代表显示除了a0, a1 &hellip;. a9 这几个文件的其他文件。</p>

<ul>
<li><strong>: 冒号</strong></li>
</ul>

<dl>
<dt>在 bash 中，这是一个内建指令：&rdquo;什么事都不干&rdquo;，但返回状态值 0。<br /></dt>
<dd>
echo $? # 回应为 0<br /></dd>
<dd>&gt; f.</dd>
</dl>

<p>上面这一行，相当于cat/dev/null&gt;f.</p>

<dl>
<dt>有时，也会出现以下这类的用法<br /></dt>
<dd><p>${HOSTNAME?} ${USER?} ${MAIL?}<br />
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或
if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。<br />
除了上述之外，还有一个地方必须使用冒号<br />
PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla<br />
在使用者自己的HOME 目录下的 .bash_profile或任何功能相似的档案中，设定关于&rdquo;路径&rdquo;的场合中，我们都使用冒号，来做区隔。</p>

<ul>
<li><strong>? 问号 (wild card)</strong></li>
</ul></dd>
</dl>

<p>使用冒号，来做区隔。</p>

<ul>
<li><strong>? 问号 (wild card)</strong></li>
</ul>

<p>在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。</p>

<h1 id="ls-a-a1">ls a?a1</h1>

<p>善用她的特点，可以做比较精确的档名匹配。</p>

<ul>
<li>*** 星号 (wild card)**</li>
</ul>

<p>相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。</p>

<h1 id="ls-a-a-a1-access-log">ls a*a a1 access_log</h1>

<p>在运算时，它则代表 &ldquo;乘法&rdquo;。<br />
let &ldquo;fmult=2*3&rdquo;<br />
除了内建指令 let，还有一个关于运算的指令expr，星号在这里也担任&rdquo;乘法&rdquo;的角色。不过在使用上得小心，他的前面必须加上escape 字元。</p>

<ul>
<li>**** 次方运算**</li>
</ul>

<p>两个星号在运算时代表 &ldquo;次方&rdquo; 的意思。<br />
let &ldquo;sus=2**3&rdquo;echo &ldquo;sus = $sus&rdquo; # sus = 8</p>

<ul>
<li><strong>$ 钱号(dollar sign)</strong></li>
</ul>

<p><em>变量替换</em> (Variable Substitution)的代表符号。<br />
vrs=123echo &ldquo;vrs = $vrs&rdquo; # vrs = 123<br />
另外，在 Regular Expressions 里被定义为 &ldquo;行&rdquo; 的最末端 (end-of-line)。这个常用在grep、sed、awk 以及
vim(vi) 当中。</p>

<ul>
<li><strong>${} 变量的正规表达式</strong></li>
</ul>

<p>bash 对 ${} 定义了不少用法。以下是取自线上说明的表列<br />
${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word}
${parameter:offset} ${parameter:offset:length} ${!prefix*} ${#parameter}
${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word}
${parameter/pattern/string} ${parameter//pattern/string}</p>

<p>_$*<br />
$* _引用script的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：<br />
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}&hellip;..<br />
个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。<br />
$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。<br />
echo &ldquo;$<em>&rdquo;<br />
还有一个与 $</em> 具有相同作用的符号，但效用与处理方式略为不同的符号。</p>

<p><em>$@</em><br />
$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。<br />
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。</p>

<p><em>$#</em><br />
这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。<br />
echo &ldquo;$#&rdquo;</p>

<ul>
<li><strong>$? 状态值 (status variable)</strong></li>
</ul>

<p>一般来说，UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。<br />
一般指令程序倘若执行成功，其回传值为 0；失败为 1。<br />
tar cvfz dfbackup.tar.gz /home/user &gt; /dev/nullecho&rdquo;$?&rdquo;</p>

<p>由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的PID。有时，script会需要产生临时文件，用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。符号</p>

<p>或许可以符合这种需求。它代表当前shell 的 PID。<br />
echo &ldquo;$HOSTNAME, $USER, $MAIL&rdquo; &gt; ftmp.$$<br />
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。<br />
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果script
执行完毕后仍不加以清除，会产生其他问题。</p>

<ul>
<li><strong>( ) 指令群组 (command group)</strong></li>
</ul>

<p>用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=<code>pwd</code> ;echo
$vcgh)，指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子</p>

<h1 id="cat-ftmp-01-bin-basha-fsh-a-incg-echo-e-n-a-n-echo">cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e &ldquo;\n $a \n&rdquo;)echo</h1>

<p>$a#./ftmp-01incgfsh<br />
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合，如运算式。</p>

<ul>
<li><strong>(( ))</strong></li>
</ul>

<p>这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。<br />
#!/bin/bash(( a = 10 ))echo -e &ldquo;inital value, a = $a\n&rdquo;(( a++))echo &ldquo;after
a++, a = $a&rdquo;</p>

<ul>
<li><strong>{ } 大括号 (Block of code)</strong></li>
</ul>

<p>有时候 script 当中会出现，大括号中会夹着一段或几段以&rdquo;分号&rdquo;做结尾的指令或变数设定。</p>

<h1 id="cat-ftmp-02-bin-basha-fsh-a-inbc-echo-e-n-a-n-echo">cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e &ldquo;\n $a \n&rdquo;}echo</h1>

<p>$a#./ftmp-02inbcinbc<br />
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。<br />
大括号也被运用在 &ldquo;函数&rdquo; 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写
script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。</p>

<p>此外，大括号还有另一种用法，如下<br />
{xx,yy,zz,&hellip;}<br />
这种大括号的组合，常用在字串的组合上，来看个例子<br />
mkdir {userA,userB,userC}-{home,bin,data}<br />
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data,
userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子<br />
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}<br />
如果不是因为支援这种用法，我们得写几行重复几次呀！</p>

<ul>
<li><strong>[ ] 中括号</strong></li>
</ul>

<p>常出现在流程控制中，扮演括住判断式的作用。if [ &ldquo;$?&rdquo; != 0 ]thenecho &ldquo;Executes error&rdquo;exit1fi<br />
这个符号在正则表达式中担任类似 &ldquo;范围&rdquo; 或 &ldquo;集合&rdquo; 的角色<br />
rm -r 200[1234]<br />
上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。</p>

<ul>
<li><strong>[[ ]]</strong></li>
</ul>

<p>这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与&amp;&amp; 逻辑等符号。<br />
#!/bin/bashread akif [[ $ak &gt; 5 || $ak&lt; 9 ]]thenecho $akfi</p>

<ul>
<li><strong>|| 逻辑符号</strong></li>
</ul>

<p>这个会时常看到，代表 or 逻辑的符号。</p>

<ul>
<li><strong>&amp; &amp; 逻辑符号</strong></li>
</ul>

<p>这个也会常看到，代表 and 逻辑的符号。</p>

<ul>
<li><strong>&amp; 后台工作</strong></li>
</ul>

<p>单一个&amp; 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。<br />
tar cvfz data.tar.gz data &gt; /dev/null&amp;</p>

<ul>
<li><strong>\ &lt;&hellip;&gt; 单字边界</strong></li>
</ul>

<p>这组符号在规则表达式中，被定义为&rdquo;边界&rdquo;的意思。譬如，当我们想找寻 the 这个单字时，如果我们用<br />
grep the FileA<br />
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况，就得加上 &ldquo;边界&rdquo; 的符号<br />
grep &lsquo;\&rsquo; FileA</p>

<ul>
<li><strong>+ 加号 (plus)</strong></li>
</ul>

<p>在运算式中，她用来表示 &ldquo;加法&rdquo;。<br />
expr 1 + 2 + 3<br />
此外在规则表达式中，用来表示&rdquo;很多个&rdquo;的前面字元的意思。</p>

<h1 id="grep-10-9-fileb109100910000910000931010009-这个符号在使用时-前面必须加上escape-字元">grep &lsquo;10\+9&rsquo; fileB109100910000910000931010009#这个符号在使用时，前面必须加上escape 字元。</h1>

<ul>
<li><strong>- 减号 (dash)</strong></li>
</ul>

<p>在运算式中，她用来表示 &ldquo;减法&rdquo;。<br />
expr 10 - 2<br />
此外也是系统指令的选项符号。<br />
ls -expr 10 - 2<br />
在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表&rdquo;标准输入&rdquo;的意思。这是 GNU指令的共通选项。譬如下例<br />
tar xpvf -<br />
这里的 - 符号，既代表从标准输入读取资料。<br />
不过，在 cd 指令中则比较特别<br />
cd -<br />
这代表变更工作目录到&rdquo;上一次&rdquo;工作目录。</p>

<ul>
<li><strong>% 除法 (Modulo)</strong></li>
</ul>

<p>在运算式中，用来表示 &ldquo;除法&rdquo;。<br />
expr 10 % 2<br />
此外，也被运用在关于变量的规则表达式当中的下列<br />
${parameter%word}${parameter%%word}<br />
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。</p>

<ul>
<li><strong>= 等号 (Equals)</strong></li>
</ul>

<p>常在设定变数时看到的符号。<br />
vara=123echo &ldquo; vara = $vara&rdquo;<br />
或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。</p>

<ul>
<li><strong>== 等号 (Equals)</strong></li>
</ul>

<p>常在条件判断式中看到，代表 &ldquo;等于&rdquo; 的意思。<br />
if [ $vara == $varb ]<br />
&hellip;下略</p>

<ul>
<li><strong>!= 不等于</strong></li>
</ul>

<p>常在条件判断式中看到，代表 &ldquo;不等于&rdquo; 的意思。<br />
if [ $vara != $varb ]<br />
&hellip;下略</p>

<ul>
<li><strong>^</strong></li>
</ul>

<p>这个符号在规则表达式中，代表行的 &ldquo;开头&rdquo; 位置，在[]中也与&rdquo;!&ldquo;(叹号)一样表示“非”</p>

<ul>
<li><strong>输出/输入重导向</strong></li>
</ul>

<blockquote>
<blockquote>
<blockquote>
<p>&amp;&gt; 2&amp;&gt; 2&amp;2</p>
</blockquote>
</blockquote>
</blockquote>

<p>文件描述符(File Descriptor)，用一个数字（通常为0-9）来表示一个文件。<br />
常用的文件描述符如下：<br />
 <strong>文件描述符 名称 常用缩写 默认值</strong><br />
0 标准输入 stdin 键盘<br />
1 标准输出 stdout 屏幕<br />
2 标准错误输出 stderr 屏幕<br />
我们在简单地用时，相当于使用 0&lt; 或 1&gt;（下面会详细介绍）。<br />
 *** cmd &gt; file**<br />
把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。<br />
 *** cmd &gt;&gt; file**<br />
把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面。<br />
 *** cmd &lt; file**<br />
使cmd命令从file读入<br />
 *** cmd &lt; text**<br />
从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用<br />
 *** cmd &lt;&lt; word**<br />
把word（而不是文件word）和後面的换行作为输入提供给cmd。<br />
 *** cmd &lt; file**<br />
以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。<br />
 *** cmd &gt;| file**<br />
功能同&gt;，但即便在设置了noclobber时也会复盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。<br />
 **: &gt; filename ** 把文件&rdquo;filename&rdquo;截断为0长度.# 如果文件不存在,
那么就创建一个0长度的文件(与&rsquo;touch&rsquo;的效果相同).<br />
 <strong>cmd &gt;&amp;n</strong> 把输出送到文件描述符n<br />
 <strong>cmd m &gt;&amp;n</strong> 把输出到文件符m的信息重定向到文件描述符n<br />
 <strong>cmd &gt;&amp;-</strong> 关闭标准输出<br />
 **cmd 输入来自文件描述符n<br />
 **cmd m m来自文件描述各个n<br />
 **cmd 关闭标准输入<br />
 **cmd 移动输入文件描述符n而非复制它。<br />
 **cmd &gt;&amp;n- <strong>移动输出文件描述符 n而非复制它。<br />
注意： &gt;&amp;实际上复制了文件描述符，这使得cmd &gt; file 2&gt;&amp;1与cmd 2&gt;&amp;1 &gt;file的效果不一样。<br />
本文转载<a href="http://blog.csdn.net/xifeijian/article/details/9253011">http://blog.csdn.net/xifeijian/article/details/9253011</a></strong>******</p>

<p><strong>八.sort并未按ASCLL排序</strong></p>

<p><strong>linux sort 命令的几个细节</strong></p>

<p>Linux
sort命令的原理是逐行按字符进行比较排序，当然，也可以通过命令行参数设定按数字进行比较，或者指定行间的分隔符，对某一个或一些字段按照自己指定的规则进行排序。这是一个很常用而且很方便的命令，但是其中的一些细节需要注意，否则会得到错误的排序结果。</p>

<ul>
<li><strong>比较方式</strong></li>
</ul>

<p>前面说过，sort命令默认是按照字符串排序，真的是这样么？看看sort的help信息，末尾有这样的文字：</p>

<pre><code> 
</code></pre>

<ol>
<li><p><code>*** WARNING ***</code></p></li>

<li><p><code>The locale specified by the environment affects sort order.</code></p></li>

<li><p><code>Set LC_ALL=C to get the traditional sort order that uses</code></p></li>

<li><p><code>native byte values.</code></p></li>
</ol>

<p>看来，环境变量也能影响sort的排序结果。实际试试看：</p>

<pre><code> 
</code></pre>

<ol>
<li><p><code>~$ cat text</code></p></li>

<li><p><code>11$</code></p></li>

<li><p><code>1{1</code></p></li>

<li><p><code>~$ sort text</code></p></li>

<li><p><code>1{1</code></p></li>

<li><p><code>11$</code></p></li>

<li><p><code>~$ echo $LC_ALL</code></p></li>

<li><p><code>~$</code></p></li>
</ol>

<p>论ASCII字符的大小，’{’应该比’1’大，但是上面的结果显示，当LC_ALL变量为空值时，sort命令输出了错误的排序结果。不过，在更多的平台上实验发现，LC_ALL为空的时候并不一定会输出这个错误的结果，具体原因不详。不过，如果按照sort的帮助信息设置LC_ALL，则结果是正确的，’1’排在’{’前面。</p>

<p>如果了解LC***系列的变量，其实只需要设置LC_COLLATE即可，该变量控制的是字符串的排序方式，在手头上的几种平台上实验，结果都是正确的。</p>

<ul>
<li><strong>按数字排序</strong></li>
</ul>

<p>加-n参数按数字排序。如果一行中还有非数字字符，则按照非数字字符前面的数字大小进行排序。</p>

<pre><code> 
</code></pre>

<ol>
<li><p><code>~$ cat text</code></p></li>

<li><p><code>11$</code></p></li>

<li><p><code>1{1</code></p></li>

<li><p><code>~$ export LC_ALL=C</code></p></li>

<li><p><code>~$ sort text</code></p></li>

<li><p><code>11$</code></p></li>

<li><p><code>1{1</code></p></li>

<li><p><code>~$ sort -n text</code></p></li>

<li><p><code>1{1</code></p></li>

<li><p><code>11$</code></p></li>
</ol>

<ul>
<li><strong>重定向</strong></li>
</ul>

<p>一般sort命令将排序结果输出到终端，如果想写入文件可以用重定向的方式，但是，如果想让排序结果直接写到排序前的文件，用一般的重定向方式sort
file_name &gt; file_name达不到效果，需要用sort命令的-o参数。</p>

<ul>
<li><strong>分隔字段</strong></li>
</ul>

<p>默认的排序是以行为单位的排序，如果想按照某个字段进行排序，可以用-t选项指定字段分隔符，-k指定要排序的字段。</p>

<p>-k参数的格式为-k start[,end]，需要注意的是，如果省略了end，则需要比较到行末，例如：</p>

<pre><code> 
</code></pre>

<ol>
<li><p><code>~$ cat text</code></p></li>

<li><p><code>1|101|2</code></p></li>

<li><p><code>1|10|2</code></p></li>

<li><p><code>~$ echo $LC_ALL</code></p></li>

<li><p><code>C</code></p></li>

<li><p><code>~$ sort -t &quot;|&quot; -k 2 text</code></p></li>

<li><p><code>1|101|2</code></p></li>

<li><p><code>1|10|2</code></p></li>

<li><p><code>~$ sort -t &quot;|&quot; -k 2,2 text</code></p></li>

<li><p><code>1|10|2</code></p></li>

<li><p><code>1|101|2</code></p></li>
</ol>

<p>虽然10排在101前面，但是不指定字段结束时，默认会继续比较，即比较’|’和’1’，所以有上面的结果。</p>

<p>通常，我们只希望按照一个或者多个字段排序，而不希望从某个字段开始一直比较到行末，所以用这个参数时最好同时指定start和end。</p>

<ul>
<li><strong>多条件排序</strong></li>
</ul>

<p>在按字段排序时如果想采用多个排序条件，如先按第二列升序，如果相同则按第三列降序，可以使用多个-k参数，如-k 2,2n –k 3,3nr</p>

<p><strong>九.简易审计系统</strong></p>

<ul>
<li><strong>连接</strong> <a href="http://www.68idc.cn/help//server/linux/2014042190951.html">http://www.68idc.cn/help//server/linux/2014042190951.html</a></li>
<li>有时候我们需要对线上用户操作记录进行历史记录待出现问题追究责任人，，但Linux系统自带的history命令用户有自行删除权限，那 <strong>怎么设置可以让用户的操作记录实时记录，并保证普通用户无权删除</strong> 呢？本文教你一招<br />
<br /></li>
</ul>

<p>1.mkdir -p /usr/local/domob/records/</p>

<p>chmod 777 /usr/local/domob/records/</p>

<p>chmod +t /usr/local/domob/records/</p>

<p>2.vi /etc/profile 在最后添加下面的代码</p>

<p>if [ ! -d /usr/local/domob/records/${LOGNAME} ]</p>

<p>then</p>

<p>mkdir -p /usr/local/domob/records/${LOGNAME}</p>

<p>chmod 300 /usr/local/domob/records/${LOGNAME}</p>

<p>fi</p>

<p>export HISTORY_FILE=&ldquo;/usr/local/domob/records/${LOGNAME}/bash_history&rdquo;</p>

<p>export PROMPT_COMMAND=&lsquo;{ date &ldquo;+%Y-%m-%d %T ##### $(who am i |awk &ldquo;{print
\$1\&rdquo; \&rdquo;\$2\&rdquo; \&rdquo;\$5}&ldquo;) #### $(history 1 | { read x cmd; echo &ldquo;$cmd&rdquo;; })&ldquo;; }
&gt;&gt;$HISTORY_FILE&rsquo;</p>

<p>转载于:<a href="https://my.oschina.net/u/3912766/blog/1928645">https://my.oschina.net/u/3912766/blog/1928645</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>