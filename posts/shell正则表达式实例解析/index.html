<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell正则表达式实例解析 | 开发者问答集锦</title>
    <meta property="og:title" content="shell正则表达式实例解析 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell正则表达式实例解析">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell正则表达式实例解析</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><strong>Shell正则表达式</strong></p>

<p>一个正则表达式就是由普通字符（例如字符 a 到
z）以及特殊字符（称为元字符）组成的文字模式。该模式描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>

<p>\ hmcLinux联盟<br />
将下一个字符标记为一个特殊字符、或一个原义字符、或一个 后向引用、或一个八进制转义符。例如，&rsquo;n&rsquo; 匹配字符 &ldquo;n&rdquo;。&rsquo;\n&rsquo; 匹配一个换行符。序列
&lsquo;\\&rsquo; 匹配 &ldquo;\&rdquo; 而 &ldquo;\(&rdquo; 则匹配 &ldquo;(&ldquo;。</p>

<p>^ hmcLinux联盟<br />
匹配输入字符串的开始位置。</p>

<p>$ hmcLinux联盟<br />
匹配输入字符串的结束位置。</p>

<ul>
<li>hmcLinux联盟<br />
匹配前面的子表达式零次或多次。例如，zo* 能匹配 &ldquo;z&rdquo; 以及 &ldquo;zoo&rdquo;。 * 等价于{0,}。</li>
</ul>

<p>+ hmcLinux联盟<br />
匹配前面的子表达式一次或多次。例如，&rsquo;zo+&rsquo; 能匹配 &ldquo;zo&rdquo; 以及 &ldquo;zoo&rdquo;，但不能匹配 &ldquo;z&rdquo;。+ 等价于 {1,}。</p>

<p>? hmcLinux联盟<br />
匹配前面的子表达式零次或一次。例如，&rdquo;do(es)?&rdquo; 可以匹配 &ldquo;do&rdquo; 或 &ldquo;does&rdquo; 中的&rdquo;do&rdquo; 。? 等价于 {0,1}。</p>

<p>{n} hmcLinux联盟<br />
n 是一个非负整数。匹配确定的 n 次。例如，&rsquo;o{2}&rsquo; 不能匹配 &ldquo;Bob&rdquo; 中的 &lsquo;o&rsquo;，但是能匹配 &ldquo;food&rdquo; 中的两个 o。</p>

<p>{n,} hmcLinux联盟<br />
n 是一个非负整数。至少匹配n 次。例如，&rsquo;o{2,}&rsquo; 不能匹配 &ldquo;Bob&rdquo; 中的 &lsquo;o&rsquo;，但能匹配 &ldquo;foooood&rdquo; 中的所有 o。&rsquo;o{1,}&rsquo;
等价于 &lsquo;o+&lsquo;。&rsquo;o{0,}&rsquo; 则等价于 &lsquo;o*&lsquo;。</p>

<p>{n,m} hmcLinux联盟<br />
m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 &ldquo;o{1,3}&rdquo; 将匹配 &ldquo;fooooood&rdquo; 中的前三个
o。&rsquo;o{0,1}&rsquo; 等价于 &lsquo;o?&lsquo;。请注意在逗号和两个数之间不能有空格。</p>

<p>? hmcLinux联盟<br />
当该字符紧跟在任何一个其他限制符(*, +, ?, {n}, {n,},
{n,m})后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串&rdquo;oooo&rdquo;，&rsquo;o+?&rsquo;
将匹配单个 &ldquo;o&rdquo;，而 &lsquo;o+&rsquo; 将匹配所有 &lsquo;o&rsquo;。</p>

<p>. hmcLinux联盟<br />
匹配除 &ldquo;\n&rdquo; 之外的任何单个字符。要匹配包括 &lsquo;\n&rsquo; 在内的任何字符，请使用象 &lsquo;[.\n]&rsquo; 的模式。</p>

<p>(pattern) hmcLinux联盟<br />
匹配pattern并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches
集合，在VisualBasic Scripting Edition 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 &lsquo;\(&rsquo; 或 &lsquo;\)&lsquo;。</p>

<p>(?:pattern) hmcLinux联盟<br />
匹配pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 &ldquo;或&rdquo; 字符
(|)来组合一个模式的各个部分是很有用。例如， &lsquo;industr(?:y|ies) 就是一个比 &lsquo;industry|industries&rsquo;更简略的表达式。</p>

<p>(?=pattern) hmcLinux联盟<br />
正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，
&lsquo;Windows(?=95|98|NT|2000)&rsquo; 能匹配 &ldquo;Windows 2000&rdquo; 中的 &ldquo;Windows&rdquo; ，但不能匹配 &ldquo;Windows
3.1&rdquo;中的&rdquo;Windows&rdquo;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>

<p>(?!pattern) hmcLinux联盟<br />
负向预查，在任何不匹配Negative lookahead matches the search string at any point where
astring not matching
pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&rsquo;Windows(?!95|98|NT|2000)&rsquo;
能匹配 &ldquo;Windows 3.1&rdquo; 中的 &ldquo;Windows&rdquo;，但不能匹配 &ldquo;Windows
2000&rdquo;中的&rdquo;Windows&rdquo;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>

<p>x|y hmcLinux联盟<br />
匹配 x 或 y。例如，&rsquo;z|food&rsquo; 能匹配 &ldquo;z&rdquo; 或 &ldquo;food&rdquo;。&rsquo;(z|f)ood&rsquo; 则匹配 &ldquo;zood&rdquo; 或 &ldquo;food&rdquo;。</p>

<p>[xyz] hmcLinux联盟<br />
字符集合。匹配所包含的任意一个字符。例如， &lsquo;[abc]&rsquo; 可以匹配 &ldquo;plain&rdquo; 中的 &lsquo;a&rsquo;。</p>

<p>[^xyz] hmcLinux联盟<br />
负值字符集合。匹配未包含的任意字符。例如， &lsquo;[^abc]&rsquo; 可以匹配 &ldquo;plain&rdquo; 中的&rsquo;p&rsquo;。</p>

<p>[a-z] hmcLinux联盟<br />
字符范围。匹配指定范围内的任意字符。例如，&rsquo;[a-z]&rsquo; 可以匹配 &lsquo;a&rsquo; 到 &lsquo;z&rsquo; 范围内的任意小写字母字符。</p>

<p>[^a-z] hmcLinux联盟<br />
负值字符范围。匹配任何不在指定范围内的任意字符。例如，&rsquo;[^a-z]&rsquo; 可以匹配任何不在 &lsquo;a&rsquo; 到 &lsquo;z&rsquo; 范围内的任意字符。</p>

<p>\b hmcLinux联盟<br />
匹配一个单词边界，也就是指单词和空格间的位置。例如， &lsquo;er\b&rsquo; 可以匹配&rdquo;never&rdquo; 中的 &lsquo;er&rsquo;，但不能匹配 &ldquo;verb&rdquo; 中的 &lsquo;er&rsquo;。</p>

<p>\B hmcLinux联盟<br />
匹配非单词边界。&rsquo;er\B&rsquo; 能匹配 &ldquo;verb&rdquo; 中的 &lsquo;er&rsquo;，但不能匹配 &ldquo;never&rdquo; 中的 &lsquo;er&rsquo;。</p>

<p>\cx hmcLinux联盟<br />
匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。 x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的
&lsquo;c&rsquo; 字符。</p>

<p>\d hmcLinux联盟<br />
匹配一个数字字符。等价于 [0-9]。</p>

<p>\D hmcLinux联盟<br />
匹配一个非数字字符。等价于 [^0-9]。</p>

<p>\f hmcLinux联盟<br />
匹配一个换页符。等价于 \x0c 和 \cL。</p>

<p>\n hmcLinux联盟<br />
匹配一个换行符。等价于 \x0a 和 \cJ。</p>

<p>\r hmcLinux联盟<br />
匹配一个回车符。等价于 \x0d 和 \cM。</p>

<p>\s hmcLinux联盟<br />
匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p>

<p>\S hmcLinux联盟<br />
匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p>

<p>\t hmcLinux联盟<br />
匹配一个制表符。等价于 \x09 和 \cI。</p>

<p>\v hmcLinux联盟<br />
匹配一个垂直制表符。等价于 \x0b 和 \cK。</p>

<p>\w hmcLinux联盟<br />
匹配包括下划线的任何单词字符。等价于&rsquo;[A-Za-z0-9_]&lsquo;。</p>

<p>\W hmcLinux联盟<br />
匹配任何非单词字符。等价于 &lsquo;[^A-Za-z0-9_]&lsquo;。</p>

<p>\xn hmcLinux联盟<br />
匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， &lsquo;\x41&rsquo; 匹配 &ldquo;A&rdquo;。&rsquo;\x041&rsquo; 则等价于 &lsquo;\x04&rsquo; &amp;
&ldquo;1&rdquo;。正则表达式中可以使用 ASCII 编码。.</p>

<p>\num hmcLinux联盟<br />
匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，&rsquo;(.)\1&rsquo; 匹配两个连续的相同字符。</p>

<p>\n hmcLinux联盟<br />
标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n
为一个八进制转义值。</p>

<p>\nm hmcLinux联盟<br />
标识一个八进制转义值或一个后向引用。如果 \nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm
为后向引用。如果 \nm之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字
(0-7)，则 \nm将匹配八进制转义值 nm。</p>

<p>\nml hmcLinux联盟<br />
如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</p>

<p>\un hmcLinux联盟<br />
匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</p>

<p><strong>Shell字符串处理</strong></p>

<ol>
<li>构造字符串<br />
直接构造<br />
STR_ZERO=hello<br />
STR_FIRST=&ldquo;i am a string&rdquo;<br />
STR_SECOND=&lsquo;success&rsquo;<br />
<br /></li>
</ol>

<p>重复多次<br />
#repeat the first parm($1) by $2 times<br />
strRepeat()<br />
{<br />
local x=$2<br />
if [ &ldquo;$x&rdquo; == &ldquo;&rdquo; ]; then<br />
x=0<br />
fi</p>

<p>local STR_TEMP=&ldquo;&rdquo;<br />
while [ $x -ge 1 ];<br />
do<br />
STR_TEMP=<code>printf &quot;%s%s&quot; &quot;$STR_TEMP&quot; &quot;$1&quot;</code><br />
x=<code>expr $x - 1</code><br />
done<br />
echo $STR_TEMP<br />
}</p>

<p>举例：<br />
STR_REPEAT=<code>strRepeat &quot;$USER_NAME&quot; 3</code><br />
echo &ldquo;repeat = $STR_REPEAT&rdquo;</p>

<ol>
<li>赋值与拷贝<br />
直接赋值<br />
与构造字符串一样<br />
USER_NAME=terry<br />
<br /></li>
</ol>

<p>从变量赋值<br />
ALIASE_NAME=$USER_NAME</p>

<ol>
<li><p>联接<br />
直接联接两个字符串<br />
STR_TEMP=<code>printf &quot;%s%s&quot; &quot;$STR_ZERO&quot; &quot;$USER_NAME&quot;</code><br />
使用printf可以进行更复杂的联接</p></li>

<li><p>求长<br />
求字符数(char)<br />
COUNT_CHAR=<code>echo &quot;$STR_FIRST&quot; | wc -m</code><br />
echo $COUNT_CHAR</p></li>
</ol>

<p>求字节数(byte)<br />
COUNT_BYTE=<code>echo &quot;$STR_FIRST&quot; | wc -c</code><br />
echo $COUNT_BYTE</p>

<p>求字数(word)<br />
COUNT_WORD=<code>echo &quot;$STR_FIRST&quot; | wc -w</code><br />
echo $COUNT_WORD</p>

<ol>
<li>比较<br />
相等比较<br />
str1 = str2<br />
<br /></li>
</ol>

<p>不等比较<br />
str1 != str2</p>

<p>举例：<br />
if [ &ldquo;$USER_NAME&rdquo; = &ldquo;terry&rdquo; ]; then<br />
echo &ldquo;I am terry&rdquo;<br />
fi</p>

<p>小于比较<br />
#return 0 if the two string is equal, return 1 if $1 &lt; $2, else 2strCompare()
{ local x=0 if [ &ldquo;$1&rdquo; != &ldquo;$2&rdquo; ]; then x=2 localTEMP=<code>printf &quot;%s\n%s&quot; &quot;$1&quot;
&quot;$2&quot;</code> local TEMP2=<code>(echo &quot;$1&quot;; echo &quot;$2&quot;) |sort</code> if [ &ldquo;$TEMP&rdquo; = &ldquo;$TEMP2&rdquo; ];
then x=1 fi fi echo $x }</p>

<ol>
<li>测试<br />
判空<br />
-z str<br />
<br /></li>
</ol>

<p>判非空<br />
-n str</p>

<p>是否为数字</p>

<h1 id="return-0-if-the-string-is-num-otherwise-1">return 0 if the string is num, otherwise 1</h1>

<p>strIsNum()<br />
{<br />
local RET=1<br />
if [ -n &ldquo;$1&rdquo; ]; then<br />
local STR_TEMP=<code>echo &quot;$1&quot; | sed 's/[0-9]//g'</code><br />
if [ -z &ldquo;$STR_TEMP&rdquo; ]; then<br />
RET=0<br />
fi<br />
fi<br />
echo $RET<br />
}</p>

<p>举例：<br />
if [ -n &ldquo;$USER_NAME&rdquo; ]; then<br />
echo &ldquo;my name is NOT empty&rdquo;<br />
fi</p>

<p>echo <code>strIsNum &quot;9980&quot;</code></p>

<ol>
<li>分割<br />
以符号＋为准，将字符分割为左右两部分<br />
使用sed<br />
举例：<br />
命令 date &ndash;rfc-3339 seconds 的输出为<br />
2007-04-14 15:09:47+08:00<br />
取其＋左边的部分<br />
date &ndash;rfc-3339 seconds | sed &rsquo;s/+[0-9][0-9]:[0-9][0-9]//g&rsquo;<br />
输出为<br />
2007-04-14 15:09:47<br />
取+右边的部分<br />
date &ndash;rfc-3339 seconds | sed &rsquo;s/.*+//g&rsquo;<br />
输出为<br />
08:00<br />
<br /></li>
</ol>

<p>以空格为分割符的字符串分割<br />
使用awk<br />
举例：<br />
STR_FRUIT=&ldquo;Banana 0.89 100&rdquo;<br />
取第3字段<br />
echo $STR_FRUIT | awk &lsquo;{ print $3; }&rsquo;</p>

<ol>
<li><p>子字符串<br />
字符串1是否为字符串2的子字符串</p>

<h1 id="return-0-is-1-is-substring-of-2-otherwise-1">return 0 is $1 is substring of $2, otherwise 1</h1>

<p>strIsSubstring()<br />
{<br />
local x=1<br />
case &ldquo;$2&rdquo; in<br />
<em>$1</em>) x=0;;<br />
esac<br />
echo $x<br />
}</p></li>
</ol>

<p>模仿秀</p>

<p>您可以将 UNIX 命令行看作是一句话：</p>

<ul>
<li>可执行命令，如 <em>cat</em> 或 <em>ls</em> ，是 <strong>动词</strong> ——操作。</li>
<li>命令的输出是 <strong>名词</strong> ——要查阅或使用的数据。</li>
<li>Shell 操作符，如 <code>|</code>（管道）或 <code>&gt;</code>（重定向标准输出），是 <strong>连词</strong> ——用于连接句子。</li>
</ul>

<p>例如，命令行：<code>ls -A | wc -l</code> 用于计算当前目录下的条目数（忽略特殊条目 <code>.</code> 和 <code>..</code>），它包含两个句子。第一个句子 <code>ls -A</code>
是动词结构，列举当前目录下的内容，第二个句子 <code>wc -l</code>
是另一个动词结构，用于计算行数。第一个句子输出的结果作为第二个句子的输入，并由连接词（管道）连接这两个句子。</p>

<p>在本系列文章以及其他文章中展示的许多您可能已经学习过的命令行句式都具有这种句子结构。</p>

<p>但是，如果缺少了文法上的修饰语，命令行将显得不专业。当然，基本句子也能完成工作，但是这样显得不 <em>优美</em> 。（在此对高中英语演唱二人组 Rad 女士和
Perlstein 女士表示歉意。）解决更有趣的问题需要用到 <em>形容词</em> 。</p>

<p>几乎所有重要问题都需要从无用数据中过滤出有用数据。虽然属性的数量和种类会有所不同，但是每种方案都通过某种方式（形式或格式），隐式或显式地描述了它要查找并处理的信息，从而生成另外一种形式的其他信息。</p>

<p>在命令行中， <em>正则表达式</em> 的作用相当于形容词——一种描述或限定词。在应用到输出时，正则表达式可辨别相关数据和无关数据。</p>

<p>标点概述</p>

<p>让我们看一个示例问题。</p>

<p><code>grep</code> 实用工具逐行过滤输入并寻找匹配。<code>grep</code> 的最简单应用是打印那些包含与某个模式匹配的文本的行。<code>grep</code>
可以查找具有固定顺序的字符组合，甚至可以通过使用 <code>-i</code> 选项来忽略大小写。</p>

<p>因此，假定文件 heroes.txt 包含以下行：</p>

<pre><code>Catwoman  
Batman  
The Tick  
Spider Man  
Black Cat  
Batgirl  
Danger Girl  
Wonder Woman  
Luke Cage  
The Punisher  
Ant Man  
Dead Girl  
Aquaman  
SCUD  
Spider Woman  
Blackbolt  
Martian Manhunter  
</code></pre>

<hr />

<p>命令行：</p>

<pre><code>grep -i man heroes.txt  
</code></pre>

<hr />

<p>将生成：</p>

<pre><code>Catwoman  
Batman  
Spider Man  
Wonder Woman  
Ant Man  
Aquaman  
Martian Manhunter  
</code></pre>

<hr />

<p>其中 <code>grep</code> 扫描 heroes.txt 文件中的每一行并查找字母 <em>m</em> ，后面紧跟 <em>a</em> ，然后紧跟 <em>n</em>
。除了必须保证相邻，这些字母可以出现在行的任何位置，甚至可以位于较大的单词中间。在不考虑大小写的情况下（<code>-i</code>
选项），Catwoman、Batman、Spider Man、Wonder Woman、Ant Man、Aquaman 和 Martian
Manhunter 都包含字符串 <code>man</code>。</p>

<p><code>grep</code> 实用工具包含其他可优化搜索的内置选项。例如，<code>-w</code> 选项限制于匹配整个单词，因此 <code>grep -i -w man</code> 将 <em>排除</em>
Catwoman 和 Batman（举例来说）。</p>

<p>该工具还有一个优秀的功能，可以排除而不是包括所有匹配的搜索结果。使用 <code>-v</code> 选项来 <em>排除</em> 匹配的行。例如：</p>

<pre><code>grep -v -i 'spider' heroes.txt  
</code></pre>

<hr />

<p>将打印除了包含字符串 <code>spider</code> 之外的所有行。</p>

<pre><code>Catwoman  
Batman  
The Tick  
Black Cat  
Batgirl  
Danger Girl  
Wonder Woman  
Luke Cage  
The Punisher  
Ant Man  
Dead Girl  
Aquaman  
SCUD  
Blackbolt  
Martian Manhunter  
</code></pre>

<hr />

<p>但是，对于以下这些情况，您该如何处理？只希望得到那些 <em>开头为</em>
“Bat”的单词；或者以“bat”、“Bat”、“cat”或“Cat”开头的单词？或者希望知道有多少漫画复仇者的名字以“man” <em>结束</em>
。在这些实例中，类似于上述三个示例的简单字符串搜索将无法满足要求，因为这些搜索不区分位置。</p>

<p>位置、位置、位置和备选项</p>

<p>正则表达式 <em>可以</em> 过滤特定的位置，例如行的开始或结束，以及单词的开始和结束。正则表达式（通常简写为 <em>regex</em>
）还可以描述：备选项（您可将其称为“this”或“that”）；固定长度、可变长度或不定长度的重复；范围（例如，“a-m
之间的任意字母”）；还有字符的类别或种类（“可打印字符”或“标点符号”），以及其他技术。</p>

<p>表 1 显示了一些常用的正则表达式操作符。您可以连接表 1 中显示的元素（以及其他操作符）并加以组合使用，从而构建（非常）复杂的正则表达式。</p>

<p><strong>表 1. 常用的正则表达式操作符</strong></p>

<table>
<thead>
<tr>
<th>操作符</th>
<th>用途</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>.</code>（句号）</td>
<td>匹配任意单个字符。</td>
</tr>

<tr>
<td><code>^</code>（脱字号）</td>
<td>匹配出现在行首或字符串开始位置的空字符串。</td>
</tr>

<tr>
<td><code>$</code>（美元符号）</td>
<td>匹配出现在行末的空字符串。</td>
</tr>

<tr>
<td><code>A</code></td>
<td>匹配大写字母 <em>A</em> 。</td>
</tr>

<tr>
<td><code>a</code></td>
<td>匹配小写字母 <em>a</em> 。</td>
</tr>

<tr>
<td><code>\d</code></td>
<td>匹配任意一位数字。</td>
</tr>

<tr>
<td><code>\D</code></td>
<td>匹配任意单个非数字字符。</td>
</tr>

<tr>
<td><code>\w</code></td>
<td>匹配任意单个字母数字字符，同义词是 <code>[:alnum:]</code>。</td>
</tr>

<tr>
<td><code>[A-E]</code></td>
<td>匹配任意大写的 <em>A、B、C、D</em> 或 <em>E</em> 。</td>
</tr>

<tr>
<td><code>[^A-E]</code></td>
<td>匹配 <em>除</em> <em>A、B、C、D</em> 和 <em>E</em> 之外的任意字符。</td>
</tr>

<tr>
<td><code>X?</code></td>
<td>匹配出现零次或一次的大写字母 <em>X</em> 。</td>
</tr>

<tr>
<td><code>X*</code></td>
<td>匹配零个或任意个大写 <em>X</em> 。</td>
</tr>

<tr>
<td><code>X+</code></td>
<td>匹配一个或多个字母 <em>X</em> 。</td>
</tr>

<tr>
<td><code>X{ _n_ }</code></td>
<td>精确匹配 <em>n</em> 个字母 <em>X</em> 。</td>
</tr>

<tr>
<td><code>X{ _n,m_ }</code></td>
<td>匹配最少 <em>n</em> 个并且不超过 <em>m</em> 个字母 <em>X</em> 。如果省略 <em>m</em> ，表达式将尝试匹配最少 <em>n 个 X</em> 。</td>
</tr>

<tr>
<td>`(abc</td>
<td>def)+`</td>
</tr>
</tbody>
</table>

<p>以下是一些使用 <code>grep</code> 作为搜索工具的正则表达式示例。许多其他 UNIX 工具，包括交互式编辑器 <code>vi</code> 和 Emacs、流编辑器 <code>sed</code> 和
<code>awk</code>，以及所有现代编程语言都支持正则表达式。在您学会正则表达式的语法（也许相当晦涩）之后，就可以将您的专业知识灵活运用到不同的工具、编程语言和操作系统。</p>

<p><strong>查找以“Bat”开头的名称</strong></p>

<p>要查找以“Bat”开头的名称，请使用：</p>

<pre><code>grep -E '^Bat'  
</code></pre>

<hr />

<p>可以使用 <code>-E</code> 选项来指定正则表达式。<code>^</code>（脱字号）字符匹配行首或字符串的开头，这是一个出现在每行或每个字符串开头字符之前的假想字符。字母
<code>B</code>、<code>a</code> 和 <code>t</code> 只具有字面含义并且仅匹配那些特定的字符。因此，命令 <code>grep -E '^Bat'</code> 将生成：</p>

<pre><code>Batman  
Batgirl  
</code></pre>

<hr />

<p>由于许多 regex 操作符也为 Shell 所使用（其中一些具有不同的用途，另外一些则有类似的用途），因此一个好的习惯是使用单引号将命令行中的每个
regex 括起来，以保护 regex 操作符免遭 Shell 的误解。例如，<code>*</code>（星号）和 <code>$</code>（美元符号）都是 regex 操作符，并且对于您的
Shell 具有特殊的含义。</p>

<p><strong>查找以“man”结尾的名称</strong></p>

<p>要查找以“man”结尾的名称，可以使用 regex <code>man$</code> 来匹配序列 <code>m</code>、<code>a</code> 和 <code>n</code>，并且后面紧接与 regex 操作符 <code>$</code>
匹配的行（字符串）。</p>

<p><strong>查找空行</strong></p>

<p>基于 <code>^</code> 和 <code>$</code> 的作用，您可以使用 regex <code>^$</code> 来查找空行（相当于在开始之后立即结束的行）。</p>

<p><strong>备选项或集合操作符</strong></p>

<p>要查找以“bat”、“Bat”、“cat”或“Cat”开头的单词，可以使用以下两个技巧。首先是 <em>备选项</em> ，如果备选项中的 <em>任意</em>
模式匹配，都会产生匹配的结果。例如，命令：</p>

<pre><code>grep -E '^(bat|Bat|cat|Cat)' heroes.txt  
</code></pre>

<hr />

<p>可实现这一技巧。regex 操作符 <code>|</code>（竖线）表示备选项，因此 <code>this|that</code> 匹配字符串 <code>this</code> 或字符串
<code>that</code>。因此，<code>^(bat|Bat|cat|Cat)</code> 表示“行首紧跟 <code>bat</code>、<code>Bat</code>、<code>cat</code> 或 <code>Cat</code>之一。”当然，可以使用
<code>grep -i</code> 来简化该 regex，这样可以忽略大小写，从而将命令简化为：</p>

<pre><code>grep -i -E '^(bat|cat)' heroes.txt  
</code></pre>

<hr />

<p>匹配“bat”、“Bat”、“cat”或“Cat”的另一个方法是使用 <code>[ ]</code>（方括号） <em>集合</em>
操作符。如果将一组字符放在一个集合中，则可以匹配那些字符中的任意一个。（您可以将 <em>集合</em> 看作是字符备选项的简写法。）</p>

<p>例如，命令行：</p>

<pre><code>grep -E '^[bcBC]at' heroes.txt  
</code></pre>

<hr />

<p>与以下命令生成的结果相同：</p>

<pre><code>grep -E '^(bat|Bat|cat|Cat)' heroes.txt  
</code></pre>

<hr />

<p>您可以再次使用 <code>-i</code> 将 regex 简化为 <code>^[bc]at</code>。</p>

<p>而且，还可以使用 <code>-</code>（连字符）操作符在集合中指定包含的字符范围。例如，用户名通常以字母开头。假定要在提交给您的服务器的 Web
表格中验证这样的用户名，可以使用类似于 <code>^[A-Za-z]</code> 的 regex。此 regex 表示“字符串的开头后紧跟任意大写字母 ( <em>A-Z</em> )
或任意小写字母 ( <em>a-z</em> )。”顺便说明一下，<code>[A-z]</code> 与 <code>[A-Za-z]</code> 作用相同。</p>

<p>还可以在集合中混合使用范围和单个字符。regex <code>[A-MXYZ]</code> 将匹配任意大写的 <em>A-M、X、Y</em> 和 <em>Z</em> 。</p>

<p>并且，如果希望反转集合（即排除集合中的任意字符），可以使用特殊集合 <code>[^ ]</code> 并包含要排除的范围或字符。以下是反转集合的示例。要查找所有名称中包含
<em>at</em> 的超级英雄，并排除 Dark Knight 和 Batman，请键入：</p>

<pre><code>grep -i -E '[^b]at' heroes.txt  
</code></pre>

<hr />

<p>此命令生成：</p>

<pre><code>Catwoman  
Black Cat  
</code></pre>

<hr />

<p>由于某些集合需要经常使用，所以设计出简化符号以代替大量字符。例如，集合 <code>[A-z0-9_]</code> 十分常用，因此可以简写为 <code>\w</code>。与此类似，操作符
<code>\W</code> 是集合 <code>[^A-z0-9_]</code> 的简写。还可以使用符号 <code>[:alnum:]</code> 代替 <code>\w</code>，使用 <code>[^[:alnum:]]</code> 代替
<code>\W</code>。</p>

<p>顺便说明一下，<code>\w</code>（以及同义词 <code>[:alnum:]</code>）是特定于区域的，而 <code>[A-z0-9_]</code> 即表示字母 A-z、数字 <em>0-9</em>
和下划线。如果要开发国际化应用程序，请使用区域特定的格式以使代码可以在许多区域之间移植。</p>

<p>跟我一起重复：重复，重复，重复</p>

<p>到目前为止，已经介绍了字面值、位置和两种备选项操作符。仅使用这些内容，就可以匹配大多数具有 <em>可预测</em> 长度的模式。现在回到用户名，通过以下 regex
命令可以确保每个用户名以字母开头并紧跟恰好七个字母或数字：</p>

<pre><code>[a-z][a-z0-9][a-z0-9][a-z0-9][a-z0-9][a-z0-9][a-z0-9][a-z0-9]  
</code></pre>

<hr />

<p>但是这样有点笨拙。而且，它只匹配恰好八个字符的用户名。它不会匹配三到八个字符之间的名称，这通常也是有效的用户名。</p>

<p>正则表达式还可以包括 <em>重复修饰符</em>
。重复修饰符可以指定数量，如没有、一个、多个、一个或多个，零或一个、五到十个，以及恰好三个。重复修饰符必须与其他模式组合，修饰符本身没有含义。</p>

<p>例如，regex：</p>

<pre><code>^[A-z][A-z0-9]{2,7}$  
</code></pre>

<hr />

<p>可以实现前面描述的用户名过滤功能。 <em>用户名</em> 是以字母开头，后面紧跟至少两个，但不超过七个字母或数字的字符串，并且紧跟字符串结尾。</p>

<p>此处的位置定位点非常重要。如果没有两个位置操作符，则会错误地接受任意长度的用户名。为什么呢？请考虑 regex：</p>

<pre><code>^[A-z][A-z0-9]{2,7}  
</code></pre>

<hr />

<p>此命令辨别：字符串是否以字母开头并紧跟二到七个字母？但是它未提到终止条件。因此，字符串 <code>samuelclemens</code>
满足条件，但是它的长度显然超出了有效用户名的范围。与此类似，省略开始定位点 <code>^</code>，或同时省略两个定位点将分别匹配以类似 <code>munster1313</code>
结束或包含该字符串的字符串。如果必须匹配特定的长度，请记得在要求的模式的开头和结尾分别加上分隔符。</p>

<p>以下是其他一些示例：</p>

<ul>
<li>可以使用 <code>{2,}</code> 查找两次或多次重复。regex <code>^G[o]{2,}gle</code> 匹配 <code>Google</code>、<code>Gooogle</code>、<code>Goooogle</code> 等等。</li>
<li>重复修饰符 <code>?</code>、<code>+</code> 和 <code>*</code> 分别查找零次或一次、一次或多次，以及零次或多次重复。（例如，您可以将 <code>?</code> 看作是 <code>{0,1}</code> 的简写法。）</li>
</ul>

<p>regex <code>boys?</code> 匹配 <code>boy</code> 或 <code>boys</code>；regex <code>Goo?gle</code> 匹配 <code>Gogle</code> 或 <code>Google</code>。</p>

<p>regex <code>Goo+gle</code> 匹配 <code>Google</code>、<code>Gooogle</code>、<code>Goooogle</code> 等等。</p>

<p>construct <code>Goo*gle</code> 匹配 <code>Gogle</code>、<code>Google</code>、<code>Gooogle</code> 等等。</p>

<ul>
<li><p>可以将重复修饰符应用到单个字符（如上所示），还可以应用到更复杂的组合。使用 <code>(</code> 和 <code>)</code> 圆括号（就像数学中的用法）将修饰符应用到子表达式。下面是一个示例：给定文本文件 test.txt：</p>

<pre><code>The rain in Spain falls mainly   
</code></pre>

<p>on the the plain.</p>

<p>It was the best of of times;<br />
it was the worst of times.</p></li>
</ul>

<hr />

<p>命令 <code>grep -i -E '(\b(of|the)\W+){2,}' test.txt</code> 将生成：</p>

<pre><code>    on the the plain.  
It was the best of of times;  
</code></pre>

<hr />

<ul>
<li>regex 操作符 <code>\b</code> 匹配 <em>单词边界</em> 或 <code>(\W\w|\w\W)</code>。该 regex 表示“一连串完整单词‘the’或‘of’后面紧跟非文字字符。”您可能会提出疑问，为什么 <code>\W+</code> 是必需的：<code>\b</code> 是位于单词开头或结尾的空字符串。在单词之间必须包括这一（或这些）字符，否则该 regex 将无法找到匹配。</li>
</ul>

<p>捕获需要注意的内容</p>

<p>查找文本是常见的问题，但是更常见的问题则是希望在找到文本之后将其提取出来。换句话说，您希望去粗取精。</p>

<p>正则表达式通过 <em>捕获</em>
来提取信息。如果希望将需要的文本与其他内容分开，请使用圆括号将模式括起来。实际上，您已经使用圆括号收集术语；在默认情况下，圆括号自动进行捕获。</p>

<p>要查看捕获，请切换到 Perl。（<code>grep</code> 实用工具不支持捕获，因为其目标是打印包含模式的行。）</p>

<p>以下命令：</p>

<pre><code>perl -n -e '/^The\s+(.*)$/ &amp;&amp; print &quot;$1\n&quot;' heroes.txt  
</code></pre>

<hr />

<p>将打印：</p>

<pre><code>Tick  
Punisher  
</code></pre>

<hr />

<p>使用命令 <code>perl -e</code> 可以直接从命令行运行 Perl 程序。<code>perl -n</code> 命令针对输入文件的每一行运行一次程序。命令的 regex
部分，即位于斜杠之间的文本（<code>/</code>）表示“匹配字符串的开头，然后字母‘T’、‘h’、‘e’后紧跟一个或多个空格字符
<code>\s+</code>，然后捕获直到字符串结尾的所有字符。</p>

<p>Perl 捕获内容被放在以 <code>$1</code> 开头的特殊 Perl 变量中。Perl 程序的其余部分打印捕获的内容。</p>

<p>每个嵌套的括号对，从左开始算起，每个左圆括号加一，放在下一个特殊的数字变量中。例如：</p>

<pre><code>perl -n -e '/^(\w)+-(\w+)$/ &amp;&amp; print &quot;$1 $2&quot;'  
</code></pre>

<hr />

<p>将生成：</p>

<pre><code>Spider Man  
Ant Man  
Spider Woman  
</code></pre>

<hr />

<p>捕获感兴趣的文本仅仅是隔靴搔痒。如果能够准确确定材料，就可以使用其他材料改变其外观。类似于 <code>vi</code> 和 Emacs
的编辑器将模式匹配与替换组合，从而将查找和替换文本组合成一步操作。还可以使用模式、替换和 <code>sed</code> 从命令行更改文本。</p>

<p>丰富的主题</p>

<p>正则表达式非常强大；可供使用的操作符的数量庞大，种类繁多。它包含如此丰富的信息和实践知识，我们在这里所能列举的实属凤毛麟角。</p>

<p>幸运的是，有以下三种优秀的正则表达式理论来源可供使用：</p>

<ul>
<li>如果在您的系统上有 Perl，可以参阅 Perl Regular Expression man 页面（键入 <code>perldoc perlre</code>）。它会提供 regex 的精彩介绍，并包含许多有用的示例。许多编程语言都已采用 Perl 兼容的正则表达式 (PCRE)，因此您在此 man 页面读到的内容已被直接转换到 PHP、Python、Java™ 和 Ruby 编程语言，以及许多其他最新工具。</li>
<li>Jeffrey Friedl 编著的《正则表达式》（第三版）被认为是 regex 用法方面的圣经。该书细致、准确、清晰、务实地说明了匹配的工作方式、所有的 regex 操作符、多数优先性（限制 <code>+</code> 和 <code>*</code> 匹配字符的数量），以及更多内容。此外，Friedl 的书还包括一些令人惊叹的正则表达式，可以准确地匹配完全限定的电子邮件地址和其他 Request for Comments (RFC) 特定的字符串。</li>
<li>Nathan Good 编著的 <em>Regular Expression Recipes</em> 一书提供了针对许多常见数据处理和过滤问题的有用的解决方案。如果需要提取邮政编码、电话号码或引用的字符串，请尝试 Nathan 的解决方案。</li>
</ul>

<p>在命令行中，可以采用许多方法使用正则表达式。几乎每个处理文本的命令都支持某种形式的正则表达式。大多数 Shell
命令语法还或多或少地扩展正则表达式以匹配文件名（尽管操作符的功能可能有所不同）。</p>

<p>例如，键入 <code>ls [a-c]</code> 以查找名为 <em>a、b</em> 或 <em>c</em> 的文件。键入 <code>ls [a-c]*</code> 以查找以 <em>a、b</em> 或 <em>c</em>
开头的所有文件名。此处的 <code>*</code> 在 Shell 中不像 <code>grep</code> 的解释器那样修饰 <code>[a-c]</code>，<code>*</code> 被解释为 <code>.*</code>。<code>?</code> 操作符在
Shell 中也可以工作，但是被解释为 <code>.</code>，即匹配任意单个字符。</p>

<p>查看您最喜欢的实用工具或 Shell 的文档以确定哪些 regex 操作符受支持，以及操作符可能具有的独特性。</p>

<ol>
<li></li>
</ol>

<p>下面我们就以具体的实例来看一下如何使用正则表达式。其中用黑体着重标出的是匹配到的字符串。</p>

<p>一个最简单的例子便是 <strong>/all/</strong> ，比如下面一段文字：</p>

<p>John’s b <strong>all</strong> fell into the hole</p>

<p>John cried because it is <strong>all</strong> his life.</p>

<p>这个正则表达式不含任何的原字符，它查找的是字符串all，这个字符串all可以是独成一个单词，也可以是其它单词的一部分，因此正则表达式 <strong>/all/</strong>
既匹配 <strong>ball</strong> 里的 <strong>all</strong> ，也匹配完整的单词all。</p>

<p>下面我们着重讨论正则表达式里原字符的用法。</p>

<h2 id="3-1-行首-行尾定位符">3.1 行首、行尾定位符</h2>

<p>行首定位符^</p>

<p>Here is a tongue twister:</p>

<p><strong>Bobby</strong> Bippy bought a bat.</p>

<p><strong>Bobby</strong> Bippy bought a ball.<br />
With his bat Bob banged the ball<br />
Banged it bump against the wall<br />
But so boldly Bobby banged it<br />
That he burst his rubber ball, &ldquo;Boo!&rdquo; cried Bobby<br />
Bad luck ball, Bad luck Bobby, bad luck ball<br />
Now to drown his many troubles<br />
 <strong>Bobby</strong> Bippy&rsquo;s blowing bubbles.</p>

<p>/^Bobby/</p>

<p>匹配位于行首的Bobby。</p>

<p>Here is a tongue twister:</p>

<p>Bobby Bippy bought a bat.</p>

<p>Bobby Bippy bought a ball.<br />
With his bat Bob banged the ball<br />
Banged it bump against the wall<br />
But so boldly Bobby banged it<br />
That he burst his rubber ball, &ldquo;Boo!&rdquo; cried <strong>Bobby</strong><br />
Bad luck ball, Bad luck Bobby, bad luck ball<br />
Now to drown his many troubles<br />
Bobby Bippy&rsquo;s blowing bubbles.</p>

<p>/Bobby$/</p>

<p>匹配位于行尾的Bobby。</p>

<h2 id="3-2-词首-词尾定位符">3.2 词首、词尾定位符</h2>

<p>词首定位符 &lt;</p>

<p>Here is a tongue twister:</p>

<p><strong>Bo</strong> bby Bippy bought a bat.</p>

<p><strong>Bo</strong> bby Bippy bought a ball.<br />
With his bat <strong>Bo</strong> b banged the ball<br />
Banged it bump against the wall<br />
But so boldly <strong>Bo</strong> bby banged it<br />
That he burst his rubber ball, &ldquo; <strong>Bo</strong> o!&rdquo; cried <strong>Bo</strong> bby<br />
Bad luck ball, Bad luck <strong>Bo</strong> bby, bad luck ball<br />
Now to drown his many troubles<br />
 <strong>Bo</strong> bby Bippy&rsquo;s blowing bubbles.</p>

<p>/</p>

<p>匹配位于词首的字符串Bo。</p>

<p>词尾定位符 &gt;</p>

<p>Here is a tongue twister:</p>

<p>Bobby Bippy bought a bat.</p>

<p>Bobby Bippy bought a <strong>ball</strong>.<br />
With his bat Bob banged the <strong>ball</strong><br />
Banged it bump against the wall<br />
But so boldly Bobby banged it<br />
That he burst his rubber ball, &ldquo;Boo!&rdquo; cried Bobby<br />
Bad luck ball, Bad luck Bobby</p>

<p>Bad luck <strong>ball</strong><br />
Now to drown his many troubles<br />
Bobby Bippy&rsquo;s blowing bubbles.</p>

<p>/ball&gt;/</p>

<p>匹配位于词尾的字符串ball。</p>

<p>在一个表达式中搭配使用词首定位符与词尾定位符</p>

<p>John’s ball fell into the <strong>hole</strong></p>

<p>John cried because it is his whole life</p>

<p>/\/</p>

<p>匹配以h作为单词开头并且以e作为单词结尾的模式hole。也就是说，字母h的前面是一个分隔单词的字符（比如空格或换行符），字母l的后面也是一个分隔单词的字符。这样，在这个例子中只有完整的单词hole会被匹配，而单词whole就不会被匹配。</p>

<h2 id="3-3-匹配单个字符">3.3 匹配单个字符</h2>

<p>匹配任意的一个字符 <strong>.</strong></p>

<p>Here is a tongue twister:</p>

<p><strong>Bobby Bippy</strong> bought a bat.</p>

<p><strong>Bobby Bippy</strong> bought a ball.<br />
With his bat Bob banged the ball<br />
Banged it bump against the wall<br />
But so boldly <strong>Bobby</strong> banged it<br />
That he burst his rubber ball, &ldquo;Boo!&rdquo; cried <strong>Bobby</strong><br />
Bad luck ball, Bad luck <strong>Bobby</strong> , bad luck ball<br />
Now to drown his many troubles<br />
 <strong>Bobby Bippy</strong> &rsquo;s blowing bubbles.</p>

<p>/B <strong>…</strong> y/</p>

<p>匹配B开头后面紧跟三个任意字符，最后紧接着一个y的字符串。在这个例子中，Bobby和Bippy都会被匹配。</p>

<p>匹配0个或多个前一字符 *</p>

<p>Here is <strong>a</strong> tongue twister:</p>

<p>Bobby Bippy bought <strong>a</strong> b <strong>a</strong> t.</p>

<p>Bobby Bippy bought <strong>a</strong> b <strong>all</strong>.<br />
With his b <strong>a</strong> t Bob b <strong>a</strong> nged the b <strong>all</strong><br />
B <strong>a</strong> nged it bump <strong>a</strong> g <strong>a</strong> inst the w <strong>all</strong><br />
But so boldly Bobby b <strong>a</strong> nged it<br />
Th <strong>a</strong> t he burst his rubber b <strong>all</strong> , &ldquo;Boo!&rdquo; cried Bobby<br />
B <strong>a</strong> d luck b <strong>all</strong> , B <strong>a</strong> d luck Bobby, b <strong>a</strong> d luck b <strong>alll</strong><br />
Now to drown his m <strong>a</strong> ny troubles<br />
Bobby Bippy&rsquo;s blowing bubbles.</p>

<p>/ al*/</p>

<p>这里的星号（*）匹配0个或多个在它前面的那个字符。前面曾提到过，正则表达式里的*和shell里的*作用是截然不同的。在shell里*表示任意个数的任意字符，而在正则表达式里，*只代表任意个数（包括0个）的前一字符，*可以看作和它前面那个字符是粘连在一起的，*只限制它前面那一个字符。这个正则表达式中的*匹配单独一个或多个连续的l，甚至也匹配一个l也没有的模式，所以，单个字符a也会被匹配。</p>

<h2 id="3-4-匹配多个字符">3.4 匹配多个字符</h2>

<p><strong>匹配一组字符里的任意字符</strong> <strong>[ ]</strong></p>

<p>Here is a tongue twister:</p>

<p>Bobby Bippy bought a bat.</p>

<p>Bobby Bippy bought a <strong>ball</strong>.<br />
With his bat Bob banged the <strong>ball</strong><br />
Banged it bump against the <strong>wall</strong><br />
But so boldly Bobby banged it<br />
That he burst his rubber <strong>ball</strong> , &ldquo;Boo!&rdquo; cried Bobby<br />
Bad luck <strong>ball</strong> , Bad luck Bobby, bad luck <strong>ball</strong> l<br />
Now to drown his many troubles<br />
Bobby Bippy&rsquo;s blowing bubbles.</p>

<p>/[bw]all/</p>

<p>方括号匹配一组字符中的一个，这个正则表达式查找的是第一个字母是b或w，后面紧跟着all的字符串，因此在这个例子中，wall和ball都会被匹配。</p>

<p><strong>匹配指定范围内的字符</strong> <strong>[x-y]</strong></p>

<p>Here is a tongue twister:</p>

<p>Bobby <strong>Bip</strong> py bought a bat.</p>

<p>Bobby <strong>Bip</strong> py bought a ball.<br />
With his bat Bob banged the ball<br />
Banged it bump against the wall<br />
But so boldly Bobby banged it<br />
That he burst his rubber ball, &ldquo;Boo!&rdquo; cried Bobby<br />
Bad luck ball, Bad luck Bobby, bad luck ball<br />
Now to drown his many troubles<br />
Bobby <strong>Bip</strong> py&rsquo;s blowing bubbles.</p>

<p>/B[a-z]p/</p>

<p>方括号里的短线（-）匹配某一范围内的一个字符，这个正则表达式将查找第一个字母是B，第二个字母是ASCII码介于a到z的字符（小写字母），第三个字母是p的字符串。</p>

<p><strong>匹配不在指定范围内的字符</strong> <strong>[^ ]</strong></p>

<p>Here is a tongue twister:</p>

<p>Bobby Bippy bought a bat.</p>

<p>Bobby Bippy bought a b <strong>all.</strong></p>

<p>With his bat Bob banged the ball<br />
Banged it bump against the wall<br />
But so boldly Bobby banged it<br />
That he burst his rubber b <strong>all,</strong> &ldquo;Boo!&rdquo; cried Bobby<br />
Bad luck b <strong>all,</strong> Bad luck Bobby, bad luck ball<br />
Now to drown his many troubles<br />
Bobby Bippy&rsquo;s blowing bubbles.</p>

<p>/all[^A-Z0-9]/</p>

<p>方括号内的脱字符^是一个否定字符，这个正则表达式查找的是后面带一个特殊字符的all，这个特殊字符既不是小写字母又不是大写字母，也不是0到9的数字，比如它可以是一个标点符号或空格。</p>

<p><strong>根据字符</strong> <strong>x</strong> <strong>出现的次数匹配</strong> <strong>x\{m\} x\{m,\} x\{m, n\}</strong></p>

<p>比如这个正则表达式：/Go\{2,5\}gle/将匹配G后面至少出现2个，最多有不超过5个o的模式。Google，Goooogle会被匹配，而Gogle和Goooooogle则不会被匹配。</p>

<h2 id="3-5-转义字符">3.5 转义字符</h2>

<p>如果要匹配的字符串中含有正则表达式的原字符，需要用斜线将其转义，就像c语言里打印单引号 ’ 要写成 \’
一样。这里有个例子：我们想要查找字符串google.com，要查找的字符串里含有正则表达式的原字符“ <strong>.</strong> ”，因此这个正则表达式要写成
/google <strong>\.</strong> com/，如果不用 <br />
转义，找到的将是google后面跟一个任意的字符，然后跟一个com的字符串。这显然不一定是我们要找的。</p>

<h2 id="3-6-字符标签">3.6 字符标签</h2>

<p>例如在下面一段文字里：</p>

<p>Occurence and happening are the most general. I mean, the words occurence and
happening are most generally used.</p>

<dl>
<dt>在这段文字里有两个拼错的单词，Occurence和occurence，（其实应该是occurrence），我们可以在vi中用下面的表达式将其修改：</dt>
</dl>

<p>:1,$s/ <strong>\(</strong> [Oo]ccur <strong>\)</strong> ence/ <strong>\1</strong> rence/</p>

<p>我们且不管这个vi命令的用法（其实它是一个替换命令，我们在后面介绍sed时还将提到）我们先拿出这个语句中的两个表达式：</p>

<p>/ <strong>\(</strong> [Oo]ccur <strong>\)</strong> ence/</p>

<p><strong>\1</strong> rence</p>

<p>其中前一个是一个正则表达式。这个命令用后面的表达式内容替换前面的正则表达式匹配到的内容。vi编辑器将查找单词Occurence和occurence，如果找到，就把圆括号中的内容加上标签（Occur或occur被加上标签），因为这是第一个被标记的模式，所以被称为标签1。这个模式被保存在称为寄存器1的内存寄存器中。在第二个正则表达式中用\1引用寄存器1中的内容，\1被替换为寄存器中的内容，后面紧跟一个rence，于是，拼错的Occurence和occurence被改正为正确的Occurrence和occurrence。</p>

<h2 id="3-7-原字符组合使用的例子">3.7 原字符组合使用的例子</h2>

<p>例1：/\/</p>

<p>Here is a tongue twister:</p>

<p>Bobby Bippy bought a bat.</p>

<p><strong>Bobby Bippy bought a ball</strong>.<br />
With his bat <strong>Bob</strong> <strong>banged the b</strong> <strong>all</strong><br />
Banged it bump against the wall<br />
But so boldly Bobby banged it<br />
That he burst his rubber ball, &ldquo;Boo!&rdquo; cried Bobby<br />
Bad luck ball, Bad luck <strong>Bobby, bad luck ball</strong><br />
Now to drown his many troubles<br />
Bobby Bippy&rsquo;s blowing bubbles.</p>

<p>/\/</p>

<p>匹配以Bob开头，后面跟任意个数的任意字符，然后以all结尾的字符串。这里再次重复， *
在Shell里表示任意个数的任意字符，而在正则表达式里表示任意个数的 <strong>前一</strong> 字符。与 <strong>.</strong>
配合使用表示任意个数（包括零个）的任意字符。实际上，*
也可以表示重复零次或任意次它前面的一组字符，我们称这一组（有时也可能是一个）字符为“原子”。当原子包括多个字符时，这多个字符要用圆括号括起来，并且需要将圆括号转义；当原子只含一个字符时，可以不用圆括号。在这个例子里，
<strong>.</strong> 表示一个任意字符，紧跟着一个*表示重复0次或任意次前面的那个任意字符。而下面的例子</p>

<p>/\(sup\)*info/</p>

<p>则表示匹配在字符串info前有0个或多个sup的字符串，因此 supinfo, info, supsupinfo都会被匹配。</p>

<p>例2：/B[a-z][bp]*y$/</p>

<p>Here is a tongue twister:</p>

<p>Bobby Bippy bought a bat.</p>

<p>Bobby Bippy bought a ball.<br />
With his bat Bob banged the ball<br />
Banged it bump against the wall<br />
But so boldly Bobby banged it<br />
That he burst his rubber ball, &ldquo;Boo!&rdquo; cried <strong>Bobby</strong><br />
Bad luck ball, Bad luck Bobby, bad luck ball<br />
Now to drown his many troubles<br />
Bobby Bippy&rsquo;s blowing bubbles.</p>

<p>/B[a-z][bp]*y$/</p>

<p>这个正则表达式匹配这样的字符串：开头字符是B，第二个字母是一个小写字母，后面紧跟0个或多个重复的b或p，最后跟一个y，并且这个字符串位于行的末尾。</p>

<ol>
<li>
<br /></li>
</ol>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>