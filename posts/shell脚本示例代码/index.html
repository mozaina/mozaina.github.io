<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell脚本示例代码 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell脚本示例代码 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell脚本示例代码">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E8%84%9A%E6%9C%AC%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell脚本示例代码</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p>1. echo_printf_usage.sh: echo和printf的用法</p>

<pre><code>#! /bin/bash

# echo和printf的用法

# echo是用于终端打印的基本命令.在默认情况下,echo在每次调用后会添加一个换行符
echo &quot;hello, beijing&quot;
echo &quot;$(pwd)&quot;
echo '$(pwd)' # 结果并不是希望得到的,将会输出: $(pwd)
echo $(pwd) # 输出结果同 echo &quot;$(pwd)&quot;

# 在默认情况下，echo会将一个换行符追加到输出文本的尾部.可以使用标志”-n”来忽略结尾的换行符
echo -n  what is your name?
echo 'hello, spring'

# 如果需要使用转义序列,则采用echo -e 这种形式
echo -e &quot;1\t2\t3&quot;
echo &quot;\&quot;china beijing\&quot;&quot;

# 显示结果定向至文件
echo &quot;csdn blog: https://blog.csdn.net/fengbingchun&quot; &gt; a.txt

# 反引号用于执行命令
echo  &quot;date: `date`&quot;

# printf是另一个可用于终端打印的命令,它使用的参数和C语言中的printf函数一样
# 默认printf不会像echo自动添加换行符，我们可以手动添加\n
# %-10s 指一个宽度为10个字符(-表示左对齐，没有则表示右对齐)，任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来
printf &quot;hello, world\n&quot;
printf &quot;%-5s %-10s %-4s\n&quot; No Name Mark
printf &quot;%-5s %-10s %-4.2f\n&quot; 1 Sarath 80.3456
printf &quot;%-5s %-10s %-4.2f\n&quot; 2 James 90.9989
printf &quot;%-5s %-10s %-4.2f\n&quot; 3 Jeff 77.564

val=5
printf &quot;val: %d\n&quot; ${val}
</code></pre>

<p>2. input_output_redirection_usage.sh：输入输出重定向的使用</p>

<pre><code>​#! /bin/bash

# 输入输出重定向的使用

# 重定向一般通过在命令间插入特定的符号来实现
# command &gt; file : 将输出重定向到file
# command &lt; file : 将输入重定向到file
# command &gt;&gt; file : 将输出以追加的方式重定向到file
# n &gt; file : 将文件描述符为n的文件重定向到file
# n &gt;&gt; file : 将文件描述符为n的文件以追加的方式重定向到file
# n &gt;&amp; m : 将输出文件m和n合并
# n &gt;操作符
echo `who` &gt; ${1}
echo `pwd` &gt;&gt; ${1}

# 输入重定向：
</code></pre>

<p>3. parameter_usage.sh：参数的使用</p>

<pre><code>​#! /bin/bash

# 参数的使用

# 我们可以在执行Shell脚本时,向脚本传递参数,脚本内获取参数的格式为:$n. n代表一个数字,1为执行脚本的第一个参数，2为执行脚本的第二个参数，以此类推

if [ $# != 3 ]; then
    echo &quot;usage: $0 param1 param2 param3&quot;
    echo &quot;e.g: $0 1 2 3&quot;
    exit 1
fi

echo &quot;执行文件名： $0&quot;
echo &quot;param1: $1&quot;; echo &quot;param2: $2&quot;; echo &quot;param3: $3&quot;

# 特殊字符用来处理参数
# $#: 传递到脚本的参数个数
echo &quot;参数个数为： $#&quot;
# $*: 以一个单字符串显示所有向脚本传递的参数
echo &quot;传递的参数作为一个字符串显示: $*&quot;
# $@: 与$*相同，但是使用时加引号，并在引号中返回每个参数
echo &quot;传递的参数作为字符串显示: $@&quot;

for i in &quot;$*&quot;; do # 循环一次
    echo &quot;loop&quot;; echo $i
done

echo &quot;&quot;
for i in &quot;$@&quot;; do # 循环三次
    echo &quot;loop&quot;; echo $i
done
</code></pre>

<p>4. variable_usage.sh：变量的用法</p>

<pre><code>​#! /bin/bash

# 变量的用法

# 脚本语言通常不需要在使用变量之前声明其类型.只需要直接赋值就可以了.在Bash中,每一个变量的值都是字符串
# 无论你给变量赋值时有没有使用引号,值都会以字符串的形式存储.
# 有一些特殊的变量会被shell环境和操作系统环境用来存储一些特别的值，这类变量被称为环境变量

# 变量名的命名须遵循如下规则:
#   变量名和等号之间不能有空格;命名只能使用英文字母，数字和下划线，首个字符不能以数字开头;
#   中间不能有空格，可以使用下划线&quot;_&quot;; 不能使用标点符号; 不能使用bash里的关键字.

# 运行shell时，会同时存在三种变量
#   局部变量:在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量
#   环境变量:所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行.必要的时候shell脚本也可以定义环境变量
#   shell变量:是由shell程序设置的特殊变量.shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

# 如果value不包含任何空白字符(如空格),那么它不需要使用引号进行引用,反之,则必须使用单引号或双引号
var=value # var = value 是错误的, &quot;=&quot;两边不能有空格

# 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界
# 推荐给所有变量加上花括号
echo $var # 注意echo $(var) 是错误的
echo ${var}

fruit=apple
count=5
echo &quot;We have $count ${fruit}(s)&quot;

# 已定义的变量，可以被重新定义
var=1234567890
echo ${#var} # 获得变量值的长度

# 环境变量
echo &quot;PATH: ${PATH}&quot;
echo &quot;HOME: ${HOME}&quot;
echo &quot;PWD: ${PWD}&quot;
echo &quot;USER: ${USER}&quot;
echo &quot;UID: ${UID}&quot;
echo &quot;SHELL: ${SHELL}&quot;

# 除了显式地直接赋值，还可以用语句给变量赋值
# 将 /etc 下目录的文件名循环出来
for file in `ls /etc`; do
    echo ${file}
done

for file in $(ls .); do
    echo ${file}
done

# 只读变量:使用readonly命令可以将变量定义为只读变量，只读变量的值不能被改变
readonly var; #var=2 # Error: var: readonly variable

# 删除变量:使用unset命令可以删除变量,变量被删除后不能再次使用。unset命令不能删除只读变量
unset count; echo &quot;count: ${count}&quot;
unset var; echo &quot;var: ${var}&quot; # Error: var: cannot unset: readonly variable
</code></pre>

<p>5. string_usage.sh：字符串的使用</p>

<pre><code>​#! /bin/bash

# 字符串的使用

# 字符串可以用单引号，也可以用双引号，也可以不用引号

# 单引号:
str='this is a string'; echo &quot;${str}&quot;
# 单引号字符串的限制：
#   单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的
#   单引号字串中不能出现单引号(对单引号使用转义符后也不行)
echo '${str}' # print: ${str}

# 双引号: 双引号里可以有变量;双引号里可以出现转义字符

# 拼接字符串
var1=&quot;hello&quot;; var2=&quot;beijing&quot;
var3=&quot;hi, ${var1}, ${var2}!&quot;; echo &quot;${var3}&quot;

# 获取字符串长度
echo &quot;var3 length: ${#var3}&quot;

# 抓取子字符串
# 从var3字符串第2个字符开始截取4个字符
echo &quot;${var3}&quot;; echo &quot;${var3:1:4}&quot;

# 查找子字符串: 注意:找出字符串中字符第一次出现的位置,若找不到则expr index返回0. 注意它匹配的是字符而非字符串
echo &quot;${var3}&quot;; echo `expr index &quot;${var3}&quot; i`
</code></pre>

<p>6. operator_usage.sh：运算符的使用</p>

<pre><code>​#! /bin/bash

# 运算符的使用

# expr是一款表达式计算工具，使用它能完成表达式的求值操作,可以用于基本算数操作
# 注意:表达式和运算符之间要有空格; 完整的表达式要被` `包含
val1=3; val2=5
val=`expr ${val1} + ${val2}`
echo &quot;val = ${val}&quot;

# let命令可以直接执行基本的算数操作.当使用let时，变量名之前不需要再添加”$”. 
# 操作符”[]”的使用方法和let命令类似.也可以使用”(())”，但使用”(())”时，变量名之前需要加上$
let ret=val1+val2
echo &quot;ret: ${ret}&quot;

ret=$((val1*val2))
echo &quot;ret: ${ret}&quot;

# expr和let都不支持浮点运算，bc支持浮点运算
ret=`echo &quot;${val1} * 1.5&quot; | bc`
echo &quot;ret: ${ret}&quot;

# 算术运算符:＋、-、×、／、%、＝、＝＝、!=
# 注意：条件表达式要放在方括号之间，并且要有空格；乘号(*)前边必须加反斜杠(\)才能实现乘法运算
val=`expr ${val1} \* ${val2}`
echo &quot;val = ${val}&quot;

if [ ${val1} == ${val2} ]; then
    echo &quot;${val1} 等于 ${val2}&quot;
else
    echo &quot;${val1} 不等于 ${val2}&quot;
fi

# 关系运算符: -eq、-ne、-gt、-lt、-ge、-le,返回true或false
# 注意：关系运算符只支持数字，不支持字符串，除非字符串的值是数字
if [ ${val1} -lt ${val2} ]; then
    echo &quot;${val1} 小于 ${val2}&quot;
else
    echo &quot;${val1} 不小于　${val2}&quot;
fi

# 布尔运算符: !(非)、-o(或)、-a(与),返回true或false
if [ ${val1} -eq ${val2} -o ${val1} -lt ${val2} ]; then
    echo &quot;${val1} 等于或小于 ${val2}&quot;
else
    echo &quot;${val1} 大于　${val2}&quot;
fi

# 逻辑运算符:&amp;&amp;、||,返回true或false
val3=2
if [[ ${val1} -gt ${val3} &amp;&amp; ${val2} -ge ${val3} ]]; then # 注意：这里要用两个[[  ]]
    echo &quot;${val1} &gt; ${val3} 且 ${val2} &gt;= ${val3}&quot;
else
    echo &quot;${val1} &lt;= ${val3} 且 ${val2} &lt; ${val3}&quot;
fi

# 字符串运算符：=、!=、-z(检测字符串长度是否为０，为０返回true)、-n(检测字符串长度是否为０，不为０返回true)等
str1=&quot;abc&quot;; str2=&quot;def&quot;; str3=&quot;&quot;
if [ ${str1} != ${str2} ]; then
    echo &quot;${str1} != ${str2}&quot;
else
    echo &quot;${str1} == ${str2}&quot;
fi

if [ -z ${str3} ]; then
    echo &quot;${str3} 长度为0&quot;
fi

if [ -n ${str1} ]; then
    echo &quot;${str1} 长度不为0&quot;
fi

if [ ${str1} ]; then
    echo &quot;${str1} 不为空&quot;
fi

# 文件测试运算符：用于检测Unix文件的各种属性
#   -b file: 检测文件是否是块设备文件，如果是，则返回 true
#   -c file: 检测文件是否是字符设备文件，如果是，则返回 true
#   -d file: 检测文件是否是目录，如果是，则返回 true
#   -f file: 检测文件是否是普通文件(既不是目录，也不是设备文件)，如果是，则返回 true
#   -g file: 检测文件是否设置了 SGID 位，如果是，则返回 true
#   -r file: 检测文件是否可读，如果是，则返回 true
#   -w file: 检测文件是否可写，如果是，则返回 true
#   -x file: 检测文件是否可执行，如果是，则返回 true
#   -s file: 检测文件是否为空（文件大小是否大于0），不为空返回 true
#   -e file: 检测文件（包括目录）是否存在，如果是，则返回 true
file=&quot;./operator_usage.sh&quot;
if [[ -r ${file} &amp;&amp; -w ${file} &amp;&amp; -x ${file} &amp;&amp; -s ${file} &amp;&amp; -e ${file} ]]; then
    echo &quot;${file}　是可读、可写、可执行的,文件不为空,文件存在   &quot;
fi

if [ -f ${file} ]; then
    echo &quot;${file} 是普通文件&quot;
fi

dir=&quot;../Samples_Shell&quot;
if [ -d ${dir} ]; then
    echo &quot;${dir} 是目录&quot;
fi

# test命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试
if test ${val1} -le ${val2}; then
    echo &quot;${val1} &lt;= ${val2}&quot;
fi

if test ${str1} != ${str2}; then
    echo &quot;${str1} != ${str2}&quot;
fi

if test -r ${file}; then
    echo &quot;${file} 可读&quot;
fi
</code></pre>

<p>7. if_for_while_case_usage.sh ：if, for, while, case的使用</p>

<pre><code>​#! /bin/bash

# if、for、while、case的使用

# if
val1=5; val2=10
if [ ${val1} == ${val2} ]; then
    echo &quot;${val1} == ${val2}&quot;
elif [ ${val1} -gt ${val2} ]; then
    echo &quot;${val1} &gt; ${val2}&quot;
else
    echo &quot;${val1} &lt; ${val2}&quot;
fi

# for
arr=(1 2 3 4 5)
for val in ${arr[@]}; do
    echo &quot;val ${val}&quot;
done

# while
val=1
while (( ${val} &lt;= 5 )); do # 注意是两个((  ))
    echo &quot;val: ${val}&quot;
    let val++
done

# until: 执行一系列命令直至条件为true时停止
val=1
until [ ! ${val} -lt 5 ]; do
   echo &quot;val: ${val}&quot;
   val=`expr ${val} + 1`
done

# case
val=4 # 2
case ${val} in
    1) echo &quot;val = 1&quot; ;;
    2) echo &quot;val = 2&quot; ;;
    3) echo &quot;val = 3&quot; ;;
    *) echo &quot;val is other value&quot; ;;
esac

# break
for val in ${arr[@]}; do
    echo &quot;val: ${val}&quot;
    if [ ${val} == 2 ]; then
        break
    fi
done

# continue
for val in ${arr[@]}; do
    if [ ${val} == 2 ]; then
        continue
    fi
    echo &quot;val: ${val}&quot;
done
</code></pre>

<p>8. array_usage.sh：数组的使用</p>

<pre><code>​#! /bin/bash

# 数组的使用

# bash支持一维数组(不支持多维数组),初始化时不需要定义数组大小,并且没有限定数组的大小。
# 类似与C语言,数组元素的下标由0开始编号.获取数组中的元素要利用下标,下标可以是整数或算术表达式，其值应大于或等于0.

# 定义数组:在Shell中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开
arr=(hi bei jing)
echo &quot;${arr[0]} ${arr[1]} ${arr[2]}&quot;
# 也可以单独定义数组的各个分量
arr[1]=&quot;tian&quot;
# 读取数组
echo &quot;${arr[0]} ${arr[1]} ${arr[2]}&quot;
# 使用@符号可以获取数组中的所有元素
echo &quot;${arr[@]}&quot;

# 获取数组的长度
echo &quot;length: ${#arr[@]}&quot; # 3
echo &quot;length: ${#arr[*]}&quot; # 3
# 取得数组单个元素的长度
echo &quot;sub length: ${#arr[2]}&quot;

# 获取数组所有元素的长度
length=0
for i in &quot;${arr[@]}&quot;; do
    let length+=${#i}
done
echo &quot;all length: ${length}&quot;
</code></pre>

<p>9. function_usage.sh：函数的使用</p>

<pre><code>​#! /bin/bash

# 函数的使用

# 可以带function fun()定义，也可以直接fun()定义,不带任何参数
# 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值
fun1() {
    echo &quot;this is a shell function!&quot;
}

echo &quot;调用fun()函数&quot;
# 注意：调用函数仅使用其函数名即可;所有函数在使用前必须定义
fun1

#
val=5
echo &quot;val: ${val}&quot;

fun2() {
    let val=val+5
}

fun2
echo &quot;val: ${val}&quot;

# 函数返回值在调用该函数后通过$?来获得
fun3 () {
    val1=20; val2=30
    let val3=val1+val2
    return ${val3}
}

fun3
echo &quot;${val1} + ${val2} = $?&quot;

# 函数参数
fun4() {
    echo &quot;第一个参数为：　${1}&quot;
    echo &quot;第二个参数为：　${2}&quot;
    echo &quot;参数总数有 $# 个&quot;
    echo &quot;作为一个字符串输出所有参数: $*&quot;
    let val=${1}+${2}
    echo &quot;val: ${val}&quot;
}

fun4 -5 -10
</code></pre>

<p>10. read_txt_file_analysis.sh：读取文本文件分析</p>

<pre><code>​#! /bin/bash

# 读取txt文件并分析

if [ $# != 2 ]; then
    echo &quot;usage: $0 src_txt_file dst_txt_file&quot;
    echo &quot;e.g: $0 ./a.txt ./b.txt&quot;
    exit 1
fi

# 读指定的txt文件，并将每行打印输出
echo &quot;1.&quot; &gt;&gt; &quot;$2&quot;
while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
    echo &quot;Text read from file: $line&quot; &gt;&gt; &quot;$2&quot;
done &lt; &quot;$1&quot;

# 判断每行中是否含有指定字符，对满足条件的行写入指定的文件
echo &quot;2.&quot; &gt;&gt; &quot;$2&quot;
sub=&quot;88&quot;
while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
    if [[ &quot;$line&quot; != &quot;${line%$sub*}&quot; ]]; then
        echo &quot;${line}&quot; &gt;&gt; &quot;$2&quot;
    fi
done &lt; &quot;$1&quot;

# 如果每行字符长度大于５,则移除每行中最后５个字符，并写入指定的文件
echo &quot;3.&quot; &gt;&gt; &quot;$2&quot;
value=5
while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
    length=${#line}
    #echo &quot;length: ${length}&quot;
    if [[ &quot;${length}&quot; -ge &quot;${vale}&quot; ]]; then
        echo &quot;${line::-${value}}&quot; &gt;&gt; &quot;$2&quot;
    fi
done &lt; &quot;$1&quot;

# 如果每行字符长度大于10,则移除每行中最前10个字符，并写入指定的文件
echo &quot;4.&quot; &gt;&gt; &quot;$2&quot;
value=10
while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
    length=${#line}
    if [[ &quot;${length}&quot; -ge &quot;${vale}&quot; ]]; then
        echo &quot;${line:${value}}&quot; &gt;&gt; &quot;$2&quot;
    fi
done &lt; &quot;$1&quot;

# 判断每行中是否含有指定字符,若有则用指定的字符替换原有的字符，并写入指定的文件
echo &quot;5.&quot; &gt;&gt; &quot;$2&quot;
sub1=&quot;group&quot;; sub2=&quot;class&quot;
while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
    if [[ &quot;$line&quot; != &quot;${line%$sub1*}&quot; ]]; then
        echo ${line} | sed -e &quot;s/${sub1}/${sub2}/g&quot; &gt;&gt; &quot;$2&quot;
    fi
done &lt; &quot;$1&quot;
</code></pre>

<p>11. read_directory_analysis.sh：读取目录文件分析</p>

<pre><code>​#! /bin/bash

# 读取目录文件并分析

if [ $# != 2 ]; then
    echo &quot;usage: $0 src_directory dst_txt_file&quot;
    echo &quot;e.g: $0 ./a ./a.txt&quot;
    exit 1
fi

# 遍历指定目录(当前层)下所有文件和目录，并写入指定txt文件
echo &quot;1.&quot; &gt;&gt; $2
for name in `ls $1`; do
    echo &quot;name: ${name}&quot; &gt;&gt; $2
done

# 遍历指定目录下所有文件，包括子目录下的所有文件,并写入指定txt文件
echo &quot;2.&quot; &gt;&gt; $2
for name in $(find $1 -type f -name &quot;*&quot;); do
    echo &quot;${name}&quot; &gt;&gt; $2
done

# 遍历指定目录下所有目录，包括子目录,并写入指定txt文件
echo &quot;3.&quot; &gt;&gt; $2
for name in $(find $1 -type d -name &quot;*&quot;); do
    echo &quot;${name}&quot; &gt;&gt; $2
done

# 遍历指定目录下的所有文件，包括子目录下的所有文件，按要求修改文件名字，并写入指定txt文件
echo &quot;4.&quot; &gt;&gt; $2
name1=&quot;xxx&quot;; name2=&quot;yyy&quot;
for name in $(find $1 -type f -name &quot;*${name1}*&quot;); do
    new_file_name=$(echo ${name} | sed -e &quot;s/${name1}/${name2}/g&quot;)
    echo &quot;${new_file_name}&quot; &gt;&gt; $2

    mv ${name} ${new_file_name}
done

# 遍历指定目录下的所有*.cpp文件，仅将.cpp文件名字并写入指定txt文件，不包括名字前面的路径
echo &quot;5.&quot; &gt;&gt; $2
name=`find ${1} -type f -name &quot;*.cpp&quot; -printf &quot;%f\n&quot;` # 注意：需要将-printf放在-name的后面，否则将会查找指定目录下的所有文件
echo &quot;${name}&quot; &gt;&gt; ${2}

# 遍历指定目录下带有Samples_*名字的子目录，仅将子目录下带有*.cpp的文件写入指定txt文件，不包括名字前面的路径,并且每个名字单独占一行
echo &quot;6.&quot; &gt;&gt; ${2}
for name in $(find ${1} -type d -name &quot;Samples_*&quot;); do
    echo &quot;dir name: ${name}&quot; &gt;&gt; ${2}
    echo `find ${name} -type f -name &quot;*.cpp&quot; -printf &quot;%f\n&quot;` | tr &quot; &quot; &quot;\n&quot; &gt;&gt; ${2}
done
</code></pre>

<p>12. special_usage.sh：一些特殊使用</p>

<pre><code>​#! /bin/bash
# 在#! /bin/bash后加-x，可以打印较多输出信息，一般在调试定位问题时可以使用

# 一些特殊使用

# 可以打印较多输出信息，一般在调试定位问题时可以使用,等同于 #! /bin/bash -x
#set -x

# ------------------------------
echo &quot;shell name： $0&quot;
# 获取此脚本的绝对路径文件名
real_path=$(realpath $0)
echo &quot;real path: ${real_path}&quot;
# 获取此脚本的绝对路径名
dir_name=`dirname &quot;${real_path}&quot;`
echo &quot;dir_name: ${dir_name}&quot;

# ------------------------------
# 调用另一个脚本,注意&quot;.&quot;
. array_usage.sh

# ------------------------------
# mktemp命令用于建立暂存文件
tmp_dir=`mktemp` # 带绝对路径文件名
tmp_dir=${dir_name}${tmp_dir}
echo &quot;tmp_dir: ${tmp_dir}&quot;
# reference: https://unix.stackexchange.com/questions/137775/how-to-extract-part-of-a-filename-before-or-before-extension
echo &quot;only show tmp_dir name: ${tmp_dir##*/}&quot;

# 如果指定目录不存在，则创建
if [[ ! -d ${tmp_dir} ]]; then
    mkdir -p ${tmp_dir}
fi

# ------------------------------
# 通过find命令查找所有目录,包含子目录
# 注意&quot;%P\n&quot;与&quot;%f\n&quot;的区别，“%P”不包含当前目录即&quot;.&quot;，&quot;%f&quot;包含当前目录
for dir in `find . -type d -printf '%P\n'`; do
    echo &quot;dir: ${dir}&quot;
done

# ------------------------------
# =~: 匹配正则表达式
input1=123; input2=4a6; input3=&quot;abcdefg&quot;
if [[ ${input1} =~ [0-9][0-9][0-9] ]]; then
    echo &quot;${input1} is number&quot;
else
    echo &quot;${input1} is not number&quot;
fi

if [[ ${input2} =~ [0-9][0-9][0-9] ]]; then
    echo &quot;${input2} is number&quot;
else
    echo &quot;${input2} is not number&quot;
fi

if [[ ${input3} =~ &quot;cde&quot; ]]; then
    echo &quot;${input3} include cde&quot;
else
    echo &quot;${input3} don't include cde&quot;
fi

# ------------------------------
# reference: http://www.runoob.com/linux/linux-comm-dd.html
# dd命令: 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出
# 把/dev/null看作&quot;黑洞&quot;,它等价于一个只写文件,所有写入它的内容都会永远丢失,而尝试从它那儿读取内容则什么也读不到.然而，/dev/null对命令行和脚本都非常的有用
contents=`dd if=../README.md bs=1 count=17 2&gt;/dev/null` # 禁止标准错误的输出
echo &quot;contents: ${contents}&quot;

# ------------------------------
# 通过&quot;%&quot;截断,%后的内容必须是变量name的最后n个字符，否则不起作用
name=&quot;/tmp/abc/xyz.jpg&quot;
echo &quot;name: ${name%.jpg}&quot; # /tmp/abc/xyz
# 通过&quot;::&quot;截断最后几个字符
echo &quot;name: ${name::-4}&quot; # /tmp/abc/xyz

# ------------------------------
# 通过&quot;##&quot;截断最前面几个字符,##后的内容必须是变量name的最前n个字符，否则不起作用
echo &quot;name: ${name##/tmp}&quot; # /abc/xyz.jpg
# 通过&quot;:&quot;截断最前面几个字符
echo &quot;name: ${name:4}&quot; # /abc/xyz.jpg

# ------------------------------
# 通过sed解析指定文件中的指定字段，并根据要求写入到另一指定文件中
sed '/typedef struct/,/}/!d;//d' file.txt  | sed 's/x[0-9]://' | sed 's/y[0-9]://' | sed 's/$/,/' # &gt; ./tmp/tmp.txt

# ------------------------------
# 通过find查找指定的所有文件，然后通过xargs将所有文件按照要求进行修改
# -I {}的参数:就是在xargs后续命令里，用{}代表xargs之前的命令结果
find . -name &quot;*.sh&quot; | xargs -I {} sed 's/echo/echo -e/' {} &gt; ./tmp/tmp.txt
find . -name &quot;*.sh&quot; | xargs -I {} cp {} ./tmp/

# ------------------------------
# $?: 上个命令的退出状态或函数的返回值.一般情况下，大部分命令执行成功会返回0，失败返回非0值
# reference: https://stackoverflow.com/questions/6834487/what-is-the-dollar-question-mark-variable-in-shell-scripting/6834512
status=$?
echo &quot;status: ${status}&quot;
if [[ ${status} != 0 ]]; then
    echo &quot;注意：非首次执行上面的命令会返回123：find . -name \&quot;*.sh\&quot; | xargs -I {} cp {} ./tmp/ &quot;
    #exit ${status}
fi

echo &quot;ok!!!&quot;

#rm -rf ${tmp_dir}
</code></pre>

<p>13. replace_a_string_with_another_string_in_all_files.sh：文件中字符串的替换</p>

<pre><code>​#! /bin/bash

# 用指定的字符串替换指定目录下所有文件中需要替换的字符串

if [ $# != 3 ]; then    
        echo &quot;usage: $0 directory_name src_string dst_string&quot;
        echo &quot;e.g: $0 ./a abcd 1234&quot;
        exit 1
fi

for file_name in `ls $1`; do
    path_file_name=$1/${file_name}
    if [ -f ${path_file_name} ]; then
        echo &quot;path_file_name: ${path_file_name}&quot;

        tmp_file=tmp.txt
        while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
                if [[ &quot;$line&quot; != &quot;${line%$2*}&quot; ]]; then
                    echo &quot;${line}&quot; | sed -e &quot;s/$2/$3/g&quot; &gt;&gt; ${tmp_file}
                else    
                echo &quot;${line}&quot; &gt;&gt; ${tmp_file}
                # 注意:不是 echo ${line} &gt;&gt; ${tmp_file}
                # 若 ${line}两边不带双引号，则会将原文件中的空格给移除掉
            fi
        done &lt; &quot;${path_file_name}&quot;
        mv ${tmp_file} ${path_file_name}
    fi
done
</code></pre>

<p>14. analysis_log_file_delete_lines.sh：删除文本文件中含有指定字符串的所有行</p>

<pre><code>#! /bin/bash

# 作用：输入源log文件，生成新log文件，新文件是删除了所有行中带有指定字符串的行
# 用法：输入参数依次为：源log文件名字，字符串，新log文件文件名字

if [ $# != 3 ]; then
        echo &quot;Error: usage: $0 log_file_name string new_log_file_name&quot;
        echo &quot;e.g: $0 ./log.txt abcd ./new_log.txt&quot;
        exit 1
fi

if [[ ! -e $1 ]]; then
        echo &quot;Error: file does not exist: $1&quot;
        exit 1
fi

if [[ -e $3 ]]; then
        echo &quot;WARNINT: file exist, first need to delete: $3&quot;
        rm $3
fi

while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
        if [[ &quot;$line&quot; == &quot;${line%$2*}&quot; ]]; then
                echo &quot;${line}&quot; &gt;&gt; &quot;$3&quot;
        fi
done &lt; &quot;$1&quot;
</code></pre>

<p>15. analysis_log_file_extract_lines.sh：提取出文本文件中含有指定字符串的所有行</p>

<pre><code>#! /bin/bash

# 作用：输入源log文件，生成新log文件，新文件是仅含有带有指定字符串的行
# 用法：输入参数依次为：源log文件名字，字符串，新log文件文件名字

if [ $# != 3 ]; then
        echo &quot;Error: usage: $0 log_file_name string new_log_file_name&quot;
        echo &quot;e.g: $0 ./log.txt abcd ./new_log.txt&quot;
        exit 1
fi

if [[ ! -e $1 ]]; then
        echo &quot;Error: file does not exist: $1&quot;
        exit 1
fi

if [[ -e $3 ]]; then
        echo &quot;WARNINT: file exist, first need to delete: $3&quot;
        rm $3
fi

while IFS='' read -r line || [[ -n &quot;$line&quot; ]]; do
        if [[ &quot;$line&quot; != &quot;${line%$2*}&quot; ]]; then
                echo &quot;${line}&quot; &gt;&gt; &quot;$3&quot;
        fi
done &lt; &quot;$1&quot;
</code></pre>

<p>以上脚本主要参考：<a href="http://www.runoob.com/linux/linux-shell.html">http://www.runoob.com/linux/linux-shell.html</a></p>

<p><strong>GitHub</strong> ： <a href="https://github.com/fengbingchun/Linux_Code_Test">https://github.com/fengbingchun/Linux_Code_Test</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>