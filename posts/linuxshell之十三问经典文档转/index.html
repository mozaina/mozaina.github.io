<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linuxshell之十三问经典文档转 | 开发者问答集锦</title>
    <meta property="og:title" content="linuxshell之十三问经典文档转 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linuxshell之十三问经典文档转">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E4%B9%8B%E5%8D%81%E4%B8%89%E9%97%AE%E7%BB%8F%E5%85%B8%E6%96%87%E6%A1%A3%E8%BD%AC/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linuxshell之十三问经典文档转</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><strong>Shell 十三问——ChinaUnix论坛精华整理</strong></p>

<hr />

<hr />

<hr />

<hr />

<p><strong>原创</strong></p>

<p>|</p>

<p><strong>ChinaUnix 网中人</strong></p>

<p>&mdash;|&mdash;</p>

<p><strong>整理</strong></p>

<p>|</p>

<p><strong>Lkydeer</strong></p>

<p><strong>整理时间</strong></p>

<p>|</p>

<p><strong>2007-7-19</strong></p>

<p><strong>联系方式</strong></p>

<p>|</p>

<p><strong>lkydeer@hotmail.com</strong></p>

<p>**<br />
**</p>

<p><strong>目 录</strong></p>

<p>1 简介&hellip; 3</p>

<p>2 为何叫做shell ？&hellip; 3</p>

<p>3 shellprompt(PS1) 与Carriage Return(CR) 的关系？&hellip;4</p>

<p>4 别人 echo、你也echo ，是问echo 知多少？&hellip; 5</p>

<p>5 &ldquo;&rdquo;(双引号) 与 &lsquo; &lsquo;(单引号)差在哪？&hellip; 7</p>

<p>6 var=value？export前后差在哪？&hellip; 11</p>

<p>7 exec 跟source 差在哪？&hellip; 16</p>

<p>8 ( ) 与 { } 差在哪？&hellip; 20</p>

<p>9 $(( )) 与 $( ) 还有${ } 差在哪？&hellip; 21</p>

<p>10 $@ 与 $* 差在哪？&hellip; 25</p>

<p>11 &amp;&amp;与 || 差在哪？&hellip; 27</p>

<p>12 &gt; 与 &lt; 差在哪？&hellip; 31</p>

<p>12.1.31</p>

<p>12.2.32</p>

<p>12.3.33</p>

<p>12.4.34</p>

<p>12.5.37</p>

<p>13 你要 if 还是 case呢？&hellip; 38</p>

<p>14 forwhat? while 与until 差在哪？&hellip; 42</p>

<p>15 [^ ] 跟 [! ] 差在哪？&hellip; 45</p>

<h1 id="1-简介">1 简介</h1>

<p>ChinaUnix论坛shell版名为网中人的前辈于2004年发布的精华贴，最近学习这块内容，觉得很多东西讲的实在透彻，非常感谢前辈网中人，但是还是自己功力不够，很多问题解答不了，不知道有没有word或者pdf版，自己简单整理了一份，留着慢慢体会，也提供给大家，希望有用，疏漏处请见谅。</p>

<h1 id="2-为何叫做-shell">2 为何叫做 shell ？</h1>

<p>在介绍shell
是甚么东西之前，不妨让我们重新检视使用者与计算机系统的关系：我们知道计算机的运作不能离开硬件，但使用者却无法直接对硬件作驱动，硬件的驱动只能透过一个称为&rdquo;操作系统(Operating
System)&ldquo;的软件来控管，事实上，我们每天所谈的 linux
，严格来说只是一个操作系统，我们称之为&rdquo;核心(kernel)&ldquo;。然而，从使用者的角度来说，使用者也没办法直接操作 kernel ，而是透过kernel
的&rdquo;外壳&rdquo;程序，也就是所谓的 shell ，来与 kernel 沟通。这也正是 kernel 跟shell 的形像命名关系。</p>

<p>从技术角度来说，shell 是一个使用者与系统的互动界面(interface)，主要是让使用者透过命令行(command line)来使用系统以完成工作。<br />
因此，shell的最简单的定义就是&mdash;命令解译器(CommandInterpreter)：<br />
* 将使用者的命令翻译给核心处理，<br />
* 同时，将核心处理结果翻译给使用者。</p>

<p>每次当我们完成系统登入(log in)，我们就取得一个互动模式的 shell ，也称为login shell 或 primary
shell。若从行程(process)角度来说，我们在 shell 所下达的命令，均是 shell 所产生的子行程。这现像，我们暂可称之为 fork
。如果是执行脚本(shell script)的话，脚本中的命令则是由另外一个非互动模式的子 shell (sub shell)来执行的。<br />
也就是 primary shell 产生 sub shell 的行程，subshell 再产生 script 中所有命令的行程。<br />
(关于行程，我们日后有机会再补充。)</p>

<p>这里，我们必须知道：kernel 与 shell 是不同的两套软件，而且都是可以被替换的：<br />
* 不同的操作系统使用不同的 kernel ，<br />
* 而在同一个kernel 之上，也可使用不同的 shell 。<br />
在 linux 的预设系统中，通常都可以找到好几种不同的 shell ，且通常会被列于如下档案里：/etc/shells不同的shell
有着不同的功能，且也彼此各异、或说&rdquo;大同小异&rdquo;。<br />
[*]常见的 shell 主要分为两大主流：<br />
sh：<br />
burne shell (sh)<br />
burne again shell(bash)<br />
csh：<br />
c shell (csh)<br />
tc shell (tcsh)<br />
korn shell (ksh)</p>

<p>[*]大部份的 Linux 系统的预设 shell 都是bash ，其原因大致如下两点：<br />
* 自由软件<br />
* 功能强大<br />
bash 是 gnu project 最成功的产品之一，自推出以来深受广大 Unix 用户喜爱，<br />
且也逐渐成为不少组织的系统标准。</p>

<h1 id="3-shellprompt-ps1-与-carriagereturn-cr-的关系">3 shellprompt(PS1) 与 CarriageReturn(CR) 的关系？</h1>

<p>当你成功登录进一个文字界面之后，大部份情形下，你会在荧幕上看到一个不断闪烁的方块或底线(视不同版本而别)，我们称之为<em>游标</em>(coursor)。游标的作用就是告诉你接下来你从键盘输入的按键所插入的位置，且每输如一键游标便向右边移动一个格子，若连续输入太多的话，则自动接在下一行输入。</p>

<p>假如你刚完成登录还没输入任何按键之前，你所看到的游标所在位置的同一行的左边部份，我们称之为<em>提示符号</em>(prompt)。提示符号的格式或因不同系统版本而各有不同，在
Linux 上，只需留意最接近游标的一个可见的提示符号，通常是如下两者之一：<br />
$：给一般使用者账号使用<br />
#：给root (管理员)账号使用</p>

<p>事实上，shell prompt的意思很简单：<br />
* 是 shell告诉使用者：您现在可以输入命令行了。<br />
我们可以说，使用者只有在得到 shell prompt 才能打命令行，而 cursor 是指示键盘在命令行所输入的位置，使用者每输入一个键，cursor
就往后移动一格，直到碰到命令行读进 CR(Carriage Return，由Enter 键产生)字符为止。<br />
CR 的意思也很简单：<br />
* 是使用者告诉 shell：老兄你可以执行我的命令行了。<br />
严格来说：<br />
* 所谓的 <strong>命令行</strong> ，就是在 shell prompt与 CR字符之间所输入的文字。<br />
(思考：为何我们这里坚持使用 CR 字符而不说Enter 键呢？答案在后面的学习中揭晓。)</p>

<p>不同的命令可接受的命令行格式或有不同，一般情况下，一个标准的命令行格式为如下所列：<br />
Command-name Options Argument</p>

<p>若从技术细节来看，shell 会依据 IFS(Internal Field Seperator) 将 command line
所输入的文字给拆解为&rdquo;字段&rdquo;(word)。<br />
然后再针对特殊字符(meta)先作处理，最后再重组整行 command line 。<br />
(注意：请务必理解上两句话的意思，我们日后的学习中会常回到这里思考。)</p>

<p>其中的 <strong>IFS</strong> 是 shell预设使用的字段分隔符，可以由一个及多个如下按键组成：<br />
* 空格键(WhiteSpace)<br />
* 表格键(Tab)<br />
* 回车键(Enter)</p>

<p>系统可接受的命令名称(command-name)可以从如下途径获得：<br />
* 明确路径所指定的外部命令<br />
* 命令别名(alias)<br />
* 自定功能(function)<br />
* shell 内建命令(built-in)<br />
* $PATH 之下的外部命令<br />
每一个命令行均必需含用命令名称，这是不能缺少的。</p>

<h1 id="4-别人-echo-你也-echo-是问-echo-知多少">4 别人 echo、你也 echo ，是问 echo 知多少？</h1>

<p>承接上一章所介绍的 commandline ，这里我们用 echo 这个命令加以进一步说明。<br />
温习&mdash;标准的 command line 包含三个部件：<br />
* command_name option argument</p>

<p>echo是一个非常简单、直接的 Linux命令：<br />
* 将 argument 送出至标准输出(STDOUT)，通常就是在监视器(monitor)上输出。<br />
(注：stdout 我们日后有机会再解说，或可先参考如下讨论：<br />
<a href="http://www.chinaunix.net/forum/viewtopic.php?t=191375">http://www.chinaunix.net/forum/viewtopic.php?t=191375</a> )</p>

<p>为了更好理解，不如先让我们先跑一下 echo 命令好了：</p>

<p>CODE:</p>

<p>$ echo</p>

<p>$</p>

<hr />

<p>你会发现只有一个空白行，然后又回到 shell prompt 上了。<br />
这是因为 echo 在预设上，在显示完 argument 之后，还会送出一个换行符号(new-line charactor)。<br />
但是上面的 command 并没任何的 argument ，那结果就只剩一个换行符号了&hellip;<br />
若你要取消这个换行符号，可利用 echo 的 -noption ：</p>

<p>CODE:</p>

<p>$ echo -n<br />
$</p>

<hr />

<p>不妨让我们回到command line 的概念上来讨论上例的 echo 命令好了：<br />
* command line 只有 command_name(echo) 及 option(-n)，并没有任何 argument 。<br />
要想看看 echo 的 argument ，那还不简单﹗接下来，你可试试如下的输入：</p>

<p>CODE:</p>

<p>$ echo first line<br />
first line<br />
$ echo -n first line<br />
first line $</p>

<hr />

<p>于上两个 echo 命令中，你会发现 argument 的部份显示在你的荧幕，而换行符号则视 -n option 的有无而别。<br />
很明显的，第二个 echo 由于换行符号被取消了，接下来的shell prompt 就接在输出结果同一行了&hellip; ^_^</p>

<p>事实上，echo 除了 -n options 之外，常用选项还有：<br />
<strong>-e</strong> ：启用反斜线控制字符的转换(参考下表)<br />
<strong>-E</strong> ：关闭反斜线控制字符的转换(预设如此)<br />
<strong>-n</strong> ：取消行末之换行符号(与 -e 选项下的 \c 字符同意)</p>

<p>关于 echo 命令所支持的反斜线控制字符如下表：<br />
\a：ALERT / BELL (从系统喇叭送出铃声)<br />
\b：BACKSPACE ，也就是向左删除键<br />
\c：取消行末之换行符号<br />
\E：ESCAPE，跳脱键<br />
\f：FORMFEED，换页字符<br />
\n：NEWLINE，换行字符<br />
\r：RETURN，回车键<br />
\t：TAB，表格跳位键<br />
\v：VERTICAL TAB，垂直表格跳位键<br />
\n：ASCII 八进位编码(以 x 开首为十六进制)<br />
\\：反斜线本身<br />
(表格数据来自 O&rsquo;Reilly 出版社之 Learning the Bash Shell, 2nd Ed.)</p>

<p>或许，我们可以透过实例来了解 echo 的选项及控制字符：</p>

<p>例一：</p>

<p>CODE:</p>

<p>$ echo -e &ldquo;a\tb\tc\nd\te\tf&rdquo;<br />
a b c<br />
d e f</p>

<hr />

<p>上例运用 \t 来区隔 abc 还有 def ，及用 \n 将 def 换至下一行。</p>

<p>例二：</p>

<p>CODE:</p>

<p>$ echo -e &ldquo;\141\011\142\011\143\012\144\011\145\011\146&rdquo;<br />
a b c<br />
d e f</p>

<hr />

<p>与例一的结果一样，只是使用ASCII 八进位编码。</p>

<p>例三：</p>

<p>CODE:</p>

<p>$ echo -e &ldquo;\x61\x09\x62\x09\x63\x0a\x64\x09\x65\x09\x66&rdquo;<br />
a b c<br />
d e f</p>

<hr />

<p>与例二差不多，只是这次换用 ASCII 十六进制编码。</p>

<p>例四：</p>

<p>CODE:</p>

<p>$ echo -ne &ldquo;a\tb\tc\nd\te\bf\a&rdquo;<br />
a b c<br />
d f $</p>

<hr />

<p>因为 e 字母后面是删除键(\b)，因此输出结果就没有 e 了。<br />
在结束时听到一声铃向，那是 \a 的杰作﹗<br />
由于同时使用了 -n 选项，因此 shell prompt 紧接在第二行之后。<br />
若你不用 -n 的话，那你在 \a 后再加个 \c ，也是同样的效果。</p>

<p>事实上，在日后的 shell 操作及 shell script设计上，echo 命令是最常被使用的命令之一。<br />
比方说，用 echo 来检查变量值：</p>

<p>CODE:</p>

<p>$ A=B<br />
$ echo $A<br />
B<br />
$ echo $?<br />
0</p>

<hr />

<p>(注：关于变量概念，我们留到下两章才跟大家说明。)</p>

<p>好了，更多的关于 command line 的格式，以及echo 命令的选项，<br />
就请您自行多加练习、运用了&hellip;</p>

<h1 id="5-双引号-与-单引号-差在哪">5 &ldquo;&rdquo;(双引号) 与 &lsquo; &lsquo;(单引号)差在哪？</h1>

<p>还是回到我们的command line 来吧&hellip;</p>

<p>经过前面两章的学习，应该很清楚当你在 shell prompt 后面敲打键盘、直到按下 Enter 的时候，你输入的文字就是 command line
了，然后 shell 才会以行程的方式执行你所交给它的命令。但是，你又可知道：你在command line 输入的每一个文字，对 shell
来说，是有类别之分的呢？</p>

<p>简单而言(我不敢说这是精确的定议，注一)，command line 的每一个charactor ，分为如下两种：<br />
* <strong>literal ：</strong>也就是普通纯文字，对 shell 来说没特殊功能。<br />
* ** meta：**对shell 来说，具有特定功能的特殊保留字符。<br />
(注一：关于 bash shell 在处理 commandline 时的顺序说明，请参考 O&rsquo;Reilly 出版社之Learning the Bash
Shell, 2nd Edition，第 177 - 180 页的说明，尤其是 178 页的流程图 Figure 7-1 &hellip; )</p>

<p>Literal 没甚么好谈的，凡举 abcd、123456 这些&rdquo;文字&rdquo;都是 literal &hellip; (easy？)<br />
但 meta 却常使我们困惑&hellip;.. (confused?)<br />
事实上，前两章我们在command line 中已碰到两个机乎每次都会碰到的 meta ：<br />
* <strong>IFS ：</strong>由 或  或 三者之一组成(我们常用 space)。<br />
* <strong>CR ：</strong>由 产生。<br />
IFS 是用来拆解command line 的每一个词(word)用的，因为shell command line 是按词来处理的。<br />
而 CR 则是用来结束 command line 用的，这也是为何我们敲  命令就会跑的原因。<br />
除了 IFS 与 CR ，常用的 meta 还有：<br />
 <strong>=</strong> ： 设定变量。<br />
 <strong>$</strong> ： 作变量或运算替换(请不要与 shell prompt 搞混了)。<br />
 <strong>&gt;</strong> ：重导向 stdout。<br />
 **&lt; **：重导向 stdin。<br />
 <strong>|</strong> ：命令管线。<br />
 <strong>&amp;</strong> ：重导向 file descriptor ，或将命令置于背境执行。<br />
 <strong>( )</strong> ：将其内的命令置于 nested subshell 执行，或用于运算或命令替换。<br />
 <strong>{ }</strong> ：将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。<br />
 <strong>;</strong> ：在前一个命令结束时，而忽略其返回值，继续执行下一个命令。<br />
 <strong>&amp; &amp;</strong> ：在前一个命令结束时，若返回值为 true，继续执行下一个命令。<br />
 <strong>||</strong> ：在前一个命令结束时，若返回值为 false，继续执行下一个命令。<br />
 <strong>!</strong> ：执行 history 列表中的命令<br />
&hellip;.</p>

<p>假如我们需要在 command line 中将这些保留字符的功能关闭的话，就需要 quoting 处理了。<br />
在 bash 中，常用的 quoting 有如下三种方法：<br />
* <strong>hard quote ：&rsquo; &lsquo;</strong>(单引号)，凡在 hard quote 中的所有 meta 均被关闭。<br />
* <strong>soft quote ： &ldquo; &ldquo;</strong> (双引号)，在 soft quoe 中大部份 meta 都会被关闭，但某些则保留(如$ )。(注二)<br />
* escape ： \ (反斜线)，只有紧接在 escape (跳脱字符)之后的单一meta 才被关闭。<br />
( 注二：在 soft quote 中被豁免的具体 meta 清单，我不完全知道，有待大家补充，或透过实作来发现及理解。 )</p>

<p>下面的例子将有助于我们对 quoting 的了解：</p>

<p>CODE:</p>

<p>$ A=B C # 空格键未被关掉，作为 IFS 处理。<br />
$ C: command not found.<br />
$ echo $A</p>

<p>$ A=&ldquo;B C&rdquo; # 空格键已被关掉，仅作为空格键处理。<br />
$ echo $A</p>

<p>B C</p>

<hr />

<p>在第一次设定 A 变量时，由于空格键没被关闭，command line 将被解读为：<br />
* A=B 然后碰到，再执行 C 命令<br />
在第二次设定 A 变量时，由于空格键被置于 soft quote 中，因此被关闭，不再作为 IFS ：<br />
* A=BC<br />
事实上，空格键无论在 soft quote 还是在 hardquote 中，均会被关闭。Enter 键亦然：</p>

<p>CODE:</p>

<p>$ A=&lsquo;B<br />
&gt; C<br />
&gt; &lsquo;<br />
$ echo &ldquo;$A&rdquo;<br />
B<br />
C</p>

<hr />

<p>在上例中，由于 被置于 hard quote 当中，因此不再作为 CR 字符来处理。<br />
这里的  单纯只是一个断行符号(new-line)而已，由于 command line 并没得到 CR 字符，因此进入第二个 shell prompt
(PS2，以 &gt; 符号表示)，command line 并不会结束，<br />
直到第三行，我们输入的  并不在 hardquote 里面，因此并没被关闭，此时，command line 碰到 CR 字符，于是结束、交给 shell
来处理。</p>

<p>上例的  要是被置于 softquote 中的话， CR 也会同样被关闭：</p>

<p>CODE:</p>

<p>$ A=&ldquo;B<br />
&gt; C<br />
&gt; &ldquo;<br />
$ echo $A<br />
B C</p>

<hr />

<p>然而，由于 echo $A 时的变量没至于 soft quote 中，因此当变量替换完成后并作命令行重组时，会被解释为 IFS ，而不是解释为 New
Line 字符。</p>

<p>同样的，用 escape 亦可关闭 CR 字符：</p>

<p>CODE:</p>

<p>$ A=B\<br />
&gt; C\<br />
&gt;<br />
$ echo $A<br />
BC</p>

<hr />

<p>上例中，第一个  跟第二个  均被 escape 字符关闭了，因此也不作为 CR 来处理，但第三个  由于没被跳脱，因此作为 CR 结束 command
line 。但由于  键本身在 shell meta 中的特殊性，在 \ 跳脱后面，仅仅取消其 CR 功能，而不会保留其 IFS 功能。</p>

<p>您或许发现光是一个  键所产生的字符就有可能是如下这些可能：<br />
CR<br />
IFS<br />
NL(New Line)<br />
FF(Form Feed)<br />
NULL<br />
&hellip;<br />
至于甚么时候会解释为甚么字符，这个我就没去深挖了，或是留给读者诸君自行慢慢摸索了&hellip; ^_^</p>

<p>至于 soft quote 跟 hard quote 的不同，主要是对于某些 meta 的关闭与否，以 $ 来作说明：</p>

<p>CODE:</p>

<p>$ A=B\ C<br />
$ echo &ldquo;$A&rdquo;<br />
B C<br />
$ echo &lsquo;$A&rsquo;<br />
$A</p>

<hr />

<p>在第一个 echo 命令行中，$ 被置于 soft quote 中，将不被关闭，因此继续处理变量替换，<br />
因此 echo 将 A 的变量值输出到荧幕，也就得到 &ldquo;B C&rdquo; 的结果。<br />
在第二个 echo 命令行中，$ 被置于 hard quote 中，则被关闭，因此 $ 只是一个 $ 符号，<br />
并不会用来作变量替换处理，因此结果是 $ 符号后面接一个 A 字母：$A 。</p>

<p>练习与思考：如下结果为何不同？</p>

<p>CODE:</p>

<p>$ A=B\ C<br />
$ echo &lsquo;&ldquo;$A&rdquo;&rsquo; # 最外面的是单引号<br />
&rdquo;$A&rdquo;<br />
$ echo &ldquo;&lsquo;$A&rsquo;&rdquo; # 最外面的是双引号<br />
&lsquo;B C&rsquo;</p>

<hr />

<p>(提示：单引号及双引号，在 quoting 中均被关?#93;了。)</p>

<p>在 CU 的 shell 版里，我发现有很多初学者的问题，都与 quoting 理解的有关。<br />
比方说，若我们在 awk 或 sed 的命令参数中调用之前设定的一些变量时，常会问及为何不能的问题。<br />
要解决这些问题，关键点就是：<br />
* 区分出 shell meta 与 command meta</p>

<p>前面我们提到的那些 meta ，都是在 commandline 中有特殊用途的，<br />
比方说 { } 是将其内一系列 command line 置于不具名的函式中执行(可简单视为 command block )，<br />
但是，awk 却需要用 { } 来区分出 awk 的命令区段(BEGIN, MAIN, END)。<br />
若你在 command line 中如此输入：</p>

<p>CODE:</p>

<p>$ awk {print $0} 1.txt</p>

<hr />

<p>由于 {} 在 shell 中并没关闭，那 shell 就将 {print $0} 视为 command block ，<br />
但同时又没有&rdquo; ; &ldquo;符号作命令区隔，因此就出现 awk 的语法错误结果。<br />
要解决之，可用 hard quote ：</p>

<p>CODE:</p>

<p>$ awk &lsquo;{print $0}&rsquo; 1.txt</p>

<hr />

<p>上面的 hardquote 应好理解，就是将原本的 {、、$(注三)、} 这几个 shell meta 关闭，避免掉在 shell 中遭到处理，而完整的成为
awk 参数中的 command meta 。<br />
( 注三：而其中的 $0 是 awk 内建的 field number ，而非 awk 的变量，awk 自身的变量无需使用 $ 。)<br />
要是理解了 hard quote 的功能，再来理解 softquote 与 escape 就不难：</p>

<p>CODE:</p>

<p>awk &ldquo;{print \$0}&rdquo; 1.txt<br />
awk \{print\ \$0\} 1.txt</p>

<hr />

<p>然而，若你要改变 awk 的 $0 的 0 值是从另一个 shell变量读进呢？<br />
比方说：已有变量 $A 的值是 0 ，那如何在 command line 中解决 awk 的 $$A 呢？<br />
你可以很直接否定掉 hard quoe 的方案：</p>

<p>CODE:</p>

<p>$ awk &lsquo;{print $$A}&rsquo; 1.txt</p>

<hr />

<p>那是因为 $A 的 $ 在 hard quote 中是不能替换变量的。<br />
聪明的读者(如你!)，经过本章学习，我想，应该可以解释为何我们可以使用如下操作了吧：</p>

<p>CODE:</p>

<p>A=0<br />
awk &ldquo;{print \$$A}&rdquo; 1.txt<br />
awk \{print\ \$$A\} 1.txt<br />
awk &lsquo;{print $&rsquo;$A&rsquo;}&rsquo; 1.txt<br />
awk &lsquo;{print $&rsquo;&ldquo;$A&rdquo;&lsquo;}&rsquo; 1.txt # 注：&rdquo;$A&rdquo; 包在 soft quote 中</p>

<hr />

<p>或许，你能举出更多的方案呢&hellip;. ^_^<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
练习与思考：请运用本章学到的知识分析如下两串讨论：<br />
<a href="http://bbs.chinaunix.net/forum/viewtopic.php?t=207178">http://bbs.chinaunix.net/forum/viewtopic.php?t=207178</a><br />
<a href="http://bbs.chinaunix.net/forum/viewtopic.php?t=216729">http://bbs.chinaunix.net/forum/viewtopic.php?t=216729</a><br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<h1 id="6-var-value-export-前后差在哪">6 var=value？export 前后差在哪？</h1>

<p>这次让我们暂时丢开 command line ，先来了解一下 bash 变量(variable)吧&hellip;</p>

<p>所谓的 <strong>变量</strong> ，就是就是利用一个特定的&rdquo;名称&rdquo;(name)来存取一段可以变化的&rdquo;值&rdquo;(value)。</p>

<p><em>设定(set)</em><br />
在 bash 中，你可以用 &ldquo;=&rdquo; 来设定或重新定义变量的内容：<br />
name=value<br />
在设定变量的时侯，得遵守如下 <strong>规则</strong> ：<br />
* 等号左右两边不能使用区隔符号(IFS)，也应避免使用 shell 的保留字符(meta charactor)。<br />
* 变量名称不能使用 $ 符号。<br />
* 变量名称的第一个字母不能是数字(number)。<br />
* 变量名称长度不可超过 256 个字母。<br />
* 变量名称及变量值之大小写是有区别的(casesensitive)。</p>

<p>如下是一些变量设定时常见的错误：<br />
A= B ：不能有 IFS<br />
1A=B ：不能以数字开头<br />
$A=B ：名称不能有 $<br />
a=B ：这跟 a=b 是不同的<br />
如下则是可以接受的设定：<br />
A=&rdquo; B&rdquo; ：IFS 被关闭了 (请参考前面的quoting 章节)<br />
A1=B ：并非以数字开头<br />
A=$B ：$ 可用在变量值内<br />
This_Is_A_Long_Name=b ：可用 _ 连接较长的名称或值，且大小写有别。</p>

<p>*** 变量替换(substitution)***<br />
Shell 之所以强大，其中的一个因素是它可以在命令行中对变量作替换(substitution)处理。在命令行中使用者可以使用 $
符号加上变量名称(除了在用 = 号定义变量名称之外)，<br />
将变量值给替换出来，然后再重新组建命令行。<br />
比方：</p>

<p>CODE:</p>

<p>$ A=ls<br />
$ B=la<br />
$ C=/tmp<br />
$ $A -$B $C</p>

<hr />

<p>(注意：以上命令行的第一个 $ 是shell prompt ，并不在命令行之内。)<br />
必需强调的是，我们所提的变量替换，只发生在 command line 上面。(是的，让我们再回到 command line 吧﹗)仔细分析最后那行
command line ，不难发现在被执行之前(在输入 CR 字符之前)，$
符号会对每一个变量作替换处理(将变量值替换出来再重组命令行)，最后会得出如下命令行：</p>

<p>CODE:</p>

<p>ls -la /tmp</p>

<hr />

<p>还记得第二章我请大家&rdquo;务必理解&rdquo;的那两句吗？若你忘了，那我这里再重贴一遍：</p>

<p>QUOTE:</p>

<p>若从技术细节来看，shell 会依据 IFS(Internal Field Seperator) 将 commandline
所输入的文字给拆解为&rdquo;字段&rdquo;(word)。然后再针对特殊字符(meta)先作处理，最后再重组整行 command line 。</p>

<p>这里的 $ 就是command line 中最经典的 meta 之一了，就是作变量替换的﹗<br />
在日常的 shell 操作中，我们常会使用 echo 命令来查看特定变量的值，例如：</p>

<p>CODE:</p>

<p>$ echo $A -$B $C</p>

<hr />

<p>我们已学过， echo 命令只单纯将其 argument 送至&rdquo;标准输出&rdquo;(STDOUT，通常是我们的荧幕)。 所以上面的命令会在荧幕上得到如下结果：</p>

<p>CODE:</p>

<p>ls -la /tmp</p>

<hr />

<p>这是由于 echo 命令在执行时，会先将 $A(ls)、$B(la)、跟 $C(/tmp)给替换出来的结果。<br />
利用 shell 对变量的替换处理能力，我们在设定变量时就更为灵活了：<br />
A=B<br />
B=$A<br />
这样，B 的变量值就可继承 A 变量&rdquo;当时&rdquo;的变量值了。<br />
不过，不要以&rdquo;数学罗辑&rdquo;来套用变量的设定，比方说：<br />
A=B<br />
B=C<br />
这样并不会让 A 的变量值变成 C 。再如：<br />
A=B<br />
B=$A<br />
A=C<br />
同样也不会让 B 的值换成 C 。</p>

<p>上面是单纯定义了两个不同名称的变量：A 与 B ，它们的值分别是 B 与 C 。<br />
若变量被重复定义的话，则原有旧值将被新值所取代。(这不正是&rdquo;可变的量&rdquo;吗？ ^_^)<br />
当我们在设定变量的时侯，请记着这点：<br />
* <strong>用一个名称储存一个数值</strong><br />
仅此而已。</p>

<p>此外，我们也可利用命令行的变量替换能力来&rdquo;扩充&rdquo;(append)变量值：<br />
A=B:C:D<br />
A=$A:E<br />
这样，第一行我们设定 A 的值为&rdquo;B:C:D&rdquo;，然后，第二行再将值扩充为 &ldquo;B:C:D:E&rdquo; 。<br />
上面的扩充范例，我们使用区隔符号( : )来达到扩充目的，<br />
要是没有区隔符号的话，如下是有问题的：<br />
A=BCD<br />
A=$AE<br />
因为第二次是将 A 的值继承 $AE 的提换结果，而非 $A 再加 E ﹗<br />
要解决此问题，我们可用更严谨的替换处理：<br />
A=BCD<br />
A=${A}E<br />
上例中，我们使用 {} 将变量名称的范围给明确定义出来，<br />
如此一来，我们就可以将 A 的变量值从 BCD 给扩充为 BCDE 。</p>

<p>(提示：关于 ${name} 事实上还可做到更多的变量处理能力，这些均属于比较进阶的变量处理，现阶段暂时不介绍了，请大家自行参考数据。如 CU 的贴子：<br />
<a href="http://www.chinaunix.net/forum/viewtopic.php?t=201843">http://www.chinaunix.net/forum/viewtopic.php?t=201843</a><br />
)</p>

<p>*** export ***</p>

<p>严格来说，我们在当前 shell 中所定义的变量，均属于&rdquo;本地变量&rdquo;(local variable)，<br />
只有经过 export 命令的&rdquo;输出&rdquo;处理，才能成为环境变量(environment variable)：</p>

<p>CODE:</p>

<p>$ A=B<br />
$ export A</p>

<hr />

<p>或：</p>

<p>CODE:</p>

<p>$ export A=B</p>

<hr />

<p>经过 export 输出处理之后，变量 A 就能成为一个环境变量供其后的命令使用。<br />
在使用 export 的时侯，请别忘记shell 在命令行对变量的&rdquo;替换&rdquo;(substitution)处理，<br />
比方说：</p>

<p>CODE:</p>

<p>$ A=B<br />
$ B=C<br />
$ export $A</p>

<hr />

<p>上面的命令并未将 A 输出为环境变量，而是将 B 作输出，这是因为在这个命令行中，$A 会首先被提换出 B 然后再&rdquo;塞回&rdquo;作 export 的参数。</p>

<p>要理解这个 export ，事实上需要从 process 的角度来理解才能透彻。<br />
我将于下一章为大家说明 process 的观念，敬请留意。</p>

<p>*** 取消变量*<br />
**<br />
要取消一个变量，在 bash 中可使用 unset 命令来处理：</p>

<p>CODE:</p>

<p>unset A</p>

<hr />

<p>与 export 一样，unset 命令行也同样会作变量替换(这其实就是 shell 的功能之一)，<br />
因此：</p>

<p>CODE:</p>

<p>$ A=B<br />
$ B=C<br />
$ unset $A</p>

<hr />

<p>事实上所取消的变量是 B 而不是 A 。</p>

<p>此外，变量一旦经过 unset 取消之后，其结果是将整个变量拿掉，而不仅是取消其变量值。<br />
如下两行其实是很不一样的：</p>

<p>CODE:</p>

<p>$ A=<br />
$ unset A</p>

<hr />

<p>第一行只是将变量 A 设定为&rdquo;空值&rdquo;(null value)，但第二行则让变量 A 不在存在。<br />
虽然用眼睛来看，这两种变量状态在如下命令结果中都是一样的：</p>

<p>CODE:</p>

<p>$ A=<br />
$ echo $A</p>

<p>$ unset A<br />
$ echo $A</p>

<hr />

<p>请学员务必能识别 null value 与 unset 的本质区别，这在一些进阶的变量处理上是很严格的。<br />
比方说：</p>

<p>CODE:</p>

<p>$ str= # 设为 null<br />
$ var=${str=expr} # 定义 var<br />
$ echo $var</p>

<p>$ echo $str</p>

<p>$ unset str # 取消<br />
$ var=${str=expr} # 定义 var<br />
$ echo $var<br />
expr<br />
$ echo $str<br />
expr</p>

<hr />

<p>聪明的读者(yes, you!)，稍加思考的话，<br />
应该不难发现为何同样的 var=${str=expr} 在null 与 unset 之下的不同吧？<br />
若你看不出来，那可能是如下原因之一：<br />
a. 你太笨了<br />
b. 不了解 var=${str=expr} 这个进阶处理<br />
c. 对本篇说明还没来得及消化吸收<br />
e. 我讲得不好<br />
不知，你选哪个呢？&hellip;. ^_^</p>

<p>嗯&hellip; 好吧，我就解释一下var=${str=expr} ：</p>

<p>首先，var=$str 这个大家都可理解吧。<br />
而接下来的思考方向是，究竟 $str 这个变量是如下哪一种情况呢：<br />
1) unset<br />
2) null<br />
3) not null</p>

<p>1) 假如是 unset ，那么var=${str=expr} 的结果将是：<br />
var=expr<br />
str=expr</p>

<p>2) 假如是 null ，那 var=${str=expr} 的结果是：<br />
var=<br />
str=</p>

<p>3) 假如是 not null (比方为 xyz )，那 var=${str=expr} 之结果是：<br />
var=xyz<br />
str=xyz</p>

<p>接下来，再来看看 var=${str:=expr} 好了：<br />
1) $str 为 not set ：<br />
var=expr<br />
str=expr</p>

<p>2) $str 为 null ：<br />
var=expr<br />
str=expr</p>

<p>3) $str 为 not null (str=xyz)：<br />
var=xyz<br />
str=xyz</p>

<p>最后比教一下 ${str=expr} 与${str:=expr} ：<br />
* 两者在 not set 与 not null 都一至<br />
* 但当 null 值时，前者会将 $var 与 $str 都设为 null ，但后者则设为 expr</p>

<p>从这个再延伸出其它模拟，不防请大家&rdquo;实作&rdquo;观查一下有何不同？<br />
var=${str-expr} vs var=${str:-expr}<br />
var=${str+expr} vs var=${str:+expr}<br />
var=${str?expr} vs var=${str:?expr}</p>

<p>hey you: 别偷懒﹗快做做看&hellip; hurry up!</p>

<h1 id="7-exec跟-source-差在哪">7 exec跟 source 差在哪？</h1>

<p>这次先让我们从 CUShell 版的一个实例贴子来谈起吧：<br />
( <a href="http://www.chinaunix.net/forum/viewtopic.php?t=194191">http://www.chinaunix.net/forum/viewtopic.php?t=194191</a> )</p>

<p>例中的提问是：</p>

<p>QUOTE:</p>

<p>cd /etc/aa/bb/cc可以执行<br />
但是把这条命令写入shell时shell不执行！<br />
这是什么原因呀！</p>

<p>我当时如何回答暂时别去深究，先让我们了解一下行程(process)的观念好了。<br />
首先，我们所执行的任何程序，都是由父行程(parent process)所产生出来的一个子行程(child
process)，子行程在结束后，将返回到父行程去。此一现像在 Linux系统中被称为 fork 。<br />
(为何要程为 fork 呢？嗯，画一下图或许比较好理解&hellip; ^_^)<br />
当子行程被产生的时候，将会从父行程那里获得一定的资源分配、及(更重要的是)继承父行程的环境﹗<br />
让我们回到上一章所谈到的&rdquo;环境变量&rdquo;吧：<br />
* 所谓环境变量其实就是那些会传给子行程的变量。<br />
简单而言，&rdquo;遗传性&rdquo;就是区分本地变量与环境变量的决定性指标。<br />
然而，从遗传的角度来看，我们也不难发现环境变量的另一个重要特征：<br />
* 环境变量只能从父行程到子行程单向继承。换句话说：在子行程中的环境如何变更，均不会影响父行程的环境。</p>

<p>接下来，再让我们了解一下命令脚本(shell script)的概念。<br />
所谓的 shell script 讲起来很简单，就是将你平时在 shell prompt 后所输入的多行 command line 依序写入一个文件去而已。<br />
其中再加上一些条件判断、互动界面、参数运用、函数调用、等等技巧，得以让 script 更加&rdquo;聪明&rdquo;的执行，<br />
但若撇开这些技巧不谈，我们真的可以简单的看成 script 只不过依次执行预先写好的命令行而已。</p>

<p>再结合以上两个概念(process + script)，那应该就不难理解如下这句话的意思了：<br />
* 正常来说，当我们执行一个 shell script时，其实是先产生一个 sub-shell 的子行程，然后 sub-shell 再去产生命令行的子行程。 **<br />
**然则，那让我们回到本章开始时所提到的例子再从新思考：</p>

<p>QUOTE:</p>

<p>cd /etc/aa/bb/cc可以执行<br />
但是把这条命令写入shell时shell不执行！<br />
这是什么原因呀！</p>

<p>我当时的答案是这样的：</p>

<p>QUOTE:因为，一般我们跑的 shell script 是用 subshell 去执行的。<br />
从 process 的观念来看，是 parentprocess 产生一个 child process 去执行，<br />
当 child 结束后，会返回 parent ，但 parent 的环境是不会因 child 的改变而改变的。<br />
所谓的环境元数很多，凡举 effective id, variable, workding dir 等等&hellip;<br />
其中的 workding dir ($PWD) 正是楼主的疑问所在：<br />
当用 subshell 来跑 script 的话，sub shell 的 $PWD 会因为cd 而变更，<br />
但当返回 primary shell 时，$PWD 是不会变更的。</p>

<p>能够了解问题的原因及其原理是很好的，但是？如何解决问题恐怕是我们更感兴趣的﹗是吧？^_^<br />
那好，接下来，再让我们了解一下 source 命令好了。<br />
当你有了 fork 的概念之后，要理解 source 就不难：<br />
 *** 所谓 source就是让 script 在当前 shell 内执行、而不是产生一个 sub-shell 来执行。**<br />
由于所有执行结果均于当前 shell 内完成，若 script的环境有所改变，当然也会改变当前环境了﹗<br />
因此，只要我们要将原本单独输入的 script 命令行变成source 命令的参数，就可轻易解决前例提到的问题了。<br />
比方说，原本我们是如此执行 script 的：</p>

<p>CODE:</p>

<p>./my.script</p>

<hr />

<p>现在改成这样即可：</p>

<p>CODE:</p>

<p>source ./my.script<br />
或：<br />
. ./my.script</p>

<hr />

<p>说到这里，我想，各位有兴趣看看 /etc 底下的众多设定文件，<br />
应该不难理解它们被定议后，如何让其它 script 读取并继承了吧？<br />
若然，日后你有机会写自己的 script ，应也不难专门指定一个设定文件以供不同的 script 一起&rdquo;共享&rdquo;了&hellip; ^_^</p>

<p>okay，到这里，若你搞得懂 fork 与 source 的不同，那接下来再接受一个挑战：<br />
-&mdash; 那 exec 又与 source/fork 有何不同呢？<br />
哦&hellip; 要了解 exec 或许较为复杂，尤其扯上 File Descriptor 的话&hellip;<br />
不过，简单来说：<br />
*exec 也是让 script在同一个行程上执行，但是原有行程则被结束了。<br />
也就是简而言之：原有行程会否终止，就是 exec 与 source/fork 的最大差异了。</p>

<p>嗯，光是从理论去理解，或许没那么好消化，不如动手&rdquo;实作+思考&rdquo;来的印像深刻哦。<br />
下面让我们写两个简单的 script ，分别命令为 1.sh 及 2.sh ：</p>

<p>1.sh</p>

<p>CODE:<br />
#!/bin/bash<br />
A=B<br />
echo &ldquo;PID for 1.sh before exec/source/fork:$$&rdquo;<br />
export A<br />
echo &ldquo;1.sh: \$A is $A&rdquo;<br />
case $1 in<br />
exec)<br />
echo &ldquo;using exec&hellip;&rdquo;<br />
exec ./2.sh ;;<br />
source)<br />
echo &ldquo;using source&hellip;&rdquo;<br />
. ./2.sh ;;<br />
*)<br />
echo &ldquo;using fork by default&hellip;&rdquo;<br />
./2.sh ;;<br />
esac<br />
echo &ldquo;PID for 1.sh after exec/source/fork:$$&rdquo;<br />
echo &ldquo;1.sh: \$A is $A&rdquo;</p>

<hr />

<p>2.sh</p>

<p>CODE:</p>

<p>#!/bin/bash<br />
echo &ldquo;PID for 2.sh: $$&rdquo;<br />
echo &ldquo;2.sh get \$A=$A from 1.sh&rdquo;<br />
A=C<br />
export A<br />
echo &ldquo;2.sh: \$A is $A&rdquo;</p>

<hr />

<p>然后，分别跑如下参数来观察结果：</p>

<p>CODE:</p>

<p>$ ./1.sh fork<br />
$ ./1.sh source<br />
$ ./1.sh exec</p>

<hr />

<p>或是，你也可以参考 CU 上的另一贴子：<br />
<a href="http://www.chinaunix.net/forum/viewtopic.php?t=191051">http://www.chinaunix.net/forum/viewtopic.php?t=191051</a></p>

<p>好了，别忘了仔细比较输出结果的不同及背后的原因哦&hellip;<br />
若有疑问，欢迎提出来一起讨论讨论~~~<br />
happy scripting! ^_^</p>

<h1 id="8-与-差在哪">8 () 与 { } 差在哪？</h1>

<p>嗯，这次轻松一下，不讲太多&hellip; ^_^</p>

<p>先说一下，为何要用 ( ) 或 { } 好了。<br />
许多时候，我们在 shell
操作上，需要在一定条件下一次执行多个命令，也就是说，要么不执行，要么就全执行，而不是每次依序的判断是否要执行下一个命令。或是，需要从一些命令执行优先次顺中得到豁免，如算术的
2*(3+4) 那样&hellip;这时候，我们就可引入&rdquo;命令群组&rdquo;(command group)的概念：将多个命令集中处理。</p>

<p>在 shell command line 中，一般人或许不太计较 ( ) 与 { }
这两对符号的差异，虽然两者都可将多个命令作群组化处理，但若从技术细节上，却是很不一样的：<br />
 <strong>( )</strong> 将 command group置于 sub-shell 去执行，也称 nested sub-shell。<br />
 <strong>{ }</strong> 则是在同一个 shell 内完成，也称为 non-named command group。<br />
若，你对上一章的 fork 与 source 的概念还记得了的话，那就不难理解两者的差异了。<br />
要是在 command group 中扯上变量及其它环境的修改，我们可以根据不同的需求来使用 ( ) 或 { } 。<br />
通常而言，若所作的修改是临时的，且不想影响原有或以后的设定，那我们就 nested sub-shell ，<br />
反之，则用 non-named command group 。</p>

<p>是的，光从 command line 来看，( ) 与 { } 的差别就讲完了，够轻松吧~~~ ^<em>^<br />
然而，若这两个 meta 用在其它 command meta 或领域中(如 Regular Expression)，还是有很多差别的。<br />
只是，我不打算再去说明了，留给读者自己慢慢发掘好了&hellip;<br />
我这里只想补充一个概念，就是 function 。<br />
所谓的 **function **，就是用一个名字去命名一个 command group ，然后再调用这个名字去执行 command group 。<br />
从 non-named command group 来推断，大概你也可以猜到我要说的是 <strong>{ }</strong> 了吧？(yes! 你真聪明﹗ ^</em>^)</p>

<p>在 bash 中，function 的定义方式有两种：<br />
方式一：</p>

<p>CODE:</p>

<p>function function_name {<br />
command1<br />
command2<br />
command3<br />
&hellip;.<br />
}</p>

<hr />

<p>方式二：</p>

<p>CODE:</p>

<p>fuction_name () {<br />
command1<br />
command2<br />
command3<br />
&hellip;.<br />
}</p>

<hr />

<p>用哪一种方式无所谓，只是若碰到所定意的名称与现有的命令或别名(Alias)冲突的话，方式二或许会失败。但方式二起码可以少打 function
这一串英文字母，对懒人来说(如我)，又何乐不为呢？&hellip; ^_^</p>

<p>function
在某一程度来说，也可称为&rdquo;函式&rdquo;，但请不要与传统编程所使用的函式(library)搞混了，毕竟两者差异很大。惟一相同的是，我们都可以随时用&rdquo;已定义的名称&rdquo;来调用它们&hellip;<br />
若我们在 shell 操作中，需要不断的重复质行某些命令，我们首先想到的，或许是将命令写成命令稿(shell script)。<br />
不过，我们也可以写成function ，然后在 command line 中打上function_name 就可当一舨的 script 来使用了。<br />
只是若你在 shell 中定义的 function ，除了可用 unset function_name 取消外，一旦退出 shell ，function
也跟着取消。<br />
然而，在 script 中使用 function 却有许多好处，除了可以提高整体 script 的执行效能外(因为已被加载)，<br />
还可以节省许多重复的代码&hellip;</p>

<p>简单而言，若你会将多个命令写成 script 以供调用的话，那，你可以将 function 看成是 **script 中的 script **&hellip; ^<em>^<br />
而且，透过上一章介绍的 source 命令，我们可以自行定义许许多多好用的 function ，再集中写在特定文件中，然后，在其它的 script 中用
source 将它们加载并反复执行。<br />
若你是 RedHat Linux 的使用者，或许，已经猜得出/etc/rc.d/init.d/functions 这个文件是作啥用的了~~~ ^</em>^<br />
okay，说要轻松点的嘛，那这次就暂时写到这吧。祝大家学习愉快﹗ ^_^</p>

<h1 id="9-与-还有-差在哪">9 $(()) 与 $( ) 还有${ } 差在哪？</h1>

<p>我们上一章介绍了 ( ) 与 { } 的不同，这次让我们扩展一下，看看更多的变化：$( ) 与${ } 又是啥玩意儿呢？</p>

<p>在 bash shell 中，$( ) 与  (反引号)都是用来做命令替换用(commandsubstitution)的。<br />
所谓的命令替换与我们第五章学过的变量替换差不多，都是用来重组命令行：<br />
* 完成引号里的命令行，然后将其结果替换出来，再重组命令行。<br />
例如：<br />
[code]$ echo the last sunday is $(date -d &ldquo;last sunday&rdquo;+%Y-%m-%d)[/code]<br />
如此便可方便得到上一星期天的日期了&hellip; ^_^</p>

<p>在操作上，用 $( ) 或  都无所谓，只是我&rdquo;个人&rdquo;比较喜欢用 $( ) ，理由是：</p>

<p>1, `` 很容易与 &lsquo; &rsquo; (单引号)搞混乱，尤其对初学者来说。<br />
有时在一些奇怪的字形显示中，两种符号是一模一样的(直竖两点)。<br />
当然了，有经验的朋友还是一眼就能分辩两者。只是，若能更好的避免混乱，又何乐不为呢？ ^_^</p>

<p>2, 在多层次的复合替换中，须要额外的跳脱( \<code>)处理，而 $( )则比较直观。例如：  
这是错的：  
[code]command1</code>command2 <code>command3</code> <code>[/code]  
原本的意图是要在 command2</code>command3<code>先将 command3 提换出来给command 2 处理，  
然后再将结果传给 command1</code>command2 &hellip;<code>来处理。  
然而，真正的结果在命令行中却是分成了</code>command2 <code>与</code><code>两段。  
正确的输入应该如下：  
[code]command1</code>command2 \<code>command3\\</code> `[/code]</p>

<p>要不然，换成 $( ) 就没问题了：<br />
[code]command1 $(command2 $(command3))[/code]<br />
只要你喜欢，做多少层的替换都没问题啦~~~ ^_^</p>

<p>不过，$( ) 并不是没有毙端的&hellip;<br />
首先， 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。<br />
而 $( ) 并不见的每一种 shell 都能使用，我只能跟你说，若你用 bash2 的话，肯定没问题&hellip; ^_^</p>

<p>接下来，再让我们看 <strong>${ }</strong> 吧&hellip;它其实就是用来作 <strong>变量替换</strong> 用的啦。<br />
一般情况下，$var 与 ${var} 并没有啥不一样。<br />
但是用 ${ } 会比较精确的界定变量名称的范围，比方说：<br />
[code]$ A=B<br />
$ echo $AB</p>

<p>[/code]<br />
原本是打算先将 $A 的结果替换出来，然后再补一个 B 字母于其后，<br />
但在命令行上，真正的结果却是只会提换变量名称为 AB 的值出来&hellip;<br />
若使用 ${ } 就没问题了：<br />
[code]$ echo ${A}B<br />
BB[/code]</p>

<p>不过，假如你只看到 ${ } 只能用来界定变量名称的话，那你就实在太小看 bash 了﹗<br />
有兴趣的话，你可先参考一下 cu 本版的精华文章：<br />
<a href="http://www.chinaunix.net/forum/viewtopic.php?t=201843">http://www.chinaunix.net/forum/viewtopic.php?t=201843</a></p>

<p>为了完整起见，我这里再用一些例子加以说明 ${ } 的一些特异功能：<br />
假设我们定义了一个变量为：<br />
file=/dir1/dir2/dir3/my.file.txt<br />
我们可以用 ${ } 分别替换获得不同的值：<br />
 <strong>${file#*/} ：</strong>拿掉第一条 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt<br />
 <strong>${file##*/} ：</strong>拿掉最后一条 / 及其左边的字符串：my.file.txt<br />
 <strong>${file#*.} ：</strong>拿掉第一个 . 及其左边的字符串：file.txt<br />
 <strong>${file##*.} ：</strong>拿掉最后一个 . 及其左边的字符串：txt<br />
 <strong>${file%/*} ：</strong>拿掉最后条 / 及其右边的字符串：/dir1/dir2/dir3<br />
 <strong>${file%%/*} ：</strong>拿掉第一条 / 及其右边的字符串：(空值)<br />
 <strong>${file%.*} ：</strong>拿掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file<br />
 <strong>${file%%.*} ：</strong>拿掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my<br />
记忆的方法为：<br />
[list]# 是去掉左边(在鉴盘上# 在 $ 之左边)<br />
% 是去掉右边(在鉴盘上% 在 $ 之右边)<br />
单一符号是最小匹配﹔两个符号是最大匹配。[/list]<br />
 <strong>${file:0:5} ：</strong>提取最左边的 5 个字节：/dir1<br />
 <strong>${file:5:5} ：</strong>提取第 5 个字节右边的连续 5 个字节：/dir2</p>

<p>我们也可以对变量值里的字符串作替换：<br />
 <strong>${file/dir/path} ：</strong>将第一个 dir 提换为 path：/path1/dir2/dir3/my.file.txt<br />
 <strong>${file//dir/path} ：</strong>将全部 dir 提换为 path：/path1/path2/path3/my.file.txt</p>

<p>利用 ${ } 还可针对不同的变量状态赋值(没设定、空值、非空值)：<br />
<strong>${file-my.file.txt} ：</strong>假如 $file 没有设定，则使用 my.file.txt 作传回值。(空值及非空值时不作处理)<br />
 <strong>${file:-my.file.txt} ：</strong>假如 $file 没有设定或为空值，则使用 my.file.txt 作传回值。(非空值时不作处理)<br />
 <strong>${file+my.file.txt} ：</strong>假如 $file 设为空值或非空值，均使用 my.file.txt 作传回值。(没设定时不作处理)<br />
 <strong>${file:+my.file.txt} ：</strong>若 $file 为非空值，则使用 my.file.txt 作传回值。(没设定及空值时不作处理)<br />
 <strong>${file=my.file.txt} ：</strong>若 $file 没设定，则使用 my.file.txt 作传回值，同时将 $file 赋值为
my.file.txt 。 (空值及非空值时不作处理)<br />
 <strong>${file:=my.file.txt} ：</strong>若 $file 没设定或为空值，则使用 my.file.txt 作传回值，同时将 $file 赋值为
my.file.txt 。 (非空值时不作处理)<br />
 <strong>${file?my.file.txt} ：</strong>若 $file 没设定，则将 my.file.txt 输出至STDERR。 (空值及非空值时不作处理)<br />
 <strong>${file:?my.file.txt} ：</strong>若 $file 没设定或为空值，则将 my.file.txt 输出至STDERR。
(非空值时不作处理)</p>

<p>tips:<br />
以上的理解在于, 你一定要分清楚 unset 与 null 及 non-null 这三种赋值状态.<br />
一般而言, : 与null 有关, 若不带: 的话, null 不受影响, 若带: 则连 null 也受影响.<br />
还有哦，${#var} 可计算出变量值的长度：<br />
 <strong>${#file}</strong> 可得到 27 ，因为/dir1/dir2/dir3/my.file.txt 刚好是27 个字节&hellip;</p>

<p>接下来，再为大家介稍一下 bash 的组数(array)处理方法。<br />
一般而言，A=&ldquo;a b c def&rdquo; 这样的变量只是将 $A 替换为一个单一的字符串，<br />
但是改为 A=(a b c def) ，则是将 $A 定义为组数&hellip;<br />
bash 的组数替换方法可参考如下方法：<br />
 <strong>${A[@]}</strong> 或 ${A[*]} 可得到a b c def (全部组数)<br />
 <strong>${A[0]}</strong> 可得到 a (第一个组数)，${A[1]} 则为第二个组数&hellip;<br />
 <strong>${#A[@]}</strong> 或 ${#A[*]} 可得到4 (全部组数数量)<br />
 <strong>${#A[0]}</strong> 可得到 1 (即第一个组数(a)的长度)，${#A[3]}可得到 3 (第四个组数(def)的长度)<br />
A[3]=xyz 则是将第四个组数重新定义为 xyz &hellip;</p>

<p>诸如此类的&hellip;.<br />
能够善用 bash 的 $( ) 与${ } 可大大提高及简化 shell 在变量上的处理能力哦~~~ ^_^</p>

<p>好了，最后为大家介绍 <strong>$(( ))</strong> 的用途吧：它是用来作 <strong>整数运算</strong> 的。<br />
在 bash 中，$(( )) 的整数运算符号大致有这些：<br />
+ - * / ：分别为 &ldquo;加、减、乘、除&rdquo;。<br />
% ：余数运算<br />
&amp; | ^ !：分别为 &ldquo;AND、OR、XOR、NOT&rdquo; 运算。</p>

<p>例：<br />
[code]$ a=5; b=7; c=2<br />
$ echo $(( a+b*c ))<br />
19<br />
$ echo $(( (a+b)/c ))<br />
6<br />
$ echo $(( (a*b)%c))<br />
1[/code]</p>

<p>在 $(( )) 中的变量名称，可于其前面加 $ 符号来替换，也可以不用，如：<br />
$(( $a + $b * $c)) 也可得到 19 的结果</p>

<p>此外，$(( )) 还可作不同进位(如二进制、八进位、十六进制)作运算呢，只是，输出结果皆为十进制而已：<br />
echo $((16#2a)) 结果为 42 (16进位转十进制)<br />
以一个实用的例子来看看吧：<br />
假如当前的 umask 是 022 ，那么新建文件的权限即为：<br />
[code]$ umask 022<br />
$ echo &ldquo;obase=8;$(( 8#666 &amp; (8#777 ^ 8#$(umask)) ))&rdquo; | bc<br />
644[/code]</p>

<p>事实上，单纯用 (( )) 也可重定义变量值，或作 testing：<br />
a=5; ((a++)) 可将 $a 重定义为6<br />
a=5; ((a&ndash;)) 则为a=4<br />
a=5; b=7; ((a &lt; b)) 会得到 0(true) 的返回值。<br />
常见的用于 (( )) 的测试符号有如下这些：<br />
[list] &gt;：大于<br />
&lt;=：小于或等于<br />
&gt;=：大于或等于<br />
==：等于<br />
!=：不等于[/list]<br />
不过，使用 (( )) 作整数测试时，请不要跟 [ ] 的整数测试搞混乱了。(更多的测试我将于第十章为大家介绍)</p>

<p>怎样？好玩吧.. ^_^ okay，这次暂时说这么多&hellip;<br />
上面的介绍，并没有详列每一种可用的状态，更多的，就请读者参考手册文件啰&hellip;</p>

<h1 id="10-与-差在哪">10 $@与 $* 差在哪？</h1>

<p>要说 $@ 与 $* 之前，需得先从 shell script 的 positional parameter 谈起&hellip;<br />
我们都已经知道变量(variable)是如何定义及替换的，这个不用再多讲了。<br />
但是，我们还需要知道有些变量是 shell 内定的，且其名称是我们不能随意修改的，<br />
其中就有 positional parameter 在内。</p>

<p>在 shell script 中，我们可用 $0, $1,$2, $3 &hellip; 这样的变量分别提取命令行中的如下部份：</p>

<p>CODE:</p>

<p>script_name parameter1 parameter2 parameter3 &hellip;</p>

<hr />

<p>我们很容易就能猜出 <strong>$0</strong> 就是代表 shell script名称(路径)本身，而 <strong>$1</strong> 就是其后的第一个参数，如此类推&hellip;.<br />
须得留意的是 IFS 的作用，也就是，若 IFS 被 quoting 处理后，那么 positional parameter 也会改变。<br />
如下例：</p>

<p>CODE:</p>

<p>my.sh p1 &ldquo;p2 p3&rdquo; p4</p>

<hr />

<p>由于在 p2 与 p3 之间的空格键被 soft quote 所关闭了，因此 my.sh 中的 $2 是&rdquo;p2 p3&rdquo; 而 $3 则是 p4&hellip;</p>

<p>还记得前两章我们提到 fucntion 时，我不是说过它是script 中的 script 吗？ ^_^<br />
是的，function 一样可以读取自己的(有别于 script 的) postitional parameter ，惟一例外的是 $0 而已。<br />
举例而言：假设 my.sh 里有一个fucntion 叫 my_fun , 若在 script 中跑 my_fun fp1 fp2 fp3 ，<br />
那么，function 内的 $0 是 my.sh ，而 $1 则是 fp1 而非 p1 了&hellip;</p>

<p>不如写个简单的 my.sh script 看看吧：</p>

<p>CODE:</p>

<p>#!/bin/bash</p>

<p>my_fun() {<br />
echo &lsquo;$0 inside function is &lsquo;$0<br />
echo &lsquo;$1 inside function is &lsquo;$1<br />
echo &lsquo;$2 inside function is &lsquo;$2<br />
}</p>

<p>echo &lsquo;$0 outside function is &lsquo;$0<br />
echo &lsquo;$1 outside function is &lsquo;$1<br />
echo &lsquo;$2 outside function is &lsquo;$2</p>

<p>my_fun fp1 &ldquo;fp2 fp3&rdquo;</p>

<hr />

<p>然后在 commandline 中跑一下 script 就知道了：</p>

<p>CODE:</p>

<p>chmod +x my.sh<br />
./my.sh p1 &ldquo;p2 p3&rdquo;<br />
$0 outside function is ./my.sh<br />
$1 outside function is p1<br />
$2 outside function is p2 p3<br />
$0 inside function is ./my.sh<br />
$1 inside function is fp1<br />
$2 inside function is fp2 fp3</p>

<hr />

<p>然而，在使用positional parameter 的时候，我们要注意一些陷阱哦：<br />
*$10 不是替换第 10个参数，而是替换第一个参数($1)然后再补一个 0 于其后﹗<br />
也就是，my.sh one two three four five six seven eigth nineten 这样的 command line ，<br />
my.sh 里的 $10 不是 ten 而是 one0 哦&hellip; 小心小心﹗<br />
要抓到 ten 的话，有两种方法：<br />
方法一是使用我们上一章介绍的 ${ } ，也就是用 ${10}即可。<br />
方法二，就是 shift 了。<br />
用通俗的说法来说，所谓的 shift 就是取消positional parameter 中最左边的参数( $0 不受影响)。<br />
其默认值为 1 ，也就是 shift 或 shift 1 都是取消 $1 ，而原本的 $2 则变成 $1、$3 变成 $2 &hellip;<br />
若 shift 3 则是取消前面三个参数，也就是原本的 $4 将变成 $1 &hellip;<br />
那，亲爱的读者，你说要 shift 掉多少个参数，才可用 $1取得 ${10} 呢？ ^_^</p>

<p>okay，当我们对 positional parameter 有了基本概念之后，那再让我们看看其它相关变量吧。<br />
首先是 <strong>$#</strong> ：它可抓出 positional parameter的数量。<br />
以前面的 my.sh p1 &ldquo;p2 p3&rdquo; 为例：<br />
由于 p2 与 p3 之间的 IFS 是在 soft quote 中，因此 $# 可得到 2 的值。<br />
但如果 p2 与 p3 没有置于 quoting 中话，那 $# 就可得到 3 的值了。<br />
同样的道理在 function 中也是一样的&hellip;</p>

<p>因此，我们常在 shell script 里用如下方法测试script 是否有读进参数：</p>

<p>CODE:</p>

<p>[ $# = 0 ]</p>

<hr />

<p>假如为 0 ，那就表示 script 没有参数，否则就是有带参数&hellip;</p>

<p>接下来就是 $@ 与 $* ：<br />
精确来讲，两者只有在 soft quote 中才有差异，否则，都表示&rdquo;全部参数&rdquo;( $0 除外)。<br />
举例来说好了：<br />
若在 command line 上跑 my.sh p1&rdquo;p2 p3&rdquo; p4 的话，<br />
不管是 $@ 还是 $* ，都可得到 p1 p2 p3 p4 就是了。<br />
但是，如果置于 soft quote 中的话：<br />
 <strong>&rdquo;$@&rdquo;</strong> 则可得到 &ldquo;p1&rdquo; &ldquo;p2 p3&rdquo; &ldquo;p4&rdquo;这三个不同的词段(word)﹔<br />
 <strong>&rdquo;$*&rdquo;</strong> 则可得到 &ldquo;p1 p2 p3 p4&rdquo; 这一整串单一的词段。</p>

<p>我们可修改一下前面的 my.sh ，使之内容如下：</p>

<p>CODE:</p>

<p>#!/bin/bash</p>

<p>my_fun() {<br />
echo &ldquo;$#&rdquo;<br />
}</p>

<p>echo &lsquo;the number of parameter in &ldquo;$@&rdquo; is &lsquo;$(my_fun &ldquo;$@&rdquo;)<br />
echo &lsquo;the number of parameter in &ldquo;$<em>&rdquo; is &lsquo;$(my_fun &ldquo;$</em>&rdquo;)</p>

<hr />

<p>然后再执行 ./my.sh p1&rdquo;p2 p3&rdquo; p4 就知道 $@ 与$* 差在哪了 &hellip; ^_^</p>

<h1 id="11-与-差在哪">11 &amp;&amp;与 || 差在哪？</h1>

<p>好不容易，进入两位数的章节了&hellip; 一路走来，很辛苦吧？也很快乐吧？ ^_^</p>

<p>在解答本章题目之前，先让我们了解一个概念：return value ﹗<br />
我们在 shell 下跑的每一个 command 或 function ，在结束的时候都会传回父行程一个值，称为 return value 。<br />
在 shell command line 中可用 $? 这个变量得到最&rdquo;新&rdquo;的一个return value ，也就是刚结束的那个行程传回的值。<br />
Return Value(RV) 的取值为 0-255 之间，由程序(或 script)的作者自行定议：<br />
* 若在 script里，用 exit RV 来指定其值，若没指定，在结束时以最后一道命令之 RV 为值。<br />
* 若在 function 里，则用 return RV 来代替 exit RV 即可。</p>

<p><strong>Return Value</strong> 的作用，是用来判断行程的退出状态(exit status)，只有两种：<br />
* 0的话为&rdquo;真&rdquo;( true )<br />
* 非 0 的话为&rdquo;假&rdquo;( false )</p>

<p>举个例子来说明好了：<br />
假设当前目录内有一份 my.file 的文件，而no.file 是不存在的：</p>

<p>CODE:</p>

<p>$ touch my.file<br />
$ ls my.file<br />
$ echo $? # first echo<br />
0<br />
$ ls no.file<br />
ls: no.file: No such file or directory<br />
$ echo $? # second echo<br />
1<br />
$ echo $? # third echo<br />
0</p>

<hr />

<p>上例的第一个 echo 是关于 ls my.file 的 RV ，可得到 0 的值，因此为 true ﹔<br />
第二个 echo 是关于 ls no.file 的 RV ，则得到非 0 的值，因此为 false ﹔<br />
第三个 echo 是关于第二个 echo $? 的 RV ，为 0 的值，因此也为true 。<br />
请记住：每一个 command 在结束时都会送回 returnvalue 的﹗不管你跑甚么样的命令&hellip;<br />
然而，有一个命令却是&rdquo;专门&rdquo;用来测试某一条件而送出 return value以供 true 或 false 的判断，<br />
它就是 <strong>test</strong> 命令了﹗<br />
若你用的是 bash ，请在 commandline 下打 man test 或 man bash 来了解这个 test 的用法。<br />
这是你可用作参考的最精确的文件了，要是听别人说的，仅作参考就好&hellip;<br />
下面我只简单作一些辅助说明，其余的一律以 man 为准：</p>

<p>首先，test 的表示式我们称为expression，其命令格式有两种：</p>

<p>CODE:</p>

<p>test expression<br />
or:<br />
[ expression ]</p>

<hr />

<p><strong>( 请务必注意 [ ]之间的空格键﹗)</strong><br />
用哪一种格式没所谓，都是一样的效果。(我个人比较喜欢后者&hellip;)</p>

<p>其次，bash 的 test 目前支持的测试对像只有三种：<br />
*string：字符串，也就是纯文字。<br />
* integer：整数( 0 或正整数，不含负数或小数点)。<br />
* file：文件。<br />
请初学者一定要搞清楚这三者的差异，因为 test 所用的 expression 是不一样的。<br />
以 A=123 这个变量为例：<br />
* [ &ldquo;$A&rdquo; = 123 ]：是字符串的测试，以测试 $A 是否为 1、2、3 这三个连续的&rdquo;文字&rdquo;。<br />
* [ &ldquo;$A&rdquo; -eq 123 ]：是整数的测试，以测试 $A 是否等于&rdquo;一百二十三&rdquo;。<br />
* [ -e &ldquo;$A&rdquo; ]：是关于文件的测试，以测试 123 这份&rdquo;文件&rdquo;是否存在。</p>

<p>第三，当 expression 测试为&rdquo;真&rdquo;时，test 就送回 0(true) 的 return value ，否则送出非 0(false)。<br />
若在 expression 之前加上一个&rdquo; ! &ldquo;(感叹号)，则是当expression 为&rdquo;假时&rdquo; 才送出 0 ，否则送出非 0 。<br />
同时，test 也允许多重的覆合测试：<br />
*expression1 -a expression2 ：当两个 exrepssion都为 true ，才送出 0 ，否则送出非0 。<br />
* expression1 -o expression2 ：只需其中一个 exrepssion 为 true ，就送出 0 ，只有两者都为false 才送出非 0 。<br />
例如：</p>

<p>CODE:</p>

<p>[ -d &ldquo;$file&rdquo; -a -x &ldquo;$file&rdquo; ]</p>

<hr />

<p>是表示当 $file 是一个目录、且同时具有 x 权限时，test 才会为 true。</p>

<p>第四，在 command line 中使用 test 时，请别忘记命令行的&rdquo;重组&rdquo;特性，<br />
也就是在碰到 meta 时会先处理 meta 再重新组建命令行。(这个特性我在第二及第四章都曾反复强调过)<br />
比方说，若 test 碰到变量或命令替换时，若不能满足expression 格式时，将会得到语法错误的结果。<br />
举例来说好了：<br />
关于 [ string1 = string2 ] 这个test 格式，<br />
在 = 号两边必须要有字符串，其中包括空(null)字符串(可用 soft quote 或 hard quote 取得)。<br />
假如 $A 目前没有定义，或被定议为空字符串的话，那如下的写法将会失败：</p>

<p>CODE:</p>

<p>$ unset A<br />
$ [ $A = abc ]<br />
[: =: unary operator expected</p>

<hr />

<p>这是因为命令行碰到 $这个 meta 时，会替换 $A 的值，然后再重组命令行，那就变成了：<br />
[ = abc ]<br />
如此一来 = 号左边就没有字符串存在了，因此造成 test 的语法错误﹗<br />
但是，下面这个写法则是成立的：</p>

<p>CODE:</p>

<p>$ [ &ldquo;$A&rdquo; = abc ]<br />
$ echo $?<br />
1</p>

<hr />

<p>这是因为在命令行重组后的结果为：<br />
[ &ldquo;&rdquo; = abc ]<br />
由于 = 左边我们用 soft quote 得到一个空字符串，而让 test 语法得以通过&hellip;</p>

<p>读者诸君请务必留意这些细节哦，因为稍一不慎，将会导至 test 的结果变了个样﹗<br />
若您对 test 还不是很有经验的话，那在使用 test 时不妨先采用如下这一个&rdquo;法则&rdquo;：<br />
* 假如在 test中碰到变量替换，用 soft quote 是最保险的﹗<br />
若你对 quoting 不熟的话，请重新温习第四章的内容吧&hellip; ^_^</p>

<p>okay，关于更多的 test 用法，老话一句：请看 manpage 吧﹗ ^_^</p>

<p>虽然洋洋洒洒讲了一大堆，或许你还在嘀咕&hellip;. 那&hellip; 那个 return value 有啥用啊？﹗<br />
问得好﹗<br />
告诉你：return value 的作用可大了﹗若你想让你的shell 变&rdquo;聪明&rdquo;的话，就全靠它了：<br />
* 有了 return value，我们可以让 shell 跟据不同的状态做不同的时情&hellip;</p>

<p>这时候，才让我来揭晓本章的答案吧~~~ ^_^<br />
&amp;&amp;与 ||  都是用来&rdquo;组建&rdquo;多个 command line 用的：<br />
* command1 &amp;&amp; command2 ：其意思是 command2 只有在 RV 为 0(true) 的条件下执行。<br />
* command1 || command2 ：其意思是 command2 只有在 RV 为非0 (false) 的条件下执行。<br />
来，以例子来说好了：</p>

<p>CODE:</p>

<p>$ A=123<br />
$ [ -n &ldquo;$A&rdquo; ] &amp;&amp; echo &ldquo;yes! it&rsquo;s ture.&rdquo;<br />
yes! it&rsquo;s ture.<br />
$ unset A<br />
$ [ -n &ldquo;$A&rdquo; ] &amp;&amp; echo &ldquo;yes! it&rsquo;s ture.&rdquo;<br />
$ [ -n &ldquo;$A&rdquo; ] || echo &ldquo;no, it&rsquo;s NOT ture.&rdquo;<br />
no, it&rsquo;s NOT ture.</p>

<hr />

<p>(注：[ -n string ] 是测试 string 长度大于 0 则为true 。)<br />
上例的第一个 &amp;&amp; 命令行之所以会执行其右边的echo 命令，是因为上一个 test 送回了 0 的 RV 值﹔但第二次就不会执行，因为为 test 送回非
0 的结果&hellip;同理，|| 右边的 echo 会被执行，却正是因为左边的 test 送回非 0 所引起的。</p>

<p>事实上，我们在同一命令行中，可用多个 &amp;&amp; 或|| 来组建呢：</p>

<p>CODE:</p>

<p>$ A=123<br />
$ [ -n &ldquo;$A&rdquo; ] &amp;&amp; echo &ldquo;yes! it&rsquo;s ture.&rdquo; || echo &ldquo;no, it&rsquo;s NOT ture.&rdquo;<br />
yes! it&rsquo;s ture.<br />
$ unset A<br />
$ [ -n &ldquo;$A&rdquo; ] &amp;&amp; echo &ldquo;yes! it&rsquo;s ture.&rdquo; || echo &ldquo;no, it&rsquo;s NOT ture.&rdquo;<br />
no, it&rsquo;s NOT ture.</p>

<hr />

<p>怎样，从这一刻开始，你是否觉得我们的 shell 是&rdquo;很聪明&rdquo;的呢？ ^_^</p>

<p>好了，最后，布置一道习题给大家做做看<br />
下面的判断是：当 $A 被赋与值时，再看是否小于 100 ，否则送出 too big! ：</p>

<p>CODE:</p>

<p>$ A=123<br />
$ [ -n &ldquo;$A&rdquo; ] &amp;&amp; [ &ldquo;$A&rdquo; -lt 100 ] || echo &lsquo;too big!&rsquo;<br />
too big!</p>

<hr />

<p>若我将 A 取消，照理说，应该不会送文字才对啊(因为第一个条件就不成立了)&hellip;</p>

<p>CODE:</p>

<p>$ unset A<br />
$ [ -n &ldquo;$A&rdquo; ] &amp;&amp; [ &ldquo;$A&rdquo; -lt 100 ] || echo &lsquo;too big!&rsquo;<br />
too big!</p>

<hr />

<p>为何上面的结果也可得到呢？<br />
又，如何解决之呢？<br />
(提示：修改方法很多，其中一种方法可利用第七章介绍过的 command group&hellip;)</p>

<h1 id="12-与-差在哪">12 &gt;与 &lt; 差在哪？</h1>

<h2 id="12-1">12.1</h2>

<p>这次的题目之前我在 CU 的shell 版已说明过了：<br />
<a href="http://bbs.chinaunix.net/forum/24/20031030/191375.html">http://bbs.chinaunix.net/forum/24/20031030/191375.html</a><br />
这次我就不重写了，将贴子的内容&rdquo;抄&rdquo;下来就是了&hellip;</p>

<p>谈到 I/O redirection ，不妨先让我们认识一下 File Descriptor (FD) 。</p>

<p>程序的运算，在大部份情况下都是进行数据(data)的处理，<br />
这些数据从哪读进？又，送出到哪里呢？<br />
这就是 file descriptor (FD) 的功用了。</p>

<p>在 shell 程序中，最常使用的  FD 大概有三个，分别为：<br />
0: Standard Input (STDIN)<br />
1: Standard Output (STDOUT)<br />
2: Standard Error Output (STDERR)</p>

<p>在标准情况下，这些 FD 分别跟如下设备(device)关联：<br />
stdin(0): keyboard<br />
stdout(1): monitor<br />
stderr(2): monitor</p>

<p>我们可以用如下下命令测试一下：</p>

<p>CODE:</p>

<p>$ mail -s test root<br />
this is a test mail.<br />
please skip.</p>

<hr />

<p>^d (同时按 crtl 跟 d 键)</p>

<p>很明显，mail 程序所读进的数据，就是从 stdin 也就是 keyboard 读进的。<br />
不过，不见得每个程序的 stdin 都跟 mail 一样从 keyboard 读进，<br />
因为程序作者可以从档案参数读进 stdin ，如：</p>

<p>CODE:</p>

<p>$ cat /etc/passwd</p>

<hr />

<p>但，要是 cat 之后没有档案参数则又如何呢？<br />
哦，请您自己玩玩看啰&hellip;. ^_^</p>

<p>CODE:</p>

<p>$ cat</p>

<hr />

<h2 id="12-2">12.2</h2>

<p>(请留意数据输出到哪里去了，最后别忘了按 ^d 离开&hellip;)<br />
至于 stdout 与stderr ，嗯&hellip; 等我有空再续吧&hellip; ^_^<br />
还是，有哪位前辈要来玩接龙呢？</p>

<p>相信，经过上一个练习后，你对 stdin 与 stdout 应该不难理解吧？<br />
然后，让我们继续看 stderr 好了。<br />
事实上，stderr 没甚么难理解的：说穿了就是&rdquo;错误信息&rdquo;要往哪边送而已&hellip;<br />
比方说，若读进的档案参数是不存在的，那我们在 monitor 上就看到了：</p>

<p>CODE:</p>

<p>$ ls no.such.file<br />
ls: no.such.file: No such file or directory</p>

<hr />

<p>若，一个命令同时产生stdout 与 stderr 呢？<br />
那还不简单，都送到 monitor 来就好了：</p>

<p>CODE:</p>

<p>$ touch my.file<br />
$ ls my.file no.such.file<br />
ls: no.such.file: No such file or directory<br />
my.file</p>

<hr />

<p>okay，至此，关于 FD 及其名称、还有相关联的设备，相信你已经没问题了吧？<br />
那好，接下来让我们看看如何改变这些 FD 的预设数据信道，<br />
我们可用 &lt; 来改变读进的数据信道(stdin)，使之从指定的档案读进。<br />
我们可用 &gt; 来改变送出的数据信道(stdout,stderr)，使之输出到指定的档案。</p>

<p>比方说：</p>

<p>CODE:</p>

<p>$ cat &lt; my.file</p>

<hr />

<p>就是从 my.file 读进数据</p>

<p>CODE:</p>

<p>$ mail -s test root &lt; /etc/passwd</p>

<hr />

<p>则是从/etc/passwd 读进&hellip;<br />
这样一来，stdin 将不再是从 keyboard 读进，而是从档案读进了&hellip;<br />
严格来说，&lt; 符号之前需要指定一个 FD 的(之间不能有空白)，<br />
但因为 0 是 &lt; 的默认值，因此 &lt; 与 0&lt; 是一样的﹗</p>

<p>okay，这个好理解吧？<br />
那，要是用两个 &lt;&lt; 又是啥呢？<br />
这是所谓的 HERE Document ，它可以让我们输入一段文本，直到读到 &lt;&lt; 后指定的字符串。<br />
比方说：</p>

<p>CODE:</p>

<p>$ cat &lt; first line here<br />
second line there<br />
third line nowhere<br />
FINISH</p>

<hr />

<h2 id="12-3">12.3</h2>

<p>这样的话，cat 会读进 3 行句子，而无需从 keyboard 读进数据且要等 ^d 结束输入。</p>

<p>至于 &gt; 又如何呢？<br />
当你搞懂了 0&lt; 原来就是改变 stdin 的数据输入信道之后，相信要理解如下两个 redirection就不难了：<br />
* 1&gt;<br />
* 2&gt;<br />
前者是改变 stdout 的数据输出信道，后者是改变 stderr 的数据输出信道。<br />
两者都是将原本要送出到 monitor 的数据转向输出到指定档案去。<br />
由于 1 是 &gt; 的默认值，因此，1&gt; 与 &gt; 是相同的，都是改 stdout 。</p>

<p>用上次的 ls 例子来说明一下好了：</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file 1&gt;file.out<br />
ls: no.such.file: No such file or directory</p>

<hr />

<p>这样 monitor 就只剩下 stderr 而已。因为 stdout 给写进 file.out 去了。</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file 2&gt;file.err<br />
my.file</p>

<hr />

<p>这样 monitor 就只剩下 stdout ，因为 stderr 写进了 file.err 。</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file 1&gt;file.out 2&gt;file.err</p>

<hr />

<p>这样 monitor 就啥也没有，因为 stdout 与 stderr 都给转到档案去了&hellip;<br />
呵~~~ 看来要理解 &gt; 一点也不难啦﹗是不？没骗你吧？ ^_^<br />
不过，有些地方还是要注意一下的。</p>

<p>首先，是同时写入的问题。比方如下这个例子：</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file 1&gt;file.both 2&gt;file.both</p>

<hr />

<p>假如 stdout(1) 与stderr(2) 都同时在写入 file.both 的话，<br />
则是采取“覆盖”方式：后来写入的覆盖前面的。<br />
让我们假设一个 stdout 与 stderr 同时写入 file.out 的情形好了：<br />
* 首先 stdout 写入10个字符<br />
* 然后 stderr 写入 6 个字符<br />
那么，这时候原本 stdout 的前面 6 个字符就被 stderr 覆盖掉了。</p>

<p>那，如何解决呢？所谓山不转路转、路不转人转嘛，<br />
我们可以换一个思维：将 stderr 导进 stdout 或将 stdout 导进 sterr ，而不是大家在抢同一份档案，不就行了﹗<br />
bingo﹗就是这样啦：<br />
*2&gt;&amp;1 就是将 stderr并进 stdout 作输出<br />
* 1&gt;&amp;2 或 &gt;&amp;2 就是将stdout 并进 stderr 作输出<br />
于是，前面的错误操作可以改为：</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file 1&gt;file.both 2&gt;&amp;1<br />
或<br />
$ ls my.file no.such.file 2&gt;file.both &gt;&amp;2</p>

<hr />

<p>这样，不就皆大欢喜了吗？ 呵~~~ ^_^</p>

<p>不过，光解决了同时写入的问题还不够，我们还有其它技巧需要了解的。<br />
故事还没结束，别走开﹗广告后，我们再回来&hellip;﹗</p>

<h2 id="12-4">12.4</h2>

<p>okay，这次不讲 I/O Redirction ，讲佛吧&hellip;<br />
(有没搞错？﹗网中人是否头壳烧坏了？&hellip;) 嘻~~~ ^_^</p>

<p>学佛的最高境界，就是&rdquo;四大皆空&rdquo;。至于是空哪四大块？我也不知，因为我还没到那境界&hellip;<br />
但这个&rdquo;空&rdquo;字，却非常值得我们返复把玩的：</p>

<p>在 Linux 档案系统里，有个设备档位于/dev/null  。<br />
许多人都问过我那是甚么玩意儿？我跟你说好了：那就是&rdquo;空&rdquo;啦﹗<br />
没错﹗空空如也的空就是 null 了&hellip;. 请问施主是否忽然有所顿误了呢？然则恭喜了~~~ ^_^</p>

<p>这个 null 在 I/O Redirection 中可有用得很呢：<br />
* 若将 FD1 跟 FD2 转到 /dev/null 去，就可将 stdout 与 stderr 弄不见掉。<br />
* 若将 FD0 接到 /dev/null 来，那就是读进 nothing 。<br />
比方说，当我们在执行一个程序时，画面会同时送出 stdout 跟 stderr ，<br />
假如你不想看到 stderr (也不想存到档案去)，那可以：</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file 2&gt;/dev/null<br />
my.file</p>

<hr />

<p>若要相反：只想看到 stderr 呢？还不简单﹗将 stdout 弄到 null 就行：</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file &gt;/dev/null<br />
ls: no.such.file: No such file or directory</p>

<hr />

<p>那接下来，假如单纯只跑程序，不想看到任何输出结果呢？<br />
哦，这里留了一手上次节目没讲的法子，专门赠予有缘人﹗&hellip; ^_^<br />
除了用 &gt;/dev/null 2&gt;&amp;1 之外，你还可以如此：</p>

<p>CODE:</p>

<p>$ ls my.file no.such.file &amp;&gt;/dev/null</p>

<hr />

<p>(提示：将 &amp;&gt; 换成 &gt;&amp; 也行啦~~! )</p>

<p>okay？讲完佛，接下来，再让我们看看如下情况：</p>

<p>CODE:</p>

<p>$ echo &ldquo;1&rdquo; &gt; file.out<br />
$ cat file.out<br />
1<br />
$ echo &ldquo;2&rdquo; &gt; file.out<br />
$ cat file.out<br />
2</p>

<hr />

<p>看来，我们在重导stdout 或 stderr 进一份档案时，似乎永远只获得最后一次导入的结果。<br />
那，之前的内容呢？<br />
呵~~~ 要解决这个问提很简单啦，将 &gt; 换成 &gt;&gt; 就好：</p>

<p>CODE:</p>

<p>$ echo &ldquo;3&rdquo; &gt;&gt; file.out<br />
$ cat file.out<br />
2<br />
3</p>

<hr />

<p>如此一来，被重导的目标档案之内容并不会失去，而新的内容则一直增加在最后面去。<br />
easy ？ 呵 &hellip; ^_^</p>

<p>但，只要你再一次用回单一的 &gt; 来重导的话，那么，旧的内容还是会被&rdquo;洗&rdquo;掉的﹗<br />
这时，你要如何避免呢？<br />
-&mdash;备份﹗ yes ，我听到了﹗不过&hellip;. 还有更好的吗？<br />
既然与施主这么有缘份，老纳就送你一个锦囊妙法吧：</p>

<p>CODE:</p>

<p>$ set -o noclobber<br />
$ echo &ldquo;4&rdquo; &gt; file.out<br />
-bash: file: cannot overwrite existing file</p>

<hr />

<p>那，要如何取消这个&rdquo;限制&rdquo;呢？<br />
哦，将 set -o 换成 set +o 就行：</p>

<p>CODE:</p>

<p>$ set +o noclobber<br />
$ echo &ldquo;5&rdquo; &gt; file.out<br />
$ cat file.out<br />
5</p>

<hr />

<p>再问：那&hellip; 有办法不取消而又&rdquo;临时&rdquo;盖写目标档案吗？<br />
哦，佛曰：不可告也﹗<br />
啊~~~ 开玩笑的、开玩笑的啦~~~ ^_^ 唉，早就料到人心是不足的了﹗</p>

<p>CODE:</p>

<p>$ set -o noclobber<br />
$ echo &ldquo;6&rdquo; &gt;| file.out<br />
$ cat file.out<br />
6</p>

<hr />

<p>留意到没有：在 &gt; 后面再加个&rdquo; | &ldquo;就好(注意： &gt; 与 | 之间不能有空白哦)&hellip;.</p>

<p>再来还有一个难题要你去参透的呢：</p>

<p>CODE:</p>

<p>$ echo &ldquo;some text here&rdquo; &gt; file<br />
$ cat &lt; file<br />
some text here<br />
$ cat &lt; file &gt; file.bak<br />
$ cat &lt; file.bak<br />
some text here<br />
$ cat &lt; file &gt; file<br />
$ cat &lt; file</p>

<hr />

<p>嗯？﹗注意到没有？﹗﹗<br />
-&mdash; 怎么最后那个 cat 命令看到的 file 竟是空的？﹗<br />
why? why? why?</p>

<h2 id="12-5">12.5</h2>

<p>前面提到：$ cat&lt; file &gt; file 之后原本有内容的档案结果却被洗掉了﹗<br />
要理解这一现像其实不难，这只是 priority 的问题而已：<br />
* 在 IO Redirection中，stdout 与 stderr 的管道会先准备好，才会从 stdin 读进资料。<br />
也就是说，在上例中，&gt; file 会先将 file 清空，然后才读进 &lt; file ， 但这时候档案已经被清空了，因此就变成读不进任何数据了&hellip;</p>

<p>哦~~~ 原来如此~~~~ ^_^<br />
那&hellip; 如下两例又如何呢？</p>

<p>CODE:</p>

<p>$ cat &lt;&gt; file<br />
$ cat &lt; file &gt;&gt; file</p>

<hr />

<p>嗯&hellip; 同学们，这两个答案就当练习题啰，下节课之前请交作业﹗</p>

<p>好了，I/O Redirection 也快讲完了，sorry，因为我也只知道这么多而已啦~~~ 嘻~~ ^_^<br />
不过，还有一样东东是一定要讲的，各位观众(请自行配乐~!#@!$%)：<br />
-&mdash; 就是 pipe line 也﹗</p>

<p>谈到 pipe line ，我相信不少人都不会陌生：<br />
我们在很多 command line 上常看到的&rdquo;| &ldquo;符号就是 pipe line 了。<br />
不过，究竟 pipe line 是甚么东东呢？<br />
别急别急&hellip; 先查一下英汉字典，看看 pipe 是甚么意思？<br />
没错﹗它就是&rdquo;水管&rdquo;的意思&hellip;<br />
那么，你能想象一下水管是怎么一根接着一根的吗？<br />
又，每根水管之间的 input 跟 output 又如何呢？<br />
灵光一闪：原来 pipe line 的 I/O 跟水管的 I/O 是一模一样的：<br />
* 上一个命令的 stdout 接到下一个命令的 stdin 去了﹗<br />
的确如此&hellip; 不管在 command line 上你使用了多少个 pipe line ，<br />
前后两个 command 的 I/O 都是彼此连接的﹗(恭喜：你终于开窍了﹗ ^_^ )</p>

<p>不过&hellip; 然而&hellip; 但是&hellip; &hellip; stderr 呢？<br />
好问题﹗不过也容易理解：<br />
* 若水管漏水怎么办？<br />
也就是说：在 pipe line 之间，前一个命令的stderr 是不会接进下一命令的 stdin 的，<br />
其输出，若不用 2&gt; 导到 file 去的话，它还是送到监视器上面来﹗<br />
这点请你在 pipe line 运用上务必要注意的。</p>

<p>那，或许你又会问：<br />
* 有办法将 stderr也喂进下一个命令的 stdin 去吗？<br />
(贪得无厌的家伙﹗)<br />
方法当然是有，而且你早已学过了﹗ ^_^<br />
我提示一下就好：<br />
* 请问你如何将 stderr 合并进 stdout 一同输出呢？<br />
若你答不出来，下课之后再来问我吧&hellip; (如果你脸皮真够厚的话&hellip;)</p>

<p>或许，你仍意尤未尽﹗或许，你曾经碰到过下面的问题：<br />
* 在 cm1 | cm2 | cm3 &hellip; 这段 pipeline 中，若要将 cm2 的结果存到某一档案呢？</p>

<p>若你写成 cm1 | cm2 &gt; file | cm3 的话，<br />
那你肯定会发现 cm3 的 stdin 是空的﹗(当然啦，你都将水管接到别的水池了﹗)<br />
聪明的你或许会如此解决：</p>

<p>CODE:</p>

<p>cm1 | cm2 &gt; file ; cm3 &lt; file</p>

<hr />

<p>是的，你的确可以这样做，但最大的坏处是：这样一来，file I/O 会变双倍﹗<br />
在 command 执行的整个过程中，file I/O 是最常见的最大效能杀手。<br />
凡是有经验的 shell 操作者，都会尽量避免或降低 fileI/O 的频率。</p>

<p>那，上面问题还有更好方法吗？<br />
有的，那就是 tee 命令了。<br />
* 所谓 ** tee** 命令是在不影响原本 I/O 的情况下，将 stdout 复制一份到档案去。<br />
因此，上面的命令行可以如此打：</p>

<p>CODE:</p>

<p>cm1 | cm2 | tee file | cm3</p>

<hr />

<p>在预设上，tee 会改写目标档案，若你要改为增加内容的话，那可用 -a 参数达成。</p>

<p>基本上，pipe line 的应用在 shell 操作上是非常广泛的，尤其是在 text filtering 方面， 凡举 cat, more,
head,tail, wc, expand, tr, grep, sed, awk, &hellip; 等等文字处理工具， 搭配起pipe line 来使用，你会惊觉
command line 原来是活得如此精彩的﹗<br />
常让人有&rdquo;众里寻他千百度，蓦然回首，那人却在灯火阑珊处﹗&rdquo;之感&hellip; ^_^</p>

<p>好了，关于 I/O Redirection 的介绍就到此告一段落。<br />
若日后有空的话，再为大家介绍其它在 shell 上好玩的东西﹗bye&hellip;^_^</p>

<h1 id="13-你要-if-还是-case-呢">13 你要 if 还是 case 呢？</h1>

<p>还记得我们在第 10 章所介绍的 return value 吗？<br />
是的，接下来介绍的内容与之有关，若你的记忆也被假期的欢乐时光所抵消掉的话，<br />
那，建议您还是先回去温习温习再回来&hellip;</p>

<p>若你记得 return value ，我想你也应该记得了 &amp;&amp; 与 || 是甚么意思吧？<br />
用这两个符号再配搭 command group 的话，我们可让shell script 变得更加聪明哦。<br />
比方说：</p>

<p>CODE:</p>

<p>comd1 &amp;&amp; {<br />
comd2<br />
comd3<br />
} || {<br />
comd4<br />
comd5<br />
}</p>

<hr />

<p>意思是说：</p>

<p>假如 comd1 的 return value 为 true 的话，<br />
然则执行 comd2 与 comd3 ，<br />
否则执行 comd4 与 comd5 。</p>

<p>事实上，我们在写 shell script 的时候，经常需要用到这样那样的条件以作出不同的处理动作。用 &amp;&amp; 与 ||
的确可以达成条件执行的效果，然而，从&rdquo;人类语言&rdquo;上来理解，却不是那么直观。<br />
更多时候，我们还是喜欢用 if &hellip;. then &hellip; else &hellip; 这样的 keyword 来表达条件执行。<br />
在 bash shell 中，我们可以如此修改上一段代码：</p>

<p>CODE:</p>

<p>if comd1<br />
then<br />
comd2<br />
comd3<br />
else<br />
comd4<br />
comd5<br />
fi</p>

<hr />

<p>这也是我们在 shell script 中最常用到的 if 判断式：</p>

<p>只要 if 后面的 command line 返回 true 的 return value (我们最常用 test 命令来送出 return value)，<br />
然则就执行 then 后面的命令，否则执行 else后的命令﹔fi 则是用来结束判断式的 keyword 。</p>

<p>在 if 判断式中，else 部份可以不用，但 then 是必需的。<br />
(若 then 后不想跑任何 command ，可用&rdquo; ： &ldquo; 这个null command 代替)。<br />
当然，then 或 else 后面，也可以再使用更进一层的条件判断式，这在 shell script 设计上很常见。<br />
若有多项条件需要&rdquo;依序&rdquo;进行判断的话，那我们则可使用 elif 这样的 keyword ：</p>

<p>CODE:</p>

<p>if comd1; then<br />
comd2<br />
elif comd3; then<br />
comd4<br />
else<br />
comd5<br />
fi</p>

<hr />

<p>意思是说：</p>

<p>若 comd1 为 true ，然则执行 comd2 ﹔<br />
否则再测试 comd3 ，然则执行 comd4 ﹔<br />
倘若 comd1 与 comd3 均不成立，那就执行 comd5 。</p>

<p>if 判断式的例子很常见，你可从很多 shell script 中看得到，我这里就不再举例子了&hellip;</p>

<p>接下来要为大家介绍的是 case 判断式。<br />
虽然 if 判断式已可应付大部份的条件执行了，然而，在某些场合中，却不够灵活，<br />
尤其是在 string 式样的判断上，比方如下：</p>

<p>CODE:</p>

<p>QQ () {<br />
echo -n &ldquo;Do you want to continue? (Yes/No): &ldquo;<br />
read YN<br />
if [ &ldquo;$YN&rdquo; = Y -o &ldquo;$YN&rdquo; = y -o &ldquo;$YN&rdquo; = &ldquo;Yes&rdquo; -o &ldquo;$YN&rdquo; = &ldquo;yes&rdquo; -o &ldquo;$YN&rdquo; = &ldquo;YES&rdquo;
]<br />
then<br />
QQ<br />
else<br />
exit 0<br />
fi<br />
}<br />
QQ</p>

<hr />

<p>从例中，我们看得出来，最麻烦的部份是在于判断 YN 的值可能有好几种式样。<br />
聪明的你或许会如此修改：</p>

<p>CODE:</p>

<p>&hellip;<br />
if echo &ldquo;$YN&rdquo; | grep -q &lsquo;<sup class="footnote-ref" id="fnref:Yy"><a href="#fn:Yy">1</a></sup>\([Ee][Ss]\)*$&rsquo;<br />
&hellip;</p>

<hr />

<p>也就是用 RegularExpression 来简化代码。(我们有机会再来介绍 RE)<br />
只是&hellip; 是否有其它更方便的方法呢？<br />
有的，就是用 case 判断式即可：</p>

<p>CODE:</p>

<p>QQ () {<br />
echo -n &ldquo;Do you want to continue? (Yes/No): &ldquo;<br />
read YN<br />
case &ldquo;$YN&rdquo; in<br />
[Yy]|[Yy][Ee][Ss])<br />
QQ<br />
;;<br />
*)<br />
exit 0<br />
;;<br />
esac<br />
}<br />
QQ</p>

<hr />

<p>我们常 case 的判断式来判断某一变量在同的值(通常是 string)时作出不同的处理，<br />
比方说，判断 script 参数以执行不同的命令。<br />
若你有兴趣、且用 Linux 系统的话，不妨挖一挖/etc/init.d/* 里那堆 script 中的 case用法。<br />
如下就是一例：</p>

<p>CODE:</p>

<p>case &ldquo;$1&rdquo; in<br />
start)<br />
start<br />
;;<br />
stop)<br />
stop<br />
;;<br />
status)<br />
rhstatus<br />
;;<br />
restart|reload)<br />
restart<br />
;;<br />
condrestart)<br />
[ -f /var/lock/subsys/syslog ] &amp;&amp; restart || :<br />
;;<br />
*)<br />
echo $&ldquo;Usage: $0 {start|stop|status|restart|condrestart}&rdquo;<br />
exit 1<br />
esac</p>

<hr />

<p>(若你对 positional parameter 的印像已经模糊了，请重看第 9 章吧。)</p>

<h1 id="14-forwhat-while-与-until-差在哪">14 forwhat? while 与 until 差在哪？</h1>

<p>终于，来到 shell 十三问的最后一问了&hellip; 长长吐一口气~~~~</p>

<p>最后要介绍的是 shell script 设计中常见的&rdquo;循环&rdquo;(loop)。<br />
所谓的 loop 就是 script 中的一段在一定条件下反复执行的代码。<br />
bash shell 中常用的 loop 有如下三种：<br />
*for<br />
* while<br />
* until</p>

<p>for loop 是从一个清单列表中读进变量值，并&rdquo;依次&rdquo;的循环执行 do 到done 之间的命令行。<br />
例：</p>

<p>CODE:</p>

<p>for var in one two three four five<br />
do<br />
echo &mdash;&mdash;&mdash;&ndash;<br />
echo &lsquo;$var is &lsquo;$var<br />
echo<br />
done</p>

<hr />

<p>上例的执行结果将会是：</p>

<p>1) for 会定义一个叫 var 的变量，其值依次是 one two three four five 。<br />
2) 因为有 5 个变量值，因此 do 与 done 之间的命令行会被循环执行 5 次。<br />
3) 每次循环均用 echo 产生三行句子。<br />
而第二行中不在 hard quote 之内的 $var 会依次被替换为 one two three four five 。<br />
4) 当最后一个变量值处理完毕，循环结束。</p>

<p>我们不难看出，在 for loop 中，变量值的多寡，决定循环的次数。<br />
然而，变量在循环中是否使用则不一定，得视设计需求而定。<br />
倘若 for loop 没有使用 in 这个 keyword 来指定变量值清单的话，其值将从 $@ (或 $* )中继承：</p>

<p>CODE:</p>

<p>for var; do<br />
&hellip;.<br />
done</p>

<hr />

<p>(若你忘记了 positional parameter ，请温习第 9 章&hellip;)</p>

<p>for loop 用于处理&rdquo;清单&rdquo;(list)项目非常方便，<br />
其清单除了可明确指定或从 positional parameter 取得之外，<br />
也可从变量替换或命令替换取得&hellip; (再一次提醒：别忘了命令行的&rdquo;重组&rdquo;特性﹗)<br />
然而，对于一些&rdquo;累计变化&rdquo;的项目(如整数加减)，for 亦能处理：</p>

<p>CODE:</p>

<p>for ((i=1;i&lt;=10;i++))<br />
do<br />
echo &ldquo;num is $i&rdquo;<br />
done</p>

<hr />

<p>除了 for loop ，上面的例子我们也可改用 while loop 来做到：</p>

<p>CODE:</p>

<p>num=1<br />
while [ &ldquo;$num&rdquo; -le 10 ]; do<br />
echo &ldquo;num is $num&rdquo;<br />
num=$(($num + 1))<br />
done</p>

<hr />

<p>whileloop的原理与 for loop稍有不同：<br />
它不是逐次处理清单中的变量值，而是取决于 while 后面的命令行之 return value ：<br />
* 若为 ture，则执行 do 与 done之间的命令，然后重新判断 while 后的 returnvalue 。<br />
* 若为 false ，则不再执行 do 与 done 之间的命令而结束循环。</p>

<p>分析上例：</p>

<p>1) 在 while 之前，定义变量num=1 。<br />
2) 然后测试(test) $num 是否小于或等于 10 。<br />
3) 结果为 true ，于是执行 echo 并将 num 的值加一。<br />
4) 再作第二轮测试，其时 num 的值为 1+1=2 ，依然小于或等于 10，因此为 true ，继续循环。<br />
5) 直到 num 为 10+1=11 时，测试才会失败&hellip; 于是结束循环。</p>

<p>我们不难发现：<br />
* 若 while的测试结果永远为 true 的话，那循环将一直永久执行下去：</p>

<p>CODE:</p>

<p>while :; do<br />
echo looping&hellip;<br />
done</p>

<hr />

<p>上例的&rdquo; :&ldquo;是 bash 的 null command ，不做任何动作，除了送回 true 的 return value 。<br />
因此这个循环不会结束，称作死循环。<br />
死循环的产生有可能是故意设计的(如跑 daemon)，也可能是设计错误。<br />
若要结束死寻环，可透过 signal 来终止(如按下 ctrl-c )。<br />
(关于 process 与 signal ，等日后有机会再补充，十三问暂时略过。)</p>

<p>一旦你能够理解 while loop 的话，那，就能理解 untilloop ：<br />
* 与 while相反，until 是在return value 为 false 时进入循环，否则结束。<br />
因此，前面的例子我们也可以轻松的用 until 来写：</p>

<p>CODE:</p>

<p>num=1<br />
until [ ! &ldquo;$num&rdquo; -le 10 ]; do<br />
echo &ldquo;num is $num&rdquo;<br />
num=$(($num + 1))<br />
done</p>

<hr />

<p>或是：</p>

<p>CODE:</p>

<p>num=1<br />
until [ &ldquo;$num&rdquo; -gt 10 ]; do<br />
echo &ldquo;num is $num&rdquo;<br />
num=$(($num + 1))<br />
done</p>

<hr />

<p>okay ，关于 bash 的三个常用的loop 暂时介绍到这里。<br />
在结束本章之前，再跟大家补充两个与 loop 有关的命令：<br />
* break<br />
* continue<br />
这两个命令常用在复合式循环里，也就是在 do &hellip; done 之间又有更进一层的 loop ，<br />
当然，用在单一循环中也未尝不可啦&hellip; ^_^</p>

<p>break 是用来打断循环，也就是&rdquo;强迫结束&rdquo;循环。<br />
若 break 后面指定一个数值 n 的话，则&rdquo;从里向外&rdquo;打断第n 个循环，<br />
默认值为 break 1 ，也就是打断当前的循环。<br />
在使用 break 时需要注意的是， 它与 return 及 exit 是不同的：<br />
*break 是结束 loop<br />
* return 是结束 function<br />
* exit 是结束 script/shell</p>

<p>而 continue 则与 break 相反：强迫进入下一次循环动作。<br />
若你理解不来的话，那你可简单的看成：在 continue 到done 之间的句子略过而返回循环顶端&hellip;<br />
与 break 相同的是：continue 后面也可指定一个数值 n ，以决定继续哪一层(从里向外计算)的循环，<br />
默认值为 continue 1 ，也就是继续当前的循环。</p>

<p>在 shell script 设计中，若能善用 loop ，将能大幅度提高 script 在复杂条件下的处理能力。<br />
请多加练习吧&hellip;.</p>

<h1 id="15-跟-差在哪">15 [^ ] 跟 [! ] 差在哪？</h1>

<p>这个问题等了好久都没人出来补充, 而我呢, 也被追杀了好几回&hellip; ^_^</p>

<p>这道题目说穿了, 就是要探讨 Wildcard 与 Regular Expression 的差别的.<br />
这也是许多初学 shell 的朋友很容易混乱的地方.<br />
首先, 让我们回到十三问之第 2 问, 再一次将我们提到的 command line format 温习一次:<br />
[code]command_name options arguments[/code]<br />
同时, 也再来理解一下我在第 5 问所提到的变量替换的特性:<br />
[code]先替换, 再重组 command lline![/code]<br />
有了这两道基础后, 才让我们来看看 wildcard 是甚么回事吧.</p>

<p><strong>Part-I: Wildcard</strong><br />
首先, wildcard 也是属于 command line 的处理工序, 作用于 argument 里的 path 之上.没错,
它不用在command_name 也不用在 options 上.而且, 若 argument 不是 path 的话, 那也与 wildcard
无关.换句更为精确的定义来讲,wildcard 是一种命令行的路径扩展(pathexpansion)功能.提到这个扩展, 那就不要忘记了 command
line 的&rdquo;重组&rdquo;特性了!是的,
这与变量替换(variablesubstitution)及命令替换(commandsubstitution)的重组特性是一样的!也就是在 wildcard
进行扩展后, 命令行会先完成重组才会交给 shell 来处理.</p>

<p>了解了 wildcard 的扩展与重组特性后, 接下来, 让我们了解一些常见的 wildcard 吧:<br />
*: 匹配 0 或多个字符<br />
?: 匹配任意单一字符<br />
[list]: 匹配 list 中的任意单一字符(注一)<br />
[!list]: 匹配不在 list 中的任意单一字符<br />
{string1,string2,&hellip;}: 匹配 sring1 或 string2 (或更多)其一字符串<br />
(注一: list 可以为指定的个别字符, 如 abcd; 也可以为一段 ASCII 字符的起止范围, 如: a-d .)</p>

<p>例:<br />
a*b: a 与 b 之间可以有任意长度的任意字符, 也可以一个也没有, 如: aabcb, axyzb, a012b, ab 等.<br />
a?b: a 与 b 之间必须也只能有一个字符, 可以是任意字符, 如: aab, abb, acb, a0b 等.<br />
a[xyz]b: a 与 b 之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb,azb 这三个.<br />
a[!0-9]b: a 与 b 之间必须也只能有一个字符, 但不能是阿拉伯数字, 如: axb, aab, a-b 等.<br />
a{abc,xyz,123}b: a 与 b 之间只能是 abc 或 xyz 或 123 这三个字符串之一, 如 aabcb, axyzb, a123b
这三个.</p>

<p>注意:<br />
1) [! ] 中的 ! 只有放在第一顺位时, 才有排除之功. 举例说:<br />
[!a]* 表示当前目录下所有不以 a 开首的路径名称.<br />
/tmp/[a\!]* 表示 /tmp 目录下以 a 或 ! 开首的路径名称. (思考: 为何 ! 前面要加 \ 呢? 提示: 十三问之 4 )</p>

<p>2) [ -] 中的 - 左右两边均有字符时, 才表示一段范围, 否则仅作 &ldquo;-&rdquo;(减号) 字符来处理. 举例说:<br />
/tmp/<em>[-z]/[a-zA-Z]</em> 表示 /tmp 目录下所有以 z 或 - 结尾的子目录下以英文字母(不分大小写)开首的路径名称.</p>

<p>3) 以 * 或 ? 开首的 wildcard 不能匹配隐藏文件(即以 . 开首的文件). 举例说:<br />
*.txt 并不能匹配 .txt 但可匹配 1.txt 这样的路径名称.<br />
但 1*txt 及 1?txt 均可匹配 1.txt 这样的路径名称.</p>

<p>基本上, 要掌握 wildcard 并不难, 只要多加练习, 再勤于思考, 就能熟加运用了.<br />
再次提醒: 别忘了&rdquo;扩充+重组&rdquo;这个重要特性, 而且只作用在 argument 的 path 上.<br />
比方说, 假设当前目录下有 a.txt b.txt c.txt 1.txt2.txt 3.txt 这几份文件.<br />
当我们在命令行中下达 ls-l [0-9].txt 的命令行时,<br />
因为 wildcard 处于 argument 的位置上, 于是根据其匹配的路径, 扩展为 1.txt2.txt 3.txt ,<br />
再重组出 ls -l1.txt 2.txt 3.txt 这样的命令行.<br />
因此, 你在命令行上敲 ls -l [0-9].txt 与 ls -l 1.txt 2.txt 3.txt 都是同样的结果, 其原因正是于此了&hellip; :)</p>

<p>#</p>

<p>**Part-II:Regular Expression<br />
**<br />
接下来的 RegularExpression(RE) 可是个大题目, 要讲的很多, 我这里当然不可能讲得很完全.只希望带给大家一个基本的入门概念,
就很是足够了&hellip;</p>

<p>先来考一下英文好了:What is expression?<br />
简单来说, 就是&rdquo;表达&rdquo;, 也就是人们在沟通时所要陈述的内容.<br />
然而, 生活中, 表达方要清楚的将意思描述清楚而让接收方完整且无误的领会, 可不是件容易的事情.<br />
因而才会出现那么多的&rdquo;误会&rdquo;, 真可叹句&rdquo;表达不易&rdquo;啊&hellip;.<br />
同样的情形也发生在计算机的数据处理过程中, 尤其是当我们在描术一段&rdquo;文字内容&rdquo;的时候&hellip;<br />
那么, 我们不禁要问: 有何方法可以让大家的误会降至最低程度而让表达的精确度达到最高程度呢?<br />
答案就是&rdquo;标准化&rdquo;了, 亦就是我们这里要谈的 Regular Expression 啦&hellip;. ^_^</p>

<p>然而, 在进入 RE 介绍之前, 不防先让我们温习一下 shell 十三问第 4 问, 也就是关于 quoting 的部份.<br />
关键是要能够区分 shellcommand line 上的 meta 与 literal 这两种不同的字符类别.<br />
然后, 我这里才跟你讲:<br />
-&ndash; RE 表达式里的字符也是分为meta 与 literal 这两种!<br />
呵, 不知亲爱的读者是否被我搞混乱了呢? &hellip; ^_^<br />
这也难怪啦, 因为这的确是最容易混乱的地方, 刚学 RE 的朋友很多时候都死在这里!<br />
因此请特别小心理解哦&hellip;<br />
简单而言, 除非你将 RE 写在特定程序使用的脚本里,<br />
否则, 我们的 RE 也是透过 command line 输入的.<br />
然而, 不少 RE 所始用的 meta 字符, 跟 shell meta 字符是冲突的.<br />
比方说, * 这个字符, 在 RE 里是一个 modifier(后述), 在 command line 上, 却是个 wildcard !</p>

<p>那么, 我们该如何解决这样的冲突呢? 关键就是看你对十三问第 4 问所提的 quoting 是否够理解了!<br />
若你明白到 shellquoting 就是在 commandline 上关闭 shell meta这一基本原理,<br />
那你就能很轻松的解决 REmeta 与 shell meta 的冲突问题了:<br />
-&ndash; 用 shellquoting 关掉 shell meta 就是了!<br />
就这么简单&hellip; ^_^<br />
再以刚提到的 * 字符为例, 若在 command line 中没有 quoting 处理的话, 如 abc* ,<br />
那就会被作为wildcard expansion 来扩充及重组了.<br />
若将之置于 quoting 中, 如 &ldquo;abc*&ldquo;, 则可避免 wildcard expansion 的处理.</p>

<p>好了, 说了大半天, 还没进入正式的 RE 介绍呢&hellip;<br />
大家别急, 因为我的教学风格就是要先建立基础, 循序渐进的&hellip; ^_^<br />
因此, 我这里还要在啰唆一个观念, 才会到 RE 的说明啦&hellip; (哈&hellip; 别打我&hellip;.)<br />
当我们在谈到 RE 时, 千万别跟 wildcard 搞混在一起!<br />
尤其在 commandline 的位置里, wildcard只作用于 argument 的 path 上.<br />
但是 RE 却只用于&rdquo;字符串处理&rdquo;的程序之中, 这与路径名称一点关系也没有!<br />
RE 所处理的字符串通常是指纯文档或透过 stdin 读进的内容&hellip;</p>

<p>okay, 够了够了, 我已看到一堆人开始出现不大耐烦的样子了&hellip;. ^_^<br />
现在, 就让我门登堂入室, 撩开 RE 的神秘面纱吧, 这样可以放过我了吧? 哈哈&hellip;</p>

<p>在 RE 的表达式里, 主要分两种字符(character): literal 与 meta.<br />
所谓 literal 就是在 RE 里不具特殊功能的字符, 如 abc, 123 这些;<br />
而 meta 在 RE 里具有特殊的功能, 要关闭之需在 meta 前面使用 escape( \ )字符.</p>

<p>然而, 在介绍 meta 之前, 先让我们来认识一下字符组合(character set)会更好些.<br />
所谓的 char. set 就是将多个连续的字符作一个集合, 比方说:<br />
abc: 表示 abc 三个连续的字符, 但彼此独立而非集合. (可简单视为三个 char. set)<br />
(abc): 表示 abc 这三个连续字符的集合. (可简单视为一个 char. set)<br />
abc|xyz: 表示或 abc 或 xyz 这两个 char. set 之一.<br />
<a href="abc" title="表示单一字符, 不为 a 或 b 或 c 即可. (与 wildcard 之 [!abc] 原理相同)  
">abc</a>: 表示单一字符, 可为 a 或 b 或 c . (与 wildcard 之 <a href="abc" title="表示单一字符, 不为 a 或 b 或 c 即可. (与 wildcard 之 [!abc] 原理相同)  
">abc</a> 原理相同)<br />
. : 表示任意单一字符. (与 wildcard 之 ? 原理相同)</p>

<p>在认识了 char. set这个概念后, 然后再让我们多认识几个 RE 中常见的 meta 字符:</p>

<p>- 锚点(anchor)<br />
用以标识 RE 于句子中的位置所在. 常见有:<br />
^: 表示句首. 如 ^abc 表示以 abc 开首的句子.<br />
$: 表示句尾. 如 abc$ 表示以 abc 结尾的句子.<br />
&lt;: abc=&ldquo;&rdquo;&gt; &gt;: 表示词尾. 如 abc&gt; 表示以 abc 结尾的词.</p>

<p>- 修饰字符(modifier)<br />
独立表示时本身不具意义, 专门用以修改前一个 char. set 的出现次数. 常见有:<br />
*: 表示前一个 char.set 的出现次数为 0 或多次. 如 ab*c 表示 a 与 c 之间可有 0 或多个 b 存在.<br />
?: 表示前一个 char.set 的出现次数为 0 或 1 次. 如 ab?c 表示 a 与 c 之间可有 0 或 1 个 b 存在.<br />
+: 表示前一个 char.set 的出现次数为 1 或多次. 如 ab+c 表示 a 与 c 之间可有 1 或多个 b 存在.<br />
{n}: 表示前一个 char.set 的出现次数必须为 n 次. 如 ab{3,}c 表示 a 与 c 之间必须有 3 个 b 存在.{n,}:
表示前一个 char. set 的出现次数至少为 n 次. 如 ab{3,}c 表示 a 与 c 之间至少有 3 个 b 存在.<br />
{n,m}: 表示前一个 char.set 的出现次数为 n 到 m 次. 如 ab{3,5}c 表示 a 与 c 之间有 3 到 5 个 b 存在.</p>

<p>然而, 当我们在识别 modifier 时, 却很容易忽略&rdquo;边界(boundary)&ldquo;字符的重要性.<br />
以刚提到的 ab{3,5}c为例, 这里的 a 与 c 就是边界字符了.<br />
若没有边界字符的帮忙, 我们很容以作出错误的解读.<br />
比方说: 我们用 ab{3,5} 这个 RE (少了 c 这个边界字符)可以抓到abbbbbbbbbbc (a 后有 10 个 b )这串字吗?<br />
从刚才的 modifier 我们一般会认为我们要的 b 是 3 到 5 个, 若超出了此范围, 就不是我们要表达的.<br />
因此, 我们或会很轻率的认为这个 RE 抓不到结果&hellip;<br />
然而答案却是可以的! 为甚么呢?<br />
让我们重新解读ab{3,5} 这个 RE 看看:<br />
我们要表达的是 a 后接 3 到 5 个 b 即可, 但 3 到 5 个 b 后面我们却没规定是甚么,<br />
因此在 RE 后面可以是任意的文字, 当然包括 b 也可以啦! (明白了吗?)<br />
同样的, 我们用 b{3,5}c 也同样可以抓到 abbbbbbbbbbc 这串字的.<br />
但我们若使用ab{3,5}c 这样的 RE 时, 由于同时有 a 与 c 这两个边界字符, 那就截然不同了!</p>

<p>有空再思考一下, 为何我们用下面这些 RE 都可抓到 abc 这串字呢?<br />
x*<br />
ax<em>, abx</em>, ax<em>b<br />
abcx</em>, abx*c, ax*bc<br />
bx<em>c, bcx</em>, x*bc<br />
&hellip;(还有更多&hellip;)<br />
但, 若我们在这些 RE 前后分别加一个 ^ 与 $ 这样的 anchor, 那又如何呢?</p>

<p>刚学 RE 时, 只要能掌握上面这些基本的 meta 大盖就可以入门了.<br />
一如前述, RE 是一种规范化的文字表达方式, 主要用于某些文字处理工具之间,<br />
如 grep, perl,vi, awk, sed, 等等. 常用以表示一段连续的字符串, 捕获之或替换之.<br />
然而, 每种工具对 RE 表达式的具体解读或有一些细微差异, 不过, 基本原则还是一致的.<br />
只要能掌握 RE 的基本原理, 那就一理通百理明了, 只是在实作时稍加变通即可.</p>

<p>比方以 grep 来说, 在 Linux 上你可找到 grep, egrep, fgrep 这几个程序, 其差异大致如下:</p>

<ul>
<li><p>grep:<br />
传统的 grep 程序, 在没有参数的情况下, 只输出符合 RE 字符串之句子. 常见参数如下:<br />
-v: 逆反模示, 只输出&rdquo;不含&rdquo; RE 字符串之句子.<br />
-r: 递归模式, 可同时处理所有层级子目录里的文件.<br />
-q: 静默模式, 不输出任何结果(stderr 除外. 常用以获取 return value, 符合为 true, 否则为 false .)<br />
-i: 忽略大小写.<br />
-w: 整词比对, 类似 \ .<br />
-n: 同时输出行号.<br />
-c: 只输出符合比对的行数.<br />
-l: 只输出符合比对的文件名称.<br />
-o: 只输出符合 RE 的字符串. (gnu 新版独有, 不见得所有版本都支持.)<br />
-E: 切换为 egrep .</p></li>

<li><p>egrep:<br />
为 grep 的扩充版本, 改良了许多传统 grep 不能或不便的操作. 比方说:<br />
- grep 之下不支持 ? 与 + 这两种 modifier, 但 egrep 则可.<br />
- grep 不支持 a|b 或 (abc|xyz) 这类&rdquo;或一&rdquo;比对, 但 egrep 则可.<br />
- grep 在处理 {n,m} 时, 需用 \{ 与 \} 处理, 但 egrep 则不需.<br />
诸如此类的&hellip; 我个人会建议能用 egrep 就不用 grep 啦&hellip; ^_^</p></li>

<li><p>fgrep:<br />
不作 RE 处理, 表达式仅作一般字符串处理, 所有 meta 均失去功能.</p></li>
</ul>

<p>好了&hellip;<br />
关于 RE 的入门, 我暂时就介绍到这里.<br />
虽然写得有点乱, 且有些观念也不很精确, 不过, 姑且算是对大家有一个交差吧&hellip;. ^_^<br />
若这两天还有时间的话, 我再举些范例来分析一下, 以助大家更好的理解.<br />
假如更有可能的话, 也顺道为大家介绍一下 sed 这个工具.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:Yy">Yy <a class="footnote-return" href="#fnref:Yy"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>