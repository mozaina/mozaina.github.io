<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux下Shell文本处理三剑客awk | 开发者问答集锦</title>
    <meta property="og:title" content="Linux下Shell文本处理三剑客awk - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux下Shell文本处理三剑客awk">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E4%B8%8Bshell%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2awk/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux下Shell文本处理三剑客awk</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="文章目录">文章目录</h3>

<pre><code>  * awk
    * 1、选项
    * 2、模式
    * 3、内置变量
    * 4、操作符
    * 5、流程控制
    * 6、数组
    * 7、内置函数
    * 8、I/O语句
    * 9、printf语句
    * 10、自定义函数
    * 11、需求案例
</code></pre>

<h3 id="awk">awk</h3>

<p>awk是一个处理文本的编程语言工具，能用简短的程序处理标准输入或文件、数据排序、计算以及生成报表等等。</p>

<p>在Linux系统下默认awk是gawk，它是awk的GNU版本。可以通过命令查看应用的版本：ls -l /bin/awk</p>

<p>基本的命令语法：awk option ‘pattern {action}’ file</p>

<p>其中pattern表示AWK在数据中查找的内容，而action是在找到匹配内容时所执行的一系列命令。花括号用于根据特定的模式对一系列指令进行分组。</p>

<p>awk处理的工作方式与数据库类似，支持对记录和字段处理，这也是grep和sed不能实现的。</p>

<p>在awk中，缺省的情况下将文本文件中的一行视为一个记录，逐行放到内存中处理，而将一行中的某一部分作为记录中的一个字段。用1,2,3…数字的方式顺序的表示行（记录）中的不同字段。用$后跟数字，引用对应的字段，以逗号分隔，0表示整个行。</p>

<h4 id="1-选项">1、选项</h4>

<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-f program-file</td>
<td>从文件中读取awk程序源文件</td>
</tr>

<tr>
<td>-F fs</td>
<td>指定fs为输入字段分隔符</td>
</tr>

<tr>
<td>-v var=value</td>
<td>变量赋值</td>
</tr>

<tr>
<td>–posix</td>
<td>兼容POSIX正则表达式</td>
</tr>

<tr>
<td>–dump-variables=[file]</td>
<td>把awk命令时的全局变量写入文件，默认文件是awkvars.out</td>
</tr>

<tr>
<td>–profile=[file]</td>
<td>格式化awk语句到文件，默认是awkprof.out</td>
</tr>
</tbody>
</table>

<h4 id="2-模式">2、模式</h4>

<p>常用模式有：</p>

<table>
<thead>
<tr>
<th>Pattern</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>BEGIN{ }</td>
<td>给程序赋予初始状态，先执行的工作</td>
</tr>

<tr>
<td>END{ }</td>
<td>程序结束之后执行的一些扫尾工作</td>
</tr>

<tr>
<td>/regular expression/</td>
<td>为每个输入记录匹配正则表达式</td>
</tr>

<tr>
<td>pattern &amp;&amp; pattern</td>
<td>逻辑and，满足两个模式</td>
</tr>

<tr>
<td>pattern</td>
<td></td>
</tr>

<tr>
<td>! pattern</td>
<td>逻辑not，不满足模式</td>
</tr>

<tr>
<td>pattern1, pattern2</td>
<td>范围模式，匹配所有模式1的记录，直到匹配到模式2</td>
</tr>
</tbody>
</table>

<p>而动作呢，就是下面所讲的print、流程控制、I/O语句等。</p>

<p>示例：</p>

<pre><code>1）从文件读取awk程序处理文件

[root@ chenc01 ~]# vi test.awk
{print $2}

[root@ chenc01 ~]# tail -n3 /etc/services |awk -f test.awk
48049/tcp
48128/tcp
49000/tcp

2）指定分隔符，打印指定字段 

打印第二字段，默认以空格分隔：

[root@ chenc01 ~]# tail -n3 /etc/services |awk '{print $2}'
48049/tcp
48128/tcp
48128/udp

指定冒号为分隔符打印第一字段：

[root@ chenc01 ~]# awk -F ':' '{print $1}' /etc/passwd
root
bin
daemon
adm
lp
sync
......

还可以指定多个分隔符，作为同一个分隔符处理：

[root@ chenc01 ~]# tail -n3 /etc/services |awk -F'[/#]' '{print $3}'  
 iqobject
 iqobject
 Matahari Broker

[root@ chenc01 ~]# tail -n3 /etc/services |awk -F'[/#]' '{print $1}'
iqobject    48619
iqobject    48619
matahari    49000

[root@ chenc01 ~]# tail -n3 /etc/services |awk -F'[/#]' '{print $2}'
tcp        
udp        
tcp        

[root@ chenc01 ~]# tail -n3 /etc/services |awk -F'[/#]' '{print $3}'
 iqobject
 iqobject
 Matahari Broker

[root@ chenc01 ~]# tail -n3 /etc/services |awk -F'[ /]+' '{print $2}'
48619
48619
49000

[]元字符的意思是符号其中任意一个字符，也就是说每遇到一个/或#时就分隔一个字段，当用多个分隔符时，就能更方面处理字段了。

3）变量赋值

[root@ chenc01 ~]# awk -v a=123 'BEGIN{print a}'  
123

系统变量作为awk变量的值：

[root@ chenc01 ~]# a=123
[root@ chenc01 ~]# awk -v a=$a 'BEGIN{print a}'  
123
或使用单引号
[root@ chenc01 ~]# awk 'BEGIN{print '$a'}'  
123

4）输出awk全局变量到文件
[root@ chenc01 ~]# seq 5 |awk --dump-variables '{print $0}'
1
2
3
4
5

[root@ chenc01 ~]# cat awkvars.out             
ARGC: number (1)
ARGIND: number (0)
ARGV: array, 1 elements
BINMODE: number (0)
CONVFMT: string (&quot;%.6g&quot;)
ERRNO: number (0)
FIELDWIDTHS: string (&quot;&quot;)
FILENAME: string (&quot;-&quot;)
FNR: number (5)
FS: string (&quot; &quot;)
IGNORECASE: number (0)
LINT: number (0)
NF: number (1)
NR: number (5)
OFMT: string (&quot;%.6g&quot;)
OFS: string (&quot; &quot;)
ORS: string (&quot;\n&quot;)
RLENGTH: number (0)
RS: string (&quot;\n&quot;)
RSTART: number (0)
RT: string (&quot;\n&quot;)
SUBSEP: string (&quot;\034&quot;)
TEXTDOMAIN: string (&quot;messages&quot;)

5）BEGIN和END

BEGIN模式是在处理文件之前执行该操作，常用于修改内置变量、变量赋值和打印输出的页眉或标题。

例如：打印页眉

[root@ chenc01 ~]# tail /etc/services |awk 'BEGIN{print &quot;Service\t\tPort\t\t\tDescription\n===&quot;}{print $0}'
Service     Port          Description
===
3gpp-cbsp    48049/tcp           # 3GPP Cell Broadcast Service 
isnetserv    48128/tcp           # Image Systems Network Services
isnetserv    48128/udp           # Image Systems Network Services
blp5      48129/tcp              # Bloomberg locator
blp5      48129/udp              # Bloomberg locator
com-bardac-dw   48556/tcp        # com-bardac-dw
com-bardac-dw   48556/udp        # com-bardac-dw
iqobject    48619/tcp            # iqobject
iqobject    48619/udp            # iqobject
matahari    49000/tcp            # Matahari Broker

END模式是在程序处理完才会执行。

例如：打印页尾

[root@ chenc01 ~]# tail /etc/services |awk '{print $0}END{print &quot;===\nEND......&quot;}'
3gpp-cbsp    48049/tcp           # 3GPP Cell Broadcast Service 
isnetserv    48128/tcp           # Image Systems Network Services
isnetserv    48128/udp           # Image Systems Network Services
blp5      48129/tcp              # Bloomberg locator
blp5      48129/udp              # Bloomberg locator
com-bardac-dw   48556/tcp        # com-bardac-dw
com-bardac-dw   48556/udp        # com-bardac-dw
iqobject    48619/tcp            # iqobject
iqobject    48619/udp            # iqobject
matahari    49000/tcp            # Matahari Broker
===
END......

6）格式化输出awk命令到文件

[root@ chenc01 ~]# tail /etc/services |awk --profile 'BEGIN{print &quot;Service\t\tPort\t\t\tDescription\n===&quot;}{print $0}END{print &quot;===\nEND......&quot;}'
Service     Port           Description
===
nimgtw      48003/udp           # Nimbus Gateway
3gpp-cbsp    48049/tcp          # 3GPP Cell Broadcast Service Protocol
isnetserv    48128/tcp          # Image Systems Network Services
isnetserv    48128/udp          # Image Systems Network Services
blp5       48129/tcp            # Bloomberg locator
blp5       48129/udp            # Bloomberg locator
com-bardac-dw  48556/tcp        # com-bardac-dw
com-bardac-dw  48556/udp        # com-bardac-dw
iqobject     48619/tcp          # iqobject
iqobject     48619/udp          # iqobject
===
END......

[root@ chenc01 ~]# cat awkprof.out 
[root@ chenc01 ~]# gawk profile, created Sat Jan  7 19:45:22 2017
     # BEGIN block(s)
     BEGIN {
         print &quot;Service\t\tPort\t\t\tDescription\n===&quot;
     }
     # Rule(s)
     {
         print $0
     }

     # END block(s)
     END {
         print &quot;===\nEND......&quot;
     }

7）/re/正则匹配

匹配包含tcp的行：

[root@ chenc01 ~]# tail /etc/services |awk '/tcp/{print $0}'  
3gpp-cbsp    48049/tcp           # 3GPP Cell Broadcast Service 
isnetserv    48128/tcp           # Image Systems Network Services
blp5      48129/tcp              # Bloomberg locator
com-bardac-dw   48556/tcp        # com-bardac-dw
iqobject    48619/tcp            # iqobject
matahari    49000/tcp            # Matahari Broker
匹配开头是blp5的行：

[root@ chenc01 ~]# tail /etc/services |awk '/^blp5/{print $0}'  
blp5      48129/tcp             # Bloomberg locator
blp5      48129/udp             # Bloomberg locator
匹配第一个字段是8个字符的行：

[root@ chenc01 ~]# tail /etc/services |awk '/^[a-z0-9]{8} /{print $0}'
iqobject    48619/tcp           # iqobject
iqobject    48619/udp           # iqobject
matahari    49000/tcp           # Matahari Broker

如果没有匹配到，请查看你的awk版本（awk --version）是不是3，因为4才支持{}

8）逻辑and、or和not

匹配记录中包含blp5和tcp的行：

[root@ chenc01 ~]# tail /etc/services |awk '/blp5/ &amp;&amp; /tcp/{print $0}'    
blp5      48129/tcp             # Bloomberg locator
匹配记录中包含blp5或tcp的行：

[root@ chenc01 ~]# tail /etc/services |awk '/blp5/ || /tcp/{print $0}'    
3gpp-cbsp    48049/tcp          # 3GPP Cell Broadcast Service 
isnetserv    48128/tcp          # Image Systems Network Services
blp5      48129/tcp             # Bloomberg locator
blp5      48129/udp             # Bloomberg locator
com-bardac-dw   48556/tcp       # com-bardac-dw
iqobject    48619/tcp           # iqobject
matahari    49000/tcp           # Matahari Broker
不匹配开头是#和空行：

[root@ chenc01 ~]# awk '! /^#/ &amp;&amp; ! /^$/{print $0}' /etc/httpd/conf/httpd.conf
或
[root@ chenc01 ~]# awk '! /^#|^$/' /etc/httpd/conf/httpd.conf  
或
[root@ chenc01 ~]# awk '/^[^#]|&quot;^$&quot;/' /etc/httpd/conf/httpd.conf

9）匹配范围
[root@ chenc01 ~]# tail /etc/services |awk '/^blp5/,/^com/'
blp5      48129/tcp               # Bloomberg locator
blp5      48129/udp               # Bloomberg locator
com-bardac-dw    48556/tcp        # com-bardac-dw
对匹配范围后记录再次处理，例如匹配关键字下一行到最后一行：

[root@ chenc01 ~]# seq 5 |awk '/3/,/^$/{printf /3/?&quot;&quot;:$0&quot;\n&quot;}' 
4
5

另一种判断真假的方式实现：

[root@ chenc01 ~]# seq 5 |awk '/3/{t=1;next}t'
4
5

1和2都不匹配3，不执行后面{}，执行t，t变量还没赋值，为空，空在awk中就为假，就不打印当前行。匹配到3，执行t=1，next跳出，不执行t。4也不匹配3，执行t，t的值上次赋值的1，为真，打印当前行，以此类推。（非0的数字都为真，所以t可以写任意非0数字）

如果想打印匹配行都最后一行，就可以这样了：

[root@ chenc01 ~]# seq 5 |awk '/3/{t=1}t'   
3
4
5
</code></pre>

<h4 id="3-内置变量">3、内置变量</h4>

<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>FS</td>
<td>输入字段分隔符，默认是空格或制表符</td>
</tr>

<tr>
<td>OFS</td>
<td>输出字段分隔符，默认是空格</td>
</tr>

<tr>
<td>RS</td>
<td>输入记录分隔符，默认是换行符\n</td>
</tr>

<tr>
<td>ORS</td>
<td>输出记录分隔符，默认是换行符\n</td>
</tr>

<tr>
<td>NF</td>
<td>统计当前记录中字段个数</td>
</tr>

<tr>
<td>NR</td>
<td>统计记录编号，每处理一行记录，编号就会+1</td>
</tr>

<tr>
<td>FNR</td>
<td>统计记录编号，每处理一行记录，编号也会+1，与NR不同的是，处理第二个文件时，编号会重新计数。</td>
</tr>

<tr>
<td>ARGC</td>
<td>命令行参数数量</td>
</tr>

<tr>
<td>ARGV</td>
<td>命令行参数数组序列数组，下标从0开始，ARGV[0]是awk</td>
</tr>

<tr>
<td>ARGIND</td>
<td>当前正在处理的文件索引值。第一个文件是1，第二个文件是2，以此类推</td>
</tr>

<tr>
<td>ENVIRON</td>
<td>当前系统的环境变量</td>
</tr>

<tr>
<td>FILENAME</td>
<td>输出当前处理的文件名</td>
</tr>

<tr>
<td>IGNORECASE</td>
<td>忽略大小写</td>
</tr>

<tr>
<td>SUBSEP</td>
<td>数组中下标的分隔符，默认为&rdquo;\034&rdquo;</td>
</tr>
</tbody>
</table>

<pre><code>示例：

1）FS和OFS

在程序开始前重新赋值FS变量，改变默认分隔符为冒号，与-F一样。

[root@ chenc01 ~]# awk 'BEGIN{FS=&quot;:&quot;}{print $1,$2}' /etc/passwd |head -n5      
root x
bin x
daemon x
adm x
lp x

也可以使用-v来重新赋值这个变量：

[root@ chenc01 ~]# awk -vFS=':' '{print $1,$2}' /etc/passwd |head -n5    # 中间逗号被换成了OFS的默认值     
root x
bin x
daemon x
adm x
lp x

由于OFS默认以空格分隔，反向引用多个字段分隔的也是空格，如果想指定输出分隔符这样：

[root@ chenc01 ~]# awk 'BEGIN{FS=&quot;:&quot;;OFS=&quot;:&quot;}{print $1,$2}' /etc/passwd |head -n5
root:x
bin:x
daemon:x
adm:x
lp:x

也可以通过字符串拼接实现分隔：

[root@ chenc01 ~]# awk 'BEGIN{FS=&quot;:&quot;}{print $1&quot;#&quot;$2}' /etc/passwd |head -n5
root#x
bin#x
daemon#x
adm#x
lp#x

2）RS和ORS

RS默认是\n分隔每行，如果想指定以某个字符作为分隔符来处理记录：

[root@ chenc01 ~]# echo &quot;www.baidu.com/user/test.html&quot; |awk 'BEGIN{RS=&quot;/&quot;}{print $0}'
www.baidu.com
user
test.html

RS也支持正则，简单演示下：

[root@ chenc01 ~]# seq -f &quot;str%02g&quot; 10 |sed 'n;n;a\-----' |awk 'BEGIN{RS=&quot;-+&quot;}{print $1}'
str01
str04
str07
str10

将输出的换行符替换为+号：
[root@ chenc01 ~]# seq 10 |awk 'BEGIN{ORS=&quot;+&quot;}{print $0}'
1+2+3+4+5+6+7+8+9+10+

替换某个字符：

[root@ chenc01 ~]# tail -n2 /etc/services |awk 'BEGIN{RS=&quot;/&quot;;ORS=&quot;#&quot;}{print $0}'
iqobject    48619#udp        # iqobject
matahari    49000#tcp        # Matahari Broker

3）NF

NF是字段个数。

[root@ chenc01 ~]# echo &quot;a b c d e f&quot; |awk '{print NF}'
6

打印最后一个字段：
[root@ chenc01 ~]# echo &quot;a b c d e f&quot; |awk '{print $NF}'
f

打印倒数第二个字段：
[root@ chenc01 ~]# echo &quot;a b c d e f&quot; |awk '{print $(NF-1)}'
e

排除最后两个字段：
[root@ chenc01 ~]# echo &quot;a b c d e f&quot; |awk '{$NF=&quot;&quot;;$(NF-1)=&quot;&quot;;print $0}'
a b c d

排除第一个字段：
[root@ chenc01 ~]# echo &quot;a b c d e f&quot; |awk '{$1=&quot;&quot;;print $0}'
 b c d e f 

4）NR和FNR

NR统计记录编号，每处理一行记录，编号就会+1，FNR不同的是在统计第二个文件时会重新计数。

打印行数：

[root@ chenc01 ~]# tail -n5 /etc/services |awk '{print NR,$0}'
1 com-bardac-dw   48556/tcp        # com-bardac-dw
2 com-bardac-dw   48556/udp        # com-bardac-dw
3 iqobject     48619/tcp           # iqobject
4 iqobject     48619/udp           # iqobject
5 matahari     49000/tcp           # Matahari Broker
打印总行数：

[root@ chenc01 ~]# tail -n5 /etc/services |awk 'END{print NR}'
5

打印第三行：
[root@ chenc01 ~]# tail -n5 /etc/services |awk 'NR==3'    
iqobject     48619/tcp        # iqobject

打印第三行第二个字段：
[root@ chenc01 ~]# tail -n5 /etc/services |awk 'NR==3{print $2}'
48619/tcp

打印前三行：
[root@ chenc01 ~]# tail -n5 /etc/services |awk 'NR&lt;=3{print NR,$0}'
1 com-bardac-dw  48556/tcp        # com-bardac-dw
2 com-bardac-dw  48556/udp        # com-bardac-dw
3 iqobject    48619/tcp           # iqobject

看下NR和FNR的区别：

[root@ chenc01 ~]# cat a
a
b
c
[root@ chenc01 ~]# cat b
c
d
e

[root@ chenc01 ~]# awk '{print NR,FNR,$0}' a b
1 1 a
2 2 b
3 3 c
4 1 c
5 2 d
6 3 e

可以看出NR每处理一行就会+1，而FNR在处理第二个文件时，编号重新计数。同时也知道awk处理两个文件时，是合并到一起处理。

[root@ chenc01 ~]# awk 'FNR==NR{print $0&quot;1&quot;}FNR!=NR{print $0&quot;2&quot;}' a b 
a1
b1
c1
c2
d2
e2

当FNR==NR时，说明在处理第一个文件内容，不等于时说明在处理第二个文件内容。

一般FNR在处理多个文件时会用到，下面会讲解。

5）ARGC和ARGV
ARGC是命令行参数数量
ARGV是将命令行参数存到数组，元素由ARGC指定，数组下标从0开始

[root@ chenc01 ~]# awk 'BEGIN{print ARGC}' 1 2 3
4

[root@ chenc01 ~]# awk 'BEGIN{print ARGV[0]}'
awk

[root@ chenc01 ~]# awk 'BEGIN{print ARGV[1]}' 1 2
1

[root@ chenc01 ~]# awk 'BEGIN{print ARGV[2]}' 1 2 
2

6）ARGIND

ARGIND是当前正在处理的文件索引值，第一个文件是1，第二个文件是2，以此类推，从而可以通过这种方式判断正在处理哪个文件。

[root@ chenc01 ~]# awk '{print ARGIND,$0}' a b
1 a
1 b
1 c
2 c
2 d
2 e

[root@ chenc01 ~]# awk 'ARGIND==1{print &quot;a-&gt;&quot;$0}ARGIND==2{print &quot;b-&gt;&quot;$0}' a b    
a-&gt;a
a-&gt;b
a-&gt;c
b-&gt;c
b-&gt;d
b-&gt;e

7）ENVIRON

ENVIRON调用系统变量。

[root@ chenc01 ~]# awk 'BEGIN{print ENVIRON[&quot;HOME&quot;]}'
/root

如果是设置的环境变量，还需要用export导入到系统变量才可以调用：

[root@ chenc01 ~]# awk 'BEGIN{print ENVIRON[&quot;a&quot;]}'

[root@ chenc01 ~]# export a

[root@ chenc01 ~]# awk 'BEGIN{print ENVIRON[&quot;a&quot;]}'
123

8）FILENAME

FILENAME是当前处理文件的文件名。

[root@ chenc01 ~]# awk 'FNR==NR{print FILENAME&quot;-&gt;&quot;$0}FNR!=NR{print FILENAME&quot;-&gt;&quot;$0}' a b   
a-&gt;a
a-&gt;b
a-&gt;c
b-&gt;c
b-&gt;d
b-&gt;e

9）忽略大小写
[root@ chenc01 ~]# echo &quot;A a b c&quot; |xargs -n1 |awk 'BEGIN{IGNORECASE=1}/a/'
A
a

等于1代表忽略大小写。
</code></pre>

<h4 id="4-操作符">4、操作符</h4>

<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>（…）</td>
<td>分组</td>
</tr>

<tr>
<td>$</td>
<td>字段引用</td>
</tr>

<tr>
<td>++ –</td>
<td>递增和递减</td>
</tr>

<tr>
<td>+ - !</td>
<td>加号，减号，和逻辑否定</td>
</tr>

<tr>
<td>* / %</td>
<td>乘，除和取余</td>
</tr>

<tr>
<td>+ -</td>
<td>加法，减法</td>
</tr>

<tr>
<td></td>
<td>&amp;</td>
</tr>

<tr>
<td>&lt; &gt; &lt;= &gt;= != ==</td>
<td>关系运算符</td>
</tr>

<tr>
<td>~ !~</td>
<td>正则表达式匹配，否定正则表达式匹配</td>
</tr>

<tr>
<td>in</td>
<td>数组成员</td>
</tr>

<tr>
<td>&amp;&amp;</td>
<td></td>
</tr>

<tr>
<td>?:</td>
<td>简写条件表达式：expr1 ? expr2 : expr3第一个表达式为真，执行expr2，否则执行expr3</td>
</tr>

<tr>
<td>= += -= *= /= %= ^=</td>
<td>变量赋值运算符</td>
</tr>
</tbody>
</table>

<p>须知：*</p>

<p>在awk中，有3种情况表达式为假：数字是0，空字符串和未定义的值。</p>

<p>数值运算，未定义变量初始值为0。字符运算，未定义变量初始值为空。</p>

<pre><code>举例测试：

[root@ chenc01 ~]# awk 'BEGIN{n=0;if(n)print &quot;true&quot;;else print &quot;false&quot;}'
false

[root@ chenc01 ~]# awk 'BEGIN{s=&quot;&quot;;if(s)print &quot;true&quot;;else print &quot;false&quot;}'
false

[root@ chenc01 ~]# awk 'BEGIN{if(s)print &quot;true&quot;;else print &quot;false&quot;}'
false

示例：

1）截取整数

[root@ chenc01 ~]# echo &quot;123abc abc123 123abc123&quot; |xargs -n1 | awk '{print +$0}'
123
0
123

[root@ chenc01 ~]# echo &quot;123abc abc123 123abc123&quot; |xargs -n1 | awk '{print -$0}'
-123
0
-123

2）感叹号

打印奇数行：

[root@ chenc01 ~]# seq 6 |awk 'i=!i'
1
3
5

打印偶数行：

[root@ chenc01 ~]# seq 6 |awk '!(i=!i)'  
2
4
6

读取第一行：i是未定义变量，也就是i=!0，!取反意思。感叹号右边是个布尔值，0或空字符串为假，非0或非空字符串为真，!0就是真，因此i=1，条件为真打印当前记录。
没有print为什么会打印呢？因为模式后面没有动作，默认会打印整条记录。
读取第二行：因为上次i的值由0变成了1，此时就是i=!1，条件为假不打印。
读取第三行：上次条件又为假，i恢复初始值0，取反，继续打印。以此类推...
可以看出，运算时并没有判断行内容，而是利用布尔值真假判断输出当前行。

2）不匹配某行

[root@ chenc01 ~]# tail /etc/services |awk '!/blp5/{print $0}'
3gpp-cbsp    48049/tcp           # 3GPP Cell Broadcast Service isnetserv    48128/tcp        # Image Systems Network Services
isnetserv    48128/udp           # Image Systems Network Services
com-bardac-dw   48556/tcp        # com-bardac-dw
com-bardac-dw   48556/udp        # com-bardac-dw
iqobject    48619/tcp            # iqobject
iqobject    48619/udp            # iqobject
matahari    49000/tcp            # Matahari Broker

3）乘法和除法

[root@ chenc01 ~]# seq 5 |awk '{print $0*2}'
2
4
6
8
10

[root@ chenc01 ~]# seq 5 |awk '{print $0%2}'
1
0
1
0
1

打印偶数行：
[root@ chenc01 ~]# seq 5 |awk '$0%2==0{print $0}'
2
4

打印奇数行：
[root@ chenc01 ~]# seq 5 |awk '$0%2!=0{print $0}'
1
3
5

4）管道符使用

[root@ chenc01 ~]# seq 5 |shuf |awk '{print $0|&quot;sort&quot;}'
1
2
3
4
5

5）正则表达式匹配

[root@ chenc01 ~]# seq 5 |awk '$0~3{print $0}'
3

[root@ chenc01 ~]# seq 5 |awk '$0!~3{print $0}'
1
2
4
5

[root@ chenc01 ~]# seq 5 |awk '$0~/[34]/{print $0}'
3
4

[root@ chenc01 ~]# seq 5 |awk '$0!~/[34]/{print $0}'
1
2
5

[root@ chenc01 ~]# seq 5 |awk '$0~/[^34]/{print $0}'
1
2
5

6）判断数组成员

[root@ chenc01 ~]# awk 'BEGIN{a[&quot;a&quot;]=123}END{if(&quot;a&quot; in a)print &quot;yes&quot;}' 
yes

7）三目运算符

[root@ chenc01 ~]# awk 'BEGIN{print 1==1?&quot;yes&quot;:&quot;no&quot;}'  # 三目运算作为一个表达式，里面不允许写print
yes

[root@ chenc01 ~]# seq 3 |awk '{print $0==2?&quot;yes&quot;:&quot;no&quot;}'
no
yes
no

替换换行符为逗号：

[root@ chenc01 ~]# seq 5 |awk '{print n=(n?n&quot;,&quot;$0:$0)}'
1
1,2
1,2,3
1,2,3,4
1,2,3,4,5

[root@ chenc01 ~]# seq 5 |awk '{n=(n?n&quot;,&quot;$0:$0)}END{print n}'
1,2,3,4,5

说明：读取第一行时，n没有变量，为假输出$0也就是1，并赋值变量n，读取第二行时，n是1为真，输出1,2 以此类推，后面会一直为真。
每三行后面添加新一行：

[root@ chenc01 ~]# seq 10 |awk '{print NR%3?$0:$0 &quot;\ntxt&quot;}'
1
2
3
txt
4
5
6
txt
7
8
9
txt
10
在

两行合并一行：

[root@ chenc01 ~]# seq 6 |awk '{printf NR%2!=0?$0&quot; &quot;:$0&quot; \n&quot;}'  
1 2 
3 4 
5 6 

[root@ chenc01 ~]# seq 6 |awk 'ORS=NR%2?&quot; &quot;:&quot;\n&quot;' 
1 2
3 4
5 6

[root@ chenc01 ~]# seq 6 |awk '{if(NR%2)ORS=&quot; &quot;;else ORS=&quot;\n&quot;;print}'

8）变量赋值

字段求和：
[root@ chenc01 ~]# seq 5 |awk '{sum+=1}END{print sum}'
5

[root@ chenc01 ~]# seq 5 |awk '{sum+=$0}END{print sum}'
15
</code></pre>

<h4 id="5-流程控制">5、流程控制</h4>

<pre><code>1）if语句

格式：if (condition) statement [ else statement ]
单分支：

[root@ chenc01 ~]# seq 5 |awk '{if($0==3)print $0}'  
3

也支持正则匹配判断，一般在写复杂语句时使用：

[root@ chenc01 ~]# echo &quot;123abc#456cde 789aaa#aaabbb &quot; |xargs -n1 |awk -F# '{if($2~/[0-9]/)print $2}'  
456cde
[root@ chenc01 ~]# echo &quot;123abc#456cde 789aaa#aaabbb &quot; |xargs -n1 |awk -F# '{if($2!~/[0-9]/)print $2}'
aaabbb
或
[root@ chenc01 ~]# echo &quot;123abc#456cde 789aaa#aaabbb&quot; |xargs -n1 |awk -F# '$2!~/[0-9]/{print $2}'   
aaabbb

双分支：

[root@ chenc01 ~]# seq 5 |awk '{if($0==3)print $0;else print &quot;no&quot;}'
no
no
3
no
no

多分支：
[root@ chenc01 ~]# cat file
1 2 3
4 5 6
7 8 9
[root@ chenc01 ~]# awk '{if($1==4){print &quot;1&quot;} else if($2==5){print &quot;2&quot;} else if($3==6){print &quot;3&quot;} else {print &quot;no&quot;}}' file      
no
1
no

2）while语句

格式：while (condition) statement
遍历打印所有字段：

[root@ chenc01 ~]# awk '{i=1;while(i&lt;=NF){print $i;i++}}' file
1
2
3
4
5
6
7
8
9

awk是按行处理的，每次读取一行，并遍历打印每个字段。

3）for语句C语言风格

格式：for (expr1; expr2; expr3) statement
遍历打印所有字段：

[root@ chenc01 ~]# cat file
1 2 3
4 5 6
7 8 9

[root@ chenc01 ~]# awk '{for(i=1;i&lt;=NF;i++)print $i}' file
1
2
3
4
5
6
7
8
9

倒叙打印文本：

[root@ chenc01 ~]# awk '{for(i=NF;i&gt;=1;i--)print $i}' file    
3
2
1
6
5
4
9
8
7

都换行了，这并不是我们要的结果。怎么改进呢？

[root@ chenc01 ~]# awk '{for(i=NF;i&gt;=1;i--){printf $i&quot; &quot;};print &quot;&quot;}' file  # print本身就会新打印一行
3 2 1
6 5 4
9 8 7
或
[root@ chenc01 ~]# awk '{for(i=NF;i&gt;=1;i--)if(i==1)printf $i&quot;\n&quot;;else printf $i&quot; &quot;}' file
3 2 1
6 5 4
9 8 7

在这种情况下，是不是就排除第一行和倒数第一行呢？我们正序打印看下
排除第一行：

[root@ chenc01 ~]# awk '{for(i=2;i&lt;=NF;i++){printf $i&quot; &quot;};print &quot;&quot;}' file
2 3
5 6
8 9

排除第二行：

[root@ chenc01 ~]# awk '{for(i=1;i&lt;=NF-1;i++){printf $i&quot; &quot;};print &quot;&quot;}' file
1 2
4 5
7 8

IP加单引号：

[root@ chenc01 ~]# echo '10.10.10.1 10.10.10.2 10.10.10.3' |awk '{for(i=1;i&lt;=NF;i++)printf &quot;\047&quot;$i&quot;\047&quot;}
'10.10.10.1'  '10.10.10.2'  '10.10.10.3'

\047是ASCII码，可以通过showkey -a命令查看。

4）for语句遍历数组

格式：for (var in array) statement

[root@ chenc01 ~]# seq -f &quot;str%.g&quot; 5 |awk '{a[NR]=$0}END{for(v in a)print v,a[v]}'
4 str4
5 str5
1 str1
2 str2
3 str3

5）break和continue语句

break跳过所有循环，continue跳过当前循环。

[root@ chenc01 ~]# awk 'BEGIN{for(i=1;i&lt;=5;i++){if(i==3){break};print i}}'
1
2

[root@ chenc01 ~]# awk 'BEGIN{for(i=1;i&lt;=5;i++){if(i==3){continue};print i}}'
1
2
4
5

6）删除数组和元素

格式：
delete array[index]  删除数组元素
delete array  删除数组

[root@ chenc01 ~]# seq -f &quot;str%.g&quot; 5 |awk '{a[NR]=$0}END{delete a;for(v in a)print v,a[v]}'
空的…  

[root@ chenc01 ~]# seq -f &quot;str%.g&quot; 5 |awk '{a[NR]=$0}END{delete a[3];for(v in a)print v,a[v]}'
4 str4
5 str5
1 str1
2 str2

7）exit语句

格式：exit [ expression ]
exit退出程序，与shell的exit一样。[ expr ]是0-255之间的数字。

[root@ chenc01 ~]# seq 5 |awk '{if($0~/3/)exit (123)}'     
[root@ chenc01 ~]# echo $?
123
</code></pre>

<h4 id="6-数组">6、数组</h4>

<pre><code>数组：存储一系列相同类型的元素，键/值方式存储，通过下标（键）来访问值。
awk中数组称为关联数组，不仅可以使用数字作为下标，还可以使用字符串作为下标。
数组元素的键和值存储在awk程序内部的一个表中，该表采用散列算法，因此数组元素是随机排序。
数组格式：array[index]=value

1）自定义数组

[root@ chenc01 ~]# awk 'BEGIN{a[0]=&quot;test&quot;;print a[0]}'
test

2）通过NR设置记录下标，下标从1开始
[root@ chenc01 ~]# tail -n3 /etc/passwd |awk -F: '{a[NR]=$1}END{print a[1]}'
systemd-network

[root@ chenc01 ~]# tail -n3 /etc/passwd |awk -F: '{a[NR]=$1}END{print a[2]}'
zabbix

[root@ chenc01 ~]# tail -n3 /etc/passwd |awk -F: '{a[NR]=$1}END{print a[3]}'
user

3）通过for循环遍历数组

[root@ chenc01 ~]# tail -n5 /etc/passwd |awk -F: '{a[NR]=$1}END{for(v in a)print a[v],v}'
zabbix 4
user 5
admin 1
systemd-bus-proxy 2
systemd-network 3

[root@ chenc01 ~]# tail -n5 /etc/passwd |awk -F: '{a[NR]=$1}END{for(i=1;i&lt;=NR;i++)print a[i],i}'
admin 1
systemd-bus-proxy 2
systemd-network 3
zabbix 4
user 5

上面打印的i是数组的下标。
第一种for循环的结果是乱序的，刚说过，数组是无序存储。
第二种for循环通过下标获取的情况是排序正常。
所以当下标是数字序列时，还是用for(expr1;expr2;expr3)循环表达式比较好，保持顺序不变。

4）通过++方式作为下标

[root@ chenc01 ~]# tail -n5 /etc/passwd |awk -F: '{a[x++]=$1}END{for(i=0;i&lt;=x-1;i++)print a[i],i}'
admin 0
systemd-bus-proxy 1
systemd-network 2
zabbix 3
user 4

x被awk初始化值是0，没循环一次+1

5）使用字段作为下标

[root@ chenc01 ~]# tail -n5 /etc/passwd |awk -F: '{a[$1]=$7}END{for(v in a)print a[v],v}'
/sbin/nologin admin
/bin/bash user
/sbin/nologin systemd-network
/sbin/nologin systemd-bus-proxy
/sbin/nologin zabbix

6）统计相同字段出现次数

[root@ chenc01 ~]# tail /etc/services |awk '{a[$1]++}END{for(v in a)print a[v],v}'
2 com-bardac-dw
1 3gpp-cbsp
2 iqobject
1 matahari
2 isnetserv
2 blp5

[root@ chenc01 ~]# tail /etc/services |awk '{a[$1]+=1}END{for(v in a)print a[v],v}' 
2 com-bardac-dw
1 3gpp-cbsp
2 iqobject
1 matahari
2 isnetserv
2 blp5

[root@ chenc01 ~]# tail /etc/services |awk '/blp5/{a[$1]++}END{for(v in a)print a[v],v}'
2 blp5

第一个字段作为下标，值被++初始化是0，每次遇到下标（第一个字段）一样时，对应的值就会被+1，因此实现了统计出现次数。
想要实现去重的的话就简单了，只要打印下标即可。

7）统计TCP连接状态

[root@ chenc01 ~]# netstat -antp |awk '/^tcp/{a[$6]++}END{for(v in a)print a[v],v}'
9 LISTEN
6 ESTABLISHED
6 TIME_WAIT

8）只打印出现次数大于等于2的

[root@ chenc01 ~]# tail /etc/services |awk '{a[$1]++}END{for(v in a) if(a[v]&gt;=2){print a[v],v}}'
2 com-bardac-dw
2 iqobject
2 isnetserv
2 blp5

9）去重

只打印重复的行：
[root@ chenc01 ~]# tail /etc/services |awk 'a[$1]++'
isnetserv    48128/udp           # Image Systems Network Services
blp5      48129/udp              # Bloomberg locator
com-bardac-dw   48556/udp        # com-bardac-dw
iqobject    48619/udp            # iqobject

不打印重复的行：
[root@ chenc01 ~]# tail /etc/services |awk '!a[$1]++'
3gpp-cbsp    48049/tcp           # 3GPP Cell Broadcast Service 
isnetserv    48128/tcp           # Image Systems Network Services
blp5      48129/tcp              # Bloomberg locator
com-bardac-dw   48556/tcp        # com-bardac-dw
iqobject    48619/tcp            # iqobject
matahari    49000/tcp            # Matahari Broker

先明白一个情况，当值是0是为假，非0整数为真，知道这点就不难理解了。
只打印重复的行说明：当处理第一条记录时，执行了++，初始值是0为假，就不打印，如果再遇到相同的记录，值就会+1，不为0，则打印。
不打印重复的行说明：当处理第一条记录时，执行了++，初始值是0为假，感叹号取反为真，打印，如果再遇到相同的记录，值就会+1，不为0为真，取反为假就不打印。

[root@ chenc01 ~]# tail /etc/services |awk '{if(a[$1]++)print $1}'    
isnetserv
blp5
com-bardac-dw
iqobject
使用三目运算：

[root@ chenc01 ~]# tail /etc/services |awk '{print a[$1]++?$1:&quot;no&quot;}'  
no
no
isnetserv
no
blp5
no
com-bardac-dw
no
iqobject
no

[root@ chenc01 ~]# tail /etc/services |awk '{if(!a[$1]++)print $1}'
3gpp-cbsp
isnetserv
blp5
com-bardac-dw
iqobject
matahari

10）统计每个相同字段的某字段总数：

[root@ chenc01 ~]# tail /etc/services |awk -F'[ /]+' '{a[$1]+=$2}END{for(v in a)print v, a[v]}'
com-bardac-dw 97112
3gpp-cbsp 48049
iqobject 97238
matahari 49000
isnetserv 96256
blp5 96258

11）多维数组

awk的多维数组，实际上awk并不支持多维数组，而是逻辑上模拟二维数组的访问方式，比如a[a,b]=1，使用SUBSEP（默认\034）作为分隔下标字段，存储后是这样a\034b。

示例：

[root@ chenc01 ~]# awk 'BEGIN{a[&quot;x&quot;,&quot;y&quot;]=123;for(v in a) print v,a[v]}'
xy 123

我们可以重新复制SUBSEP变量，改变下标默认分隔符：

[root@ chenc01 ~]# awk 'BEGIN{SUBSEP=&quot;:&quot;;a[&quot;x&quot;,&quot;y&quot;]=123;for(v in a) print v,a[v]}'
x:y 123

根据指定的字段统计出现次数：

[root@ chenc01 ~]# cat file
A 192.168.1.1 HTTP
B 192.168.1.2 HTTP
B 192.168.1.2 MYSQL
C 192.168.1.1 MYSQL
C 192.168.1.1 MQ
D 192.168.1.4 NGINX

[root@ chenc01 ~]# awk 'BEGIN{SUBSEP=&quot;-&quot;}{a[$1,$2]++}END{for(v in a)print a[v],v}' file
1 D-192.168.1.4
1 A-192.168.1.1
2 C-192.168.1.1
2 B-192.168.1.2
</code></pre>

<h4 id="7-内置函数">7、内置函数</h4>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>int(expr)</td>
<td>截断为整数</td>
</tr>

<tr>
<td>sqrt(expr)</td>
<td>平方根</td>
</tr>

<tr>
<td>rand()</td>
<td>返回一个随机数N，0和1范围，0 &lt; N &lt; 1</td>
</tr>

<tr>
<td>srand([expr])</td>
<td>使用expr生成随机数，如果不指定，默认使用当前时间为种子，如果前面有种子则使用生成随机数</td>
</tr>

<tr>
<td>asort(a, b)</td>
<td>对数组a的值进行排序，把排序后的值存到新的数组b中，新排序的数组下标从1开始</td>
</tr>

<tr>
<td>asorti(a,b)</td>
<td>对数组a的下标进行排序，同上</td>
</tr>

<tr>
<td>sub(r, s [, t])</td>
<td>对输入的记录用s替换r正则匹配，t可选针对某字段替换，但只替换第一个字符串</td>
</tr>

<tr>
<td>gsub(r, s [, t])</td>
<td>对输入的记录用s替换r正则匹配，t可选针对某字段替换，否则替换所有字符串</td>
</tr>

<tr>
<td>gensub(r, s, h [, t])</td>
<td>对输入的记录用s替换r正则匹配，h替换指定索引位置</td>
</tr>

<tr>
<td>index(s, t)</td>
<td>返回s中字符串t的索引位置，0为不存在</td>
</tr>

<tr>
<td>length([s])</td>
<td>返回s的长度</td>
</tr>

<tr>
<td>match(s, r [, a])</td>
<td>测试字符串s是否包含匹配r的字符串，如果不包含返回0</td>
</tr>

<tr>
<td>split(s, a [, r [, seps] ])</td>
<td>根据分隔符seps将s分成数组a</td>
</tr>

<tr>
<td>substr(s, i [, n])</td>
<td>截取字符串s从i开始到长度n，如果n没指定则是剩余部分</td>
</tr>

<tr>
<td>tolower(str)</td>
<td>str中的所有大写转换成小写</td>
</tr>

<tr>
<td>toupper(str)</td>
<td>str中的所有小写转换成大写</td>
</tr>

<tr>
<td>systime()</td>
<td>当前时间戳</td>
</tr>

<tr>
<td>strftime([format [, timestamp[, utc-flag]]])</td>
<td>格式化输出时间，将时间戳转为字符串</td>
</tr>
</tbody>
</table>

<pre><code>示例：

1）int()

截断为整数：
[root@ chenc01 ~]# echo -e &quot;123abc\nabc123\n123abc123&quot; | awk '{print int($0)}'
123
0
123

[root@ chenc01 ~]# awk 'BEGIN{print int(10/3)}'
3

2）sqrt()

获取9的平方根：
[root@ chenc01 ~]# awk 'BEGIN{print sqrt(9)}'
3

3）rand()和srand()

rand()并不是每次运行就是一个随机数，会一直保持一个不变：
[root@ chenc01 ~]# awk 'BEGIN{print rand()}'
0.237788

当执行srand()函数后，rand()才会发生变化，所以一般在awk着两个函数结合生成随机数，但是也有很大几率生成一样：

[root@ chenc01 ~]# awk 'BEGIN{srand();print rand()}'
0.31687

如果想生成1-10的随机数可以这样：

[root@ chenc01 ~]# awk 'BEGIN{srand();print int(rand()*10)}'
4

如果想更完美生成随机数，还得做相应的处理！

4）asort()和asorti()

排序数组：
[root@ chenc01 ~]# seq -f &quot;str%.g&quot; 5 |awk '{a[x++]=$0}END{s=asort(a,b);for(i=1;i&lt;=s;i++)print b[i],i}'       
str1 1
str2 2
str3 3
str4 4
str5 5

[root@ chenc01 ~]# seq -f &quot;str%.g&quot; 5 |awk '{a[x++]=$0}END{s=asorti(a,b);for(i=1;i&lt;=s;i++)print b[i],i}' 
0 1
1 2
2 3
3 4
4 5

asort将a数组的值放到数组b，a下标丢弃，并将数组b的总行号赋值给s，新数组b下标从1开始，然后遍历。

5）sub()和gsub()

替换正则匹配的字符串：

[root@ chenc01 ~]# tail /etc/services |awk '/blp5/{sub(/tcp/,&quot;icmp&quot;);print $0}'
blp5      48129/icmp        # Bloomberg locator
blp5      48129/udp         # Bloomberg locator

[root@ chenc01 ~]# tail /etc/services |awk '/blp5/{gsub(/c/,&quot;9&quot;);print $0}'
blp5      48129/t9p         # Bloomberg lo9ator
blp5      48129/udp         # Bloomberg lo9ator

[root@ chenc01 ~]# echo &quot;1 2 2 3 4 5&quot; |awk 'gsub(2,7,$2){print $0}'
1 7 2 3 4 5

[root@ chenc01 ~]# echo &quot;1 2 3 a b c&quot; |awk 'gsub(/[0-9]/, '0'){print $0}'  
0 0 0 a b c

在指定行前后加一行：

[root@ chenc01 ~]# seq 5 | awk 'NR==2{sub('/.*/',&quot;txt\n&amp;&quot;)}{print}'
1
txt
2
3
4
5

[root@ chenc01 ~]# seq 5 | awk 'NR==2{sub('/.*/',&quot;&amp;\ntxt&quot;)}{print}'
1
2
txt
3
4
5

6）index()

获取字段索引起始位置：
[root@ chenc01 ~]# tail -n 5 /etc/services |awk '{print index($2,&quot;tcp&quot;)}'
7
0
7
0
7

7）length()

统计字段长度：
[root@ chenc01 ~]# tail -n 5 /etc/services |awk '{print length($2)}'
9
9
9
9
9

统计数组的长度：
[root@ chenc01 ~]# tail -n 5 /etc/services |awk '{a[$1]=$2}END{print length(a)}'
3

8）match

[root@ chenc01 ~]# echo &quot;123abc#456cde 789aaa#234bbb 999aaa#aaabbb&quot; |xargs  -n1 |awk '{print match($0,234)}'     
0
8
0

如果记录匹配字符串234，则返回索引位置，否则返回0。
那么，我们只想打印包含这个字符串的记录就可以这样：

[root@ chenc01 ~]# echo &quot;123abc#456cde 789aaa#234bbb 999aaa#aaabbb&quot; |xargs  -n1 |awk '{if(match($0,234)!=0)print $0}' 
789aaa#234bbb    

9）split()

切分记录为数组a：
[root@ chenc01 ~]# echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk '{split($0,a);for(v in a)print a[v],v}'
123#456#789 1
abc#cde#fgh 1
以#号切分记录为数据a：

[root@ chenc01 ~]# echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk '{split($0,a,&quot;#&quot;);for(v in a)print a[v],v}'
123 1
456 2
789 3
abc 1
cde 2
fgh 3

10）substr()

截取字符串索引4到最后：
[root@ chenc01 ~]# echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk '{print substr($0,4)}'           
#456#789
#cde#fgh

截取字符串索引4到长度5：
[root@ chenc01 ~]# echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk '{print substr($0,4,5)}'
#456#
#cde#

11）tolower()和toupper()

转换小写：
[root@ chenc01 ~]# echo -e &quot;123#456#789\nABC#cde#fgh&quot; |awk '{print tolower($0)}'
123#456#789
abc#cde#fgh

转换大写：
[root@ chenc01 ~]# echo -e &quot;123#456#789\nabc#cde#fgh&quot; |awk '{print toupper($0)}'
123#456#789
ABC#CDE#FGH

12)时间处理

返回当前时间戳：
[root@ chenc01 ~]# awk 'BEGIN{print systime()}'
1483297766

将时间戳转为日期和时间
[root@ chenc01 ~]# echo &quot;1483297766&quot; |awk '{print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,$0)}'      
2017-01-01 14:09:26
</code></pre>

<h4 id="8-i-o语句">8、I/O语句</h4>

<table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>getline</td>
<td>读取下一个输入记录设置给$0</td>
</tr>

<tr>
<td>getline var</td>
<td>读取下一个输入记录并赋值给变量var</td>
</tr>

<tr>
<td>command</td>
<td>getline [var]</td>
</tr>

<tr>
<td>next</td>
<td>停止当前处理的输入记录后面动作</td>
</tr>

<tr>
<td>print</td>
<td>打印当前记录</td>
</tr>

<tr>
<td>printf fmt, expr-list</td>
<td>格式化输出</td>
</tr>

<tr>
<td>printf fmt, expr-list &gt;file</td>
<td>格式输出和写到文件</td>
</tr>

<tr>
<td>system(cmd-line)</td>
<td>执行命令和返回状态</td>
</tr>

<tr>
<td>print … &gt;&gt; file</td>
<td>追加输出到文件</td>
</tr>

<tr>
<td>print …</td>
<td>command</td>
</tr>
</tbody>
</table>

<pre><code>示例：

1）getline

获取匹配的下一行：
[root@ chenc01 ~]# seq 5 |awk '/3/{getline;print}'
4

[root@ chenc01 ~]# seq 5 |awk '/3/{print;getline;print}'
3
4

在匹配的下一行加个星号：
[root@ chenc01 ~]# seq 5 |awk '/3/{getline;sub(&quot;.*&quot;,&quot;&amp;*&quot;);print}'
4*

[root@ chenc01 ~]# seq 5 |awk '/3/{print;getline;sub(&quot;.*&quot;,&quot;&amp;*&quot;)}{print}'
1
2
3
4*
5

2）getline var

把a文件的行追加到b文件的行尾：
[root@ chenc01 ~]# cat a
a
b
c

[root@ chenc01 ~]# cat b
1 one
2 two
3 three

[root@ chenc01 ~]# awk '{getline line
1 one a
2 two b
3 three c

把a文件的行替换b文件的指定字段：

[root@ chenc01 ~]# awk '{getline line
1 a
2 b
3 c

把a文件的行替换b文件的对应字段：

[root@ chenc01 ~]# awk '{getline line
1 one
2 b
3 three

3）command | getline [var]

获取执行shell命令后结果的第一行：
[root@ chenc01 ~]# awk 'BEGIN{&quot;seq 5&quot;|getline var;print var}'
1

循环输出执行shell命令后的结果：
[root@ chenc01 ~]# awk 'BEGIN{while(&quot;seq 5&quot;|getline)print}'
1
2
3
4
5

4）next

不打印匹配行：
[root@ chenc01 ~]# seq 5 |awk '{if($0==3){next}else{print}}'
1
2
4
5

删除指定行：
[root@ chenc01 ~]# seq 5 |awk 'NR==1{next}{print $0}'
2
3
4
5

如果前面动作成功，就遇到next，后面的动作不再执行，跳过。
或者：
[root@ chenc01 ~]# seq 5 |awk 'NR!=1{print}' 
2
3
4
5

把第一行内容放到每行的前面：
[root@ chenc01 ~]# cat a
hello 
1 a
2 b
3 c

[root@ chenc01 ~]# awk 'NR==1{s=$0;next}{print s,$0}' a  
hello  1 a
hello  2 b
hello  3 c

[root@ chenc01 ~]# awk 'NR==1{s=$0}NF!=1{print s,$0}' a   
hello  1 a
hello  2 b
hello  3 c

5）system()

执行shell命令判断返回值：
[root@ chenc01 ~]# awk 'BEGIN{if(system(&quot;grep root /etc/passwd &amp;&gt;/dev/null&quot;)==0)print &quot;yes&quot;;else print &quot;no&quot;}'
yes

6）打印结果写到文件

[root@ chenc01 ~]# tail -n5 /etc/services |awk '{print $2 &gt; &quot;a.txt&quot;}'
[root@ chenc01 ~]# cat a.txt
48049/tcp
48128/tcp
48128/udp
48129/tcp
48129/udp

7）管道连接shell命令

将结果通过grep命令过滤：
[root@ chenc01 ~]# tail -n5 /etc/services |awk '{print $2|&quot;grep tcp&quot;}'
48556/tcp
48619/tcp
49000/tcp
</code></pre>

<h4 id="9-printf语句">9、printf语句</h4>

<p>格式化输出，默认打印字符串不换行。</p>

<p>格式：printf [format] arguments</p>

<table>
<thead>
<tr>
<th>Format</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>%s</td>
<td>一个字符串</td>
</tr>

<tr>
<td>%d，%i</td>
<td>一个小数</td>
</tr>

<tr>
<td>%f</td>
<td>一个浮点数</td>
</tr>

<tr>
<td>%.ns</td>
<td>输出字符串，n是输出几个字符</td>
</tr>

<tr>
<td>%m.nf</td>
<td>输出浮点数，m是输出整数位数，n是输出的小数位数</td>
</tr>

<tr>
<td>%x</td>
<td>不带正负号的十六进制，使用a至f表示10到15</td>
</tr>

<tr>
<td>%X</td>
<td>不带正负号的十六进制，使用A至F表示10至15</td>
</tr>

<tr>
<td>%%</td>
<td>输出单个%</td>
</tr>

<tr>
<td>%-5s</td>
<td>左对齐，对参数每个字段左对齐,宽度为5</td>
</tr>

<tr>
<td>%-4.2f</td>
<td>左对齐，宽度为4，保留两位小数</td>
</tr>

<tr>
<td>%5s</td>
<td>右对齐，不加横线表示右对齐</td>
</tr>
</tbody>
</table>

<pre><code>示例：

将换行符换成逗号：
[root@ chenc01 ~]# seq 5 |awk '{if($0!=5)printf &quot;%s,&quot;,$0;else print $0}' 
1,2,3,4,5

小括号中的5是最后一个数字。
输出一个字符：
[root@ chenc01 ~]# awk 'BEGIN{printf &quot;%.1s\n&quot;,&quot;abc&quot;}'    
a

保留一个小数点：
[root@ chenc01 ~]# awk 'BEGIN{printf &quot;%.2f\n&quot;,10/3}'
3.33

格式化输出：
[root@ chenc01 ~]# awk 'BEGIN{printf &quot;user:%s\tpass:%d\n&quot;,&quot;abc&quot;,123}'
user:abc    pass:123

左对齐宽度10：
[root@ chenc01 ~]# awk 'BEGIN{printf &quot;%-10s %-10s %-10s\n&quot;,&quot;ID&quot;,&quot;Name&quot;,&quot;Passwd&quot;}'
ID     Name    Passwd

右对齐宽度10：
[root@ chenc01 ~]# awk 'BEGIN{printf &quot;%10s %10s %10s\n&quot;,&quot;ID&quot;,&quot;Name&quot;,&quot;Passwd&quot;}'  
     ID    Name   Passwd

打印表格：
[root@ chenc01 ~]# vi test.awk
BEGIN{
print &quot;+--------------------+--------------------+&quot;;
printf &quot;|%-20s|%-20s|\n&quot;,&quot;Name&quot;,&quot;Number&quot;;
print &quot;+--------------------+--------------------+&quot;;
}

[root@ chenc01 ~]# awk -f test.awk
+--------------------+--------------------+
|Name         |Number        |
+--------------------+--------------------+
格式化输出：
[root@ chenc01 ~]# awk -F: 'BEGIN{printf &quot;UserName\t\tShell\n-----------------------------\n&quot;}{printf &quot;%-20s %-20s\n&quot;,$1,$7}END{print &quot;END...\n&quot;}' /etc/passwd

打印十六进制：
[root@ chenc01 ~]# awk 'BEGIN{printf &quot;%x %X&quot;,123,123}'
7b 7B
</code></pre>

<h4 id="10-自定义函数">10、自定义函数</h4>

<pre><code>格式：function name(parameter list) { statements }

示例：
[root@ chenc01 ~]# awk 'function myfunc(a,b){return a+b}BEGIN{print myfunc(1,2)}'   
3
</code></pre>

<h4 id="11-需求案例">11、需求案例</h4>

<pre><code>1）分析Nginx日志

日志格式：'$remote_addr - $remote_user [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'

统计访问IP次数：
[root@ chenc01 ~]# awk '{a[$1]++}END{for(v in a)print v,a[v]}' access.log

统计访问访问大于100次的IP：
[root@ chenc01 ~]# awk '{a[$1]++}END{for(v in a){if(a[v]&gt;100)print v,a[v]}}' access.log 

统计访问IP次数并排序取前10：
[root@ chenc01 ~]# awk '{a[$1]++}END{for(v in a)print v,a[v] |&quot;sort -k2 -nr |head -10&quot;}' access.log

统计时间段访问最多的IP：
[root@ chenc01 ~]# awk '$4&gt;=&quot;[02/Jan/2017:00:02:00&quot; &amp;&amp; $4&lt;=&quot;[02/Jan/2017:00:03:00&quot;{a[$1]++}END{for(v in a)print v,a[v]}' access.log

统计上一分钟访问量：
[root@ chenc01 ~]# date=$(date -d '-1 minute' +%d/%d/%Y:%H:%M)
[root@ chenc01 ~]# awk -vdate=$date '$4~date{c++}END{print c}' access.log

统计访问最多的10个页面：
[root@ chenc01 ~]# awk '{a[$7]++}END{for(v in a)print v,a[v] |&quot;sort -k1 -nr|head -n10&quot;}' access.log

统计每个URL数量和返回内容总大小：
[root@ chenc01 ~]# awk '{a[$7]++;size[$7]+=$10}END{for(v in a)print a[v],v,size[v]}' access.log

统计每个IP访问状态码数量：
[root@ chenc01 ~]# awk '{a[$1&quot; &quot;$9]++}END{for(v in a)print v,a[v]}' access.log

统计访问IP是404状态次数：
[root@ chenc01 ~]# awk '{if($9~/404/)a[$1&quot; &quot;$9]++}END{for(i in a)print v,a[v]}' access.log

2）两个文件对比

找出b文件在a文件相同记录：
[root@ chenc01 ~]# seq 1 5 &gt; a
[root@ chenc01 ~]# seq 3 7 &gt; b
方法1：
[root@ chenc01 ~]# awk 'FNR==NR{a[$0];next}{if($0 in a)print $0}' a b 
3
4
5

[root@ chenc01 ~]# awk 'FNR==NR{a[$0];next}{if($0 in a)print FILENAME,$0}' a b
b 3
b 4
b 5

[root@ chenc01 ~]# awk 'FNR==NR{a[$0]}NR&gt;FNR{if($0 in a)print $0}' a b  
3
4
5

[root@ chenc01 ~]# awk 'FNR==NR{a[$0]=1;next}(a[$0]==1)' a b  # a[$0]是通过b文件每行获取值，如果是1说明有
[root@ chenc01 ~]# awk 'FNR==NR{a[$0]=1;next}{if(a[$0]==1)print}' a b
3
4
5

方法2：
[root@ chenc01 ~]# awk 'FILENAME==&quot;a&quot;{a[$0]}FILENAME==&quot;b&quot;{if($0 in a)print $0}' a b
3
4
5

方法3：
[root@ chenc01 ~]# awk 'ARGIND==1{a[$0]=1}ARGIND==2 &amp;&amp; a[$0]==1' a b   
3
4
5

找出b文件在a文件不同记录：

方法1：
[root@ chenc01 ~]# awk 'FNR==NR{a[$0];next}!($0 in a)' a b       
6
7

[root@ chenc01 ~]# awk 'FNR==NR{a[$0]=1;next}(a[$0]!=1)' a b
[root@ chenc01 ~]# awk 'FNR==NR{a[$0]=1;next}{if(a[$0]!=1)print}' a b
6
7

方法2：
[root@ chenc01 ~]# awk 'FILENAME==&quot;a&quot;{a[$0]=1}FILENAME==&quot;b&quot; &amp;&amp; a[$0]!=1' a b

方法3：
[root@ chenc01 ~]# awk 'ARGIND==1{a[$0]=1}ARGIND==2 &amp;&amp; a[$0]!=1' a b 

3）合并两个文件

将a文件合并到b文件：
[root@ chenc01 ~]# cat a
zhangsan 20
lisi 23
wangwu 29

[root@ chenc01 ~]# cat b
zhangsan man
lisi woman
wangwu man

[root@ chenc01 ~]# awk 'FNR==NR{a[$1]=$0;next}{print a[$1],$2}' a b
zhangsan 20 man
lisi 23 woman
wangwu 29 man

[root@ chenc01 ~]# awk 'FNR==NR{a[$1]=$0}NR&gt;FNR{print a[$1],$2}' a b     
zhangsan 20 man
lisi 23 woman
wangwu 29 man

将a文件相同IP的服务名合并：

[root@ chenc01 ~]# cat a
192.168.1.1: httpd
192.168.1.1: tomcat
192.168.1.2: httpd
192.168.1.2: postfix
192.168.1.3: mysqld
192.168.1.4: httpd

[root@ chenc01 ~]# awk 'BEGIN{FS=&quot;:&quot;;OFS=&quot;:&quot;}{a[$1]=a[$1] $2}END{for(v in a)print v,a[v]}' a  
192.168.1.4: httpd
192.168.1.1: httpd tomcat
192.168.1.2: httpd postfix
192.168.1.3: mysqld

说明：数组a存储是$1=a[$1] $2，第一个a[$1]是以第一个字段为下标，值是a[$1] $2，也就是$1=a[$1] $2，值的a[$1]是用第一个字段为下标获取对应的值，但第一次数组a还没有元素，那么a[$1]是空值，此时数组存储是192.168.1.1=httpd，再遇到192.168.1.1时，a[$1]通过第一字段下标获得上次数组的httpd，把当前处理的行第二个字段放到上一次同下标的值后面，作为下标192.168.1.1的新值。此时数组存储是192.168.1.1=httpd tomcat。每次遇到相同的下标（第一个字段）就会获取上次这个下标对应的值与当前字段并作为此下标的新值。

4）将第一列合并到一行
[root@ chenc01 ~]# cat file
1 2 3
4 5 6
7 8 9

[root@ chenc01 ~]# awk '{for(i=1;i&lt;=NF;i++)a[i]=a[i]$i&quot; &quot;}END{for(v in a)print a[v]}' file   
1 4 7
2 5 8
3 6 9

说明：
for循环是遍历每行的字段，NF等于3，循环3次。

读取第一行时：
第一个字段：a[1]=a[1]1&quot; &quot;  值a[1]还未定义数组，下标也获取不到对应的值，所以为空，因此a[1]=1 。
第二个字段：a[2]=a[2]2&quot; &quot;  值a[2]数组a已经定义，但没有2这个下标，也获取不到对应的值，为空，因此a[2]=2 。
第三个字段：a[3]=a[3]3&quot; &quot;  值a[2]与上面一样，为空,a[3]=3 。

读取第二行时：
第一个字段：a[1]=a[1]4&quot; &quot;  值a[2]获取数组a的2为下标对应的值，上面已经有这个下标了，对应的值是1，因此a[1]=1 4
第二个字段：a[2]=a[2]5&quot; &quot;  同上，a[2]=2 5
第三个字段：a[3]=a[3]6&quot; &quot;  同上，a[2]=3 6

读取第三行时：
处理方式同上，数组最后还是三个下标，分别是1=1 4 7，2=2 5 8，3=3 6 9。最后for循环输出所有下标值。

5）字符串拆分，统计出现的次数

字符串拆分：
方法1：
[root@ chenc01 ~]# echo &quot;hello world&quot; |awk -F '' '{print $1}'
h

[root@ chenc01 ~]# echo &quot;hello&quot; |awk -F '' '{for(i=1;i&lt;=NF;i++)print $i}'   
h
e
l
l
o

方法2：
[root@ chenc01 ~]# echo &quot;hello&quot; |awk '{split($0,a,&quot;''&quot;);for(v in a)print a[v]}'
l
o
h
e
l

统计字符串中每个字母出现的次数：

[root@ chenc01 ~]# echo &quot;a.b.c,c.d.e&quot; |awk -F '[.,]' '{for(i=1;i&lt;=NF;i++)a[$i]++}END{for(v in a)print v,a[v]}'
a 1
b 1
c 2
d 1
e 1

6）统计平均成绩

[root@ chenc01 ~]# cat file
job 80
dave 84
tom 75
dave 73
job 72
tom 83
dave 88

[root@ chenc01 ~]# awk '{a[$1]+=$2;b[$1]++}END{for(i in a)print i,a[i]/b[i]}' file
job 76
dave 81.6667
tom 79

7）费用统计

[root@ chenc01 ~]# cat file
zhangsan 8000 1
zhangsan 5000 1
lisi 1000 1
lisi 2000 1
wangwu 1500 1
zhaoliu 6000 1
zhaoliu 2000 1
zhaoliu 3000 1

[root@ chenc01 ~]# awk '{name[$1]++;cost[$1]+=$2;number[$1]+=$3}END{for(v in name)print v,cost[v],number[v]}' file
zhangsan 5000 1
lisi 3000 2
wangwu 1500 1
zhaoliu 11000 3

8）获取数字字段最大值
[root@ chenc01 ~]# cat file
a b 1
c d 2
e f 3
g h 3
i j 2

获取第三字段最大值：
[root@ chenc01 ~]# awk 'BEGIN{max=0}{if($3&gt;max)max=$3}END{print max}' file
3

打印第三字段最大行：
[root@ chenc01 ~]# awk 'BEGIN{max=0}{a[$0]=$3;if($3&gt;max)max=$3}END{for(v in a)print v,a[v],max}' a
g h 3 3 3
e f 3 3 3
c d 2 2 3
a b 1 1 3
i j 2 2 3

[root@ chenc01 ~]# awk 'BEGIN{max=0}{a[$0]=$3;if($3&gt;max)max=$3}END{for(v in a)if(a[v]==max)print v}' a
gh 3
e f 3

9）去除第一行和最后一行
[root@ chenc01 ~]# seq 5 |awk 'NR&gt;2{print s}{s=$0}'
2
3
4

读取第一行，NR=1，不执行print s，s=1
读取第二行，NR=2，不执行print s，s=2 （大于为真） 
读取第三行，NR=3，执行print s，此时s是上一次p赋值内容2，s=3
最后一行，执行print s，打印倒数第二行，s=最后一行
获取Nginx负载均衡配置端IP和端口：

[root@ chenc01 ~]# cat nginx.conf
upstream example-servers1 {
  server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;
}

upstream example-servers2 {
  server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;
  server 127.0.0.1:82 backup;
}

[root@ chenc01 ~]# awk '/example-servers1/,/}/{if(NR&gt;2){print s}{s=$2}}' nginx.conf  
127.0.0.1:80
[root@ chenc01 ~]# awk '/example-servers1/,/}/{if(i&gt;1)print s;s=$2;i++}' nginx.conf  
[root@ chenc01 ~]# awk '/example-servers1/,/}/{if(i&gt;1){print s}{s=$2;i++}}' nginx.conf
127.0.0.1:80

读取第一行，i初始值为0，0&gt;1为假，不执行print s，x=example-servers1，i=1
读取第二行，i=1，1&gt;1为假，不执行print s，s=127.0.0.1:80,i=2
读取第三行，i=2，2&gt;1为真，执行print s，此时s是上一次s赋值内容127.0.0.1:80，i=3
最后一行，执行print s，打印倒数第二行，s=最后一行。
这种方式与上面一样，只是用i++作为计数器。

10）知道上述方式，就可以实现这种需求了，打印匹配行的上一行

[root@ chenc01 ~]# seq 5 |awk '/3/{print s}{s=$0}'
2
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>