<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Vi使用及Shell编程 | 开发者问答集锦</title>
    <meta property="og:title" content="Vi使用及Shell编程 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Vi使用及Shell编程">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/vi%E4%BD%BF%E7%94%A8%E5%8F%8Ashell%E7%BC%96%E7%A8%8B/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Vi使用及Shell编程</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>内容简介：<br />
1、vi 及其使用（高兴誉、赵礼）<br />
2、Shell 简述（刘歆）<br />
3、变量及注释（刘歆）<br />
4、最简单的例子（刘歆）<br />
5、流程控制（阴小波）<br />
6、函数（阴小波）<br />
7、实例及其分析（阴小波）<br />
8、感谢及答疑（阴小波）<br />
Vi 简介<br />
vi 是个可视化的编辑器(visual edit). vi 是UNIX 下面的缺省编辑器。 Vi 提供两种操作模<br />
式： 输入模式（insert mode），指令模式（command mode）.当使用者进入vi 后，即处于指<br />
令模式下，此刻键入任何字皆被视为指令；a 或i 键用来进入输入模式， 在输入模式下，每<br />
个按键代表输入字符，离开输入模式用键。<br />
vi 技巧<br />
1. 文件加密 :X<br />
然后系统会提示输入密码，输入密码后存盘退出。<br />
下次编辑时请使用vi -x filename 打开被加密的文件。<br />
2． 上下两行合并 J<br />
删除所有行 dG<br />
交换两个字符位置xp<br />
上下两行调换ddp<br />
注：xp 和ddp 应该理解为删除一个字符(x)和删除一行(dd),然后在p(paste),这样便不需<br />
记新命令了.<br />
3． 从当前位置删除到行尾d$<br />
从当前位置复制到行尾y$<br />
如果要粘贴到其他地方 p 就可以了<br />
4．文件移动<br />
:line1,line2mline3: 将line1&ndash;line2 之间的内容移到line3 下 相当于word 的剪切，<br />
:line1,line2tline3: 将line1&ndash;line2 之间的内容粘贴到line3 下，相当于word 的粘贴。<br />
:n1,n2w filename：把行N1-N2 之间内容写入新文件filename 中。<br />
5．自动添加字符串 :ab string strings<br />
例如 &ldquo;:ab usa United States of America&rdquo; 。<br />
当你在文件里插入 usa 时 ，United States of America 就蹦出来了<br />
6． 替换命令操作 :g/s1/s/s2/s3/g<br />
第一个g 表示对每一个包括s1 的行都进行替换，第二个g 表示对每一个包括s1 的行的<br />
所有的s2 都用s3 替换，s 表示替换，s2 是要被替换的字符串，他可以和s1 相同（如果相同<br />
的话用//代替），s3 是替换字符串<br />
注：在整个文件中替换特定字符串 :%s/old_word/new_word/g<br />
7． 寄存器操作<br />
&rdquo;?nyy：将当前行及其下n 行的内容保存到寄存器？中，其中?为一个字母，n 为一个数<br />
字<br />
&rdquo;?nyw：将当前行及其下n 个字保存到寄存器？中，其中?为一个字母，n 为一个数字<br />
&rdquo;?nyl：将当前行及其下n 个字符保存到寄存器？中，其中?为一个字母，n 为一个数字<br />
&rdquo;?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是<br />
一个数字<br />
ndd：将当前行及其下共n 行文本删除，并将所删内容放到1 号删除寄存器中。<br />
注：vi 还有有编号的删除缓冲区。撤消命令只能恢复上一次的删除，当且仅当这个删除<br />
是最后一次操作。但是，vi 可以把最近9 次删除的内容都放入9 个编号从1 到9 的缓冲区内。<br />
最近一次删除保存在缓冲区1，次近的在缓冲区2，依此类推。例如，&rdquo;2p 可以放置第二个<br />
删除缓冲区中的内容。<br />
8. 排序<br />
如有一文件，内容为：<br />
333<br />
222<br />
334<br />
444<br />
111<br />
553<br />
554<br />
233<br />
运行命令:%!sort 文件内容为：<br />
111<br />
222<br />
233<br />
333<br />
334<br />
444<br />
553<br />
554<br />
9． vi 环境选项<br />
noautoindent nomodelines noshowmode<br />
autoprint nonumber noslowopen<br />
noautowrite nonovice tabstop=8<br />
nobeautify nooptimize taglength=0<br />
directory=/var/tmp paragraphs=IPLPPPQPP LIpplpipnpbtags=tags /usr/lib/tags<br />
noedcompatible prompt tagstack<br />
noerrorbells noreadonly term=vt100<br />
noexrc redraw noterse<br />
flash remap timeout<br />
hardtabs=8 report=5 ttytype=vt100<br />
noignorecase scroll=11 warn<br />
nolisp sections=NHSHH HUuhsh+c window=23<br />
nolist shell=/bin/ksh wrapscan<br />
magic shiftwidth=8 wrapmargin=0<br />
mesg noshowmatch nowriteany<br />
For C-Shell:<br />
setenv EXINIT &ldquo;set nu&rdquo;<br />
For Bourne or Korn Shell:<br />
EXINIT=&ldquo;set nu&rdquo;; export EXINIT<br />
For Korn Shell Only (alternate method):<br />
typeset -x EXINIT=&ldquo;set nu&rdquo;<br />
在 .profile 里设置 vi 的环境选项 , 以上均测试过<br />
10. 重复上一次操作 .：<br />
恢复上一次的操作 u<br />
11． :! shell-command 执行SHELL 命令的操作<br />
举例<br />
1．删除文件中的几行<br />
到删除的开始处 ma<br />
到删除的结束处 d’a<br />
2．拷贝文件中的几行<br />
到拷贝的开始处 ma<br />
到拷贝的结束处 y’a<br />
3．替换文件中所有匹配的字符<br />
替换文件中的 lesson 为course<br />
s/lesson/course/g<br />
注意：可能替换含有lesson 的其他词<br />
4．替换文件中一个区域的字符<br />
start_line, end_line %s/lesson/course/g 或者<br />
采用宏的方式<br />
‘a,. %s/lesson/course/g #需要定义宏；’.’是指光标所在行<br />
5．替换一个文件中某些词<br />
比如替换none 为nothing<br />
查找 /none<br />
替换 cw，输入nothing，按键盘Esc<br />
继续查找 n<br />
替换 .<br />
6．重复执行一个shell 命令<br />
编译一个程序<br />
保存编辑后的文件 :w<br />
编译文件 :!make<br />
修改文件后，在保存 :w<br />
再编译 :!!<br />
7．在两个文件互拷贝<br />
第一种方法：<br />
编辑源文件 vi source_file<br />
到拷贝的部分开始处 ma<br />
到拷贝的部分结束处 :.,’a w tempfile<br />
退出当前文件 :q<br />
编辑目的文件 vi dest_file<br />
到拷贝的地方 :r tempfile<br />
第二种方法：<br />
编辑源文件 vi source_file<br />
到拷贝的部分开始处 ma<br />
到拷贝的部分结束处 “ay’a<br />
不退出源文件编辑目的文件 :e dest_file<br />
到拷贝的地方 “ap<br />
vi 命令一览表<br />
1.进入vi 的命令:<br />
vi filename :打开或新建文件，并将光标置于第一行首<br />
vi +n filename ：打开文件，并将光标置于第n 行首<br />
vi + filename ：打开文件，并将光标置于最后一行首<br />
vi +/pattern filename：打开文件，并将光标置于第一个与pattern 匹配的串处<br />
vi -r filename ：在上次正用vi 编辑时发生系统崩溃，恢复filename<br />
vi filename&hellip;.filename ：打开多个文件，依次进行编辑<br />
2.移动光标类命令:<br />
h ：光标左移一个字符<br />
l ：光标右移一个字符<br />
space：光标右移一个字符<br />
Backspace：光标左移一个字符<br />
k 或Ctrl+p：光标上移一行<br />
j 或Ctrl+n ：光标下移一行<br />
Enter ：光标下移一行<br />
w 或W ：光标右移一个字至字首<br />
b 或B ：光标左移一个字至字首<br />
e 或E ：光标右移一个字至字尾<br />
) ：光标移至句尾<br />
( ：光标移至句首<br />
)：光标移至段落开头<br />
{：光标移至段落结尾<br />
nG：光标移至第n 行首<br />
n+：光标下移n 行<br />
n-：光标上移n 行<br />
n$：光标移至第n 行尾<br />
H ：光标移至屏幕顶行<br />
M ：光标移至屏幕中间行<br />
L ：光标移至屏幕最后行<br />
0：（注意是数字零）光标移至当前行首<br />
$：光标移至当前行尾<br />
3.屏幕翻滚类命令:<br />
Ctrl+u：向文件首翻半屏<br />
Ctrl+d：向文件尾翻半屏<br />
Ctrl+f：向文件尾翻一屏<br />
Ctrl＋b；向文件首翻一屏<br />
nz：将第n 行滚至屏幕顶部，不指定n 时将当前行滚至屏幕顶部。<br />
4.插入文本类命令:<br />
i ：在光标前<br />
I ：在当前行首<br />
a：光标后<br />
A：在当前行尾<br />
o：在当前行之下新开一行<br />
O：在当前行之上新开一行<br />
r：替换当前字符<br />
R：替换当前字符及其后的字符，直至按ESC 键<br />
s：从当前光标位置处开始，以输入的文本替代指定数目的字符<br />
S：删除指定数目的行，并以所输入文本代替之<br />
ncw 或nCW：修改指定数目的字<br />
nCC：修改指定数目的行<br />
5.删除命令:<br />
ndw 或ndW：删除光标处开始及其后的n-1 个字<br />
do：删至行首<br />
d$：删至行尾<br />
ndd：删除当前行及其后n-1 行<br />
x 或X：删除一个字符，x 删除光标后的，而X 删除光标前的<br />
Ctrl+u：删除输入方式下所输入的文本<br />
6.搜索及替换命令:<br />
/pattern：从光标开始处向文件尾搜索pattern<br />
?pattern：从光标开始处向文件首搜索pattern<br />
n：在同一方向重复上一次搜索命令<br />
N：在反方向上重复上一次搜索命令<br />
：s/p1/p2/g：将当前行中所有p1 均用p2 替代<br />
：n1,n2s/p1/p2/g：将第n1 至n2 行中所有p1 均用p2 替代<br />
：g/p1/s//p2/g：将文件中所有p1 均用p2 替换<br />
7.选项设置:<br />
all：列出所有选项设置情况<br />
term：设置终端类型<br />
ignorance：在搜索中忽略大小写<br />
list：显示制表位(Ctrl+I)和行尾标志（$）<br />
number：显示行号<br />
report：显示由面向行的命令修改过的数目<br />
terse：显示简短的警告信息<br />
warn：在转到别的文件时若没保存当前文件则显示NO write 信息<br />
nomagic：允许在搜索模式中，使用前面不带“/”的特殊字符<br />
nowrapscan：禁止vi 在搜索到达文件两端时，又从另一端开始<br />
mesg：允许vi 显示其他用户用write 写到自己终端上的信息<br />
8.最后行方式命令:<br />
：n1,n2 co n3：将n1 行到n2 行之间的内容拷贝到第n3 行下<br />
：n1,n2 m n3：将n1 行到n2 行之间的内容移至到第n3 行下<br />
：n1,n2 d ：将n1 行到n2 行之间的内容删除<br />
：w ：保存当前文件<br />
：e filename：打开文件filename 进行编辑<br />
：x：保存当前文件并退出<br />
：q：退出vi<br />
：q!：不保存文件并退出vi<br />
：!command：执行shell 命令command<br />
：n1,n2 w!command：将文件中n1 行至n2 行的内容作为command 的输入并执行之，若不指<br />
定n1，n2，则表示将整个文件内容作为command 的输入<br />
：r!command：将命令command 的输出结果放到当前行<br />
9.寄存器操作:<br />
&rdquo;?nyy：将当前行及其下n 行的内容保存到寄存器？中，其中?为一个字母，n 为一个数字<br />
&rdquo;?nyw：将当前行及其下n 个字保存到寄存器？中，其中?为一个字母，n 为一个数字<br />
&rdquo;?nyl：将当前行及其下n 个字符保存到寄存器？中，其中?为一个字母，n 为一个数字<br />
&rdquo;?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一<br />
个数字<br />
ndd：将当前行及其下共n 行文本删除，并将所删内容放到1 号删除寄存器中。<br />
Shell 编程<br />
如何开始:<br />
如同其他语言一样，通过我们使用任意一种文字编辑器，比如nedit、kedit、emacs、<br />
vi 等来编写我们的shell 程序。程序必须以下面的行开始（必须方在文件的第一行）：<br />
#!/bin/sh<br />
符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用<br />
/bin/sh 来执行程序。当编辑好脚本时，如果要执行该脚本，还必须使其可执行。要使脚本<br />
可执行：<br />
chmod +x filename<br />
然后，您可以通过输入： ./filename 来执行您的脚本。<br />
注释:<br />
在进行shell 编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建<br />
议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您<br />
也能在很短的时间内明白该脚本的作用及工作原理。<br />
变量:<br />
在其他编程语言中您必须使用变量。在shell 编程中，所有的变量都由字符串组成，<br />
并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：<br />
变量名=值<br />
取出变量值可以加一个美元符号（$）在变量前面，如：<br />
$HOME<br />
四、实例：<br />
#!/bin/sh<br />
a=&ldquo;hello world&rdquo;<br />
echo &ldquo;A is:&rdquo;<br />
echo $a<br />
在您的编辑器中输入以上内容，然后将其保存为一个文件first。之后执行<br />
chmod +x first<br />
使其可执行，最后输入./first 执行该脚本。这个脚本将会输出：<br />
A is:<br />
hello world<br />
有许多变量是系统自动设定的，这将在后面使用这些变量时进行讨论。如果您需要处理数学<br />
表达式，那么您需要使用诸如expr 等程序（见下面）。除了一般的仅在程序内有效的shell<br />
变量以外，还有环境变量。由export 关键字处理过的变量叫做环境变量。我们不对环境变<br />
量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。<br />
五、Shell 命令和流程控制<br />
在shell 脚本中可以使用三类命令：<br />
1)Unix 命令:<br />
虽然在shell 脚本中可以使用任意的unix 命令，但是还是由一些相对更常用的命令。<br />
这些命令通常是用来进行文件和文字操作的。<br />
常用命令语法及功能<br />
echo &ldquo;some text&rdquo;: 将文字内容打印在屏幕上<br />
ls: 文件列表<br />
wc –l file 计算文件行数<br />
wc -w file 计算文件中的单词数<br />
wc -c file: 计算文件中的字符数<br />
cp sourcefile destfile: 文件拷贝<br />
mv oldname newname : 重命名文件或移动文件<br />
rm file: 删除文件<br />
grep &lsquo;pattern&rsquo; file: 在文件内搜索字符串比如：grep &lsquo;searchstring&rsquo; file.txt<br />
cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：<br />
输出每行第5 个到第9 个字符cut -b5-9 file.txt 千万不要和cat 命令混淆，这是两个完<br />
全不同的命令<br />
cat file.txt: 输出文件内容到标准输出设备（屏幕）上<br />
file somefile: 得到文件类型<br />
read var: 提示用户输入，并将输入赋值给变量<br />
sort file.txt: 对file.txt 文件中的行进行排序<br />
expr: 进行数学运算Example: add 2 and 3expr 2 &ldquo;+&rdquo; 3<br />
find: 搜索文件比如：根据文件名搜索find . -name filename -print<br />
tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile<br />
sed: Sed 是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，<br />
并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell<br />
中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file | sed<br />
&rsquo;s/linuxfocus/LinuxFocus/&rsquo; &gt; newtext.file<br />
2) 概念: 管道, 重定向和 backtick<br />
这些不是系统命令，但是他们真的很重要。<br />
管道 (|) 将一个命令的输出作为另外一个命令的输入。<br />
grep &ldquo;hello&rdquo; file.txt | wc -l<br />
在file.txt 中搜索包含有”hello”的行并计算其行数。在这里grep 命令的输出作为wc<br />
命令的输入。当然您可以使用多个命令。<br />
重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。<br />
&gt; 写入文件并覆盖旧文件<br />
&gt;&gt; 加到文件的尾部，保留旧文件内容。<br />
反短斜线：使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br />
命令：find . -mtime -1 -type f -print<br />
用来查找过去24 小时（-mtime –2 则表示过去48 小时）内修改过的文件。如果您想<br />
将所有查找到的文件打一个包，则可以使用以下脚本：<br />
#!/bin/sh</p>

<h1 id="the-ticks-are-backticks-not-normal-quotes">The ticks are backticks (`) not normal quotes (&lsquo;):</h1>

<p>tar -zcvf lastmod.tar.gz <code>find . -mtime -1 -type f -print</code><br />
3) 流程控制<br />
a. &ldquo;if&rdquo; 表达式 如果条件为真则执行then 后面的部分：<br />
if &hellip;.; then<br />
&hellip;.<br />
elif &hellip;.; then<br />
&hellip;.<br />
else<br />
&hellip;.<br />
fi<br />
大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件<br />
是否存在及是否可读等等…通常用&rdquo; [ ] &ldquo;来表示条件测试。注意这里的空格很重要。要确<br />
保方括号的空格。<br />
[ -f &ldquo;somefile&rdquo; ] ：判断是否是一个文件<br />
[ -x &ldquo;/bin/ls&rdquo; ] ：判断/bin/ls 是否存在并有可执行权限<br />
[ -n &ldquo;$var&rdquo; ] ：判断$var 变量是否有值<br />
[ &ldquo;$a&rdquo; = &ldquo;$b&rdquo; ] ：判断$a 和$b 是否相等<br />
<em>）执行man test 可以查看所有测试表达式可以比较和判断的类型。<br />
直接执行以下脚本：<br />
#!/bin/sh<br />
if [ &ldquo;$SHELL&rdquo; = &ldquo;/bin/bash&rdquo; ]; then<br />
echo &ldquo;your login shell is the bash (bourne again shell)&rdquo;<br />
else<br />
echo &ldquo;your login shell is not bash but $SHELL&rdquo;<br />
fi<br />
变量$SHELL 包含了登录shell 的名称，我们和/bin/bash 进行了比较。<br />
b. case 表达式可以用来匹配一个给定的字符串，而不是数字。<br />
case &hellip; in<br />
&hellip;) do something here ;;<br />
esac<br />
让我们看一个例子。 file 命令可以辨别出一个给定文件的文件类型，比如：<br />
file lf.gz<br />
这将返回：<br />
lf.gz: gzip compressed data, deflated, original filename,<br />
last modified: Mon Aug 27 23:09:18 2001, os: Unix<br />
我们利用这一点写了一个叫做smartzip 的脚本，该脚本可以自动解压bzip2, gzip 和zip<br />
类型的压缩文件：<br />
#!/bin/sh<br />
ftype=<code>file &quot;$1&quot;</code><br />
case &ldquo;$ftype&rdquo; in<br />
&rdquo;$1: Zip archive&rdquo;</em>)<br />
unzip &ldquo;$1&rdquo; ;;<br />
&rdquo;$1: gzip compressed&rdquo;<em>)<br />
gunzip &ldquo;$1&rdquo; ;;<br />
&rdquo;$1: bzip2 compressed&rdquo;</em>)<br />
bunzip2 &ldquo;$1&rdquo; ;;<br />
*) error &ldquo;File $1 can not be uncompressed with smartzip&rdquo;;;<br />
esac<br />
您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一<br />
个参数值。也就是说，当我们运行：<br />
smartzip articles.zip<br />
$1 就是字符串 articles.zip<br />
c. while-loop 将运行直到表达式测试为真。will run while the expression that we test<br />
for is true. 关键字&rdquo;break&rdquo; 用来跳出循环。而关键字”continue”用来不执行余下的部<br />
分而直接跳到下一个循环。<br />
d. for-loop 表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br />
for var in &hellip;.; do<br />
&hellip;.<br />
done<br />
在下面的例子中，将分别打印ABC 到屏幕上：<br />
#!/bin/sh<br />
for var in A B C ; do<br />
echo &ldquo;var is $var&rdquo;<br />
done<br />
######引号#######<br />
在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通<br />
配符（比如*）替换成合适的文件名，它变量替换成变量值。为了防止程序作这种替换，您<br />
可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg 文件，<br />
mail.jpg 和tux.jpg。<br />
#!/bin/sh<br />
echo <em>.jpg<br />
这将打印出&rdquo;mail.jpg tux.jpg&rdquo;的结果。<br />
引号 (单引号和双引号) 将防止这种通配符扩展：<br />
#!/bin/sh<br />
echo &ldquo;</em>.jpg&rdquo;<br />
echo &lsquo;<em>.jpg&rsquo;<br />
这将打印&rdquo;</em>.jpg&rdquo; 两次。<br />
Here documents<br />
当要将几行文字传递给一个命令时，here documents 一种不错的方法。对每个脚本写一段<br />
帮助性的文字是很有用的，此时如果我们有那个here documents 就不必用echo 函数一行行<br />
输出。 一个 &ldquo;Here document&rdquo; 以 &lt;&lt; 开头，后面接上一个字符串，这个字符串还必须出<br />
现在here document 的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，<br />
并且使用here documents 打印帮助：<br />
#!/bin/sh</p>

<h1 id="we-have-less-than-3-arguments-print-the-help-text">we have less than 3 arguments. Print the help text:</h1>

<p>if [ $# -lt 3 ] ; then<br />
cat &lt;<br />
ren &ndash; renames a number of files using sed regular expressions<br />
USAGE: ren &lsquo;regexp&rsquo; &lsquo;replacement&rsquo; files&hellip;<br />
EXAMPLE: rename all *.HTM files in *.html:<br />
ren &lsquo;HTM$&rsquo; &lsquo;html&rsquo; *.HTM<br />
HELP<br />
exit 0<br />
fi<br />
OLD=&ldquo;$1&rdquo;<br />
NEW=&ldquo;$2&rdquo;</p>

<h1 id="the-shift-command-removes-one-argument-from-the-list-of">The shift command removes one argument from the list of</h1>

<h1 id="command-line-arguments">command line arguments.</h1>

<p>shift<br />
shift</p>

<h1 id="contains-now-all-the-files">$* contains now all the files:</h1>

<p>for file in $*; do<br />
if [ -f &ldquo;$file&rdquo; ] ; then<br />
newfile=<code>echo &quot;$file&quot; | sed &quot;s/${OLD}/${NEW}/g&quot;</code><br />
if [ -f &ldquo;$newfile&rdquo; ]; then<br />
echo &ldquo;ERROR: $newfile exists already&rdquo;<br />
else<br />
echo &ldquo;renaming $file to $newfile &hellip;&rdquo;<br />
mv &ldquo;$file&rdquo; &ldquo;$newfile&rdquo;<br />
fi<br />
fi<br />
done<br />
这是一个复杂一些的例子。让我们详细讨论一下。第一个if 表达式判断输入命令行参数是<br />
否小于3 个 (特殊变量$# 表示包含参数的个数) 。如果输入参数小于3 个，则将帮助文字<br />
传递给cat 命令，然后由cat 命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输<br />
入参数等于或大于3 个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。<br />
下一步，我们使用shift 命令将第一个和第二个参数从参数列表中删除，这样原来的第三个<br />
参数就成为参数列表$*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地<br />
被赋值给变量$file。接着我们判断该文件是否存在，如果存在则通过sed 命令搜索和替换<br />
来产生新的文件名。然后将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的<br />
目的：得到了旧文件名和新文件名。然后使用mv 命令进行重命名。<br />
六、函数<br />
如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同<br />
的代码，并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：<br />
functionname()<br />
{</p>

<h1 id="inside-the-body-1-is-the-first-argument-given-to-the-function">inside the body $1 is the first argument given to the function</h1>

<h1 id="2-the-second">$2 the second &hellip;</h1>

<p>body<br />
}<br />
您需要在每个程序的开始对函数进行声明，在后面的例子中再详细介绍。<br />
七、实例<br />
现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参<br />
数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是<br />
一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy 命令：<br />
cp framework.sh myscript，然后再插入自己的函数。<br />
让我来看一个具体的例子：二进制到十进制的转换<br />
脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr 命令<br />
进行数学运算的例子：<br />
#!/bin/sh</p>

<h1 id="vim-set-sw-4-ts-4-et">vim: set sw=4 ts=4 et:</h1>

<p>help()<br />
{<br />
cat &lt;<br />
b2h &ndash; convert binary to decimal<br />
USAGE: b2h [-h] binarynum<br />
OPTIONS: -h help text<br />
EXAMPLE: b2h 111010<br />
will return 58<br />
HELP<br />
exit 0<br />
}<br />
error()<br />
{</p>

<h1 id="print-an-error-and-exit">print an error and exit</h1>

<p>echo &ldquo;$1&rdquo;<br />
exit 1<br />
}<br />
lastchar()<br />
{</p>

<h1 id="return-the-last-character-of-a-string-in-rval">return the last character of a string in $rval</h1>

<p>if [ -z &ldquo;$1&rdquo; ]; then</p>

<h1 id="empty-string">empty string</h1>

<p>rval=&ldquo;&rdquo;<br />
return<br />
fi</p>

<h1 id="wc-puts-some-space-behind-the-output-this-is-why-we-need-sed">wc puts some space behind the output this is why we need sed:</h1>

<p>numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed 's/ //g'</code></p>

<h1 id="now-cut-out-the-last-char">now cut out the last char</h1>

<p>rval=<code>echo -n &quot;$1&quot; | cut -b $numofchar</code><br />
}<br />
chop()<br />
{</p>

<h1 id="remove-the-last-character-in-string-and-return-it-in-rval">remove the last character in string and return it in $rval</h1>

<p>if [ -z &ldquo;$1&rdquo; ]; then</p>

<h1 id="empty-string-1">empty string</h1>

<p>rval=&ldquo;&rdquo;<br />
return<br />
fi</p>

<h1 id="wc-puts-some-space-behind-the-output-this-is-why-we-need-sed-1">wc puts some space behind the output this is why we need sed:</h1>

<p>numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed 's/ //g'</code><br />
if [ &ldquo;$numofchar&rdquo; = &ldquo;1&rdquo; ]; then</p>

<h1 id="only-one-char-in-string">only one char in string</h1>

<p>rval=&ldquo;&rdquo;<br />
return<br />
fi<br />
numofcharminus1=<code>expr $numofchar &quot;-&quot; 1</code></p>

<h1 id="now-cut-all-but-the-last-char">now cut all but the last char:</h1>

<p>rval=<code>echo -n &quot;$1&quot; | cut -b 0-${numofcharminus1}</code><br />
}<br />
while [ -n &ldquo;$1&rdquo; ]; do<br />
case $1 in<br />
-h) help;shift 1;; # function help is called<br />
--) shift;break;; # end of options<br />
-*) error &ldquo;error: no such option $1. -h for help&rdquo;;;<br />
*) break;;<br />
esac<br />
done</p>

<h1 id="the-main-program">The main program</h1>

<p>sum=0<br />
weight=1</p>

<h1 id="one-arg-must-be-given">one arg must be given:</h1>

<p>[ -z &ldquo;$1&rdquo; ] &amp;&amp; help<br />
binnum=&ldquo;$1&rdquo;<br />
binnumorig=&ldquo;$1&rdquo;<br />
while [ -n &ldquo;$binnum&rdquo; ]; do<br />
lastchar &ldquo;$binnum&rdquo;<br />
if [ &ldquo;$rval&rdquo; = &ldquo;1&rdquo; ]; then<br />
sum=<code>expr &quot;$weight&quot; &quot;+&quot; &quot;$sum&quot;</code><br />
fi</p>

<h1 id="remove-the-last-position-in-binnum">remove the last position in $binnum</h1>

<p>chop &ldquo;$binnum&rdquo;<br />
binnum=&ldquo;$rval&rdquo;<br />
weight=<code>expr &quot;$weight&quot; &quot;*&quot; 2</code><br />
done<br />
echo &ldquo;binary $binnumorig is decimal $sum&rdquo;</p>

<p>该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制&rdquo;10&rdquo;<br />
可以这样转换成十进制： 0 * 1 + 1 * 2 = 2<br />
为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c 计算字符个<br />
数，然后使用cut 命令取出末尾一个字符。Chop 函数的功能则是移除最后一个字符。<br />
我们希望您现在可以开始写您自己的shell 脚本，希望<br />
您玩得开心。<br />
谢谢大家</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>