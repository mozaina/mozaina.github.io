<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linuxshell脚本编程自动化脚本awksedgrepfind文本分析LinuxShell命令行及脚本编程实例详解 | 开发者问答集锦</title>
    <meta property="og:title" content="linuxshell脚本编程自动化脚本awksedgrepfind文本分析LinuxShell命令行及脚本编程实例详解 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linuxshell脚本编程自动化脚本awksedgrepfind文本分析LinuxShell命令行及脚本编程实例详解">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%ACawksedgrepfind%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90linuxshell%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%8A%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linuxshell脚本编程自动化脚本awksedgrepfind文本分析LinuxShell命令行及脚本编程实例详解</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="linux-shell脚本编程-自动化脚本-awk-sed-grep-find-文本分析-linuxshell命令行及脚本编程实例详解">linux shell脚本编程 自动化脚本 awk sed grep find 文本分析 LinuxShell命令行及脚本编程实例详解</h1>

<p>本文github</p>

<p>window 下 从零开始——PowerShell应用入门（全例子入门讲解）</p>

<p>各种逗比脚本参考</p>

<p>参考代码1</p>

<p>参考代码2</p>

<p>Linux-Shell脚本编程书籍代码</p>

<p>把平时有用的手动操作做成脚本，这样可以便捷的使用</p>

<p>awk 与 sed 学习，包括了知识点介绍，和一些习题练习</p>

<p>三十分钟学会AWK</p>

<p>三十分钟学会SED</p>

<p>Shell脚本学习笔记</p>

<p>LinuxShell命令行及脚本编程实例详解 推荐 百度下载</p>

<p>LinuxShell命令行及脚本编程实例详解 推荐 CSDN下载</p>

<h3 id="脚本解释器">脚本解释器</h3>

<h4 id="sh">sh</h4>

<p>即Bourne shell，POSIX（Portable Operating System
Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p>

<h4 id="bash">bash</h4>

<p>Bash是Bourne shell的替代品，属GNU
Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux
Bash编程，精通Shell编程。</p>

<p>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p>

<pre><code>[root@centosraw ~]# ls -l /bin/*sh
-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash
-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dash
lrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash
</code></pre>

<p>但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p>

<pre><code>iMac:~ wuxiao$ ls -l /bin/*sh
-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash
-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh
-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh
-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh
-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh
-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh
</code></pre>

<h4 id="高级编程语言">高级编程语言</h4>

<p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p>

<p>编译型语言，只要有解释器，也可以用作脚本编程，如C
shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p>

<h2 id="如何选择shell编程语言">如何选择shell编程语言</h2>

<h3 id="熟悉-vs-陌生">熟悉 vs 陌生</h3>

<p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p>

<p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p>

<h3 id="简单-vs-高级">简单 vs 高级</h3>

<p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p>

<p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p>

<ul>
<li>它的函数只能返回字串，无法返回数组</li>
<li>它不支持面向对象，你无法实现一些优雅的设计模式</li>
<li>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</li>
</ul>

<h3 id="环境兼容性">环境兼容性</h3>

<p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac
os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p>

<h2 id="第一个shell脚本">第一个shell脚本</h2>

<h3 id="编写">编写</h3>

<p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell
脚本，扩展名就用php好了。</p>

<p>输入一些代码，第一行一般是这样：</p>

<pre><code>#!/bin/bash
#!/usr/bin/php
</code></pre>

<p>“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p>

<h3 id="运行">运行</h3>

<p>运行Shell脚本有两种方法：</p>

<h4 id="作为可执行程序">作为可执行程序</h4>

<pre><code>chmod +x test.sh
./test.sh
</code></pre>

<p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin,
/sbin,
/usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p>

<p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p>

<p>这里的&rdquo;系统&rdquo;，其实就是shell这个应用程序（想象一下Windows
Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
<li>Advanced Bash-Scripting Guide，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅</li>
<li>Unix Shell Programming</li>
<li>Linux Shell Scripting Tutorial - A Beginner’s handbook</li>
</ul>

<h1 id="linuxshell命令行及脚本编程实例详解笔记">LinuxShell命令行及脚本编程实例详解笔记</h1>

<h1 id="linuxshell命令行及脚本编程实例详解">LinuxShell命令行及脚本编程实例详解</h1>

<p>Linux 典藏大师系列丛书</p>

<p>shell 脚本的构成:</p>

<pre><code>1. shell 关键字 if ...then else; for ...done; while do done
2. shell 命令 export,echo,exit,pwd,return
3. linux 命令 data rm mkdir cd 
4. 文本处理功能 awk cut sed grep
5. 函数 功能语句集合 /etc/init.d/functions
6. 控制流语句 if...then...else
</code></pre>

<p>bash 登录脚本 ~/.bash_profile 打开shell 会执行的脚本</p>

<p>bash 退出脚本 ~/bash_logout 退出shell 会执行的脚本</p>

<h2 id="shell-变量">shell 变量</h2>

<pre><code>username=wanyouwen

或者

username=&quot;wanyouwen&quot;   注意等号=前后不能有空格

赋值数字给变量

var=2

注意shell默认赋值是字符串赋值

如 var=$var+1

echo var

&gt;&gt;&gt; 1+1  看到是不是2
如果想把算术表达式的值赋给一个变量，需要用let

let var=2+3

echo $var

5


# 使用(())
cnt=0

cnt=$(($cnt+1))

将一个变量赋值给另外一个变量
a=3
b=$a
echo $b

将命令的结果赋值给变量
var='pwd'  或者 var=$(pwd) 
echo $var

获取命令行输入 获取read命令得到的值

$ echo -n &quot;Enter var:&quot;; read var
Enter var: 1234
$ echo var
1234
</code></pre>

<h2 id="打印变量">打印变量</h2>

<pre><code>最简单的使用 echo

echo $变量名

var=10
echo $var
echo ${var}
echo &quot;value: $var&quot;
echo &quot;value: ${var}&quot;

也可以使用 printf

printf  &quot;格式&quot; $变量

var = 111
printf &quot;%s\n&quot; $var   类似于c语言的printf()函数

%d  %i  带符号十进制格式打印
%o      无符号八进制
%u      无符号十进制
%x      无符号小写十六进制
%X      无符号大写十六进制
%f      浮点数格式
%e      双精度浮点数  e
%E      双精度浮点数  E
#c      以字符的格式
%s      以字符串的格式
%n      指定打印字符的个数
%%      打印一个%

转义字符
\&quot;      打印一个双引号 &quot;
\\ 
\a      警告音
\b      删除前一个字符
\f      换页符
\r      回车，回到本行开头
\n      换行，到下一行开头
\t      一个制表符
\v      竖直制表符

### echo中 使用转移字符  需要 -e 选项使能转移字符
$ echo -e &quot;User name: $USER\tHome Directory: $HOME\n&quot;
&gt;&gt;&gt; User name: ywy  Home Directory: /home/wyw

######字符串#####
var=shell
$printf &quot;%s\n&quot; $var
shell
$printf &quot;%1s\n&quot; $var   #指定参数长度小于实际长度，按实际长度打印
shell
$printf &quot;%1.3s\n&quot; $var #小数点后指示打印的字符串长度
she
$printf &quot;%1.6s\n&quot; $var #小数点后指示打印的字符串长度
shell
$printf &quot;%3.6s\n&quot; $var #小数点后指示打印的字符串长度
shell
$printf &quot;%6.6s\n&quot; $var #指定长度大于实际长度，左边补空格
 shell                
$printf &quot;%10.6s\n&quot; $var #指定长度大于实际长度，左边补空格
     shell              #左边补了5个空格
$printf &quot;%10.2s\n&quot; $var #指定长度大于实际长度，左边补空格
     sh                 #左边补了5个空格，同时只打印前2个字符


####小数######
$varr=123.45678
$printf &quot;%5.1f\n&quot; $varr #打印总长度5(包含小数点)保留小数点后1位数字
1123.5
$printf &quot;%6.2f\n&quot; $varr #
1123.46
$printf &quot;%7.3f\n&quot; $varr #
123.457
$printf &quot;%9.3f\n&quot; $varr #打印长度9，保留小数点后3位，只有7位长度，左侧空格
  123.457
$printf &quot;%10.3f\n&quot; $varr #打印长度10，保留小数点后3位，只有7位长度，左侧空格
   123.457
</code></pre>

<h2 id="变量引用-双引号-变量名-将变量整体化">变量引用 双引号 “$变量名” 将变量整体化</h2>

<pre><code>LIST=&quot;one two three&quot;

for var in $LIST   # 将变量的值分成3个参数传递给了for循环
do
    echo &quot;$var&quot;
done
&gt;&gt;&gt;
one
two
three

for var in &quot;$LIST&quot;   # 将变量的值作为一个整体传递给了for循环
do
    echo &quot;$var&quot;
done
&gt;&gt;&gt;
one
</code></pre>

<h2 id="export-变量名-变量值-声明定义全局变量-多bash环境可用">export 变量名=变量值 声明定义全局变量 多bash环境可用</h2>

<h2 id="readonly-变量名-变量值-声明只读变量">readonly 变量名=变量值 声明只读变量</h2>

<h2 id="unset-变量名-删除-export-定义的全局变量-不能删除-readonly-只读变量">unset 变量名 删除 export 定义的全局变量，不能删除 readonly 只读变量</h2>

<h2 id="检查变量是否存在-变量名-不存在提示语-或-变量名-不存在提示语">检查变量是否存在 变量名? 不存在提示语 或 ${变量名:? 不存在提示语}</h2>

<pre><code>JAVA_HOME=/usr/local/jdk
export JAVA_HOME
echo ${JAVA_HOME:? Error variable is not defined}
&gt;&gt;&gt; /usr/local/jdk

unset JAVA_HOME
echo ${JAVA_HOME:? Error variable is not defined}
&gt;&gt;&gt; -bash JAVA_HOME: Error variable is not defined


还有一种更简单的检查变量是否存在的方法 使用 if语句来判断
</code></pre>

<h2 id="回调-历史命令">回调 历史命令</h2>

<pre><code>#### 回调 历史命令
history
&gt;&gt;&gt;
会显示之前输入过的命令 
id1 命令
...
idn 命令

!! 输入两个! 会执行就一条指令
!+id号 会执行历史命令中对应id号的命令
!+历史命令开头的字符  会执行历史命令中有已字符开头的命令
</code></pre>

<h2 id="shell中的扩展-展开-繁殖">shell中的扩展 展开 繁殖</h2>

<p>大括号扩展 波浪号扩展 参数和变量扩展 命令替换 算术扩展 进程替换 单词拆分 和 文件名扩展</p>

<h3 id="大括号扩展-前缀字符-字符1-字符2-字符n-后缀字符">大括号扩展 前缀字符{字符1,字符2,…,字符n}后缀字符</h3>

<pre><code>echo a{b,c,d}e
&gt;&gt;&gt; abe ace ade

echo {a..z}  # 按字母表顺序显示 a~z字母
&gt;&gt;&gt; a b c d ... x y z

echo {0..10} # 显示0~10的数字
&gt;&gt;&gt; 0 1 2 3 ... 9 10

echo {6..-4} # 显示6~-4的数字
&gt;&gt;&gt; 6 5 4 3 ... 0 -1 -2 -3 -4

echo {g..a} # 显示g~a的字母 反向
&gt;&gt;&gt; g f e d c b a

echo {1..3}{a..c}
&gt;&gt;&gt; 1a 1b 1c 2a 2b 2c 3a 3b 3c

## 嵌套
echo a{{b,c}1,{d,e}3,f}h
ab1h ac1h ad3h ae3h afh

## 大括号扩展 繁殖命令
在 当前目录下创建三个文件夹 son1 son2 son3
mkdir ./{son1,son2,son3}

## bash 4.0 新功能 {起点..终点..步长}
echo {0..10..2}
&gt;&gt;&gt; 0 2 4 6 8 10

echo {10..3..-2}
&gt;&gt;&gt; 10 8 6 4 2

echo {a..k..2}
&gt;&gt;&gt; a c e g i k

echo {0001..11..5}   # 指定形式
&gt;&gt;&gt; 0001 0006 0011
</code></pre>

<h3 id="波浪号-指代用户主目录">~ 波浪号 指代用户主目录</h3>

<pre><code>cd ~
pwd
&gt;&gt;&gt; /home/wyw
cd ~wyw
pwd
&gt;&gt;&gt; /home/wyw

~+ 指代 shell变量 PWD的值
echo ~+
&gt;&gt;&gt; /tmp
echo $PWD
&gt;&gt;&gt; /tmp

~-  指代 shell变量 LODPWD 的值
echo ~1
&gt;&gt;&gt; /home/wyw
echo $LODPWD
&gt;&gt;&gt; /home/wyw
</code></pre>

<h3 id="文件名扩展">文件名扩展</h3>

<pre><code>* 匹配任意字符，包括空格,多个字符,单个字符
? 匹配任意单个字符
[xyx] 匹配阔靠内的任意单个字符

ls ./*.txt
&gt;&gt;&gt; 列出 当前目录下 所有以.txt结尾的文件

ls ./[abc]*.cfg
&gt;&gt;&gt; 列出 当前目录下 以a或b或c开头，以.cfg结尾的文件

ls ./image?.jpg
&gt;&gt;&gt; 显示所有 image1.jpg\image2.jpg\...\image9.jpg 文件

ls ./image1[0-9]*.jpg
&gt;&gt;&gt;  列出 以 image10 \ image11 \...\image19开头，以.jpg结尾的文件
</code></pre>

<h3 id="命令别名">命令别名</h3>

<pre><code>alias 别名='完整命令'

例如：
alias ll='ls -l'

是 cp\mv\rm等命令交互式地执行并解释执行了哪些操作
alias cp='cp -iv'
alias mv='mv -iv'
alias rm='rm -iv'

查看磁盘使用情况

alias dus='df -h'
查看所有定义的别名命令
alias
不带参数
</code></pre>

<h2 id="第三章-常用-shell-命令">第三章 常用 shell 命令</h2>

<h3 id="ls-列出文件名和目录">ls 列出文件名和目录</h3>

<pre><code>ls
ls -l
-l 显示全部文件信息:
第一个字符：-,普通文件 d,文件夹 s,套接字文件 l,链接文件
后面9个字符: 文件权限，rwx 读r 写w 执行x 分别为 所有者、用户组、其他用户的权限

ls -lh 文件大小显示为KB MB GB 单位

ls -ls 安装文件大小顺序列出文件和文件夹

ls -a 显示所有文件

# 生成文件名变量
prototxt_file_name=$(ls *.prototxt)
#.prototxt文件数量
count=$(grep -c &quot;.prototxt&quot; $prototxt_file_name | wc)
</code></pre>

<h3 id="cat-显示文件-more-less-head-tail-file">cat 显示文件 more less head tail file</h3>

<pre><code>cat 查看文件内容 连接文件 创建一个或多个文件 重定向输出到终端或文件

# 查看文件内容   cat 正序显示   tat 倒序显示文件内容
cat wyw.txt  / cat -n wyw.txt 显示行号  / cat -b wyw.txt 显示非空白行行号 

cat -e  wyw.txt 会在每行末尾 多显示 $ 符号 （多行内容转换成一行时很有用）

#使用命令行输入创建文件 并连接多个文件

cat &gt;test1
&gt;&gt;&gt; hello!
cat &gt;test2
&gt;&gt;&gt; world!
cat test1 test2 &gt; test3
#显示 test3
cat test3
&gt;&gt;&gt; 
hello!
world!


# more 分屏显示文件内容
more /etc/inittab  / more -10 /etc/inittab 指定一次显示的行号

# less 查看文件速度快 可快速查找关键字
less /etc/inittab 
输入 /关键字  然后回车 向后搜索关键字 
     ?关键字  然后回车 向前搜索关键字 

Ctrl+B 向回翻一个窗口的内容 Ctrl+F 向后翻一个窗口的内容 


# 显示 文件 头 head  显示 文件尾 tail

head /etc/inittab / head -10 /etc/inittab   显示开头前10行
tail /etc/inittab / tail -20  /etc/inittab  显示末尾倒数20行


# file 文件名 显示文件类型

file /etc/inittab 
&gt;&gt;&gt; /etc/inittab: ASCII English text
file -i /etc/inittab 
</code></pre>

<h3 id="wc-查看文件统计信息">wc 查看文件统计信息</h3>

<pre><code>wc 文件名
&gt;&gt;&gt; 行数 单词数 字节数 文件名
wc -l 文件名  只统计行数
wc -w 文件名  只统计单词数
wc -c 文件名  只统计字节数
wc -L 文件名  统计文件中最长行的长度
</code></pre>

<h3 id="find-查找文件-目录">find 查找文件/目录</h3>

<pre><code># 查找文件

find ./wanyouwen/*.txt  # 查找 ./wanyouwen 目录下的 txt文件
find ./wanyouwen -type f -name &quot;*.txt&quot; 
find ./wanyouwen -type f -perm 0777  查找权限是777的文件
find ./wanyouwen -type f ! -perm 777  查找权限不是777的文件
find ./wanyouwen -type f -perm /a+x  查找可执行文件

find ./wanyouwen -type f empty  查找空文件

# 查找文件夹
find ./ -type d -name wanyouwn
find ./wanyouwen -type d empty  查找空文件夹(目录)
</code></pre>

<h3 id="touch-创建文件-mkdir-创建文件夹-cp-复制文件-文件夹-ln-s-创建符号链接文件-mv移动-重命名文件-目录">touch 创建文件 mkdir 创建文件夹 cp 复制文件/文件夹 ln -s 创建符号链接文件 mv移动/重命名文件/目录</h3>

<pre><code># 创建文件
touch 文件1 文件2 文件3
touch -c 已有的文件名 只更新 文件时间戳
touch -m 已有的文件名 只更新 文件的修改时间

# 创建文件夹
mkdir 文件名1
mkdir -p 文件名2/文件夹3  递归创建 带有父目录

# 复制文件/文件夹
cp 文件1 ./xxx/ 复制

# 创建符号链接文件
ln -s  原地址  目标地址  # 在目标地址创建一个 原地址的快捷链接

# 移动/重命名文件/目录
mv 原地址文件/目录 新地址文件/目录

# 删除文件/目录
rm 文件名
rm -rf 文件夹
rm *.txt
rm *[0-9].txt
</code></pre>

<h3 id="管理文件或目录权限">管理文件或目录权限</h3>

<pre><code># 显示权限
ls -l
# 修改权限
chmod 777 文件   r(4)  w(2) x(1)
chmod a+r 文件
chmod a+w 文件
chmod a+x 文件
chmod o+r 文件
chmod o+w 文件
chmod o+x 文件
chmod u+r 文件
chmod u+w 文件
chmod u+x 文件
chmod g+r 文件
chmod g+w 文件
chmod g+x 文件
# 修改所有者 和 用户组
chown
chgrp
# 设置(用户、组)权限位
setuid
setgid
</code></pre>

<h3 id="文本处理">文本处理</h3>

<h4 id="文本排序-sort">文本排序 sort</h4>

<pre><code>$ cat tep.txt
abc
def
ghi
def
$ sort tep.txt  # 将文件内容按字母顺序排序
abc
def
def
ghi
$ sort -u tep.txt # 排序 并去除重复的行
abc
def
ghi

$ cat digit.txt
10
30
20
100
$ sort -n digit.txt # 按数字大小排序
10
20
30
100
$ sort -n -r digit.txt # 按数字大小 倒序 排序
100
30
20
10

# 多列数字排序
$ cat  dig.txt
abc,30
def,10
ghi,20
def,50
$ sort   dig.txt # 默认按每行的第一列进行排序
abc,30
def,10
def,50
ghi,20

$ sort -t ',' -k2n,2 dig.txt # 按第二列 数字大小顺序排序 -t 指定分隔符 -k 指定列数
def,10
ghi,20
abc,30
def,50

$ sort -t ',' -k2nr,2 dig.txt # 按第二列 数字大小倒序排序 -t 指定分隔符 -k 指定列数 r倒序
def,50
abc,30
ghi,20
def,10
</code></pre>

<h4 id="文本去重-uniq-unique-独一无二">文本去重 uniq (unique) 独一无二</h4>

<pre><code>$ cat  tep.txt
aaa
aaa
bbb
ccc
ccc
$ uniq tep.txt  # 去除重复行
aaa
bbb
ccc
$ uniq -c  tep.txt  # 记录每行出现次数
2 aaa
1 bbb
2 ccc
$ uniq -d  tep.txt  # 只显示有重复的行，只显示一次
aaa
ccc
$ uniq -D  tep.txt  # 只显示有重复的行，显示所有
aaa
aaa
ccc
ccc
$ uniq -u  tep.txt  # 只显示不重复的行
bbb

$ uniq -w 3 tep.txt  # 限定每行的前3个字符来比较每行是否重复
$ uniq -f 1 tep.txt  # 跳过每行前1个字符来比较每行是否重复
</code></pre>

<h4 id="替换或删除字符-tr">替换或删除字符 tr</h4>

<pre><code># 大小写转换
$ echo linuxShell | tr [:lower:] [:upper:]
LINUXSHELL
$  echo linuxShell | tr a-z A-Z  # 功能同上 
LINUXSHELL

# 替换空格
$ echo &quot;Hello world&quot; | tr -s [:space:] '\t'
Hello   world   # 空格 换成 制表符  -s 多个连续的空格算一个

# 删除 字符 -d 选项
$ echo &quot;Hello world&quot; | tr -d a-z # 删除全部小写字母
$ echo &quot;Hello world 12345&quot; | tr -d [:digit:] # 删除全部数字
$ echo &quot;Hello world 12345&quot; | tr -cd [:digit:] # 删除全部数字以外的字符
</code></pre>

<h4 id="字符串查找-grep-常用">字符串查找 grep 常用</h4>

<pre><code>grep  关键字 目标文件/目标文件夹/字符串
grep -r 关键字 目标文件夹   # 递归查找  或者 grep -R 关键字 目标文件夹
grep -c 关键字 目标文件/目标文件夹/字符串  # 查找出现的次数
grep -n 关键字 目标文件/目标文件夹/字符串  # 显示行号和对应出现的位置
</code></pre>

<h4 id="文件比较-diff">文件比较 diff</h4>

<pre><code>diff 文件1  文件2   # 比较两个文件的差异
diff -yw 文件1  文件2   # 并排显示两个文件的差异
</code></pre>

<h3 id="其他常用命令">其他常用命令</h3>

<pre><code>hostname  # 查看主机名
hostname 新主机名  # 临时修改主机名，下次重启恢复原主机名

who/w   # 列出系统登录用户
who -b  # 显示系统启动时间
who -l  # 显示系统登录进程时间
who -m  # 只显示与当前用户相关的信息

uptime   # 查看系统运行时间

uname    # 查看系统信息，内核名
uname -r # 内核版本信息
uname -p # 系统硬件CPU类型
uname -i # 硬件平台信息
uname -n # 打印主机名
uname -a # 显示上述所有信息

#### 获取日期信息 data 

year = $(data +%Y)
&gt;&gt;&gt; 2019
year = $(data +%y)
&gt;&gt;&gt; 19
mouth = $(data +%m)
&gt;&gt;&gt; 08
mouth = $(data +%d)
&gt;&gt;&gt; 10

$(data +%H)   小时

$(data +%M)  分钟

$(data +%S)  秒

week = 'data +%a' # 星期几
</code></pre>

<h2 id="第四章-shell命令进阶">第四章 shell命令进阶</h2>

<h3 id="文档处理-和-归档-paste合并文件-dd备份和拷贝文件">文档处理 和 归档 paste合并文件 dd备份和拷贝文件</h3>

<pre><code>### paste 合并多个文件的相应行到同一行
$ cat t.txt
&gt;&gt;&gt;
1
2
3

$ cat d.txt
&gt;&gt;&gt;
a
b
c

$ paste t.txt d.txt
&gt;&gt;&gt;
1 a
2 b
3 c

$ paste -d'|' t.txt d.txt # 指定合并时的分隔符
1|a
2|b
3|c

$ paste -d':,' t.txt d.txt y.txt # 合并多个文件时指定多个分隔符


### 文档复制 dd
# dd if=输入文件的路径(默认标准输入) of=输出文件的路径(默认标准输出)

# 实例：
dd if=/dev/sda of=/dev/sdb   #将磁盘/dev/sda 数据复制到 磁盘/dev/sdb
dd if=/dev/dvd of=dvd.iso    #将磁盘/dev/dvd 数据复制变为一个iso文件
dd if=/dev/zero of=/dev/sda2 #擦除/dev/sda2分区的数据(格式化)

### 压缩和归档文件 gzip bzip2
### 解压缩文件    gunzip bunzip2
### 打包/解包文件  tar -czvf xxx（打包）  tar -xzvf xxx (解包)
</code></pre>

<h3 id="监测和管理磁盘">监测和管理磁盘</h3>

<pre><code>### 挂载mount 和 卸载umount 存储介质 到 文件系统某节点

### df 报告文件系统磁盘空间利用率
df -a  # 显示所有文件系统信息
df -h  # 以GB MB 单位来显示文件大小 和 使用率等信息
df -t  # 显示文件系统类型
df -m  # 以为块大小单位显示文件系统信息

### du 评估文件空间利用率
du -h
du -sh
du -h --time # 显示大小和修改时间
</code></pre>

<h3 id="后台执行命令-cron-大管家-at大将军执行者-任务发布者">后台执行命令 cron 大管家 at大将军执行者 &amp;任务发布者</h3>

<pre><code>###  cron 大管家 
cron 是定时执行计划任务的守护进程，cron进程会从/etc/init.d 中自动启动。
cron进程会在目录 /var/spool/cron/crontabs/ 下搜索定时计划任务文件，并将这些定时计划任务载入内存。
cron进程还会读取 /etc/crontab 以及 /etc/cron.d 下的内容
cron进程会每分钟唤醒一次，审查所有存储的定时任务，是否按规定执行(大管家)

crontab -l
&gt;&gt;&gt;60 6 * * 0  /home/xxx/backup  
# 每周日(0)的6点30分 指向该任务；前5个字段分别为 分钟 小时 日期 月份 星期; * 号表示任意，小时为24小时制。

###  at大将军执行者 在指定时间执行命令

at noon 在中午12点前 midnight 凌晨12点 teatime下午4点 ...

### &amp;将任务放在后台执行   指令 &amp;

### nohup  运行一个对挂起免疫的命令 
</code></pre>

<h1 id="第二篇-shell-脚本编程">第二篇 shell 脚本编程</h1>

<h2 id="5-shell-编程基础">5. shell 编程基础</h2>

<pre><code>#!/bin/bash  # 第一行，指示行，指定解释器，若没有，则默认使用 /bin/sh作为解释器

### 单行注释
# xxxxx代码

### 多行注释 1
:&lt;&gt;&gt; linux_bash        

echo ${FILENAME##*.}  # 移除文件名，保留后缀 ##*.
&gt;&gt;&gt; txt

FILENAMEPATH=home/wanyouwen/linux_bash.txt

echo ${FILENAME%/*}   # 移除文件名保留目录路径 %/*
&gt;&gt;&gt; home/wanyouwen/
echo ${FILENAME##*/}   # 移除目录路径保留文件名 ##*/
&gt;&gt;&gt; linux_bash.txt

### 字符串长度

${#变量名}  # 获取变量名指定的字符串长度
TEX=&quot;123456789a&quot;
${#TEX}
&gt;&gt;&gt; 10

### 获取子字符串
#{变量名:起点:长度}   索引从0开始
${TEX:3:4}
&gt;&gt;&gt; 4567

#### bash 脚本参数
./xxx.bash  参数1  参数2 参数3 参数4

param1=$1
param2=$2
param3=$3
param4=$4


#### declare 指定变量类型
declare -r var=1   # 设定只读变量 var 其值为1
var=2              # 只读变量不能被修改，会报错
declare -i 变量    # 指定变量为整数型变量

declare -a 变量    # 声明数组变量
declare -a linux={'ubuntu','redhat'}

简单数组定义
linux=()
赋值
linux[0]='ubuntu'
linux[1]='redhat'

# 获取数组变量元素
echo ${linux[@]}  或者 echo ${linux[*]}  # 索引编号 @/* 代表所有元素
&gt;&gt;&gt; ubuntu redhat
echo ${linux[0]}
&gt;&gt;&gt; ubuntu
echo ${linux}    # 数组名指代第一个元素
&gt;&gt;&gt; ubuntu
</code></pre>

<h3 id="shell-算数运算">shell 算数运算</h3>

<pre><code>id++  id--  变量后递增和后递减
++id  --id  变量前递增和前递减
- 单目 负号
= 单目 正号
+
! 逻辑反  ~按位取反
** 求幂
* 乘  /除 %取余 +加 -减
&lt;&lt; 按位左移   &gt;&gt; 按位右移
&lt;=  &gt;= &lt;&gt;  小于等于 大于等于 不等于
&amp; 按位与
^ 按位异或
| 按位或
&amp;&amp; 逻辑与
|| 逻辑或

expr?值1:值2



10   普通数字开头 十进制数
020  0数字开头为  八进制数
0x30 0x开头为     十六进制数

2#111 #前面指定进制数  2进制数
32#20 #32进制数


##### 64 进制数   
let base64=64#@_
64进制数，0~9;a~z;A~Z;@ _
@表示62
_表示63
</code></pre>

<h2 id="6-shell-的条件执行">6. shell 的条件执行</h2>

<pre><code>### test 测试文件属性 字符串测试 算术测试

### if 条件语句
if [ $变量 == $变量2 ]
then
   xxxx
else 
   xxxx
fi

if [ $变量 == $变量2 ]    
then
   xxxx
elif [ $变量 -gt $变量2 ]      ### -gt大于-ge大于等于 -eq等于 -ne不等于 -lt小于 -le小于等于
then
   xxxx
else
   xxxx
fi

### 查看脚本的命令行参数数量 ###################

if [ $# -ne 1 ]; then
     echo &quot;usage: $0 param1&quot;
     exit 1
fi

num=$1 # 获取第一个命令行参数

if [ $num -ge 90 ] &amp;&amp; [ $num -le 100 ]  
# 多条件 与&amp;&amp; （-a 也表示与 and   或|| （-o 也表示或 or） 逻辑非！
then
   echo &quot; 90 &lt;= num &lt;= 100&quot;
fi

if [ ! -f xxx.txt ]; then echo &quot; xxx.txt not exit &quot;; fi

-d 路径存不存在  
</code></pre>

<h3 id="case-多分支">case 多分支</h3>

<pre><code>if [ $# -lt 2 ]
then
   echo &quot;usage: $0 param1 param2 &quot;
fi

# 多case语句
case &quot;$1&quot; in
1)
  xxxx
;;  # 1)分支结束 必须要两个;来结束
2)
  xxxx
;;
3) 
  xxxxx
;;
4 | 5 | 6)    # 多重case 匹配
   XXXXX
;;
esac  # 结束case语句
</code></pre>

<h2 id="7-bash-循环">7. bash 循环</h2>

<h3 id="7-1-for-循环">7.1 for 循环</h3>

<pre><code>for 变量 in  列表
do
 ...
done

# 例如
param=&quot;1 2 3 4 5 6 7 8 9 10&quot;
for num in $param
do
   echo $num
done

for i in 1 2 3
do
...
done

for s in aa bb cc dd
do
...
done


for (( i = 0; i &lt; 3; i++ ))
do
   for (( j = 0; j &lt; 5; j++ ))
   do
     ...
   done
   ...
done
</code></pre>

<h3 id="7-2-while循环">7.2 while循环</h3>

<pre><code>while [ $var -le 3 ]
do
  var=$(( var + 1)) # 变量自加1
done


# while  和 read  读取文件

while read -r line
do
   echo $line
done &lt; &quot;$file_name&quot;


# 读取文件 成 多列

while read -r col1 col2 col3   # 每一行分成三列
do
   echo $col1 $col2 $col3
done &lt; &quot;$file_name&quot;

# 无限循环

while :
do
...
sleep 3
done

while true
do
...
done
</code></pre>

<h3 id="7-3-until循环-与-while类似-只不过-在条件为假时执行">7.3 until循环 与 while类似 只不过 在条件为假时执行</h3>

<h3 id="7-4-select循环">7.4 select循环</h3>

<h3 id="7-5-循环控制-break-和-continue">7.5 循环控制 break 和 continue</h3>

<p>break 跳出整个循环，退出循环</p>

<p>continue 跳过当前次循环，执行下一次循环</p>

<h2 id="8-shell-函数">8. shell 函数</h2>

<pre><code># 格式1
function_name()
{
# 函数体
# 返回值 可选
return int
}

# 格式2
function function_name()
{
# 函数体
}

# 格式3
function function_name
{
# 函数体
local xxx  #函数内部变量
}

# 函数放在后台运行
function_name &amp;
</code></pre>

<h3 id="函数参数">函数参数</h3>

<pre><code>fname()
{
# 获取函数参数
func_name=$0  # 函数名
arg1=$1
arg2=$2
# 函数参数总数
arg_num=$#
# $* / $@ 所有参数

# 以上同脚本的参数获取和统计方法
# 关于参数的语句

# 遍历所有参数
for  arg  in $* ; do 
...
done
}
</code></pre>

<h1 id="调用函数-并传递参数给函数">调用函数 并传递参数给函数</h1>

<p>fname foo bar</p>

<h1 id="函数名-参数1-1-参数2-2">函数名 参数1 ($1) 参数2 ($2)</h1>

<h2 id="9-正则表达式">9. 正则表达式</h2>

<h2 id="10-脚本输入处理">10. 脚本输入处理</h2>

<h2 id="11-shell重定向">11. shell重定向</h2>

<h2 id="12-管道和过滤器">12. 管道和过滤器</h2>

<h2 id="13-捕获">13. 捕获</h2>

<h2 id="14-sed-和-awk-文本分析修改">14. sed 和 awk 文本分析修改</h2>

<h2 id="15-其他">15. 其他</h2>

<p><a href="https://img.it610.com/image/info8/eef73a4633c34c569d3660e78f143844.jpg"><img src="https://img.it610.com/image/info8/eef73a4633c34c569d3660e78f143844.jpg" alt="linux shell脚本编程 自动化脚本 awk sed grep find 文本分析
LinuxShell命令行及脚本编程实例详解_第1张图片" /></a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>