<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell基础九awk | 开发者问答集锦</title>
    <meta property="og:title" content="shell基础九awk - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell基础九awk">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E5%9F%BA%E7%A1%80%E4%B9%9Dawk/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell基础九awk</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>From:<a href="http://bbs.chinaunix.net/viewthread.php?tid=448687">http://bbs.chinaunix.net/viewthread.php?tid=448687</a></p>

<p>下面没有讲述a w k的全部特性，也不涉及a w k的深层次编程，仅讲述使用a w k执行行操作及怎样从文本文件和字符串中抽取信息。</p>

<p>QUOTE:</p>

<p>内容有：<br />
&rdquo; 抽取域。<br />
&rdquo; 匹配正则表达式。<br />
&rdquo; 比较域。<br />
&rdquo; 向a w k传递参数。<br />
&rdquo; 基本的a w k行操作和脚本。</p>

<p>a w k语言的最基本功能是在文件或字符串中基于指定规则浏览和抽取信息。a w k抽取信息后，才能进行其他文本操作。完整的a w
k脚本通常用来格式化文本文件中的信息。</p>

<p><strong>1 调用awk</strong></p>

<p><strong>有三种方式调用a w k，第一种是命令行方式，如：</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>awk [-F fild-separator] &lsquo;commands&rsquo; input-file(s)</p>

<p>这里，c o m m a n d s是真正的a w k命令。<br />
上面例子中， [ - F域分隔符]是可选的，因为a w k使用空格作为缺省的域分隔符，因此如果要浏览域间有空格的文本，不必指定这个选项，但如果要浏览诸如p
a s s w d文件，此文件各域以冒号作为分隔符，则必须指明- F选项，如：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>awk -F: &lsquo;commands&rsquo; input-file(s)</p>

<p><strong>第二种方法</strong> 是将所有a w k命令插入一个文件，并使a w k程序可执行，然后用a w k命令解释器作为脚本的首行，以便通过键入脚本名称来调用它。</p>

<p><strong>第三种方式</strong> 是将所有的a w k命令插入一个单独文件，然后调用：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>awk -f awk-script-file input-files(s)</p>

<p>- f选项指明在文件a w k _ s c r i p t _ f i l e中的a w k脚本， i n p u t _ f i l e ( s
)是使用a w k进行浏览的文件名。</p>

<p><strong>2 awk脚本</strong><br />
在命令中调用a w k时，a w k脚本由各种操作和模式组成。<br />
如果设置了- F选项，则a w k每次读一条记录或一行，并使用指定的分隔符分隔指定域，但如果未设置- F选项，a w
k假定空格为域分隔符，并保持这个设置直到发现一新行。当新行出现时，a w
k命令获悉已读完整条记录，然后在下一个记录启动读命令，这个读进程将持续到文件尾或文件不再存在。</p>

<p>参照表，a w k每次在文件中读一行，找到域分隔符（这里是符号#），设置其为域n，直至一新行（这里是缺省记录分隔符），然后，划分这一行作为一条记录，接着a
w k再次启动下一行读进程。<br />
<strong>awk读文件记录的方式</strong></p>

<p>QUOTE:</p>

<p>域1 分隔符 域2 分隔符 域3 分隔符 域4及换行<br />
P. B u n n y (记录1 ) # 0 2 / 9 9 # 4 8 # Yellow /n<br />
J . Tr o l l (记录2 ) # 0 7 / 9 9 # 4 8 4 2 # Brown-3 /n</p>

<p><strong>2.1 模式和动作</strong><br />
任何a w k语句都由模式和动作组成。在一个a w
k脚本中可能有许多语句。模式部分决定动作语句何时触发及触发事件。处理即对数据进行的操作。如果省略模式部分，动作将时刻保持执行状态。<br />
模式可以是任何条件语句或复合语句或正则表达式。模式包括两个特殊字段B E G I N和E N D。使用B E G I N语句设置计数和打印头。B E G I
N语句使用在任何文本浏览动作之前，之后文本浏览动作依据输入文件开始执行。E N D语句用来在a w
k完成文本浏览动作后打印输出文本总数和结尾状态标志。如果不特别指明模式， a w k总是匹配或打印行数。<br />
实际动作在大括号{ }内指明。动作大多数用来打印，但是还有些更长的代码诸如i f和循环（l o o p i n g）语句及循环退出结构。如果不指明采取动作，
a w k将打印出所有浏览出来的记录。</p>

<p><strong>2. 域和记录</strong><br />
a w k执行时，其浏览域标记为$ 1，$ 2 &hellip; $ n。这种方法称为域标识。使用这些域标识将更容易对域进行进一步处理。<br />
使用$ 1 , $ 3表示参照第1和第3域，注意这里用逗号做域分隔。如果希望打印一个有5个域的记录的所有域，不必指明$ 1 , $ 2 , $ 3 , $
4 , $ 5，可使用$ 0，意即所有域。Aw k浏览时，到达一新行，即假定到达包含域的记录末尾，然后执行新记录下一行的读动作，并重新设置域分隔。<br />
注意执行时不要混淆符号$和s h e l l提示符$，它们是不同的。<br />
为打印一个域或所有域，使用p r i n t命令。这是一个a w k动作（动作语法用圆括号括起来）。</p>

<p><strong>1. 抽取域</strong><br />
真正执行前看几个例子，现有一文本文件g r a d e . t x t，记录了一个称为柔道数据库的行信息。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ cat grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p>此文本文件有7个域，即（1）名字、（2）升段日期、（3）学生序号、（4）腰带级别、（5）年龄、（6）目前比赛积分、（7）比赛最高分。<br />
因为域间使用空格作为域分隔符，故不必用- F选项划分域，现浏览文件并导出一些数据。在例子中为了利于显示，将空格加宽使各域看得更清晰。</p>

<p><strong>2. 保存a w k输出</strong><br />
有两种方式保存s h e l l提示符下a w k脚本的输出。最简单的方式是使用输出重定向符号&gt;文件名，下面的例子重定向输出到文件w o w。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;{print $0}&rsquo; grade.txt &gt;wow<br />
$ cat grade.txt</p>

<p>使用这种方法要注意，显示屏上不会显示输出结果。因为它直接输出到文件。只有在保证输出结果正确时才会使用这种方法。它也会重写硬盘上同名数据。</p>

<p>第二种方法是使用t e e命令，在输出到文件的同时输出到屏幕。在测试输出结果正确与否时多使用这种方法。例如输出重定向到文件d e l e t e _ m e
_ a n d _ d i e，同时输出到屏幕。使用这种方法，在a w k命令结尾写入| tee delete_me_and_die。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;{print $0}&rsquo; grade.txt | tee delete_me_and_die</p>

<p><strong>3. 使用标准输入</strong><br />
在深入讲解这一章之前，先对a w k脚本的输入方法简要介绍一下。实际上任何脚本都是从标准输入中接受输入的。为运行本章脚本，使用a w
k脚本输入文件格式，例如：</p>

<p>QUOTE:</p>

<p>belts.awk grade_student.txt<br />
也可替代使用下述格式：<br />
使用重定向方法：<br />
belts.awk &lt; grade2.txt<br />
或管道方法：<br />
grade2.txt | belts.awk</p>

<p>这里我怎么看不明白，汗</p>

<p><strong>4. 打印所有记录</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;{print $0}&rsquo; grade.txt</p>

<p>a w k读每一条记录。因为没有模式部分，只有动作部分{print $0}(打印所有记录)，这个动作必须用花括号括起来。上述命令打印整个文件。</p>

<p><strong>5. 打印单独记录</strong><br />
假定只打印学生名字和腰带级别，通过查看域所在列，可知为f i e l d - 1和f i e l d - 4，因此可以使用$ 1和$
4，但不要忘了加逗号以分隔域。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;{print $1,$4}&rsquo; grade.txt<br />
M.Tans Green<br />
J.Lulu green<br />
P.Bunny Yellow<br />
J.Troll Brown-3<br />
L.Tansl Brown-2</p>

<p><strong>6. 打印报告头</strong><br />
上述命令输出在名字和腰带级别之间用一些空格使之更容易划分，也可以在域间使用t a b键加以划分。为加入t a b键，使用t a b键速记引用符/
t，后面将对速记引用加以详细讨论。也可以为输出文本加入信息头。本例中加入n a m e和b e l t及下划线。下划线使用/ n，强迫启动新行，并在/
n下一行启动打印文本操作。打印信息头放置在B E G I N模式部分，因为打印信息头被界定为一个动作，必须用大括号括起来。在a w
k查看第一条记录前，信息头被打印。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;BEGIN {print &ldquo;Name Belt/n&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;}{print
$1&rdquo;/t&rdquo;,$4}&rsquo; grade.txt<br />
Name Belt<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
M.Tans Green<br />
J.Lulu green<br />
P.Bunny Yellow<br />
J.Troll Brown-3<br />
L.Tansl Brown-2</p>

<p><strong>7. 打印信息尾</strong><br />
如果在末行加入end of report信息，可使用E N D语句。E N D语句在所有文本处理动作执行完之后才被执行。E N
D语句在脚本中的位置放置在主要动作之后。下面简单打印头信息并告之查询动作完成。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;BEGIN {print &ldquo;Name/n&mdash;&mdash;&ndash;&rdquo;}{print $1} END {print &ldquo;end-of-report&rdquo;}&rsquo;
grade.txt<br />
Name<br />
-&mdash;&mdash;-<br />
M.Tans<br />
J.Lulu<br />
P.Bunny<br />
J.Troll<br />
L.Tansl</p>

<p>8. awk错误信息提示<br />
几乎可以肯定，在使用a w k时，将会在命令中碰到一些错误。a w k将试图打印错误行，但由于大部分命令都只在一行，因此帮助不大。<br />
系统给出的显示错误信息提示可读性不好。使用上述例子，如果丢了一个双引号， a w k将返回：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;BEGIN {print &ldquo;Name/n&mdash;&mdash;&ndash;}{print $1} END {&ldquo;end-of-report&rdquo;}&rsquo;
grade.txt<br />
awk: cmd. line:1: BEGIN {print &ldquo;Name/n&mdash;&mdash;&ndash;}{print $1} END {&ldquo;end-of-
report&rdquo;}<br />
awk: cmd. line:1: ^ unterminated string</p>

<p>当第一次使用a w k时，可能被错误信息搅得不知所措，但通过长时间和不断的学习，可总结出以下规则。在碰到a w k错误时，可相应查找：</p>

<p>QUOTE:</p>

<p>&rdquo; 确保整个a w k命令用单引号括起来。<br />
&rdquo; 确保命令内所有引号成对出现。<br />
&rdquo; 确保用花括号括起动作语句，用圆括号括起条件语句。<br />
&rdquo; 可能忘记使用花括号，也许你认为没有必要，但a w k不这样认为，将按之解释语法</p>

<p>。<br />
<strong>如果查询文件不存在，将得到下述错误信息：</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;END {print NR}&rsquo; grades.txt<br />
awk: cmd. line:2: fatal: cannot open file `grades.txt&rsquo; for reading (没有那个文件或目录)</p>

<p><strong>9.awk 键盘输入</strong><br />
如果在命令行并没有输入文件g r a d e . t x t，将会怎样？</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$ awk &lsquo;BEGIN {print &ldquo;Name/n&mdash;&mdash;&ndash;&rdquo;}{print $1} END {&ldquo;end-of-report&rdquo;}&rsquo;<br />
Name<br />
-&mdash;&mdash;-</p>

<p>B E G I N部分打印了文件头，但a w k最终停止操作并等待，并没有返回s h e l l提示符。这是因为a w
k期望获得键盘输入。因为没有给出输入文件， a w k假定下面将会给出。如果愿意，顺序输入相关文本，并在输入完成后敲键。如果敲入了正确的域分隔符， a w
k会像第一个例子一样正常处理文本。这种处理并不常用，因为它大多应用于大量的打印稿。</p>

<p><strong>2.3awk中正则表达式及其操作</strong></p>

<p>在g r e p一章中，有许多例子用到正则表达式，这里将不使用同样的例子，但可以使用条件操作讲述a w k中正则表达式的用法。<br />
这里正则表达式用斜线括起来。例如，在文本文件中查询字符串G r e e n，使用/ G r e e n /可以查出单词G r e e n的出现情况。</p>

<p><strong>2.4元字符</strong><br />
这里是a w k中正则表达式匹配操作中经常用到的字符，详细情况请参阅本书第7章正则表达式概述。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>/ ^ $ . [] | () * + ?</p>

<p>这里有两个字符第7章没有讲到，因为它们只适用于a w k而不适用于g r e p或s e d。它们是：</p>

<p>QUOTE:</p>

<p>+ 使用+匹配一个或多个字符。<br />
？ 匹配模式出现频率。例如使用/X Y?Z/匹配X Y Z或Y Z。</p>

<p><strong>条件操作符</strong><br />
<strong>a w k条件操作符</strong><br />
操作符描述操作符描述<br />
&lt; 小于&gt; = 大于等于<br />
&lt; = 小于等于~ 匹配正则表达式<br />
= = 等于!~ 不匹配正则表达式<br />
!= 不等于</p>

<p><strong>1. 匹配</strong><br />
为使一域号匹配正则表达式，使用符号‘～’后紧跟正则表达式，也可以用i f语句。a w k中i f后面的条件用（）括起来。<br />
观察文件g r a d e . t x t，如果只要显示b r o w n腰带级别可知其所在域为f i e l d -
4，这样可以写出表达式{if($4~/brown/) print }意即如果f i e l d - 4包含b r o w
n，打印它。如果条件满足，则打印匹配记录行。可以编写下面脚本，因为这是一个动作，必须用花括号{ }括起来。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if($4~/Brown/) print $0}&rsquo; grade.txt<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p>匹配记录找到时，如果不特别声明， a w k缺省打印整条记录。使用i
f语句开始有点难，但不要着急，因为有许多方法可以跳过它，并仍保持同样结果。下面例子意即如果记录包含模式b r o w n，就打印它：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$0 ~ /Brown/&rsquo; grade.txt<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p><strong>2. 精确匹配</strong><br />
假定要使字符串精确匹配，比如说查看学生序号4 8，文件中有许多学生序号包含4 8，如果在f i e l d - 3中查询序号4 8，a w
k将返回所有序号带4 8的记录：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if($3~/48/) print$0}&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 26 26</p>

<p>为精确匹配4 8，使用等号= =，并用单引号括起条件。例如$ 3</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$3==&ldquo;48&rdquo; {print$0}&rsquo; grade.txt<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
[root@Linux_chenwy sam]# awk &lsquo;{if($3==&ldquo;48&rdquo;) print$0}&rsquo; grade.txt<br />
P.Bunny 02/99 48 Yellow 12 35 28</p>

<p><strong>3. 不匹配</strong><br />
有时要浏览信息并抽取不匹配操作的记录，与~相反的符号是!~，意即不匹配。像原来使用查询b r o w
n腰带级别的匹配操作一样，现在看看不匹配情况。表达式$0 !~/brown/，意即查询不包含模式b r o w n腰带级别的记录并打印它。<br />
<strong>注意，缺省情况下， a w k将打印所有匹配记录，因此这里不必加入动作部分。</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$0 !~ /Brown/&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26<br />
P.Bunny 02/99 48 Yellow 12 35 28</p>

<p>可以只对f i e l d - 4进行不匹配操作，方法如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if($4~/Brown/) print $0}&rsquo; grade.txt<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p>如 果只使用命令awk$4 !=&ldquo;brown&rdquo;{print $0} grade.txt，将返回错误结果，因为用引号括起了b r o w n，将只匹配‘b r
o w n而不匹配b r o w n - 2和b r o w n - 3，当然，如果想要查询非b r o w n - 2的腰带级别，可做如下操作：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$4!=&ldquo;Brown-2&rdquo; {print $0}&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 26 26</p>

<p><strong>4. 小于</strong><br />
看看哪些学生可以获得升段机会。测试这一点即判断目前级别分f i e l d - 6是否小于最高分f i e l d -
7，在输出结果中，加入这一改动很容易。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if($6 &lt; $7) print $0}&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26</p>

<p><strong>5. 小于等于</strong><br />
对比小于，小于等于只在操作符上做些小改动，满足此条件的记录也包括上面例子中的输出情况。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if($6 &lt;= $7) print $1}&rsquo; grade.txt<br />
M.Tans<br />
J.Lulu<br />
J.Troll</p>

<p><strong>6. 大于</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if($6 &gt; $7) print $1}&rsquo; grade.txt<br />
P.Bunny<br />
L.Tansl</p>

<p><strong>7. 设置大小写</strong><br />
为查询大小写信息，可使用[ ]符号。在测试正则表达式时提到可匹配[ ]内任意字符或单词，因此若查询文件中级别为g r e e
n的所有记录，不论其大小写，表达式应为‘ / [ G g ] r e e n /’</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;/[Gg]reen/&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26</p>

<p><strong>8. 任意字符</strong><br />
抽取名字，其记录第一域的第四个字符是a，使用句点.。表达式/ ^ &hellip; a /意为行首前三个字符任意，第四个是a，尖角符号代表行首。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$1 ~ /^&hellip;a/&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p><strong>9. 或关系匹配</strong><br />
为抽取级别为y e l l o w或b r o w n的记录，使用竖线符|。意为匹配| 两边模式之一。注意，使用竖线符时，语句必须用圆括号括起来。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$0 ~/(Yellow|Brown)/&rsquo; grade.txt<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p>上面例子输出所有级别为Ye l l o w或B r o w n的记录。</p>

<p>使用这种方法在查询级别为G r e e n或g r e e n时，可以得到与使用[ ]表达式相同的结果。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;/^M/&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44</p>

<p><strong>10. 行首</strong><br />
不必总是使用域号。如果查询文本文件行首包含M的代码，可简单使用下面^符号：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;/^M/&rsquo; grade.txt</p>

<p>复合表达式即为模式间通过使用下述各表达式互相结合起来的表达式：</p>

<p>QUOTE:</p>

<p>&amp;&amp; AND : 语句两边必须同时匹配为真。<br />
|| O R：语句两边同时或其中一边匹配为真。<br />
! 非求逆</p>

<p><strong>11. AND</strong><br />
打印记录，使其名字为‘ P. B u n n y且级别为Ye l l o w，使用表达式( $ 1 = = &ldquo; P. B u n n y &rdquo; &amp; &amp;$ 4
= = &ldquo; Ye l l o w &rdquo; )，意为&amp; &amp;两边匹配均为真。完整命令如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if ($1==&ldquo;P.Bunny&rdquo; &amp;&amp; $4==&ldquo;Yellow&rdquo;) print $0}&rsquo;
grade.txt<br />
P.Bunny 02/99 48 Yellow 12 35 28</p>

<p><strong>12. Or</strong><br />
如果查询级别为Ye l l o w或B r o w n，使用或命令。意为“ | |”符号两边的匹配模式之一或全部为真。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{if ($4==&ldquo;Yellow&rdquo; || $4~/Brown/) print $0}&rsquo;
grade.txt<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p>原来不一定得加print,下面我自己对例一二做了一下</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>1<br />
[root@Linux_chenwy sam]# awk &lsquo;$4~/Brown/&rsquo; grade.txt<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>2<br />
[root@Linux_chenwy sam]# awk &lsquo;$3==&ldquo;48&rdquo;&rsquo; grade.txt<br />
P.Bunny 02/99 48 Yellow 12 35 28</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$3=&ldquo;48&rdquo;&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48 Green 8 40 44<br />
J.Lulu 06/99 48 green 9 24 26<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 48 Brown-3 12 26 26<br />
L.Tansl 05/99 48 Brown-2 12 30 28</p>

<p>2中，我把=和==写错了，呵呵，一个是赋值，一个是等于</p>

<p><strong>awk内置变量</strong><br />
a w k有许多内置变量用来设置环境信息。这些变量可以被改变。表9 - 3显示了最常使用的一些变量，并给出其基本含义。</p>

<p>QUOTE:</p>

<p>awk内置变量<br />
A R G C 命令行参数个数<br />
A R G V 命令行参数排列<br />
E N V I R O N 支持队列中系统环境变量的使用<br />
FILENAME a w k浏览的文件名<br />
F N R 浏览文件的记录数<br />
F S 设置输入域分隔符，等价于命令行- F选项<br />
N F 浏览记录的域个数<br />
N R 已读的记录数<br />
O F S 输出域分隔符<br />
O R S 输出记录分隔符<br />
R S 控制记录分隔符</p>

<p>QUOTE:</p>

<p>A R G C支持命令行中传入a w k脚本的参数个数。A R G V是A R G C的参数排列数组，其中每一元素表示为A R G V [ n
]，n为期望访问的命令行参数。</p>

<p>E N V I R O N 支持系统设置的环境变量，要访问单独变量，使用实际变量名，例如E N V I R O N [“E D I TO R”]
=“Vi”。</p>

<p>F I L E N A M E支持a w k脚本实际操作的输入文件。因为a w
k可以同时处理许多文件，因此如果访问了这个变量，将告之系统目前正在浏览的实际文件。</p>

<p>F N R支持a w k目前操作的记录数。其变量值小于等于N R。如果脚本正在访问许多文件，每一新输入文件都将重新设置此变量。</p>

<p>F S用来在a w k中设置域分隔符，与命令行中- F选项功能相同。缺省情况下为空格。如果用逗号来作域分隔符，设置F S = &ldquo;，&rdquo;。</p>

<p>N F支持记录域个数，在记录被读之后再设置。</p>

<p>O F S允许指定输出域分隔符，缺省为空格。如果想设置为#，写入O F S = &ldquo; # &ldquo;。</p>

<p>O R S为输出记录分隔符，缺省为新行（ / n）。</p>

<p>R S是记录分隔符，缺省为新行( / n )。</p>

<p><strong>NF、NR和FILENAME</strong></p>

<p>要快速查看记录个数，应使用N R。比如说导出一个数据库文件后，如果想快速浏览记录个数，以便对比于其初始状态，查出导出过程中出现的错误。使用N
R将打印输入文件的记录个数。print NR放在E N D语法中。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# awk &lsquo;END{print NR}&rsquo; grade.txt<br />
5</p>

<p>如：所有学生记录被打印，并带有其记录号。使用N F变量显示每一条读记录中有多少个域，并在E N D部分打印输入文件名。<br />
[root@chenwy sam]# awk &lsquo;{print NF,NR,$0} END{print FILENAME}&rsquo; grade.txt</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>7 1 M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
7 2 J.Lulu 06/99 48317 green 9 24 26<br />
7 3 P.Bunny 02/99 48 Yellow 12 35 28<br />
7 4 J.Troll 07/99 4842 Brown-3 12 26 26<br />
7 5 L.Tansl 05/99 4712 Brown-2 12 30 28<br />
grade.txt</p>

<p>在从文件中抽取信息时，最好首先检查文件中是否有记录。下面的例子只有在文件中至少有一个记录时才查询B r o w n级别记录。使用A N
D复合语句实现这一功能。意即至少存在一个记录后，查询字符串B r o w n，最后打印结果。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# awk &lsquo;{if (NR&gt;0 &amp;&amp; $4~/Brown/)print $0}&rsquo; grade.txt<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p>N F的一个强大功能是将变量$ P W D的返回值传入a w k并显示其目录。这里需要指定域分隔符/。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# echo $PWD | awk -F/ &lsquo; {print $NF}&rsquo;<br />
sam</p>

<p>另一个例子是显示文件名。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# echo &ldquo;/usr/local/etc/rc.sybase&rdquo; | awk -F/ &lsquo;{print $NF}&rsquo;<br />
rc.sybase</p>

<p>如果不指定域分割符，返回的如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# echo $PWD | awk &lsquo;{print $NF}&rsquo;<br />
/usr/sam<br />
[root@chenwy sam]# echo &ldquo;/usr/local/etc/rc.sybase&rdquo; | awk &lsquo;{print $NF}&rsquo;<br />
/usr/local/etc/rc.sybase</p>

<p><strong>awk操作符</strong><br />
在a w k中使用操作符，基本表达式可以划分为数字型、字符串型、变量型、域及数组元素，前面已经讲过一些。下面列出其完整列表。</p>

<p>在表达式中可以使用下述任何一种操作符。</p>

<p>QUOTE:</p>

<p>= += *= / = %= ^ = 赋值操作符<br />
？ 条件表达操作符<br />
|| &amp;&amp; ! 并、与、非（上一节已讲到）<br />
~!~ 匹配操作符，包括匹配和不匹配<br />
&lt; &lt;= == != &gt;&gt; 关系操作符<br />
+ - * / % ^ 算术操作符<br />
+ + &ndash; 前缀和后缀</p>

<p>前面已经讲到了其中几种操作，下面继续讲述未涉及的部分。</p>

<p><strong>1. 设置输入域到域变量名</strong><br />
在a w k中，设置有意义的域名是一种好习惯，在进行模式匹配或关系操作时更容易理解。<br />
一般的变量名设置方式为n a m e = $ n，这里n a m e为调用的域变量名， n为实际域号。例如设置学生域名为n a m e，级别域名为b e l
t，操作为n a m e = $ 1 ; b e l t s = $ 4。注意分号的使用，它分隔a w k命令。下面例子中，重新赋值学生名域为n a m
e，级别域为b e l t s。查询级别为Ye l l o w的记录，并最终打印名称和级别。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;{name=$1;belts=$4;if(belts ~/Yellow/) print name&rdquo; is
belt &ldquo;belts}&rsquo; grade.txt<br />
P.Bunny is belt Yellow</p>

<p><strong>2. 域值比较操作</strong><br />
有两种方式测试一数值域是否小于另一数值域。<br />
1) 在B E G I N中给变量名赋值。<br />
2) 在关系操作中使用实际数值。<br />
通常在B E G I N部分赋值是很有益的，可以在a w k表达式进行改动时减少很多麻烦。<br />
使用关系操作必须用圆括号括起来。<br />
下面的例子查询所有比赛中得分在2 7点以下的学生。<br />
用引号将数字引用起来是可选的，“2 7”、2 7产生同样的结果。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;{if ($6 M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26</p>

<p>第二个例子中给数字赋以变量名B A S E L I N E和在B E G I N部分给变量赋值，两者意义相同。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;BEGIN{BASELINE=&ldquo;27&rdquo;} {if ($6 J.Lulu 06/99 48317 green 9
24 26<br />
J.Troll 07/99 4842 Brown-3 12 26 26</p>

<p><strong>3. 修改数值域取值</strong><br />
当在a w k中修改任何域时，重要的一点是要记住实际输入文件是不可修改的，修改的只是保存在缓存里的a w k复本。a w k会在变量N R或N
F变量中反映出修改痕迹。<br />
为修改数值域，简单的给域标识重赋新值，如： $ 1 = $ 1 + 5，会将域1数值加5，但要确保赋值域其子集为数值型。<br />
修改M . Ta n s l e y的目前级别分域，使其数值从4 0减为3 9，使用赋值语句$ 6 = $ 6 - 1，当然在实施修改前首先要匹配域名。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;{if($1==&ldquo;M.Tans&rdquo;) {$6=$6-1};print $1,$6,$7}&rsquo; grade.txt<br />
M.Tans 39 44<br />
J.Lulu 24 26<br />
P.Bunny 35 28<br />
J.Troll 26 26<br />
L.Tansl 30 28</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;{if($1==&ldquo;M.Tans&rdquo;) {$6=$6-1;print $1,$6,$7}}&rsquo; grade.txt<br />
M.Tans 39 44</p>

<p><strong>4. 修改文本域</strong><br />
修改文本域即对其重新赋值。需要做的就是赋给一个新的字符串。在J . Tr o l l中加入字母，使其成为J . L . Tr o l l，表达式为$ 1 =
&ldquo; J . L . Tr o l l &ldquo;，记住字符串要使用双秒号（ &rdquo; &ldquo;），并用圆括号括起整个语法。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;{if($1==&ldquo;J.Troll&rdquo;) $1=&ldquo;J.L.Troll&rdquo;; print $1}&rsquo; grade.txt<br />
M.Tans<br />
J.Lulu<br />
P.Bunny<br />
J.L.Troll<br />
L.Tansl</p>

<p><strong>5. 只显示修改记录</strong><br />
上述例子均是对一个小文件的域进行修改，因此打印出所有记录查看修改部分不成问题，但如果文件很大，记录甚至超过1 0
0，打印所有记录只为查看修改部分显然不合情理。在模式后面使用花括号将只打印修改部分。取得模式，再根据模式结果实施操作，可能有些抽象，现举一例，只
打印修改部分。注意花括号的位置。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;{if($1==&ldquo;J.Troll&rdquo;) {$1=&ldquo;J.L.Troll&rdquo;; print $1}}&rsquo;
grade.txt<br />
J.L.Troll</p>

<p><strong>不知道为什么，我这里多了一个空行？</strong></p>

<p><strong>6. 创建新的输出域</strong><br />
在a w k中处理数据时，基于各域进行计算时创建新域是一种好习惯。创建新域要通过其他域赋予新域标识符。如创建一个基于其他域的加法新域{ $ 4 = $ 2
+ $ 3 }，这里假定记录包含3个域，则域4为新建域，保存域2和域3相加结果。<br />
在文件g r a d e . t x t中创建新域8保存域目前级别分与域最高级别分的减法值。表达式为‘{ $ 8 = $ 7 - $ 6
}’，语法首先测试域目前级别分小于域最高级别分。新域因此只打印其值大于零的学生名称及其新域值。在B E G I N部分加入t a b键以对齐报告头。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;BEGIN{print &ldquo;Name/tDifference&rdquo;}{if($6 Name Difference<br />
M.Tans 4<br />
J.Lulu 2</p>

<p>当然可以创建新域，并赋给其更有意义的变量名。例如：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;BEGIN{print &ldquo;Name/tDifference&rdquo;}{if($6 Name Difference<br />
M.Tans 4<br />
J.Lulu 2</p>

<p><strong>7. 增加列值</strong><br />
为增加列数或进行运行结果统计，使用符号+ =。增加的结果赋给符号左边变量值，增加到变量的域在符号右边。例如将$ 1加入变量t o t a l，表达式为t o
t a l + = $ 1。列值增加很有用。许多文件都要求统计总数，但输出其统计结果十分繁琐。在a w k中这很简单，请看下面的例子。<br />
将所有学生的‘目前级别分’加在一起，方法是t o t + = $ 6，t o t即为a w k浏览的整个文件的域6结果总和。所有记录读完后，在E N
D部分加入一些提示信息及域6总和。不必在a w k中显示说明打印所有记录，每一个操作匹配时，这是缺省动作。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;(tot+=$6); END{print &ldquo;Club student total points :&rdquo;
tot}&rsquo;<br />
grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28<br />
Club student total points :155</p>

<p>如果文件很大，你只想打印结果部分而不是所有记录，在语句的外面加上圆括号（）即可。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;{(tot+=$6)}; END{print &ldquo;Club student total points :&rdquo;
tot}&rsquo; grade.txt<br />
Club student total points :155</p>

<p><strong>8. 文件长度相加</strong><br />
在目录中查看文件时，如果想快速查看所有文件的长度及其总和，但要排除子目录，使用ls -l命令，然后管道输出到a w k，a w
k首先剔除首字符为d（使用正则表达式）的记录，然后将文件长度列相加，并输出每一文件长度及在E N D部分输出所有文件的长度。<br />
本例中，首先用ls
-l命令查看一下文件属性。注意第二个文件属性首字符为d，说明它是一个目录，文件长度是第5列，文件名是第9列。如果系统不是这样排列文件名及其长度，应适时加以改变。<br />
下面的正则表达式表明必须匹配行首，并排除字符d，表达式为^ [ ^ d ]。<br />
使用此模式打印文件名及其长度，然后将各长度相加放入变量t o t中。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ ls -l | awk &lsquo;/^[^d]/ {print $9&rdquo;/t&rdquo;$5} {tot+=$5} END {print
&ldquo;total KB:&rdquo; tot}&rsquo;<br />
&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.<br />
total KB:174144</p>

<p><strong>内置的字符串函数</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>awk内置字符串函数<br />
g s u b ( r, s ) 在整个$ 0中用s替代r<br />
g s u b ( r, s , t ) 在整个t中用s替代r<br />
i n d e x ( s , t ) 返回s中字符串t的第一位置<br />
l e n g t h ( s ) 返回s长度<br />
m a t c h ( s , r ) 测试s是否包含匹配r的字符串<br />
s p l i t ( s , a , f s ) 在f s上将s分成序列a<br />
s p r i n t ( f m t , e x p ) 返回经f m t格式化后的e x p<br />
s u b ( r, s ) 用$ 0中最左边最长的子串代替s<br />
s u b s t r ( s , p ) 返回字符串s中从p开始的后缀部分<br />
s u b s t r ( s , p , n ) 返回字符串s中从p开始长度为n的后缀部分</p>

<p><strong>g s u b函数</strong> 有点类似于s e d查找和替换。它允许替换一个字符串或字符为另一个字符串或字符，并以正则表达式的形式执行。第一个函数作用于记录$
0，第二个g s u b函数允许指定目标，然而，如果未指定目标，缺省为$ 0。<br />
<strong>i n d e x（s，t）函数</strong> 返回目标字符串s中查询字符串t的首位置。l e n g t h函数返回字符串s字符长度。<br />
<strong>m a t c h函数</strong> 测试字符串s是否包含一个正则表达式r定义的匹配。s p l i t使用域分隔符f s将字符串s划分为指定序列a。<br />
<strong>s p r i n t函数</strong> 类似于p r i n t f函数（以后涉及），返回基本输出格式f m t的结果字符串e x p。<br />
<strong>s u b（r，s）函数</strong> 将用s替代$ 0中最左边最长的子串，该子串被（ r）匹配。<br />
<strong>s u b（s，p）</strong> 返回字符串s在位置p后的后缀。s u b s t r（s，p，n）同上，并指定子串长度为n。<br />
现在看一看a w k中这些字符串函数的功能。</p>

<p><strong>1. gsub</strong><br />
要在整个记录中替换一个字符串为另一个，使用正则表达式格式， /目标模式/，替换模式/。例如改变学生序号4 8 4 2到4 8 9 9：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy root]# cd /usr/sam<br />
[root@Linux_chenwy sam]# awk &lsquo;gsub(/4842/,4899){print $0}&rsquo; grade.txt<br />
J.Troll 07/99 4899 Brown-3 12 26 26</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;gsub(/4842/,4899)&rsquo; grade.txt<br />
J.Troll 07/99 4899 Brown-3 12 26 26</p>

<p><strong>2. index</strong><br />
查询字符串s中t出现的第一位置。必须用双引号将字符串括起来。例如返回目标字符串B u n n y中n y出现的第一位置，即字符个数。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;BEGIN {print index(&ldquo;Bunny&rdquo;,&ldquo;ny&rdquo;)}&rsquo; grade.txt<br />
4</p>

<p><strong>3. length</strong><br />
返回所需字符串长度，例如检验字符串J . Tr o l l返回名字及其长度，即人名构成的字符个数</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$1==&ldquo;J.Troll&rdquo; {print length($1)&rdquo; &ldquo;$1}&rsquo; grade.txt<br />
7 J.Troll</p>

<p>还有一种方法，这里字符串加双引号。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;BEGIN{print length(&ldquo;A FEW GOOD MEN&rdquo;)}&rsquo;<br />
14</p>

<p><strong>4. match</strong><br />
m a t c h测试目标字符串是否包含查找字符的一部分。可以对查找部分使用正则表达式，返回值为成功出现的字符排列数。如果未找到，返回0，第一个例子在A N
C D中查找d。因其不存在，所以返回0。第二个例子在A N C D中查找D。因其存在，所以返回A N C D中D出现的首位置字符数。第三个例子在学生J .
L u l u中查找u。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;BEGIN{print match(&ldquo;ANCD&rdquo;,/d/)}&rsquo;<br />
0<br />
[root@Linux_chenwy sam]# awk &lsquo;BEGIN{print match(&ldquo;ANCD&rdquo;,/D/)}&rsquo;<br />
4<br />
[root@Linux_chenwy sam]# awk &lsquo;$1==&ldquo;J.Lulu&rdquo; {print match($1,&ldquo;u&rdquo;)}&rsquo; grade.txt<br />
4</p>

<p><strong>5. split</strong><br />
使用s p l i t返回字符串数组元素个数。工作方式如下：如果有一字符串，包含一指定分隔符- ，例如A D2 - K P 9 - J U 2 - L P
- 1，将之划分成一个数组。使用s p l i t，指定分隔符及数组名。此例中，命令格式为( &ldquo; A D 2 - K P 9 - J U 2 - L P -
1 &ldquo;，p a r t s _ a r r a y，&rdquo; - &ldquo;），s p l i t然后返回数组下标数，这里结果为4。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;BEGIN {print
split(&ldquo;123-456-789&rdquo;,pats_array,&ldquo;-&rdquo;)}&lsquo;3</p>

<p>还有一个例子使用不同的分隔符。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;BEGIN {print split(&ldquo;123#456#789&rdquo;,myarray,&ldquo;#&rdquo;)}&rsquo;
3</p>

<p>这个例子中，s p l i t返回数组m y a r r a y的下标数。数组m y a r r a y取值如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>myarray[1]=123<br />
myarray[2]=456<br />
myarray[3]=789</p>

<p>结尾部分讲述数组概念。</p>

<p><strong>6. sub</strong><br />
使用s u b发现并替换模式的第一次出现位置。字符串S T R包含‘poped popo pill’，执行下列s u b命令s u b（/ o p /，&rdquo;
o p &ldquo;，S T R）。模式o p第一次出现时，进行替换操作，返回结果如下：‘pO Ped pope pill’。</p>

<p>如：学生J . Tr o l l的记录有两个值一样，“目前级别分”与“最高级别分”。只改变第一个为2 9，第二个仍为2 4不动，操作命令为s u b（/ 2
6 /，&rdquo; 2 9 &ldquo;，$ 0），只替换第一个出现2 4的位置。注意J . Tr o l l记录需存在。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$1==&ldquo;J.Troll&rdquo; sub(/26/,&ldquo;29&rdquo;,$0)&rsquo; grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 29<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 29 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28</p>

<p><strong>7. substr</strong><br />
s u b s t r是一个很有用的函数。它按照起始位置及长度返回字符串的一部分。例子如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$1==&ldquo;L.Tansl&rdquo; {print substr($1,1,3)}&rsquo; grade.txt<br />
L.T</p>

<p>上面例子中，指定在域1的第一个字符开始，返回其前面5个字符。</p>

<p>如果给定长度值远大于字符串长度， a w k将从起始位置返回所有字符，要抽取L Ta n s l - e
y的姓，只需从第3个字符开始返回长度为7。可以输入长度9 9，a w k返回结果相同。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;$1==&ldquo;L.Tansl&rdquo; {print substr($1,1,99)}&rsquo; grade.txt<br />
L.Tansl</p>

<p>s u b s t
r的另一种形式是返回字符串后缀或指定位置后面字符。这里需要给出指定字符串及其返回字串的起始位置。例如，从文本文件中抽取姓氏，需操作域1，并从第三个字符开始：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;{print substr($1,3)}&rsquo; grade.txt<br />
Tans<br />
Lulu<br />
Bunny<br />
Troll<br />
Tansl</p>

<p>还有一个例子，在B E G I N部分定义字符串，在E N D部分返回从第t个字符开始抽取的子串。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# awk &lsquo;BEGIN{STR=&ldquo;A FEW GOOD MEN&rdquo;}END{print
substr(STR,7)}&rsquo; grade.txt<br />
GOOD MEN</p>

<p><strong>8. 从s h e l l中向a w k传入字符串</strong><br />
a w k脚本大多只有一行，其中很少是字符串表示的。大多要求在一行内完成a w k脚本，这一点通过将变量传入a w k命令行会变得很容易。现就其基本原理讲<br />
述一些例子。<br />
使用管道将字符串s t a n d - b y传入a w k，返回其长度。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# echo &ldquo;Stand-by&rdquo; | awk &lsquo;{print length($0)}&rsquo;<br />
8</p>

<p>设置文件名为一变量，管道输出到a w k，返回不带扩展名的文件名。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# STR=&ldquo;mydoc.txt&rdquo;<br />
[root@Linux_chenwy sam]# echo $STR|awk &lsquo;{print substr($STR,1,5)}&rsquo;<br />
mydoc</p>

<p>设置文件名为一变量，管道输出到a w k，只返回其扩展名。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# STR=&ldquo;mydoc.txt&rdquo;<br />
[root@Linux_chenwy sam]# echo $STR|awk &lsquo;{print substr($STR,7)}&rsquo;<br />
txt</p>

<p><strong>字符串屏蔽序列</strong></p>

<p>使用字符串或正则表达式时，有时需要在输出中加入一新行或查询一元字符。<br />
打印一新行时，（新行为字符/ n），给出其屏蔽序列，以不失其特殊含义，用法为在字符串前加入反斜线。例如使用/ n强迫打印一新行。<br />
如果使用正则表达式，查询花括号（ { }），在字符前加反斜线，如/ / { /，将在a w k中失掉其特殊含义。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>awk中使用的屏蔽序列<br />
/ b 退格键<br />
/ t t a b键<br />
/ f 走纸换页<br />
/ d d d 八进制值<br />
/ n 新行<br />
/ c 任意其他特殊字符，例如/ /为反斜线符号<br />
/ r 回车键</p>

<p>使用上述符号，打印May Day，中间夹t a b键，后跟两个新行，再打印May Day，但这次使用八进制数1 0 4、1 4 1、1 7
1、分别代表D、a、y。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# awk &lsquo;BEGIN {print&rdquo;/n/May/tDay/n/nMay/t/104/141/171&rdquo;}&rsquo;</p>

<p>May Day</p>

<p>May Day</p>

<p>注意，/ 1 0 4为D的八进制A S C I I码，/ 1 4 1为a的八进制A S C I I码，等等。</p>

<p><strong>awk输出函数printf</strong><br />
目前为止，所有例子的输出都是直接到屏幕，除了t a b键以外没有任何格式。a w k提供函数p r i n t
f，拥有几种不同的格式化输出功能。例如按列输出、左对齐或右对齐方式。<br />
每一种p r i n t f函数（格式控制字符）都以一个%符号开始，以一个决定转换的字符结束.转换包含三种修饰符。<br />
p r i n t f函数基本语法是p r i n t f（[格式控制符]，参数），格式控制字符通常在引号里。</p>

<p><strong>printf修饰符</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>- 左对齐<br />
Wi d t h 域的步长，用0表示0步长<br />
. p r e c 最大字符串长度，或小数点右边的位数<br />
表9-7 awk printf格式<br />
% c A S C I I字符<br />
% d 整数<br />
% e 浮点数，科学记数法<br />
% f 浮点数，例如（1 2 3 . 4 4）<br />
% g a w k决定使用哪种浮点数转换e或者f<br />
% o 八进制数<br />
% s 字符串<br />
% x 十六进制数</p>

<p><strong>1. 字符转换</strong><br />
观察A S C I I码中6 5的等价值。管道输出6 5到a w k。p r i n t f进行A S C I
I码字符转换。这里也加入换行，因为缺省情况下p r i n t f不做换行动作。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>A[sam@chenwy sam]$ echo &ldquo;65&rdquo; | awk &lsquo;{printf &ldquo;%c/n&rdquo;,$0}&rsquo;<br />
A</p>

<p>按同样方式使用a w k得到同样结果。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;BEGIN{printf &ldquo;%c/n&rdquo;,65}&rsquo;<br />
A</p>

<p>所有的字符转换都是一样的，下面的例子表示进行浮点数转换后‘ 9 9 9’的输出结果。整数传入后被加了六个小数点。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ awk &lsquo;BEGIN{printf &ldquo;%f/n&rdquo;,999}&rsquo;<br />
999.000000</p>

<p><strong>2. 格式化输出</strong><br />
打印所有的学生名字和序列号，要求名字左对齐， 1 5个字符长度，后跟序列号。注意/ n换行符放在最后一个指示符后面。输出将自动分成两列。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# awk &lsquo;{printf &ldquo;%-15s %s/n&rdquo;,$1,$3}&rsquo; grade.txt<br />
M.Tans 48311<br />
J.Lulu 48317<br />
P.Bunny 48<br />
J.Troll 4842<br />
L.Tansl 4712</p>

<p>加入一些文本注释帮助理解报文含义。可在正文前嵌入头信息。注意这里使用p r i n t加入头信息。如果愿意，也可使用p r i n t f。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# awk &lsquo;BEGIN{print &ldquo;Name/t/tS.Number&rdquo;}{printf &ldquo;%-15s
%s/n&rdquo;,$1,$3}&rsquo; grade.txt<br />
Name S.Number<br />
M.Tans 48311<br />
J.Lulu 48317<br />
P.Bunny 48<br />
J.Troll 4842<br />
L.Tansl 4712</p>

<p><strong>3.向一行a w k命令传值</strong><br />
在查看a w k脚本前，先来查看怎样在a w k命令行中传递变量。<br />
在a w k执行前将值传入a w k变量，需要将变量放在命令行中，格式如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>awk 命令变量=输入文件值</p>

<p>（后面会讲到怎样传递变量到a w k脚本中）。<br />
下面的例子在命令行中设置变量A G E等于1 0，然后传入a w k中，查询年龄在1 0岁以下的所有学生。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# awk &lsquo;{if ($5 M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26</p>

<p>要 快速查看文件系统空间容量，观察其是否达到一定水平，可使用下面a w
k一行脚本。因为要监视的已使用空间容量不断在变化，可以在命令行指定一个触发值。首先用管道命令将df -k 传入a w
k，然后抽出第4列，即剩余可利用空间容量。使用$ 4 ~ / ^ [ 0 - 9 ] /取得容量数值（1 0 2 4块）而不是d
f的文件头，然后对命令行与‘ i f ( $ 4 &lt; T R I G G E R )’上变量T R I G G E R中指定<br />
的值进行查询测试。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# df -k|awk &lsquo;{if($4 /boot 458589<br />
/dev/shm 99352</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# df -k|awk &lsquo;($4~/<sup class="footnote-ref" id="fnref:0-9"><a href="#fn:0-9">1</a></sup>/) {if($4 / 2610716<br />
/boot 458589<br />
/dev/shm 99352</p>

<p>($4~/<sup class="footnote-ref" id="fnref:0-9"><a href="#fn:0-9">2</a></sup>/)好像没什么用</p>

<p>在系统中使用df -k命令，产生下列信息：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@chenwy sam]# df -k<br />
文件系统 1K-块 已用 可用 已用% 挂载点<br />
/dev/sda2 5162828 2289804 2610764 47% /<br />
/dev/sda1 497829 13538 458589 3% /boot<br />
none 99352 0 99352 0% /dev/shm</p>

<p>如果系统中d f输出格式不同，必须相应改变列号以适应工作系统。<br />
当然可以使用管道将值传入a w k。本例使用w h o命令， w h o命令第一列包含注册用户名，这里打印注册用户，并加入一定信息。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ who |awk &lsquo;{print $1&rdquo; is logged on&rdquo;}&rsquo;<br />
root is logged on<br />
root is logged on<br />
[sam@chenwy sam]$ who<br />
root :0 Nov 23 20:17<br />
root pts/0 Nov 23 20:25 (:0.0)</p>

<p>a w k也允许传入环境变量。下面的例子使用环境变量HOME支持当前用户目录。可从pwd命令管道输出到a w k中获得相应信息。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ pwd | awk &lsquo;{if ($1==derr) print $1}&rsquo; derr=$HOME<br />
/usr/sam</p>

<p><strong>4. awk脚本文件</strong><br />
可以将a w k脚本写入一个文件再执行它。命令不必很长（尽管这是写入一个脚本文件的主要原因），甚至可以接受一行命令。这样可以保存a w
k命令，以使不必每次使用时都需要重新输入。使用文件的另一个好处是可以增加注释，以便于理解脚本的真正用途和功能。<br />
使用前面的几个例子，将之转换成a w k可执行文件。像原来做的一样，将学生目前级别分相加awk ‘（t o t + = $ 6） END{print
&ldquo;club student total points：&rdquo; t o t }’ g r a d e . t x t。<br />
创建新文件s t u d e n t _ t o t . a w k，给所有a w k程序加入a w
k扩展名是一种好习惯，这样通过查看文件名就知道这是一个a w k程序。文本如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ cat student_tot.awk<br />
#!/bin/awk -f<br />
#all commnet lines must start with a hash &lsquo;#&rsquo;<br />
#name:students_tots.awk<br />
#to call:student_tot.awk grade.txt<br />
#prints total and average of club student points</p>

<p>#print a header first<br />
BEGIN{<br />
print &ldquo;Student Date Member No. Grade Age Points Max&rdquo;<br />
print &ldquo;Name Joined Gained Point Available&rdquo;<br />
print &ldquo;==============================================================&rdquo;<br />
}<br />
#let&rsquo;s add the scores of points gained<br />
(tot+=$6)</p>

<p>#finished proessing now let&rsquo;s print the total and average point<br />
END{<br />
print &ldquo;Club student total points :&rdquo; tot<br />
print &ldquo;Average Club Student Points:&rdquo; tot/NR}</p>

<p>通过将命令分开，脚本可读性提高，还可以在命令之间加入注释。这里加入头<br />
信息和结尾的平均值。基本上这是一个一行脚本文件。<br />
执行时，在脚本文件后键入输入文件名，但是首先要对脚本文件加入可执行权限。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@chenwy sam]$ chmod u+x student_tot.awk<br />
[sam@chenwy sam]$./student_tot.awk grade.txt<br />
Student Date Member No. Grade Age Points Max</p>

<h1 id="name-joined-gained-point-available">Name Joined Gained Point Available</h1>

<p>M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26<br />
P.Bunny 02/99 48 Yellow 12 35 28<br />
J.Troll 07/99 4842 Brown-3 12 26 26<br />
L.Tansl 05/99 4712 Brown-2 12 30 28<br />
Club student total points :155<br />
Average Club Student Points:31</p>

<p><strong>过滤相同行：</strong><br />
如有一个文件strip中有多条重复错误提法：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat strip<br />
etreiytrpytyu<br />
ERROR*<br />
ERROR*<br />
ERROR*<br />
ERROR*<br />
IUEWROPYJRTMELUYK<br />
ERROR*<br />
ERROR*<br />
ERROR*<br />
ERROR*<br />
ERROR*<br />
ERROR*<br />
EWUTIRWJYHT<br />
ERROR*<br />
ERROR*<br />
JGIOERYO56ERU<br />
ERROR*<br />
ERROR*<br />
ERROR*<br />
JGEORYKP65EKU;YK,</p>

<p>现在用a w k脚本过滤出错误行的出现频率，使得每一个失败记录只对应一个错误行。awk脚本如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat error_strip.awk<br />
#!/bin/awk -f<br />
#error_strip.awk<br />
#to call:error_strip.awk<br />
#strips out the ERROR* lines if there are more than one<br />
#ERROR* lines after each failed record.</p>

<p>BEGIN {error_line=&ldquo;&rdquo;}<br />
#tell awk the whole is &ldquo;ERROR<em>&rdquo;<br />
{if ($0==&ldquo;ERROR</em>&rdquo; &amp;&amp; error_line==&ldquo;ERROR*&ldquo;)</p>

<p>#go to next line<br />
next;<br />
error_line=$0;print}</p>

<p>执行结果如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ ./error_strip.awk strip<br />
etreiytrpytyu<br />
ERROR*<br />
IUEWROPYJRTMELUYK<br />
ERROR*<br />
EWUTIRWJYHT<br />
ERROR*<br />
JGIOERYO56ERU<br />
ERROR*<br />
JGEORYKP65EKU;YK,</p>

<p><strong>5. 在a w k中使用F S变量</strong><br />
如果使用非空格符做域分隔符（ F S）浏览文件，例如# 或：，编写这样的一行命令很容易，因为使用F S选项可以在命令行中指定域分隔符。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>$awk -F: &lsquo;{print $0}&rsquo; inputfile</p>

<p>使用a w k脚本时，记住设置F S变量是在B E G I N部分。如果不这样做， a w k将会发生混淆，不知道域分隔符是什么。<br />
下述脚本指定F S变量。脚本从/ e t c / p a s s w d文件中抽取第1和第5域，通过分号“;”分隔p a s s w
d文件域。第1域是帐号名，第5域是帐号所有者。<br />
<strong>我举的例子是第七个域：</strong></p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ awk -F: &lsquo;{print $1,&ldquo;/t&rdquo;,$7}&rsquo; passwd<br />
root /bin/bash<br />
bin /sbin/nologin<br />
daemon /sbin/nologin<br />
adm /sbin/nologin<br />
lp /sbin/nologin<br />
sync /bin/sync<br />
&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p>这是不用脚本的，后面的结果省略</p>

<p>现使用脚本如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat passwd.awk<br />
#!/bin/awk -f<br />
#to call:passwd.awk /etc/passwd<br />
#print out the first and seventh fields<br />
BEGIN{<br />
FS=&rdquo;:&ldquo;}<br />
{print $1,&ldquo;/t&rdquo;,$7}</p>

<p>结果如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ chmod u+x passwd.awk<br />
[sam@Linux_chenwy sam]$ ./passwd.awk passwd<br />
root /bin/bash<br />
bin /sbin/nologin<br />
daemon /sbin/nologin<br />
adm /sbin/nologin<br />
lp /sbin/nologin<br />
sync /bin/sync<br />
&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>

<p><strong>6. 向a w k脚本传值</strong><br />
向a w k脚本传值与向a w k一行命令传值方式大体相同，格式为：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>awk script_file var=value input_file</p>

<p>下述脚本对比检查文件中域号和指定数字。这里使用了N F变量M A X，表示指定检查的域号，使用双引号将域分隔符括起来，即使它是一个空格。<br />
脚本如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat fieldcheck.awk<br />
#!/bin/awk -f<br />
#check on how many fields in a file<br />
#name:fieldcheck.awk<br />
#to call:fieldcheck MAX=n FS= filename</p>

<p>NF!=MAX{<br />
print(&ldquo;line&rdquo; NR &ldquo; does not have &rdquo; MAX &ldquo;fields&rdquo;)}</p>

<p>如果NF中的值不等于最大MAX值，则打印出&rdquo;哪一行的域总数不是max&rdquo;</p>

<p>如果以/ e t c / p a s s w d作输入文件（p a s s w d文件有7个域），运行上述脚本。参数格式如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ chmod u+x fieldcheck.awk<br />
[sam@Linux_chenwy sam]$ ./fieldcheck.awk MAX=7 FS=&rdquo;:&rdquo; passwd</p>

<p>正好7个域，如果改成6，就会显示不同结果，试试看？</p>

<p>使用前面一行脚本的例子，将之转换成a w k脚本如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat name.awk<br />
#!/bin/awk -f<br />
#name:age.awk<br />
#to call:age.awk AGE=n grade.txt<br />
#print ages that are lower than the age supplied on the comand line<br />
{if ($5 print $0}</p>

<p>文本包括了比实际命令更多的信息，没关系，仔细研读文本后，就可以精确知道其功能及如何调用它。<br />
不要忘了增加脚本的可执行权限，然后将变量和赋值放在命令行脚本名字后、输入文件前执行。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ chmod u+x name.awk<br />
[sam@Linux_chenwy sam]$ ./name.awk AGE=10 grade.txt<br />
M.Tans <sup>5</sup>&frasl;<sub>99</sub> 48311 Green 8 40 44<br />
J.Lulu 06/99 48317 green 9 24 26</p>

<p>同样可以使用前面提到的管道命令传值，下述a w k脚本从d u命令获得输入，并输出块和字节数。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# cat duawk.awk<br />
#!/bin/awk -f<br />
#to call:du|duawk.awk<br />
#prints file/direc&rsquo;s in bytes and blocks<br />
BEGIN{<br />
OFS=&ldquo;/t&rdquo;;<br />
print &ldquo;name&rdquo; &ldquo;/t/t&rdquo;,&ldquo;bytes&rdquo;,&ldquo;blocks/n&rdquo;<br />
print &ldquo;===============================&rdquo;}<br />
{print $2,&ldquo;/t/t&rdquo;,$1*512,$1}</p>

<p>使用du的结果如下</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# du<br />
12 ./.kde/Autostart<br />
16 ./.kde<br />
8 ./.xemacs<br />
4 ./sam<br />
4 ./dir1<br />
4 ./file6<br />
184 .</p>

<p>执行：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[root@Linux_chenwy sam]# du | ./duawk.awk<br />
name bytes blocks</p>

<p>===============================<br />
./.kde/Autostart 6144 12<br />
./.kde 8192 16<br />
./.xemacs 4096 8<br />
./sam 2048 4<br />
./dir1 2048 4<br />
./file6 2048 4<br />
. 94208 184</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>OFS=&ldquo;/t&rdquo;;</p>

<p>是什么意思了，好累，晚上再研究，谁解答一下更好</p>

<p><strong>数组</strong><br />
前面讲述s p l i t函数时，提到怎样使用它将元素划分进一个数组。这里还有一个例子：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ awk &lsquo;BEGIN {print split(&ldquo;123#456#789&rdquo;,myarray,&ldquo;#&rdquo;)}&rsquo;<br />
3</p>

<p>实际上m y a r r a y数组为</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>Myarray[1]=&ldquo;123&rdquo;<br />
Myarray[2]=&ldquo;456&rdquo;<br />
Myarray[3]=&ldquo;789&rdquo;</p>

<p>数组使用前，不必定义，也不必指定数组元素个数。经常使用循环来访问数组。下面是一种循环类型的基本结构：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>For (element in array ) print array[element]</p>

<p>对于记录“ 1 2 3 # 4 5 6 # 6 7 8”，先使用s p l i t函数划分它，再使用循环打印各数组元素。操作脚本如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat arraytest.awk<br />
#!/bin/awk -f<br />
#name:arraytest.awk<br />
#prints out an array<br />
BEGIN{<br />
record=&ldquo;123#456#789&rdquo;;<br />
split(record,myarray,&ldquo;#&rdquo;)}<br />
END{for (i in myarray) {print myarray[i]}}</p>

<p>要运行脚本，使用/ d e v / n u l l作为输入文件。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>sam@Linux_chenwy sam]$chmod u+x arraytest.awk<br />
[sam@Linux_chenwy sam]$ ./arraytest.awk /dev/null<br />
123<br />
456<br />
789<br />
[sam@Linux_chenwy sam]$</p>

<p><strong>数组和记录</strong><br />
上面的例子讲述怎样通过s p l i t函数使用数组。也可以预先定义数组，并使用它与域进行比较测试，下面的例子中将使用更多的数组。<br />
下面是从空手道数据库卸载的一部分数据，包含了学生级别及是否是成人或未成年人的信息，有两个域，分隔符为（ #），文件如下：</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat grade_student.txt<br />
Yellow#Junior<br />
Orange#Senior<br />
Yellor#Junior<br />
Purple#Junior<br />
Brown-2#Junior<br />
White#Senior<br />
Orange#Senior<br />
Red#Junior<br />
Red#Junior<br />
Brown-2#Senior<br />
Yellow#Senior<br />
Red#Junior<br />
Blue#Senior<br />
Green#Senior<br />
Purple#Junior<br />
White#Junior</p>

<p>脚本功能是读文件并输出下列信息。<br />
1) 俱乐部中Ye l l o w、O r a n g e和R e d级别的人各是多少。<br />
2 ) 俱乐部中有多少成年人和未成年人。<br />
查看文件，也许2 0秒内就会猜出答案，但是如果记录超过6 0个又怎么办呢？这不会很容易就看出来，必须使用a w k脚本。<br />
首先看看a w k脚本，然后做进一步讲解。</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ cat belts.awk<br />
#!/bin/awk -f<br />
#name:belts.awk<br />
#to call:belts.awk grade2.txt<br />
#loops through the grade2.txt file and counts how many<br />
#belts we have in (yellow,orange,red)<br />
#also count how many adults and juniors we have</p>

<p>#start of BEGIN<br />
#set FS and load the arrays with our values</p>

<p>#B E G I N部分设置F S为符号#，即域分隔符</p>

<p>BEGIN{FS=&ldquo;#&rdquo;</p>

<p>#Load the belt colours we are interested in only<br />
#因为要查找Ye l l o w、O r a n g e和R e d三个级别。<br />
#然后在脚本中手工建立数组下标对学生做同样的操作。<br />
#注意，脚本到此只有下标或元素，并没有给数组名本身加任何注释。</p>

<p>belt[&ldquo;Yellow&rdquo;]<br />
belt[&ldquo;Orange&rdquo;]<br />
belt[&ldquo;Red&rdquo;]<br />
#end of BEGIN<br />
#load the student type<br />
student[&ldquo;Junior&rdquo;]<br />
student[&ldquo;Senior&rdquo;]<br />
}</p>

<p>##初始化完成后， B E G I N部分结束。记住B E G I N部分并没有文件处理操作。</p>

<p>#loop thru array that holds the belt colours against field-1<br />
#if we have a match,keep a running total</p>

<p>#现在可以处理文件了。<br />
#首先给数组命名为c o l o r，使用循环语句测试域1级别列是否<br />
#等于数组元素之一（Ye l l o w、O r a n g e或R e d），<br />
#如果匹配，依照匹配元素将运行总数保存进数组。</p>

<p>{for (colour in belt)<br />
{if($1==colour)<br />
belt[colour]++}}</p>

<p>#loop thru array that holds the student type against<br />
#field-2 if we have a match,keep a runing total</p>

<p>#同样处理数组‘ S e n i o r _ o r _ j u n i o r’，<br />
#浏览域2时匹配操作满足，运行总数存入j u n i o r或s e n i o r的匹配数组元素。</p>

<p>{for (senior_or_junior in student)<br />
{if ($2==senior_or_junior)<br />
student[senior_or_junior]++}}</p>

<p>#finished processing so print out the matches..for each array</p>

<p>#E N D部分打印浏览结果，对每一个数组使用循环语句并打印它。</p>

<p>END{for (colour in belt )print &ldquo;The club has &ldquo;,belt[colour],colour,&ldquo;Belts&rdquo;</p>

<p>#注意在打印语句末尾有一个/符号，用来通知a w k（或相关脚本）命令持续到下一行，<br />
#当输入一个很长的命令，并且想分行输入时可使用这种方法。</p>

<p>for (senior_or_junior in student) print &ldquo;The club has &ldquo;,/<br />
student[senior_or_junior],senior_or_junior,&ldquo;student&rdquo;}</p>

<p>运行脚本前记住要加入可执行权限</p>

<p>[Copy to clipboard] [ - ]</p>

<p>CODE:</p>

<p>[sam@Linux_chenwy sam]$ chmod u+x belts.awk<br />
[sam@Linux_chenwy sam]$ ./belts.awk grade_student.txt<br />
The club has 3 Red Belts<br />
The club has 2 Orange Belts<br />
The club has 2 Yellow Belts<br />
The club has 7 Senior student<br />
The club has 9 Junior student</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:0-9">0-9 <a class="footnote-return" href="#fnref:0-9"><sup>[return]</sup></a></li>
<li id="fn:0-9">0-9 <a class="footnote-return" href="#fnref:0-9"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>