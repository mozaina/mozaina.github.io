<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux命令行与Shell脚本编程大全读书笔记 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux命令行与Shell脚本编程大全读书笔记 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux命令行与Shell脚本编程大全读书笔记">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux命令行与Shell脚本编程大全读书笔记</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>Linux内核4大主要功能：</p>

<p>内存管理</p>

<p>进程管理</p>

<p>设备管理</p>

<p>文件系统管理</p>

<p>Linux系统启动的进程和脚本管理</p>

<p>1./etc/inittab 管理系统开机时会自动启动的进程</p>

<p>2./etc/init.d
管理开机时启动或停止某个应用的脚本放在这个目录下，/etc/rcX.d目录在启动时，所有加载的脚本都是init.d下脚本的link</p>

<p><strong>Linux</strong> <strong>命令集合</strong></p>

<p>1.ipcs -m 查看系统上的当前共享内存页面</p>

<p>2.cp -R dir1 dir2: 递归的复制dir1到dir2</p>

<p>cp -f test* dir2：将所有以test开头的文件复制到dir2，-f参数用来强制覆盖dir2目录中已有的同名文件，而不会提示用户</p>

<p>cp -a old/. new/：将old目录下的所有文件拷贝到new，包括隐藏文件</p>

<p>cp -l test1 test4:  创建了test1的硬链接文件test4，实际上二者标示的是同一个文件，因二者的节点号是相同的</p>

<p>cp -s test1 test5：创建了test1的软链接文件test5。链接文件只要存储源文件的信息，并不需要存储源文件中的数据</p>

<p>ln -s test1 test5 ln -l test1 test4  可以达到和上述类似的效果</p>

<ol>
<li>rm -rf dir2：删除dir2目录及其子目录和文件</li>
<li>stat test1：查看文件统计信息</li>
<li>file test1：查看文件类型，包括ASCII文本文件；Shell脚本文件；二进制可执行文件</li>
<li>cat -n 1.txt 查看1.txt的内容，且给文本的每行加上行号</li>
</ol>

<p>cat -b 1.txt  与上述指令的区别，只在文本非空白行加上行号</p>

<p>cat -s 1.txt  压缩文本中连续的多个空白行为一个空白行</p>

<p>more 1.tx  查看文本文件的内容，空格键可以翻页； 回车键可以显示下一行</p>

<ol>
<li>ps -aux：可以查看当前系统所有进程的详细信息</li>
</ol>

<p>ps l: 查看当前控制台下属于当前用户的进程信息</p>

<p>可以在上述指令后增加参数 - -forest，可以看到进程之间的启动关系</p>

<p>进程信息中STAT列含义如下：</p>

<p>&lt;：该进程运行在高优先级</p>

<p>N：该进程运行在低优先级</p>

<p>L：该进程有页面锁定在内存中</p>

<p>s：该进程是个控制进程</p>

<p>l：该进程是多线程的</p>

<p>+：该进程运行在前端</p>

<ol>
<li>top指令设置刷新间隔为2秒: top -d 2</li>
<li>df -h: 显示某个设备上还有多少磁盘空间</li>
<li>du -h: 显示某一个目录下各个子目录的空间</li>
<li>printenv:打印当前shell所在的全局变量</li>
<li>set：显示为某个特定进程设置的所有环境变量（包括全局变量）</li>
<li>export 变量名：可以导出当前的局部变量成为全局变量 如：export test</li>
<li>变量定义注意事项：环境变量名称、等号和值之间没有空格；如果赋值一个含有空格的字符串，必须用单引号将字符串扩起来</li>
</ol>

<p>15. unset：删除环境变量，如：unset test. 注意：在shell子进程中unset的全局环境变量，在父进程中该环境变量依然有效。</p>

<ol>
<li>PATH：定义了命令行输入命令的搜索路径。</li>
<li>/etc/profile 是每个shell启动时，默认的主启动文件</li>
<li>每个用户的shell启动脚本，有如下三者中的一种：$HOME/.bash_profile $HOME/.bash_login $HOME/.profile 这三个文件会加载$HOME目录下的.bashrc的启动脚本，.bashrc会加载/etc目录下的bashrc文件，同时$/HOME/.bashrc可以作为用户自定义脚本执行的地方。</li>
<li>alias -p 可以查看已有的命令别名列表</li>
<li>查看Flash分区信息：cat /proc/mtd（显示分区名称、大小） cat /proc/partition（显示block）</li>
<li>在shell中显示提示而不换行，如：echo -n “This is a test string: ”</li>
<li>在shell中显示$符号，需要按照转义处理。如：echo “test print \$15”</li>
<li>在shell中使用反引号，可以获取命令的输出结果，然后赋值给一个变量。如：test=<code>date</code> test变量内容即为date的输出</li>
<li>IFS：内部字段分隔符，该环境变量定义了bash shell用作字段分隔符的一系列字符。可以如下方式使用该变量：</li>
</ol>

<p>IFS.OLD=$IFS</p>

<p>IFS=$’\n’</p>

<p>IFS=$IFS.OLD</p>

<ol>
<li><strong>$</strong>* <strong>变量：把所有参数当成一个参数，而不是多个参数；</strong> <strong>$@</strong> <strong>变量：会单独处理每个参数，所有参数当做同一字符串中的多个独立的单词</strong></li>
<li>最后一个参数的表现方式：</li>
</ol>

<p><strong>params=$#</strong></p>

<p><strong>echo the last parameter is $params</strong></p>

<p><strong>echo the last parameter is ${!#}</strong></p>

<ol>
<li><strong>使用</strong> <strong>$</strong> <strong>和方括号将数学表达式圈起来：</strong> <strong>var1=$[1+(2*5)]</strong></li>
<li>bc:浮点计算器</li>
<li>$?: 该变量用来保存上个执行命令的退出状态码，退出码0，表示命令成功结束；非0，表示命令异常结束</li>
<li>exit：该命令可以在shell结束时，指定一个退出状态码。该值取值范围0~255，如果指定返回大于255，会被系统自动取模后的结果，作为退出状态码</li>
<li>if-then语句格式一：</li>
</ol>

<p>if command</p>

<p>then</p>

<p>commands</p>

<p>fi</p>

<ol>
<li>if-then语句格式二(在command之后增加一个分号)：</li>
</ol>

<p>if command: then</p>

<p>commands</p>

<p>fi</p>

<ol>
<li>if-then-else格式：</li>
</ol>

<p>if command</p>

<p>then</p>

<p>commands</p>

<p>else</p>

<p>commands</p>

<p>fi</p>

<ol>
<li>嵌套if( elif )</li>
</ol>

<p>if command1</p>

<p>then</p>

<p>commands</p>

<p>elif command2</p>

<p>then</p>

<p>commands</p>

<p>fi</p>

<ol>
<li>test：上述if的条件判断都是根据命令的执行退出状态码来执行，如果想执行条件判断，需要使用test命令，或者使用[ ]</li>
<li>if条件判断命令格式一：</li>
</ol>

<p>if test condition</p>

<p>then</p>

<p>commands</p>

<p>fi</p>

<ol>
<li>if条件判断命令格式二：</li>
</ol>

<p>if [ condition ]</p>

<p>then</p>

<p>commands</p>

<p>fi</p>

<ol>
<li>test命令可以判断3类条件：数值比较、字符串比较、文件比较</li>
<li>test数值比较功能：</li>
</ol>

<p>n1 -eq n2  检查n1是否等于n2</p>

<p>n1 -ge n2  检查n1是否大于或等于n2</p>

<p>n1 -gt n2  检查n1是否大于n2</p>

<p>n1 -le n2  检查n1是否小于或等于n2</p>

<p>n1 -lt n2  检查n1是否小于n2</p>

<p>n1 -ne n2  检查n1是否不等于n2</p>

<ol>
<li>test字符串比较功能：</li>
</ol>

<p>str1 = str2  检查str1是否与str2相同</p>

<p>str1 != str2  检查str1是否与str2不同</p>

<p>str1 &lt; str2  检查str1是否比str2小（在使用时，需要对于符号转义，如：if [ $val1 &lt; $val2 ]）</p>

<p>str1 &gt; str2  检查str1是否比str2大（在使用时，需要对于符号转义，如：if [ $val1 &gt; $val2 ]）</p>

<p><strong>-n str1</strong> <strong>检查</strong> <strong>str1</strong> <strong>的长度是否大于</strong> <strong>0</strong></p>

<p><strong>-z str1</strong> <strong>检查</strong> <strong>str1</strong> <strong>的长度是否为</strong> <strong>0</strong></p>

<p>注：在test命令中，大写字母会小于小写字母，这是因为test使用标准ASCII顺序，即小写字母的ASCII值会大于大写字母的ASCII值</p>

<p>sort命令排序时，小写字母的会排在前面</p>

<ol>
<li>test文件较功能：</li>
</ol>

<p>-d file  检查file是否存在并且是一个目录</p>

<p>-e file  检查file是否存在</p>

<p>-f file  检查file是否存在并且是一个文件</p>

<p>-s file  检查file是否存在并且非空</p>

<p>-r file  检查file是否存在并且可读</p>

<p>-w file  检查file是否存在并且可写</p>

<p>-x file  检查file是否存在并且可执行</p>

<p>-O file  检查file是否存在并属于当前用户所有</p>

<p>-G file  检查file是否存在并与当前用户有相同的组</p>

<p>file1 -nt file2  检查file1是否比file2新</p>

<p>file1 -ot file2  检查file1是否比file2旧</p>

<p>-b file 若文件存在且是一个块特殊文件，则为真</p>

<p>-c file 若文件存在且是一个字符特殊文件，则为真</p>

<p>-d file 若文件存在且是一个目录，则为真</p>

<p>-e file 若文件存在，则为真</p>

<p>-f file 若文件存在且为一个规则文件，则为真</p>

<p>-g file 若文件存在且设置了SGID位的值，则为真</p>

<p>-h file 若文件存在且为一个符号链接，则为真</p>

<p>-k file 若文件存在且设置了“sticky”位的值，则为真</p>

<p>-p file 若文件存在且为一已命名管道，则为真</p>

<p>-s file 若文件存在且其大小大于零，则为真</p>

<p>-u file 若文件存在且设置了SUID位的值，则为真</p>

<p>-r file 若文件存在且可读，则为真</p>

<p>-w file 若文件存在且可写，则为真</p>

<p>-x file 若文件存在且可执行，则为真</p>

<p>-o file 若文件存在且被有效用户ID所拥有，则为真</p>

<p>$# 是传给脚本的参数个数</p>

<p>$0 是脚本本身的名字</p>

<p>$1 是传递给该shell脚本的第一个参数</p>

<p>$2 是传递给该shell脚本的第二个参数 （注意：对于多过9个参数，需要在数字周围加花括号，如第10个参数: ${10}）</p>

<p>$@ 是传给脚本的所有参数的列表</p>

<p>$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</p>

<p>$$ 是脚本运行的当前进程ID号</p>

<p>$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>

<p>$-记录着当前设置的shell选项</p>

<ol>
<li>复合条件测试：</li>
</ol>

<p>[ condition1 ] &amp;&amp; [ condition2 ]  只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp;右边的命令才会被执行</p>

<p>[ condition1 ] || [ condition2 ]</p>

<ol>
<li>test使用标准数学运算符</li>
</ol>

<p>if (( $val1 ** 2 &gt; 90))  双括号中的特殊字符，如 &lt; 和 &gt; 不再需要转义，就可以直接使用了</p>

<ol>
<li>双括号中命令符号</li>
</ol>

<p>val++  后增</p>

<p>val- -  后减</p>

<p>++val  先增</p>

<p>- -val  先减</p>

<p>**  幂运算</p>

<p>&lt;&lt; 左移位</p>

<blockquote>
<blockquote>
<p>右移位</p>
</blockquote>
</blockquote>

<p>&amp;&amp; 逻辑与</p>

<p>||  逻辑或</p>

<p>！ 逻辑非</p>

<p>&amp; 位与</p>

<p>|  位或</p>

<p>~  位求反</p>

<ol>
<li>test使用字符串模式匹配比较</li>
</ol>

<p>if [[ $USER == r* ]] $USER环境变量是否是以字母r开头的</p>

<ol>
<li>case命令</li>
</ol>

<p>case variable in</p>

<p>pattern1 | pattern2)</p>

<p>commands1;;</p>

<p>pattern3)</p>

<p>commands2;;</p>

<p>*)</p>

<p>default commands;;</p>

<p>esac</p>

<ol>
<li>for命令</li>
</ol>

<p>for var in list</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<ol>
<li>for命令中使用通配符</li>
</ol>

<p>for file in /home/rich/test/*</p>

<p>do</p>

<p>echo “test file $file”</p>

<p>done</p>

<ol>
<li>C语言风格for命令</li>
</ol>

<p>for (( i=1; i &lt;= 10; i++))</p>

<p>do</p>

<p>echo “test…”</p>

<p>done</p>

<ol>
<li>while 命令</li>
</ol>

<p>while test command</p>

<p>do</p>

<p>other commands</p>

<p>done</p>

<p>如：</p>

<p>while [ $val1 -gt 0]</p>

<p>do</p>

<p>echo $val1</p>

<p>var1=$[$var1 - 1]</p>

<p>done</p>

<p>注意：while命令允许你在while语句行定义多个测试命令，但只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环</p>

<p>51.until 命令</p>

<p>until test command</p>

<p>do</p>

<p>other commands</p>

<p>done</p>

<p>注意：until命令要求你指定一个通常输出非零退出码的测试命令。（非零，表示测试条件尚不成立）</p>

<p>52.break 跳出多重循环</p>

<p>break n</p>

<p>这里n 说明了要跳出的循环层级。默认情况下，n为1，表明跳出的是当前的循环。</p>

<p>如果将n 设置为2，break命令就会停止下一级的外部循环</p>

<ol>
<li>continue 继续循环</li>
</ol>

<p>continue n</p>

<p>这里n 定义了要继续的循环层级。</p>

<p>如 continue 2 表示跳出当前循环，继续外层的循环</p>

<p>54.要在shell脚本的参数值中包含空格，需要把有空格的参数用单引号或双引号括起来</p>

<p>55.basename命令会只返回程序名而不包括路径</p>

<p>如： name=<code>basename $0</code></p>

<p>56.shift 命令</p>

<p>默认情况下，这个命令会将命令前移，如，变量$3的值会移到$2</p>

<p>shift的好处：不知道参数个数，可以利用shift指令，只操作第一个参数$1,只需要在循环中每次shift，同时判断$1是否为空（while [ -n
“$1” ]）</p>

<p>shift n</p>

<p>表明要移动几个位置，如shift 2 :  移动2个位置</p>

<p>注意：当使用shift时，一个参数被移除后，它的值会被丢掉，且无法恢复</p>

<p>57.getopt 命令</p>

<p>处理命令行选项和参数时非常方便的工具</p>

<p>格式：</p>

<p>getopt options optstring parameters</p>

<p>options：如 -q选项，可以在命令执行时忽略错误信息</p>

<p>optstring：是这个过程的关键，定义了命令行有效的选项字母，还定义了那些选项字母需要参数值。 <strong>每个需要参数的选项字母后加一个冒号。</strong></p>

<p>例如：</p>

<p>getopt -q ab:cd -a -b test1 -c -d test2 test3</p>

<p>执行结果：-a -b test1 -c -d - - test2 test3</p>

<p>这里- - 表示分开行中的额外参数</p>

<ol>
<li>getopts 命令</li>
</ol>

<p>getopt的命令中，选项字母的参数值是不能有空格的，而 getopts就可以解决该问题</p>

<p>格式：</p>

<p>getopts opstring variable</p>

<p>opstring: 有效字母都会列在其中，如果选项字母要求有个参数，就加一个冒号。 <strong>要去掉错误消息，可以在</strong> <strong>opstring</strong>
<strong>之前加一个冒号。</strong></p>

<p><strong>例如：</strong></p>

<p>getopts :ab:c -a -b “test1 test2“ -c</p>

<p>59.read命令</p>

<p>（1）基本的读取</p>

<p>例如1：</p>

<p>echo -n “Enter you name: ” -n  选项会移除掉字符串末尾的换行符，允许用户紧跟其后输入数据</p>

<p>read name  读取的数据存储到$name中了</p>

<p>例如2：</p>

<p>read -p “please enter you age: ” age -p选项，允许你直接在read命令行中指定提示字符，读取的数据存储到 $age</p>

<p>(2)超时处理</p>

<p>例如1：</p>

<p>read -t 5 -p “please enter you name: ” name -t选项指定了read命令等待输入的秒数</p>

<p>例如2：</p>

<p>read -n1 -p “Do you want to continue [Y/N] ?” answer -n1选项，表明read读取单个字符后退出</p>

<p>（3）隐藏读取（多用于密码）</p>

<p>read -s -p “Enter you password: ” pass
-s选项，阻止将数据显示在显示器上，实际上只是将输入文本颜色设置成和背景色一样罢了</p>

<p>（4）从文件中读取</p>

<p>cat test | while read line  将从cat的 test文件内容，每次read都读取一行，将一行内容存储到变量$line</p>

<p><strong>60.</strong> <strong>查看系统的所有线程</strong></p>

<p>（1）ps -T</p>

<p>（2）top之后输入h，可以查看各个线程对于CPU的占用</p>

<p>61.重定向描述符</p>

<p>例如1：同时重定向错误和数据</p>

<p>ls -al test test2 test3 2&gt;test6 1&gt;test7</p>

<p>重定向错误到test6；重定向输出到test7</p>

<p>例如2：重定向输入</p>

<p>cat &lt; testfile</p>

<p>强制cat命令接收来自非STDIN的文件的输入</p>

<p>62.重定向输出和错误 &amp;&gt;</p>

<p>例如：</p>

<p>ls -al test test2 test3 &amp;&gt; test7</p>

<p>将ls的结果，包括可能的错误输出都重定向到文件test7中</p>

<p>63.临时重定向输出到错误STDERR &gt;&amp;2</p>

<p>例如：</p>

<p>echo “This is an error” &gt;&amp;2</p>

<p>64.永久重定向 exec命令</p>

<p>在shell脚本中，使用exec命令，永久重定向shell执行期间的特定描述符</p>

<p>例如1：脚本中重定向输出</p>

<p>exec 1&gt;testout</p>

<p>exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中所有发给STDOUT的输出，都会被重定向到testout文件中</p>

<p>例如2：脚本中重定向输入</p>

<p>exec 0&lt; testfile</p>

<p>这个命令告诉shell它应该从文件testfile中获得输入，而不是STDIN</p>

<p>65.阻止命令输入，重定向到/dev/null</p>

<p>这种情况，在脚本运行在后台时很常见。shell输入到null的任何数据都不会保存，这些数据都被丢掉了。</p>

<p>例如1：</p>

<p>ls -al &gt; /dev/null</p>

<p>例如2：阻止任何错误都不保存</p>

<p>ls -al badfile test6 2&gt; /dev/null</p>

<p>例如3： **&gt; /dev/null 2&gt;&amp;1 **</p>

<p>shell中可能经常能看到：&gt;/dev/null 2&gt;&amp;1</p>

<p>命令的结果可以通过%&gt;的形式来定义输出</p>

<p>/dev/null 代表空设备文件</p>

<blockquote>
<p>代表重定向到哪里，例如：echo &ldquo;123&rdquo; &gt; /home/123.txt</p>
</blockquote>

<p>1 表示stdout标准输出，系统默认值是1，所以&rdquo;&gt;/dev/null&rdquo;等同于&rdquo;1&gt;/dev/null&rdquo;</p>

<p>2 表示stderr标准错误</p>

<p>&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p>

<p>那么本文标题的语句：</p>

<p>1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。</p>

<p>2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p>

<p>66.快速移除现有文件数据</p>

<p>输入重定向时，将/dev/null作为输入文件。由于/dev/null文件不含有任何内容，程序员通常用它来快速移除现有文件中的数据，而不用先删除再创建文件。</p>

<p>例如：</p>

<p>cat /dev/null &gt; testfile</p>

<p>文件testfile仍然存在系统上，但现在它是空文件。</p>

<p>67.mktemp命令</p>

<p>在/tmp目录下创建临时文件</p>

<p>例如1：创建本地临时文件</p>

<p>mktemp testing.XXXXXX</p>

<p>mktemp命令会用6个字符码替换这6个X，从而保证文件名在目录中是唯一的。</p>

<p>例如2：创建临时文件时，返回全路径</p>

<p>tempfile = <code>mktemp -t tmp.XXXXXX</code></p>

<p>后续可以在任何目录下，通过tempfile来引用新创建的临时文件了，因此时获知了全路径</p>

<p>例如3：创建临时目录</p>

<p>tempdir =<code>mktemp -d dir.XXXXXX</code></p>

<p>后续可以再tempdir这个临时目录下创建自己的临时文件。</p>

<p>68.tee命令</p>

<p>将输入一边发送到显示器，一边发送到tee命令指定的文件中</p>

<p>例如1：</p>

<p>date | tee testfile</p>

<p>date的执行结果，既显示在屏幕上，又存储到文件testfile中</p>

<p>例如2：tee追加存储</p>

<p>date | tee -a testfile</p>

<p>想testfile中追加新的date的数据。没有-a选项，则每次执行tee，都会覆盖文件的内容</p>

<p>69.信号处理</p>

<p>SIGHUP 挂起进程，当终端断开时，将发送该信号给终端控制进程</p>

<p>SIGINT 终止进程（ctrl + c）终端驱动程序将发送该信号给前台进程组</p>

<p>SIGQUIT 停止进程（ctrl + \）该信号将发往前台进程组，并生成可用于调试的核心转储文件。在进程陷入死循环时，可以触发该信号调试</p>

<p>SIGKILL 无条件终止进程</p>

<p>SIGTERM 可能的话终止进程 kill和killall命令所发送的默认信号。</p>

<p>SIGSTOP 无条件停止进程，但不是终止进程</p>

<p>SIGTSTP 停止或暂停进程，但不终止进程（ctrl + z） 作业控制的停止信号，发送信号给前台进程组，使其停止运行。</p>

<p>SIGCONT 继续运行停止的进程</p>

<p>shell默认情况下，会忽略收到的 SIGQUIT和 SIGTERM信号。正因为这样，交互式shell才不会被意外终止。</p>

<p>用户有时会使用kill -KILL  或者killall -9
显式向进程发送SIGKILL信号。然而这一做法通常是错误的。精心的设计应用程序应当为SIGTERM信号设置处理器程序，以便于其能够预先清除临时文件和释放其他资源，从而全身而退。</p>

<p>发送SIGKILL信号可以杀掉某个进程，从而绕开了SIGTERM信号的处理程序。因此，总是应该首先尝试使用SIGTERM信号来终止进程，而把SIGKILL信号作为最后手段，去对付那些不响应SIGTERM信号的失控进程</p>

<p>SIGKILL 和 SIGSTOP信号，是一个必执行信号。处理器程序无法将其阻塞、忽略或者捕获，故而总能成功执行。</p>

<ol>
<li>shell中捕捉信号</li>
</ol>

<p>trap commands signals</p>

<p>例如：</p>

<p>trap “echo ‘Sorry！I have trapped Ctrl-C’” SIGINT SIGTERM</p>

<p>trap在每次检测到SIGINT或 SIGTERM信号时显示一行简单的文本消息。</p>

<p>一般trap 指令放置在shell执行的正文第一行，在捕捉到信号后，自动执行。</p>

<ol>
<li>grep命令</li>
</ol>

<p>grep -q -e &ldquo;No medium found&rdquo; -e &ldquo;No such file or directory&rdquo;</p>

<p>说明：</p>

<p>-q：安静模式，不打印任何标准输出。如果有匹配的内容则立即返回状态值0。</p>

<p>-e：并列使用多个 -e参数可以实现或条件，同时查询多个条件，满足其中之一即可。</p>

<p>72.函数</p>

<p>（1）函数定义两种形式：</p>

<p>function name {</p>

<p>commands</p>

<p>}</p>

<p>name( ){</p>

<p>commands</p>

<p>}</p>

<p>(2)函数的返回值</p>

<p>情况一：</p>

<p>函数中最后一条命令的退出状态码，作为函数的退出状态码</p>

<p>情况二：</p>

<p>return 命令来退出函数并返回特定的退出状态码</p>

<p>注：函数的退出状态码必须小于256，大于256将返回一个错误</p>

<p>(3)函数的输出保存到shell变量中</p>

<p>如：result=<code>testfunc</code></p>

<p>这条命令将testfunc函数的输出付给$result变量。</p>

<p>这种方法，可以用来从函数返回大于256的返回值，只需要在函数的最后用echo将结果输出即可。</p>

<p>如：echo $[$value * 2]</p>

<p>(4)函数中使用变量</p>

<p>情况一：</p>

<p>向函数传递变量，bash shell会将函数当做小脚本来对待。</p>

<p>如：</p>

<p>value=<code>addfunc 10 15</code></p>

<p>向函数addfunc传递了两个参数10和15</p>

<p>情况二：</p>

<p>由于函数使用特殊参数环境变量作为自己的参数值，它不能直接从脚本的命令行获取脚本的参数值。即脚本的参数如$1，与函数的$1不同。</p>

<p>情况三：全局变量和局部变量</p>

<p>在shell脚本中任何地方定义的变量都是全局变量；</p>

<p>在函数内部使用local声明的变量，都是局部变量。</p>

<p>例如：local temp</p>

<ol>
<li><strong>shell中的${}，##和%%的使用</strong></li>
</ol>

<p>假设我们定义了一个变量为：<br />
file=/dir1/dir2/dir3/my.file.txt</p>

<p>可以用${ }分别替换得到不同的值：<br />
${file#<em>/}：删掉第一个 /及其左边的字符串：dir1/dir2/dir3/my.file.txt<br />
${file##</em>/}：删掉最后一个 / 及其左边的字符串：my.file.txt<br />
${file#<em>.}：删掉第一个 . 及其左边的字符串：file.txt<br />
${file##</em>.}：删掉最后一个 . 及其左边的字符串：txt<br />
${file%/<em>}：删掉最后一个 / 及其右边的字符串：/dir1/dir2/dir3<br />
${file%%/</em>}：删掉第一个 / 及其右边的字符串：(空值)<br />
${file%.<em>}：删掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file<br />
${file%%.</em>}：删掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my</p>

<p>记忆的方法为：</p>

<h1 id="是-去掉左边-键盘上-在-的左边">是 去掉左边（键盘上#在 $的左边）</h1>

<p>%是去掉右边（键盘上%  在$ 的右边）<br />
单一符号是最小匹配；两个符号是最大匹配<br />
${file:0:5}：提取最左边的 5个字节：/dir1<br />
${file:5:5}：提取第 5个字节右边的连续5个字节：/dir2</p>

<p>也可以对变量值里的字符串作替换：<br />
${file/dir/path}：将第一个dir替换为path：/path1/dir2/dir3/my.file.txt<br />
${file//dir/path}：将全部dir替换为 path：/path1/path2/path3/my.file.txt</p>

<p>利用 ${ }  还可针对不同的变数状态赋值(沒设定、空值、非空值)：<br />
${file-my.file.txt} ：假如 $file沒有设定，則使用 my.file.txt作传回值。(空值及非空值時不作处理)<br />
${file:-my.file.txt}  ：假如 $file 沒有設定或為空值，則使用 my.file.txt作傳回值。 (非空值時不作处理)<br />
${file+my.file.txt} ：假如 $file設為空值或非空值，均使用 my.file.txt作傳回值。(沒設定時不作处理)<br />
${file:+my.file.txt}  ：若 $file 為非空值，則使用 my.file.txt作傳回值。 (沒設定及空值時不作处理)<br />
${file=my.file.txt} ：若 $file沒設定，則使用 my.file.txt作傳回值，同時將 $file賦值為
my.file.txt。(空值及非空值時不作处理)<br />
${file:=my.file.txt}  ：若 $file 沒設定或為空值，則使用 my.file.txt作傳回值，同時將
$file賦值為my.file.txt。 (非空值時不作处理)<br />
${file?my.file.txt} ：若 $file沒設定，則將 my.file.txt輸出至 STDERR。 (空值及非空值時不作处理)</p>

<p>${file:?my.file.txt}  ：若 $file 没设定或为空值，则将 my.file.txt输出至 STDERR。 (非空值時不作处理)</p>

<p>${#var} 可计算出变量值的长度：</p>

<p>${#file} 可得到 27，因为/dir1/dir2/dir3/my.file.txt是27个字节</p>

<p><strong>Shell重定向＆ &gt;file、2&gt;&amp;1、1&gt;&amp;2的区别</strong></p>

<p>0表示标准输入<br />
1表示标准输出<br />
2表示标准错误输出<br />
&gt; 默认为标准输出重定向，与 1&gt; 相同<br />
2&gt;&amp;1 意思是把 标准错误输出 重定向到 标准输出.<br />
&amp;&gt;file 意思是把 标准输出 和 标准错误输出 都重定向到文件file中</p>

<p><strong>1 &gt;/dev/null 2&gt;&amp;1</strong> <strong>的含义</strong></p>

<p>shell中可能经常能看到：&gt;/dev/null 2&gt;&amp;1</p>

<p>命令的结果可以通过%&gt;的形式来定义输出</p>

<p>/dev/null 代表空设备文件<br />
&gt; 代表重定向到哪里，例如：echo &ldquo;123&rdquo; &gt; /home/123.txt<br />
1 表示stdout标准输出，系统默认值是1，所以&rdquo;&gt;/dev/null&rdquo;等同于&rdquo;1&gt;/dev/null&rdquo;<br />
2 表示stderr标准错误<br />
&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p>

<p>那么本文标题的语句：<br />
1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。<br />
2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p>

<p><strong>/dev/null</strong> <strong>的用途</strong> ****</p>

<p>/dev/null
，从名称上可以很显然看出是一个空文件（写入到/dev/null时全部丢失，读取/dev/null时自己返回EOF），那么你会很疑惑，他到底有什么用途呢，请看下文听我讲解，可能你在很多脚本里看过
/dev/null，具体总结下几种常见用途.</p>

<p>一、禁止标准输出.</p>

<p>eg:</p>

<p>cat $filename &gt;/dev/null</p>

<h1 id="文件内容丢失-不会输出到标准输出">文件内容丢失，不会输出到标准输出，.</h1>

<p>二、禁止标准错误</p>

<p>eg:</p>

<p>rm $badname 2&gt;/dev/null</p>

<p>#删除文件错误时，不会再有提示到终端，都丢到/dev/null里去了</p>

<p>三、禁止标准输出和标准错误的输出.</p>

<p>eg1:</p>

<p>cat $filename 2&gt;/dev/null &gt;/dev/null</p>

<h1 id="如果-filename-不存在-将不会有任何错误信息提示">如果&rdquo;$filename&rdquo;不存在，将不会有任何错误信息提示.</h1>

<h1 id="如果-filename-存在-文件的内容不会打印到标准输出">如果&rdquo;$filename&rdquo;存在, 文件的内容不会打印到标准输出.</h1>

<h1 id="因此-上面的代码根本不会输出任何信息">因此, 上面的代码根本不会输出任何信息.</h1>

<h1 id="当只想测试命令的退出码而不想有任何输出时非常有用">当只想测试命令的退出码而不想有任何输出时非常有用。</h1>

<p>eg2:</p>

<p>#&mdash;&mdash;&mdash;&ndash;测试命令的退出 begin &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-#</p>

<p>ls dddd 2&gt;/dev/null 8</p>

<p>echo $? //输出命令退出代码：0为命令正常执行，1-255为有出错。</p>

<p>#&mdash;&mdash;&mdash;&ndash;测试命令的退出 end&mdash;&mdash;&mdash;&ndash;#</p>

<p>cat $filename &amp;&gt;/dev/null</p>

<p>四、清除日志文件内容</p>

<p>eg:</p>

<p>cat /dev/null &gt; /var/log/messages</p>

<h1 id="var-log-messages-有同样的效果-但不会产生新的进程-因为-是内建的">: &gt; /var/log/messages  有同样的效果, 但不会产生新的进程.（因为:是内建的）</h1>

<p>cat /dev/null &gt; /var/log/wtmp</p>

<p>五、 隐藏cookie而不再使用</p>

<p>eg:</p>

<p>if [ -f ~/.netscape/cookies ] #  如果存在则删除.</p>

<p>then</p>

<p>rm -f ~/.netscape/cookies</p>

<p>fi</p>

<p>ln -s /dev/null ~/.netscape/cookies</p>

<h1 id="现在所有的cookies都会丢弃而不会保存在磁盘上了">现在所有的cookies都会丢弃而不会保存在磁盘上了.</h1>

<p>linux中shell变量$#,$@,$0,$1,$2的含义解释:<br />
变量说明:<br />
$$<br />
Shell本身的PID（ProcessID）<br />
$!<br />
Shell最后运行的后台Process的PID<br />
$?<br />
最后运行的命令的结束代码（返回值）<br />
$-<br />
使用Set命令设定的Flag一览<br />
$*<br />
所有参数列表。如&rdquo;$*&ldquo;用「&rdquo;」括起来的情况、以&rdquo;$1 $2 … $n&rdquo;的形式输出所有参数。<br />
$@<br />
所有参数列表。如&rdquo;$@&ldquo;用「&rdquo;」括起来的情况、以&rdquo;$1&rdquo; &ldquo;$2&rdquo; … &ldquo;$n&rdquo;的形式输出所有参数。<br />
$#<br />
添加到Shell的参数个数<br />
$0<br />
Shell本身的文件名<br />
$1～$n<br />
添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>

<p>【shell】常用语法 -b file -c file -f file-d file -x file</p>

<p>****<strong>【</strong> <strong>shell</strong> <strong>】常用语法</strong> <strong>-b file -c file -f file-d file -x file</strong></p>

<p><strong>一、</strong> <strong>test</strong> <strong>条件判断</strong></p>

<p><strong>1</strong> <strong>，</strong> <strong>test</strong> <strong>文件测试：</strong></p>

<p>-b file 若文件存在且是一个块特殊文件，则为真</p>

<p>-c file 若文件存在且是一个字符特殊文件，则为真</p>

<p>-d file 若文件存在且是一个目录，则为真</p>

<p>-e file 若文件存在，则为真</p>

<p>-f file 若文件存在且为一个规则文件，则为真</p>

<p>-g file 若文件存在且设置了SGID位的值，则为真</p>

<p>-h file 若文件存在且为一个符号链接，则为真</p>

<p>-k file 若文件存在且设置了“sticky”位的值，则为真</p>

<p>-p file 若文件存在且为一已命名管道，则为真</p>

<p>-s file 若文件存在且其大小大于零，则为真</p>

<p>-u file 若文件存在且设置了SUID位的值，则为真</p>

<p>-r file 若文件存在且可读，则为真</p>

<p>-w file 若文件存在且可写，则为真</p>

<p>-x file 若文件存在且可执行，则为真</p>

<p>-o file 若文件存在且被有效用户ID所拥有，则为真</p>

<p><strong>2</strong> <strong>，</strong> <strong>test</strong> <strong>字符串比较</strong></p>

<p>-z string 若string长度为0，则为真</p>

<p>-n string 若string长度不为0，则为真</p>

<p>string1 = string2  若两个字符串相等，则为真</p>

<p>string1 != string2  若两个字符串不相等，则为真</p>

<p><strong>3</strong> <strong>，</strong> <strong>test</strong> <strong>命令的数字比较操作符</strong></p>

<p>int1 -eq int2 若int1等于int2，则为真</p>

<p>int1 –ne int2 若int1不等于int2，则为真</p>

<p>int1 –lt int2 若int1小于int2，则为真</p>

<p>int1 –le int2 若int1小于等于int2，则为真</p>

<p>int1 –gt int2 若int1大于int2，则为真</p>

<p>int1 –ge int2 若int1大于等于int2，则为真</p>

<p><strong>4</strong> <strong>，</strong> <strong>test</strong> <strong>复合表达式</strong></p>

<p>! expr  若expr为假则复合表达式为真。expr可以是任何有效的测试表达式</p>

<p>expr1 -a expr2  若expr1和expr2都为真，则为真</p>

<p>expr1 -o expr2  若expr1和expr2有一个为真，则为真</p>

<p><strong>二、</strong> <strong>shell</strong> <strong>里的特殊变量</strong></p>

<h1 id="sh-usr-local-bkeep-shell-sh-001-002">sh /usr/local/bkeep/shell.sh 001 002</h1>

<p>I&rsquo;m $0 is:/usr/local/bkeep/shell.sh //正在被执行脚本的名字；<code>basename $0</code></p>

<p>I&rsquo;m $1 is:001 //$1接收到的参数</p>

<p>I&rsquo;m $2 is:002 //$2接收到的参数</p>

<p>I&rsquo;m $# is:2 //总共接收到的参数个数</p>

<p>I&rsquo;m $* is:001 002 //把接收到的参数全部打印出来</p>

<p>I&rsquo;m $@ is:001 002 //同上</p>

<p>I&rsquo;m $? is:0 //上一个脚本的退出状态“0”代表正常；“1”非正常退出</p>

<p>I&rsquo;m $$ is:24137 //当前执行脚本的进程ID</p>

<p>I&rsquo;m $! is: //前一个后台进程的id</p>

<p>三:其他</p>

<p>1.返回值 #?</p>

<p>cd dir</p>

<p>echo &ldquo;$?&rdquo;</p>

<p>如果dir存在，则返回0，不存在则返回1.其他函数的命令也是一样，比如diff，等等。</p>

<p>每个命令都会返回一个 exit 状态(有时候也叫return状态).成功返回0,如果返回一个非0值,通<br />
常情况下都会被认为是一个错误码.一个编写良好的UNIX命令,程序,和工具都会返回一个0作为<br />
退出码来表示成功,虽然偶尔也会有例外.</p>

<p>同样的,脚本中的函数和脚本本身都会返回退出状态.在脚本或者是脚本函数中执行的最后的命<br />
令会决定退出状态.在脚本中,exit nnn命令将会把nnn 退出码传递给shell</p>

<p>$?读取最后执行命令的退出码.函数返回后,$?给出函数最后执行的那条命令的退出码.这种给<br />
函数返回值的方法是 Bash  的方法.对于脚本来说也一样.总之,一般情况下,0为成功,非0失败W</p>

<p>2 .</p>

<p>$ 变量替换操作符<br />
只有在变量被声明,赋值,unset或exported 或者是在变量代表一个signal的时候,<br />
变量才会是以本来的面目出现在脚本里.变量在被赋值的时候,可能需要使用&rdquo;=&ldquo;,<br />
read状态或者是在循环的头部.<br />
在&rdquo;&ldquo;中还是会发生变量替换,这被叫做部分引用,或叫弱引用.而在&rdquo;中就不会发生变<br />
量替换,这叫做全引用,也叫强引用.这两个符合在同一个按键上。具体见第5章的讨论.<br />
注意:$var 与${var}的区别,不加{},在某些上下文将引起错误,为了安全,使用2.</p>

<p>还有一个按键在左上角，即按键1的左边。此按键有下面的作用。即将ls -l的结果传给a</p>

<p>17 a=<code>ls -l</code> # 把ls -l的结果给a<br />
18 echo $a # 别忘了,这么引用的话,ls的结果中的所有空白部分都没了(包括换行)<br />
19 echo<br />
20 echo &ldquo;$a&rdquo; # 这么引用就正常了,保留了空白</p>

<p>或者直接</p>

<p>echo &ldquo;$(ls -l)&rdquo; 也可以取出目录</p>

<p>3.</p>

<p>在read  命令状态中<br />
30 echo -n &ldquo;Enter \&ldquo;a\&rdquo; &ldquo;<br />
31 read a<br />
32 echo &ldquo;The value of \&ldquo;a\&rdquo; is now $a.&rdquo;<br />
33<br />
34 echo<br />
35</p>

<p>这个方法可以接受键盘输入到a中。</p>

<p>4.</p>

<p>在一个双引号中直接使用变量名,一般都是没有问题的.它阻止了所有在引号中的特殊字符的<br />
重新解释--包括变量名[2]&ndash;但是$,`和\除外.[3]保留$,作为特殊字符的意义,是为了能够在双<br />
引号中也能够正常地引用变量(&ldquo;$var&rdquo;).这样在&rdquo;&ldquo;中可以使用变量所表达的值(Example 4-1).<br />
使用&rdquo;&ldquo;来防止单词分割.[4]如果在参数列表中使用双引号,将使得双引号中的参数作为一个参<br />
数.即使双引号中的字符串包含多个单词(也就是包含空白部分),也不会变为多个参数,如:<br />
1 variable1=&ldquo;a variable containing five words&rdquo;<br />
2 COMMAND This is $variable1 # COMMAND  将以7 个参数来执行<br />
3 # &ldquo;This&rdquo; &ldquo;is&rdquo; &ldquo;a&rdquo; &ldquo;variable&rdquo; &ldquo;containing&rdquo; &ldquo;five&rdquo; &ldquo;words&rdquo;<br />
4<br />
5 COMMAND &ldquo;This is $variable1&rdquo; # COMMAND  将以1 个参数来执行</p>

<p>5.赋值的方法</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>a：C风格的赋值<br />
7 (( a = 23 )) # 给一个变量赋值,从&rdquo;=&ldquo;两边的空格就能看出这是c风格的处理.<br />
8 echo &ldquo;a (initial value) = $a&rdquo;<br />
9<br />
10 (( a++ )) # 变量&rsquo;a&rsquo;后加1,C风格.<br />
11 echo &ldquo;a (after a++) = $a&rdquo;<br />
12<br />
13 (( a&ndash; )) # 变量&rsquo;a&rsquo;后减1,C风格.<br />
14 echo &ldquo;a (after a&ndash;) = $a&rdquo;</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>37(( t = a&lt;45?7:11 )) # C  风格的3 元操作.<br />
38 echo &ldquo;If a &lt; 45, then t = 7, else t = 11.&rdquo;<br />
39 echo &ldquo;t = $t &rdquo; # Yes!</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>18 LIMIT=10<br />
19<br />
20 for ((a=1; a &lt;= LIMIT ; a++)) # Double parentheses, and &ldquo;LIMIT&rdquo; with no
&ldquo;$&rdquo;.<br />
20 for ((a=1; a &lt;= LIMIT ; a++)) #  双圆括号, 并且&rdquo;LIMIT&rdquo;变量前边没有 &ldquo;$&rdquo;.<br />
21 do<br />
22 echo -n &ldquo;$a &rdquo;<br />
23 done</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>b:let</p>

<p>4 a=2334 # 整型<br />
5 let &ldquo;a += 1&rdquo; #不加双引号也可以<br />
6 echo &ldquo;a = $a &rdquo; # a = 2335</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>c:取变量</p>

<p>5 a=2334</p>

<p>6 a=$(($a+1))</p>

<p>7 echo &ldquo;$a&rdquo; #a=2335</p>

<p>—————————————————————</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>