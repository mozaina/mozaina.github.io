<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>提取知识点bltsignalTerminalshell正则表达式 | 开发者问答集锦</title>
    <meta property="og:title" content="提取知识点bltsignalTerminalshell正则表达式 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="提取知识点bltsignalTerminalshell正则表达式">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/%E6%8F%90%E5%8F%96%E7%9F%A5%E8%AF%86%E7%82%B9bltsignalterminalshell%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">提取知识点bltsignalTerminalshell正则表达式</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p>1023</p>

<p>知识管理：网博士，有道笔记</p>

<p>学习方法：<br />
枪挑一条线，滚扫一大片：<br />
程序员分两类：一种是学过C语言的，一种是没有学过C语言的<br />
读书由薄到厚，再由厚到薄<br />
行业经典（Jolt), cheatsheet refcard<br />
网络是最好的老师<br />
八格亚路（baidu,google,yahoo,bing&hellip;)<br />
blog,weibo,twitter,facebook<br />
公开课<br />
理论与实践：理论上理论都是正确的，实际上并不是<br />
写代码，读代码<br />
sourceforge,google code, github&hellip;</p>

<p>图书：<br />
豆瓣：<a href="http://www.douban.com">http://www.douban.com</a> rocflytosky<br />
<a href="http://book.douban.com/doulist/1345225/">http://book.douban.com/doulist/1345225/</a></p>

<p>1 分析实用程序<br />
/bin, /usr/bin, /usr/local/bin<br />
学习使用工具，分析工具，了解功能和原理<br />
2 学习系统调用<br />
函数和系统调用本质上都是函数。不同的库，不同的头文件<br />
分析需要哪些系统调用，学习系统调用的使用方法：参数？返回值？<br />
3 编程实现<br />
利用上面的原理和一组协同工作的系统调用，自己编程实现使用程序的功能<br />
或积极主动抄代码，学习那些系统调用是协同工作的</p>

<p>C语言的学习可以参考这个思路，实现标准库<br />
伴随我们学习经常要问的三个问题：<br />
能做什么？<br />
如何实现？<br />
自己如何编写？</p>

<p>利用Linux学习Linux编程：<br />
搜索ManPages<br />
man -k<br />
man -k XXX | grep -i YYY<br />
阅读头文件<br />
参阅see also</p>

<p>man who<br />
man -k utmp<br />
man 5 utmp<br />
utmp.h<br />
grep -i XXX -nr /usr/include</p>

<p>链接控制：stty<br />
文件 ：磁盘文件和设备的抽象</p>

<p>stty:显示，设置终端属性<br />
设备和文件<br />
文件：数据，属性，目录中的名字<br />
设备：文件名，i-node，文件所有者，权限，修改时间</p>

<p>设备:<br />
ls -C /dev | head<br />
设备和系统调用<br />
int fd;<br />
fd = open(&ldquo;/dev/tape&rdquo;, O_RDONLY);<br />
lseek(fd, (long)4096, SEEK_SET);<br />
n = read(fd, buf, buflen);<br />
close(fd);</p>

<p>终端设备就像文件<br />
终端：键盘和显示单元。功能接收用户输入，并将输出信息显示给用户。<br />
广义：串口，打印机，调制解调器，telnet窗口，ssh窗口等</p>

<p>tty(1)</p>

<p>cp /etc/motd /dev/pts/2</p>

<p>who &gt; /dev/pts/2</p>

<p>ls -li /dev/pts/2</p>

<p>设备文件的属性<br />
设备文件和文件大小<br />
主设备号和从设备号<br />
设备文件和权限<br />
读获取数据<br />
写发送数据</p>

<p>write(1)<br />
实现：文件名是设备名</p>

<p>设备文件和i-node<br />
目录不能区分磁盘文件和设备文件<br />
磁盘文件和设备文件的区分在i-node<br />
设备文件的i-node包含指向内核子程序表的指针，主设备号指向设备驱动程序</p>

<p>设备与文件的不同<br />
文件：内核缓冲<br />
设备属性：波特率，奇偶校验位，暂停位等<br />
链接属性和控制<br />
有哪些属性？<br />
如何检测？<br />
如何设置？</p>

<p>磁盘链接的属性<br />
属性修改模式<br />
获取设置<br />
修改设置<br />
存储设置<br />
#include</p>

<p>int s;</p>

<p>s = fcntl(fd, F_GETFL);</p>

<p>s |= O_SYNC;</p>

<p>result = fcntl(fd, F_SETFL, s)<br />
if( result == 1)<br />
perror(&ldquo;setting SYNC&rdquo;);</p>

<p>属性1：缓冲<br />
属性2：自动添加模式<br />
wtmp</p>

<p>fcntrl 添加O_APPEND</p>

<p>write(fd, buf, size) 使得lseek和write成为一个原子操作</p>

<p>popen pwrite</p>

<p>open控制文件描述符号<br />
fd = open (WTMP_FILE, O_WRONLY | O_APPEND | O_SYNC);</p>

<p>O_CREAT<br />
O_TRUNC<br />
O_EXEL</p>

<p>O_CREAT | O_EXEL:多进程同时创建文件</p>

<p>终端连接的属性<br />
终端I/O: getchar/putchar</p>

<p>#inlcude</p>

<p>int main()<br />
{<br />
int c, n=0;</p>

<p>while( (c=getchar()) != &lsquo;q&rsquo;)<br />
printf(&ldquo;char %3d is %c cod %d \n&rdquo;, n++, c , c);<br />
}</p>

<p>./listchars<br />
hello</p>

<p>在用户输入回车后才接收数据（行缓冲）<br />
Return（ascii 13) 看作换行符（ascii 10）<br />
进程发换行符，终端接受回车换行符</p>

<p>终端驱动程序<br />
处理进程和外部设备间数据流的内核子程序的集合称为终端驱动程序或者tty驱动程序</p>

<p>与终端驱动交互：stty</p>

<p>stty 能干什么？<br />
stty -a<br />
如何实现stty ？<br />
tty驱动：man stty<br />
输入<br />
输出<br />
本地<br />
控制<br />
本地</p>

<p>编写终端驱动<br />
man -k terminal | grep -i attribute</p>

<p>tcgetattr(3)/tcsetattr(3)<br />
struct termios</p>

<p>几个例子<br />
显示echo状态<br />
改变echo状态</p>

<p>自己编写stty:</p>

<p>其他：<br />
ioctl<br />
示例：获取终端屏幕大小</p>

<p>文件，设备和流</p>

<p>用户程序设计：终端控制和信号<br />
实用工具：自动打开3个文件描述符（0标准输入，1标准输出，2标准错误），从标准输入读入字节，进行处理，结果字节流写到标准输出，错误信息发送到标准错误。<br />
输入输出可以被重定向<br />
sort &gt; output<br />
sort x &gt; /dev/lp<br />
who | tr &lsquo;[a-z]&rdquo;[A-Z]&rsquo;<br />
特定设备程序：为特定应用控制设备<br />
用户程序：设备相关程序<br />
vi， emacs, pine, more, lynx, hangman, robots, bsdgames</p>

<p>特点：<br />
立即响应击键事件，不用回车<br />
有限的输入集<br />
输入的超时<br />
屏蔽^+C</p>

<p>终端驱动程序的模式<br />
rotate.c</p>

<p>stty -icanon;./rotate<br />
stty icanno</p>

<p>stty -icanon -echo;./rotate<br />
stty icanon echo<br />
终端模式<br />
规范模式：cooked模式<br />
缓冲，回显，编辑，控制由驱动程序完成</p>

<p>非规范模式<br />
关闭缓冲和编辑功能</p>

<p>raw 模式<br />
每步处理都被一个独立的位控制</p>

<p>用户程序<br />
play_again.c<br />
问题:icanon<br />
需要回车<br />
有缓冲</p>

<p>play_again1.c<br />
tcgetattr(0, &amp;ttystate);<br />
ttystate.c_lflag &amp;= ~ICANON;<br />
ttystate.c_cc[VMIN] = 1;<br />
tcsetattr(0, TCSANOW, &amp;ttystate);</p>

<p>问题<br />
非法提示太多</p>

<p>play_again2.c<br />
tcgetattr(0, &amp;ttystate);<br />
ttystate.c_lflag &amp;= ~ICANON;<br />
ttystate.c_lflag &amp;= ~ECHO;<br />
ttystate.c_cc[VMIN] = 1;<br />
tcsetattr(0, TCSANOW, &amp;ttystate);</p>

<p>问题<br />
超时无显示</p>

<p>play_again3.c<br />
问题<br />
^+C结束整个程序</p>

<p>信号<br />
^+C能做什么？<br />
信号是什么？异步消息，软中断</p>

<p>kill -l<br />
man 7 signal<br />
signal.h</p>

<p>产生信号：<br />
用户:^+C, ^+D ^+\ (stty -a)<br />
内核<br />
进程:kill raise<br />
信号处理<br />
接受默认处理<br />
忽略信号<br />
信号处理程序<br />
signal(2)<br />
函数指针<br />
typedef void (*SigFunc)(int);<br />
SigFunc signal(int, SigFunc);</p>

<p>SIG_ERR<br />
SIG_DFL<br />
SIG_IGN<br />
grep XXX -nr /usr/include</p>

<p>sigdemo1.c：捕捉信号<br />
sigdemo2.c：忽略^+C, ^+\退出</p>

<p>SIGKILL SIGSTOP不能忽略<br />
play_again4.c</p>

<p>10.25<br />
事件驱动编程-视频游戏<br />
视频游戏和操作系统<br />
UNIX和星际旅行:Dennise Ritchie 和 Ken Thompson</p>

<p>视频游戏做什么</p>

<p>视频游戏怎么做<br />
空间<br />
时间<br />
中断<br />
并发<br />
操作系统<br />
内核如何管理进程？</p>

<p>屏幕管理，时间，信号，共享资源</p>

<p>单人桌球游戏</p>

<p>curses库</p>

<p>sudo apt-get install libncurses5-dev</p>

<p>#include</p>

<p>gcc xx.c -o xx -l ncurses</p>

<p>基本curses函数<br />
initscr():初始化curses库和tty<br />
endwin():关闭curses并重置tty<br />
refresh():使屏幕按意图显示<br />
mov(r,c):光标移动到(r,c)<br />
addstr(s):在当前位置绘制字符串<br />
addch&copy;：在当前位置绘制字符<br />
clear():清屏<br />
standout:启动standout模式，一般使得屏幕反色<br />
standend:关闭standout模式</p>

<p>curses的常量<br />
int LINES; // 当前终端的行数<br />
int COLS; // 当前终端的列数<br />
int TABSIZE // 制表符长度</p>

<p>代码模式：<br />
fopen fread/fwrite fclose<br />
open read/write close<br />
opendir readdir closedir<br />
initscr addstr endwin</p>

<p>代码最常出现的问题是变量没有被初始化，特别是指针<br />
代码结束不释放资源导致内存泄漏<br />
open/close 模式值得总结学习，对应面向对象程序设计语言里面的构造函数，析构函数</p>

<p>示例：<br />
hello1.c:基本操作<br />
hello2.c:与循环变量和其他函数配合，进行复杂显示。<br />
理解refresh：虚拟屏幕与实际屏幕<br />
对比标准I/O中的流与文件</p>

<p>hello3.c:时钟编程<br />
sleep(3)<br />
hello4.c:动画<br />
hello5.c:弹回</p>

<p>问题：<br />
延时1s,时间太长<br />
移动的同时如何处理用户输入？</p>

<p>时钟编程1：Alarms<br />
alarm(2)<br />
pause(2):挂起一个进程，直到某个信号被处理</p>

<p>如何实现sleep?<br />
为SIGALARM设置一个处理函数<br />
调用alarm<br />
调用pause</p>

<p>编程实现一个4s sleep:sleep1.c</p>

<p>计时器可以用来调度：<br />
调用alarm设置计时器，然后做其他事情<br />
计时器到零，发送信号，处理函数被调用</p>

<p>时钟编程2：间隔计时器<br />
sleep和alarm提供的时间精度不够：秒</p>

<p>高精度计时：间隔计时器<br />
usleep(3), 微妙做单位</p>

<p>进程的三种计时系统:time</p>

<p>ITIMER_REAL：进程实际时间计时，运行完发送SIGALARM消息<br />
ITIMER_VIRTUAL：用户态,SIGVTALR<br />
ITIMER_PROF:用户态，用户态到核心态陷入 SIGPROF<br />
TIMER_REAL</p>

<p>高精度定时示例:ticker_demo.c<br />
getitimer<br />
setitimer</p>

<p>struct itimerval {<br />
struct timeval it_interval; /* next value <em>/<br />
struct timeval it_value; /</em> current value */<br />
};</p>

<p>struct timeval {<br />
long tv_sec; /* seconds <em>/<br />
long tv_usec; /</em> microseconds */<br />
};</p>

<p>信号处理1：signal<br />
signal(SIGALARM, SIG_DFL)<br />
signal(SIGALARM, SIG_IGN)<br />
signal(SIGALARM, handler)<br />
老鼠夹问题：信号被捕获，信号处理函数就失效了，再次设置就有可能丢失信号，信号的不可靠性<br />
sinal(SIGINT , inthandler);<br />
void inthandler(int signum){<br />
signal(SIGINT, inthandler);<br />
}</p>

<p>不知道信号被发送的原因<br />
处理函数无法阻塞其他信号</p>

<p>如何处理多信号：</p>

<p>生活中的示例</p>

<p>进程的多信号处理:sigdemo3.c<br />
处理函数每次使用完都会被禁用吗？<br />
如果SigY在进程处理SigX时到达，会发生什么？<br />
如果进程处理SigX时又有SigX到达，会发生什么？<br />
如果信号到达时，进程被getchar,read之类输入阻塞，会发生什么？</p>

<p>^C^C^C^C<br />
^\^C^\^C<br />
hello^C CR<br />
hello CR^C<br />
^\^\hello^C</p>

<p>处理函数每次使用完都会被禁用吗？<br />
Linux上不会禁止，不存在老鼠夹问题<br />
如果两次^C杀死进程，说明不可靠<br />
如果SigY在进程处理SigX时到达，会发生什么？<br />
先处理Y再处理X<br />
如果进程处理SigX时又有SigX到达，会发生什么？<br />
递归调用同一个信号处理函数<br />
忽略后者：Linux<br />
阻塞第二个<br />
如果信号到达时，进程被getchar,read之类输入阻塞，会发生什么？</p>

<p>信号处理2：sigaction(2)<br />
struct sigaction {<br />
void (*sa_handler)(int);<br />
void (*sa_sigaction)(int, siginfo_t *, void *);<br />
sigset_t sa_mask;<br />
int sa_flags;<br />
void (*sa_restorer)(void);<br />
};</p>

<p>在一些情况下，一个操作不应该被其他操作打断</p>

<p>sa_mask:阻塞其他信号<br />
sigprocmask(2)<br />
构造信号集合<br />
sigemptyset(3)<br />
sigfillset(3)<br />
sigaddset(3)<br />
sigdelset(3)<br />
sigismember(3)<br />
sa_flags<br />
小练习：暂时阻塞SIGINT SIGQUIT<br />
注意退出要恢复原来的系统状态</p>

<p>sigset_t sigs, presigs;<br />
sigemptyset( &amp;sigs );<br />
sigaddset( &amp;sigs, SIGINT );<br />
sigaddset( &amp;sigs, SIGQUIT );<br />
sigprocmask( SIG_BLOCK, &amp;sigs, &amp;presigs );<br />
//&hellip;<br />
sigprocmask( SIT_SET, *presigs, NULL );</p>

<p>sigactiondemo.c</p>

<p>阻塞信号和忽略信号的区别：<br />
忽略信号：信号还会被传递，只是不处理<br />
阻塞信号：解除阻塞前，信号不传递</p>

<p>可重入代码:一个信号处理或者一个函数，如果在激活状态下能被调用而不引起任何问题<br />
sa_flags:SA_NODEFER 允许处理函数的递归调用，清除可以阻塞信号<br />
处理程序不可重入，必须阻塞信号<br />
阻塞信号就会丢失信号<br />
丢失重要信号怎么办？</p>

<p>临界区：</p>

<p>进程发送信号：kill(1) kill(2)<br />
SIGUSR1, SIGUSR2</p>

<p>视频游戏：<br />
一条线上控制动画：bounce1d.c<br />
空格反向<br />
f加速<br />
s减速</p>

<p>问题：用O代替hello<br />
控制上下移动</p>

<p>两维动画：<br />
不变的是<br />
计时器驱动<br />
等待键盘输入<br />
状态变量</p>

<p>变化的是<br />
如何让球斜着移动？<br />
两个计时器</p>

<p>异步I/O<br />
使用O_ASYNC: bounce_async.c<br />
使用aio_read:bounce_aio.c</p>

<p>自己编写</p>

<p>GDB-SegFaut<br />
工具<br />
gdb -tui (^+X+A)<br />
cgdb<br />
ddd<br />
IDE-Eclipse<br />
调试方法-三窗口法<br />
VI:编辑源代码，之后w保存，修改完毕才wq退出<br />
GCC：编译，运行测试用例，有问题则调试<br />
GDB: 调试，但是重新编译程序不必退出GDB，这样不需要重新输入命令行参数，保留了原来设置的断点，省心，提高效率<br />
调试原则<br />
确认原则<br />
逐个确认你自认为正确的事情对应的代码确实是正确的<br />
从简单工作开始<br />
错误往往发生在边界<br />
等价划分测试用例<br />
使用自顶向下法<br />
单步调试优先使用next，出现错误再使用step<br />
使用工具确定段错误的位置<br />
ulimit -c check<br />
ulimit -c n (KB) set<br />
backspace<br />
frame n<br />
up<br />
down<br />
corefile<br />
通过中断信号确定死循环<br />
^+c continue<br />
使用二分法提高确认效率</p>

<p>示例1, 插入排序，基本调试技巧：<br />
ins.c<br />
用例：  12 5<br />
12 5 19 22 6 1</p>

<p>示例2,段错误的定位<br />
string.c<br />
Init_CString:<br />
Delete_CString:<br />
Chomp:删除并返回最后一个字符<br />
Append_Chars_To_String:</p>

<p>gcc -g string.c<br />
ulimit -c unlimited<br />
./string<br />
gdb string core</p>

<p>1026<br />
多线程</p>

<p>同一时刻完成多项任务<br />
程序：函数<br />
进程：线程</p>

<p>函数执行路线：<br />
单线程<br />
hello_single.c<br />
多线程<br />
hello_multi.c</p>

<p>gcc .. -lpthread</p>

<p>pthread_create<br />
pthread_join<br />
pthread_exit</p>

<p>线程的种种退出：<br />
return:pthread_join 中value_ptr指向线程函数的返回值<br />
被pthread_cancel异常终止：value_ptr指向的位置存放PTHREAD_CANCELED(-1)<br />
调用pthread_exit,value_ptr指向的位置存放的是传给pthread_exit的参数</p>

<p>线程分工合作：<br />
多线程wc:非字母或者非数字的字符跟在字母和数字后就算一个单词<br />
两个线程，一个计数器：twordcount1.c<br />
互斥锁： twordcount2.c<br />
互斥锁会影响程序效率，让程序变慢<br />
两个线程，两个计算器，传递多参数：twordcount3.c<br />
结构体传递多参数</p>

<p>总结：并发问题</p>

<p>1028<br />
线程与进程<br />
线程共享：<br />
数据空间<br />
pid<br />
文件描述符<br />
信号处理方式<br />
当前工作目录<br />
用户ID，组ID<br />
线程独享：<br />
线程ID<br />
上下文<br />
栈<br />
errno<br />
sa_mask<br />
调度优先级</p>

<p>共享数据空间：<br />
malloc free:返回静态局部变量的指针的函数会导致内存泄漏<br />
共享fd<br />
一个线程关闭，一个线程使用？<br />
fork exec exit signals<br />
fork:只有调用fork的线程出现在新进程<br />
exec:新进程取代当前进程，所有执行中的线程都会消失<br />
exit:退出进程，会导致内存异常，系统错误，线程崩溃<br />
signals:</p>

<p>fork pthread_create<br />
exit pthread_exit<br />
waitpid pthread_join<br />
atexit pthread_cleanup_push<br />
getpid pthread_self<br />
abort pthread_cancel</p>

<p>并发：多线程？多进程？<br />
容易设计，编码，调试<br />
运行效率高<br />
兼容性</p>

<p>生产者消费者问题<br />
读者写者问题<br />
哲学家问题</p>

<p>线程通信：<br />
线程中没有父子概念，没有类wait机制，可以让A等待B，B结束后通知A<br />
邮箱机制与条件变量：<br />
容器，旗帜，锁<br />
pthread_cond_t flag<br />
struct arg_set *msg<br />
pthread_mutex_t lock</p>

<p>pthread_cond_wait等待旗帜升起，将原线程挂起<br />
pthread_cond_signal 升旗</p>

<p>生产者消费者问题</p>

<p>信号量（semaphore)<br />
表示可用的资源数量，与mutex不同，可以表示多个资源，实现多资源的同步<br />
man 7 sem_overview</p>

<p>sem_init<br />
sem_wait:获得资源，使得semphore-1,如果semphore值为0,则挂起等待，如果不希望挂起，调用sem_trywait<br />
sem_trywait<br />
sem_post:释放资源，使得semphore+1,同时唤起等待的线程<br />
sem_destroy</p>

<p>多线程在Web服务器中的应用</p>

<p>线程和动画<br />
定时器可以实现动画，通过SIGALRM<br />
线程优点：<br />
线程机制可以更好的匹配内部和外部结构，<br />
在外部，用户可以看到两个独立的活动:动画和键盘控制<br />
在内部：线程可以把动画和键盘输入代码分开，线程通过共享变量定义位置，动画速度<br />
画面的移动需要隐藏的计时器完成<br />
现代线程允许在多处理器并行处理<br />
动画轨道，渲染，纹理，旋转等复杂计算可以通过并行提高速度</p>

<p>基于多线程机制的多重动画<br />
tanimate.c<br />
互斥量：<br />
初始化，控制移动消息，读取和处理用户输入的循环</p>

<p>方向变量，屏幕冲突</p>

<p>1029</p>

<p>gdb-调试<br />
GUI<br />
tty /dev/pts/4 //开启执行终端，gdb 在不同终端执行程序，键盘输入和屏幕输出将位于执行终端<br />
执行窗口输入：sleep 100000;//执行窗口的输入是控制程序而不是进入 shell<br />
完成调试输入^+C, 结束sleep<br />
程序输入错误退出：<br />
^+j reset ^+j</p>

<p>Threads<br />
info threads<br />
thread 3<br />
break 88 thread 3<br />
break 88 thread 3 if x==y</p>

<p>1029<br />
小项目：<br />
多线程拷贝的实现<br />
mmap<br />
stat</p>

<p>Shell编程<br />
应用示例&mdash;监视系统用户程序</p>

<p>伪代码：<br />
获取现在的用户列表1<br />
不停的做下面的事情<br />
等待一会<br />
获取现在的用户列表2<br />
比较两个用户列表<br />
如何列表1有，列表2没有<br />
退出登录用户<br />
如果列表1没有，列表2有<br />
新登录用户</p>

<p>用列表2替换列表1的内容</p>

<p>shell：<br />
who | sort &gt; prev<br />
while true; do<br />
sleep 60<br />
who | sort &gt; curr<br />
echo “logged out:&rdquo;<br />
comm -23 prev curr<br />
echo &ldquo;logged in:&rdquo;<br />
comm -13 prev curr<br />
mv curr prev<br />
done</p>

<p>Unix/Linux的脚本思维方式<br />
通过进程组合完成复杂功能，而不是通过函数调用组成大应用程序</p>

<p>对比：计算机指令<br />
对比函数调用：y = f1(f2(x)); x &gt; f2 | f1 &gt; y</p>

<p>shell脚本<br />
脚本简单易用<br />
工具灵活：每个工具完成一个特定，通用的功能（对比函数库，类库）<br />
I/O重定向，管道的使用和作用</p>

<p>Shell是一种具备特殊功能的程序，提供了用户与内核进行交互操作的一种接口(系统调用，shell)<br />
/ect/shells<br />
default: /etc/passwd</p>

<p>三种登录Shell的方法<br />
X Window<br />
SSH Secure Shell<br />
PuTTY:<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a></p>

<p>编译型语言<br />
编写-编译-链接-运行（edit-compile-link-run）<br />
C\C++、Ada、Java、C#&hellip;</p>

<p>脚本语言<br />
解释器（interpreter）读入脚本程序代码，将其转换成内部的形式执行<br />
解释器本身则是编译型程序<br />
Python, Ruby, Javascript&hellip;</p>

<p>Shell脚本编程的优势<br />
编译：语言效率<br />
脚本：程序员效率</p>

<p>Shell脚本的执行方式<br />
交互式命令行<br />
which whereis<br />
type -t<br />
man bash-builtins<br />
cd alias umask exit<br />
help cd<br />
内建命令（！ : . alias bg bind break builtin case cd command continue declare dirs
disown do done echo elif else enable ecac eval exec exit export fc fg fi for
funtion getops hash help history if in jobs kill let local logout popd pushd
pwd read readonly return select set shift suspend test then time times trap
type typeset ulimit umask unalias unset until wait while)<br />
cd..;ls<br />
子shell (cd..; ls)</p>

<p>脚本文件<br />
#! /bin/sh-<br />
cd ..<br />
ls</p>

<p>编写脚本的一般模式：<br />
命令行下测试正确<br />
编写脚本<br />
chmod +x</p>

<p>用户和用户组管理<br />
用户管理常用命令<br />
用户账号添加命令useradd 或adduser<br />
修改用户命令usermod<br />
删除用户命令userdel<br />
用户口令管理命令passwd<br />
用户组管理常用命令<br />
groupadd groupmod groupdel`</p>

<p>文件和目录操作<br />
文件操作常用命令</p>

<p>目录操作常用命令</p>

<p>文件和目录权限管理常用命令<br />
chmod chown</p>

<p>查找文件命令——find<br />
find [路径] [选项] [操作]<br />
路径是find命令所查找的目录路径，例如用.来表示当前目录，用/来表示系统根目录<br />
选项用于指定查找条件，如：可以指定按照文件属主、更改时间、文件类型等条件来查找</p>

<p>-name</p>

<p>按照文件名查找文件。</p>

<p>-perm<br />
按照文件权限来查找文件。</p>

<p>-prune<br />
使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。</p>

<p>-user<br />
按照文件属主来查找文件。</p>

<p>-group<br />
按照文件所属的组来查找文件。</p>

<p>-mtime -n +n<br />
按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime
选项，但它们都和-m time选项。</p>

<p>-nogroup<br />
查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。</p>

<p>-nouser<br />
查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。<br />
-newer file1 ! file2</p>

<p>查找更改时间比文件file1新但比文件file2旧的文件。<br />
-type</p>

<p>查找某一类型的文件，诸如：</p>

<p>b - 块设备文件。<br />
d - 目录。<br />
c - 字符设备文件。<br />
p - 管道文件。<br />
l - 符号链接文件。<br />
f - 普通文件。</p>

<p>-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。<br />
-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。<br />
-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。</p>

<p>-mount：在查找文件时不跨越文件系统mount点。<br />
-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。<br />
-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。</p>

<p>另外,下面三个的区别:<br />
-amin n<br />
查找系统中最后N分钟访问的文件</p>

<p>-atime n<br />
查找系统中最后n*24小时访问的文件</p>

<p>-cmin n<br />
查找系统中最后N分钟被改变文件状态的文件</p>

<p>-ctime n<br />
查找系统中最后n*24小时被改变文件状态的文件</p>

<p>-mmin n<br />
查找系统中最后N分钟被改变文件数据的文件</p>

<p>-mtime n<br />
查找系统中最后n*24小时被改变文件数据的文件<br />
操作用于指定结果的输出方式:<br />
print,exec,ok</p>

<p>find . -name &rsquo;t<em>&rsquo; -perm 744 -print<br />
find . -mtime -90 -print<br />
find /etc -type f -name &ldquo;rc</em>&rdquo; -exec ls -l {} \;<br />
find . -name &ldquo;*.conf&rdquo; -mtime +5 -ok rm {} \;</p>

<p>查找当前用户主目录下的所有文件：</p>

<p>下面两种方法都可以使用</p>

<p>$ find $HOME -print<br />
$ find ~ -print</p>

<p>当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件；</p>

<p>$ find . -type f -perm 644 -exec ls -l {} \;</p>

<p>查找系统中所有文件长度为0的普通文件，并列出它们的完整路径；</p>

<p>$ find / -type f -size 0 -exec ls -l {} \;</p>

<p>查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们；</p>

<p>$ find /var/logs -type f -mtime +7 -ok rm { } \;</p>

<p>查找系统中所有属于root组的文件；</p>

<p>$find . -group root -exec ls -l { } \;<br />
-rw-r&ndash;r&ndash; 1 root root 595 10月 31 01:09 ./fie1</p>

<p>将删除当目录中访问时间在7日以来、含有数字后缀的admin.log文件。<br />
$ find . -name &ldquo;admin.log[0-9][0-9][0-9]&rdquo; -atime -7 -ok<br />
rm { } \;<br />
&lt; rm &hellip; ./admin.log001 &gt; ? n<br />
&lt; rm &hellip; ./admin.log002 &gt; ? n<br />
&lt; rm &hellip; ./admin.log042 &gt; ? n<br />
&lt; rm &hellip; ./admin.log942 &gt; ? n</p>

<p>查找当前文件系统中的所有目录并排序；<br />
$ find . -type d | sort</p>

<p>文件处理<br />
sort命令<br />
-t选项可用于设置分隔符<br />
sort -t: CARGO.db<br />
-k选项用于指定排序的域，sort默认按第1域进行排序<br />
sort -t: -k3 CARGO.db<br />
-n选项用于指定按数值大小进行排序<br />
sort -t: -k3n CARGO.db<br />
-r选项用于将排序结果逆向显示<br />
sort -t: -k3nr CARGO.db<br />
-u选项用于去除排序结果中的重复行<br />
sort -t: -u CARGO.db<br />
-o选项用于指定结果文件的名字<br />
sort -t: -k3n -o SORT.txt CARGO.db<br />
-c选项用于测试文件是否已经排好序<br />
sort -t: -c CARGO.db<br />
sort -t: -c SORT.txt<br />
sort -t: -k3n -c SORT.txt<br />
-m选项用于将两个排好序的文件合并成一个排好序的文件，在文件合并前，它们必须已经排好序，<br />
-m选项对未排序的文件合并是没有任何意义<br />
sort -t: -m CARGO2.db SORT.txt<br />
uniq命令<br />
sort -u<br />
sort -u命令时，所有重复记录都被去掉<br />
uniq命令去除的重复行必须是连续重复出现的行，中间不能夹杂任何其他文本行<br />
-c：每行的重复次数<br />
count_word.sh<br />
-u：显示有重复的记录<br />
-d：显示无重复的</p>

<p>uniq CARGO3.db<br />
sort -u CARGO3.db</p>

<p>join命令:用于实现两个文件中记录的连接操作<br />
连接操作将两个文件中具有相同域的记录选择出来，再将这些记录所有的域放到一行<br />
-a1或-a2<br />
除了显示以共同域进行连接的结果外，-a1表示还显示第1个文件中没有共同域的记录，-a2则表示显示第2个文件中没有共同域的记录<br />
-i<br />
比较域内容时，忽略大小写差异<br />
-o<br />
设置结果显示的格式<br />
-t<br />
改变域分隔符<br />
-v1或-v2<br />
跟-a选项类似，但是，不显示以共同域进行连接的结果<br />
-1和-2<br />
-1用于设置文件1用于连接的域，-2用于设置文件2用于连接的域</p>

<p>当两个文件进行连接时，文件1中的记录可能在文件2中找不到共同域，反过来，文件2中也可能存在这样的记录，join命令的结果默认是不显示这些未进行连接的记录的<br />
-a和-v选项就是用于显示这些未进行连接的记录，-a1和-v1指显示文件1中的未连接记录，而-a2和-v2指显示文件2中的未连接记录<br />
-a和-v选项的区别在于：-a选项显示以共同域进行连接的结果，而-v选项则不显示这些记录</p>

<p>cat TEACHER.db<br />
cat TEACHER_HOBBY.db<br />
join -t: TEACHER.db TEACHER_HOBBY.db<br />
join -t: -a1 TEACHER.db TEACHER_HOBBY.db<br />
join -t: -a2 TEACHER.db TEACHER_HOBBY.db<br />
join -t: -v1 TEACHER.db TEACHER_HOBBY.db<br />
join -t: -v2 TEACHER.db TEACHER_HOBBY.db<br />
join -t: -o1.1 2.2 1.2 TEACHER.db TEACHER_HOBBY.db</p>

<p>cat AREACODE.db<br />
sort -t: -k3 -o TEACHER1.db TEACHER.db<br />
join -t: -i -1 3 -2 1  TEACHER1.db AREACODE.db</p>

<p>cut命令:从标准输入或文本文件中按域或行提取文本<br />
-c:n n,m n-m<br />
指定提取的字符数，或字符范围<br />
-f<br />
指定提取的域数，或域范围<br />
-d<br />
改变域分隔符</p>

<p>cut -c3 TEACHER.db<br />
cut -c1-5 TEACHER.db</p>

<p>cut -d: -f1,4 TEACHER.db<br />
cut -d: -f1-3 TEACHER.db</p>

<p>paste命令:将文本文件或标准输出中的内容粘贴到新的文件，它可以将来自于不同文件的数据粘贴到一起，形成新的文件<br />
-d<br />
默认域分隔符是空格或Tab键，设置新的域分隔符<br />
-s<br />
将每个文件粘贴成一行<br />
-<br />
从标准输入中读取数据</p>

<p>cat FILE1<br />
cat FILE2<br />
paste FILE1 FILE2<br />
paste -d: FILE1 FILE2<br />
paste -d@ FILE1 FILE2<br />
paste -d: -s FILE1 FILE2</p>

<p>ls | paste -d&rdquo; &ldquo; - - - - - -</p>

<p>split命令:split命令用于将大文件切割成小文件，split命令可以按照文件的行数、字节数切割文件，并能在输出的多个小文件中自动加上编号<br />
-或-l<br />
此两个选项等价，都用于指定切割成小文件的行数<br />
-b<br />
指定切割成小文件的字节<br />
-C<br />
与-b选项类似，但是，切割时尽量维持每行的完整性</p>

<p>split -2 TEACHER.db PEO.db<br />
split -b100 TEACHER.db<br />
split -C100 TEACHER.db</p>

<p>tr命令:tr命令实现字符转换功能<br />
tr [选项] 字符串1 字符串2 tr命令要么将输入文件重定向到标准输入，要么从管道读入数据,记住tr命令的输入文件之前需要加上“ -c<br />
选定字符串1中字符集的补集，即反选字符串1中的字符集<br />
-d<br />
删除字符串1中出现的所有字符<br />
-s<br />
删除所有重复出现的字符序列，只保留一个</p>

<p>tr -d A-Z  tr -d 0-9  tr -d &ldquo;[\n]&rdquo;  tr -s &ldquo;[\n]&rdquo;</p>

<p>tr &ldquo;[a-z],[A-Z]&rdquo;  tr &ldquo;[a-z]&rdquo; &ldquo;[A-Z]&rdquo;</p>

<p>变量和引用<br />
变量可分为三类：<br />
本地变量是仅可以在用户当前Shell生命期的脚本中使用的变量<br />
环境变量则适用于所有由登录进程所产生的子进程<br />
环境变量在用户登录后到注销之前的所有编辑器、脚本、程序和应用中都有效<br />
位置参数也属于变量，它用于向Shell脚本传递参数，是只读的</p>

<p>无类型，动态类型<br />
integer.sh<br />
null-undeclear.sh</p>

<p>变量替换<br />
变量是某个值的名称，引用变量值就称为变量替换<br />
$符号是变量替换符号，如variable是变量名，那么$variable就表示变量的值</p>

<p>变量赋值有两种格式：</p>

<p>variable=value<br />
${ variable=value }<br />
unset命令可以清除变量的值<br />
readonly可将变量设置为只读，变量一旦设置为只读，任何用户不能对此变量进行重新赋值</p>

<p>环境变量<br />
PWD<br />
PATH<br />
HOME<br />
SHELL<br />
PPID<br />
PS1 PS2<br />
\d<br />
以“周 月 日”格式显示的日期<br />
\H<br />
主机名和域名<br />
\h<br />
主机名<br />
\s<br />
Shell的类型名称<br />
\T<br />
以12小时制显示时间，格式为：HH:MM:SS<br />
\t<br />
以24小时制显示时间，格式为：HH:MM:SS<br />
\@<br />
以12小时制显示时间，格式为：am/pm<br />
\u<br />
当前的用户名<br />
\v<br />
bash Shell的版本号<br />
\V<br />
bash Shell的版本号和补丁号<br />
\w<br />
当前工作目录的完整路径<br />
\W<br />
当前工作目录名字<br />
\#<br />
当前命令的序列号<br />
\$<br />
如果UID为0，打印#；否则，打印$</p>

<p>.bash_profile<br />
/etc/profile<br />
.bashrc<br />
子shell<br />
.bash_logout<br />
退出</p>

<p>father.sh child.sh<br />
位置参数<br />
$1 &hellip; ${10}&hellip;<br />
$* $@</p>

<p>命令替换</p>

<p>退出状态<br />
$?</p>

<p>测试</p>

<p>if/else<br />
case</p>

<p>运算符</p>

<p>循环与结构化命令</p>

<p>expr</p>

<p>管道与重定向</p>

<p>函数</p>

<p>调试<br />
Shell选项，不修改代码<br />
-n: 读一遍脚本中的命令但不执行，用于检查脚本中的语法错误</p>

<p>-v: 一边执行脚本，一边将执行过的脚本命令打印到标准错误输出</p>

<p>-x: 提供跟踪执行信息，将执行的每一条命令和结果依次打印出来</p>

<p>用法：<br />
sh -x<br />
修改脚本：  #! /bin/sh -x<br />
修改脚本： set -x 开启<br />
set +x 关闭<br />
trap: 内建命令，用于捕捉信号<br />
trap command sig1 sig2 sig3&hellip;sign<br />
shell会产生三个伪信号：<br />
EXIT<br />
从函数中退出，或整个脚本执行完毕<br />
ERR<br />
当一条命令返回非零状态码，即命令执行不成功<br />
DEBUG<br />
脚本中的每一条命令执行之前</p>

<p>trapdebug.sh<br />
trapexit.sh<br />
traperr.sh<br />
调试钩子<br />
if [ &ldquo;$DEBUG&rdquo; = &ldquo;true&rdquo; ]<br />
then<br />
echo &ldquo;Debugging information:&rdquo;<br />
&hellip;<br />
fi</p>

<p>debugblock.sh</p>

<p>export DEBUG=true<br />
./debugblock.sh</p>

<p>Regex<br />
grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来，grep也是Linux中最广泛使用的命令之一</p>

<p>grep: BRE, Basic Regular Expression<br />
egrep: Extended Regular Expression<br />
fgrep: 并行，快速<br />
rgrep: recursive grep<br />
1992 POSIX，三个grep合并，grep -E =egrep; grep -F =fgrep; grep -r =rgrep</p>

<p>grep [选项][模式][文件…]<br />
-c<br />
只输出匹配行的数量<br />
-i<br />
搜索时忽略大小写<br />
-h<br />
查询多文件时不显示文件名<br />
-l<br />
只列出符合匹配的文件名，而不列出具体匹配行<br />
-n<br />
列出所有匹配行，并显示行号<br />
-s<br />
不显示不存在或无匹配文本的错误信息<br />
-v<br />
显示不包含匹配文本的所有行<br />
-w<br />
匹配整词<br />
-r<br />
递归搜索，不仅搜索当前工作目录，而且搜索子目录<br />
-E<br />
支持扩展的正则表达式<br />
-F<br />
不支持正则表达式，按照字符串的字面意思进行匹</p>

<p>sed&amp;awk</p>

<p>sed（stream editor）是流编辑器，可对文本文件和标准输入进行编辑。<br />
sed只是对缓冲区中原始文件的副本进行编辑，并不编辑原始的文件<br />
如果需要保存改动内容，可以选择使用下面两种方法：<br />
重定向<br />
w编辑命令<br />
sed 调用<br />
在Shell命令行输入命令调用sed，格式为：<br />
sed [选项] ‘sed命令’ 输入文件<br />
将sed命令插入脚本文件后，然后通过sed命令调用它，格式为：<br />
sed [选项] -f sed脚本文件 输入文件<br />
将sed命令插入脚本文件后，最常用的方法是设置该脚本文件为可执行，然后直接执行该脚本文件，格式为：<br />
./sed脚本文件 输入文件</p>

<p>第二种方法脚本文件的首行不以#!/bin/sed –f开头；第三种方法脚本文件的首行是#!/bin/sed –f<br />
推荐使用第一种方法和第三种方法<br />
sed 选项<br />
-n<br />
不打印所有行到标准输出<br />
-e<br />
表示将下一个字符串解析为sed编辑命令，如果只传递一个编辑命令给sed，-e选项可以省略<br />
当向sed命令传递多个编辑命令时，在每个编辑命令前需要加上-e选项<br />
-f<br />
表示正在调用sed脚本文件</p>

<p>sed 文本定位<br />
x: x为指定行号<br />
x,y: 指定从x到y的行号范围<br />
/pattern/: 查询包含模式的行<br />
/pattern/pattern/: 查询包含两个模式的行<br />
/pattern/,x: 从与pattern的匹配行到x号行之间的行<br />
x,/pattern/: 从x号行到与pattern的匹配行之间的行<br />
x,y!: 查询不包括x和y行号的行</p>

<p>sed -n &lsquo;1p&rsquo; input<br />
sed &lsquo;1p&rsquo; input<br />
sed &lsquo;3,6p&rsquo; input<br />
sed &lsquo;/certificate/p&rsquo; input<br />
sed -n &lsquo;/certificate/=&rsquo; input<br />
sed -n -e &lsquo;/certificate/=&rsquo; -e &lsquo;/Certificate/=&rsquo; input</p>

<p>sed编辑命令<br />
p: 打印匹配行<br />
=: 打印文件行号<br />
a: 在定位行号之后追加文本信息<br />
i: 在定位行号之前插入文本信息<br />
d: 删除定位行<br />
c: 用新文本替换定位文本<br />
s: 使用替换模式替换相应模式<br />
r: 从另一个文件中读文本<br />
w: 将文本写入到一个文件<br />
y: 变换字符<br />
q: 第一个模式匹配完成后退出<br />
l: 显示与八进制ASCII代码等价的控制字符<br />
{}: 在定位行执行的命令组<br />
n: 读取下一个输入行，用下一个命令处理新的行<br />
h: 将模式缓冲区文本拷贝到保持缓冲区<br />
H: 将模式缓冲区文本追加到保持缓冲区<br />
x: 互换模式缓冲区和保持缓冲区内容<br />
g: 将保持缓冲区内容拷贝到模式缓冲区<br />
G: 将保持缓冲区内容追加到模式缓冲区</p>

<p>查找到与模式匹配的文本行，这是sed命令经常使用的命令<br />
经常需要结合正则表达式</p>

<p>追加文本：匹配行后面插入<br />
插入文本：匹配行前面插入 append.sed<br />
修改文本：将所匹配的文本行利用新文本替代 modify.sed<br />
删除文本：将指定行或指定行范围进行删除: 指定地址 d</p>

<p>sed替换文本操作将所匹配的文本行利用新文本替换，替换文本与修改文本功能有相似之处，它们之间的区别在于：替换文本可以替换一个字符串，而修改文本是对整行进行修改<br />
替换文本的格式为：<br />
s/被替换的字符串/新字符串/[替换选项]<br />
g<br />
表示替换文本中所有出现被替换字符串之处<br />
p<br />
与-n选项结合，只打印替换行<br />
w 文件名<br />
表示将输出定向到一个文件</p>

<p>从文件中读入文本，r选项<br />
cat otherfile<br />
sed&rsquo;/Certificate/r otherfile&rsquo; input</p>

<p>退出命令： q选项表示完成指定地址的匹配后立即退出<br />
sed &lsquo;5 q&rsquo; input<br />
sed -n &lsquo;/.r.<em>/p&rsquo; input<br />
sed &lsquo;/.r.</em>/q&rsquo; input<br />
变换命令： y选项表示字符变换，它将一系列的字符变换为相应的字符<br />
sed ‘y/被变换的字符序列/变换的字符序列/’ 输入文件<br />
sed y命令要求被变换的字符序列和变换的字符序列等长，否则sed y命令将报错<br />
sed &lsquo;y/12345/ABCDE/&rsquo; input</p>

<p>命令组：{}<br />
sed -n &lsquo;/Certificate/{p;=} input<br />
sed -n -e &lsquo;/Certificate/p&rsquo; -e &lsquo;/Certificate/=&rsquo; input</p>

<p>awk: Alfred V.Aho, Peter J. Weinberger, Brian W.Kernighan<br />
语法类似C语言</p>

<p>调用awk有三种方法（与sed类似）：<br />
在Shell命令行输入命令调用awk，格式为：<br />
awk [-F 域分隔符] ‘awk程序段’ 输入文件<br />
将awk程序段插入脚本文件后，然后通过awk命令调用它：<br />
awk -f awk脚本文件 输入文件<br />
将awk命令插入脚本文件后，最常用的方法是设置该脚本文件为可执行，然后直接执行该脚本文件，格式为：<br />
./awk脚本文件 输入文件<br />
第二种方法脚本文件的首行不以#!/bin/awk –f开头；第三种方法脚本文件的首行是#!/bin/awk –f<br />
推荐使用第一种方法和第三种方法</p>

<p>BEGIN<br />
循环进入每行<br />
END</p>

<p>awk记录和域<br />
awk认为输入文件是结构化的，awk将每个输入文件行定义为记录，行中的每个字符串定义为域，域之间用空格、Tab键或其他符号进行分割，分割域的符号就叫分隔符</p>

<p>Aka EDU  1234567<br />
roc EDU  s234567<br />
awk关系、布尔运算符、表达式:C<br />
系统变量<br />
$n<br />
当前记录的第n个域，域间由FS分割<br />
$0<br />
记录的所有域<br />
ARGC<br />
命令行参数的数量<br />
ARGIND<br />
命令行中当前文件的位置（以0开始标号）<br />
ARGV<br />
命令行参数的数组<br />
CONVFMT<br />
数字转换格式<br />
ENVIRON<br />
环境变量关联数组<br />
ERRNO<br />
最后一个系统错误的描述<br />
FIELDWIDTHS<br />
字段宽度列表，以空格键分割<br />
FILENAME<br />
当前文件名<br />
FNR<br />
浏览文件的记录数<br />
FS<br />
字段分隔符，默认是空格键<br />
IGNORECASE<br />
布尔变量，如果为真，则进行忽略大小写的匹配<br />
NF<br />
当前记录中的域数量<br />
NR<br />
当前记录数<br />
OFMT<br />
数字的输出格式<br />
OFS<br />
输出域分隔符，默认是空格键<br />
ORS<br />
输出记录分隔符，默认是换行符<br />
RLENGTH<br />
由match函数所匹配的字符串长度<br />
RS<br />
记录分隔符，默认是空格键<br />
RSTART<br />
由match函数所匹配的字符串的第1个位置<br />
SUBSEP<br />
数组下标分隔符，默认值是\034</p>

<p>格式化输出：printf</p>

<p>内置字符串函数<br />
gsub(r,s)<br />
在输入文件中用s替换r<br />
gsub(r,s,t)<br />
在t中用s替换r<br />
index(s,t)<br />
返回s中字符串第一个t的位置<br />
length(s)<br />
返回s的长度<br />
match(s,t)<br />
测试s是否包含匹配t的字符串<br />
split(r,s,t)<br />
在t上将r分成序列s<br />
sub(r,s,t)<br />
将t中第1次出现的r替换为s<br />
substr(r,s)<br />
返回字符串r中从s开始的后缀部分<br />
substr(r,s,t)<br />
返回字符串r中从s开始长度为t的后缀部分</p>

<p>awk条件语句和循环语句</p>

<p>数组<br />
ARGC ARGV ENVIRON</p>

<p>shell应用<br />
文本-》HTML<br />
topN<br />
random</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>