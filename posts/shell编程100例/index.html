<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell编程100例 | 开发者问答集锦</title>
    <meta property="og:title" content="shell编程100例 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell编程100例">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B100%E4%BE%8B/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell编程100例</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><a href="https://blog.csdn.net/yugemengjing/article/details/82469785">https://blog.csdn.net/yugemengjing/article/details/82469785</a></p>

<p>1、编写hello world脚本</p>

<p>#!/bin/bash</p>

<h1 id="编写hello-world脚本">编写hello world脚本</h1>

<p>echo “Hello World!”<br />
2、通过位置变量创建 Linux 系统账户及密码</p>

<p>#!/bin/bash</p>

<h1 id="通过位置变量创建-linux-系统账户及密码">通过位置变量创建 Linux 系统账户及密码</h1>

<p>#$1 是执行脚本的第一个参数,$2 是执行脚本的第二个参数<br />
useradd “$1”<br />
echo “$2” | passwd ‐‐stdin “$1”<br />
3、备份日志</p>

<p>#!/bin/bash</p>

<h1 id="每周-5-使用-tar-命令备份-var-log-下的所有日志文件">每周 5 使用 tar 命令备份/var/log 下的所有日志文件</h1>

<h1 id="vim-root-logbak-sh">vim /root/logbak.sh</h1>

<h1 id="编写备份脚本-备份后的文件名包含日期标签-防止后面的备份将前面的备份数据覆盖">编写备份脚本,备份后的文件名包含日期标签,防止后面的备份将前面的备份数据覆盖</h1>

<h1 id="注意-date-命令需要使用反引号括起来-反引号在键盘键上面">注意 date 命令需要使用反引号括起来,反引号在键盘键上面</h1>

<p>tar -czf log-<code>date +%Y%m%d</code>.tar.gz /var/log</p>

<h1 id="crontab-e-编写计划任务-执行备份脚本">crontab ‐e #编写计划任务,执行备份脚本</h1>

<p>00 03 * * 5 /root/logbak.sh<br />
4、一键部署 LNMP(RPM 包版本)</p>

<p>#!/bin/bash</p>

<h1 id="一键部署-lnmp-rpm-包版本">一键部署 LNMP(RPM 包版本)</h1>

<h1 id="使用-yum-安装部署-lnmp-需要提前配置好-yum-源-否则该脚本会失败">使用 yum 安装部署 LNMP,需要提前配置好 yum 源,否则该脚本会失败</h1>

<h1 id="本脚本使用于-centos7-2-或-rhel7-2">本脚本使用于 centos7.2 或 RHEL7.2</h1>

<p>yum ‐y install httpd<br />
yum ‐y install mariadb mariadb‐devel mariadb‐server<br />
yum ‐y install php php‐mysql</p>

<p>systemctl start httpd mariadb<br />
systemctl enable httpd mariadb<br />
5、监控内存和磁盘容量，小于给定值时报警</p>

<p>#!/bin/bash</p>

<h1 id="实时监控本机内存和硬盘剩余空间-剩余内存小于500m-根分区剩余空间小于1000m时-发送报警邮件给root管理员">实时监控本机内存和硬盘剩余空间,剩余内存小于500M、根分区剩余空间小于1000M时,发送报警邮件给root管理员</h1>

<h1 id="提取根分区剩余空间">提取根分区剩余空间</h1>

<p>disk_size=$(df / | awk ‘///{print $4}’)</p>

<h1 id="提取内存剩余空间">提取内存剩余空间</h1>

<p>mem_size=$(free | awk ‘/Mem/{print $4}’)<br />
while :<br />
do</p>

<h1 id="注意内存和磁盘提取的空间大小都是以-kb-为单位">注意内存和磁盘提取的空间大小都是以 Kb 为单位</h1>

<p>if [ $disk_size -le 512000 -a $mem_size -le 1024000 ]<br />
then<br />
mail ‐s “Warning” root &lt; Insufficient resources,资源不足<br />
EOF<br />
fi<br />
done<br />
6、猜数字游戏</p>

<p>#!/bin/bash</p>

<h1 id="脚本生成一个-100-以内的随机数-提示用户猜数字-根据用户的输入-提示用户猜对了">脚本生成一个 100 以内的随机数,提示用户猜数字,根据用户的输入,提示用户猜对了,</h1>

<h1 id="猜小了或猜大了-直至用户猜对脚本结束">猜小了或猜大了,直至用户猜对脚本结束。</h1>

<h1 id="random-为系统自带的系统变量-值为-0-32767的随机数">RANDOM 为系统自带的系统变量,值为 0‐32767的随机数</h1>

<h1 id="使用取余算法将随机数变为-1-100-的随机数">使用取余算法将随机数变为 1‐100 的随机数</h1>

<p>num= [ R A N D O M e c h o &ldquo; [RANDOM%100+1] echo &ldquo; [RANDOMecho&rdquo;num&rdquo;</p>

<h1 id="使用-read-提示用户猜数字">使用 read 提示用户猜数字</h1>

<h1 id="使用-if-判断用户猜数字的大小关系-eq-等于-ne-不等于-gt-大于-ge-大于等于">使用 if 判断用户猜数字的大小关系:‐eq(等于),‐ne(不等于),‐gt(大于),‐ge(大于等于),</h1>

<h1 id="lt-小于-le-小于等于">‐lt(小于),‐le(小于等于)</h1>

<p>while :<br />
do<br />
read -p &ldquo;计算机生成了一个 1‐100 的随机数,你猜: &ldquo; cai<br />
if [ $cai -eq $num ]<br />
then<br />
echo “恭喜,猜对了”<br />
exit<br />
elif [ $cai -gt $num ]<br />
then<br />
echo “Oops,猜大了”<br />
else<br />
echo “Oops,猜小了”<br />
fi<br />
done<br />
7、检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用字串对比版本)</p>

<p>#!/bin/bash</p>

<h1 id="检测本机当前用户是否为超级管理员-如果是管理员-则使用-yum-安装-vsftpd-如果不">检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不</h1>

<h1 id="是-则提示您非管理员-使用字串对比版本">是,则提示您非管理员(使用字串对比版本)</h1>

<p>if [ $USER == “root” ]<br />
then<br />
yum ‐y install vsftpd<br />
else<br />
echo “您不是管理员,没有权限安装软件”<br />
fi<br />
8、检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用 UID 数字对比版本)</p>

<p>#!/bin/bash</p>

<h1 id="检测本机当前用户是否为超级管理员-如果是管理员-则使用-yum-安装-vsftpd-如果不-1">检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不</h1>

<h1 id="是-则提示您非管理员-使用-uid-数字对比版本">是,则提示您非管理员(使用 UID 数字对比版本)</h1>

<p>if [ $UID -eq 0 ];then<br />
yum ‐y install vsftpd<br />
else<br />
echo “您不是管理员,没有权限安装软件”<br />
fi<br />
9、编写脚本:提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户不输入账户名,则提示必须输入账户名并退出脚本;如果用户不输入密码,则统一使用默认的
123456 作为默认密码。</p>

<p>#!/bin/bash</p>

<h1 id="编写脚本-提示用户输入用户名和密码-脚本自动创建相应的账户及配置密码-如果用户">编写脚本:提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户</h1>

<h1 id="不输入账户名-则提示必须输入账户名并退出脚本-如果用户不输入密码-则统一使用默">不输入账户名,则提示必须输入账户名并退出脚本;如果用户不输入密码,则统一使用默</h1>

<h1 id="认的-123456-作为默认密码">认的 123456 作为默认密码。</h1>

<p>read -p &ldquo;请输入用户名: &ldquo; user<br />
#使用‐z 可以判断一个变量是否为空,如果为空,提示用户必须输入账户名,并退出脚本,退出码为 2<br />
#没有输入用户名脚本退出后,使用$?查看的返回码为 2<br />
if [ -z KaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;#&rsquo; at position 45: …名&rdquo; exit 2
fi #̲使用 stty ‐echo 关…{pass:‐123456}<br />
useradd “ u s e r &ldquo; e c h o &rdquo; user&rdquo; echo &ldquo; user&rdquo;echo&rdquo;pass” | passwd ‐‐stdin
“$user”<br />
10、输入三个数并进行升序排序</p>

<p>#!/bin/bash</p>

<h1 id="依次提示用户输入-3-个整数-脚本根据数字大小依次排序输出-3-个数字">依次提示用户输入 3 个整数,脚本根据数字大小依次排序输出 3 个数字</h1>

<p>read -p “请输入一个整数:” num1<br />
read -p “请输入一个整数:” num2<br />
read -p “请输入一个整数:” num3</p>

<h1 id="不管谁大谁小-最后都打印-echo-n-u-m-1-num1-num1-num2-num3">不管谁大谁小,最后都打印 echo “ n u m 1 , num1, num1,num2,$num3”</h1>

<h1 id="num1-中永远存最小的值-num2-中永远存中间值-num3-永远存最大值">num1 中永远存最小的值,num2 中永远存中间值,num3 永远存最大值</h1>

<h1 id="如果输入的不是这样的顺序-则改变数的存储顺序-如-可以将-num1-和-num2-的值对调">如果输入的不是这样的顺序,则改变数的存储顺序,如:可以将 num1 和 num2 的值对调</h1>

<p>tmp=0</p>

<h1 id="如果-num1-大于-num2-就把-num1-和和-num2-的值对调-确保-num1-变量中存的是最小值">如果 num1 大于 num2,就把 num1 和和 num2 的值对调,确保 num1 变量中存的是最小值</h1>

<p>if [ $num1 -gt  n u m 2 ] ; t h e n t m p = num2 ];then tmp=
num2];thentmp=num1<br />
num1= n u m 2 n u m 2 = num2 num2= num2num2=tmp<br />
fi</p>

<h1 id="如果-num1-大于-num3-就把-num1-和-num3-对调-确保-num1-变量中存的是最小值">如果 num1 大于 num3,就把 num1 和 num3 对调,确保 num1 变量中存的是最小值</h1>

<p>if [ $num1 -gt  n u m 3 ] ; t h e n t m p = num3 ];then tmp=
num3];thentmp=num1<br />
num1= n u m 3 n u m 3 = num3 num3= num3num3=tmp<br />
fi</p>

<h1 id="如果-num2-大于-num3-就把-num2-和-num3-对标-确保-num2-变量中存的是小一点的值">如果 num2 大于 num3,就把 num2 和 num3 对标,确保 num2 变量中存的是小一点的值</h1>

<p>if [ $num2 -gt  n u m 3 ] ; t h e n t m p = num3 ];then tmp=
num3];thentmp=num2<br />
num2= n u m 3 n u m 3 = num3 num3= num3num3=tmp<br />
fi<br />
echo “排序后数据(从小到大)为: n u m 1 , num1, num1,num2,$num3”<br />
11、石头、剪刀、布游戏</p>

<p>#!/bin/bash</p>

<h1 id="编写脚本-实现人机游戏">编写脚本,实现人机游戏</h1>

<p>game=(石头 剪刀 布)<br />
num= [ R A N D O M c o m p u t e r = [RANDOM%3] computer=
[RANDOMcomputer={game[$num]}</p>

<h1 id="通过随机数获取计算机的出拳">通过随机数获取计算机的出拳</h1>

<h1 id="出拳的可能性保存在一个数组中-game-0-game-1-game-2-分别是-3-中不同的可能">出拳的可能性保存在一个数组中,game[0],game[1],game[2]分别是 3 中不同的可能</h1>

<p>echo “请根据下列提示选择您的出拳手势”<br />
echo “1.石头”<br />
echo “2.剪刀”<br />
echo “3.布”</p>

<p>read -p “请选择 1‐3:” person<br />
case $person in<br />
1)<br />
if [ $num -eq 0 ]<br />
then<br />
echo “平局”<br />
elif [ $num -eq 1 ]<br />
then<br />
echo “你赢”<br />
else<br />
echo “计算机赢”<br />
fi;;<br />
2)<br />
if [ $num -eq 0 ]<br />
then<br />
echo “计算机赢”<br />
elif [ $num -eq 1 ]<br />
then<br />
echo “平局”<br />
else<br />
echo “你赢”<br />
fi;;<br />
3)<br />
if [ $num -eq 0 ]<br />
then<br />
echo “你赢”<br />
elif [ $num -eq 1 ]<br />
then<br />
echo “计算机赢”<br />
else<br />
echo “平局”<br />
fi;;<br />
*)<br />
echo “必须输入 1‐3 的数字”<br />
esac<br />
12、编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(for 版本)</p>

<p>#!/bin/bash</p>

<h1 id="编写脚本测试-192-168-4-0-24-整个网段中哪些主机处于开机状态-哪些主机处于关机">编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机</h1>

<h1 id="状态-for-版本">状态(for 版本)</h1>

<p>for i in {1…254}<br />
do</p>

<h1 id="每隔0-3秒ping一次-一共ping2次-并以1毫秒为单位设置ping的超时时间">每隔0.3秒ping一次，一共ping2次，并以1毫秒为单位设置ping的超时时间</h1>

<p>ping ‐c 2 ‐i 0.3 ‐W 1 192.168.4.$i &amp;&gt;/dev/null<br />
if [  ? − e q 0 ] ; t h e n e c h o &ldquo; 192.168.4. ? -eq 0 ];then echo
&ldquo;192.168.4. ?−eq0];thenecho&rdquo;192.168.4.i is up&rdquo;<br />
else<br />
echo “192.168.4.$i is down”<br />
fi<br />
done<br />
13、编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(while 版本)</p>

<p>#!/bin/bash</p>

<h1 id="编写脚本测试-192-168-4-0-24-整个网段中哪些主机处于开机状态-哪些主机处于关机-1">编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机</h1>

<h1 id="状态-while-版本">状态(while 版本)</h1>

<p>i=1<br />
while [  i − l e 254 ] d o p i n g ‐ c 2 ‐ i 0.3 ‐ W 1192.168.4. i -le 254 ]
do ping ‐c 2 ‐i 0.3 ‐W 1 192.168.4. i−le254]doping‐c2‐i0.3‐W1192.168.4.i
&amp;&gt;/dev/null<br />
if [  ? − e q 0 ] ; t h e n e c h o &ldquo; 192.168.4. ? -eq 0 ];then echo
&ldquo;192.168.4. ?−eq0];thenecho&rdquo;192.168.4.i is up&rdquo;<br />
else<br />
echo “192.168.4.$i is down”<br />
fi<br />
let i++<br />
done<br />
14、编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(多进程版)</p>

<p>#!/bin/bash</p>

<h1 id="编写脚本测试-192-168-4-0-24-整个网段中哪些主机处于开机状态-哪些主机处于关机-2">编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机</h1>

<h1 id="状态-多进程版">状态(多进程版)</h1>

<p>#定义一个函数,ping 某一台主机,并检测主机的存活状态<br />
myping(){<br />
ping ‐c 2 ‐i 0.3 ‐W 1 $1 &amp;&gt;/dev/null<br />
if [ $? -eq 0 ];then<br />
echo “$1 is up”<br />
else<br />
echo &ldquo;KaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;}&rsquo; at position 15: 1 is down&rdquo; fi
}̲ for i in {1..2…i &amp;<br />
done</p>

<h1 id="使用-符号-将执行的函数放入后台执行">使用&amp;符号,将执行的函数放入后台执行</h1>

<h1 id="这样做的好处是不需要等待ping第一台主机的回应-就可以继续并发ping第二台主机-依次类推">这样做的好处是不需要等待ping第一台主机的回应,就可以继续并发ping第二台主机,依次类推。</h1>

<p>15、编写脚本,显示进度条</p>

<p>#!/bin/bash</p>

<h1 id="编写脚本-显示进度条">编写脚本,显示进度条</h1>

<p>jindu(){<br />
while :<br />
do<br />
echo -n ‘#’<br />
sleep 0.2<br />
done<br />
}<br />
jindu &amp;<br />
cp -a $1 $2<br />
killall $0<br />
echo “拷贝完成”<br />
16、进度条,动态时针版本；定义一个显示进度的函数,屏幕快速显示| / ‐ </p>

<p>#!/bin/bash</p>

<h1 id="进度条-动态时针版本">进度条,动态时针版本</h1>

<h1 id="定义一个显示进度的函数-屏幕快速显示">定义一个显示进度的函数,屏幕快速显示| / ‐ </h1>

<p>rotate_line(){<br />
INTERVAL=0.5 #设置间隔时间<br />
COUNT=“0” #设置4个形状的编号,默认编号为 0(不代表任何图像)<br />
while :<br />
do<br />
COUNT=<code>expr $COUNT + 1</code> #执行循环,COUNT 每次循环加 1,(分别代表4种不同的形状)<br />
case $COUNT in #判断 COUNT 的值,值不一样显示的形状就不一样<br />
“1”) #值为 1 显示‐<br />
echo -e ‘‐’&rdquo;\b\c&rdquo;<br />
sleep $INTERVAL<br />
;;<br />
“2”) #值为 2 显示\,第一个\是转义<br />
echo -e ‘\’&rdquo;\b\c&rdquo;<br />
sleep $INTERVAL<br />
;;<br />
“3”) #值为 3 显示|<br />
echo -e “|\b\c”<br />
sleep $INTERVAL<br />
;;<br />
“4”) #值为 4 显示/<br />
echo -e “/\b\c”<br />
sleep $INTERVAL<br />
;;<br />
_) #值为其他时,将 COUNT 重置为 0<br />
COUNT=“0”;;<br />
esac<br />
done<br />
}<br />
rotate_line<br />
17、9_9 乘法表</p>

<p>#!/bin/bash</p>

<h1 id="9-9-乘法表-编写-shell-脚本-打印-9-9-乘法表">9 <em>9 乘法表(编写 shell 脚本,打印 9</em> 9 乘法表)</h1>

<p>for i in <code>seq 9</code><br />
do<br />
for j in <code>seq $i</code><br />
do<br />
echo -n &ldquo; j ∗ j* j∗i=$[i*j] &ldquo;<br />
done<br />
echo<br />
done<br />
18、使用死循环实时显示 eth0 网卡发送的数据包流量</p>

<p>#!/bin/bash</p>

<h1 id="使用死循环实时显示-eth0-网卡发送的数据包流量">使用死循环实时显示 eth0 网卡发送的数据包流量</h1>

<p>while :<br />
do<br />
echo &lsquo;本地网卡 eth0 流量信息如下: ’<br />
ifconfig eth0 | grep “RX pack” | awk ‘{print $5}’<br />
ifconfig eth0 | grep “TX pack” | awk ‘{print $5}’<br />
sleep 1<br />
done<br />
19、使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码本脚本执行,需要提前准备一个 user.txt
文件,该文件中包含有若干用户名信息</p>

<p>#!/bin/bash</p>

<h1 id="使用-user-txt-文件中的人员名单-在计算机中自动创建对应的账户并配置初始密码">使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码</h1>

<h1 id="本脚本执行-需要提前准备一个-user-txt-文件-该文件中包含有若干用户名信息">本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息</h1>

<p>for i in <code>cat user.txt</code><br />
do<br />
useradd $i<br />
echo “123456” | passwd ‐‐stdin $i<br />
done<br />
20、编写批量修改扩展名脚本</p>

<p>#!/bin/bash</p>

<h1 id="编写批量修改扩展名脚本-如批量将-txt-文件修改为-doc-文件">编写批量修改扩展名脚本,如批量将 txt 文件修改为 doc 文件</h1>

<h1 id="执行脚本时-需要给脚本添加位置参数">执行脚本时,需要给脚本添加位置参数</h1>

<h1 id="脚本名-txt-doc-可以将-txt-的扩展名修改为-doc">脚本名 txt doc(可以将 txt 的扩展名修改为 doc)</h1>

<h1 id="脚本名-doc-jpg-可以将-doc-的扩展名修改为-jpg">脚本名 doc jpg(可以将 doc 的扩展名修改为 jpg)</h1>

<p>for i in &ldquo;ls <em>.$1&rdquo;<br />
do<br />
mv $i ${i%.</em>}.$2<br />
done<br />
21、使用 expect 工具自动交互密码远程其他主机安装 httpd 软件</p>

<p>#!/bin/bash</p>

<h1 id="使用-expect-工具自动交互密码远程其他主机安装-httpd-软件">使用 expect 工具自动交互密码远程其他主机安装 httpd 软件</h1>

<h1 id="删除-ssh-known-hosts-后-ssh-远程任何主机都会询问是否确认要连接该主机">删除~/.ssh/known_hosts 后,ssh 远程任何主机都会询问是否确认要连接该主机</h1>

<p>rm ‐rf ~/.ssh/known_hosts<br />
expect &lt; spawn ssh 192.168.4.254</p>

<p>expect “yes/no” {send “yes\r”}</p>

<h1 id="根据自己的实际情况将密码修改为真实的密码字串">根据自己的实际情况将密码修改为真实的密码字串</h1>

<p>expect “password” {send “密码\r”}<br />
expect “#” {send “yum ‐y install httpd\r”}<br />
expect “#” {send “exit\r”}<br />
EOF<br />
22、一键部署 LNMP(源码安装版本)</p>

<p>#!/bin/bash</p>

<h1 id="一键部署-lnmp-源码安装版本">一键部署 LNMP(源码安装版本)</h1>

<p>menu()<br />
{<br />
clear<br />
echo &ldquo; ##############‐‐‐‐Menu‐‐‐‐##############&rdquo;<br />
echo “# 1. Install Nginx”<br />
echo “# 2. Install MySQL”<br />
echo “# 3. Install PHP”<br />
echo “# 4. Exit Program”<br />
echo &ldquo; ########################################&rdquo;<br />
}</p>

<p>choice()<br />
{<br />
read -p “Please choice a menu[1‐9]:” select<br />
}</p>

<p>install_nginx()<br />
{<br />
id nginx &amp;&gt;/dev/null<br />
if [ $? -ne 0 ];then<br />
useradd -s /sbin/nologin nginx<br />
fi<br />
if [ -f nginx‐1.8.0.tar.gz ];then<br />
tar -xf nginx‐1.8.0.tar.gz<br />
cd nginx‐1.8.0<br />
yum -y install gcc pcre‐devel openssl‐devel zlib‐devel make<br />
./configure ‐‐prefix=/usr/local/nginx ‐‐with‐http_ssl_module<br />
make<br />
make install<br />
ln -s /usr/local/nginx/sbin/nginx /usr/sbin/<br />
cd …<br />
else<br />
echo “没有 Nginx 源码包”<br />
fi<br />
}</p>

<p>install_mysql()<br />
{<br />
yum -y install gcc gcc‐c++ cmake ncurses‐devel perl<br />
id mysql &amp;&gt;/dev/null<br />
if [ $? -ne 0 ];then<br />
useradd -s /sbin/nologin mysql<br />
fi<br />
if [ -f mysql‐5.6.25.tar.gz ];then<br />
tar -xf mysql‐5.6.25.tar.gz<br />
cd mysql‐5.6.25<br />
cmake .<br />
make<br />
make install<br />
/usr/local/mysql/scripts/mysql_install_db ‐‐user=mysql
‐‐datadir=/usr/local/mysql/data/<br />
‐‐basedir=/usr/local/mysql/<br />
chown -R root.mysql /usr/local/mysql<br />
chown -R mysql /usr/local/mysql/data<br />
/bin/cp -f /usr/local/mysql/support‐files/mysql.server /etc/init.d/mysqld<br />
chmod +x /etc/init.d/mysqld<br />
/bin/cp -f /usr/local/mysql/support‐files/my‐default.cnf /etc/my.cnf<br />
echo “/usr/local/mysql/lib/” &gt;&gt; /etc/ld.so.conf<br />
ldconfig<br />
echo ‘PATH=$PATH:/usr/local/mysql/bin/’ &gt;&gt; /etc/profile<br />
export PATH<br />
else<br />
echo “没有 mysql 源码包”<br />
exit<br />
fi<br />
}</p>

<p>install_php()<br />
{<br />
#安装 php 时没有指定启动哪些模块功能,如果的用户可以根据实际情况自行添加额外功能如‐‐with‐gd 等<br />
yum -y install gcc libxml2‐devel<br />
if [ -f mhash‐0.9.9.9.tar.gz ];then<br />
tar -xf mhash‐0.9.9.9.tar.gz<br />
cd mhash‐0.9.9.9<br />
./configure<br />
make<br />
make install<br />
cd …<br />
if [ ! ‐f /usr/lib/libmhash.so ];then<br />
ln -s /usr/local/lib/libmhash.so /usr/lib/<br />
fi<br />
ldconfig<br />
else<br />
echo “没有 mhash 源码包文件”<br />
exit<br />
fi<br />
if [ -f libmcrypt‐2.5.8.tar.gz ];then<br />
tar -xf libmcrypt‐2.5.8.tar.gz<br />
cd libmcrypt‐2.5.8<br />
./configure<br />
make<br />
make install<br />
cd …<br />
if [ ! -f /usr/lib/libmcrypt.so ];then<br />
ln -s /usr/local/lib/libmcrypt.so /usr/lib/<br />
fi<br />
ldconfig<br />
else<br />
echo “没有 libmcrypt 源码包文件”<br />
exit<br />
fi<br />
if [ -f php‐5.4.24.tar.gz ];then<br />
tar -xf php‐5.4.24.tar.gz<br />
cd php‐5.4.24<br />
./configure ‐‐prefix=/usr/local/php5 ‐‐with‐mysql=/usr/local/mysql
‐‐enable‐fpm ‐‐<br />
enable‐mbstring ‐‐with‐mcrypt ‐‐with‐mhash
‐‐with‐config‐file‐path=/usr/local/php5/etc ‐‐with‐<br />
mysqli=/usr/local/mysql/bin/mysql_config<br />
make &amp;&amp; make install<br />
/bin/cp -f php.ini‐production /usr/local/php5/etc/php.ini<br />
/bin/cp -f /usr/local/php5/etc/php‐fpm.conf.default
/usr/local/php5/etc/php‐fpm.conf<br />
cd …<br />
else<br />
echo “没有 php 源码包文件”<br />
exit<br />
fi<br />
}</p>

<p>while :<br />
do<br />
menu<br />
choice<br />
case $select in<br />
1)<br />
install_nginx<br />
;;<br />
2)<br />
install_mysql<br />
;;<br />
3)<br />
install_php<br />
;;<br />
4)<br />
exit<br />
;;<br />
*)<br />
echo Sorry!<br />
esac<br />
done<br />
23、编写脚本快速克隆 KVM 虚拟机</p>

<p>#!/bin/bash</p>

<h1 id="编写脚本快速克隆-kvm-虚拟机">编写脚本快速克隆 KVM 虚拟机</h1>

<h1 id="本脚本针对-rhel7-2-或-centos7-2">本脚本针对 RHEL7.2 或 Centos7.2</h1>

<h1 id="本脚本需要提前准备一个-qcow2-格式的虚拟机模板">本脚本需要提前准备一个 qcow2 格式的虚拟机模板,</h1>

<h1 id="名称为-var-lib-libvirt-images-rh7-template-的虚拟机模板">名称为/var/lib/libvirt/images /.rh7_template 的虚拟机模板</h1>

<h1 id="该脚本使用-qemu-img-命令快速创建快照虚拟机">该脚本使用 qemu‐img 命令快速创建快照虚拟机</h1>

<h1 id="脚本使用-sed-修改模板虚拟机的配置文件-将虚拟机名称-uuid-磁盘文件名-mac-地址">脚本使用 sed 修改模板虚拟机的配置文件,将虚拟机名称、UUID、磁盘文件名、MAC 地址</h1>

<h1 id="exit-code">exit code:</h1>

<h1 id="65-user-input-nothing">65 ‐&gt; user input nothing</h1>

<h1 id="66-user-input-is-not-a-number">66 ‐&gt; user input is not a number</h1>

<h1 id="67-user-input-out-of-range">67 ‐&gt; user input out of range</h1>

<h1 id="68-vm-disk-image-exists">68 ‐&gt; vm disk image exists</h1>

<p>IMG_DIR=/var/lib/libvirt/images<br />
BASEVM=rh7_template<br />
read -p &ldquo;Enter VM number: &ldquo; VMNUM<br />
if [  V M N U M − l e 9 ] ; t h e n V M N U M = 0 VMNUM -le 9 ];then VMNUM=0
VMNUM−le9];thenVMNUM=0VMNUM<br />
fi</p>

<p>if [ -z “${VMNUM}” ]; then<br />
echo “You must input a number.”<br />
exit 65<br />
elif [[ ${VMNUM} =~ [a‐z] ]; then<br />
echo “You must input a number.”<br />
exit 66<br />
elif [ ${VMNUM} -lt 1 -o ${VMNUM} -gt 99 ]; then<br />
echo “Input out of range”<br />
exit 67<br />
fi</p>

<p>NEWVM=rh7_node${VMNUM}</p>

<p>if [ -e  I M G D I R / IMG_DIR/ IMGD​IR/{NEWVM}.img ]; then<br />
echo “File exists.”<br />
exit 68<br />
fi</p>

<p>echo -en “Creating Virtual Machine disk image…\t”<br />
qemu‐img create -f qcow2 ‐b  I M G D I R / . IMG_DIR/. IMGD​IR/.{BASEVM}.img
I M G D I R / IMG_DIR/ IMGD​IR/{NEWVM}.img &amp;&gt; /dev/null</p>

<p>echo -e “\e[32;1m[OK]\e[0m”</p>

<p>#virsh dumpxml  B A S E V M &gt; / t m p / m y v m . x m l c a t / v a r / l i b
/ l i b v i r t / i m a g e s / . r h e l 7. x m l &gt; / t m p / m y v m . x m l
s e d − i &ldquo; / &lt; n a m e &gt; {BASEVM} &gt; /tmp/myvm.xml cat
/var/lib/libvirt/images/.rhel7.xml &gt; /tmp/myvm.xml sed -i &ldquo;/
BASEVM&gt;/tmp/myvm.xmlcat/var/lib/libvirt/images/.rhel7.xml&gt;/tmp/myvm.xmlsed−i&rdquo;/<name>{BASEVM}/s/
B A S E V M / {BASEVM}/ BASEVM/{NEWVM}/&rdquo; /tmp/myvm.xml<br />
sed -i “/uuid/s/.*/KaTeX parse error: Undefined control sequence: \/ at
position 11: (uuidgen)/&rdquo; /tmp/my…{BASEVM}.img/s/ B A S E V M / {BASEVM}/
BASEVM/{NEWVM}/” /tmp/myvm.xml</p>

<h1 id="修改-mac-地址-本例使用的是常量-每位使用该脚本的用户需要根据实际情况修改这些值">修改 MAC 地址,本例使用的是常量,每位使用该脚本的用户需要根据实际情况修改这些值</h1>

<h1 id="最好这里可以使用便利-这样更适合于批量操作-可以克隆更多虚拟机">最好这里可以使用便利,这样更适合于批量操作,可以克隆更多虚拟机</h1>

<p>sed -i “/mac /s/a1/0c/” /tmp/myvm.xml</p>

<p>echo -en “Defining new virtual machine…\t\t”<br />
virsh define /tmp/myvm.xml &amp;&gt; /dev/null<br />
echo -e “\e[32;1m[OK]\e[0m”<br />
24、点名器脚本</p>

<p>#!/bin/bash</p>

<h1 id="编写一个点名器脚本">编写一个点名器脚本</h1>

<h1 id="该脚本-需要提前准备一个-user-txt-文件">该脚本,需要提前准备一个 user.txt 文件</h1>

<h1 id="该文件中需要包含所有姓名的信息-一行一个姓名-脚本每次随机显示一个姓名">该文件中需要包含所有姓名的信息,一行一个姓名,脚本每次随机显示一个姓名</h1>

<p>while :<br />
do<br />
#统计 user 文件中有多少用户<br />
line=<code>cat user.txt |wc ‐l</code><br />
num= [ R A N D O M s e d − n &ldquo; [RANDOM%line+1] sed -n &ldquo; [RANDOMsed−n&rdquo;{num}p&rdquo;
user.txt<br />
sleep 0.2<br />
clear<br />
done<br />
25、查看有多少远程的 IP 在连接本机</p>

<p>#!/bin/bash</p>

<h1 id="查看有多少远程的-ip-在连接本机-不管是通过-ssh-还是-web-还是-ftp-都统计">查看有多少远程的 IP 在连接本机(不管是通过 ssh 还是 web 还是 ftp 都统计)</h1>

<h1 id="使用-netstat-atn-可以查看本机所有连接的状态-a-查看所有">使用 netstat ‐atn 可以查看本机所有连接的状态,‐a 查看所有,</h1>

<h1 id="t仅显示-tcp-连接的信息-n-数字格式显示">-t仅显示 tcp 连接的信息,‐n 数字格式显示</h1>

<h1 id="local-address-第四列是本机的-ip-和端口信息">Local Address(第四列是本机的 IP 和端口信息)</h1>

<h1 id="foreign-address-第五列是远程主机的-ip-和端口信息">Foreign Address(第五列是远程主机的 IP 和端口信息)</h1>

<h1 id="使用-awk-命令仅显示第-5-列数据-再显示第-1-列-ip-地址的信息">使用 awk 命令仅显示第 5 列数据,再显示第 1 列 IP 地址的信息</h1>

<h1 id="sort-可以按数字大小排序-最后使用-uniq-将多余重复的删除-并统计重复的次数">sort 可以按数字大小排序,最后使用 uniq 将多余重复的删除,并统计重复的次数</h1>

<p>netstat -atn | awk ‘{print $5}’ | awk ‘{print $1}’ | sort -nr | uniq -c<br />
26、对 100 以内的所有正整数相加求和(1+2+3+4…+100)</p>

<p>#!/bin/bash</p>

<h1 id="对-100-以内的所有正整数相加求和-1-2-3-4-100">对 100 以内的所有正整数相加求和(1+2+3+4…+100)</h1>

<p>#seq 100 可以快速自动生成 100 个整数<br />
sum=0<br />
for i in <code>seq 100</code><br />
do<br />
sum= [ s u m + i ] d o n e e c h o &ldquo; 总 和 是 : [sum+i] done echo &ldquo;总和是:
[sum+i]doneecho&rdquo;总和是:sum&rdquo;<br />
27、统计 13:30 到 14:30 所有访问 apache 服务器的请求有多少个</p>

<p>#!/bin/bash</p>

<h1 id="统计-13-30-到-14-30-所有访问-apache-服务器的请求有多少个">统计 13:30 到 14:30 所有访问 apache 服务器的请求有多少个</h1>

<h1 id="awk-使用-f-选项指定文件内容的分隔符是-或者">awk 使用‐F 选项指定文件内容的分隔符是/或者:</h1>

<h1 id="条件判断-7-8-大于等于-13-30-并且要求-7-8-小于等于-14-30">条件判断$7:$8 大于等于 13:30,并且要求,$7:$8 小于等于 14:30</h1>

<h1 id="最后使用-wc-l-统计这样的数据有多少行-即多少个">最后使用 wc ‐l 统计这样的数据有多少行,即多少个</h1>

<p>awk -F “[ /:]” ‘$7&rdquo;:&ldquo;$8&gt;=“13:30” &amp;&amp; $7&rdquo;:&ldquo;$8&lt;=“14:30”’
/var/log/httpd/access_log |wc -l<br />
28、统计 13:30 到 14:30 所有访问本机 Aapche 服务器的远程 IP 地址是什么</p>

<p>#!/bin/bash</p>

<h1 id="统计-13-30-到-14-30-所有访问本机-aapche-服务器的远程-ip-地址是什么">统计 13:30 到 14:30 所有访问本机 Aapche 服务器的远程 IP 地址是什么</h1>

<h1 id="awk-使用-f-选项指定文件内容的分隔符是-或者-1">awk 使用‐F 选项指定文件内容的分隔符是/或者:</h1>

<h1 id="条件判断-7-8-大于等于-13-30-并且要求-7-8-小于等于-14-30-1">条件判断$7:$8 大于等于 13:30,并且要求,$7:$8 小于等于 14:30</h1>

<h1 id="日志文档内容里面-第-1-列是远程主机的-ip-地址-使用-awk-单独显示第-1-列即可">日志文档内容里面,第 1 列是远程主机的 IP 地址,使用 awk 单独显示第 1 列即可</h1>

<p>awk -F “[ /:]” ‘$7&rdquo;:&ldquo;$8&gt;=“13:30” &amp;&amp; $7&rdquo;:&ldquo;$8&lt;=“14:30”{print $1}’
/var/log/httpd/access_log<br />
29、打印国际象棋棋盘</p>

<p>#!/bin/bash</p>

<h1 id="打印国际象棋棋盘">打印国际象棋棋盘</h1>

<h1 id="设置两个变量-i-和-j-一个代表行-一个代表列-国际象棋为-8-8-棋盘">设置两个变量,i 和 j,一个代表行,一个代表列,国际象棋为 8*8 棋盘</h1>

<h1 id="i-1-是代表准备打印第一行棋盘-第-1-行棋盘有灰色和蓝色间隔输出-总共为-8-列">i=1 是代表准备打印第一行棋盘,第 1 行棋盘有灰色和蓝色间隔输出,总共为 8 列</h1>

<h1 id="i-1-j-1-代表第-1-行的第-1-列-i-2-j-3-代表第-2-行的第-3-列">i=1,j=1 代表第 1 行的第 1 列;i=2,j=3 代表第 2 行的第 3 列</h1>

<h1 id="棋盘的规律是-i-j-如果是偶数-就打印蓝色色块-如果是奇数就打印灰色色块">棋盘的规律是 i+j 如果是偶数,就打印蓝色色块,如果是奇数就打印灰色色块</h1>

<h1 id="使用-echo-ne-打印色块-并且打印完成色块后不自动换行-在同一行继续输出其他色块">使用 echo ‐ne 打印色块,并且打印完成色块后不自动换行,在同一行继续输出其他色块</h1>

<p>for i in {1…8}<br />
do<br />
for j in {1…8}<br />
do<br />
sum=$[i+j]<br />
if [ $[sum%2] -eq 0 ];then<br />
echo -ne “\033[46m \033[0m”<br />
else<br />
echo -ne “\033[47m \033[0m”<br />
fi<br />
done<br />
echo<br />
done<br />
30、统计每个远程 IP 访问了本机 apache 几次?</p>

<p>#!/bin/bash</p>

<h1 id="统计每个远程-ip-访问了本机-apache-几次">统计每个远程 IP 访问了本机 apache 几次?</h1>

<p>awk ‘{ip[$1]++}END{for(i in ip){print ip[i],i}}’ /var/log/httpd/access_log<br />
31、统计当前 Linux 系统中可以登录计算机的账户有多少个</p>

<p>#!/bin/bash</p>

<h1 id="统计当前-linux-系统中可以登录计算机的账户有多少个">统计当前 Linux 系统中可以登录计算机的账户有多少个</h1>

<p>#方法 1:<br />
grep &ldquo;bashKaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;#&rsquo; at position 23: …passwd |
wc -l #̲方法 2: awk -f: &lsquo;…/{x++}end{print x}’ /etc/passwd<br />
32、统计/var/log 有多少个文件,并显示这些文件名</p>

<p>#!/bin/bash</p>

<h1 id="统计-var-log-有多少个文件-并显示这些文件名">统计/var/log 有多少个文件,并显示这些文件名</h1>

<h1 id="使用-ls-递归显示所有-再判断是否为文件-如果是文件则计数器加-1">使用 ls 递归显示所有,再判断是否为文件,如果是文件则计数器加 1</h1>

<p>cd /var/log<br />
sum=0<br />
for i in <code>ls -r *</code><br />
do<br />
if [ -f  i ] ; t h e n l e t s u m + + e c h o &ldquo; 文 件 名 : i ];then let sum++
echo &ldquo;文件名: i];thenletsum++echo&rdquo;文件名:i&rdquo;<br />
fi<br />
done<br />
echo “总文件数量为:$sum”<br />
33、自动为其他脚本添加解释器信息</p>

<p>#!/bin/bash</p>

<h1 id="自动为其他脚本添加解释器信息-bin-bash-如脚本名为-test-sh-则效果如下">自动为其他脚本添加解释器信息#!/bin/bash,如脚本名为 test.sh 则效果如下:</h1>

<h1 id="test-sh-abc-sh-自动为-abc-sh-添加解释器信息">./test.sh abc.sh 自动为 abc.sh 添加解释器信息</h1>

<h1 id="test-sh-user-sh-自动为-user-sh-添加解释器信息">./test.sh user.sh 自动为 user.sh 添加解释器信息</h1>

<h1 id="先使用-grep-判断对象脚本是否已经有解释器信息-如果没有则使用-sed-添加解释器以及描述信息">先使用 grep 判断对象脚本是否已经有解释器信息,如果没有则使用 sed 添加解释器以及描述信息</h1>

<p>if ! grep -q “^#!” $1; then<br />
sed ‘1i #!/bin/bash’ $1<br />
sed &lsquo;2i #Description: ’<br />
fi</p>

<h1 id="因为每个脚本的功能不同-作用不同-所以在给对象脚本添加完解释器信息-以及-description-后还希望">因为每个脚本的功能不同,作用不同,所以在给对象脚本添加完解释器信息,以及 Description 后还希望</h1>

<h1 id="继续编辑具体的脚本功能的描述信息-这里直接使用-vim-把对象脚本打开-并且光标跳转到该文件的第-2-行">继续编辑具体的脚本功能的描述信息,这里直接使用 vim 把对象脚本打开,并且光标跳转到该文件的第 2 行</h1>

<p>vim +2 $1<br />
34、自动化部署 varnish 源码包软件</p>

<p>#!/bin/bash</p>

<h1 id="自动化部署-varnish-源码包软件">自动化部署 varnish 源码包软件</h1>

<h1 id="本脚本需要提前下载-varnish-3-0-6-tar-gz-这样一个源码包软件-该脚本即可用自动源码安装部署软件">本脚本需要提前下载 varnish‐3.0.6.tar.gz 这样一个源码包软件,该脚本即可用自动源码安装部署软件</h1>

<p>yum -y install gcc readline‐devel pcre‐devel<br />
useradd -s /sbin/nologin varnish<br />
tar -xf varnish‐3.0.6.tar.gz<br />
cd varnish‐3.0.6</p>

<h1 id="使用-configure-make-make-install-源码安装软件包">使用 configure,make,make install 源码安装软件包</h1>

<p>./configure ‐‐prefix=/usr/local/varnish<br />
make &amp;&amp; make install</p>

<h1 id="在源码包目录下-将相应的配置文件拷贝到-linux-系统文件系统中">在源码包目录下,将相应的配置文件拷贝到 Linux 系统文件系统中</h1>

<h1 id="默认安装完成后-不会自动拷贝或安装配置文件到-linux-系统-所以需要手动-cp-复制配置文件">默认安装完成后,不会自动拷贝或安装配置文件到 Linux 系统,所以需要手动 cp 复制配置文件</h1>

<h1 id="并使用-uuidgen-生成一个随机密钥的配置文件">并使用 uuidgen 生成一个随机密钥的配置文件</h1>

<p>cp redhat/varnish.initrc /etc/init.d/varnish<br />
cp redhat/varnish.sysconfig /etc/sysconfig/varnish<br />
cp redhat/varnish_reload_vcl /usr/bin/<br />
ln -s /usr/local/varnish/sbin/varnishd /usr/sbin/<br />
ln -s /usr/local/varnish/bin/* /usr/bin<br />
mkdir /etc/varnish<br />
cp /usr/local/varnish/etc/varnish/default.vcl /etc/varnish/<br />
uuidgen &gt; /etc/varnish/secret<br />
35、编写 nginx 启动脚本</p>

<p>#!/bin/bash</p>

<h1 id="编写-nginx-启动脚本">编写 nginx 启动脚本</h1>

<h1 id="本脚本编写完成后-放置在-etc-init-d-目录下-就可以被-linux-系统自动识别到该脚本">本脚本编写完成后,放置在/etc/init.d/目录下,就可以被 Linux 系统自动识别到该脚本</h1>

<h1 id="如果本脚本名为-etc-init-d-nginx-则-service-nginx-start-就可以启动该服务">如果本脚本名为/etc/init.d/nginx,则 service nginx start 就可以启动该服务</h1>

<h1 id="service-nginx-stop-就可以关闭服务">service nginx stop 就可以关闭服务</h1>

<h1 id="service-nginx-restart-可以重启服务">service nginx restart 可以重启服务</h1>

<h1 id="service-nginx-status-可以查看服务状态">service nginx status 可以查看服务状态</h1>

<p>program=/usr/local/nginx/sbin/nginx<br />
pid=/usr/local/nginx/logs/nginx.pid<br />
start(){<br />
if [ -f $pid ];then<br />
echo “nginx 服务已经处于开启状态”<br />
else<br />
$program<br />
fi<br />
stop(){<br />
if [ -! -f $pid ];then<br />
echo “nginx 服务已经关闭”<br />
else<br />
$program -s stop<br />
echo “关闭服务 ok”<br />
fi<br />
}<br />
status(){<br />
if [ -f $pid ];then<br />
echo “服务正在运行…”<br />
else<br />
echo “服务已经关闭”<br />
fi<br />
}</p>

<p>case $1 in<br />
start)<br />
start;;<br />
stop)<br />
stop;;<br />
restart)<br />
stop<br />
sleep 1<br />
start;;<br />
status)<br />
status;;<br />
*)<br />
echo “你输入的语法格式错误”<br />
esac<br />
36、自动对磁盘分区、格式化、挂载</p>

<p>#!/bin/bash</p>

<h1 id="自动对磁盘分区-格式化-挂载">自动对磁盘分区、格式化、挂载</h1>

<h1 id="对虚拟机的-vdb-磁盘进行分区格式化-使用">对虚拟机的 vdb 磁盘进行分区格式化,使用&lt;</h1>

<h1 id="n-新建分区-p-创建主分区-1-分区编号为-1-两个空白行-两个回车-相当于将整个磁盘分一个区">n(新建分区),p(创建主分区),1(分区编号为 1),两个空白行(两个回车,相当于将整个磁盘分一个区)</h1>

<h1 id="注意-1-后面的两个回车-空白行-是必须的">注意:1 后面的两个回车(空白行)是必须的!</h1>

<p>fdisk /dev/vdb &lt;&lt; EOF<br />
n<br />
p<br />
1</p>

<p>wq<br />
EOF</p>

<p>#格式化刚刚创建好的分区<br />
mkfs.xfs /dev/vdb1</p>

<p>#创建挂载点目录<br />
if [ -e /data ]; then<br />
exit<br />
fi<br />
mkdir /data</p>

<p>#自动挂载刚刚创建的分区,并设置开机自动挂载该分区<br />
echo ‘/dev/vdb1 /data xfs defaults 1 2’ &gt;&gt; /etc/fstab<br />
mount -a<br />
37、自动优化 Linux 内核参数</p>

<p>#!/bin/bash</p>

<h1 id="自动优化-linux-内核参数">自动优化 Linux 内核参数</h1>

<p>#脚本针对 RHEL7<br />
cat &gt;&gt; /usr/lib/sysctl.d/00‐system.conf &lt; fs.file‐max=65535<br />
net.ipv4.tcp_timestamps = 0<br />
net.ipv4.tcp_synack_retries = 5<br />
net.ipv4.tcp_syn_retries = 5<br />
net.ipv4.tcp_tw_recycle = 1<br />
net.ipv4.tcp_tw_reuse = 1<br />
net.ipv4.tcp_fin_timeout = 30<br />
#net.ipv4.tcp_keepalive_time = 120<br />
net.ipv4.ip_local_port_range = 1024 65535<br />
kernel.shmall = 2097152<br />
kernel.shmmax = 2147483648<br />
kernel.shmmni = 4096<br />
kernel.sem = 5010 641280 5010 128<br />
net.core.wmem_default=262144<br />
net.core.wmem_max=262144<br />
net.core.rmem_default=4194304<br />
net.core.rmem_max=4194304<br />
net.ipv4.tcp_fin_timeout = 10<br />
net.ipv4.tcp_keepalive_time = 30<br />
net.ipv4.tcp_window_scaling = 0<br />
net.ipv4.tcp_sack = 0<br />
EOF</p>

<p>sysctl –p<br />
38、切割 Nginx 日志文件(防止单个文件过大,后期处理很困难)</p>

<p>#mkdir /data/scripts<br />
#vim /data/scripts/nginx_log.sh<br />
#!/bin/bash</p>

<h1 id="切割-nginx-日志文件-防止单个文件过大-后期处理很困难">切割 Nginx 日志文件(防止单个文件过大,后期处理很困难)</h1>

<p>logs_path=&ldquo;/usr/local/nginx/logs/&rdquo;<br />
mv ${logs<em>path}access.log KaTeX parse error: Expected group after &lsquo;</em>&rsquo; at
position 18: …ogs_path}access_̲(date -d “yesterday” +&ldquo;%Y%m%d&rdquo;).log<br />
kill -USR1 <code>cat /usr/local/nginx/logs/nginx.pid</code></p>

<h1 id="chmod-x-data-scripts-nginx-log-sh">chmod +x /data/scripts/nginx_log.sh</h1>

<h1 id="crontab-e-脚本写完后-将脚本放入计划任务每天执行一次脚本">crontab ‐e #脚本写完后,将脚本放入计划任务每天执行一次脚本</h1>

<p>0 1 * * * /data/scripts/nginx_log.sh<br />
39、检测 MySQL 数据库连接数量</p>

<p>#!/bin/bash</p>

<h1 id="检测-mysql-数据库连接数量">检测 MySQL 数据库连接数量</h1>

<h1 id="本脚本每-2-秒检测一次-mysql-并发连接数-可以将本脚本设置为开机启动脚本-或在特定时间段执行">本脚本每 2 秒检测一次 MySQL 并发连接数,可以将本脚本设置为开机启动脚本,或在特定时间段执行</h1>

<h1 id="以满足对-mysql-数据库的监控需求-查看-mysql-连接是否正常">以满足对 MySQL 数据库的监控需求,查看 MySQL 连接是否正常</h1>

<h1 id="本案例中的用户名和密码需要根据实际情况修改后方可使用">本案例中的用户名和密码需要根据实际情况修改后方可使用</h1>

<p>log_file=/var/log/mysql_count.log<br />
user=root<br />
passwd=123456<br />
while :<br />
do<br />
sleep 2<br />
count=<code>mysqladmin -u &quot;$user&quot; -p &quot;$passwd&quot; status | awk '{print $4}'</code><br />
echo &ldquo;<code>date +%Y‐%m‐%d</code> 并发连接数为:$count&rdquo; &gt;&gt; $log_file<br />
done<br />
40、根据 md5 校验码,检测文件是否被修改</p>

<p>#!/bin/bash</p>

<h1 id="根据-md5-校验码-检测文件是否被修改">根据 md5 校验码,检测文件是否被修改</h1>

<h1 id="本示例脚本检测的是-etc-目录下所有的-conf-结尾的文件-根据实际情况-您可以修改为其他目录或文件">本示例脚本检测的是/etc 目录下所有的 conf 结尾的文件,根据实际情况,您可以修改为其他目录或文件</h1>

<h1 id="本脚本在目标数据没有被修改时执行一次-当怀疑数据被人篡改-再执行一次">本脚本在目标数据没有被修改时执行一次,当怀疑数据被人篡改,再执行一次</h1>

<h1 id="将两次执行的结果做对比-md5-码发生改变的文件-就是被人篡改的文件">将两次执行的结果做对比,MD5 码发生改变的文件,就是被人篡改的文件</h1>

<p>for i in  ( l s / e t c / ∗ . c o n f ) d o m d 5 s u m &ldquo; (ls /etc/*.conf) do
md5sum &ldquo; (ls/etc/∗.conf)domd5sum&rdquo;i&rdquo; &gt;&gt; /var/log/conf_file.log<br />
done<br />
41、检测 MySQL 服务是否存活</p>

<p>#!/bin/bash</p>

<h1 id="检测-mysql-服务是否存活">检测 MySQL 服务是否存活</h1>

<h1 id="host-为你需要检测的-mysql-主机的-ip-地址-user-为-mysql-账户名-passwd-为密码">host 为你需要检测的 MySQL 主机的 IP 地址,user 为 MySQL 账户名,passwd 为密码</h1>

<h1 id="这些信息需要根据实际情况修改后方可使用">这些信息需要根据实际情况修改后方可使用</h1>

<p>host=192.168.51.198<br />
user=root<br />
passwd=123456<br />
mysqladmin -h ‘ h o s t ′ − u ′ host&rsquo; -u &lsquo; host′−u′user’ -p’$passwd’ ping
&amp;&gt;/dev/null<br />
if [ $? -eq 0 ]<br />
then<br />
echo “MySQL is UP”<br />
else<br />
echo “MySQL is down”<br />
fi<br />
42、备份 MySQL 的 shell 脚本(mysqldump版本)</p>

<p>#!/bin/bash</p>

<h1 id="备份-mysql-的-shell-脚本-mysqldump版本">备份 MySQL 的 shell 脚本(mysqldump版本)</h1>

<h1 id="定义变量-user-数据库用户名-passwd-数据库密码-date-备份的时间标签">定义变量 user(数据库用户名),passwd(数据库密码),date(备份的时间标签)</h1>

<h1 id="dbname-需要备份的数据库名称-根据实际需求需要修改该变量的值-默认备份-mysql-数据库">dbname(需要备份的数据库名称,根据实际需求需要修改该变量的值,默认备份 mysql 数据库)</h1>

<p>user=root<br />
passwd=123456<br />
dbname=mysql<br />
date=$(date +%Y%m%d)</p>

<h1 id="测试备份目录是否存在-不存在则自动创建该目录">测试备份目录是否存在,不存在则自动创建该目录</h1>

<p>[ ! -d /mysqlbackup ] &amp;&amp; mkdir /mysqlbackup</p>

<h1 id="使用-mysqldump-命令备份数据库">使用 mysqldump 命令备份数据库</h1>

<p>mysqldump -u “ u s e r &ldquo; − p &rdquo; user&rdquo; -p &ldquo; user&rdquo;−p&rdquo;passwd” “ d b n a m e &ldquo; &gt; /
m y s q l b a c k u p / &ldquo; dbname&rdquo; &gt; /mysqlbackup/&rdquo;
dbname&rdquo;&gt;/mysqlbackup/&ldquo;dbname”-${date}.sql<br />
43、将文件中所有的小写字母转换为大写字母</p>

<p>#!/bin/bash</p>

<h1 id="将文件中所有的小写字母转换为大写字母">将文件中所有的小写字母转换为大写字母</h1>

<h1 id="1是位置参数-是你需要转换大小写字母的文件名称">$1是位置参数,是你需要转换大小写字母的文件名称</h1>

<h1 id="执行脚本-给定一个文件名作为参数-脚本就会将该文件中所有的小写字母转换为大写字母">执行脚本,给定一个文件名作为参数,脚本就会将该文件中所有的小写字母转换为大写字母</h1>

<p>tr “[a‐z]” “[A‐Z]” &lt; $1<br />
44、非交互自动生成 SSH 密钥文件</p>

<p>#!/bin/bash</p>

<h1 id="非交互自动生成-ssh-密钥文件">非交互自动生成 SSH 密钥文件</h1>

<h1 id="t-指定-ssh-密钥的算法为-rsa-算法-n-设置密钥的密码为空-f-指定生成的密钥文件-存放在哪里">‐t 指定 SSH 密钥的算法为 RSA 算法;‐N 设置密钥的密码为空;‐f 指定生成的密钥文件&gt;存放在哪里</h1>

<p>rm -rf ~/.ssh/{known_hosts,id_rsa*}<br />
ssh‐keygen -t RSA -N ‘’ -f ~/.ssh/id_rsa<br />
45、检查特定的软件包是否已经安装</p>

<p>#!/bin/bash</p>

<h1 id="检查特定的软件包是否已经安装">检查特定的软件包是否已经安装</h1>

<p>if [ $# -eq 0 ];then<br />
echo “你需要制定一个软件包名称作为脚本参数”<br />
echo “用法:$0 软件包名称 …”<br />
fi</p>

<h1 id="提-取-所-有-的-位-置-变-量-的-值-相-当-于-提取所有的位置变量的值-相当于-提取所有的位置变量的值-相当于">@ 提 取 所 有 的 位 置 变 量 的 值 , 相 当 于 @提取所有的位置变量的值,相当于 @提取所有的位置变量的值,相当于*</h1>

<p>for package in “$@”<br />
do<br />
if rpm -q KaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;&amp;&rsquo; at position 11: {package}
&amp;̲&gt;/dev/null ;the…{package}\033[32m 已经安装\033[0m&rdquo;<br />
else<br />
echo -e “${package}\033[34;1m 未安装\033[0m”<br />
fi<br />
done<br />
46、监控 HTTP 服务器的状态(测试返回码)</p>

<p>#!/bin/bash</p>

<h1 id="监控-http-服务器的状态-测试返回码">监控 HTTP 服务器的状态(测试返回码)</h1>

<h1 id="设置变量-url为你需要检测的目标网站的网址-ip-或域名-比如百度">设置变量,url为你需要检测的目标网站的网址(IP 或域名),比如百度</h1>

<p>url=<a href="http://http://183.232.231.172/index.html">http://http://183.232.231.172/index.html</a></p>

<h1 id="定义函数-check-http">定义函数 check_http:</h1>

<h1 id="使用-curl-命令检查-http-服务器的状态">使用 curl 命令检查 http 服务器的状态</h1>

<h1 id="m-设置curl不管访问成功或失败-最大消耗的时间为-5-秒-5-秒连接服务为相应则视为无法连接">‐m 设置curl不管访问成功或失败,最大消耗的时间为 5 秒,5 秒连接服务为相应则视为无法连接</h1>

<h1 id="s-设置静默连接-不显示连接时的连接速度-时间消耗等信息">‐s 设置静默连接,不显示连接时的连接速度、时间消耗等信息</h1>

<h1 id="o-将-curl-下载的页面内容导出到-dev-null-默认会在屏幕显示页面内容">‐o 将 curl 下载的页面内容导出到/dev/null(默认会在屏幕显示页面内容)</h1>

<h1 id="w-设置curl命令需要显示的内容-http-code-指定curl返回服务器的状态码">‐w 设置curl命令需要显示的内容%{http_code},指定curl返回服务器的状态码</h1>

<p>check_http()<br />
{<br />
status_code=$(curl -m 5 -s -o /dev/null -w %{http_code} $url)<br />
}</p>

<p>while :<br />
do<br />
check_http<br />
date=$(date +%Y%m%d‐%H:%M:%S)</p>

<h1 id="生成报警邮件的内容">生成报警邮件的内容</h1>

<pre><code>    echo &quot;当前时间为:$date
    $url 服务器异常,状态码为${status_code}.
    请尽快排查异常.&quot; &gt; /tmp/http$$.pid
</code></pre>

<h1 id="指定测试服务器状态的函数-并根据返回码决定是发送邮件报警还是将正常信息写入日志">指定测试服务器状态的函数,并根据返回码决定是发送邮件报警还是将正常信息写入日志</h1>

<pre><code>    if [ $status_code -ne 200 ];then
            mail -s Warning root &lt; /tmp/http$$.pid
    else
            echo &quot;$url 连接正常&quot; &gt;&gt; /var/log/http.log
    fi
    sleep 5
</code></pre>

<p>done</p>

<p>47、自动添加防火墙规则,开启某些服务或端口(适用于 RHEL7)</p>

<p>#!/bin/bash</p>

<h1 id="自动添加防火墙规则-开启某些服务或端口-适用于-rhel7">自动添加防火墙规则,开启某些服务或端口(适用于 RHEL7)</h1>

<p>#</p>

<h1 id="设置变量定义需要添加到防火墙规则的服务和端口号">设置变量定义需要添加到防火墙规则的服务和端口号</h1>

<h1 id="使用-firewall-cmd-get-services-可以查看-firewall-支持哪些服务">使用 firewall‐cmd ‐‐get‐services 可以查看 firewall 支持哪些服务</h1>

<p>service=“nfs http ssh”<br />
port=“80 22 8080”</p>

<h1 id="循环将每个服务添加到防火墙规则中">循环将每个服务添加到防火墙规则中</h1>

<p>for i in $service<br />
do<br />
echo &ldquo;Adding  i s e r v i c e t o f i r e w a l l &rdquo; f i r e w a l l ‐ c m d −
− a d d − s e r v i c e = i service to firewall&rdquo; firewall‐cmd &ndash;add-service=
iservicetofirewall&rdquo;firewall‐cmd−−add−service={i}<br />
done</p>

<p>#循环将每个端口添加到防火墙规则中<br />
for i in $port<br />
do<br />
echo &ldquo;Adding  i P o r t t o f i r e w a l l &rdquo; f i r e w a l l ‐ c m d − − a d
d − p o r t = i Port to firewall&rdquo; firewall‐cmd &ndash;add-port=
iPorttofirewall&rdquo;firewall‐cmd−−add−port={i}/tcp<br />
done<br />
#将以上设置的临时防火墙规则,转换为永久有效的规则(确保重启后有效)<br />
firewall‐cmd &ndash;runtime-to-permanent<br />
48、使用脚本自动创建逻辑卷</p>

<p>#!/bin/bash</p>

<h1 id="使用脚本自动创建逻辑卷">使用脚本自动创建逻辑卷</h1>

<h1 id="清屏-显示警告信息-创建将磁盘转换为逻辑卷会删除数据">清屏,显示警告信息,创建将磁盘转换为逻辑卷会删除数据</h1>

<p>clear<br />
echo -e “\033[32m !!!警告(Warning)!!!\033[0m”<br />
echo<br />
echo “+++++++++++++++++++++++++++++++++++++++++++++++++”<br />
echo “脚本会将整个磁盘转换为 PV,并删除磁盘上所有数据!!!”<br />
echo “This Script will destroy all data on the Disk”<br />
echo “+++++++++++++++++++++++++++++++++++++++++++++++++”<br />
echo<br />
read -p “请问是否继续 y/n?:” sure</p>

<h1 id="测试用户输入的是否为-y-如果不是则退出脚本">测试用户输入的是否为 y,如果不是则退出脚本</h1>

<p>[ $sure != y ] &amp;&amp; exit</p>

<h1 id="提示用户输入相关参数-磁盘-卷组名称等数据-并测试用户是否输入了这些值-如果没有输入-则脚本退出">提示用户输入相关参数(磁盘、卷组名称等数据),并测试用户是否输入了这些值,如果没有输入,则脚本退出</h1>

<p>read -p “请输入磁盘名称,如/dev/vdb:” disk<br />
[ -z $disk ] &amp;&amp; echo “没有输入磁盘名称” &amp;&amp; exit<br />
read -p “请输入卷组名称:” vg_name<br />
[ -z $vg_name ] &amp;&amp; echo “没有输入卷组名称” &amp;&amp; exit<br />
read -p “请输入逻辑卷名称:” lv_name<br />
[ -z $lv_name ] &amp;&amp; echo “没有输入逻辑卷名称” &amp;&amp; exit<br />
read -p “请输入逻辑卷大小:” lv_size<br />
[ -z $lv_size ] &amp;&amp; echo “没有输入逻辑卷大小” &amp;&amp; exit</p>

<h1 id="使用命令创建逻辑卷">使用命令创建逻辑卷</h1>

<p>pvcreate $disk<br />
vgcreate $vg_name $disk<br />
lvcreate -L ${lv_size}M -n ${lv_name} ${vg_name}<br />
49、显示 CPU 厂商信息</p>

<p>#!/bin/bash</p>

<h1 id="显示-cpu-厂商信息">显示 CPU 厂商信息</h1>

<p>awk ‘/vendor_id/{print $3}’ /proc/cpuinfo | uniq<br />
50、删除某个目录下大小为 0 的文件</p>

<p>#!/bin/bash</p>

<h1 id="删除某个目录下大小为-0-的文件">删除某个目录下大小为 0 的文件</h1>

<p>#/var/www/html 为测试目录,脚本会清空该目录下所有 0 字节的文件<br />
dir=&ldquo;/var/www/html&rdquo;<br />
find $dir -type f -size 0 -exec rm -rf {} ;<br />
51、查找 Linux 系统中的僵尸进程</p>

<p>#!/bin/bash</p>

<h1 id="查找-linux-系统中的僵尸进程">查找 Linux 系统中的僵尸进程</h1>

<h1 id="awk-判断-ps-命令输出的第-8-列为-z-是-显示该进程的-pid-和进程命令">awk 判断 ps 命令输出的第 8 列为 Z 是,显示该进程的 PID 和进程命令</h1>

<p>ps aux | awk ‘{if($8 == “Z”){print $2,$11}}’<br />
52、提示用户输入年份后判断该年是否为闰年</p>

<p>#!/bin/bash</p>

<h1 id="提示用户输入年份后判断该年是否为闰年">提示用户输入年份后判断该年是否为闰年</h1>

<h1 id="能被4整除并且并不能被100整除的年份是闰年">能被4整除并且并不能被100整除的年份是闰年</h1>

<h1 id="能被400整除的年份也是闰年">能被400整除的年份也是闰年</h1>

<p>read -p “请输入一个年份:” year</p>

<p>if [ “KaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;#&rsquo; at position 49: …份&rdquo; exit fi
#̲使用正则测试变量 year 中…year” =~ [a‐Z] ]];then<br />
echo “你输入的不是数字”<br />
exit<br />
fi</p>

<h1 id="判断是否为闰年">判断是否为闰年</h1>

<p>if [ $[year % 4] -eq 0 ] &amp;&amp; [  [ y e a r e c h o &ldquo; [year % 100] -ne 0 ];then
echo &ldquo; [yearecho&rdquo;year年是闰年&rdquo;<br />
elif [  [ y e a r e c h o &ldquo; [year % 400] -eq 0 ];then echo &ldquo;
[yearecho&rdquo;year年是闰年&rdquo;<br />
else<br />
echo “$year年不是闰年”<br />
fi<br />
53、生成随机密码(urandom 版本)</p>

<p>#!/bin/bash</p>

<h1 id="生成随机密码-urandom-版本">生成随机密码(urandom 版本)</h1>

<h1 id="dev-urandom-文件是-linux-内置的随机设备文件">/dev/urandom 文件是 Linux 内置的随机设备文件</h1>

<h1 id="cat-dev-urandom-可以看看里面的内容-ctrl-c-退出查看">cat /dev/urandom 可以看看里面的内容,ctrl+c 退出查看</h1>

<h1 id="查看该文件内容后-发现内容有些太随机-包括很多特殊符号-我们需要的密码不希望使用这些符号">查看该文件内容后,发现内容有些太随机,包括很多特殊符号,我们需要的密码不希望使用这些符号</h1>

<h1 id="tr-dc-a-za-z0-9-dev-urandom">tr ‐dc ‘_A‐Za‐z0‐9’ &lt; /dev/urandom</h1>

<h1 id="该命令可以将随机文件中其他的字符删除-仅保留大小写字母-数字-下划线-但是内容还是太多">该命令可以将随机文件中其他的字符删除,仅保留大小写字母,数字,下划线,但是内容还是太多</h1>

<h1 id="我们可以继续将优化好的内容通过管道传递给-head-命令-在大量数据中仅显示头-10-个字节">我们可以继续将优化好的内容通过管道传递给 head 命令,在大量数据中仅显示头 10 个字节</h1>

<h1 id="注意-a-前面有个下划线">注意 A 前面有个下划线</h1>

<p>tr -dc ‘_A‐Za‐z0‐9’ 54、生成随机密码(字串截取版本)</p>

<p>#!/bin/bash</p>

<h1 id="生成随机密码-字串截取版本">生成随机密码(字串截取版本)</h1>

<h1 id="设置变量-key-存储密码的所有可能性-密码库-如果还需要其他字符请自行添加其他密码字符">设置变量 key,存储密码的所有可能性(密码库),如果还需要其他字符请自行添加其他密码字符</h1>

<h1 id="使用-统计密码库的长度">使用$#统计密码库的长度</h1>

<p>key=“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”<br />
num=${#key}</p>

<h1 id="设置初始密码为空">设置初始密码为空</h1>

<p>pass=’’</p>

<h1 id="循环-8-次-生成随机密码">循环 8 次,生成随机密码</h1>

<h1 id="每次都是随机数对密码库的长度取余-确保提取的密码字符不超过密码库的长度">每次都是随机数对密码库的长度取余,确保提取的密码字符不超过密码库的长度</h1>

<h1 id="每次循环提取一位随机密码-并将该随机密码追加到-pass-变量的最后">每次循环提取一位随机密码,并将该随机密码追加到 pass 变量的最后</h1>

<p>for i in {1…8}<br />
do<br />
index= [ R A N D O M p a s s = [RANDOM%num] pass= [RANDOMpass=passKaTeX parse
error: Expected &lsquo;}&rsquo;, got &lsquo;EOF&rsquo; at end of input: {key:index:1}<br />
done<br />
echo $pass<br />
55、生成随机密码(UUID 版本,16 进制密码)</p>

<p>#!/bin/bash</p>

<h1 id="生成随机密码-uuid-版本-16-进制密码">生成随机密码(UUID 版本,16 进制密码)</h1>

<p>uuidgen<br />
56、生成随机密码(进程 ID 版本,数字密码)</p>

<p>#!/bin/bash</p>

<h1 id="生成随机密码-进程-id-版本-数字密码">生成随机密码(进程 ID 版本,数字密码)</h1>

<p>echo $$<br />
57、测试用户名与密码是否正确</p>

<p>#!/bin/bash</p>

<h1 id="测试用户名与密码是否正确">测试用户名与密码是否正确</h1>

<p>#用户名为 tom 并且密码为 123456,则提示登录成功,否则提示登录失败<br />
read -p “请输入用户名:” user<br />
read -p “请输入密码:” pass<br />
if [ “ u s e r &ldquo; = = ′ t o m ′ − a &rdquo; user&rdquo; == &lsquo;tom&rsquo; -a &ldquo; user&rdquo;==′tom′−a&rdquo;pass”
== ‘123456’ ];then<br />
echo “Login successful”<br />
else<br />
echo “Login Failed”<br />
fi<br />
58、循环测试用户名与密码是否正确</p>

<p>#!/bin/bash</p>

<h1 id="循环测试用户名与密码是否正确">循环测试用户名与密码是否正确</h1>

<h1 id="循环测试用户的账户名和密码-最大测试-3-次-输入正确提示登录成功-否则提示登录失败">循环测试用户的账户名和密码,最大测试 3 次,输入正确提示登录成功,否则提示登录失败</h1>

<h1 id="用户名为-tom-并且密码为-123456">用户名为 tom 并且密码为 123456</h1>

<p>for i in {1…3}<br />
do<br />
read -p “请输入用户名:” user<br />
read -p “请输入密码:” pass<br />
if [ “ u s e r &ldquo; = = ′ t o m ′ − a &rdquo; user&rdquo; == &lsquo;tom&rsquo; -a &ldquo; user&rdquo;==′tom′−a&rdquo;pass”
== ‘123456’ ];then<br />
echo “Login successful”<br />
exit<br />
fi<br />
done<br />
echo “Login Failed”<br />
59、Shell 脚本的 fork 炸弹</p>

<p>#!/bin/bash</p>

<h1 id="shell-脚本的-fork-炸弹">Shell 脚本的 fork 炸弹</h1>

<h1 id="快速消耗计算机资源-致使计算机死机">快速消耗计算机资源,致使计算机死机</h1>

<h1 id="定义函数名为-点-函数中递归调用自己并放入后台执行">定义函数名为.(点), 函数中递归调用自己并放入后台执行</h1>

<p>.() { .|.&amp; };.<br />
60、批量下载有序文件(pdf、图片、视频等等)</p>

<p>#!/bin/bash</p>

<h1 id="批量下载有序文件-pdf-图片-视频等等">批量下载有序文件(pdf、图片、视频等等)</h1>

<h1 id="本脚本准备有序的网络资料进行批量下载操作-如-01-jpg-02-jpg-03-jpg">本脚本准备有序的网络资料进行批量下载操作(如 01.jpg,02.jpg,03.jpg)</h1>

<h1 id="设置资源来源的域名连接">设置资源来源的域名连接</h1>

<p>url=“<a href="http://www.baidu.com/”">http://www.baidu.com/”</a><br />
echo “开始下载…”<br />
sleep 2<br />
type=jpg<br />
for i in <code>seq 100</code><br />
echo “正在下载 i . i. i.type”<br />
curl  u r l / url/ url/i. t y p e − o / t m p / type -o /tmp/
type−o/tmp/{i}$type<br />
sleep 1<br />
done<br />
#curl 使用-o 选项指定下载文件另存到哪里.<br />
61、显示当前计算机中所有账户的用户名称</p>

<p>#!/bin/bash</p>

<h1 id="显示当前计算机中所有账户的用户名称">显示当前计算机中所有账户的用户名称</h1>

<h1 id="下面使用3种不同的方式列出计算机中所有账户的用户名">下面使用3种不同的方式列出计算机中所有账户的用户名</h1>

<h1 id="指定以-为分隔符-打印-etc-passwd-文件的第-1-列">指定以:为分隔符,打印/etc/passwd 文件的第 1 列</h1>

<p>awk -F: ‘{print $1}’ /etc/passwd</p>

<h1 id="指定以-为分隔符-打印-etc-passwd-文件的第-1-列-1">指定以:为分隔符,打印/etc/passwd 文件的第 1 列</h1>

<p>cut -d: -f1 /etc/passwd</p>

<h1 id="使用-sed-的替换功能-将-etc-passwd-文件中-后面的所有内容替换为空-仅显示用户名">使用 sed 的替换功能,将/etc/passwd 文件中:后面的所有内容替换为空(仅显示用户名)</h1>

<p>sed ‘s/:.*//’ /etc/passwd<br />
62、制定目录路径,脚本自动将该目录使用 tar 命令打包备份到/data目录</p>

<p>#!/bin/bash</p>

<h1 id="制定目录路径-脚本自动将该目录使用-tar-命令打包备份到-data目录">制定目录路径,脚本自动将该目录使用 tar 命令打包备份到/data目录</h1>

<p>[ ! -d /data ] &amp;&amp; mkdir /data<br />
[ -z $1 ] &amp;&amp; exit<br />
if [ -d $1 ];then<br />
tar -czf /data/$1.-<code>date +%Y%m%d</code>.tar.gz $1<br />
else<br />
echo “该目录不存在”<br />
fi<br />
63、显示进度条(回旋镖版)</p>

<p>#!/bin/bash</p>

<h1 id="显示进度条-回旋镖版">显示进度条(回旋镖版)</h1>

<p>while :<br />
do<br />
clear<br />
for i in {1…20}<br />
do<br />
echo ‐e “\033[3;KaTeX parse error: Undefined control sequence: \0 at position
74: … do echo ‐e &ldquo;\̲0̲33[3;{i}H*”<br />
sleep 0.1<br />
done<br />
clear<br />
done<br />
64、安装 LAMP 环境(yum 版本)</p>

<p>#!/bin/bash</p>

<h1 id="安装-lamp-环境-yum-版本">安装 LAMP 环境(yum 版本)</h1>

<h1 id="本脚本适用于-rhel7-rhel6-中数据库为-mysql">本脚本适用于 RHEL7(RHEL6 中数据库为 mysql)</h1>

<p>yum makecache &amp;&gt;/dev/null<br />
num=$(yum repolist | awk ‘/repolist/{print $2}’ | sed ‘s/,//’)<br />
if [ $num -lt 0 ];then<br />
yum -y install httpd<br />
yum -y install mariadb mariadb-server mariadb-devel<br />
yum -y install php php-mysql<br />
else<br />
echo “未配置 yum 源…”<br />
fi<br />
65、循环关闭局域网中所有主机</p>

<p>#!/bin/bash</p>

<h1 id="循环关闭局域网中所有主机">循环关闭局域网中所有主机</h1>

<h1 id="假设本机为-192-168-4-100-编写脚本关闭除自己外的其他所有主机">假设本机为 192.168.4.100,编写脚本关闭除自己外的其他所有主机</h1>

<h1 id="脚本执行-需要提前给所有其他主机传递-ssh-密钥-满足无密码连接">脚本执行,需要提前给所有其他主机传递 ssh 密钥,满足无密码连接</h1>

<p>for i in {1…254}<br />
do<br />
[ KaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;&amp;&rsquo; at position 13: i -eq 100 ] &amp;̲&amp;
continue ech…i…&rdquo;<br />
ssh 192.168.4.$i poweroff<br />
done<br />
66、获取本机 MAC 地址</p>

<p>#!/bin/bash</p>

<h1 id="获取本机-mac-地址">获取本机 MAC 地址</h1>

<p>ip a s | awk ‘BEGIN{print &ldquo; 本 机 MAC 地 址 信 息 如 下 :&ldquo;}/1/{print
$2;getline;if($0~/link/ether/){print $2}}’ | grep -v lo:</p>

<h1 id="awk-读取-ip-命令的输出-输出结果中如果有以数字开始的行-先显示该行的地-2-列-网卡名称">awk 读取 ip 命令的输出,输出结果中如果有以数字开始的行,先显示该行的地 2 列(网卡名称),</h1>

<h1 id="接着使用-getline-再读取它的下一行数据-判断是否包含-link-ether">接着使用 getline 再读取它的下一行数据,判断是否包含 link/ether</h1>

<h1 id="如果保护该关键词-就显示该行的第-2-列-mac-地址">如果保护该关键词,就显示该行的第 2 列(MAC 地址)</h1>

<h1 id="lo-回环设备没有-mac-因此将其屏蔽-不显示">lo 回环设备没有 MAC,因此将其屏蔽,不显示</h1>

<p>67、自动配置 rsynd 服务器的配置文件 rsyncd.conf</p>

<p>#!/bin/bash</p>

<h1 id="自动配置-rsynd-服务器的配置文件-rsyncd-conf">自动配置 rsynd 服务器的配置文件 rsyncd.conf</h1>

<h1 id="see-rsyncd-conf-man-page-for-more-options">See rsyncd.conf man page for more options.</h1>

<p>[ ! -d /home/ftp ] &amp;&amp; mkdir /home/ftp<br />
echo ‘uid = nobody<br />
gid = nobody<br />
use chroot = yes<br />
max connections = 4<br />
pid file = /var/run/rsyncd.pid<br />
exclude = lost+found/<br />
transfer logging = yes<br />
timeout = 900<br />
ignore nonreadable = yes<br />
dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2<br />
[ftp]<br />
path = /home/ftp<br />
comment = share’ &gt; /etc/rsyncd.conf<br />
68、修改 Linux 系统的最大打开文件数量</p>

<p>#!/bin/bash</p>

<h1 id="修改-linux-系统的最大打开文件数量">修改 Linux 系统的最大打开文件数量</h1>

<h1 id="往-etc-security-limits-conf-文件的末尾追加两行配置参数-修改最大打开文件数量为-65536">往/etc/security/limits.conf 文件的末尾追加两行配置参数,修改最大打开文件数量为 65536</h1>

<p>cat &gt;&gt; /etc/security/limits.conf &lt;</p>

<ul>
<li>soft nofile 65536</li>
<li>hard nofile 65536<br />
EOF<br />
69、设置 Python 支持自动命令补齐功能</li>
</ul>

<p>#!/bin/bash</p>

<h1 id="设置-python-支持自动命令补齐功能">设置 Python 支持自动命令补齐功能</h1>

<h1 id="summary-enable-tab-complete-for-python">Summary:Enable tab complete for python</h1>

<h1 id="description">Description:</h1>

<p>Needs import readline and rlcompleter module</p>

<p>#</p>

<p>import readline</p>

<p>#</p>

<p>import rlcompleter</p>

<p>#</p>

<p>help(rlcompleter) display detail: readline.parse_and_bind(‘tab: complete’)</p>

<p>#</p>

<p>man python display detail: PYTHONSTARTUP variable</p>

<p>if [ ! -f /usr/bin/tab.py ];then<br />
cat &gt;&gt; /usr/bin/tab.py &lt; import readline<br />
import rlcompleter<br />
readline.parse_and_bind(‘tab: complete’)<br />
EOF<br />
fi<br />
sed -i ‘$a export PYTHONSTARTUP=/usr/bin/tab.py’ /etc/profile<br />
source /etc/profile<br />
70、自动修改计划任务配置文件</p>

<p>#!/bin/bash</p>

<h1 id="自动修改计划任务配置文件">自动修改计划任务配置文件</h1>

<p>read -p “请输入分钟信息(00‐59):” min<br />
read -p “请输入小时信息(00‐24):” hour<br />
read -p “请输入日期信息(01‐31):” date<br />
read -p “请输入月份信息(01‐12):” month<br />
read -p “请输入星期信息(00‐06):” weak<br />
read -p “请输入计划任务需要执行的命令或脚本:” program<br />
echo “$min $hour $date $month $weak $program” &gt;&gt; /etc/crontab<br />
71、使用脚本循环创建三位数字的文本文件(111-999 的文件)</p>

<p>#!/bin/bash</p>

<h1 id="使用脚本循环创建三位数字的文本文件-111-999-的文件">使用脚本循环创建三位数字的文本文件(111-999 的文件)</h1>

<p>for i in {1…9}<br />
do<br />
for j in {1…9}<br />
do<br />
for k in {1…9}<br />
do<br />
touch /tmp/ i i ij$k.txt<br />
done<br />
done<br />
done<br />
72、找出/etc/passwd 中能登录的用户,并将对应在/etc/shadow 中第二列密码提出处理</p>

<p>#!/bin/bash</p>

<h1 id="找出-etc-passwd-中能登录的用户-并将对应在-etc-shadow-中第二列密码提出处理">找出/etc/passwd 中能登录的用户,并将对应在/etc/shadow 中第二列密码提出处理</h1>

<p>user= ( a w k − F : ′ / b a s h (awk -F: &lsquo;/bash (awk−F:′/bash/{print $1}’
/etc/passwd)<br />
for i in  u s e r d o a w k − F : − v x = user do awk -F: -v x=
userdoawk−F:−vx=i ‘$1==x{print $1,$2}’ /etc/shadow<br />
done<br />
73、统计/etc/passwd 中 root 出现的次数</p>

<p>#!/bin/bash</p>

<h1 id="统计-etc-passwd-中-root-出现的次数">统计/etc/passwd 中 root 出现的次数</h1>

<p>#每读取一行文件内容,即从第 1 列循环到最后 1 列,依次判断是否包含 root 关键词,如果包含则 x++<br />
awk -F: ‘{i=1;while(i&lt;=NF){if($i~/root/){x++};i++}} END{print &ldquo;root 出现次数为&rdquo;x}’
/etc/passwd<br />
74、统计 Linux 进程相关数量信息</p>

<p>#!/bin/bash</p>

<h1 id="统计-linux-进程相关数量信息">统计 Linux 进程相关数量信息</h1>

<p>running=0<br />
sleeping=0<br />
stoped=0<br />
zombie=0</p>

<h1 id="在-proc-目录下所有以数字开始的都是当前计算机正在运行的进程的进程-pid">在 proc 目录下所有以数字开始的都是当前计算机正在运行的进程的进程 PID</h1>

<h1 id="每个-pid-编号的目录下记录有该进程相关的信息">每个 PID 编号的目录下记录有该进程相关的信息</h1>

<p>for pid in /proc/[1‐9]*<br />
do<br />
procs= [ p r o c s + 1 ] s t a t = [procs+1] stat= [procs+1]stat=(awk ‘{print
$3}’ $pid/stat)</p>

<h1 id="每个-pid-目录下都有一个-stat-文件-该文件的第-3-列是该进程的状态信息">每个 pid 目录下都有一个 stat 文件,该文件的第 3 列是该进程的状态信息</h1>

<pre><code>case $stat in
R)
    running=$[running+1]
    ;;
T)
    stoped=$[stoped+1]
    ;;
S)
    sleeping=$[sleeping+1]
    ;;
Z)
    zombie=$[zombie+1]
    ;;
esac
</code></pre>

<p>done<br />
echo “进程统计信息如下”<br />
echo “总进程数量为: p r o c s &ldquo; e c h o &rdquo; R u n n i n g 进 程 数 为 : procs&rdquo; echo
&ldquo;Running 进程数为: procs&rdquo;echo&rdquo;Running进程数为:running”<br />
echo “Stoped 进程数为: s t o p e d &ldquo; e c h o &rdquo; S l e e p i n g 进 程 数 为 : stoped&rdquo;
echo &ldquo;Sleeping 进程数为: stoped&rdquo;echo&rdquo;Sleeping进程数为:sleeping”<br />
echo “Zombie 进程数为:$zombie”<br />
75、从键盘读取一个论坛积分,判断论坛用户等级</p>

<p>#!/bin/bash</p>

<h1 id="从键盘读取一个论坛积分-判断论坛用户等级">从键盘读取一个论坛积分,判断论坛用户等级</h1>

<p>#等级分类如下:</p>

<h1 id="大于等于-90-神功绝世">大于等于 90 神功绝世</h1>

<h1 id="大于等于-80-小于-90-登峰造极">大于等于 80,小于 90 登峰造极</h1>

<h1 id="大于等于-70-小于-80-炉火纯青">大于等于 70,小于 80 炉火纯青</h1>

<h1 id="大于等于-60-小于-70-略有小成">大于等于 60,小于 70 略有小成</h1>

<h1 id="小于-60-初学乍练">小于 60 初学乍练</h1>

<p>read -p “请输入积分(0‐100):” JF<br />
if [  J F − g e 90 ] ; t h e n e c h o &ldquo; JF -ge 90 ] ; then echo &ldquo;
JF−ge90];thenecho&rdquo;JF 分,神功绝世&rdquo;<br />
elif [  J F − g e 80 ] ; t h e n e c h o &ldquo; JF -ge 80 ] ; then echo &ldquo;
JF−ge80];thenecho&rdquo;JF 分,登峰造极&rdquo;<br />
elif [  J F − g e 70 ] ; t h e n e c h o &ldquo; JF -ge 70 ] ; then echo &ldquo;
JF−ge70];thenecho&rdquo;JF 分,炉火纯青&rdquo;<br />
elif [  J F − l t 60 ] ; t h e n e c h o &ldquo; JF -lt 60 ] ; then echo &ldquo;
JF−lt60];thenecho&rdquo;JF 分,略有小成&rdquo;<br />
else<br />
echo “$JF 分,初学乍练”<br />
fi<br />
76、判断用户输入的数据类型(字母、数字或其他)</p>

<p>#!/bin/bash</p>

<h1 id="判断用户输入的数据类型-字母-数字或其他">判断用户输入的数据类型(字母、数字或其他)</h1>

<p>read -p “请输入一个字符:” KEY<br />
case “$KEY” in<br />
[a‐z]|[A‐Z])<br />
echo “字母”<br />
;;<br />
[0‐9])<br />
echo “数字”<br />
;;<br />
*)<br />
echo “空格、功能键或其他控制字符”<br />
esac<br />
77、显示进度条(数字版)</p>

<p>#!/bin/bash</p>

<h1 id="显示进度条-数字版">显示进度条(数字版)</h1>

<h1 id="echo-使用-e-选项后-在打印参数中可以指定-h-设置需要打印内容的-x-y-轴的定位坐标">echo 使用‐e 选项后,在打印参数中可以指定 H,设置需要打印内容的 x,y 轴的定位坐标</h1>

<h1 id="设置需要打印内容在第几行-第几列">设置需要打印内容在第几行,第几列</h1>

<p>for i in {1…100}<br />
do<br />
echo -e “\033[6;8H[”<br />
echo -e “\033[6;9H$i%”<br />
echo -e “\033[6;13H]”<br />
sleep 0.1<br />
done<br />
78、打印斐波那契数列</p>

<p>#!/bin/bash</p>

<h1 id="打印斐波那契数列-该数列的特点是后一个数字-永远都是前-2-个数字之和">打印斐波那契数列(该数列的特点是后一个数字,永远都是前 2 个数字之和)</h1>

<h1 id="斐波那契数列后一个数字永远是前-2-个数字之和">斐波那契数列后一个数字永远是前 2 个数字之和</h1>

<h1 id="如-0-1-1-2-3-5-8-13">如:0 1 1 2 3 5 8 13 … …</h1>

<p>list=(0 1)<br />
for i in <code>seq 2 11</code><br />
do<br />
list[$i]=<code>expr ${list[‐1]} + ${list[‐2]}</code><br />
done<br />
echo ${list[@]}<br />
79、判断用户输入的是 Yes 或 NO</p>

<p>#!/bin/bash</p>

<h1 id="判断用户输入的是-yes-或-no">判断用户输入的是 Yes 或 NO</h1>

<p>read -p “Are you sure?[y/n]:” sure<br />
case $sure in<br />
y|Y|Yes|YES)<br />
echo “you enter $a”<br />
;;<br />
n|N|NO|no)<br />
echo “you enter $a”<br />
;;<br />
*)<br />
echo “error”;;<br />
esac<br />
80、显示本机 Linux 系统上所有开放的端口列表</p>

<p>#!/bin/bash</p>

<h1 id="显示本机-linux-系统上所有开放的端口列表">显示本机 Linux 系统上所有开放的端口列表</h1>

<h1 id="从端口列表中观测有没有没用的端口-有的话可以将该端口对应的服务关闭-防止意外的攻击可能性">从端口列表中观测有没有没用的端口,有的话可以将该端口对应的服务关闭,防止意外的攻击可能性</h1>

<p>ss -nutlp | awk ‘{print $1,$5}’ | awk -F&rdquo;[: ]&rdquo; ‘{print &ldquo;协议:&rdquo; 1 , &ldquo; 端 口 号 : &ldquo;
1,&ldquo;端口号:&rdquo; 1,&ldquo;端口号:&ldquo;NF}’ | grep “[0‐9]” | uniq<br />
81、将 Linux 系统中 UID 大于等于 1000 的普通用户都删除</p>

<p>#!/bin/bash</p>

<h1 id="将-linux-系统中-uid-大于等于-1000-的普通用户都删除">将 Linux 系统中 UID 大于等于 1000 的普通用户都删除</h1>

<h1 id="先用-awk-提取所有-uid-大于等于-1000-的普通用户名称">先用 awk 提取所有 uid 大于等于 1000 的普通用户名称</h1>

<h1 id="再使用-for-循环逐个将每个用户删除即可">再使用 for 循环逐个将每个用户删除即可</h1>

<p>user=$(awk -F: ‘$3&gt;=1000{print $1}’ /etc/passwd)<br />
for i in $user<br />
do<br />
userdel -r $i<br />
done<br />
82、使用脚本开启关闭虚拟机</p>

<p>#!/bin/bash</p>

<h1 id="使用脚本开启关闭虚拟机">使用脚本开启关闭虚拟机</h1>

<h1 id="脚本通过调用virsh命令实现对虚拟机的管理-如果没有该命令-需要安装-libvirt-client-软件包">脚本通过调用virsh命令实现对虚拟机的管理,如果没有该命令,需要安装 libvirt‐client 软件包</h1>

<h1 id="1是脚本的第1个参数-2是脚本的第2个参数">$1是脚本的第1个参数,$2是脚本的第2个参数</h1>

<h1 id="第1个参数是你希望对虚拟机进行的操作指令-第2个参数是虚拟机名称">第1个参数是你希望对虚拟机进行的操作指令,第2个参数是虚拟机名称</h1>

<p>case $1 in<br />
list)<br />
virsh list &ndash;all<br />
;;<br />
start)<br />
virsh start $2<br />
;;<br />
stop)<br />
virsh destroy $2<br />
;;<br />
enable)<br />
virsh autostart $2<br />
;;<br />
disable)<br />
virsh autostart &ndash;disable $2<br />
;;<br />
*)<br />
echo “Usage:$0 list”<br />
echo “Usage:$0 [start|stop|enable|disable] VM_name”<br />
cat &lt;&lt; EOF<br />
#list 显示虚拟机列表<br />
#start 启动虚拟机<br />
#stop 关闭虚拟机<br />
#enable 设置虚拟机为开机自启<br />
#disable 关闭虚拟机开机自启功能<br />
EOF<br />
;;<br />
esac<br />
83、调整虚拟机内存参数的 shell 脚本</p>

<p>#!/bin/bash</p>

<h1 id="调整虚拟机内存参数的-shell-脚本">调整虚拟机内存参数的 shell 脚本</h1>

<h1 id="脚本通过调用-virsh-命令实现对虚拟机的管理-如果没有该命令-需要安装-libvirt-client-软件包">脚本通过调用 virsh 命令实现对虚拟机的管理,如果没有该命令,需要安装 libvirt‐client 软件包</h1>

<p>cat &lt;&lt; EOF<br />
1.调整虚拟机最大内存数值<br />
2.调整实际分配给虚拟机的内存数值<br />
EOF<br />
read -p “请选择[1‐2]:” select<br />
case $select in<br />
1)<br />
read -p “请输入虚拟机名称” name<br />
read -p “请输入最大内存数值(单位:k):” size<br />
virsh setmaxmem $name &ndash;size $size &ndash;config<br />
;;<br />
2)<br />
read -p “请输入虚拟机名称” name<br />
read -p “请输入实际分配内存数值(单位:k):” size<br />
virsh setmem $name $size<br />
;;<br />
*)<br />
echo “Error”<br />
;;<br />
esac<br />
84、查看 KVM 虚拟机中的网卡信息(不需要进入启动或进入虚拟机)</p>

<p>#!/bin/bash</p>

<h1 id="查看-kvm-虚拟机中的网卡信息-不需要进入启动或进入虚拟机">查看 KVM 虚拟机中的网卡信息(不需要进入启动或进入虚拟机)</h1>

<h1 id="该脚本使用-guestmount-工具-可以将虚拟机的磁盘系统挂载到真实机文件系统中">该脚本使用 guestmount 工具,可以将虚拟机的磁盘系统挂载到真实机文件系统中</h1>

<h1 id="centos7-2-中安装-libguestfs-tools-c-可以获得-guestmount-工具">Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具</h1>

<h1 id="虚拟机可以启动或者不启动都不影响该脚本的使用">虚拟机可以启动或者不启动都不影响该脚本的使用</h1>

<h1 id="将虚拟机磁盘文件挂载到文件系统后-就可以直接读取磁盘文件中的网卡配置文件中的数据">将虚拟机磁盘文件挂载到文件系统后,就可以直接读取磁盘文件中的网卡配置文件中的数据</h1>

<p>clear<br />
mountpoint=&ldquo;/media/virtimage&rdquo;<br />
[ ! -d $mountpoint ] &amp;&amp; mkdir $mountpoint<br />
read -p “输入虚拟机名称:” name<br />
echo “请稍后…”</p>

<h1 id="如果有设备挂载到该挂载点-则先-umount-卸载">如果有设备挂载到该挂载点,则先 umount 卸载</h1>

<p>if mount | grep -q “$mountpoint” ;then<br />
umount $mountpoint<br />
fi</p>

<h1 id="只读的方式-将虚拟机的磁盘文件挂载到特定的目录下-这里是-media-virtimage-目录">只读的方式,将虚拟机的磁盘文件挂载到特定的目录下,这里是/media/virtimage 目录</h1>

<p>guestmount -r -d $name -i KaTeX parse error: Undefined control sequence: \0 at
position 78: …‐‐‐‐&rdquo; echo -e &ldquo;\̲0̲33[32mname 虚拟机中网卡列表如下:\033[0m&rdquo;<br />
dev=$(ls /media/virtimage/etc/sysconfig/network‐scripts/ifcfg-* |awk -F&rdquo;[/‐]&rdquo;
‘{print $9}’)<br />
echo $dev<br />
echo “‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐”<br />
echo<br />
echo<br />
echo “+++++++++++++++++++++++++++++++++++++++++++”<br />
echo -e “\033[32m 网卡 IP 地址信息如下:\033[0m”<br />
for i in  d e v d o e c h o − n &ldquo; dev do echo -n &rdquo; devdoecho−n&rdquo;i:&rdquo;<br />
grep -q “IPADDR” /media/virtimage/etc/sysconfig/network‐scripts/ifcfg-$i ||
echo “未配置 IP地址”<br />
awk -F= &lsquo;/IPADDR/{print KaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;}&rsquo; at position
2: 2}̲&rsquo; /media/virtim…i<br />
done<br />
echo “+++++++++++++++++++++++++++++++++++++++++++”<br />
85、不登陆虚拟机,修改虚拟机网卡 IP 地址</p>

<p>#!/bin/bash</p>

<h1 id="不登陆虚拟机-修改虚拟机网卡-ip-地址">不登陆虚拟机,修改虚拟机网卡 IP 地址</h1>

<h1 id="该脚本使用-guestmount-工具-centos7-2-中安装-libguestfs-tools-c-可以获得-guestmount-工具">该脚本使用 guestmount 工具,Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具</h1>

<h1 id="脚本在不登陆虚拟机的情况下-修改虚拟机的-ip-地址信息">脚本在不登陆虚拟机的情况下,修改虚拟机的 IP 地址信息</h1>

<h1 id="在某些环境下-虚拟机没有-ip-或-ip-地址与真实主机不在一个网段">在某些环境下,虚拟机没有 IP 或 IP 地址与真实主机不在一个网段</h1>

<h1 id="真实主机在没有-virt-manger-图形的情况下-远程连接虚拟机很麻烦">真实主机在没有 virt‐manger 图形的情况下,远程连接虚拟机很麻烦</h1>

<h1 id="该脚本可以解决类似的问题">该脚本可以解决类似的问题</h1>

<p>read -p “请输入虚拟机名称:” name<br />
if virsh domstate $name | grep -q running ;then<br />
echo “修改虚拟机网卡数据,需要关闭虚拟机”<br />
virsh destroy $name<br />
fi<br />
mountpoint=&ldquo;/media/virtimage&rdquo;<br />
[ ! -d $mountpoint ] &amp;&amp; mkdir  m o u n t p o i n t e c h o &ldquo; 请 稍 后 &hellip; &rdquo; i f
m o u n t ∣ g r e p − q &ldquo; mountpoint echo &ldquo;请稍后&hellip;&rdquo; if mount | grep -q &ldquo;
mountpointecho&rdquo;请稍后&hellip;&ldquo;ifmount∣grep−q&rdquo;mountpoint&rdquo; ;then<br />
umount $mountpoint<br />
fi<br />
guestmount -d $name -i $mountpoint<br />
read -p “请输入需要修改的网卡名称:” dev<br />
read -p “请输入 IP 地址:” addr</p>

<h1 id="判断原本网卡配置文件中是否有-ip-地址-有就修改该-ip-没有就添加一个新的-ip-地址">判断原本网卡配置文件中是否有 IP 地址,有就修改该 IP,没有就添加一个新的 IP 地址</h1>

<p>if grep -q “IPADDR”  m o u n t p o i n t / e t c / s y s c o n f i g / n e t w
o r k ‐ s c r i p t s / i f c f g ‐
mountpoint/etc/sysconfig/network‐scripts/ifcfg‐
mountpoint/etc/sysconfig/network‐scripts/ifcfg‐dev ;then<br />
sed -i “/IPADDR/s/=.*/=$addr/”  m o u n t p o i n t / e t c / s y s c o n f i
g / n e t w o r k ‐ s c r i p t s / i f c f g ‐
mountpoint/etc/sysconfig/network‐scripts/ifcfg‐
mountpoint/etc/sysconfig/network‐scripts/ifcfg‐dev<br />
else<br />
echo “IPADDR=$addr” &gt;&gt; m o u n t p o i n t / e t c / s y s c o n f i g / n e t
w o r k ‐ s c r i p t s / i f c f g ‐
mountpoint/etc/sysconfig/network‐scripts/ifcfg‐
mountpoint/etc/sysconfig/network‐scripts/ifcfg‐dev<br />
fi</p>

<h1 id="如果网卡配置文件中有客户配置的-ip-地址-则脚本提示修改-ip-完成">如果网卡配置文件中有客户配置的 IP 地址,则脚本提示修改 IP 完成</h1>

<p>awk -F= -v x=$addr ‘$2==x{print “完成…”}’  m o u n t p o i n t / e t c / s y s c
o n f i g / n e t w o r k ‐ s c r i p t s / i f c f g −
mountpoint/etc/sysconfig/network‐scripts/ifcfg-
mountpoint/etc/sysconfig/network‐scripts/ifcfg−dev<br />
86、破解虚拟机密码,无密码登陆虚拟机系统</p>

<p>#!/bin/bash</p>

<h1 id="破解虚拟机密码-无密码登陆虚拟机系统">破解虚拟机密码,无密码登陆虚拟机系统</h1>

<h1 id="该脚本使用-guestmount-工具-centos7-2-中安装-libguestfs-tools-c-可以获得-guestmount-工具-1">该脚本使用 guestmount 工具,Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具</h1>

<p>read -p “请输入虚拟机名称:” name<br />
if virsh domstate $name | grep -q running ;then<br />
echo “破解,需要关闭虚拟机”<br />
virsh destroy $name<br />
fi<br />
mountpoint=&ldquo;/media/virtimage&rdquo;<br />
[ ! -d $mountpoint ] &amp;&amp; mkdir  m o u n t p o i n t e c h o &ldquo; 请 稍 后 &hellip; &rdquo; i f
m o u n t ∣ g r e p − q &ldquo; mountpoint echo &ldquo;请稍后&hellip;&rdquo; if mount | grep -q &ldquo;
mountpointecho&rdquo;请稍后&hellip;&ldquo;ifmount∣grep−q&rdquo;mountpoint&rdquo; ;then<br />
umount $mountpoint<br />
fi<br />
guestmount -d $name -i $mountpoint</p>

<h1 id="将-passwd-中密码占位符号-x-删除-该账户即可实现无密码登陆系统">将 passwd 中密码占位符号 x 删除,该账户即可实现无密码登陆系统</h1>

<p>sed -i “/^root/s/x//” $mountpoint/etc/passwd<br />
87、Shell 脚本对信号的处理,执行脚本后,按键盘 Ctrl+C 无法终止的脚本</p>

<p>#!/bin/bash</p>

<h1 id="shell-脚本对信号的处理-执行脚本后-按键盘-ctrl-c-无法终止的脚本">Shell 脚本对信号的处理,执行脚本后,按键盘 Ctrl+C 无法终止的脚本</h1>

<h1 id="使用-trap-命令可以拦截用户通过键盘或-kill-命令发送过来的信号">使用 trap 命令可以拦截用户通过键盘或 kill 命令发送过来的信号</h1>

<h1 id="使用-kill-l-可以查看-linux-系统中所有的信号列表-其中-2-代表-ctrl-c">使用 kill ‐l 可以查看 Linux 系统中所有的信号列表,其中 2 代表 Ctrl+C</h1>

<h1 id="trap-当发现有用户-ctrl-c-希望终端脚本时-就执行-echo-暂停-10s-sleep-10-这两条命令">trap 当发现有用户 ctrl+C 希望终端脚本时,就执行 echo “暂停 10s”;sleep 10 这两条命令</h1>

<h1 id="另外用户使用命令-kill-2-脚本的-pid-也可以中断脚本和-ctrl-c-一样的效果-都会被-trap-拦截">另外用户使用命令:[ kill ‐2 脚本的 PID ] 也可以中断脚本和 Ctrl+C 一样的效果,都会被 trap 拦截</h1>

<p>trap ‘echo “暂停 10s”;sleep 10’ 2<br />
while :<br />
do<br />
echo “go go go”<br />
done<br />
88、一键部署 memcached</p>

<p>#!/bin/bash</p>

<h1 id="一键部署-memcached">一键部署 memcached</h1>

<h1 id="脚本用源码来安装-memcached-服务器">脚本用源码来安装 memcached 服务器</h1>

<h1 id="注意-如果软件的下载链接过期了-请更新-memcached-的下载链接">注意:如果软件的下载链接过期了,请更新 memcached 的下载链接</h1>

<p>wget <a href="http://www.memcached.org/files/memcached-1.5.1.tar.gz">http://www.memcached.org/files/memcached-1.5.1.tar.gz</a><br />
yum -y install gcc<br />
tar -xf memcached‐1.5.1.tar.gz<br />
cd memcached‐1.5.1<br />
./configure<br />
make<br />
make install<br />
89、一键配置 VNC 远程桌面服务器(无密码版本)</p>

<p>#!/bin/bash</p>

<h1 id="一键配置-vnc-远程桌面服务器-无密码版本">一键配置 VNC 远程桌面服务器(无密码版本)</h1>

<h1 id="脚本配置的-vnc-服务器-客户端无需密码即可连接">脚本配置的 VNC 服务器,客户端无需密码即可连接</h1>

<h1 id="客户端仅有查看远程桌面的权限-没有鼠标和键盘的操作权限">客户端仅有查看远程桌面的权限,没有鼠标和键盘的操作权限</h1>

<p>rpm &ndash;quiet -q tigervnc‐server<br />
if [ $? -ne 0 ];then<br />
yum -y tigervnc‐server<br />
fi<br />
x0vncserver AcceptKeyEvents=0 AlwaysShared=1<br />
AcceptPointerEvents=0 SecurityTypes=None rfbport=5908<br />
90、关闭 SELinux</p>

<p>#!/bin/bash</p>

<h1 id="关闭-selinux">关闭 SELinux</h1>

<p>sed -i ‘/^SELINUX/s/=.*/=disabled/’ /etc/selinux/config<br />
setenforce 0<br />
91、查看所有虚拟机磁盘使用量以及CPU使用量信息</p>

<p>#!/bin/bash</p>

<h1 id="查看所有虚拟机磁盘使用量以及cpu使用量信息">查看所有虚拟机磁盘使用量以及CPU使用量信息</h1>

<p>virt‐df<br />
read -n1 “按任意键继续” key<br />
virt‐top<br />
92、使用 shell 脚本打印图形</p>

<p>#!/bin/bash</p>

<h1 id="使用-shell-脚本打印如下图形">使用 shell 脚本打印如下图形:</h1>

<h1 id="打印第一组图片">打印第一组图片</h1>

<h1 id="for-为类-c-语言的语法格式-也可以使用-for-i-in-do-done-的格式替换">for(())为类 C 语言的语法格式,也可以使用 for i in;do ;done 的格式替换</h1>

<h1 id="for-i-1-i-9-i-循环会执行-9-次-i-从-1-开始到-9-每循环一次-i-自加-1">for((i=1;i&lt;=9;i++))循环会执行 9 次,i 从 1 开始到 9,每循环一次 i 自加 1</h1>

<p>clear<br />
for (( i=1; i&lt;=9; i++ ))<br />
do<br />
for (( j=1; j&lt;=i; j++ ))<br />
do<br />
echo -n “$i”<br />
done<br />
echo “”<br />
done<br />
read -n1 “按任意键继续” key<br />
#打印第二组图片<br />
clear<br />
for (( i=1; i&lt;=5; i++ ))<br />
do<br />
for (( j=1; j&lt;=i; j++ ))<br />
do<br />
echo -n &ldquo; |&rdquo;<br />
done<br />
echo “_ &ldquo;<br />
done<br />
read -n1 “按任意键继续” key<br />
#打印第三组图片<br />
clear<br />
for (( i=1; i&lt;=5; i++ ))<br />
do<br />
for (( j=1; j&lt;=i; j++ ))<br />
do<br />
echo -n &ldquo; *”<br />
done<br />
echo “”<br />
done<br />
for (( i=5; i&gt;=1; i‐‐ ))<br />
do<br />
for (( j=1; j&lt;=i; j++ ))<br />
do<br />
echo -n &ldquo; *&rdquo;<br />
done<br />
echo “”<br />
done<br />
93、根据计算机当前时间,返回问候语,可以将该脚本设置为开机启动</p>

<p>#!/bin/bash</p>

<h1 id="根据计算机当前时间-返回问候语-可以将该脚本设置为开机启动">根据计算机当前时间,返回问候语,可以将该脚本设置为开机启动</h1>

<h1 id="00-12-点为早晨-12-18-点为下午-18-24-点为晚上">00‐12 点为早晨,12‐18 点为下午,18‐24 点为晚上</h1>

<h1 id="使用-date-命令获取时间后-if-判断时间的区间-确定问候语内容">使用 date 命令获取时间后,if 判断时间的区间,确定问候语内容</h1>

<p>tm=$(date +%H)<br />
if [ $tm -le 12 ];then<br />
msg=“Good Morning $USER”<br />
elif [ $tm -gt 12 -a $tm -le 18 ];then<br />
msg=“Good Afternoon $USER”<br />
else<br />
msg=“Good Night  U S E R &ldquo; f i e c h o &rdquo; 当 前 时 间 是 : USER&rdquo; fi echo &ldquo;当前时间是:
USER&rdquo;fiecho&rdquo;当前时间是:(date +”%Y‐%m‐%d %H:%M:%S&rdquo;)&rdquo;<br />
echo -e “\033[34m$msg\033[0m”<br />
94、读取用户输入的账户名称,将账户名写入到数组保存</p>

<p>#!/bin/bash</p>

<h1 id="读取用户输入的账户名称-将账户名写入到数组保存">读取用户输入的账户名称,将账户名写入到数组保存</h1>

<h1 id="定义数组名称为-name-数组的下标为-i-小标从-0-开始-每输入一个账户名-下标加-1-继续存下一个账户">定义数组名称为 name,数组的下标为 i,小标从 0 开始,每输入一个账户名,下标加 1,继续存下一个账户</h1>

<h1 id="最后-输入-over-脚本输出总结性信息后脚本退出">最后,输入 over,脚本输出总结性信息后脚本退出</h1>

<p>i=0<br />
while :<br />
do<br />
read -p “请输入账户名,输入 over 结束:” key<br />
if [  k e y = = &ldquo; o v e r &rdquo; ] ; t h e n b r e a k e l s e n a m e [ key ==
&ldquo;over&rdquo; ];then break else name[ key==&ldquo;over&rdquo;];thenbreakelsename[i]= k e y l e t
i + + f i d o n e e c h o &ldquo; 总 账 户 名 数 量 : key let i++ fi done echo &ldquo;总账户名数量:
keyleti++fidoneecho&rdquo;总账户名数量:{#name[*]}&rdquo;<br />
echo “${name[@]}”<br />
95、判断文件或目录是否存在</p>

<p>#!/bin/bash</p>

<h1 id="判断文件或目录是否存在">判断文件或目录是否存在</h1>

<p>if [ $# -eq 0 ] ;then<br />
echo “未输入任何参数,请输入参数”<br />
echo “用法:$0 [文件名|目录名]”<br />
fi<br />
if [ -f $1 ];then<br />
echo “该文件,存在”<br />
ls -l $1<br />
else<br />
echo “没有该文件”<br />
fi<br />
if [ -d $1 ];then<br />
echo “该目录,存在”<br />
ls -ld $2<br />
else<br />
echo “没有该目录”<br />
fi<br />
96、打印各种格式的时间</p>

<p>#!/bin/bash</p>

<h1 id="打印各种时间格式">打印各种时间格式</h1>

<p>echo “显示星期简称(如:Sun)”<br />
date +%a<br />
echo “显示星期全称(如:Sunday)”<br />
date +%A<br />
echo “显示月份简称(如:Jan)”<br />
date +%b<br />
echo “显示月份全称(如:January)”<br />
date +%B<br />
echo “显示数字月份(如:12)”<br />
date +%m<br />
echo “显示数字日期(如:01 号)”<br />
date +%d<br />
echo “显示数字年(如:01 号)”<br />
date +%Y echo “显示年‐月‐日”<br />
date +%F<br />
echo “显示小时(24 小时制)”<br />
date +%H<br />
echo “显示分钟(00…59)”<br />
date +%M<br />
echo “显示秒”<br />
date +%S<br />
echo “显示纳秒”<br />
date +%N<br />
echo “组合显示”<br />
date +&ldquo;%Y%m%d %H:%M:%S&rdquo;<br />
97、使用 egrep 过滤 MAC 地址</p>

<p>#!/bin/bash</p>

<h1 id="使用-egrep-过滤-mac-地址">使用 egrep 过滤 MAC 地址</h1>

<h1 id="mac-地址由-16-进制组成-如-aa-bb-cc-dd-ee-ff">MAC 地址由 16 进制组成,如 AA:BB:CC:DD:EE:FF</h1>

<h1 id="0-9a-fa-f-2-表示一段十六进制数值-5-表示连续出现5组前置-的十六进制">[0‐9a‐fA‐F]{2}表示一段十六进制数值,{5}表示连续出现5组前置:的十六进制</h1>

<p>egrep “[0‐9a‐fA‐F]{2}(:[0‐9a‐fA‐F]{2}){5}” $1<br />
98、统计双色球各个数字的中奖概率</p>

<p>#!/bin/bash</p>

<h1 id="统计双色球各个数字的中奖概率">统计双色球各个数字的中奖概率</h1>

<h1 id="往期双色球中奖号码如下">往期双色球中奖号码如下:</h1>

<h1 id="01-04-11-28-31-32-16">01 04 11 28 31 32 16</h1>

<h1 id="04-07-08-18-23-24-02">04 07 08 18 23 24 02</h1>

<h1 id="02-05-06-16-28-29-04">02 05 06 16 28 29 04</h1>

<h1 id="04-19-22-27-30-33-01">04 19 22 27 30 33 01</h1>

<h1 id="05-10-18-19-30-31-03">05 10 18 19 30 31 03</h1>

<h1 id="02-06-11-12-19-29-06">02 06 11 12 19 29 06</h1>

<h1 id="统计篮球和红球数据出现的概率次数-篮球不分顺序-统计所有篮球混合在一起的概率">统计篮球和红球数据出现的概率次数(篮球不分顺序,统计所有篮球混合在一起的概率)</h1>

<p>awk ‘{print $1&rdquo;\n&rdquo;$2&rdquo;\n&rdquo;$3&rdquo;\n&rdquo;$4&rdquo;\n&rdquo;$5&rdquo;\n&rdquo;$6}’ 1.txt | sort | uniq -c | sort<br />
awk ‘{print $7}’ 1.txt | sort | uniq -c | sort<br />
99、生成签名私钥和证书</p>

<p>#!/bin/bash</p>

<h1 id="生成签名私钥和证书">生成签名私钥和证书</h1>

<p>read -p “请输入存放证书的目录:” dir<br />
if [ ! -d $dir ];then<br />
echo “该目录不存在”<br />
exit<br />
fi<br />
read -p “请输入密钥名称:” name</p>

<h1 id="使用-openssl-生成私钥">使用 openssl 生成私钥</h1>

<p>openssl genrsa -out  d i r / {dir}/ dir/{name}.key</p>

<h1 id="使用-openssl-生成证书-subj-选项可以在生成证书时-非交互自动填写-common-name-信息">使用 openssl 生成证书 #subj 选项可以在生成证书时,非交互自动填写 Common Name 信息</h1>

<p>openssl req -new -x509 -key  d i r / {dir}/ dir/{name}.key -subj “/CN=common”
-out  d i r / {dir}/ dir/{name}.crt<br />
100、使用awk编写的wc程序</p>

<p>#!/bin/bash</p>

<h1 id="使用awk编写的wc程序">使用awk编写的wc程序</h1>

<h1 id="自定义变量-chars-变量存储字符个数-自定义变量-words-变量存储单词个数">自定义变量 chars 变量存储字符个数,自定义变量 words 变量存储单词个数</h1>

<h1 id="awk-内置变量-nr-存储行数">awk 内置变量 NR 存储行数</h1>

<h1 id="length-为-awk-内置函数-用来统计每行的字符数量-因为每行都会有一个隐藏的-所以每次统计后都-1">length()为 awk 内置函数,用来统计每行的字符数量,因为每行都会有一个隐藏的$,所以每次统计后都+1</h1>

<h1 id="wc-程序会把文件结尾符-也统计在内-可以使用-cat-a-文件名-查看该隐藏字符">wc 程序会把文件结尾符$也统计在内,可以使用 cat ‐A 文件名,查看该隐藏字符</h1>

<p>awk ‘{chars+=length($0)+1;words+=NF} END{print NR,words,chars}’ $1<br />
注：本篇文章是根据王森的博客整理而来，仅供学习参考！<br />
————————————————<br />
版权声明：本文为CSDN博主「baiduoWang」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：<a href="https://blog.csdn.net/yugemengjing/article/details/82469785">https://blog.csdn.net/yugemengjing/article/details/82469785</a></p>

<hr />

<ol>
<li>0‐9 ↩︎</li>
</ol>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>