<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linuxshell脚本编程基础篇六 | 开发者问答集锦</title>
    <meta property="og:title" content="Linuxshell脚本编程基础篇六 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linuxshell脚本编程基础篇六">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linuxshell脚本编程基础篇六</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>继 Linux shell 脚本编程-基础篇 （五）</p>

<p>6 控制脚本</p>

<hr />

<p>构建高级脚本时，如何在 Linux 系统上运行和控制它们。到目前为止，我们运行脚本的唯一方式就是以实时模式在命令行界面上直接运行。这并不是 Linux<br />
上运行脚本的唯一方式。有不少方法可以用来运行 shell 脚本。另外还有一些选项能够用于控制脚本。这些控制方法包括向脚本发送信号、修改脚本的优先<br />
级以及在脚本运行时切换到不同的运行模式。</p>

<p>6.1 处理信号<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
Linux 利用信号与运行在系统中的进程进行通信。之前介绍了不同的 Linux 信号以及 Linux
如何用这些信号来停止、启动、终止进程。可以通过对脚本进行<br />
编程，使其在收到特定信号时执行某些命令，从而控制 shell 脚本的操作。</p>

<p>6.1.1 重温Linux 信号<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
man 7 signal</p>

<p>常见 Linux 进程信号<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 信 号 | 名 称 | 描 述<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 1 | SIGHUP | 挂起<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 2 | SIGINT | 中断<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 3 | SIGQUIT | 结束运行<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 4 | SIGILL | 无效指令<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 9 | SIGKILL | 无条件终止<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 11 | SIGSEGV | 段错误，非法内存引用<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 15 | SIGTERM | 尽可能终止，Termination signal<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 18 | SIGCONT | 在 SIGSTOP 或 SIGTSTP 之后恢复执行<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 19 | SIGSTOP | 无条件停止运行，但不终止<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>默认情况下，bash shell 会忽略收到的任何 SIGQUIT (3)和 SIGTERM (15)信号（正因为这样，交互式 shell
才不会被意外终止）。但是bash shell 会处<br />
理收到的 SIGHUP (1)和 SIGINT (2)信号。</p>

<p>如果 bash shell 收到了 SIGHUP 信号，比如要离开一个交互式shell，它就会退出。但在退出之前，它会将 SIGHUP 信号传给所有由该
shell 所启动的进<br />
程（包括正在运行的 shell 脚本）。</p>

<p>通过 SIGINT 信号，可以中断 shell。Linux 内核会停止为 shell 分配 CPU 处理时间。这种情况发生时，shell 会将 SIGINT
信号传给所有由它所启动的<br />
进程，以此告知出现的状况。</p>

<p>shell 会将这些信号传给 shell 脚本程序来处理。而 shell 脚本的默认行为是忽略这些信号。它们可能会不利于脚本的运行。要避免这种情况，可以脚本<br />
中加入识别信号的代码，并执行命令来处理信号。</p>

<p>6.1.2 生成信号<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
bash shell 允许用键盘上的组合键生成两种基本的 Linux 信号。这个特性在需要停止或暂停失控程序时非常方便。</p>

<p>■ 中断进程<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
Ctrl+C 组合键会生成 SIGINT 信号，并将其发送给当前在 shell 中运行的所有进程。可以运行一条需要很长时间才能完成的命令，然后按下
Ctrl+C组合键<br />
来测试它。</p>

<p>[devalone@devalone 15]$ sleep 10<br />
^C</p>

<p>Ctrl+C 组合键会发送 SIGINT 信号，停止 shell 中当前运行的进程。sleep 命令会使得 shell
暂停指定的秒数，命令提示符直到计时器超时才会返回。在<br />
超时前按下 Ctrl+C 组合键，就可以提前终止 sleep 命令。</p>

<p>■ 暂停进程<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
可以在进程运行期间暂停进程，而无需终止它。尽管有时这可能会比较危险（比如，脚本打开了一个关键的系统文件的文件锁），但通常它可以在不终止进<br />
程的情况下能够深入脚本内部一窥究竟。</p>

<p>Ctrl+Z 组合键会生成一个 SIGTSTP 信号，停止 shell
中运行的任何进程。停止（stopping）进程跟终止（terminating）进程不同：停止进程会让程序继续<br />
保留在内存中，并能从上次停止的位置继续运行。</p>

<p>当用 Ctrl+Z 组合键时，shell 会通知用户进程已经被停止了：</p>

<p>[devalone@devalone 15]$ sleep 100<br />
^Z<br />
[1]+ 已停止 sleep 100</p>

<p>方括号中的数字是 shell 分配的作业号（job number）。shell 将 shell
中运行的每个进程称为作业，并为每个作业分配唯一的作业号。它会给第一个作业<br />
分配作业号1，第二个作业号2，以此类推。</p>

<p>如果用户的 shell 会话中有一个已停止的作业，在退出 shell 时，bash 会提醒。</p>

<p>[devalone@devalone 15]$ sleep 100<br />
^Z<br />
[1]+ 已停止 sleep 100<br />
[devalone@devalone 15]$ exit<br />
注销<br />
有停止的任务。</p>

<p>可以用 ps 命令来查看已停止的作业：</p>

<p>[devalone@devalone 15]$ ps -l<br />
F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD<br />
0 S 1000 2291 2286 0 80 0 - 30530 wait pts/0 00:00:00 bash<br />
0 T 1000 2792 2291 0 80 0 - 28079 signal pts/0 00:00:00 sleep<br />
0 R 1000 2799 2291 0 80 0 - 36971 - pts/0 00:00:00 ps</p>

<p>在 S 列中（进程状态），ps 命令将已停止作业的状态为显示为 T。这说明命令要么被跟踪，要么被停止了。</p>

<p>如果在有已停止作业存在的情况下，仍旧想退出 shell，只要再输入一遍 exit 命令就行了。shell 会退出，终止已停止作业。或者，既然已经知道了已停止<br />
作业的 PID，就可以用 kill 命令来发送一个 SIGKILL 信号来终止它。</p>

<p>[devalone@devalone 15]$ kill -SIGKILL 2792<br />
[1]+ Killed sleep 100<br />
[devalone@devalone 15]$ ps -l<br />
F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD<br />
0 S 1000 2291 2286 0 80 0 - 30530 wait pts/0 00:00:00 bash<br />
0 R 1000 2802 2291 0 80 0 - 36971 - pts/0 00:00:00 ps</p>

<p>6.1.3 捕获信号<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
也可以不忽略信号，在信号出现时捕获它们并执行其他命令。trap 命令允许指定 shell 脚本要监控并从 shell 中拦截的 Linux
信号。如果脚本收到trap<br />
命令中列出的信号，该信号不再由 shell 处理，而是交由本地处理。 trap命令的格式为：</p>

<p>trap commands signals</p>

<p>在 trap 命令行上，只要列出想要 shell 执行的命令，以及一组用空格分开的待捕获的信号。可以用数值或 Linux 信号名来指定信号。</p>

<p>示例： 展示了如何使用 trap 命令来忽略 SIGINT 信号，并控制脚本的行为</p>

<p>[devalone@devalone 16]$ cat test1.sh<br />
#!/bin/bash</p>

<h1 id="testing-signal-trapping">testing signal trapping</h1>

<p>trap &ldquo;echo &lsquo;Sorry! I have trapped Ctrl + C&rsquo; &rdquo; SIGINT</p>

<p>echo This is a test script</p>

<p>count=1<br />
while [ $count -le 10 ]<br />
do<br />
echo &ldquo;Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1 ]<br />
done</p>

<p>echo &ldquo;This is the end of the test script&rdquo;<br />
#</p>

<p>本例中用到的 trap 命令会在每次检测到 SIGINT 信号时显示一行简单的文本消息。捕获这些信号会阻止用户用 bash shell 组合键 Ctrl+C
来停止程序。</p>

<p>运行：<br />
[devalone@devalone 16]$ test1.sh<br />
This is a test script<br />
Loop #1<br />
Loop #2<br />
Loop #3<br />
^CSorry! I have trapped Ctrl + C<br />
Loop #4<br />
Loop #5<br />
Loop #6<br />
^CSorry! I have trapped Ctrl + C<br />
Loop #7<br />
Loop #8<br />
Loop #9<br />
Loop #10<br />
This is the end of the test script</p>

<p>每次使用 Ctrl+C 组合键，脚本都会执行 trap 命令中指定的 echo 语句，而不是处理该信号并允许 shell 停止该脚本。</p>

<p>6.1.4 捕获脚本退出<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
除了在 shell 脚本中捕获信号，也可以在 shell 脚本退出时进行捕获。这是在 shell 完成任务时执行命令的一种简便方法。</p>

<p>要捕获 shell 脚本的退出，只要在 trap 命令后加上 EXIT 信号就行。</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test2.sh<br />
#!/bin/bash</p>

<h1 id="trapping-the-script-exit">trapping the script exit</h1>

<p>trap &ldquo;echo Goodby&hellip;&rdquo; EXIT</p>

<p>count=1<br />
while [ $count -le 5 ]<br />
do<br />
echo &ldquo;Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1 ]<br />
done<br />
#</p>

<p>运行：<br />
[devalone@devalone 16]$ chmod a+x test2.sh<br />
[devalone@devalone 16]$ test2.sh<br />
Loop #1<br />
Loop #2<br />
Loop #3<br />
Loop #4<br />
Loop #5<br />
Goodby&hellip;</p>

<p>当脚本运行到正常的退出位置时，捕获就被触发了，shell 会执行在 trap 命令行指定的命令。如果提前退出脚本，同样能够捕获到 EXIT。</p>

<p>运行：<br />
[devalone@devalone 16]$ test2.sh<br />
Loop #1<br />
Loop #2<br />
^CGoodby&hellip;</p>

<p>因为 SIGINT 信号并没有出现在 trap 命令的捕获列表中，当按下 Ctrl+C 组合键发送 SIGINT
信号时，脚本就退出了。但在脚本退出前捕获到了 EXIT，<br />
于是 shell 执行了 trap 命令。</p>

<p>6.1.5 修改或移除捕获<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的 trap 命令。</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test3.sh<br />
#!/bin/bash</p>

<h1 id="modify-a-set-trap">modify a set trap</h1>

<p>trap &ldquo;echo &lsquo; Sorry&hellip;Ctrl-C is trapped.&rsquo;&rdquo; SIGINT</p>

<p>count=1<br />
while [ $count -le 5 ]<br />
do<br />
echo &ldquo;Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1 ]<br />
done</p>

<p>trap &ldquo;echo &lsquo;I modifie the trap!&rsquo;&rdquo; SIGINT</p>

<p>count=1<br />
while [ $count -le 5 ]<br />
do<br />
echo &ldquo;Second Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1]<br />
done</p>

<p>修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的trap命令进行处理。</p>

<p>运行：<br />
[devalone@devalone 16]$ test3.sh<br />
Loop #1<br />
Loop #2<br />
^C Sorry&hellip;Ctrl-C is trapped.<br />
Loop #3<br />
Loop #4<br />
Loop #5<br />
Second Loop #1<br />
^CI modifie the trap!<br />
Second Loop #2<br />
Second Loop #3<br />
Second Loop #4<br />
Second Loop #5</p>

<p>也可以删除已设置好的捕获。只需要在 trap 命令与希望恢复默认行为的信号列表之间加上两个连字符就行了。</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test3b.sh<br />
#!/bin/bash</p>

<h1 id="remove-a-set-trap">remove a set trap</h1>

<p>trap &ldquo;echo &lsquo; Sorry&hellip;Ctrl-C is trapped.&rsquo;&rdquo; SIGINT</p>

<p>count=1<br />
while [ $count -le 5 ]<br />
do<br />
echo &ldquo;Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1 ]<br />
done</p>

<p>trap &ndash; SIGINT<br />
echo &ldquo;I just removed the trap&rdquo;</p>

<p>count=1<br />
while [ $count -le 5 ]<br />
do<br />
echo &ldquo;Second Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1]<br />
done<br />
#</p>

<p>运行：<br />
[devalone@devalone 16]$ chmod a+x test3b.sh<br />
[devalone@devalone 16]$ test3b.sh<br />
Loop #1<br />
Loop #2<br />
^C Sorry&hellip;Ctrl-C is trapped.<br />
Loop #3<br />
Loop #4<br />
Loop #5<br />
^C Sorry&hellip;Ctrl-C is trapped.<br />
I just removed the trap<br />
Second Loop #1<br />
Second Loop #2<br />
^C</p>

<p>移除信号捕获后，脚本按照默认行为来处理 SIGINT 信号，也就是终止脚本运行。但如果信号是在捕获被移除前接收到的，那么脚本会按照原先 trap 命令中<br />
的设置进行处理。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
也可以在 trap 命令后使用单连字符来恢复信号的默认行为。单连字符和双连字符都可以正常发挥作用。</p>

<p>6.2 以后台模式运行脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
直接在命令行界面运行 shell 脚本有时不怎么方便。一些脚本可能要执行很长一段时间，而用户可能不想在命令行界面一直干等着。当脚本在运行时，没法<br />
在终端会话里做别的事情。幸好有个简单的方法可以解决。</p>

<p>在用 ps 命令时，会看到运行在
Linux系统上的一系列不同进程。显然，所有这些进程都不是运行在终端显示器上的。这样的现象被称为在后台(background)<br />
运行进程。在后台模式中，进程运行时不会和终端会话上的 STDIN、STDOUT 以及 STDERR 关联。</p>

<p>6.2.1 后台运行脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
以后台模式运行shell脚本非常简单。只要在命令后加个 &amp; 符就行了。</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test4.sh<br />
#!/bin/bash</p>

<h1 id="test-running-in-the-background">test running in the background</h1>

<p>#</p>

<p>count=1<br />
while [ $count -le 10 ]<br />
do<br />
sleep 1<br />
count=$[ $count + 1 ]<br />
done<br />
#</p>

<p>运行：<br />
[devalone@devalone 16]$ test4.sh &amp;<br />
[1] 2947</p>

<p>当 &amp; 符放到命令后时，它会将命令和 bash shell 分离开来，将命令作为系统中的一个独立的后台进程运行。显示的第一行是：</p>

<p>[1] 2947</p>

<p>方括号中的数字是 shell 分配给后台进程的作业号。下一个数是 Linux 系统分配给进程的进程ID（PID）。Linux
系统上运行的每个进程都必须有一个唯一<br />
的 PID。</p>

<p>一旦系统显示了这些内容，新的命令行界面提示符就出现了。可以回到 shell，而所执行的命令正在以后台模式安全的运行。这时，可以在提示符输入新的<br />
命令。当后台进程结束时，它会在终端上显示出一条消息：</p>

<p>[1]+ 已完成 test4.sh</p>

<p>这表明了作业的作业号以及作业状态（已完成, Done），还有用于启动作业的命令。</p>

<p>注意，当后台进程运行时，它仍然会使用终端显示器来显示 STDOUT 和 STDERR消息:</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test5.sh<br />
#!/bin/bash</p>

<h1 id="test-running-in-the-background-with-output">test running in the background with output</h1>

<p>echo &ldquo;Start the test script&rdquo;<br />
count=1<br />
while [ $count -le 5 ]<br />
do<br />
echo &ldquo;Loop #$count&rdquo;<br />
sleep 1<br />
count=$[ $count + 1 ]<br />
done</p>

<p>echo &ldquo;Test script is complete&rdquo;</p>

<p>运行：</p>

<p>[devalone@devalone 16]$ chmod a+x test5.sh<br />
[devalone@devalone 16]$ test5.sh &amp;<br />
[1] 2988<br />
[devalone@devalone 16]$ Start the test script<br />
Loop #1<br />
Loop #2<br />
Loop #3<br />
Loop #4<br />
Loop #5<br />
Test script is complete</p>

<p>[1]+ 已完成 test5.sh</p>

<p>会注意到在上面的例子中，脚本 test5.sh 的输出与 shell 提示符混杂在了一起，这也是为什么 Start the test
script会出现在提示符旁边的原因。</p>

<p>在显示输出的同时，仍然可以运行命令：</p>

<p>[devalone@devalone 16]$ test5.sh &amp;<br />
[1] 2995<br />
[devalone@devalone 16]$ Start the test script<br />
Loop #1<br />
Loop #2<br />
llLoop #3</p>

<p>总用量 44<br />
-rw-rw-r&ndash;. 1 devalone devalone 86 1月 7 13:15 nohup.out<br />
-rw-rw-r&ndash;. 1 devalone devalone 124 1月 7 13:15 test10.out<br />
-rw-rw-r&ndash;. 1 devalone devalone 200 1月 7 13:15 test10.sh<br />
-rw-rw-r&ndash;. 1 devalone devalone 173 1月 7 13:15 test13b.sh<br />
-rw-rw-r&ndash;. 1 devalone devalone 129 1月 7 13:15 test13.sh<br />
-rwxrwxr-x. 1 devalone devalone 273 1月 7 13:15 test1.sh<br />
-rwxrwxr-x. 1 devalone devalone 179 1月 7 13:15 test2.sh<br />
-rwxrwxr-x. 1 devalone devalone 351 1月 7 13:15 test3b.sh<br />
-rwxrwxr-x. 1 devalone devalone 346 1月 7 13:15 test3.sh<br />
-rwxrwxr-x. 1 devalone devalone 128 7月 8 16:34 test4.sh<br />
-rwxrwxr-x. 1 devalone devalone 222 1月 7 13:15 test5.sh<br />
[devalone@devalone 16]$ Loop #4<br />
Loop #5<br />
Test script is complete</p>

<p>[1]+ 已完成 test5.sh</p>

<p>当脚本test5.sh运行在后台模式时，我们输入了命令 ll 。脚本输出、输入的命令以及命令输出全都混在了一起。最好是将后台运行的脚本的 STDOUT 和<br />
STDERR 进行重定向，避免这种杂乱的输出。</p>

<p>6.2.2 运行多个后台作业<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
可以在命令行提示符下同时启动多个后台作业。每次启动新作业时，Linux 系统都会为其分配一个新的作业号和 PID。通过 ps命令，可以看到所有脚本处于<br />
运行状态。</p>

<p>在终端会话中使用后台进程时一定要小心。注意，在 ps 命令的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么<br />
后台进程也会随之退出。</p>

<p>6.3 在非控制台下运行脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
有时会想在终端会话中启动 shell 脚本，然后让脚本一直以后台模式运行到结束，即使中间退出终端会话，后台进程也不会随之退出。。这可以用 nohup<br />
命令来实现。</p>

<p>nohup 命令运行了另外一个命令来阻断所有发送给该进程的 SIGHUP 信号。这会在退出终端会话时阻止进程退出。</p>

<p>nohup命令的格式如下：</p>

<p>[devalone@devalone 16]$ nohup test1.sh &amp;<br />
[1] 3024<br />
[devalone@devalone 16]$ nohup: 忽略输入并把输出追加到 nohup.out</p>

<p>和普通后台进程一样，shell 会给命令分配一个作业号，Linux 系统会为其分配一个 PID 号。区别在于，当使用 nohup
命令时，如果关闭该会话，脚本会<br />
忽略终端会话发过来的 SIGHUP 信号。</p>

<p>由于 nohup 命令会解除终端与进程的关联，进程也就不再同 STDOUT 和 STDERR 联系在一起。为了保存该命令产生的输出，nohup 命令会自动将
STDOUT 和<br />
STDERR 的消息重定向到一个名为 nohup.out 的文件中。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
如果使用 nohup 运行了另一个命令，该命令的输出会被追加到已有的 nohup.out 文件中。当运行位于同一个目录中的多个命令时一定要当心，因为所有<br />
的输出都会被发送到同一个 nohup.out 文件中，结果会非常混乱。</p>

<p>nohup.out 文件包含了通常会发送到终端显示器上的所有输出。在进程完成运行后，可以查看 nohup.out 文件中的输出结果。</p>

<p>[devalone@devalone 16]$ cat nohup.out<br />
Start the test script<br />
Loop #1<br />
Loop #2<br />
Loop #3<br />
Loop #4<br />
Loop #5<br />
Test script is complete<br />
This is a test script<br />
Loop #1<br />
Loop #2<br />
Loop #3<br />
Loop #4<br />
Loop #5</p>

<p>&hellip;</p>

<p>输出会出现在 nohup.out 文件中，就跟进程在命令行下运行时一样。</p>

<p>6.4 作业控制<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
前面部分，已经知道了如何用组合键停止 shell 中正在运行的作业。在作业停止后，Linux 系统会让用户选择是终止还是重启。可以用 kill 命令终止该<br />
进程。要重启停止的进程需要向其发送一个 SIGCONT 信号。</p>

<p>启动、停止、终止以及恢复作业的这些功能统称为作业控制。通过作业控制，就能完全控制 shell 环境中所有进程的运行方式了。</p>

<p>6.4.1 查看作业<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
作业控制中的关键命令是 jobs 命令。jobs 命令允许查看 shell 当前正在处理的作业。</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test10.sh<br />
#!/bin/bash</p>

<h1 id="test-job-control">test job control</h1>

<p>echo &ldquo;script process ID: $$&rdquo;</p>

<p>count=1<br />
while [ $count -le 10 ]<br />
do<br />
echo &ldquo;Loop #$count&rdquo;<br />
sleep 10<br />
count=$[ $count + 1 ]<br />
done</p>

<p>echo &ldquo;end of script&hellip;&rdquo;<br />
#</p>

<p>[devalone@devalone 16]$ chmod a+x test10.sh</p>

<p>脚本用 $$ 变量来显示 Linux 系统分配给该脚本的 PID，然后进入循环，每次迭代都休眠 10 秒。可以从命令行中启动脚本，然后使用 Ctrl+Z
组合键来<br />
停止脚本。</p>

<p>运行：<br />
[devalone@devalone 16]$ test10.sh<br />
script process ID: 3082<br />
Loop #1<br />
^Z<br />
[1]+ 已停止 test10.sh</p>

<p>还是使用同样的脚本，利用 &amp; 将另外一个作业作为后台进程启动。出于简化的目的，脚本的输出被重定向到文件中，避免出现在屏幕上。</p>

<p>[devalone@devalone 16]$ test10.sh &gt; test10.out &amp;<br />
[2] 3086<br />
[devalone@devalone 16]$</p>

<p>jobs 命令可以查看分配给 shell 的作业。jobs 命令会显示这两个已停止/运行中的作业，以及它们的作业号和作业中使用的命令。</p>

<p>[devalone@devalone 16]$ jobs<br />
[1]+ 已停止 test10.sh<br />
[2]- 运行中 test10.sh &gt; test10.out &amp;</p>

<p>要想查看作业的 PID，可以在 jobs 命令中加入 -l 选项（小写的L）：</p>

<p>[devalone@devalone 16]$ jobs -l<br />
[1]+ 3082 Stopped test10.sh<br />
[2]- 3086 运行中 test10.sh &gt; test10.out &amp;</p>

<p>jobs 命令使用一些不同的命令行参数，见下表：</p>

<p>jobs 命令参数<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 参 数 | 描 述<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -l | 列出进程的PID以及作业号<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -n | 只列出上次shell发出的通知后改变了状态的作业<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -p | 只列出作业的PID<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -r | 只列出运行中的作业<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| -s | 只列出已停止的作业<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>注意 jobs 命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业<br />
控制命令的操作对象。</p>

<p>当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加号的作业和一个带减号的作业，不管 shell 中有多少个正在运行<br />
的作业。</p>

<p>下面例子说明了队列中的下一个作业在默认作业移除时是如何成为默认作业的。有 3 个独立的进程在后台被启动。jobs 命令显示出了这些进程、进程的PID<br />
及其状态。注意，默认进程（带有加号的那个）是最后启动的那个进程，也就是 3 号作业。</p>

<p>运行：<br />
[devalone@devalone 16]$ test10.sh &gt; test10a.out &amp;<br />
[1] 3107<br />
[devalone@devalone 16]$ test10.sh &gt; test10b.out &amp;<br />
[2] 3109<br />
[devalone@devalone 16]$ test10.sh &gt; test10c.out &amp;<br />
[3] 3111<br />
[devalone@devalone 16]$ jobs -l<br />
[1] 3107 运行中 test10.sh &gt; test10a.out &amp;<br />
[2]- 3109 运行中 test10.sh &gt; test10b.out &amp;<br />
[3]+ 3111 运行中 test10.sh &gt; test10c.out &amp;</p>

<p>调用了 kill 命令向默认进程发送了一个 SIGKILL 信号，终止了该作业。在接下来的 jobs
命令输出中，先前带有减号的作业成了现在的默认作业，减号也<br />
变成了加号。</p>

<p>[devalone@devalone 16]$ kill -9 3111<br />
[devalone@devalone 16]$ jobs -l<br />
[1]- 3107 已完成 test10.sh &gt; test10a.out<br />
[2]+ 3109 已完成 test10.sh &gt; test10b.out</p>

<p>6.4.2 重启停止的作业<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在 bash 作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管当前工作的终端，所以在使用该功能时要小心了。</p>

<p>示例：<br />
[devalone@devalone 16]$ test10.sh<br />
script process ID: 3162<br />
Loop #1<br />
^Z<br />
[1]+ 已停止 test10.sh<br />
[devalone@devalone 16]$ bg<br />
[1]+ test10.sh &amp;<br />
[devalone@devalone 16]$ jobs<br />
[1]+ 运行中 test10.sh &amp;</p>

<p>因为该作业是默认作业（从加号可以看出），只需要使用 bg 命令就可以将其以后台模式重启。注意，当作业被转入后台模式时，并不会列出其PID。如果有<br />
多个作业，得在 bg 命令后加上作业号。</p>

<p>示例：<br />
[devalone@devalone 16]$ test10.sh<br />
script process ID: 3176<br />
Loop #1<br />
^Z<br />
[1]+ 已停止 test10.sh<br />
[devalone@devalone 16]$ test10.sh<br />
script process ID: 3178<br />
Loop #1<br />
^Z<br />
[2]+ 已停止 test10.sh<br />
[devalone@devalone 16]$ jobs<br />
[1]- 已停止 test10.sh<br />
[2]+ 已停止 test10.sh<br />
[devalone@devalone 16]$ bg 2<br />
[2]+ test10.sh &amp;<br />
[devalone@devalone 16]$ Loop #2<br />
Loop #3<br />
Loop #4</p>

<p>命令 bg 2 用于将第二个作业置于后台模式。注意，当使用 jobs 命令时，它列出了作业及其状态，即便是默认作业当前并未处于后台模式。</p>

<p>要以前台模式重启作业，可用带有作业号的 fg 命令。</p>

<p>[devalone@devalone 16]$ fg 2<br />
test10.sh<br />
Loop #2<br />
Loop #3</p>

<p>由于作业是以前台模式运行的，直到该作业完成后，命令行界面的提示符才会出现。</p>

<p>6.5 调整谦让度<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在多任务操作系统中（Linux 就是），内核负责将 CPU 时间分配给系统上运行的每个进程。调度优先级（scheduling
priority）是内核分配给进程的 CPU<br />
时间（相对于其他进程）。在 Linux 系统中，由 shell 启动的所有进程的调度优先级默认都是相同的。</p>

<p>调度优先级是个整数值，从-20（最高优先级）到 +19（最低优先级）。默认情况下，bash shell 以优先级 0 来启动所有进程。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
最低值-20 是最高优先级，而最高值 19 是最低优先级。</p>

<p>有时想要改变一个 shell 脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他进程过多的处理能力），还是给予它更高的优先级（这样它就能<br />
获得更多的处理时间），都可以通过 nice 命令做到。</p>

<p>6.5.1 nice 命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
nice 命令允许设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用 nice 的 -n 命令行来指定新的优先级级别。</p>

<p>示例：<br />
[devalone@devalone 16]$ nice -n 10 ./test4.sh &gt; test4.out &amp;<br />
[2] 3223<br />
[devalone@devalone 16]$ ps -p 3223 -o pid,ppid,ni,cmd<br />
PID PPID NI CMD<br />
3223 2291 10 /bin/bash ./test4.sh</p>

<p>注意，必须将 nice 命令和要启动的命令放在同一行中。ps 命令的输出验证了谦让度值（NI 列）已经被调整到了10。</p>

<p>nice 命令会让脚本以更低的优先级运行。但如果想提高某个命令的优先级，可能会吃惊。</p>

<p>示例：<br />
$ nice -n -10 ./test4.sh &gt; test4.out &amp;<br />
[1] 4985<br />
$ nice: cannot set niceness: Permission denied</p>

<p>nice 命令阻止普通系统用户来提高命令的优先级。注意，指定的作业的确运行了，但是试图使用 nice 命令提高其优先级的操作却失败了。</p>

<p>nice 命令的 -n 选项并不是必须的，只需要在破折号后面跟上优先级就行了。</p>

<p>示例：<br />
[devalone@devalone 16]$ nice -10 ./test4.sh &gt; test4.out &amp;<br />
[1] 3274<br />
[devalone@devalone 16]$ jobs -l<br />
[1]+ 3274 运行中 nice -10 ./test4.sh &gt; test4.out &amp;</p>

<p>6.5.2 renice 命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
有时想改变系统上已运行命令的优先级。这正是 renice 命令可以做到的。它允许指定运行进程的 PID 来改变它的优先级。</p>

<p>示例：<br />
[devalone@devalone 16]$ ./test10.sh &amp;<br />
[1] 5055</p>

<p>[devalone@devalone 16]$ renice -n 10 -p 5055<br />
5055: old priority 0, new priority 10</p>

<p>renice 命令会自动更新当前运行进程的调度优先级。和 nice命令一样，renice 命令也有一些限制：</p>

<p>□ 只能对属于用户自己的进程执行 renice；<br />
□ 只能通过 renice 降低进程的优先级；<br />
□ root 用户可以通过 renice 来任意调整进程的优先级。</p>

<p>如果想完全控制运行进程，必须以 root 账户身份登录或使用 sudo 命令。</p>

<p>6.6 定时运行作业<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
使用脚本时，可能会想要在某个预设时间运行脚本，这通常是本人不在场的时候。Linux 系统提供了多个在预选时间运行脚本的方法：at 命令和 cron 表。<br />
每个方法都使用不同的技术来安排脚本的运行时间和频率。</p>

<p>6.6.1 用 at 命令来计划执行作业<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
at 命令允许指定 Linux 系统何时运行脚本。at 命令会将作业提交到队列中，指定 shell 何时运行该作业。at 的守护进程 atd
会以后台模式运行，检查<br />
作业队列来运行作业。大多数 Linux 发行版会在启动时运行此守护进程。</p>

<p>atd 守护进程会检查系统上的一个特殊目录（通常位于 /var/spool/at）来获取用 at 命令提交的作业。默认情况下，atd 守护进程会每 60
秒检查一下这个<br />
目录。有作业时，atd 守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配，atd 守护进程就会运行此作业。</p>

<p>■ at 命令的格式<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
at 命令的基本格式非常简单：</p>

<p>at [-f filename] time</p>

<p>默认情况下，at 命令会将 STDIN 的输入放到队列中。可以用 -f 参数来指定用于读取命令（脚本文件）的文件名。</p>

<p>time 参数指定了 Linux 系统何时运行该作业。如果指定的时间已经错过，at 命令会在第二天的那个时间运行指定的作业。</p>

<p>在如何指定时间这个问题上，可以非常灵活。at 命令能识别多种不同的时间格式:</p>

<p>● 标准的小时和分钟格式，比如10:15。<br />
● AM/PM指示符，比如10:15 PM。<br />
● 特定可命名时间，比如now、noon、midnight 或者 teatime（4 PM）。</p>

<p>除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期:</p>

<p>● 标准日期格式，比如 MMDDYY、MM/DD/YY或DD.MM.YY。<br />
● 文本日期，比如Jul 4 或 Dec 25，加不加年份均可。<br />
● 也可以指定时间增量。<br />
□ 当前时间+25 min<br />
□ 明天10:15 PM<br />
□ 10:15+7天</p>

<p>在使用 at 命令时，该作业会被提交到作业队列（job queue）。作业队列会保存通过 at 命令提交的待处理的作业。针对不同优先级，存在 26 种不同的<br />
作业队列。作业队列通常用小写字母 a~z 和大写字母 A~Z 来指代。</p>

<p>作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at 的作业会被提交到a作业队列。如果想以更高优先级运行作业，可以<br />
用 -q 参数指定不同的队列字母。</p>

<p>■ 获取作业的输出<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
当作业在 Linux 系统上运行时，显示器并不会关联到该作业。取而代之的是，Linux 系统会将提交该作业的用户的电子邮件地址作为 STDOUT 和
STDERR。<br />
任何发到 STDOUT 或 STDERR 的输出都会通过邮件系统发送给该用户。</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test13.sh<br />
#!/bin/bash</p>

<h1 id="test-using-at-command">test using at command</h1>

<p>echo &ldquo;this script ran at $(date +%B%d,%T)&rdquo;<br />
echo<br />
sleep 5<br />
echo &ldquo;this is the script&rsquo;s end&hellip;&rdquo;<br />
[devalone@devalone 16]$ chmod a+x test13.sh</p>

<p>运行：<br />
[devalone@devalone 16]$ at -f /home/devalone/study/shell-script/16/test13.sh
now<br />
warning: commands will be executed using /bin/sh<br />
job 1 at Sun Jul 8 18:09:00 2018</p>

<p>at 命令会显示分配给作业的作业号以及为作业安排的运行时间。-f 选项指明使用哪个脚本文件，now 指示 at 命令立刻执行该脚本。</p>

<p>使用 e-mail 作为 at 命令的输出极其不便。at 命令利用 sendmail 应用程序来发送邮件。如果系统中没有安装
sendmail，那就无法获得任何输出。因此<br />
在使用 at 命令时，最好在脚本中对 STDOUT 和 STDERR 进行重定向，如下例所示</p>

<p>示例：<br />
[devalone@devalone 16]$ cat test13b.sh<br />
#!/bin/bash</p>

<h1 id="test-using-at-command-1">test using at command</h1>

<p>echo &ldquo;this script ran at $(date +%B%d,%T)&rdquo; &gt; test13b.out<br />
echo &gt;&gt; test13b.out<br />
sleep 5<br />
echo &ldquo;this is the script&rsquo;s end&hellip;&rdquo; &gt;&gt; test13b.out</p>

<p>运行：<br />
[devalone@devalone 16]$ at -M -f test13b.sh now<br />
warning: commands will be executed using /bin/sh<br />
job 3 at Sun Jul 8 18:15:00 2018</p>

<p>[devalone@devalone 16]$ cat test13b.out<br />
this script ran at 七月08,18:15:11</p>

<p>this is the script&rsquo;s end&hellip;</p>

<p>如果不想在 at 命令中使用邮件或重定向，最好加上 -M 选项来屏蔽作业产生的输出信息。</p>

<p>■ 列出等待的作业<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
atq 命令可以查看系统中有哪些作业在等待。</p>

<p>示例：<br />
[devalone@devalone 16]$ at -M -f test13b.sh teatime<br />
warning: commands will be executed using /bin/sh<br />
job 4 at Mon Jul 9 16:00:00 2018<br />
[devalone@devalone 16]$ at -M -f test13b.sh tomorrow<br />
warning: commands will be executed using /bin/sh<br />
job 5 at Mon Jul 9 18:18:00 2018<br />
[devalone@devalone 16]$ at -M -f test13b.sh 13:30<br />
warning: commands will be executed using /bin/sh<br />
job 6 at Mon Jul 9 13:30:00 2018<br />
[devalone@devalone 16]$ at -M -f test13b.sh now<br />
warning: commands will be executed using /bin/sh<br />
job 7 at Sun Jul 8 18:18:00 2018</p>

<p>[devalone@devalone 16]$ atq<br />
7 Sun Jul 8 18:18:00 2018 = devalone<br />
5 Mon Jul 9 18:18:00 2018 a devalone<br />
4 Mon Jul 9 16:00:00 2018 a devalone<br />
6 Mon Jul 9 13:30:00 2018 a devalone</p>

<p>■ 删除作业<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
一旦知道了哪些作业在作业队列中等待，就能用 atrm 命令来删除等待中的作业。</p>

<p>示例：<br />
[devalone@devalone 16]$ atrm 5<br />
[devalone@devalone 16]$ atrm 6<br />
[devalone@devalone 16]$ atq<br />
4 Mon Jul 9 16:00:00 2018 a devalone</p>

<p>只要指定想要删除的作业号就行了。只能删除自己提交的作业，不能删除其他人的。</p>

<p>6.6.2 安排需要定期执行的脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
用 at 命令在预设时间安排脚本执行非常好用，但如果需要脚本在每天的同一时间运行或是每周一次、每月一次呢？用不着再使用 at 不断提交作业了，可以<br />
利用 Linux 系统的另一个功能：cron 命令。</p>

<p>Linux 系统使用 cron 程序来安排要定期执行的作业。cron 程序会在后台运行并检查一个特殊的表（被称作 cron
时间表，crontab），以获知已安排执行的<br />
作业。</p>

<p>■ cron 时间表<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
cron 时间表采用一种特别的格式来指定作业何时运行。其格式如下：</p>

<p>min hour dayofmonth month dayofweek command</p>

<p>cron 时间表允许用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目。例如，如果想在每天的 10:15 运行一个命令，可以用
cron时间表条目：</p>

<p>15 10 * * * command</p>

<p>在 dayofmonth、month 以及 dayofweek 字段中使用了通配符，表明 cron 会在每个月每天的 10:15 执行该命令。</p>

<p>要指定在每周一 4:15 PM 运行的命令，可以用下面的条目：</p>

<p>15 16 * * 1 command</p>

<p>可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定 dayofweek 表项。</p>

<p>在每个月的第一天中午 12点 执行命令。可以用下面的格式：</p>

<p>00 12 1 * * command</p>

<p>dayofmonth 表项指定月份中的日期值（1~31）。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
如何设置一个在每个月的最后一天执行的命令，因为无法设置 dayofmonth 的值来涵盖所有的月份。这个问题困扰着 Linux 和 Unix
程序员，也激发了<br />
不少解决办法。常用的方法是加一条使用 date 命令的 if-then 语句来检查明天的日期是不是 01：</p>

<p>00 12 * * * if [<code>date +%d -d tomorrow</code> = 01 ] ; then ; command</p>

<p>它会在每天中午12点来检查是不是当月的最后一天，如果是，cron 将会运行该命令。</p>

<p>命令列表必须指定要运行的命令或脚本的全路径名。可以像在普通的命令行中那样，添加任何想要执行的命令行参数和重定向符号。</p>

<p>15 10 * * * /home/rich/test4.sh &gt; test4out</p>

<p>cron 程序会用提交作业的用户账户运行该脚本。因此，提交作业账户必须有访问该命令和命令中指定的输出文件的权限。</p>

<p>时间表的每项工作(每行)的格式都有 6 个字段，其中前 5 个是时间字段，第六个是要执行的指令。</p>

<p>时间表各字段定义：<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;+<br />
| 意义 | min(分钟) | hour(小时)| dayofmonth(日期)|month(月份)|dayofweek(周)| command(指令)
|<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;+<br />
|数字范围 | 0-59 | 0-23 | 1-31 | 1-12 | 0-7 | 执行的命令 |<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>特殊符号意义：<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
| 符号 | 意义<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
|*(星号) |代表任何时刻都接受的意思。！丼例来说，15 10 * * * 日、月、周都是 * ， 就代表任何月，<br />
| |任何日，不管星期几的 10:15 都执行后面的指令。<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
|,(逗号) |代表分隔时段。如，计划命令在 3:00 和 6:00 时执行，就会是： 0 3,6 * * * command<br />
| |时间参数还是有五栏，第二栏是 3,6 ，代表 3 和 6 都适用。<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
|-(连字符) |代表一段时间范围内，例如，8 点到 12 点之间的每个小时的 20 分时都执行一项命令：<br />
| |20 8-12 * * * command<br />
| |第二栏变成 8-12，代表 8,9,10,11,12 都适用。<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
|/n(斜线) |n 是个数字，代表&rdquo;每隔 n 单位间隔&rdquo; 的意思，例如每隔 5 分钟执行一次命令，则：<br />
| |*/5 * * * * command<br />
+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>■ 构建 cron 时间表<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
每个系统用户（包括root用户）都可以用自己的 cron 时间表来运行安排好的任务。Linux 提供了 crontab 命令来处理 cron
时间表。要列出已有的 cron<br />
时间表，可以用 -l 选项。</p>

<p>[devalone@devalone ~]$ crontab -l<br />
no crontab for devalone</p>

<p>[devalone@devalone ~]$ sudo crontab -l<br />
no crontab for root</p>

<p>默认情况下，用户的 cron 时间表文件并不存在。要为 cron 时间表添加条目，可以用 -e 选项。在添加条目时，crontab
命令会启用一个文本编辑器），<br />
使用已有的 cron 时间表作为文件内容（或者是一个空文件，如果时间表不存在的话）。</p>

<p>■ 系统配置文件： /etc/crontab<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
crontab -e 是针对使用者的 cron 来设计的，如果是 &ldquo;系统的例行任务&rdquo; 则不需要以 crontab -e 来管理例行性工作排程。只要编辑
/etc/crontab 这个<br />
配置文件就可以了。注意，crontab -e 的这个 crontab 其实是 /usr/bin/crontab 这个可执行文件，而 /etc/crontab
是一个村文本文件，可以 root身份<br />
编辑这个配置文件。</p>

<p>基本上，cron 服务最低检测限制是 “分钟”，cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron
里面的内容，因此，只要编辑完/etc/crontab<br />
并保存，cron 服务就会自动执行新的配置。</p>

<p>查看现有配置：</p>

<p>[devalone@devalone ~]$ cat /etc/crontab<br />
SHELL=/bin/bash<br />
PATH=/sbin:/bin:/usr/sbin:/usr/bin<br />
MAILTO=root</p>

<h1 id="for-details-see-man-4-crontabs">For details see man 4 crontabs</h1>

<h1 id="example-of-job-definition">Example of job definition:</h1>

<h1 id="minute-0-59">.&mdash;&mdash;&mdash;&mdash;&mdash;- minute (0 - 59)</h1>

<h1 id="hour-0-23">| .&mdash;&mdash;&mdash;&mdash;- hour (0 - 23)</h1>

<h1 id="day-of-month-1-31">| | .&mdash;&mdash;&mdash;- day of month (1 - 31)</h1>

<h1 id="month-1-12-or-jan-feb-mar-apr">| | | .&mdash;&mdash;- month (1 - 12) OR jan,feb,mar,apr &hellip;</h1>

<h1 id="day-of-week-0-6-sunday-0-or-7-or">| | | | .&mdash;- day of week (0 - 6) (Sunday=0 or 7) OR</h1>

<p>sun,mon,tue,wed,thu,fri,sat</p>

<h1 id="toc_16">| | | | |</h1>

<h1 id="user-name-command-to-be-executed">* * * * * user-name command to be executed</h1>

<ul>
<li>15 * * * root /usr/bin/dnf update -y</li>
</ul>

<p>这个文件与 crontab -e 的内容几乎一样，只有几个地方不同：</p>

<p>● MAILTO=root：当 /etc/crontab 中配置的例行性工作发生错误时，或者改工作的执行结果有 STDOUT/STDERR
时，将错误信息发送给谁。默认是由系统<br />
直接发一封 mail 给 root 账户。但由于 root 账户无法在客户端以 POP3 之类的软件收信，因此通常将这个账户改成自己的 e-mail
账号，以便随时<br />
了解系统的状况，如：</p>

<p>MAILTO=devalone@sohu.com</p>

<p>● PATH=/sbin:/bin:/usr/sbin:/usr/bin<br />
命令执行的搜索路径，默认值就可以了。</p>

<p>● SHELL=/bin/bash<br />
执行的 shell 环境，默认为 /bin/bash, 也可以改成其他 shell，如 sh, zsh</p>

<p>● * 15 * * * root /usr/bin/dnf update -y</p>

<p>这与使用者的 crontab -e 不同。使用者自己的 crontab 不需要指定身份，但 /etc/crontab 里面要指定执行者的账户，这里指定由
root 账户执行后面<br />
的命令。其格式为：</p>

<p>min hour dayofmonth month dayofweek username command</p>

<p>/etc/crontab 文件支持两种下达指令的方式，一种是直接下达指令，一种则是以目录来规划，例如：</p>

<p>● 指令类型：</p>

<ul>
<li>15 * * * root /usr/bin/dnf update -y<br />
<br /></li>
</ul>

<p>以 root 身份每天 15:00 执行系统更新指令。</p>

<p>● 目录规划：</p>

<p>*/5 * * * * root run-parts /root/runcron</p>

<p>建立一个 /root/runcron 目录，将要每隔 5 分钟执行的可执行文件都放到该目录下，系统每 5 分钟以 roo
账户执行一次该目录下的所有可执行文件。</p>

<p>■ 浏览 cron 目录<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
如果创建的脚本对精确的执行时间要求不高，用预配置的 cron 脚本目录会更方便。有 4 个基本目录：hourly、daily、monthly 和
weekly。</p>

<p>[devalone@devalone ~]$ ls -ld /etc/cron.*ly<br />
drwxr-xr-x. 2 root root 4096 12月 22 2017 /etc/cron.daily<br />
drwxr-xr-x. 2 root root 4096 3月 9 2017 /etc/cron.hourly<br />
drwxr-xr-x. 2 root root 4096 2月 4 2016 /etc/cron.monthly<br />
drwxr-xr-x. 2 root root 4096 2月 4 2016 /etc/cron.weekly</p>

<p>因此，如果脚本需要每天运行一次，只要将脚本复制到 daily 目录，cron 就会每天执行它。</p>

<p>■ anacron 程序<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
cron 程序的唯一问题是它假定 Linux 系统是 7×24 小时运行的。除非将 Linux 当成服务器环境来运行，否则此假设未必成立。</p>

<p>如果某个作业在 cron 时间表中安排运行的时间已到，但这时候 Linux 系统处于关机状态，那么这个作业就不会被运行。当系统开机时，cron 程序不会再去<br />
运行那些错过的作业。要解决这个问题，许多 Linux 发行版还包含了 anacron 程序。</p>

<p>如果 anacron 知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果 Linux 系统关机了几天，当它再次开机时，原定在关机期间运行的作业会<br />
自动运行。</p>

<p>这个功能常用于进行常规日志维护的脚本。如果系统在脚本应该运行的时间刚好关机，日志文件就不会被整理，可能会变很大。通过 anacron，至少可以保证<br />
系统每次启动时整理日志文件。</p>

<p>anacron 程序只会处理位于 cron 目录的程序，比如 /etc/cron.monthly。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个
cron 目录都有个<br />
时间戳文件，该文件位于/var/spool/anacron 目录。</p>

<p>[devalone@devalone ~]$ ll /var/spool/anacron<br />
总用量 12<br />
-rw&mdash;&mdash;-. 1 root root 9 7月 8 12:11 cron.daily<br />
-rw&mdash;&mdash;-. 1 root root 9 6月 29 17:17 cron.monthly<br />
-rw&mdash;&mdash;-. 1 root root 9 7月 6 11:59 cron.weekly</p>

<p>[devalone@devalone ~]$ sudo cat /var/spool/anacron/cron.daily<br />
20180708</p>

<p>anacron 程序使用自己的时间表（通常位于 /etc/anacrontab）来检查作业目录。</p>

<p>[devalone@devalone ~]$ sudo cat /etc/anacrontab</p>

<h1 id="etc-anacrontab-configuration-file-for-anacron">/etc/anacrontab: configuration file for anacron</h1>

<h1 id="see-anacron-8-and-anacrontab-5-for-details">See anacron(8) and anacrontab(5) for details.</h1>

<p>SHELL=/bin/sh<br />
PATH=/sbin:/bin:/usr/sbin:/usr/bin<br />
MAILTO=root</p>

<h1 id="the-maximal-random-delay-added-to-the-base-delay-of-the-jobs">the maximal random delay added to the base delay of the jobs</h1>

<p>RANDOM_DELAY=45</p>

<h1 id="the-jobs-will-be-started-during-the-following-hours-only">the jobs will be started during the following hours only</h1>

<p>START_HOURS_RANGE=3-22</p>

<p>#period in days delay in minutes job-identifier command<br />
1 5 cron.daily nice run-parts /etc/cron.daily<br />
7 25 cron.weekly nice run-parts /etc/cron.weekly<br />
@monthly 45 cron.monthly nice run-parts /etc/cron.monthly</p>

<p>anacron 时间表的基本格式和 cron 时间表略有不同：</p>

<p>period delay identifier command</p>

<p>period 条目定义了作业多久运行一次，以天为单位。anacron 程序用此条目来检查作业的时间戳文件。delay 条目会指定系统启动后 anacron
程序需要<br />
等待多少分钟再开始运行错过的脚本。command 条目包含了 run-parts 程序和一个 cron 脚本目录名。run-parts
程序负责运行传给它的目录中的任何脚本。</p>

<p>可以使用 which run-parts 搜索，其实那是一个 bash script 脚本程序。</p>

<p>[devalone@devalone ~]$ which run-parts<br />
/usr/bin/run-parts</p>

<p>[devalone@devalone ~]$ ll /usr/bin/run-parts<br />
-rwxr-xr-x. 1 root root 2089 2月 4 2016 /usr/bin/run-parts</p>

<p>[devalone@devalone ~]$ cat /usr/bin/run-parts<br />
#!/bin/bash</p>

<h1 id="run-parts-concept-taken-from-debian">run-parts - concept taken from Debian</h1>

<p>&hellip;</p>

<p>看下 /usr/bin/run-parts 文件内容，这个脚本会执行后面给出的目录内的所有文件。</p>

<p>注意，anacron 不会运行位于/etc/cron.hourly 的脚本。这是因为 anacron 程序不会处理执行时间需求小于一天的脚本。</p>

<p>identifier 条目是一种特别的非空字符串，如 cron-weekly。它用于唯一标识日志消息和错误邮件中的作业。</p>

<p>6.6.3 使用新shell 启动脚本<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
如果每次运行脚本的时候都能够启动一个新的 bash shell（即便只是某个用户启动了一个bash shell），将会非常的方便。有时候，希望为 shell
会话设置<br />
某些 shell 功能，或者只是为了确保已经设置了某个文件。</p>

<p>当用户登入 bash shell 时需要运行的启动文件，基本上，依照下列顺序所找到的第一个文件会被运行，其余的文件会被忽略：</p>

<p>□ $HOME/.bash_profile<br />
□ $HOME/.bashrc<br />
□ $HOME/.bash_login<br />
□ $HOME/.profile</p>

<p>因此，应该将需要在登录时运行的脚本放在上面第一个文件中。</p>

<p>每次启动一个新 shell时，bash shell都会运行.bashrc文件。</p>

<p>.bashrc 文件通常也是通过某个 bash 启动文件来运行的。因为 .bashrc 文件会运行两次：一次是当用户登录 bash shell
时，另一次是当用户启动一个<br />
bash shell时。如果需要一个脚本在两个时刻都得以运行，可以把这个脚本放进该文件中。</p>

<p>示例：<br />
[devalone@devalone ~]$ cat .bashrc</p>

<h1 id="bashrc">.bashrc</h1>

<h1 id="source-global-definitions">Source global definitions</h1>

<p>if [ -f /etc/bashrc ]; then<br />
. /etc/bashrc<br />
fi</p>

<h1 id="uncomment-the-following-line-if-you-don-t-like-systemctl-s-auto-paging">Uncomment the following line if you don&rsquo;t like systemctl&rsquo;s auto-paging</h1>

<p>feature:</p>

<h1 id="export-systemd-pager">export SYSTEMD_PAGER=</h1>

<h1 id="user-specific-aliases-and-functions">User specific aliases and functions</h1>

<p>export REPO_URL=&lsquo;<a href="https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'">https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'</a></p>

<p>echo &ldquo;I&rsquo;m in a new shell&rdquo;</p>

<p>[devalone@devalone ~]$ bash<br />
I&rsquo;m in a new shell<br />
[devalone@devalone ~]$ exit</p>

<p>（本篇完）</p>

<p>系列目录：</p>

<p>Linux shell 脚本编程-基础篇 （一）</p>

<p>Linux shell 脚本编程-基础篇 （二）</p>

<p>Linux shell 脚本编程-基础篇 （三）</p>

<p>Linux shell 脚本编程-基础篇 （四）</p>

<p>Linux shell 脚本编程-基础篇 （五）</p>

<p>Linux shell 脚本编程-基础篇 （六）</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
参考：</p>

<p>《Linux 命令行与 shell 脚本编程大全》 第 3 版 —— 2016.8（美）Richard Blum Cristine Bresnahan</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>