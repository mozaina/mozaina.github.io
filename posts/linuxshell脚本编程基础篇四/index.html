<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linuxshell脚本编程基础篇四 | 开发者问答集锦</title>
    <meta property="og:title" content="Linuxshell脚本编程基础篇四 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linuxshell脚本编程基础篇四">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linuxshell脚本编程基础篇四</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>继 Linux shell 脚本编程-基础篇 （三）</p>

<p>4. 处理用户输入</p>

<hr />

<p>脚本还得能够与使用者进行交互。bash shell 提供了一些不同的方法来从用户处获得数据，包括命令行参数（添加在命令后的数据）、命令行选项（可修改</p>

<p>命令行为的单个字母）以及直接从键盘读取输入的能力。</p>

<p>4.1 命令行参数<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
向 shell 脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。</p>

<p>./addem 10 30</p>

<p>本例向脚本 addem 传递了两个命令行参数（10和30）。脚本会通过特殊的变量来处理命令行参数。</p>

<p>4.1.1 读取参数<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
bash shell 会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数。这也包括 shell
所执行的脚本名称。位置参数<br />
变量是标准的数字：$0是程序名，$1是第一个参数，$2是第二个参数，依次类推，直到第九个参数$9。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test1.sh<br />
#!/bin/bash</p>

<h1 id="using-one-command-line-parameter">using one command line parameter</h1>

<p>factorial=1<br />
for (( number=1; number &lt;= $1; number++ ))<br />
do<br />
factorial=$[ $factorial * $number ]<br />
done<br />
echo The factorial of $1 is $factorial</p>

<p>运行：<br />
[devalone@devalone 14]$ test1.sh 5<br />
The factorial of 5 is 120</p>

<p>可以在 shell 脚本中像使用其他变量一样使用 $1 变量。shell 脚本会自动将命令行参数的值分配给变量，不需要作任何处理。</p>

<p>如果需要输入更多的命令行参数，则每个参数都必须用空格分开。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test2.sh<br />
#!/bin/bash</p>

<h1 id="testing-two-command-line-parameters">testing two command line parameters</h1>

<p>total=$[ $1 * $2 ]<br />
echo The first paramter is $1.<br />
echo The second parameter is $2.<br />
echo The total value is $total.</p>

<p>运行：<br />
[devalone@devalone 14]$ test2.sh 2 5<br />
The first paramter is 2.<br />
The second parameter is 5.<br />
The total value is 10.</p>

<p>shell 会将每个参数分配给对应的变量。</p>

<p>也可以在命令行上用文本字符串：</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test3.sh<br />
#!/bin/bash</p>

<h1 id="testing-string-parameters">testing string parameters</h1>

<p>echo Hello $1, glad to meet you</p>

<p>运行：<br />
[devalone@devalone 14]$ test3.sh deva<br />
Hello deva, glad to meet you</p>

<p>shell 将输入到命令行的字符串值传给脚本。但碰到含有空格的文本字符串时就会出现问题：</p>

<p>运行：<br />
[devalone@devalone 14]$ test3.sh deva Richard<br />
Hello deva, glad to meet you</p>

<p>每个参数都是用空格分隔的，所以 shell 会将空格当成两个值的分隔符。要在参数值中包含空格，必须要用引号（单引号或双引号均可）。</p>

<p>运行：<br />
[devalone@devalone 14]$ test3.sh &lsquo;deva Richard&rsquo;<br />
Hello deva Richard, glad to meet you</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
将文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置。</p>

<p>如果脚本需要的命令行参数不止 9 个，仍然可以处理，但是需要稍微修改一下变量名。在第 9 个变量之后，必须在变量数字周围加上花括号，比如${10}。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test4.sh<br />
#!/bin/bash</p>

<h1 id="handling-lots-of-parameters">handling lots of parameters</h1>

<p>total=$[ ${10} * ${11} ]<br />
echo The 10th parameter is ${10}<br />
echo The 11th parameter is ${11}<br />
echo The total is $total</p>

<p>运行：<br />
[devalone@devalone 14]$ test4.sh 1 2 3 4 5 6 7 8 9 10 12<br />
The 10th parameter is 10<br />
The 11th parameter is 12<br />
The total is 120</p>

<p>4.1.2 读取脚本名<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
可以用 $0 参数获取 shell 在命令行启动的脚本名。这在编写多功能工具时很方便。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test5.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-0-parameter">Testing the $0 parameter</h1>

<p>echo The zero parameter is set to: $0<br />
#</p>

<p>运行：<br />
[devalone@devalone 14]$ test5.sh<br />
The zero parameter is set to: ./test5.sh</p>

<p>[devalone@devalone 14]$ bash test5.sh<br />
The zero parameter is set to: test5.sh</p>

<p>运行方式不同，结果也不同。当传给 $0 变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量 $0 就会使用整个路径。</p>

<p>运行：</p>

<p>[devalone@devalone 14]$ bash /home/devalone/study/shell-script/14/test5.sh<br />
The zero parameter is set to: /home/devalone/study/shell-script/14/test5.sh</p>

<p>如果要编写一个根据脚本名来执行不同功能的脚本，就得做点额外工作。得把脚本的运行路径给剥离掉。另外，还要删除与脚本名混杂在一起的命令。</p>

<p>幸好有个方便的小命令可以帮到我们。basename 命令会返回不包含路径的脚本名。</p>

<p>示例：</p>

<p>[devalone@devalone 14]$ cat test5b.sh<br />
#!/bin/bash</p>

<h1 id="using-basename-with-the-0-parameter">using basename with the $0 parameter</h1>

<p>name=$(basename $0)<br />
echo The script name is: $name<br />
#</p>

<p>运行：<br />
[devalone@devalone 14]$ bash /home/devalone/study/shell-script/14/test5b.sh<br />
The script name is: test5b.sh</p>

<p>[devalone@devalone 14]$ test5b.sh<br />
The script name is: test5b.sh</p>

<p>现在好多了。可以用这种方法来编写基于脚本名执行不同功能的脚本：</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test6.sh<br />
#!/bin/bash</p>

<h1 id="testing-a-multi-function-script">testing a multi-function script</h1>

<p>name=$(basename $0)</p>

<p>if [ $name = &ldquo;addem&rdquo; ]<br />
then<br />
total=$[ $1 + $2 ]<br />
elif [ $name = &ldquo;multem&rdquo; ]<br />
then<br />
total=$[ $1 * $2 ]<br />
fi</p>

<p>echo<br />
echo The calculated value is $total</p>

<p>运行：<br />
[devalone@devalone 14]$ cp test6.sh addem</p>

<p>[devalone@devalone 14]$ ls -l *em<br />
-rwxrwxr-x. 1 devalone devalone 221 7月 6 16:24 addem<br />
lrwxrwxrwx. 1 devalone devalone 8 7月 6 16:25 multem -&gt; test6.sh</p>

<p>[devalone@devalone 14]$ addem 2 5</p>

<p>The calculated value is 7<br />
[devalone@devalone 14]$ multem 2 5</p>

<p>The calculated value is 10</p>

<p>4.1.3 测试参数<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在 shell 脚本中使用命令行参数时要小心些。如果脚本不加参数运行，可能会出问题。</p>

<p>运行：<br />
[devalone@devalone 14]$ addem 2<br />
./addem:行8: 2 + : 语法错误: 需要操作数 (错误符号是 &ldquo;+ &ldquo;)</p>

<p>The calculated value is</p>

<p>当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。在使用参数前一定要检查其中是否存在数据。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test7.sh<br />
#!/bin/bash</p>

<h1 id="testing-parameters-befor-use">testing parameters befor use</h1>

<p>if [ -n &ldquo;$1&rdquo; ]<br />
then<br />
echo Hello $1, glad to meet you<br />
else<br />
echo Sorry, you did not identify yourself<br />
fi</p>

<p>运行：<br />
[devalone@devalone 14]$ test7.sh<br />
Sorry, you did not identify yourself</p>

<p>[devalone@devalone 14]$ test7.sh Michael<br />
Hello Michael, glad to meet you</p>

<p>4.2 特殊参数变量<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在 bash shell 中有些特殊变量，它们会记录命令行参数。</p>

<p>4.2.1 参数统计<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
特殊变量 $# 含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test8.sh<br />
#!/bin/bash</p>

<h1 id="getting-the-number-of-parameters">getting the number of parameters</h1>

<p>echo there are $# parameters supplied</p>

<p>运行：<br />
[devalone@devalone 14]$ test8.sh<br />
there are 0 parameters supplied<br />
[devalone@devalone 14]$ test8.sh 1 2 3 4 5<br />
there are 5 parameters supplied<br />
[devalone@devalone 14]$ test8.sh 1 2 3 4 5 6 7 8 9 10<br />
there are 10 parameters supplied</p>

<p>[devalone@devalone 14]$ test8.sh Michael Dan<br />
there are 2 parameters supplied<br />
[devalone@devalone 14]$ test8.sh &ldquo;Michael Dan&rdquo;<br />
there are 1 parameters supplied</p>

<p>在使用参数前测试参数的总数：<br />
[devalone@devalone 14]$ cat test9.sh<br />
#!/bin/bash</p>

<h1 id="testing-parameters">testing parameters</h1>

<p>if [ $# -ne 2 ]<br />
then<br />
echo<br />
echo Usage: test9.sh a b<br />
echo<br />
else<br />
total=$[ $1 + $2 ]<br />
echo<br />
echo the total is $total<br />
echo<br />
fi</p>

<p>运行：<br />
[devalone@devalone 14]$ test9.sh</p>

<p>Usage: test9.sh a b</p>

<p>[devalone@devalone 14]$ test9.sh 10</p>

<p>Usage: test9.sh a b</p>

<p>[devalone@devalone 14]$ test9.sh 10 15</p>

<p>the total is 25</p>

<p>if-then 语句用 -ne 测试命令行参数数量。如果参数数量不对，会显示一条错误消息告知脚本的正确用法。</p>

<p>这个变量还提供了一个简便方法来获取命令行中最后一个参数，完全不需要知道实际上到底用了多少个参数。不过要实现这一点，得稍微多花点工夫。</p>

<p>可能会觉得既然$#变量含有参数的总数，那么变量 ${$#} 就代表了最后一个命令行参数变量。试试看会发生什么：</p>

<p>[devalone@devalone 14]$ cat badtest1.sh<br />
#!/bin/bash</p>

<h1 id="testing-grabbing-last-parameter">testing grabbing last parameter</h1>

<p>echo The last parameter was ${$#}<br />
#</p>

<p>运行：<br />
[devalone@devalone 14]$ ./badtest1.sh 10<br />
The last parameter was 3681</p>

<p>表明不能在花括号内使用美元符。必须将美元符换成感叹号。很奇怪，但的确管用。</p>

<p>[devalone@devalone 14]$ cat test10.sh<br />
#!/bin/bash</p>

<h1 id="grabbing-the-last-parameter">grabbing the last parameter</h1>

<p>parameter=$#<br />
echo<br />
echo the parameter count is $parameter<br />
echo the last parameter is ${!#}<br />
echo</p>

<p>运行：<br />
[devalone@devalone 14]$ test10.sh 1 2 3 4 5</p>

<p>the parameter count is 5<br />
the last parameter is 5</p>

<p>这个测试将 $# 变量的值赋给了变量 params，然后也按特殊命令行参数变量的格式使用了该变量。两种方法都没问题。重要的是要注意，当命令行上没有<br />
任何参数时，$# 的值为 0，params 变量的值也一样，但 ${!#} 变量会返回命令行用到的脚本名。</p>

<p>4.2.2 抓取所有的数据<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
有时候需要抓取命令行上提供的所有参数。这时候不需要先用 $# 变量来判断命令行上有多少参数，然后再进行遍历，可以使用一组其他的特殊变量来解决<br />
这个问题。</p>

<p>$* 和 $@ 变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。</p>

<p>$* 变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上 $* 变量会将这些参数视为一个整体，而<br />
不是多个个体。</p>

<p>$@ 变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样就能够遍历所有的参数值，得到每个参数。这通常通过 for 命令完成。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test11.sh<br />
#!/bin/bash</p>

<h1 id="testing-and">testing $* and $@</h1>

<p>echo<br />
echo &ldquo;Using the \$* method: $*&rdquo;<br />
echo &ldquo;Using the \$@ method: $@&rdquo;</p>

<p>运行：<br />
[devalone@devalone 14]$ test11.sh rich barbara katie jessica</p>

<p>Using the $* method: rich barbara katie jessica<br />
Using the $@ method: rich barbara katie jessica</p>

<p>从表面上看，两个变量产生的是同样的输出，都显示出了所有命令行参数。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test12.sh<br />
#!/bin/bash</p>

<h1 id="testing-and-1">testing $* and $@</h1>

<p>echo<br />
count=1</p>

<p>for param in &ldquo;$<em>&rdquo;<br />
do<br />
echo &ldquo;\$</em> parameter #$count = $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>echo<br />
count=1</p>

<p>for param in &ldquo;$@&rdquo;<br />
do<br />
echo &ldquo;\$@ parameter #$count = $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>运行：<br />
[devalone@devalone 14]$ test12.sh rich barbara katie jessica</p>

<p>$* parameter #1 = rich barbara katie jessica</p>

<p>$@ parameter #1 = rich<br />
$@ parameter #2 = barbara<br />
$@ parameter #3 = katie<br />
$@ parameter #4 = jessica</p>

<p>现在清楚多了。通过使用 for 命令遍历这两个特殊变量，能看到它们是如何不同地处理命令行参数的。$* 变量会将所有参数当成单个参数，而 $@ 变量会<br />
单独处理每个参数。这是遍历命令行参数的一个绝妙方法。</p>

<p>4.3 移动变量<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
bash shell 的 shift 命令能够用来操作命令行参数。跟字面上的意思一样，shift 命令会根据它们的相对位置来移动命令行参数。</p>

<p>在使用 shift 命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量 $3 的值会移到 $2 中，变量 $2 的值会移到 $1 中，而变量
$1 的<br />
值则会被删除（注意，变量 $0 的值，也就是程序名，不会改变）。</p>

<p>这是遍历命令行参数的另一个好方法，尤其是在不知道到底有多少参数时。可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test13.sh<br />
#!/bin/bash</p>

<h1 id="demonstrating-the-shift-command">demonstrating the shift command</h1>

<p>echo<br />
count=1<br />
while [ -n &ldquo;$1&rdquo; ]<br />
do<br />
echo &ldquo;Parameter #$count = $1&rdquo;<br />
count=$[ $count + 1 ]<br />
shift<br />
done</p>

<p>运行：<br />
[devalone@devalone 14]$ test13.sh rich barbara katie jessica</p>

<p>Parameter #1 = rich<br />
Parameter #2 = barbara<br />
Parameter #3 = katie<br />
Parameter #4 = jessica</p>

<p>这个脚本通过测试第一个参数值的长度执行了一个 while 循环。当第一个参数的长度为零时，循环结束。测试完第一个参数后，shift 命令会将所有参数的<br />
位置移动一个位置。</p>

<p>NOTE:<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
使用 shift 命令的时候要小心。如果某个参数被移出，它的值就被丢弃了，无法再恢复</p>

<p>也可以一次性移动多个位置，只需要给 shift 命令提供一个参数，指明要移动的位置数就行了。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test14.sh<br />
#!/bin/bash</p>

<h1 id="demonstrating-a-multi-position-shift">demonstrating a multi-position shift</h1>

<p>echo<br />
echo &ldquo;The original parameters: $*&rdquo;<br />
shift 2<br />
echo &ldquo;Here&rsquo;s the new first parameter: $1&rdquo;<br />
echo</p>

<p>运行：<br />
[devalone@devalone 14]$ test14.sh 1 2 3 4 5</p>

<p>The original parameters: 1 2 3 4 5<br />
Here&rsquo;s the new first parameter: 3</p>

<p>通过使用 shift 命令的参数，就可以轻松地跳过不需要的参数。</p>

<p>4.4 处理选项<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
选项是跟在单破折线后面的单个字母，它能改变命令的行为。</p>

<p>4.4.1 查找选项<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
表面上看，命令行选项也没什么特殊的。在命令行上，它们紧跟在脚本名之后，就跟命令行参数一样。实际上，如果愿意，可以像处理命令行参数一样处理<br />
命令行选项。</p>

<p>● 处理简单选项<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在前面的 test13.sh 脚本中，看到了如何使用 shift 命令来依次处理脚本程序携带的命令行参数。也可以用同样的方法来处理命令行选项。</p>

<p>在提取每个单独参数时，用 case 语句来判断某个参数是否为选项:</p>

<p>[devalone@devalone 14]$ cat test15.sh<br />
#!/bin/bash</p>

<h1 id="extracting-command-line-options-as-parameters">extracting command line options as parameters</h1>

<p>echo<br />
while [ -n &ldquo;$1&rdquo; ]<br />
do<br />
case &ldquo;$1&rdquo; in<br />
-a) echo &ldquo;found the -a option&rdquo;;;<br />
-b) echo &ldquo;found the -b option&rdquo;;;<br />
-c) echo &ldquo;found the -c option&rdquo;;;<br />
*) echo &ldquo;$1 is not an option&rdquo;;;<br />
esac<br />
shift<br />
done</p>

<p>运行：<br />
[devalone@devalone 14]$ test15.sh -a -b -c -d</p>

<p>found the -a option<br />
found the -b option<br />
found the -c option<br />
-d is not an option</p>

<p>case 语句会检查每个参数是不是有效选项。如果是的话，就运行对应 case 语句中的命令。不管选项按什么顺序出现在命令行上，这种方法都适用。</p>

<p>运行：<br />
[devalone@devalone 14]$ test15.sh -d -c -a</p>

<p>-d is not an option<br />
found the -c option<br />
found the -a option</p>

<p>● 分离参数和选项<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
经常遇到想在 shell 脚本中同时使用选项和参数的情况。Linux 中处理这个问题的标准方式是用特殊字符来将二者分开，该字符会告诉脚本何时选项结束<br />
以及普通参数何时开始。</p>

<p>对 Linux 来说，这个特殊字符是双破折线（&ndash;）。shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作<br />
参数，而不是选项来处理了。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test16.sh<br />
#!/bin/bash</p>

<h1 id="extracting-options-and-parameters">extracting options and parameters</h1>

<p>echo<br />
while [ -n &ldquo;$1&rdquo; ]<br />
do<br />
case &ldquo;$1&rdquo; in<br />
-a) echo &ldquo;found the -a option&rdquo;;;<br />
-b) echo &ldquo;found the -b option&rdquo;;;<br />
-c) echo &ldquo;found the -c option&rdquo;;;<br />
--) shift<br />
break;;<br />
*) echo &ldquo;$1 is not an option&rdquo;;;<br />
esac<br />
shift<br />
done</p>

<p>count=1<br />
for param in $@<br />
do<br />
echo &ldquo;parameter #$count: $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>在遇到双破折线时，脚本用 break 命令来跳出 while 循环。由于过早地跳出了循环，我们需要再加一条 shift 命令来将双破折线移出参数变量。</p>

<p>运行：<br />
[devalone@devalone 14]$ test16.sh -c -a -b &ndash; test1 test2 test3</p>

<p>found the -c option<br />
found the -a option<br />
found the -b option<br />
parameter #1: test1<br />
parameter #2: test2<br />
parameter #3: test3</p>

<p>当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p>

<p>● 处理带值的选项<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
有些选项会带上一个额外的参数值。在这种情况下，命令行看起来像下面这样：</p>

<p>$ ./testing.sh -a test1 -b -c -d test2</p>

<p>当命令行选项要求额外的参数时，脚本必须能检测到并正确处理。下面是如何处理的示例：</p>

<p>[devalone@devalone 14]$ cat test17.sh<br />
#!/bin/bash</p>

<h1 id="extracting-options-and-values">extracting options and values</h1>

<p>echo<br />
while [ -n &ldquo;$1&rdquo; ]<br />
do<br />
case &ldquo;$1&rdquo; in<br />
-a) echo &ldquo;found the -a option&rdquo;;;<br />
-b) param=&ldquo;$2&rdquo;<br />
echo &ldquo;found the -b option, with parameter value $param&rdquo;<br />
shift ;;<br />
-c) echo &ldquo;found the -c option&rdquo;;;<br />
--) shift<br />
break;;<br />
*) echo &ldquo;$1 is not an option&rdquo;;;<br />
esac<br />
shift<br />
done</p>

<p>count=1<br />
for param in $@<br />
do<br />
echo &ldquo;parameter #$count: $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>运行：<br />
[devalone@devalone 14]$ test17.sh -a -b test1 -d</p>

<p>found the -a option<br />
found the -b option, with parameter value test1<br />
-d is not an option</p>

<p>在这个例子中，case 语句定义了三个它要处理的选项。-b 选项还需要一个额外的参数值。由于要处理的参数是 $1，额外的参数值就应该位于$2（因为所有<br />
的参数在处理完之后都会被移出）。只要将参数值从 $2 变量中提取出来就可以了。当然，因为这个选项占用了两个参数位，所以还需要使用 shift 命令<br />
多移动一个位置。</p>

<p>只用这些基本的特性，整个过程就能正常工作，不管按什么顺序放置选项（但要记住包含每个选项相应的选项参数）。</p>

<p>运行：<br />
[devalone@devalone 14]$ test17.sh -b test1 -a -d</p>

<p>found the -b option, with parameter value test1<br />
found the -a option<br />
-d is not an option</p>

<p>现在 shell 脚本中已经有了处理命令行选项的基本能力，但还有一些限制。比如，如果想将多个选项放进一个参数中时，它就不能工作了。</p>

<p>[devalone@devalone 14]$ test17.sh -ac<br />
-ac is not an option</p>

<p>在 Linux中，合并选项是一个很常见的用法，而且如果脚本想要对用户更友好一些，也要给用户提供这种特性。幸好，有另外一种处理选项的方法能够帮忙。</p>

<p>4.4.2 使用getopt 命令<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
getopt 命令是一个在处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而在脚本中解析它们时更方便。</p>

<p>● 命令的格式<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
getopt 命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式。它的命令格式如下：</p>

<p>getopt optstring parameters</p>

<p>optstring 是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。</p>

<p>首先，在 optstring 中列出要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。getopt 命令会基于此定义的<br />
optstring 解析提供的参数。</p>

<p>下面是个 getopt 如何工作的简单例子：</p>

<p>[devalone@devalone 14]$ getopt ab:cd -a -b test1 -cd test2 test3<br />
-a -b test1 -c -d &ndash; test2 test3</p>

<p>optstring 定义了四个有效选项字母：a、b、c和d。冒号（:）被放在了字母 b 后面，因为 b 选项需要一个参数值。当 getopt
命令运行时，它会检查提供<br />
的参数列表（-a -b test1 -cd test2 test3），并基于提供的 optstring 进行解析。注意，它会自动将 -cd
选项分成两个单独的选项，并插入双破折线来<br />
分隔行中的额外参数。</p>

<p>如果指定了一个不在 optstring 中的选项，默认情况下，getopt 命令会产生一条错误消息：</p>

<p>[devalone@devalone 14]$ getopt ab:cd -a -b test1 -cde test2 test3<br />
getopt: invalid option &ndash; &lsquo;e&rsquo;<br />
-a -b test1 -c -d &ndash; test2 test3</p>

<p>如果想忽略这条错误消息，可以在命令后加 -q 选项：</p>

<p>[devalone@devalone 14]$ getopt -q ab:cd -a -b test1 -cde test2 test3<br />
-a -b &lsquo;test1&rsquo; -c -d &ndash; &lsquo;test2&rsquo; &lsquo;test3&rsquo;</p>

<p>注意，getopt 命令选项必须出现在 optstring 之前。</p>

<p>● 在脚本中使用 getopt<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
可以在脚本中使用 getopt 来格式化脚本所携带的任何命令行选项或参数，但用起来略微复杂。方法是用 getopt 命令生成的格式化后的版本来替换已有的<br />
命令行选项和参数。用 set 命令能够做到。</p>

<p>set 命令的选项之一是双破折线（&ndash;），它会将命令行参数替换成 set 命令的命令行值。</p>

<p>然后，该方法会将原始脚本的命令行参数传给 getopt 命令，之后再将 getopt 命令的输出传给 set 命令，用 getopt
格式化后的命令行参数来替换原始的<br />
命令行参数，看起来如下所示：</p>

<p>set &ndash; $(getopt -q ab:cd &ldquo;$@&rdquo;)</p>

<p>现在原始的命令行参数变量的值会被 getopt 命令的输出替换，而 getopt 已经为我们格式化好了命令行参数。</p>

<p>利用该方法，现在就可以写出能帮我们处理命令行参数的脚本。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test18.sh<br />
#!/bin/bash</p>

<h1 id="extract-command-line-options-and-values-with-getopt">extract command line options and values with getopt</h1>

<p>set &ndash; $(getopt -q ab:cd &ldquo;$@&rdquo;)</p>

<p>echo<br />
while [ -n &ldquo;$1&rdquo; ]<br />
do<br />
case &ldquo;$1&rdquo; in<br />
-a) echo &ldquo;found the -a option&rdquo;;;<br />
-b) param=&ldquo;$2&rdquo;<br />
echo &ldquo;found the -b option, with parameter value $param&rdquo;<br />
shift ;;<br />
-c) echo &ldquo;found the -c option&rdquo;;;<br />
--) shift<br />
break;;<br />
*) echo &ldquo;$1 is not an option&rdquo;;;<br />
esac<br />
shift<br />
done</p>

<p>count=1<br />
for param in $@<br />
do<br />
echo &ldquo;parameter #$count: $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>运行：<br />
[devalone@devalone 14]$ test18.sh -ac</p>

<p>found the -a option<br />
found the -c option</p>

<p>[devalone@devalone 14]$ test18.sh -a -b test1 -cd test2 test3 test4</p>

<p>found the -a option<br />
found the -b option, with parameter value &lsquo;test1&rsquo;<br />
found the -c option<br />
-d is not an option<br />
parameter #1: &lsquo;test2&rsquo;<br />
parameter #2: &lsquo;test3&rsquo;<br />
parameter #3: &lsquo;test4&rsquo;</p>

<p>现在看起来相当不错了。但是，在 getopt 命令中仍然隐藏着一个小问题。看看这个例子：</p>

<p>运行：<br />
[devalone@devalone 14]$ test18.sh -a -b test1 -cd &ldquo;test2 test3&rdquo; test4</p>

<p>found the -a option<br />
found the -b option, with parameter value &lsquo;test1&rsquo;<br />
found the -c option<br />
-d is not an option<br />
parameter #1: &lsquo;test2<br />
parameter #2: test3&rsquo;<br />
parameter #3: &lsquo;test4&rsquo;</p>

<p>getopt 命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。还有另外一个办法能解决这个问题。</p>

<p>● 使用更高级的 getopts<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
getopts 命令（注意是复数）内建于 bash shell。它跟近亲 getopt 看起来很像，但多了一些扩展功能。</p>

<p>与 getopt 不同，前者将命令行上选项和参数处理后只生成一个输出，而 getopts 命令能够和已有的 shell 参数变量配合默契。</p>

<p>每次调用它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于 0 的退出状态码。这让它非常适合用解析命令行<br />
所有参数的循环中。</p>

<p>getopts 命令的格式如下：</p>

<p>getopts optstring variable</p>

<p>optstring 值类似于 getopt 命令中的那个。有效的选项字母都会列在 optstring
中，如果选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，<br />
可以在 optstring 之前加一个冒号。getopts 命令将当前参数保存在命令行中定义的 variable 中。</p>

<p>getopts 命令会用到两个环境变量。如果选项需要跟一个参数值，OPTARG 环境变量就会保存这个值。OPTIND 环境变量保存了参数列表中
getopts 正在处理<br />
的参数位置。这样就能在处理完选项之后继续处理其他命令行参数了。</p>

<p>getopts 命令的简单示例：</p>

<p>[devalone@devalone 14]$ cat test19.sh<br />
#!/bin/bash</p>

<h1 id="simple-demonstration-of-the-getopts-command">simple demonstration of the getopts command</h1>

<p>echo<br />
while getopts :ab:c opt<br />
do<br />
case &ldquo;$opt&rdquo; in<br />
a) echo &ldquo;Found the -a option&rdquo;;;<br />
b) echo &ldquo;Found the -b option, with value $OPTARG&rdquo;;;<br />
c) echo &ldquo;Found the -c option&rdquo;;;<br />
*) echo &ldquo;Unknown option: $opt&rdquo;;;<br />
esac<br />
done</p>

<p>运行：<br />
[devalone@devalone 14]$ test19.sh -ab test1 -c</p>

<p>Found the -a option<br />
Found the -b option, with value test1<br />
Found the -c option</p>

<p>while语句定义了 getopts 命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（opt）。</p>

<p>注意到在本例中case语句的用法有些不同。getopts 命令解析命令行选项时会移除开头的单破折线，所以在 case 定义中不用单破折线。</p>

<p>getopts 命令有几个好用的功能。可以在参数值中包含空格。</p>

<p>运行：<br />
[devalone@devalone 14]$ test19.sh -ab &ldquo;test1 test2&rdquo; -c</p>

<p>Found the -a option<br />
Found the -b option, with value test1 test2<br />
Found the -c option</p>

<p>另一个好用的功能是将选项字母和参数值放在一起使用，而不用加空格。</p>

<p>运行：<br />
[devalone@devalone 14]$ test19.sh -abtest1</p>

<p>Found the -a option<br />
Found the -b option, with value test1</p>

<p>getopts 命令能够从 -b 选项中正确解析出 test1 值。</p>

<p>除此之外，getopts 还能够将命令行上找到的所有未定义的选项统一输出成问号。</p>

<p>运行：<br />
[devalone@devalone 14]$ test19.sh -d</p>

<p>Unknown option: ?</p>

<p>[devalone@devalone 14]$ test19.sh -acde</p>

<p>Found the -a option<br />
Found the -c option<br />
Unknown option: ?<br />
Unknown option: ?</p>

<p>getopts 命令知道何时停止处理选项，并将参数留给处理。在 getopts 处理每个选项时，它会将 OPTIND 环境变量值增一。在 getopts
完成处理时，<br />
可以使用 shift 命令和 OPTIND 值来移动参数。</p>

<p>示例：</p>

<p>[devalone@devalone 14]$ cat test20.sh<br />
#!/bin/bash</p>

<h1 id="processing-options-parameters-with-getopts">processing options &amp; parameters with getopts</h1>

<p>echo<br />
while getopts :ab:cd opt<br />
do<br />
case &ldquo;$opt&rdquo; in<br />
a) echo &ldquo;Found the -a option&rdquo;;;<br />
b) echo &ldquo;Found the -b option, with value $OPTARG&rdquo;;;<br />
c) echo &ldquo;Found the -c option&rdquo;;;<br />
d) echo &ldquo;Found the -d option&rdquo;;;<br />
*) echo &ldquo;Unknown option: $opt&rdquo;;;<br />
esac<br />
done</p>

<p>shift $[ $OPTIND - 1 ]</p>

<p>echo<br />
count=1<br />
for param in &ldquo;$@&rdquo;<br />
do<br />
echo &ldquo;Parameter $count: $param&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>运行：<br />
[devalone@devalone 14]$ test20.sh -a -b test1 -d test2 test3 test4</p>

<p>Found the -a option<br />
Found the -b option, with value test1<br />
Found the -d option</p>

<p>Parameter 1: test2<br />
Parameter 2: test3<br />
Parameter 3: test4</p>

<p>4.5 将选项标准化<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
在创建 shell 脚本时，显然可以控制具体怎么做。程序员完全可以决定用哪些字母选项以及它们的用法。但有些字母选项在 Linux 世界里已经拥有了某种<br />
程度的标准含义。如果能在 shell 脚本中支持这些选项，脚本看起来能更友好一些。</p>

<p>下表显示了 Linux 中用到的一些命令行选项的常用含义。</p>

<p>常用的Linux命令选项<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| 选 项 | 描 述<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -a | 显示所有对象<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -c | 生成一个计数<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -d | 指定一个目录<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -e | 扩展一个对象<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -f | 指定读入数据的文件<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -h | 显示命令的帮助信息<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -i | 忽略文本大小写<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -l | 产生输出的长格式版本<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -n | 使用非交互模式（批处理）<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -o | 将所有输出重定向到的指定的输出文件<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -q | 以安静模式运行<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -r | 递归地处理目录和文件<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -s | 以安静模式运行<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -v | 生成详细输出<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -x | 排除某个对象<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
| -y | 对所有问题回答yes<br />
+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>如果自己的选项也采用同样的含义，这样用户在使用这样的脚本时就不用去查手册了。</p>

<p>4.6 获得用户输入<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
尽管命令行选项和参数是从脚本用户处获得输入的一种重要方式，但有时脚本的交互性还需要更强一些。比如想要在脚本运行时问个问题，并等待运行脚本的<br />
用户来回答。bash shell 为此提供了 read 命令。</p>

<p>4.6.1 基本的读取<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
read 命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read 命令会将数据放进一个变量。下面是 read 命令的最简单用法。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test21.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-read-command">testing the read command</h1>

<p>echo -n &ldquo;Enter your name: &ldquo;<br />
read name<br />
echo &ldquo;Hello $name, welcome to my program&rdquo;</p>

<p>运行：<br />
[devalone@devalone 14]$ test21.sh<br />
Enter your name: Michael<br />
Hello Michael, welcome to my program</p>

<p>注意，生成提示的 echo 命令使用了 -n 选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。这让脚本看起来更<br />
像表单。</p>

<p>实际上，read 命令包含了 -p 选项，允许直接在 read 命令行指定提示符。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test22.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-read-p-option">testing the read -p option</h1>

<p>read -p &ldquo;Please enter your age: &ldquo; age<br />
days=$[ $age * 365 ]<br />
echo &ldquo;That makes you over $days days old!&rdquo;</p>

<p>运行：<br />
[devalone@devalone 14]$ test22.sh<br />
Please enter your age: 22<br />
That makes you over 8030 days old!</p>

<p>再次运行第一个例子，输入名和姓氏两个单词：<br />
[devalone@devalone 14]$ test21.sh<br />
Enter your name: Michael Y.<br />
Hello Michael Y., welcome to my program</p>

<p>在例示例中当有名字输入时，read 命令会将姓和名保存在同一个变量中。read 命令会将提示符后输入的所有数据分配给单个变量，要么就指定多个变量。<br />
输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test23.sh<br />
#!/bin/bash</p>

<h1 id="enter-multiple-variablse">enter multiple variablse</h1>

<p>read -p &ldquo;Enter your name: &ldquo; first last<br />
echo &ldquo;Checking data for $last, $first&rdquo;</p>

<p>运行：<br />
[devalone@devalone 14]$ test23.sh<br />
Enter your name: Michael Ya<br />
Checking data for Ya, Michael</p>

<p>也可以在 read 命令行中不指定变量。如果是这样，read 命令会将它收到的任何数据都放进特殊环境变量 REPLY 中。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test24.sh<br />
#!/bin/bash</p>

<h1 id="testing-the-reply-environment-variable">testing the REPLY environment variable</h1>

<p>read -p &ldquo;Enter you name: &ldquo;<br />
echo<br />
echo Hello $REPLY, welcome to my program</p>

<p>运行：<br />
[devalone@devalone 14]$ test24.sh<br />
Enter you name: Michael</p>

<p>Hello Michael, welcome to my program</p>

<p>REPLY 环境变量会保存输入的所有数据，可以在 shell 脚本中像其他变量一样使用。</p>

<p>4.6.2 超时<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
使用 read 命令时要当心。脚本很可能会一直等着脚本用户的输入。如果不管是否有数据输入，脚本都必须继续执行，可以用 -t 选项来指定一个计时器。<br />
-t 选项指定了 read 命令等待输入的秒数。当计时器过期后，read 命令会返回一个非零退出状态码。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test25.sh<br />
#!/bin/bash</p>

<h1 id="enter-multiple-variablse-1">enter multiple variablse</h1>

<p>if read -t 5 -p &ldquo;Enter your name: &ldquo; name<br />
then<br />
echo &ldquo;Hello $name, welcome to my script&rdquo;<br />
else<br />
echo &ldquo;Sorry, too slow&rdquo;<br />
fi</p>

<p>运行：<br />
[devalone@devalone 14]$ test25.sh<br />
Enter your name: Sorry, too slow</p>

<p>如果计时器过期，read 命令会以非零退出状态码退出，可以使用如 if-then 语句或 while
循环这种标准的结构化语句来理清所发生的具体情况。在本例中，<br />
计时器过期时，if 语句不成立，shell 会执行 else 部分的命令。</p>

<p>也可以不对输入过程计时，而是让 read 命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test26.sh<br />
#!/bin/bash</p>

<h1 id="getting-just-one-character-of-input">getting just one character of input</h1>

<p>read -n1 -p &ldquo;Do you want to continue [Y/N]?&rdquo; answer<br />
case $answer in<br />
Y | y) echo<br />
echo &ldquo;fine, continue on&hellip;&rdquo;;;<br />
N | n) echo<br />
echo OK, goodbye<br />
exit;;<br />
esac<br />
echo &ldquo;This is the end of the scripty&rdquo;</p>

<p>运行：<br />
[devalone@devalone 14]$ test26.sh<br />
Do you want to continue [Y/N]?y<br />
fine, continue on&hellip;<br />
This is the end of the scripty<br />
[devalone@devalone 14]$ test26.sh<br />
Do you want to continue [Y/N]?n<br />
OK, goodbye</p>

<p>本例中将 -n 选项和值 1 一起使用，告诉 read 命令在接受单个字符后退出。只要按下单个字符回答后，read 命令就会接受输入并将它传给变量，无需按<br />
回车键。</p>

<p>4.6.3 隐藏方式读取<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
有时需要从脚本用户处得到输入，但又在屏幕上显示输入信息。其中典型的例子就是输入的密码，但除此之外还有很多其他需要隐藏的数据类型。</p>

<p>-s 选项可以避免在 read 命令中输入的数据出现在显示器上。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test27.sh<br />
#!/bin/bash</p>

<h1 id="hiding-input-data-from-the-monitor">hiding input data from the monitor</h1>

<p>read -s -p &ldquo;Enter your password: &ldquo; pass<br />
echo<br />
echo &ldquo;Is your password really $pass ?&rdquo;</p>

<p>运行：<br />
[devalone@devalone 14]$ test27.sh<br />
Enter your password:<br />
Is your password really 12345 ?</p>

<p>输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用。</p>

<p>4.6.4 从文件中读取<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
也可以用 read命令来读取 Linux 统上文件里保存的数据。每次调用 read 命令，它都会从文件中读取一行文本。当文件中再没有内容时，read
命令会退出<br />
并返回非零退出状态码。</p>

<p>其中最难的部分是将文件中的数据传给 read 命令。最常见的方法是对文件使用 cat 命令，将结果通过管道直接传给含有 read 命令的 while 命令。</p>

<p>示例：<br />
[devalone@devalone 14]$ cat test28.sh<br />
#!/bin/bash</p>

<h1 id="reading-data-from-a-file">reading data from a file</h1>

<p>count=1<br />
cat test | while read line<br />
do<br />
echo &ldquo;Line $count: $line&rdquo;<br />
count=$[ $count + 1 ]<br />
done</p>

<p>echo &ldquo;finished processing the file&rdquo;</p>

<p>运行：<br />
[devalone@devalone 14]$ cat test<br />
The quick brown dog jumps over the lazy fox.<br />
This is a test, this only a test.<br />
Romeo,Romeo! wherefore art thou Romeo?</p>

<p>[devalone@devalone 14]$ test28.sh<br />
Line 1: The quick brown dog jumps over the lazy fox.<br />
Line 2: This is a test, this only a test.<br />
Line 3: Romeo,Romeo! wherefore art thou Romeo?<br />
finished processing the file</p>

<p>while 循环会持续通过 read 命令处理文件中的行，直到 read 命令以非零退出状态码退出。</p>

<p>系列目录：</p>

<p>Linux shell 脚本编程-基础篇 （一）</p>

<p>Linux shell 脚本编程-基础篇 （二）</p>

<p>Linux shell 脚本编程-基础篇 （三）</p>

<p>Linux shell 脚本编程-基础篇 （四）</p>

<p>Linux shell 脚本编程-基础篇 （五）</p>

<p>Linux shell 脚本编程-基础篇 （六）</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>参考：</p>

<p>《Linux 命令行与 shell 脚本编程大全》 第 3 版 —— 2016.8（美）Richard Blum Cristine Bresnahan</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>