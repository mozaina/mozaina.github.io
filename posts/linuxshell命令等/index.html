<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linuxshell命令等 | 开发者问答集锦</title>
    <meta property="og:title" content="linuxshell命令等 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linuxshell命令等">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E5%91%BD%E4%BB%A4%E7%AD%89/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linuxshell命令等</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <pre><code>Linux命令【注意:建议用UltraEdit打开】


一.文件处理命令
  1.命令格式与目录处理命令
    ls –a【查看隐藏文件】
    ls –l【查看文件信息长格式显示】
    ls –d【查看指定目录的详细信息】
    ls –h【显示容量大小】
    ls –i【查看任何文件的I 节点】
    ll 文件名【查看一个文件的详细信息】
  2.目录处理命令
    mkdir –p【递归创建目录】
    cd【切换指定目录】
    pwd【显示当前目录】
    rmdir【删除空目录】
    cp【复制文件到某个目录下】
    cp –r【复制目录】
    cp –p【保留文件属性】
    mv【剪切文件、改名】
    rm【删除文件】
    rm –r【删除目录】
    rm –f【强制执行】
  3.文件处理命令
    touch【创建空文件】
    cat【查看文件内容】
    cat –n【显示行号】
    tac【显示文件内容(反向列示)】
    more【分页显示文件内容(空格或f[翻页], Enter[换行], q或Q[退出])】
    less【分页显示文件内容(可向上翻页),填写/可搜索关键词,n等于next,PageUp和PageDown】
    head【显示文件前面几行】
    head -n【指定行数,head –n 20 /etc/services】
    tail【显示文件后面几行】
    tail –n【指定行数】
    tail –f【动态显示文件末尾内容】
  4.链接命令
    ln【生成链接文件,类似拷贝,可以同步更新】
    ln –s【创建软链接，相当于快捷方式】

二. 权限管理命令
  1.权限管理命令
    chmod【改变文件或目录权限,u=所有者;g=所有组;o=其他人;a=全部,[{ugoa}{+-=}{rwx}],chmod u+x,o-r或640 文件名,r—4;w—2;x—1,rwx—7(4+2+1)】
    chmod –R【递归修改,子目录的权限也修改】
  2.其他权限管理命令
    chown【改变文件或目录的所有者,chown 用户 文件或目录】
    chgrp【改变文件或目录的所属组】
    umask【显示,设置文件的缺省权限】

三. 文件搜索命令
  1.文件搜索命令
    find【文件搜索,find 搜索范围 匹配条件】
    find 搜索范围 -name或-iname(不区分大小写) 匹配条件【根据文件名称搜索,匹配条件(abcd)=*bc*=ab??，*=匹配任意字符，?=匹配单个字符】
    find 搜索范围 -size +n/-n/n(n代表文件的大小)【根据文件的大小搜索】
    find 搜索范围 -size +163840 -a/-o -size -204800【查找(-a=大于80M小于100M的文件,-o=两个条件满足一个即可)】
    find 搜索范围 -user 用户名【根据用户名搜索文件，搜索范围=/home】
    find 搜索范围 -group 所属组名【根据所属组名搜索文件】
    find 搜索范围 -cmin/-amin/-mmin -5【查找5分钟内被修改过(-cmin=文件属性,-amin=访问时间,-mmin=文件内容)的文件】
    find 搜索范围 -type f/d/l【根据文件类型查找,f=文件，d=目录，l=软链接文件】
    find 搜索范围 -inum n【根据i节点查找,n=i节点数】
    以上搜索结果命令加(find /tmp -name *aaaa*) -exec/-ok 命令(ls -l[显示详细信息]) {} \;【对搜索结果执行命令操作】
    2.其他搜索命令
        locate -i 文件名【在文件资料库中查找文件,-i=不区分大小写】
        updatedb【更新文件资料库，tmp目录不在更新范围内】
        which 命令(ls)【搜索命令所在目录及别名信息】
        whereis 命令(ls)【搜索命令所在目录及帮助文档路径】
        grep -i/-v mysql /root/install.log【在文件中搜索字符匹配的行并输出,-i=不区分大小写，-v=排除指定字串(^#=排除#带头的行)】

四. 帮助命令
    man 命令或配置文件【获取帮助信息】
    info 命令【获取帮助信息,显示和man不同】
    whatis 命令【获取该命令的简介信息】
    apropos 配置文件名称【只查看配置文件的信息】
    命令 --help【获取该命令的选项信息】
    help 内置命令【查看Shell内置命令的帮助信息】

五. 用户管理命令
    useradd 用户名【添加新用户】
    passwd 用户名【设置用户密码】
    who【查看登录用户信息，tty本地登录,pts远程终端】
    w【查看登录用户的详细信息,全】

六. 压缩解压命令
    gzip 文件【压缩文件,压缩后的格式:.gz】
    gunzip 文件【解压.gz的压缩文件】
    tar -zcf temp.tar.gz temp【打包目录,-c:打包,-v:显示详细信息,-f:指定文件名,-z:打包同时压缩,temp:文件名】
    tar -zxf temp.tar.gz【解压目录,-x:解包,-v:显示详细信息,-f:指定文件名,-z:解包同时解压,temp:文件名】
    zip -r temp.zip temp【压缩问价或目录,-r:压缩目录,temp:文件名】
    unzip temp【解压.zip的压缩文件,temp:文件名或目录】
    bzip2 -k temp【压缩文件,-k:产生压缩文件后保留原文件，temp:文件名】
    bunzip2 -k temp【解压文件,-k:解压缩后保留原文件,temp:文件名】
    tar -cjf temp.tar.bz2 temp【压缩】
    tar -xjf temp.tar.bz2【解压】

七. 网络命令
    write 用户名【给在线用户发信息,以Ctrl+D保存结束】
    wall 信息【发广播信息】
    ping -c 4 IP地址【测试网络连通性,-c:指定发送次数为4次】
    ifconfig eth0 192.168.0.169【查看和设置网卡信息】
    mail 用户名【查看发送电子邮件，以Ctrl+D保存结束,help查看信息】
    last【列出目前与过去登入系统的用户信息】
    lastlog -u 502【检查某特定用户上次登录的时间】
    traceroute 网址【显示数据包到主机间的路径 IP等等】
    netstat -t/-u/-l/-r/-n【显示网络相关信息,-t:TCP协议,-u:UDP协议,-l:监听,-r:路由,-n:显示IP地址和端口号】
    netstat -tlun【查看本机监听的端口】
    netstat -an【查看本机所有的网络】
    netstat -rn【查看本机路由表】
    mount【挂载命令---详细找百度吧】
    mount /dev/sr0 /mnt/cdrom/【挂载光盘】
    umount /dev/sr0【卸载挂载点】

八.关机重启命令
    shutdown -h now【现在关机,-h:关机,now:现在】
    shutdown -h 20:30【定时关机,-h:关机】
    shutdown -r now【现在重启,-r:重启,now:现在】
    shutdown -r 20:30【定时重启,-r:重启】
    shutdown -c【取消前一个定时关机命令】
    init 0:关机/1:关机/2:不完全多用户/不含NFS服务/3:完全多用户/4:未分配/5:图形界面/6:重启【系统运行级别】
    cat /etc/inittab【修改系统默认运行级别】
    runlevel【查询系统运行级别,默认是N 3,N:代表上一次的系统级别】
    logout【退出登录命令——注意一定记得退出登录】


九.文本编辑器常用命令

    1).vim常用操作
        vim 文件名【进入或新建--进入命令模式】
        i/a/o【进入插入模式,a:在光标所在字符后插入,A:在光标所在行尾插入,i:在光标所在字符前插入,I:在光标所在行行首插入,o:在光标下插入新行,O:在光标上插入新行】

        :set nu【添加行号】
        :set nonu【取消行号】
        gg【到第一行】
        G【到最后一行】
        nG【到第n行】
        :n【到第n行--------推荐】
        $【移至行尾】
        0【移至行首】

        x【删除光标所在处字符-----------推荐】
        nx【删除光标所在处后n个字符】
        dd【删除光标所在行,ndd删除n行--------推荐】
        dG【删除光标所在行到文件末尾内容】
        D【删除光标所在处到行尾内容】
        :n,nd【删除指定范围的行】

        yy【复制当前行------------推荐】
        nyy【复制当前行一下n行】
        dd【剪切当前行】
        ndd【剪切当前行以下n行】
        p/P【粘贴在当前光标所在行下(p)或行上(P)--------推荐】

        r【取代光标所在处字符】
        R【从光标所在处开始替换字符,按ESC结束】
        u【取消上一步操作,撤销----------推荐】

        /string【搜索指定字符串,string:字符串,n:搜索指定字符串的下一个出现位置】
        :set ic【搜索时忽略大小写】
        :set noic【取消搜索时忽略大小写】
        :%s/old/new/g【全文替换指定字符串,冒号指全文替换,%s:全文搜索,old:要替换的字符串,new:替换的新的字符串,g:不询问确认】
        :n,ns/old/new/c【在一定范围内替换指定字符串,(n,ns:起始行,终止行s),c:询问确认】

        :w【保存修改------推荐】
        :w /tmp/temp.txt【另存为指定文件】
        :wq【保存退出---------推荐】
        :q!【不保存退出】
        ZZ【快捷键,保存修改并退出】
        :wq!【保存修改并退出(文件所有者及root可使用)】

        按ESC【退出模式,进入命令模式】

    2).vim使用技巧
        :r /tmp/temp.txt(被导入的文件)【把temp.txt的内容导入到光标处】
        :r !date(命令)【可以在不退出vim的情况下,执行相应的操作命令,date:系统时间命令】
        :map ^P I#【定义快捷键:map,^P:按ctrl+v+p(快捷键按Ctrl+p),注释该行】
        :map ^B 0x【定义快捷键:map,^B:按ctrl+v+b(快捷键按Ctrl+b),取消注释该行】
        :1,4s/^/#//g【多行注释,把1到4行的行首添加#】
        :1,4s/^#//g【取消多行注释,把1到4行的行首的#去掉】
        :1,4s/^/\/\//g【多行注释,把1到4行的行首添加//】
        :1,4s/^\/\//g【取消多行注释,把1到4行的行首的//去掉】
        :ab mymail www.xxx@163.com【替换,在编辑时填写mymail回车时就会被替换成邮箱】

        #快捷键或编辑模式命令 在重启后会失效,必须在/root/.vimrc或/home/***/.vimrc目录下才会被永久保存---注意填写时不用填写:了

========================================================================================================

一、软件包管理简介
  1.软件包分类
    源码包---脚本安装包
    二进制包(RPM包、系统默认包)---常见

二、RPM包管理-rpm命令管理
  01.RPM包命令原则
    http-2.2.15-15.e16.centos.1.i686.rpm
    httpd------------软件包名
    2.2.15-----------软件版本
    15---------------软件发布的次数
    e16.centos-------适合的Linux平台
    i686-------------适合的硬件平台
    rpm--------------rpm包扩展名
  02.RPM包依赖性
    树形依赖:a-&gt;b-&gt;c
    环形依赖:a-&gt;b-&gt;c-&gt;a
    模块依赖:模块依赖查询网站www.rpmfind.net
  03.包全名与包名
    包全名:操作的包是没有安装的软件包时,使用包全名,而且要注意路径
    包名:操作已经安装的软件包时,使用包名,是搜索/var/lib/rpm/中的数据库
  04.RPM安装
    rpm -ivh 包全名【-i:安装,-v:显示详细信息,-h:显示进度,--nodeps:不检测依赖性】
  05.RPM包升级
    rpm -Uvh 包全名【-U:升级】
  06.卸载
    rpm -e 包名【-e:卸载,--nodeps:不检测依赖性】
  07.查询是否安装
    rpm -q 包名【查询包是否安装,-q:查询】
    rpm -q | grep 包名【查询包是否安装,-q:查询,grep:管道符--查询与包名相关的包】
    rpm -qa【查询所有已经安装的RPM包,-a:所有】
  08.查询软件包详细信息
    rpm -qi 包名【-i:查询软件信息,-p:查询未安装包信息(包全名)】
  09.查询包中文件安装位置
    rpm -ql 包名【-l:列表,-p:查询未安装包信息(包全名)】
  10.查询系统文件属于哪个RPM包
    rpm -qf 系统文件名【-f:查询系统文件属于哪个软件包】
  11.查询软件包的依赖性
    rpm -qR 包名【-R:查询软件包的依赖性,-p:查询未安装包信息】
  12.RPM包校验
    rpm -V 已安装的包名【-V:校验指定RPM包中的文件】
    1).验证内容中的8个信息的具体内容如下
        S:文件大小是否改变
        M:文件类型或文件的权限(rwx)是否被改变
        5:文件MD5校验和是否改变(可以看成文件内容是否改变)
        D:设备的中,从代码是否改变
        L:文件路径是否改变
        U:文件属主(所有者)是否改变
        G:文件的数组是否改变
        T:文件的修改时间是否改变
      2).文件类型
        c:配置文件
        d:普通文件
        g:&quot;鬼&quot;文件,很少见,就是该文件不应该被这个RPM包包含
        l:授权文件
        r:描述文件
  13.RPM包中文件提取
    rpm2cpio 包全名 | \ cpio -idv .文件绝对路径【rpm2cpio:将rpm包转换为cpio格式的命令,cpio:是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件】
    cpio 选项 RPM包安装的服务可以使用系统服务管理命令(service)来管理,例如RPM包安装的apache的启动方法是:
                /etc/rc.d/init.d/httpd start或service httpd start【开启服务】
                service httpd stop【停止服务】
            &gt;而源码包安装的服务则不能被服务管理命令管理,因为没有安装到默认路径中,所以只能用绝对路径进行服务的管理,如:
                /usr/local/apache2/bin/apachectl start
    2.源码包安装过程
        1).安装准备
            安装C语言编译器
            下载源码包http://mirror.bit.edu.cn/apache/httpd/
        2).安装注意事项
            源代码保存位置:/usr/local/src/
            软件安装位置:/usr/local/
            如何确定安装过程报错:
                安装过程停止
                并出现error、warning或no的提示
        3).源码包安装过程
            下载源码包
            解压缩下载的源码包
            进入解压缩目录
                (./configure)软件配置与检测
                定义需要的功能选项
                检测系统环境是否符合安装要求(检测系统是否安装gcc[c语言编译器]等等)
                把定义好的功能选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑

                ./configure --prefix=/usr/local/apache2
                make【编译】
                make clean【如果以上两个步骤有错误,就执行清空临时文件命令,没有错误就不用执行】
                make install【编译安装】
        4).源码包的卸载
            不需要卸载命令,直接删除安装目录即可.不会遗留任何垃圾文件

五、脚本安装包与软件包选择
    1.脚本安装包
        #脚本安装包并不是独立的软件包类型,常见安装的是源码包
        #是认为把安装过程写成了自动安装的脚本,只要执行脚本,定义简单的参数,就可以完成安装
        #非常类似于Windows下软件的安装方式
    2.Webmin的作用
        #Webmin是一个基于Web的Linux系统管理界面.您就可以通过图形化的方式设置用户帐号、apache、DNS、文件共享等服务.
    3.Webmin安装过程
        #下载软件http://sourceforge.net/projects/webadmin/files/webmin/
        #解压缩,并进入加压缩目录
        #执行安装脚本(./setup.sh)
        #卸载(/etc/webmin/uninstall.sh)
        #安装完了注意先把防火墙关了(service iptables stop),不然外界不能访问

六、用户和用户组管理
    1.用户配置文件
        1).用户信息文件/etc/passwd
            ①.用户管理简介
                ◆所以越是对服务器安全性要求高的服务器,越是要建立合理的用户权限等级制度和服务器操作规范
                ◆在Linux中主要是通过用户配置文件来查看和修改用户信息
            ②./etc/passwd
                第一字段:用户名称
                第二字段:密码标志
                第三字段:UID(用户ID)--0:超级用户,1-499:系统用户(伪用户),500-65535:普通用户
                第四字段:GID(用户初始组ID)
                第五字段:用户说明
                第六字段:家目录--普通用户:/home/用户名/,超级用户:/root/
                第七字段:登录之后的Shell
            ③.初始组和附加组
                初始组:就是指用户一登录就立刻拥有这个用户组的相关权限,每个用户的初始组只能有一个,一般就是和这个用户的用户名相同的组名作为这个用户的初始组.
                附加组:指用户可以加入多个其他的用户组,并拥有这些组的权限,附加组可以有多个.
            ④.Shell是什么
                Shell就是Linux的命令解释器
                在/etc/passwd当中,除了标准Shell是/bin/bash之外,还可以写如/sbin/nologin
        2).影子文件/etc/shadow
            1.字段的解释
                第一字段:用户名
                第二字段:加密密码
                    加密算法升级为SHA512散列加密算法
                    如果密码位是&quot;!!&quot;或&quot;*&quot;代表没有密码,不能登录
                第三字段:密码最后一次修改日期
                    使用1970年1月1日作为标准时间,每过一天时间戳加1
                第四字段:两次密码的修改间隔时间(和第三字段相比)
                第五字段:密码有效期(和第三字段相比)
                第六字段:密码修改到期前的警告天数(和第五字段相比)
                第七字段:密码过期后的宽限天数(和第五字段相比)
                    0:代表密码过期后立即生效
                    -1:则代表密码永久不会生效
                第八字段:帐号失效时间
                    要用时间戳表示
                第九字段:保留字段
            2.时间戳换算
                把时间戳换算为如期
                    date -d &quot;1970-01-01 16066 days&quot;
                把日期换算为时间戳
                    echo $(($(date --date=&quot;2015/8/31&quot; +%s)/86400+1))
        3).组信息文件/etc/gtoup和组密码文件/etc/gshadow
            1.组信息文件/etc/group
                第一字段:组名
                第二字段:组密码标志
                第三字段:GID
                第四字段:组中附加用户
            2.组密码文件/etc/gshadow
                第一字段:组名
                第二字段:组密码
                第三字段:组管理员用户名
                第四字段:组中附加用户
    2.用户管理相关文件
        1).用户的家目录
            普通用户:/home/用户名/,所有者和所属组都是此用户,权限是700
            超级用户:/root/,所有者和所属组都是root用户,权限是500
        2).用户的邮箱
            /var/spool/mail/用户名/
        3).用户模板目录
            /etc/skel/
    3.用户管理命令
        1).用户添加命令useradd
            ①.useradd命令格式
                -u UID:手工指定用户的UID号
                -d 家目录:手工指定用户的家目录
                -c 用户说明:手工指定用户的说明
                -g 组名:手工指定用户的初始组
                -G 组名:指定用户的附加组
                -s shell:手工指定用户的登录Shell,默认是/bin/bash
        2).修改用户密码passwd
            ①.passwd命令格式
                -S:查询用户密码的密码状态.仅root用户可用
                -l:暂时锁定用户.仅root用户可用
                -u:解锁用户.仅用户可用
                --stdin:可以通过管道符输出的数据作为用户的密码
        3).修改用户信息usermod,修改用户密码状态chage
            ①.修改用户信息usermod
                -u UID:修改用户的UID号
                -c 用户说明:修改用户的说明信息
                -G 组名:修改用户的附加组
                -L:临时锁定用户
                -U:解锁用户锁定
            ②.修改用户密码状态chage
                -l:列出用户的详细密码状态
                -d 日期:修改密码最后一次更改日期(shadow3字段)
                -m 天数:两次密码修改间隔(4字段)
                -M 天数:密码有效期(5字段)
                -W 天数:密码过期前警告天数(6字段)
                -I 天数:密码过后宽限天数(7字段)
                -E 日期:帐号失效时间(8字段)
        4).删除用户userdel,用户切换命令su
            ①.删除用户userdel
                -r:删除用户的同时删除用户家目录
            ②.查看用户ID
                id 用户名
            ③.切换用户身份su(su - 用户名)
                -:选项只使用&quot;-&quot;代表连带用户的环境变量一起切换,[&quot;-&quot;必须加上]
                -c 命令:仅执行一次命令,而不切换用户身份
    4.用户组管理命令
        1).添加用户组
            groupadd 组名【-g GID:指定组ID】
        2).修改用户组
            groupmod 组名【-g GID:修改组ID,-n 新组名:修改组名】
        3).删除用户组
            groupdel 组名
        4).把用户添加入组或从组中删除
            gpasswd 选项 组名【-a 用户名:把用户加入组,-d 用户名:把用户从组中删除】

七、权限管理
    1.ACL权限
        1).ACL权限简介与开启
            ①.
            ②.查看分区ACL权限是否开启
                dumpe2fs -h /dev/sda3【dumpe2fs命令是查询指定分区详细文件系统信息的命令,-h:仅显示超级块中信息,而不显示磁盘块组的详细信息】
            ③.临时开启分区ACL权限
                mount -o remount,acl /【重新挂载根分区,并挂载加入acl权限】
            ④.永久开启分区ACL权限
                vim /etc/fstab【进入编辑模式,UUID=asdqq-qweqwe-qweqwe-qweqew-qweqwe2131123 / ext4 defaults,acl 1 1(加入acl)】
                mount -o remount /【重新挂载文件系统,使修改生效】
        2).查看与设定ACL权限
            ①.查看ACl命令
                getfacle 文件名【查看acl权限】
            ②.设定ACL权限的命令(setfacl 选项 文件名)
                -m:设定ACl权限(u:用户名:权限)
                -x:删除指定的ACl权限
                -b:删除所有的ACl权限
                -d:设定默认ACL权限
                -k:删除默认ACL权限
                -R:递归设定ACL权限
        3).最大有效权限与删除ACL权限
            ①.最大有效权限mask
                mask是用来指定最大有效权限的.如果我给用户赋予了ACL权限,是需要和mask的权限&quot;相与&quot;才能得到用户的真正权限
                setfacl -m m:rx 文件名【修改最大有效权限,设定mask权限为r-x.使用&quot;m:权限&quot;格式】
            ②.删除ACL权限
                setfacl -x u:用户名 文件名【删除指定用户的ACl权限】
                setfacl -x g:组名 文件名【删除指定用户组的ACl权限】
                setfacl -b 文件名【会删除文件的所有的ACL权限】
        4).默认ACL权限和递归ACL权限
            ①.递归ACL权限
                递归是父目录在设定ACL权限时,所有的子文件和子目录也会拥有相同的ACl权限
                setfacl -m u:用户名:权限 -R 文件名
            ②.默认ACL权限
                默认ACl权限的作用是如果给父目录设定了默认ACl权限,那么父目录中所有新建的子文件都会继承父目录的ACL权限.
                setfacl -m d:u:用户名:权限 文件名
    2.文件特殊权限
        1).SetUID
            ①.SetUID的功能
                &gt;只有可以执行的二进制程序才能设定SUID权限
                &gt;命令执行者要对该程序拥有x(执行)权限
                &gt;命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)
                &gt;SetUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效.
                &gt;passwd命令拥有SetUID权限,所以普通可以修改自己的密码[ll /usr/bin/passwd]
                &gt;cat命令没有SetUID权限,所以普通用户不能查看/etc/shadow文件[ll /bin/cat]
            ②.设定SetUID的方法
                &gt;4代表SUID[chmod 4755 文件名,chmod u+s 文件名]
            ③.取消SetUID的方法
                &gt;chmod 755 文件名
                &gt;chmod u-s 文件名
            ④.危险的SetUID
                &gt;关键目录应严格控制写权限.比如&quot;/&quot;、&quot;/usr&quot;等
                &gt;用户的密码设置要严格遵守密码的三原则
                &gt;对系统中默认应该具有SetUID权限的文件做一列表,定时检查有没有这之外的文件被设置了SetUID权限.
        2).SetGID
            ①.SetGID针对文件的作用
                &gt;只有可执行的二进制程序才能设置SGID权限
                &gt;命令执行者要对该程序拥有x(执行)权限
                &gt;命令执行在执行程序的时候,组身份升级为该程序文件的属组.
                &gt;SetGID权限同样只在该程序执行过程中有效,也就是说组身份改变只在程序执行过程中有效.
                &gt;/usr/bin/locate是可执行二进制程序,可以赋予SGID.
                &gt;执行用户lamp对/usr/bin/locate命令拥有执行权限.
                &gt;执行/usr/bin/locate命令时,组身份会升级为slocate组,而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限,所以普通用户可以使用locate命令,查询mlocate.db数据库.
                &gt;命令结束,lamp用户的组身份返回为lamp组.
            ②.SetGID针对目录的作用
                &gt;普通用户必须对此目录拥有r和x权限,才能进入此目录.
                &gt;普通用户在此目录中的有效组会变成此目录的属组.
                &gt;若普通用户对此目录拥有w权限时,新建的文件默认属组是这个目录的属组.
            ③.设定SetGID
                &gt;2代表SGID[chmod 2755 文件名,chmod g+s 文件名]
            ④.取消SetGID
                &gt;chmod 755 文件名
                &gt;chmod g-s 文件名
        3).Sticky BIT
            ①.SBIT粘着位作用
                &gt;粘着位目录只针对目录有效
                &gt;普通用户对该目录拥有w和x权限,即普通用户可以在此目录拥有写入权限.
                &gt;如果没有粘着位,因为普通用户拥有w权限,所以可以删除此目录下所有文件,包括其他用户建立的文件.一但赋予了粘着位,除了root可以删除所有文件,普通用户就算拥有w权限,也只能删除自己建立的文件,但是不能删除其他用户建立的文件.
            ②.设置与取消粘着位
                &gt;设置粘着位
                    chmod 1775 目录名
                    chmod o+t 目录名
                &gt;取消粘着位
                    chmod 777 目录名
                    chmod o-t 目录名
    3.文件系统属性chattr权限
        1).chattr命令格式
            chattr [+-=][选项] 文件或目录名【+:增加权限,-:删除权限,=:等于某权限】
                选项:&gt;i:如果对文件设置i属性,那么不允许对文件进行删除、改名,也不能添加和修改数据;如果对目录设置i属性,那么只能修改目录下文件的数据,但不允许建立和删除文件.
                         &gt;a:如果对文件设置a属性,那么只能在文件中增加数据,但是不能删除也不能修改数据;如果对目录设置a属性,那么只允许在目录中建立和修改文件,但是不允许删除.
        2).查看文件系统属性
            lsattr 选项 文件名【-a:显示所有文件和目录,-d:若目标是目录,仅列出目录本身的属性,而不是子文件的】
    4.系统命令sudo权限
        1).sudo权限
            &gt;root把本来只能超级用户执行的命令赋予普通用户执行.
            &gt;sudo的操作对象是系统命令.
        2).sudo使用
            &gt;visudo【实际修改的是/etc/sudoers文件】
                root ALL=(ALL) ALL
                #用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
                %whell ALL=(ALL) ALL
                #%组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
        3).授权sc用户可以重启服务器
            &gt;visudo【进入vim编辑模式】
                sc ALL=/sbin/shutdown -r now【例】
        4).普通用户执行sudo赋予的命令(不建议给普通用户授权vim这样的工具权限)
            sudo -l【查看可用的sudo命令】
            sudo /sbin/shutdown -r now【普通用户执行sudo赋予的命令】

八、文件系统管理
    1.回顾分区和文件系统
        1).分区类型
            &gt;主分区:总共最多只能分四个
            &gt;扩展分区:只能有一个,也算做主分区的一种,也就是说主分区加扩展分区最多有四个.但是扩展分区不能存储数据和格式化,必须再划分成逻辑分区才能使用.
            &gt;逻辑分区:逻辑分区是在扩展分区中划分的,如果是IDE硬盘,Linux最多支持59个逻辑分区,如果是SCSI硬盘Linux最多支持11个逻辑分区.
        2).文件系统
            &gt;ext2:是ext文件系统的升级版本,RedHatLinux7.2版本以前的系统默认都是ext2文件系统.1993年发布,最大支持16TB的分区和最大2TB的文件.
            &gt;ext3:ext3文件系统是ext2文件系统的升级版本,最大的区别就是带日志功能,以在系统突然停止时提高文件系统的可靠性.支持最大16TB的分区和最大2TB的文件.
            &gt;ext4:它是ext3文件系统的升级版.ext4在性能、伸缩性和可靠性方面进行了大量改进.ext4的变化可以说是翻天覆地的,比如向下兼容ext3、最大1EB文件系统和16TB文件、无线数量子目录、extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等.
    2.文件系统常用命令
        1).df命令、du命令、fsck命令和dump2fs命令
            ①.文件系统查看命令df[df 选项 挂载点]
                -a:显示所有的文件系统信息,包括特殊文件系统,如/proc、/sysfs
                -h:使用习惯单位显示容量,如KB,MB或GB等.
                -T:显示文件系统类型
                -m:以MB为单位显示容量
                -k:以KB为单位显示容量.默认就是以KB为单位.
            ②.统计目录或文件大小[du 选项 目录或文件名]
                -a:显示每个子文件的磁盘占用量.默认只统计子目录的磁盘占用量.
                -h:使用习惯单位显示磁盘占用量,如KB,MB或GB等.
                -s:统计总占用量,而不列出子目录和子文件的占用量.
            ③.du命令和df命令的区别
                &gt;df命令是从文件系统考虑的,不光要考虑文件占用的空间,还要统计被命令或程序占用的空间(最常见的就是文件已经删除,但是程序并没有释放空间)
                &gt;du命令是面向文件的,只会计算文件或目录占用的空间.
            ④.文件系统修复命令fsck[fsck 选项 分区设备文件名]
                -a:不用显示用户提示,自动修复文件系统.
                -y:自动修复.和-a作用一致,不过有些文件系统只支持-y.
            ⑤.显示磁盘状态命令dumpe2fs[dumpe2fs 分区设备文件名]
        2).挂载命令
            ①.查询与自动挂载
                &gt;mount -l【查询系统中已经挂载的设备,-l:会显示卷标名称】
                &gt;mount -a【依据配置文件/etc/fstab的内容,自动挂载】
            ②.挂载命令格式
                &gt;mount [选项] 设备文件名 挂载点【挂载命令】
                -t 文件系统:加入文件系统类型来指定挂载的类型,可以ext3、ext4、iso9660等文件系统.
                -L 卷标名:挂载指定卷标的分区,而不是安装设备文件名挂载.
                -o 特殊选项:可以指定挂载的额外选项.
                &gt;atime/noatime:更新访问时间/不更新访问时间.访问分区文件时,是否更新文件的访问时间,默认为更新.
                &gt;async/sync:异步/同步,默认为异步.
                &gt;auto/noauto:自动/手动,mount -a命令执行时,是否会自动安装/etc/fstab文件内容挂载,默认为自动.
                &gt;defaults:定义默认值,相当于rw,suid,dev,exec,auto,nouser,async这七个选项.
                &gt;exec/noexec:[常用]执行/不执行,设定是否允许在文件系统中执行可执行文件,默认是exec允许.
                &gt;remount:[常用]重新挂载已经挂载的文件系统,一般用于指定修改特殊权限.
                &gt;rw/ro:读写/只读,文件系统挂载时,是否具有读写权限,默认是rw.
                &gt;suid/nosuid:具有/不具有SUID权限,设定文件系统是否具有SUID和SGID的权限,默认是具有.
                &gt;user/nouser:允许/不允许普通用户挂载,设定文件系统是否允许普通用户挂载,默认是不允许,只有root可以挂载分区.
                &gt;usrquota:写入代表文件系统支持用户磁盘配额,默认不支持.
                &gt;grpquota:写入代表文件系统支持组磁盘配额,默认不支持.
        3).挂载光盘与U盘
            ①.挂载光盘
                &gt;mkdir /mnt/cdrom/【建立挂载点】
                &gt;mount -t iso9660 /dev/cdrom /mnt/cdrom/或mount /dev/sr0 /mnt/cdrom/【挂载光盘】
            ②.卸载命令[umount 设备文件名或挂载点]
                umount /mnt/cdrom/
            ③.挂载U盘
                &gt;fdisk -l【查看U盘设备文件名】
                &gt;mount -t vfat /dev/sdb1 /mnt/usb/【注意:Linux默认不支持NTFS文件系统】
            ④.卸载U盘
                &gt;umount /mnt/usb/
        4).支持NTFS文件系统
            ①.下载NTFS-3G插件
                http://www.tuxera.com/community/open-source-ntfs-3g/
            ②.安装NTFS-3G
                tar -zxf ntfs-3g_ntfsprogs-2015.3.14.tgz【解压】
                cd ntfs-3g_ntfsprogs-2015.3.14【进入解压目录】
                ./configure【编译器准备,没有指定安装目录,安装到默认位置中】
                make【编译】
                make install【编译安装】
            ③.使用
                mount -t ntfs-3g 分区设备文件名 挂载点【mount -t ntfs-3g /dev/sdb1 /mnt/usb/】
            ④.卸载NTFS移动硬盘
                &gt;umount /mnt/usb/
    3.fdisk分区
        1).fdisk命令分区过程
            ①.添加新硬盘
            ②.查看新硬盘
                fdisk -l
            ③.使用fdisk命令分区
                fdisk /dev/sdb
                &gt;--------fdisk交互指令说明--------
                &gt;a:设置可引导标记
                &gt;b:编辑bsd磁盘标签
                &gt;c:设置DOS操作系统兼容标记
                &gt;d:删除一个分区
                &gt;l:显示已知的文件系统类型.82为Linux swap分区,83为Linux分区
                &gt;m:显示帮助菜单
                &gt;n:新建分区
                &gt;o:建立空白DOS分区表
                &gt;p:显示分区列表
                &gt;q:不保存退出
                &gt;s:新建空白SUN磁盘标签
                &gt;t:改变一个分区的系统ID
                &gt;u:改变显示记录单位
                &gt;v:验证分区表
                &gt;w:保存退出
                &gt;x:附加功能(仅专家)
            ④.重新读取分区表信息
                partprobe
            ⑤.格式化分区
                mkfs -t ext4 /dev/sdb1
        2).分区自动挂载与fstab文件修复
            ①./etc/fstab文件[/dev/sdb1 /disk1 ext4 defaults 1 2]
                &gt;第一字段:分区设备文件名或UUID(硬盘通用唯一识别码)
                &gt;第二字段:挂载点
                &gt;第三字段:文件系统名称
                &gt;第四字段:挂载参数
                &gt;第五字段:指定分区是否被dump备份,0代表不备份,1代表每天备份,2代表不定期备份
                &gt;第六字段:指定分区是否被fsck检测,0代表不检测,其他数字代表检测的优先级,那么当然1的优先级比2高
            ②.mount -a【依据配置文件/etc/fstab的内容,自动挂载】
            ③./etc/fstab文件修复
                mount -o remount,rw /
    4.分配swap分区
        1).free命令
            free【查看内存与swap分区使用状况】
            &gt;cached(缓存):是指把读取出来的数据保存在内存当中,当再次读取时,不用读取硬盘而直接从内存当中读取,加速了数据的读取过程.
            &gt;buffer(缓存):是指在写入数据时,先把分散的写入操作保存到内存当中,当达到一定程度再集中写入硬盘,减少了磁盘碎片和硬盘的反复寻道,加速了数据的写入过程
        2).新建swap分区
            fdisk /dev/sdb【别忘记把分区ID改为82】
        3).格式化
            mkswap /dev/sdb6
        4).加入swap分区
            swapon /dev/sdb6【加入swap分区】
            swapoff /dev/sdb6【取消swap分区】
        5).swap分区开机自动挂载
            vim /etc/fstab【进入vim命令模式】
                /dev/sdb6   swap    swap defaults 0 0

十、Shell基础
    1.Shell概述
        1).shell是什么
            &gt;shell是一个命令行解释器,它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用shell来启动、挂起、停止甚至是编写一些程序.
            &gt;shell还是一个功能相当强大的编程语言,易编写,易调试,灵活性较强.shell是解释执行的脚本语言,在shell中可以直接调用Linux系统命令.
        2).shell的分类
            &gt;bourne shell:从1979起Unix就开始使用bourne shell,bourne shell的主文件名为sh.
            &gt;bash:bash与sh兼容,现在使用的Linux就是使用bash作为用户的基本shell
        3).Linux支持的Shell
            cat /etc/shells
    2.Shell脚本的执行方式
        1).echo输出命令[echo 选项 输出内容]
            -e:支持反斜线控制的字符转换[echo -e &quot;abc\n&quot;]
            ------转义字符--------
            \\:输出/本身
            \a:输出警告声
            \b:退格键,也就是向左删除键
            \c:取消输出行末的换行符.和&quot;-n&quot;选项一致
            \e:ESCAPE键
            \f:换页符
            \n:换行符
            \r:回车符
            \t:制表符,也就是Tab键
            \v:垂直制表符
            \0nnn:按照八进制ASCII码表输出字符.其中0为数字零,nnn是三位八进制数
            \xhh:按照十六进制ASCII码输出字符.其中hh是两位十六进制数
        2).第一个脚本
            vim /tmp/helloworld.sh
            #!/bin/bash【shell脚本必须填写这个标题】
        3).脚本执行
            &gt;赋予执行权限,直接运行
                chmod 755 /tmp/helloworld.sh【分配权限】
                /tmp/helloworld.sh【执行】
            &gt;通过Bash调用执行脚本
                bash /tmp/helloworld.sh【执行】
    3.bash的基本功能
        1).历史命令与命令补全
            ①.历史命令
                history 选项 历史命令保存文件
                -c:清空历史命令
                -w:把缓存中的历史命令写入历史命令保存文件
                &gt;.bash_history【家目录的常用命令保存文件】
                &gt;历史命令默认会保存1000条,可以在环境变量配置文件/etc/profile中进行修改
                &gt;历史命令的调用
                    /使用上、下箭头调用以前的历史命令
                    /使用&quot;!n&quot;重复执行第n条历史命令
                    /使用&quot;!!&quot;重复执行上一条命令
                    /使用&quot;!字串&quot;重复执行最后一条以该字串开头的命令
            ②.命令与文件补全
                &gt;在bash中,命令与文件补全是非常方便与常用的功能,我们只要在输入命令或文件时,按&quot;Tab&quot;键就会自动进行补全
        2).命令别名与常用快捷键
            ①.命令别名
                alias 别名='原命令'【设定命令别名】
                alias【查询命令别名】
                &gt;命令执行时顺序
                    1.第一顺位执行用绝对路径或相对路径执行的命令
                    2.第二顺位执行别名
                    3.第三顺位执行bash的内部命令
                    4.第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令
                &gt;让别名永久生效
                    vim /root/.bashrc
                &gt;删除别名
                    unalias 别名
            ②.bash常用快捷键
                ctrl+a:把光标移动到命令行开头.如果我们输入的命令过长,想要把光标移动到命令行开头时使用
                ctrl+e:把光标移动到命令行结尾
                ctrl+c:强制终止当前的命令
                ctrl+l:清屏,相当于clear命令
                ctrl+u:删除或剪切光标之前的命令.我输入了一行很长的命令,不用使用退格键一个一个字符的删除,使用这个快捷键会更加方便
                ctrl+k:删除或剪切光标之后的内容
                ctrl+y:粘贴ctr+u或ctrl+k剪切的内容
                ctrl+r:在历史命令中搜索,按下ctrl+r之后,就会出现搜索界面,只要输入搜索内容,就会从历史命令中搜索
                ctrl+d:退出当前终端
                ctrl+z:暂停,并放入后台.这个快捷键牵扯工作管理的内容,我们在系统管理章节详细介绍
                ctrl+s:暂停屏幕输出
                ctrl+q:恢复屏幕输出
        3).输入输出重定向
            ①.标准输入输出
                | 设备 | 设备文件名 | 文件描述符 | 类型      |
                | 键盘 | /dev/stdin|    0       |标准输入    |
                |显示器|/dev/sdtout|    1       |标准输出    |
                |显示器|/dev/sdterr|    2       |标准错误输出|
            ②.输出重定向
                -----------------------------------------------------------------------------------
             |       类型      |    符号     |      作用
             |------------------------------------------------------------------------------------
             |                 |   命令&gt;文件  |以覆盖的方式,把命令的正确输出输出到指定的文件或设备当中
             |  标准输出重定向  |-----------------------------------------------------------------
             |                 |   命令&gt;&gt;文件 |以追加的方式,把命令的正确输出输出到指定的文件或设备当中
                -------------------------------------------------------------------------------------
             |                 |  错误名2&gt;文件 |以覆盖的方式,把命令的错误输出输出到指定的文件或设备当中
             |标准错误输出重定向|-------------------------------------------------------------------
             |                 |错误命令2&gt;&gt;文件|以追加的方式,把命令的错误输出输出到指定的文件或设备当中
              -------------------------------------------------------------------------------------
              -------------------------------------------------------------------------------------
             |               |命令&gt;文件2&gt;&amp;1     |以覆盖的方式,把正确输出和错误输出都保存到同一个文件中
             |               |命令&gt;&gt;文件2&gt;&amp;1    | 以追加的方式,把正确输出和错误输出都保存到同一个文件中
             |正确输出和      |命令&amp;&gt;文件       | 以覆盖的方式,把正确输出和错误输出都保存到同一个文件中
             |错误输出同时保存|命令&amp;&gt;&gt;文件       |以追加的方式,把正确输出和错误输出都保存到同一个文件中
             |               |命令&gt;&gt;文件 2&gt;&gt;文件|把正确的输出追加到文件1中,把错误的输出追加到文件2中
              ------------------------------------------
            ③.输入重定向
                wc [选项] [文件名]【-c:统计字节数,-w:统计单词数,-l:统计行数】
                命令dd if=输入文件 of=输出文件 bs=字节数 count=个数
                    if:指定源文件或源设备
                    of:指定目标文件或目标设备
                    bs:指定一次输入/输出多少字节,即把这些字节看做一个数据块
                    count:指定输入/输出多少个数据块
            ②.管道符
                命令1 | 命令2【命令1的正确输出作为命令2的操作对象】
                &gt;grep [选项] &quot;搜索内容&quot;
                    -i:忽略大小写
                    -n:输出行号
                    -v:反向查找
                    --color=auto:搜索出的关键字用颜色显示
        5).通配符与其他特殊符号
            ①.通配符
                ?:匹配一个任意字符
                *:匹配0个或多个任意字符,也就是可以匹配任何内容
                []:匹配中括号中任意一个字符.例如:[abc]代表一定匹配一个字符,或者是a，或者是b，或者是c
                [-]:匹配中括号中任意一个字符,-代表一个范围.例如:[a-z]代表匹配一个小写字母
                [^]:逻辑非,表示匹配不是中括号内的一个字符.例如:[^0-9]代表匹配一个不是数字的字符
            ②.bash中其他特殊符号
                '':单引号,在单引号中所有的特殊符号,如&quot;$&quot;和&quot;`&quot;(反引号)都没有特殊含义.
                &quot;&quot;:双引号,在双引号中特殊符号都没有特殊含义,但是&quot;$&quot;、&quot;`&quot;和&quot;\&quot;是例外,拥有&quot;调用变量的值&quot;、&quot;引用命令&quot;和&quot;转义符&quot;的特殊含义
                ``:反引号,反引号括起来的内容是系统命令,在bash中会先执行它.和$()作用一样,不过推荐使用$()，因为反引号非常容易看错.
                $():和反引号作用一样,用来引用系统命令
                #:在shell脚本中,#开头的行代表注释.
                $:用于调用变量的值,如需要调用变量name的值时,需要用$name的方式得到变量的值.
                \:转义符,跟在\之后的特殊符号将失去特殊含义,变为普通字符.如\$将输出&quot;$&quot;符号,而不当做是变量引用.
    4.bash的变量
        1).用户自定义变量
            &gt;变量定义[name='hello world']
            &gt;变量叠加[name=&quot;$name&quot;123456]
            &gt;变量调用[echo $name]
            &gt;变量查看[set]
            &gt;变量删除[unset name]
        2).环境变量
            ①.环境变量是什么
                &gt;用户自定义变量只在当前的shell中生效,而环境变量会在当前shell和这个shell的所有子shell当中生效.如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有的shell中生效.
            ②.设置环境变量
                export 变量名=变量值【申明变量】
                env【查询变量】
                unset 变量名【删除变量】
            ③.系统常见环境变量
                &gt;PATH:系统查找命令的路径
                    echo $PATH /usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root:bin
                &gt;PATH:&quot;$PATH&quot;:/root/bin【PATH变量叠加】
                &gt;PS1定义系统提示符的变量【PS1='[\u@\h \w]\$ '】
                    \d:显示日期,格式为&quot;星期 月 日&quot;
                    \h:显示简写主机名.如默认主机名&quot;localhost&quot;
                    \t:显示24小时制时间,格式为&quot;HH:MM:SS&quot;
                    \T:显示12小时制时间,格式为&quot;HH:MM:SS&quot;
                    \A:显示24小时制时间,格式为&quot;HH:MM&quot;
                    \u:显示当前用户名
                    \w:显示当前所在目录的完整名称
                    \W:显示当前所在目录的最后一个目录
                    \#:执行的第几个命令
                    \$:提示符.如果是root用户会显示提示符为&quot;#&quot;,如果是普通用户会显示提示符为&quot;$&quot;
        3).位置参数变量
            $n:n为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}
            $*:这个变量代表命令行所有的参数,$*把所有的参数看成一个整体
            $@:这个变量也代表命令行中所有的参数,不过$@把每个参数区分对待
            $#:这个变量代表命令行中所有参数的个数
        4).预定义变量
            ①.预定义变量
                $?:最后一次执行的命令的返回状态.如果这个变量的值为0,证明上一个命令正确执行;如果这个变量的值为非0(具体是哪个数,由命令自己来决定),则证明上一个命令执行不正确了.【常用】
                $$:当前进程的进程号(PID)
                $!:后台运行的最后一个进程的进程号(PID)
            ②.接收键盘输入
                read [选项] [变量名]【read -s -p &quot;请输入动态口令: &quot; kouling echo &quot;您输入的口令是: $koulin&quot;】
                    -p &quot;提示信息&quot;:在等待read输入时,输出提示信息
                    -t 秒数:read命令会一直等待用户输入,使用此选项可以指定等待时间
                    -n 字符数:read命令只接受指定的字符数,就会执行
                    -s:隐藏输入的数据,适用于机密信息的输入
    5.bash的运算符
        1).数值运算与运算符
            ①.declare [+/-] [选项] 变量名【declare声明变量类型】
                    -:给变量设定类型属性
                    +:取消变量的类型属性
                    -i:将变量声明为整数型(integer)
                    -x:将变量声明为环境变量
                    -p:显示指定变量的被声明的类型
            ②.数值运算-方法
                declare -i cc=$aa+$bb
                dd=$(expr $aa+$bb)【expr或let数值运算工具】
                ff=$(($aa+$bb))【&quot;$((运算式))&quot;或&quot;$[运算式]&quot;】
            ③.运算符
                优先级|  运算符       |说明
                --------------------------------------------------------
                13      -，+                 单目负,单目正
                12      !,~                     逻辑非,按位取反或补码
                11      *,/,%                   乘,除,取模
                10      +,-                     加,减
                9           &lt;&gt;                  按位左移,按位右移
                8           &lt; =,&gt; =,                    小于或等于,大于或等于,小于,大于
                7           ==,!=                   等于,不等于
                6           &amp;                           按位与
                5           ^                           按位异或
                4           |                           按位或
                3           &amp;&amp;                      逻辑与
                2           ||                      逻辑或
                1           =,+=,-=,*=,/=,%=,&amp;=,^=,|=,&lt;&lt;=,&gt;&gt;=               赋值,运算且赋值
        2).变量测试与内容替换
            变量置换方式 | 变量y没有设值                     |  变量y为空值          |  变量y设值
            ----------------------------------------------------------------------------------
            x=${y-新值}   x=新值                             x为空                   x=$y
            x=${y:-新值}  x=新值                             x=新值                  x=$y
            x=${y+新值}   x为空                              x=新值                  x=新值
            x=${y:+新值}  x为空                              x为空                   x=新值
            x=${y=新值}   x=新值,y=新值                      x为空,y值不变            x=$y,y值不变
            x=${y:=新值}  x=新值,y=新值                      x=新值,y=新值            x=$y,y值不变
            x=${y?新值}   新值输出到标准错误输出(就是屏幕)    x为空                    x=$y
            x=${y:?新值}  新值输出到标准错误输出              新值输出到标准错误输出   x=$y
    6.环境遍历配置文件
        1).环境变量配置文件简介
            ①.source命令
                source 配置文件【强制配置文件生效】
                . 配置文件【强制配置文件生效】
            ②.环境变量配置文件简介
                &gt;环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量,比如PATH,HISTSIZE,PS1,HOSTNAME等默认环境变量.
                &gt;/etc/profile
                &gt;/etc/profile.d/*.sh
                &gt;～/.bash_profile
                &gt;～/.bashrc
                &gt;/etc/bashrc
        2).环境变量配置文件作用
            ①./etc/profile的作用
                &gt;USER变量
                &gt;LOGNAME变量
                &gt;MAIL变量
                &gt;PATH变量
                &gt;HOSTNAME变量
                &gt;HISTSIZE变量
                &gt;umask
                &gt;调用/etc/profile.d/*.sh文件
        3).其它配置文件和登录信息
            ①.注销时生效的环境变量配置文件
                ～/.bash_logout
            ②.其他配置文件
                ～/.bash_history
            ③.shell登录信息
                &gt;本地终端欢迎信息:/etc/issue
                    \d:显示当前系统日期
                    \s:显示操作系统名称
                    \l:显示登录的终端号,这个比较常用
                    \m:显示硬件体系结构,如i286,i686等
                    \n:显示主机名
                    \o:显示域名
                    \r:显示内核版本
                    \t:显示当前系统时间
                    \u:显示当前登录用户的序列号
                &gt;远程终端欢迎信息:/etc/issue.net
                    转义符在/etc/issue.net文件中不能使用
                    是否显示此欢迎信息,由ssh的配置文件/etc/ssh/sshd_config决定,加入&quot;Banner /etc/issue.net&quot;行才能显示(记得重启SSH服务)
                &gt;登录后欢迎信息:/etc/motd
                    不管是本地登录,还是远程登录,都可以显示此欢迎信息

十一.讲shell编程
    1.基础正则表达式
        1).正则表达式与通配符
            &gt;正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配.grep,awk,sed等命令可以支持正则表达式.
            &gt;通配符用来匹配符合条件的文件名,通配符是完全匹配.ls,find,cp这些命令不支持正则表达式,所以只能使用shell自己的通配符来进行匹配了.
        2).基础正则表达式
            *:前一个字符匹配0次或任意多次
            .:匹配除了换行符外任意一个字符
            ^:匹配行首.例如:^hello会匹配以hello开头的行
            $:匹配行尾.例如:hello&amp;会匹配以hello结尾的行
            []:匹配中括号中指定的任意一个字符,只匹配一个字符.例如:[aoeiu]匹配任意一个元音字母,[0-9]匹配任意一位数字,[a-z][0-9]匹配小写字和一位数字结构的两位字符.
            [^]:匹配除中括号的字符以外的任意一个字符.例如:[^0-9]匹配任意一位非数字字符,[^a-z]表示任意一位非小写字母.
            \:转义符.用于取消将特殊符号的含义取消.
            \{n\}:表示其前面的字符恰好出现n次.例如:[0-9]\{4\}匹配4位数字,[1][3-8][0-9]\{9\}匹配手机号码.
            \{n,\}:表示其前面的字符出现不小于n次.例如:[0-9]\{2,\}表示两位及以上的数字.
            \{n,m\}:表示其前面的字符至少出现n次,最多出现m次.例如:[a-z]\{6,8\}匹配6到8位的小写字母.
        2.1).例子
            grep &quot;a*&quot; aaa.txt【匹配所有内容,包括空白行】
            grep &quot;aa*&quot; aaa.txt【匹配至少包含有一个a的行】
            grep &quot;aaa*&quot; aaa.txt【匹配最少包含两个连续a的字符串】
            grep &quot;aaaaa*&quot; aaa.txt【则会匹配最少包含四个连续a的字符串】
            grep &quot;s..d&quot; aaa.txt【&quot;s..d&quot;会匹配在s和d这两个字母之间一定有两个字符的单词】
            grep &quot;s.*d&quot; aaa.txt【匹配在s和d字母之间有任意字符】
            grep &quot;.*&quot; aaa.txt【匹配所有内容】
            grep &quot;^M&quot; aaa.txt【匹配以大写&quot;M&quot;开头的行】
            grep &quot;n$&quot; aaa.txt【匹配以小写&quot;n&quot;结尾的行】
            grep -n &quot;^$&quot; aaa.txt【会匹配空白行】
            grep &quot;s[ao]id&quot; aaa.txt【匹配s和i字母中,要么是a,要么是o】
            grep &quot;[0-9]&quot; aaa.txt【匹配任意一个数字】
            grep &quot;^[a-z]&quot; aaa.txt【匹配用小写字母开头的行】
            grep &quot;^[^a-z]&quot; aaa.txt【匹配不用小写字母开头的行】
            grep &quot;^[^a-zA-Z]&quot; aaa.txt【匹配不用字母开头的行】
            grep &quot;\.$&quot; aaa.txt【匹配使用&quot;.&quot;结尾的行】
            grep &quot;a\{3\}&quot; aaa.txt【匹配a字母连续出现三次的字符串】
            grep &quot;[0-9]\{3\}&quot; aaa.txt【匹配包含连续的三个数字的字符串】
            grep &quot;^[0-9]\{3,\}[a-z]&quot; aaa.txt【匹配最少用连续三个数字开头的行】
            grep &quot;sa\{1,3\}i&quot; aaa.txt【匹配在字母s和字母i之间有最少一个a,最多三个a】
    2.字符截取命令
        1).cut字段提取命令
            cut [选项] 文件名【-f 列号:提取第几列,-d 分隔符:按照指定分隔符分割列】
        2).printf命令
            printf '输出类型输出格式' 输出内容
                输出类型:
                    %ns:输出字符串.n是数字指代输出几个字符
                    %ni:输出整数.n是数字指代输出几个数字
                    %m.nf:位数和小数位数.如%8.2f代表共输出8位数,其中2位是小数,6位是整数
                输出格式:
                    \a:输出警告声音
                    \b:输出退格键,也就是Backpace键
                    \f:清除屏幕
                    \n:换行
                    \r:回车,也就是Enter键
                    \t:水平输出退格键,也就是Tab键
                    \v:垂直输出退格键,也就是Tab键
        3).awk命令---【具体用法建议百度】
            ①.awk '条件1{动作1} 条件2{动作2}...' 文件名【awk '{printf $2 &quot;\t&quot; $6&quot;\n&quot;}' temp.txt】
                条件:
                    一般使用关系表达式作为条件
                    x&gt;10        判断变量x是否大于10
                    x&gt;=10       大于等于
                    x&lt;=10       小于等于
                动作:
                    格式化输出
                    流程控制语句
            ②.awk 'BEGIN{printf &quot;hello world\n&quot;}{printf $2 &quot;\t&quot; $6&quot;\n&quot;}' temp.txt【BEGIN优先执行一段输出】
            ③.awk 'END{printf &quot;hello world\n&quot;}{printf $2 &quot;\t&quot; $6&quot;\n&quot;}' temp.txt【所有数据处理完之后,再执行end命令的输出】
            ④.cat /etc/passwd | grep &quot;/bin/bash&quot; | awk 'BEGIN {FS=&quot;:&quot;}{printf $2 &quot;\t&quot; $6&quot;\n&quot;}'【FS内置变量,指定分隔符】
            ⑤.cat temp.txt | grep -v name | awk '$6&gt;=87 {printf $2 &quot;\n&quot;}'【关系运算符】
        4).sed命令
            ①.sed命令
                sed是一种几乎包括在所有UNIX平台(包括Linux)的轻量级流编辑器.sed主要是用来将数据进行选取,替换,删除,新增的命令.
            ②.sed [选项] '[动作]' 文件名【sed -n '2p' temp.txt】
                选项:
                    -n:一般sed命令会把所有数据都输出到屏幕,如果加入此选择,则只会把经过sed命令处理的行输出到屏幕.
                    -e:允许对输入数据应用多条sed命令编辑.
                    -i:用sed的修改结果直接修改读取数据的文件,而不是由屏幕输出.
                动作:
                    a:追加,在当前行后添加一行或多行.添加多行时,除最后一行外,每行末尾需要用&quot;\&quot;代表数据未完结
                    c:行替换,用c后面的字符串替换原数据行,替换多行时,除最后一行外,每行末尾需要用&quot;\&quot;代表数据未完结
                    i:插入,在当期行前插入一行或多行.插入多行时,除最后一行外,每行末尾需要用&quot;\&quot;代表数据未完结
                    d:删除,删除指定的行
                    p:打印,输出指定的行
                    s:字串替换,用一个字符串替换另外一个字符串.格式为&quot;行范围s/旧字串/新字串/g&quot;(和vim中的替换格式类似)
    3.字符处理命令
        1).排序命令sort
            sort [选项] 文件名
                -f:忽略大小写
                -n:以数值型进行排序,默认使用字符串型排序
                -r:反向排序
                -t:指定分隔符,默认是分隔符是制表符
                -k n[,m]:按照指定的字段范围排序.从第n字段开始,m字段结束(默认到行尾)
        2).统计命令wc
            wc [选项] 文件名
                -l:只统计行数
                -w:只统计单词数
                -m:只统计字符数
    4.条件判断
        1).按照文件类型进行判断【[ -f /tmp/temp.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;】
            测试选项 |        作用
            ------------------------------------------------------------------------
            -b 文件  |判断该文件是否存在,并且是否为块设备文件(是块设备文件为真)
            -c 文件  |判断该文件是否存在,并且是否为字符设备文件(是字符设备文件为真)
            -d 文件  |判断该文件是否存在,并且是否为目录文件(是目录为真)
            -e 文件  |判断该文件是否存在(存在为真)
            -f 文件  |判断该文件是否存在,并且是否为普通文件(是普通文件为真)
            -L 文件  |判断该文件是否存在,并且是否为符号链接文件(是符号链接文件为真)
            -p 文件  |判断该文件是否存在,并且是否为管道文件(是管道文件为真)
            -s 文件  |判断该文件是否存在,并且是否为非空(非空为真)
            -S 文件  |判断该文件是否存在,并且是否为套接字文件(是套接字文件为真 )
        2).按照文件权限进行判断【[ -r /tmp/temp.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;】
            测试选项 |        作用
            ------------------------------------------------------------------------
            -r 文件  |判断该文件是否存在,并且是否该文件拥有读权限(有读权限为真)
            -w 文件  |判断该文件是否存在,并且是否该文件拥有写权限(有写权限为真)
            -x 文件  |判断该文件是否存在,并且是否该文件拥有执行权限(有执行权限为真)
            -u 文件  |判断该文件是否存在,并且是否该文件拥有SUID权限(有SUID权限为真)
            -g 文件  |判断该文件是否存在,并且是否该文件拥有SGID权限(有SGID权限为真)
            -k 文件  |判断该文件是否存在,并且是否该文件拥有SBit权限(有SBit权限为真)
        3).两个文件之间进行比较【[ /tmp/temp.txt -nt /tmp/temp.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;】
            测试选项        |        作用
            ------------------------------------------------------------------------
            文件1 -nt 文件2 |判断文件1的修改时间是否比文件2的新(如果新则为真)
            文件1 -ot 文件2 |判断文件1的修改时间是否比文件2的旧(如果旧则为真)
            文件1 -ef 文件2 |判断文件1是否和文件2的inode号一致,可以理解为两个文件是否为同一个文件.这个判断用于判断硬链接是很好的方法.
        4).两个整数之间比较【[ 22 -eq 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;】
            测试选项        |        作用
            ------------------------------------------------------------------------
            整数1 -eq 整数2 |判断整数1是否和整数2相等(相等为真)
            整数1 -no 整数2 |判断整数1是否和整数2不相等(不相等为真)
            整数1 -gt 整数2 |判断整数1是否大于整数2(大于为真)
            整数1 -it 整数2 |判断整数1是否小于整数2(小于为真)
            整数1 -ge 整数2 |判断整数1是否大于等于整数2(大于等于为真)
            整数1 -le 整数2 |判断整数1是否小于等于整数2(小于等于为真)
        5).字符串的判断【[ -z temp ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;】
            测试选项        |        作用
            ------------------------------------------------------------------------
            -z 字符串          |判断字符串是否为空(为空返回真)
            -n 字符串          |判断字符串是否为非空(非空返回真)
            字串1 == 字串2  |判断字符串1是否和字符串2相等(相等返回真)
            字串1 != 字串2  |判断字符串1是否和字符串2不相等(不相等返回真)
        6).多重条件判断【[ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;】
            测试选项        |        作用
            ------------------------------------------------------------------------
            判断1 -a 判断2      |逻辑与,判断1和判断2都成立,最终的结果才为真
            判断1 -o 判断2      |逻辑或,判断1和判断2有一个成立,最终的结果就为真
            ! 判断                        |逻辑非,使原始的判断式取反
    5.流程控制
        1).if语句
            ①.单分支if条件语句
                if [ 条件判断式 ];then
                    程序
                fi
                或者
                if [ 条件判断式 ]
                    then
                        程序
                fi
                -----------------------------------
                单分支条件语句需要注意几个点
                    &gt;if语句使用fi结尾,和一般语言使用大括号结尾不同
                    &gt;[ 条件判断式 ]就是使用test命令判断,所以中括号和条件判断式之间必须有空格.
                    &gt;then后面跟符合条件之后执行的程序,可以放在[]之后,用&quot;;&quot;分割.也可以换行写入,就不需要&quot;;&quot;了.
            ②.双分支if条件语句
                if [ 条件判断式 ]
                    then
                        条件成立时,执行的程序
                else
                    条件不成立时,执行的另一个程序
                fi
            ③.多分支if条件语句
                if [ 条件判断式1 ]
                    then
                        条件成立时,执行的程序
                        exit 1
                elif [ 条件判断式2 ]
                    then
                        条件成立时,执行的程序
                else
                        条件不成立时,执行的另一个程序
                fi
        2).case语句
            ①.多分支case条件语句
                &gt;case语句和if...elif...slse语句一样都是多分支条件语句,不过和if多分支条件语句不同的是,case语句只能判断一种条件关系,而if语句可以判断多种条件关系.
                case $变量名 in
                    &quot;值1&quot;)
                        如果变量的值等于值1,则执行程序1
                        ;;
                    &quot;值2&quot;)
                        如果变量的值等于值2,则执行程序2
                        ;;
                    *)
                        如果变量的值都不是以上的值,则执行此程序
                        ;;
                esac    
        3).for循环
            ①.语法一
                for 变量 in 值1 值2 值3 ...
                    do
                        程序:echo &quot;hello&quot;
                    done
            ②.语法二
                for (( 初始值;循环控制条件;变量变化))
                    do
                        程序
                    done
        4).while循环
            ①.while循环
                &gt;while循环是不定循环,也称作条件循环.只要条件判断式成立,循环就会一直继续,直到条件判断式不成立,循环才会停止.这就和for的固定循环不太一样了.
                格式:
                    while [ 条件判断式 ]
                        do
                            程序
                        done
            ②.until循环
                &gt;until循环,和while循环相反,until循环时只要条件判断式不成立则进行循环,并执行循环程序.一旦循环条件成立,则终止循环.
                格式:
                    until [ 条件判断式 ]
                        do
                            程序
                        done

十二、Linux服务管理
    1.服务简介与分类
        1).服务的分类
            &gt;RPM包默认安装的服务
                独立的服务
                基于xinetd服务
            &gt;源码包安装的服务
        2).查询已安装的服务
            &gt;RPM包安装的服务
                chkconfig --list【查看服务自动启状态,可以看到所有RPM包安装的服务】
            &gt;源码包安装的服务
                查看服务安装位置,一般是/usr/local/下
    2.RPM包安装服务的管理
        1).独立服务的管理
            ①.RPM包安装服务的位置
                &gt;RPM安装服务和源码包安装服务的区别就是安装位置的不同
                    源码包安装在指定位置,一般是/usr/local/
                    RPM包安装在默认位置中
                        /etc/init.d/:启动脚本位置
                        /etc/sysconfig/:初始化环境配置文件位置
                        /etc/:配置文件位置
                        /etc/xinetd.conf:xinetd配置文件
                        /etc/xinetd.d/:基于xinetd服务的启动脚本
                        /var/lib/:服务产生的数据放在这里
                        /var/log/:日志
            ②.独立服务的启动
                &gt;/etc/init.d 独立服务名 start|stop|status|restart
                &gt;service 独立服务名 start|stop|status|restart
            ③.独立服务的自动启动
                &gt;chkconfig [--level 运行级别] [独立服务名] [on|off]【chkconfig --level 2345 httpd on(Apache服务自启动)】
                &gt;修改/etc/rc.d/rc.local文件【推荐】
                &gt;使用ntsysv命令管理自启动
        2).基于xinetd服务的管理
            ①.安装xinetd与telnet
                yum -y install xinetd
                yum -y install telnet-service
            ②.xinetd服务的启动
                vim /etc/xinetd.d/telnet
            ③.xinetd服务自启动
                chkconfig telnet on
    3.源码包安装服务的管理
        1).源码包安装服务的启动
            ①.使用绝对路径,调用启动脚本来启动.不同的源码包的启动脚本不同.可以查看源码包的安装说明,查看启动脚本的方法.
                /usr/local/apache2/bin/apachectl start|stop
        2).源码包服务的自启动
            vim /etc/rc.d/rc.local
            加入
            /usr/local/apache2/bin/apachect1 start
        3).让源码包服务被服务管理命令识别
            ①.让源码包的apache服务能被service命令管理启动
                ln -s /usr/local/apache2/bin/apachect1 /etc/init.d/apache
            ②.让源码包的apache服务能被chkconfig与ntsysv命令管理自启动
                vim /etc/init.d/apache
                    #chkconfig:35 86 76
                    #指定httpd脚本可以被chkconfig命令管理.格式是:chkconfig: 运行级别 启动顺序 关闭顺序
                    #description: source package apache
                    #说明,内容随意
                chkconfig --add apache【把源码包apache加入chkconfig命令】

十二、Linux系统管理
    1.进程管理
        1).进程查看
            ①.查看系统中所有进程
                ps aux【查看系统中所有进程,使用BSD操作系统格式】
                ps -le【查看系统中所有进程,使用Linux标准命令格式】
                    &gt;USER:该进程是由哪个用户产生的.
                    &gt;PID:进程的ID号.
                    &gt;%CPU:该进程占用CPU资源的百分比,占用越高,进程越耗费资源.
                    &gt;%MEM:该进程占用物理内存的百分比,占用越高,进程越耗费资源.
                    &gt;VSZ:该进程占用虚拟内存的大小,单位KB.
                    &gt;RSS:该进程占用实际物理内存的大小,单位KB.
                    &gt;TTY:该进程是在哪个终端中运行的.其中tty1-tty7代表本地控制台终端,tty1-tty6是本地的字符界面终端,tty7是图形终端.pts/0-255代表虚拟终端.
                    &gt;STAT:进程状态.常见的状态有,R:运行,S:睡眠,T:停止状态,s:包含子进程,+:位于后台
                    &gt;START:该进程的启动时间
                    &gt;TIME:该进程占用CPU的运算时间,注意不是系统时间
                    &gt;COMMAND:产生此进程的命令名
            ②.查看系统健康状态
                top [选项]【-d 秒数:指定top命令每隔几秒更新.默认是3秒】
                在top命令的交互模式当中可以执行的命令:
                    ?或h:显示交互模式的帮助
                    P:以CPU使用率排序,默认就是此项
                    M:以内存的使用率排序
                    N:以PID排序
                    q:退出top
                ------------说明top命令后的信息----------------------
                第一行信息为任务队列信息
                    12:25:12-----系统当前时间
                    up 1 day, 13:22-----系统的运行时间,本机已经运行1天13小时22分钟
                    2 users-----当前登录了两个用户
                    load average: 0.00, 0.00, 0.00-----【重点】系统在之前1分钟,5分钟,15分钟的平均负载.一般认为小于1时,负载较小.如果大于1,系统已经超出负荷.
                第二行为进程信息
                    Tasks:  84 total-----系统中的进程总数
                    1 running-----正在运行的进程数
                    94 sleeping-----睡眠的进程
                    0 stopped-----正在停止的进程
                    0 zombie-----僵尸进程.如果不是0,需要手工检查僵尸进程
                第三行为CPU信息
                    Cpu(s):  0.0%us-----用户模式占用的CPU百分比
                    0.1%sy-----系统模式占用的CPU百分比
                    0.0%ni-----改变过优先级的用户进程占用的CPU百分比
                    99.7%id-----【重点】空闲CPU的CPU百分比
                    0.1%wa-----等待输入/输出的进程的占用CPU百分比.
                    0.0%hi-----硬中断请求服务占用的CPU百分比.
                    0.1%si-----软中断请求服务占用的CPU百分比.
                    0.0%st-----st(Steal time)虚拟时间百分比.就是当有虚拟机时,虚拟CPU等待实际CPU的时间百分比.
                第四行为物理内存信息
                    Mem:   1030532k total-----物理内存的总量,单位KB
                    213760k used-----已经使用的物理内存数量
                    816772k free-----【重点】空闲的物理内存数量,我们使用的是虚拟机,总共只分配了1024MB内存,所以只有816MB的空闲内存了
                    22836k buffers-----作为缓冲的内存数量
                第五行为交换分区(swap)信息
                    Swap:  1048568k total-----交换分区(虚拟内存)的总大小
                    0k used-----已经使用的交互分区的大小
                    1048568k free-----空闲交换分区的大小
                    118624k cached-----作为缓存的交互分区的大小
            ③.查看进程树
                pstree [选项]【-p:显示进程的PID,-u:显示进程的所属用户】
        2).进程管理
            ①.kill命令
                kill -l【查看可用的进程信号】
                    -----------常用信号-----------------------
                    1:SIGHUP:该信号让进程立即关闭,然后重新读取配置文件之后重启.
                    2:SIGINT:程序终止信号,用于终止前台进程.相当于输出ctrl+c快捷键.
                    8:SIGFPE:在发生致命的算术运算错误时发出.不仅包括浮点运算错误,还包括溢出及除数为0等其他所有的算术的错误.
                    9:SIGKILL:用来立即结束程序的运行.本信号不能被阻塞、处理和忽略.一般用于强制终止进程.
                    14:SIGALRM:时钟定时信号,计算的是实际的时间或时钟时间.alarm函数使用该信号.
                    15:SIGTERM:正常结束进程的信号,kill命令的默认信号.有时如果进程已经发生问题,这个信号是无法正常终止进程的,我们才会尝试SIGKILL信号,也就是信号9.
                    18:SIGCONT:该信号可以让暂停的进程恢复执行,本信号不能被阻断.
                    19:SIGSTOP:该信号可以暂停前台进程,相当于输入ctrl+z快捷键.本信号不能被阻断.
            ②.killall命令
                killall [选项][信号] 进程名【按照进程名杀死进程】
                    -i:交互式,询问是否要杀死某个进程
                    -I:忽略进程名的大小写
            ③.pkill命令
                pkill [选项][信号] 进程名【按照进程名终止进程】
                    -t 终端号:按照终端号踢出用户
                    ---------按照终端号踢出用户--------------------
                    w【使用w命令查询本机已经登录的用户】
                    pkill -9 -t pts/0【强制杀死从pts/0虚拟终端登录的进程,注意:-9和-t的位置不能换,否则踢出失败】
            ④.终止进程
                kill -15 [进程的PID]
    2.工作管理
        1).把进程放入后台
            &gt;tar -zcf etc.tar.gz /etc &amp;【在命令后面加上&quot;&amp;&quot;符号,后台运行】
            &gt;top【在top命令执行的过程中,按下ctrl+z快捷键,后台暂停】
        2).查看后台的工作
            jobs -l【-l:显示工作的PID】
            注:&quot;+&quot;号代表最近一个放入后台的工作,也是工作恢复时,默认恢复的工作.&quot;-&quot;号代表倒数第二个放入后台的工作.
        3).将后台暂停的工作恢复到前台执行
            fg %工作号【%工作号:&quot;%&quot;号可以省略,但是注意工作号和PID的区别】
        4).将后台暂停的工作恢复到后台执行
            bg %工作号【注:后台恢复执行的命令,是不能和前台有交互的,否则不能恢复到后台执行(top、vim这些命令是不能在后台运行的)】
    3.系统资源查看
        1).vmstat命令监控系统资源
            vmstat [刷新延时 刷新次数]【vmstat 1 3:监听3次我的系统资源,每次间隔1秒】
        2).dmesg开机时内核检测信息
            dmesg | grep CPU
        3).free命令查看内存使用状态
            free [-b|-k|-m|-g]
                -b:以字节为单位显示
                -k:以KB为单位显示,默认就是以KB为单位显示
                -m:以MB为单位显示
                -g:以GB为单位显示
        4).查看CPU信息
            cat /proc/cpuinfo
        5).uptime命令
            uptime【显示系统的启动时间和平均负载,也就是top命令的第一行.w命令也可以看到这个数据】
        6).查看系统与内核相关信息
            uname [选项]【-a:查看系统所有相关信息,-r:查看内核版本,-s:查看内核名称】
            file /bin/ls【判断当前系统的位数】
            lsb_release -a【查询当前Linux系统的发行版本】
        7).列出进程打开或使用的文件信息
            lsof [选项]【列出进程调用或打开的文件的信息】
                -c 字符串:只列出以字符串开头的进程打开的文件
                -u 用户名:只列出某个用户的进程打开的文件
                -p pid:列出某个PID进程打开的文件
    4.系统定时任务
        1).crond服务管理与访问控制
            service crond restart【】
            chkconfig crond on【】
        2).用户的crontab设置
            crontab [选项]【-e:编辑crontab定时任务,-l:查询crontab任务,-r:删除当前用户所有的crontab任务】
            ----------格式----------------------------------------------------------------------------------------------------------
            * * * * * 执行的任务

            -----------“*”的含义--------------------------------------------------------------------------------------------------
            第一个&quot;*&quot;:一小时当中的第几分钟:0-59
            第二个&quot;*&quot;:一天当中的第几小时:0-23
            第三个&quot;*&quot;:一个月当中的第几天:1-31
            第四个&quot;*&quot;:一年当中的第几月:1-12
            第五个&quot;*&quot;:一周当中的星期几:0-7(0和7都代表星期日)
            ----------------特殊符号说明---------------------------------------------------------------------------------------------
            *:代表任何时间.比如第一个&quot;*&quot;就代表一小时中每分钟都执行一次的意思.
            ,:代表不连续的时间.比如&quot;0 8,12,16 * * * 命令&quot;,就代表在每天的8点0分,12点0分,16点0分都执行一次命令.
            -:代表连续的时间范围.比如&quot;0 5 * * 1-6 命令&quot;,代表在周一到周六的凌晨5点0分执行命令
            */n:代表每隔多久执行一次.比如&quot;*/10 * * * * 命令&quot;,代表每隔10分钟就执行一遍命令
            --------------例子-----------------------------------------------------------------------------------------------------------
            45 22 * * * 命令-----在22点45分执行命令
            0 17 * * 1 命令-----每周一的17点0分执行命令
            0 5 1,15 * * 命令-----每月1号和15号的凌晨5点0分执行命令
            40 4 * * 1-5 命令-----每周一到周五的凌晨4点40分执行命令
            */10 4 * * * 命令-----每天的凌晨4点,每隔10分钟执行一次命令
            0 0 1,15 * 1 命令-----每月1号和15号,每周一的0点0分都会执行命令.注意:星期几和几号最好不要同时出现,因为它们定义的都是天.非常容易让管理员混乱.
        3).定时操作
            crontab -e【清空定时任务】
            crontab -r【查看定时任务】

十三、日志管理
    1.日志管理简介
        1).日志服务
            &gt;在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务.resyslogd日志服务更加先进,功能更多.但是不论该服务的使用,还是日志文件的格式其实都是和syslogd服务相兼容的,所以学习起来基本和syslogd服务一致.
            &gt;rsyslogd的新特点:
                -基于TCP网络协议传输日志信息
                -更安全的网络传输方式
                -有日志消息的及时分析框架
                -后台数据库
                -配置文件中可以写简单的逻辑判断
                -与syslog配置文件相兼容
            &gt;确定服务启动
                ps aux | grep rsyslogd【查看服务是否启动】
                chkconfig --list | grep rsyslog【查看服务是否自启动】
        2).常见日志的作用
            /var/log/cron-----记录了系统定时任务相关的日志
            /var/log/cups/-----记录打印信息的日志
            /var/log/dmesg-----记录了系统在开机时内核自检的信息.也可以使用dmesg命令直接查看内核自检信息
            /var/log/btmp-----记录错误登录的日志.这个文件是二进制文件,不能直接vim查看,而要使用[lastb]命令查看
            /var/log/lastlog-----记录系统中所有用户最后一次的登录时间的日志.这个文件也是二进制文件,不能直接vim,而要使用lastlog命令查看
            /var/log/mailog-----记录邮件信息
            /var/log/message-----记录系统重要信息的日志.这个日志文件中会记录Linux系统的绝大多数重要信息,如果系统出现问题时,首先要检查的就应该是这个日志文件.
            /var/log/secure-----记录验证和授权方面的信息,只要涉及账户和密码的程序都会记录.比如说系统的登录,ssh的登录,su切换用户,sudo授权,甚至添加用户和修改用户密码都会记录在这个日志文件中.
            /var/log/wtmp-----永久记录所有用户的登录,注销信息,同时记录系统的启动,重启,关机事件.同样这个文件也是一个二进制文件,不能直接vim,而需要使用last命令来查看.
            /var/run/utmp-----记录当前已经登录的用户的信息.这个文件会随着用户的登录和注销而不断变化,只记录当前登录用户的信息.同样这个文件不能直接vim,而要使用w,who,users等命令来查询.
            -----------------
            &gt;除了系统默认的日志之外,采用RPM方式安装的系统服务也会默认把日志记录在/var/log/目录中(源码包安装的服务日志是在源码包指定目录中).不过这些日志不是由rsyslogd服务来记录和管理的,而是各个服务使用自己的日志管理文档来记录自身日志.
            /var/log/httpd/-----RPM包安装的apache服务的默认日志目录
            /var/log/mail/-----RPM包安装的邮件服务的额外日志目录
            /var/log/samba/-----RPM包安装的samba服务的日志目录
            /var/log/sssd/-----守护进程安全服务目录
    2.rsyslogd日志服务
        1).日志文件格式
            &gt;基本日志格式包含一下四列:
                -事件产生的时间
                -发生事件的服务器的主机名
                -产生事件的服务名或程序名
                -事件的具体信息
        2)./etc/rsyslog.conf配置文件
            authpriv.*  /var/log/secure【服务名称[连接符号]日志等级  日志记录位置】
            #认证相关服务,所有日志等级  记录在/var/log/secure日志中
            -----------服务名称--------------------------------
            auth-----安全和认证相关消息(不推荐使用authpriv替代)
            authpriv-----安全和认证相关消息(私有的)
            cron-----系统定时任务cront和ar产生的日志
            daemon-----和各个守护进程相关的日志
            ftp-----ftp守护进程产生的日志
            kern-----内核产生的日志(不是用户进程产生的)
            local0-local7-----为本地使用预留的服务
            lpr-----打印产生的日志
            mail-----邮件收发信息
            news-----与新闻服务器相关的日志
            syslog-----有syslogd服务产生的日志信息(虽然服务名称已经改为rsyslogd,但是很多配置都还是沿用了syslogd的,这里并没有修改服务名)
            user-----用户等级类别的日志信息
            uucp-----uucp子系统的日志信息,uucp是早起Linux系统进行数据传递的协议,后来也常用在新闻组服务中
            ------------连接符号-----------------------------------------
            连接符号可以识别为:
                &quot;*&quot;代表所有日志等级,比如:&quot;authpriv.*&quot;代表authpriv认证信息服务产生的日志,所有的日志等级都记录
                &quot;.&quot;代表只要比后面的等级高的(包含该等级)日志都记录下来.比如:&quot;cron.info&quot;代表cron服务产生的日志,只要日志等级大于等于info级别,就记录
                &quot;.=&quot;代表只记录所需等级的日志,其它等级的都不记录.比如:&quot;*.=emerg&quot;代表人和日志服务产生的日志,只要等级是emerg等级就记录.这种用法及少见,了解就好
                &quot;.!&quot;代表不等于,也就是除了该等级的日志外,其它等级的日志都记录
            -------------日志等级--------------------------------------------------------------
            debug-----一般的调试信息说明
            info-----基本的通知信息
            notice-----普通信息,但是有一定的重要性
            warning-----警告信息,但是还不会影响到服务或系统的运行
            err-----错误信息,一般达到err等级的信息以及可以影响到服务或系统的运行了
            crit-----临界状况信息,比err等级还要严重
            alert-----警告状态信息,比crit还要严重.必须立即采取行动
            emerg-----疼痛等级信息,系统已经无法使用了
            -------------日志记录位置-----------------------------------------------------------------------
            &gt;日志文件的绝对路径,如&quot;/var/log/secure&quot;
            &gt;系统设备文件,如&quot;/dev/1p0&quot;
            &gt;转发给远程主机,如&quot;@192.168.0.210:514&quot;
            &gt;用户名,如&quot;root&quot;
            &gt;忽略或丢弃日志,如&quot;~&quot;
    3.日志轮替
        1).日志文件的命名规则
            &gt;如果配置文件中拥有&quot;dateext&quot;参数,那么日志会用日期来作为日志文件的后缀,例如&quot;secure-20130605&quot;.这样的话日志文件名不会重叠,所以也就不需要日志文件的改名,只需要保存指定的日志个数,删除多余的日志文件即可.
            &gt;如果配置文件中没有&quot;dateext&quot;参数,那么日志文件就需要进行改名了.当第一次进行日志轮替时,当前的&quot;secure&quot;日志会自动改名为&quot;secure.1&quot;,然后新建&quot;secure&quot;日志,用来保存新的日志.当第二次进行日志轮替时,&quot;secure.1&quot;会自动改名为&quot;secure.2&quot;,当前的&quot;secure&quot;日志会自动改名为&quot;secure.1&quot;,然后也会新建&quot;secure&quot;日志,用来保存新的日志,以此类推.
        2).logrotate配置文件
            daily-----日志的轮替周期是每天
            weekly-----日志的轮替周期是每周
            monthly-----日志的轮替周期是每月
            rotate 数字-----保留的日志文件的个数,0指没有备份
            compress-----日志轮替时,旧的日志进行压缩
            create mode owner group-----建立新日志,同时指定新日志的权限与所有者和所属组.如:create 0600 root utmp
            mail address-----当日志轮替时,输出内容通过邮件发送到指定的邮件地址.如:mail 123@163.com
            missingok-----如果日志不存在,则忽略该日志的警告信息
            notifempty-----如果日志为空文件,则不进行日志轮替
            minsize 大小-----日志轮替的最小值.也就是日志一定要达到这个最小值才会轮替,否则就算时间达到也不轮替
            size 大小-----日志只有大于指定大小才进行日志轮替,而不是按照时间轮替.如:size 100k
            dateext-----使用日期作为日志轮替文件的后缀.如:secure-20150909
        3).假设,把apache日志加入轮替
            vim /etc/log/rotate.conf【进入vim命令模式】
            /usr/local/apache2/logs/access_log{
                daily
                create
                rotate 30
            }
        4).logrotate命令
            logrotate [选项] 配置文件名
            选项:
                如果此命令没有选项,则会按照配置文件中的条件进行日志轮替
                -v:显示日志轮替过程.加了-v选项,会显示日志轮替的过程
                -f:强制进行日志轮替.不管日志轮替的条件是否已经符合,强制配置文件中所有的日志进行轮替

十四、启动管理
    1.CentOS 6.x启动管理
        1).系统运行级别
            ①.运行级别
                0-----关机
                1-----单用户模式,可以想象为windows的安全模式,主要用与系统修复
                2-----不完全的命令行模式,不含NFS服务
                3-----完全的命令行模式,就是标准字符界面
                4-----系统保留
                5-----图形模式
                6-----重启动
            ②.运行级别命令
                runlevel【查看运行级别命令】
                init 运行级别【改变运行级别命令】
            ③.系统默认运行级别
                vim /etc/inittab【进入vim命令模式进行修改】
                    id:3:initdefault:
                    #系统开机后直接进入哪个运行级别
        2).系统启动过程
            ①.启动流程图
                --------------------------------------------------------------------------------------------------------------------------
                                           单系统直接启动 --&gt; 加载内核 --------&gt;--------------------&gt;-------------------&gt;------             
                                                                                ∧                                                                            |            
                BIOS -加载-&gt; MBR -加载-&gt; MBR中启动引导程序                                                                     |--&gt;   
                                                            ∨                                                                            |      
                                              多系统 --&gt; 调用其它分区启动扇区中启动引导程序 --&gt; 启动不同的操作系统 --&gt; 加载内核 --               
                -------------------------------------------------------------------------------------------------------------------------------     
                -&gt; 内核解压并自检 -搜索-&gt; 找到initramfs --&gt; 建立仿真根目录 --&gt; 加载驱动 --&gt; 加载真正系统根目录 -调用-&gt; /sbin/init -调用-&gt;
                ------------------------------------------------------------------------------------------------------------------------------
                             ----调用--&gt; /etc/rc.d/rc.sysinit --&gt; 系统初始化
                            ∧
                -&gt; /etc/init/rcS.conf
                            ∨
                             ----调用--&gt; /etc/inittab -传入运行级别-&gt; /etc/init/rc.conf -调用-&gt; /etc/rc.d/rc -按照运行级别调用-&gt; /etc/rc[0-6].d --&gt;
                -------------------------------------------------------------------------------------------------------------------------------
                -&gt; 按照优先级启动和关闭相应脚本 -启动和关闭-&gt; /etc/rc.d/rc.local中的程序 --&gt; 登录界面 -输入用户名和密码-&gt; 进入系统
                -------------------------------------------------------------------------------------------------------------------------------
            ②.initramfs内存文件系统
                &gt;CentOS 6.x中使用initramfs内存文件系统取代了CentOS 5.x中的initrd RAM Disk.它们的作用类似,可以通过启动引导程序加载到内存中,然后加载启动过程中所需要的内核模块,比如USB,SATA,SCSI硬盘的驱动和LVM,RAID文件系统的驱动.
            ③.调用/etc/init/rcS.conf配置文件
                &gt;主要功能是两个
                    先调用/etc/rc.d/rc.sysinit,然后由/etc/rc.d/rc.sysinit配置文件进行Linux系统初始化.
                    然后再调用/etc/inittab,然后由/etc/inittab配置文件确定系统的默认运行级别
            ④.由/etc/rc.d/rc.sysinit初始化
                &gt;获得网络环境
                &gt;挂载设备
                &gt;开机启动画面Plymouth(取代了过往的RHGB)
                &gt;判断是否启用SELinux
                &gt;显示于开机过程中的欢迎画面
                &gt;初始化硬件
                &gt;用户自定义模块的加载
                &gt;配置内核的参数
                &gt;设置主机名
                &gt;同步存储器
                &gt;设备映射器及相关的初始化
                &gt;初始化软件磁盘陈列(RAID)
                &gt;初始化LVM的文件系统功能
                &gt;检验磁盘文件系统(fsck)
                &gt;设置磁盘配额(quota)
                &gt;重新以可读写模式挂载系统磁盘
                &gt;更新quota(非必要)
                &gt;启动系统虚拟随机数生成器
                &gt;配置机器(非必要)
                &gt;清除开机过程当中的临时文件
                &gt;创建ICE目录
                &gt;启动交换分区
                &gt;将开机信息写入/var/log/dmesg文件中
            ⑤.调用/etc/rc.d/rc文件
                &gt;运行级别参数传入/etc/rc.d/rc这个脚本之后,由这个脚本文件按照不同的运行级别启动/etc/rc[0-6].d/目录中的相应的程序
                    /etc/rc3.d/K??开头的文件(??是数字),会按照数字顺序依次关闭
                    /etc/rc3.d/S??开头的文件(??是数字),会按照数字顺序依次启动
    2.启动引导程序grub
        1).grub配置文件
            ①.grub中分区表示
                硬盘              分区               Linux中设备文件名               grub中设备文件名
                ------------------------------------------------------------------------------------------
                第一块SCSI硬盘   第一个主分区       /dev/sda1                    hd(0,0)
                                第二个主分区        /dev/sda2                    hd(0,1)
                                扩展分区            /dev/sda3                   hd(0,2)
                                第一个逻辑分区      /dev/sda5                    hd(0,4)
                -----------------------------
                第二块SCSI硬盘  第一个主分区        /dev/sda1                     hd(1,0)
                               第二个主分区         /dev/sda2                     hd(1,1)
                               扩展分区             /dev/sda3                     hd(1,2)
                               第一个逻辑           /dev/sda5                     hd(1,4)
            ②.grub配置文件
                vim /boot/grub/grub.conf
                    &gt;default=0      默认启动第一个系统
                    &gt;timeout=5      等待时间,默认是5秒
                    &gt;splashimage=(hd0,0)/grub/splash.xpm.gz     这里是指定grub启动时的背景图像文件的保存位置的
                    &gt;hiddenmenu     隐藏菜单
                    &gt;title CentOS (2.6.32-431.el6.i686)【title就是标题的意思】
                    &gt;root (hd0,0)【是指启动程序的保存分区】
                    &gt;kernel /vmlinuz-2.6.32-431.el6.i686 ro root=UUID=e43f03c7-454c-463f-ac17-ac310220d6d8 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet【定义内核加载时的选项】
                    &gt;initrd /initramfs-2.6.32-431.el6.i686.img【指定了initramfs内存文件系统镜像文件的所在位置】
        2).grub加密与字符界面分辨率调整
            ①.grub加密
                grub-md5-crypt【生成加密密码串】
                vim /boot/grub/grub.conf【进入vim命令模式】
                    default=0
                    timeout=5
                    password --md5 asfdfsdfsdfdasdadww%$d$6asdfsf/
                    #password选项放在整体设置处
            ②.纯字符界面分辨率调整
                grep &quot;CONFIG_FRAMEBUFFER_CONSOLE&quot; /boot/config-2.6.32-279.e16.i686【查询内核是否支持分辨率修改】
                ---------------分辨率表格----------------------------------
                色深      640*480     800*600     1024*768        1280*1024       
                8位      769             771             773                 775             
                15位     784             787             790                 793             
                16位     785             788             791                 794             
                32位     786             789             792                 795             
                -------------------------------------------------------
                vim /boot/grub/grub.conf【进入vim编辑模式】
                    kernel /vmlinuz-2.6.32-431.el6.i686 ro root=UUID=e43f03c7-454c-463f-ac17-ac310220d6d8 rd_NO_LUKS  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet vga=791【在这句话的结尾加上&quot;vga=791&quot;就行了】
    3.系统修复模式
        ①.单用户模式
            &gt;单用户模式常见的错误修复
                遗忘root密码
                修改系统默认运行级别
        ②.重要系统文件丢失,导致系统无法启动【进入光盘修复模式】
            bash-4.1# chroot /mnt/sysimage
            #改变主目录
            sh-4.1# cd /root
            #进入root根目录,再进行操作
            sh-4.1# rpm -qf /etc/inittab
            #查询下/etc/inittab文件属于哪个包
            sh-4.1# mkdir /mnt/cdrom
            #建立挂载点
            sh-4.1# mount /dev/sr0 /mnt/cdrom
            #挂载硬盘
            sh-4.1# rpm2cpio /mnt/cdrom/Packages/initscripts-8.45.3-1.i386.rpm | cpio -idv ./etc/inittab
            #提取inittab文件到当前目录
            sh-4.1# cp etc/inittab /etc/inittab
            #复制inittab文件到指定位置,从而达到修复系统文件的目的
        ③.Linux的安全性
            用户密码    --&gt; grub加密  --&gt; BIOS加密  
                    ∨                       ∨                       ∨
            单用户模式       光盘修复模式      拔除主板电池  

十五、备份与恢复
    1.备份概述
        1).Linux系统需要备份的数据
            &gt;/root/目录
            &gt;/home/目录
            &gt;/var/spool/mail/目录
            &gt;/etc/目录
            &gt;其它目录
            -------安装服务的数据------------
            &gt;apache需要备份的数据
                配置文件
                网页主目录
                日志文件
            &gt;MySql需要备份的数据
                源码包安装的MySql: /usr/local/mysql/data/
                RPM包安装的MySql: /var/lib/mysql/
        2).备份策略
            &gt;完全备份:完全备份就是指把所有需要备份的数据全部备份,当然完全备份可以备份整块硬盘,整个分区或某个具体的目录
            &gt;增量备份
            &gt;差异备份
    2.dump和restore命令
        1).dump备份命令【默认是没有安装的】
            dump [选项] 备份之后的文件名 原文件或目录
                -0:就是我们说的[0-9]十个备份级别
                -f 文件名:指定备份之后的文件名
                -u:备份成功之后,把备份时间记录在/etc/dumpdates文件
                -v:显示备份过程中更多的输出信息
                -j:调用bzlib库压缩备份文件,其实就是把备份文件压缩为.bz2格式
                -W:显示允许被dump的分区的备份等级及备份时间 
                ------------备份分区--------------------------------------------
                dump -0uj -f /root/boot.bak.bz2 /boot
                #备份命令.先执行一次完全备份,并压缩和更新备份时间
                cat /etc/dumpdates
                #查看备份时间文件
                cp install.log /boot/
                #复制日志文件到/boot分区
                dump -1uj -f /root/boot.bak.bz2 /boot/
                #增量备份/boot分区,并压缩
                dump -W
                #查询分区的备份时间及备份级别的
                -----------备份文件或目录------------------------------
                dump -0j -f /root/etc.dump.bz2 /etc/【完全备份/etc/目录,只能使用0级别进行完全备份,而不再支持增量备份】
        2).restore恢复命令
            restore [模式选项] [选项]
                模式选项:restore命令常用的模式有以下四种,这四个模式不能混用
                    -C:比较备份数据和实际数据的变化
                    -i:进入交互模式,手工选择需要恢复的文件
                    -t:查看模式,用于查看备份文件中拥有哪些数据
                    -r:还原模式,用于数据还原
                选项:
                    -f:指定备份文件的文件名
                ----------比较备份数据和实际数据的变化-------------------------
                restore -C -f /root/boot.bak.bz2
              ----------查看模式-----------------
                restore -t -f boot.bak.bz2
                ----------还原分区模式-------------------
                #还原boot.bak.bz2分区备份
                #先还原完全备份的数据
                mkdir boot.test
                cd boot.test/
                restore -r -f /root/boot.bak.bz2
                #解压缩
                restore -r -f /root/boot.bak.bz2
                #恢复增量备份数据
                ----------还原文件或目录----------------
                #还原/etc/目录的备份etc.dump.bz2
                restore -r -f etc.dump.bz2
                #还原etc.dump.bz2备份
</code></pre>

<p>转载于:<a href="https://www.cnblogs.com/peak-c/p/6023240.html">https://www.cnblogs.com/peak-c/p/6023240.html</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>