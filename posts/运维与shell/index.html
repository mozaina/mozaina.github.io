<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>运维与shell | 开发者问答集锦</title>
    <meta property="og:title" content="运维与shell - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="运维与shell">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/%E8%BF%90%E7%BB%B4%E4%B8%8Eshell/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">运维与shell</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="运维工作内容">运维工作内容</h2>

<h3 id="术语名词">术语名词</h3>

<ul>
<li>IDC(Internet Data Center )：互联网数据中心，主要服务包括整机租用、服务器托管、机柜租用、机房租用、专线接入或网络管理服务等。广义上的IDC业务，实际上就是数据中心所提供的一切服务。客户租用数据中心的服务器和带宽，并利用数据中心的技术力量，来实现自己对软、硬件的要求，搭建自己的互联网平台，享用数据中心所提供的一系列服务。</li>
<li>ISP(nternet Service Provider):互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。</li>
<li>ICP(Internet Content Provider):互联网内容提供商，向广大用户综合提供互联网信息业务和增值业务的电信运营商。 根据中华人民共和国国务院令第292号《互联网信息服务管理办法》规定，国家对提供互联网信息服务的ICP实行许可证制度。从而，ICP证成为网站经营的许可证，经营性网站必须办理ICP证，否则就属于非法经营。因此，办理ICP证是企业网站合法经营的需要.</li>
<li>CDN(Content Delivery Network):内容分发网络,依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</li>
<li>LVS(Linux Virtual Server):意即Linux虚拟服务器，是一个虚拟的服务器集群系统。LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。</li>
<li>CGI(Common Gateway Interface)通用网关接口:CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新的交互式媒体.</li>
<li>GSLB(Global Server Load Balance，全局负载均衡:作为 CDN 系统架构中最核心的部分，负责流量调度.基于DNS的GSLB 绝大部分使用负载均衡技术的应用都通过域名来访问目的主机，在用户发出任何应用连接请求时，首先必须通过DNS请求获得服务器的IP地址，基于DNS的GSLB正是在返回DNS解析结果的过程中进行智能决策，给用户返回一个最佳的服务IP。用户应用流程与没有GSLB时未发生任何变化。这也是市场上主流的GSLB技术。</li>
<li>BOSS(Business &amp; Operation Support System，BOSS):是业务运营支撑系统。通常所说的BOSS分为四个部分：计费及结算系统、营业与账务系统、客户服务系统和决策支持系统。BOSS从业务层面来看就是一个框架，来承载业务系统、CRM系统、计费系统。实现统一框架中的纵向、横向管理。该系统最早由电信部门的计费系统发展演变而来，基本功能包括客户资料管理、产品管理、用户订购管理、计费、出帐、结算等，负责登记客户资料、管理用户订购服务的提供、实时的根据不同产品、套餐的资费标准计算业务（手机、固定电话用户通话时、点播收视、宽带流量与时间等）的消费金额，准实时及定期计算用户帐单，实时或定期结算用户各种消费费用。</li>
</ul>

<h2 id="shell编程">shell编程</h2>

<p>Shell的作用是解释执行用户的命令，用户输入一条命令，Shell就解释执行一条，这种方式称为交互式（Interactive），Shell还有一种执行命令的方式称为批处理（Batch），用户事先写一个Shell脚本（Script），其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。<br />
由于历史原因，UNIX系统上有很多种Shell：</p>

<ul>
<li><p>sh（Bourne Shell）：由Steve Bourne开发，各种UNIX系统都配有sh。</p></li>

<li><p>csh（C Shell）：由Bill Joy开发，随BSD UNIX发布，它的流程控制语句很像C语言，支持很多Bourne Shell所不支持的功能：作业控制，命令历史，命令行编辑。</p></li>

<li><p>ksh（Korn Shell）：由David Korn开发，向后兼容sh的功能，并且添加了csh引入的新功能，是目前很多UNIX系统标准配置的Shell，在这些系统上/bin/sh往往是指向/bin/ksh的符号链接。</p></li>

<li><p>tcsh（TENEX C Shell）：是csh的增强版本，引入了命令补全等功能，在FreeBSD、Mac OS X等系统上替代了csh。</p></li>

<li><p>bash（Bourne Again Shell）：由GNU开发的Shell，主要目标是与POSIX标准保持一致，同时兼顾对sh的兼容，bash从csh和ksh借鉴了很多功能，是各种Linux发行版标准配置的Shell，在Linux系统上/bin/sh往往是指向/bin/bash的符号链接。虽然如此，bash和sh还是有很多不同的，一方面，bash扩展了一些命令和参数，另一方面，bash并不完全和sh兼容，有些行为并不一致，所以bash需要模拟sh的行为：当我们通过sh这个程序名启动bash时，bash可以假装自己是sh，不认扩展的命令，并且行为与sh保持一致。</p></li>

<li><p>zsh 的命令补全功能非常强大，可以补齐路径，补齐命令，补齐参数等。</p></li>
</ul>

<p>vim /etc/passwd<br />
其中最后一列显示了用户对应的shell类型</p>

<p>用户在命令行输入命令后，一般情况下Shell会fork并exec该命令，但是Shell的内建命令例外，执行内建命令相当于调用Shell进程中的一个函数，并不创建新的进程。以前学过的cd、alias、umask、exit等命令即是内建命令，凡是用which命令查不到程序文件所在位置的命令都是内建命令，内建命令没有单独的man手册，要在man手册中查看内建命令，应该:<br />
$ man bash-builtins</p>

<p>如export、shift、if、eval、[、for、while等等。内建命令虽然不创建新的进程，但也会有Exit
Status，通常也用0表示成功非零表示失败，虽然内建命令不创建新的进程，但执行结束后也会有一个状态码，也可以用特殊变量$?读出。</p>

<h3 id="执行脚本">执行脚本</h3>

<p>编写一个简单脚本t1.sh:</p>

<pre><code>#! /bin/sh
cd ..
ls
</code></pre>

<p>Shell脚本中用#表示注释，相当于C语言的//注释。但如果#位于第一行开头，并且是#!（称为Shebang）则例外，它表示该脚本使用后面指定的解释器/bin/sh解释执行。如果把这个脚本文件加上可执行权限然后执行：</p>

<pre><code>chmod a+x t1.sh
./t1.sh
</code></pre>

<p>Shell会fork一个子进程并调用exec执行./t1.sh这个程序，exec系统调用应该把子进程的代码段替换成./t1.sh程序的代码段，并从它的_start开始执行。然而t1.sh是个文本文件，根本没有代码段和_start函数，怎么办呢？其实exec还有另外一种机制，如果要执行的是一个文本文件，并且第一行用Shebang指定了解释器，则用解释器程序的代码段替换当前进程，并且从解释器的_start开始执行，而这个文本文件被当作命令行参数传给解释器。因此，执行上述脚本相当于执行程序</p>

<pre><code>$ /bin/sh ./t1.sh
</code></pre>

<p>以这种方式执行不需要test.sh文件具有可执行权限。</p>

<p>如果将命令行下输入的命令用()括号括起来，那么也会fork出一个子Shell执行小括号中的命令，一行中可以输入由分号;隔开的多个命令，比如：</p>

<pre><code>$ (cd ..;ls -l)
</code></pre>

<p>和上面两种方法执行Shell脚本的效果是相同的，cd ..命令改变的是子Shell的PWD，而不会影响到交互式Shell。然而命令</p>

<pre><code>$ cd ..;ls -l
</code></pre>

<p>则有不同的效果，cd ..命令是直接在交互式Shell下执行的，改变交互式Shell的PWD，然而这种方式相当于这样执行Shell脚本：</p>

<pre><code>$ source ./t1.sh
</code></pre>

<p>或者</p>

<pre><code>$ . ./t1.sh
</code></pre>

<p>source或者.命令是Shell的内建命令，这种方式也不会创建子Shell，而是直接在交互式Shell下逐行执行脚本中的命令。</p>

<h3 id="基本语法">基本语法</h3>

<p><strong>变量</strong><br />
有两种变量:</p>

<ul>
<li><p>环境变量<br />
环境变量可以从父进程传给子进程，因此Shell进程的环境变量可以从当前Shell进程传给fork出来的子进程。用printenv命令可以显示当前Shell进程的环境变量。</p></li>

<li><p>本地变量<br />
只存在于当前Shell进程，用set命令可以显示当前Shell进程中定义的所有变量（包括本地变量和环境变量）和函数。<br />
环境变量是任何进程都有的概念，而本地变量是Shell特有的概念。在Shell中，环境变量和本地变量的定义和用法相似。在Shell中定义或赋值一个变量：</p>

<p>$ VARNAME=value</p></li>
</ul>

<p>注意等号两边都不能有空格，否则会被Shell解释成命令和命令行参数。<br />
一个变量定义后仅存在于当前Shell进程，它是本地变量，用export命令可以把本地变量导出为环境变量，定义和导出环境变量通常可以一步完成：</p>

<pre><code>$ export VARNAME=value
</code></pre>

<p>用unset命令可以删除已定义的环境变量或本地变量。</p>

<pre><code>$ unset VARNAME
</code></pre>

<p>如果一个变量叫做VARNAME，用${VARNAME}可以表示它的值，在不引起歧义的情况下也可以用$VARNAME表示它的值。通过以下例子比较这两种表示法的不同：</p>

<pre><code>$ echo $SHELL
</code></pre>

<p>注意，在定义变量时不用 ，取变量值时要用 ， 取 变 量 值 时 要 用
。和C语言不同的是，Shell变量不需要明确定义类型，事实上Shell变量的值都是字符串，比如我们定义VAR=45，其实VAR的值是字符串45而非整数。Shell变量不需要先定义后使用，如果对一个没有定义的变量取值，则值为空字符串。</p>

<p><strong>文件名代换（Globbing）：* ? []</strong><br />
这些用于匹配的字符称为通配符（Wildcard），具体如下：</p>

<pre><code>*   匹配0个或多个任意字符
?   匹配一个任意字符
[若干字符]  匹配方括号中任意一个字符的一次出现

$ ls /dev/ttyS*
$ ls ch0?.doc
$ ls ch0[0-2].doc
$ ls ch[012]   [0-9].doc
</code></pre>

<p>注意，Globbing所匹配的文件名是由Shell展开的，也就是说在参数还没传给程序之前已经展开了，比如上述ls
ch0[012].doc命令，如果当前目录下有ch00.doc和ch02.doc，则传给ls命令的参数实际上是这两个文件名，而不是一个匹配字符串。</p>

<p>**命令代换：<code>或 $()**  
由'</code>‘反引号括起来的也是一条命令，Shell先执行该命令，然后将输出结果立刻代换到当前命令行中。例如定义一个变量存放date命令的输出：</p>

<pre><code>$ DATE=`date`
$ echo $DATE
</code></pre>

<p>命令代换也可以用$()表示：</p>

<pre><code>$ DATE=$(date)
</code></pre>

<p><strong>算术代换：$(())</strong><br />
用于算术计算，$(())中的Shell变量取值将转换成整数，同样含义的$[]等价例如：</p>

<pre><code>$ VAR=45
$ echo $(($VAR+3))
$(())中只能用+-*/和()运算符，并且只能做整数运算。

$[base#n],其中base表示进制,n按照base进制解释，后面再有运算数，按十进制解释。

echo $[2#10+11]
echo $[8#10+11]
echo $[10#10+11]
</code></pre>

<p>*<em>转义字符*</em><br />
和C语言类似，\在Shell中被用作转义字符，用于去除紧跟其后的单个字符的特殊意义（回车除外），换句话说，紧跟其后的字符取字面值。例如：</p>

<pre><code>$ echo $SHELL
/bin/bash
$ echo \$SHELL
$SHELL
$ echo \\
\
</code></pre>

<p>比如创建一个文件名为“$ $”的文件可以这样：</p>

<pre><code>$ touch \$\ \$
</code></pre>

<p>还有一个字符虽然不具有特殊含义，但是要用它做文件名也很麻烦，就是-号。如果要创建一个文件名以-号开头的文件，这样是不行的：</p>

<pre><code>$ touch -hello
touch: invalid option -- h
Try `touch --help' for more information.

即使加上\转义也还是报错：

$ touch \-hello
touch: invalid option -- h
Try `touch --help' for more information.
</code></pre>

<p>因为各种UNIX命令都把-号开头的命令行参数当作命令的选项，而不会当作文件名。如果非要处理以-号开头的文件名，可以有两种办法：</p>

<pre><code>$ touch ./-hello
</code></pre>

<p>或者</p>

<pre><code>$ touch -- -hello
</code></pre>

<p>\还有一种用法，在\后敲回车表示续行，Shell并不会立刻执行命令，而是把光标移到下一行，给出一个续行提示符&gt;，等待用户继续输入，最后把所有的续行接到一起当作一个命令执行。例如：</p>

<pre><code>$ ls \
&gt; -l
（ls -l命令的输出）
</code></pre>

<p><strong>单引号</strong><br />
和C语言不一样，Shell脚本中的单引号和双引号一样都是字符串的界定符（双引号下一节介绍），而不是字符的界定符。单引号用于保持引号内所有字符的字面值，即使引号内的\和回车也不例外，但是字符串中不能出现单引号。如果引号没有配对就输入回车，Shell会给出续行提示符，要求用户把引号配上对。例如：</p>

<pre><code>$ echo '$SHELL'
$SHELL
$ echo 'ABC\（回车）
&gt; DE'（再按一次回车结束命令）
ABC\
DE
</code></pre>

<p>再如：</p>

<pre><code>&gt;DA=$(date)
&gt;echo '$DA'
$DA
</code></pre>

<p><strong>双引号</strong><br />
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引号的处理方式不同</p>

<pre><code>&gt;echo &quot;$DA&quot;
2018年 09月 01日 星期六 12:04:40 CST
</code></pre>

<h3 id="shell脚本语法">shell脚本语法</h3>

<p><strong>条件测试：test[</strong><br />
命令test或[可以测试一个条件是否成立，如果测试结果为真，则该命令的Exit Status为0，如果测试结果为假，则命令的Exit
Status为1（注意与C语言的逻辑表示正好相反）。例如测试两个数的大小关系：</p>

<pre><code>~$ var=2
~$ test $var -gt 1
~$ echo $?
0
~$ test $var -gt 3
~$ echo $?
1
~$ [ $var -gt 3 ]
~$ echo $?
1
~$
</code></pre>

<p>虽然看起来很奇怪，但左方括号[确实是一个命令的名字，传给命令的各参数之间应该用空格隔开，比如，$VAR、-gt、3、]是[命令的四个参数，它们之间必须用空格隔开。命令test或[的参数形式是相同的，只不过test命令不需要]参数。以[命令为例，常见的测试命令如下表所示：</p>

<pre><code>[ -d DIR ]              如果DIR存在并且是一个目录则为真
[ -f FILE ]             如果FILE存在且是一个普通文件则为真
[ -z STRING ]           如果STRING的长度为零则为真
[ -n STRING ]           如果STRING的长度非零则为真
[ STRING1 = STRING2 ]   如果两个字符串相同则为真
[ STRING1 != STRING2 ]  如果字符串不相同则为真
[ ARG1 OP ARG2 ]        ARG1和ARG2应该是整数或者取值为整数的变量，OP是-eq（等于）-ne（不等于）-lt（小于）-le（小于等于）-gt（大于）-ge（大于等于）之中的一个
</code></pre>

<p>和C语言类似，测试条件之间还可以做与、或、非逻辑运算：</p>

<pre><code>带与、或、非的测试命令

[ ! EXPR ]          EXPR可以是上表中的任意一种测试条件，!表示逻辑反
[ EXPR1 -a EXPR2 ]  EXPR1和EXPR2可以是上表中的任意一种测试条件，-a表示逻辑与
[ EXPR1 -o EXPR2 ]  EXPR1和EXPR2可以是上表中的任意一种测试条件，-o表示逻辑或
</code></pre>

<p>例如：</p>

<pre><code>$ VAR=abc
$ [ -d Desktop -a $VAR = 'abc' ]
$ echo $?
0
</code></pre>

<p>注意，如果上例中的$VAR变量事先没有定义，则被Shell展开为空字符串，会造成测试条件的语法错误（展开为[ -d Desktop -a = ‘abc’
]），作为一种好的Shell编程习惯，应该总是把变量取值放在双引号之中（展开为[ -d Desktop -a “” = ‘abc’ ]）：</p>

<pre><code>$ unset VAR
$ [ -d Desktop -a $VAR = 'abc' ]
bash: [: too many arguments
$ [ -d Desktop -a &quot;$VAR&quot; = 'abc' ]
$ echo $?
1
</code></pre>

<p><strong>if/then/elif/else/fi</strong><br />
和C语言类似，在Shell中用if、then、elif、else、fi这几条命令实现分支控制。这种流程控制语句本质上也是由若干条Shell命令组成的，例如先前讲过的</p>

<pre><code>if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi
</code></pre>

<p>其实是三条命令，if [ -f ~/.bashrc ]是第一条，then .
~/.bashrc是第二条，fi是第三条。如果两条命令写在同一行则需要用;号隔开，一行只写一条命令就不需要写;号了，另外，then后面有换行，但这条命令没写完，Shell会自动续行，把下一行接在then后面当作一条命令处理。和[命令一样，要注意命令和各参数之间必须用空格隔开。if命令的参数组成一条子命令，如果该子命令的Exit
Status为0（表示真），则执行then后面的子命令，如果Exit
Status非0（表示假），则执行elif、else或者fi后面的子命令。if后面的子命令通常是测试命令，但也可以是其它命令。Shell脚本没有{}括号，所以用fi表示if语句块的结束。见下例：</p>

<pre><code>#! /bin/sh

if [ -f /bin/bash ]
then echo &quot;/bin/bash is a file&quot;
else echo &quot;/bin/bash is NOT a file&quot;
fi
if :; then echo &quot;always true&quot;; fi
</code></pre>

<p>:是一个特殊的命令，称为空命令，该命令不做任何事，但Exit
Status总是真。此外，也可以执行/bin/true或/bin/false得到真或假的Exit Status。再看一个例子：</p>

<pre><code>   #! /bin/sh

    echo &quot;Is it morning? Please answer yes or no.&quot;
    read YES_OR_NO
    if [ &quot;$YES_OR_NO&quot; = &quot;yes&quot; ]; then
      echo &quot;Good morning!&quot;
    elif [ &quot;$YES_OR_NO&quot; = &quot;no&quot; ]; then
      echo &quot;Good afternoon!&quot;
    else
      echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;
      exit 1
    fi
    exit 0
</code></pre>

<p>上例中的read命令的作用是等待用户输入一行字符串，将该字符串存到一个Shell变量中。</p>

<p>此外，Shell还提供了&amp;&amp;和||语法，和C语言类似，具有Short-circuit特性，很多Shell脚本喜欢写成这样：</p>

<pre><code>test &quot;$(whoami)&quot; != 'root' &amp;&amp; (echo you are using a non-privileged account; exit 1)
</code></pre>

<p>&amp;&amp;相当于“if…then…”，而||相当于“if not…then…”。&amp;&amp;和||用于连接两个命令，而上面讲的-a和-
o仅用于在测试表达式中连接两个测试条件，要注意它们的区别，例如，</p>

<pre><code>test &quot;$VAR&quot; -gt 1 -a &quot;$VAR&quot; -lt 3
</code></pre>

<p>和以下写法是等价的</p>

<pre><code>test &quot;$VAR&quot; -gt 1 &amp;&amp; test &quot;$VAR&quot; -lt 3
</code></pre>

<p><strong>case/esac</strong><br />
case命令可类比C语言的switch/case语句，esac表示case语句块的结束。C语言的case只能匹配整型或字符型常量表达式，而Shell脚本的case可以匹配字符串和Wildcard，每个匹配分支可以有若干条命令，末尾必须以;;结束，执行时找到第一个匹配的分支并执行相应的命令，然后直接跳到esac之后，不需要像C语言一样用break跳出。</p>

<pre><code>   #! /bin/sh

    echo &quot;Is it morning? Please answer yes or no.&quot;
    read YES_OR_NO
    case &quot;$YES_OR_NO&quot; in
    yes|y|Yes|YES)
      echo &quot;Good Morning!&quot;;;
    [nN]*)
      echo &quot;Good Afternoon!&quot;;;
    *)
      echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;
      exit 1;;
    esac
    exit 0
</code></pre>

<p>使用case语句的例子可以在系统服务的脚本目录/etc/init.d中找到。这个目录下的脚本大多具有这种形式（以/etc/init.d/nfs-
kernel-server为例）：</p>

<pre><code>    case &quot;$1&quot; in
        start)
            ...
        ;;
        stop)
            ...
        ;;
        reload | force-reload)
            ...
        ;;
        restart)
        ...
        *)
            log_success_msg &quot;Usage: nfs-kernel-server {start|stop|status|reload|force-reload|restart}&quot;
            exit 1
        ;;
    esac
</code></pre>

<p>启动nfs-kernel-server服务的命令是</p>

<pre><code>$ sudo /etc/init.d/nfs-kernel-server start
</code></pre>

<p>$1是一个特殊变量，在执行脚本时自动取值为第一个命令行参数，也就是start，所以进入start)分支执行相关的命令。同理，命令行参数指定为stop、reload或restart可以进入其它分支执行停止服务、重新加载配置文件或重新启动服务的相关命令。</p>

<p><strong>for/do/done</strong><br />
Shell脚本的for循环结构和C语言很不一样，它类似于某些编程语言的foreach循环。例如：</p>

<pre><code> #! /bin/sh

    for FRUIT in apple banana pear; do
      echo &quot;I like $FRUIT&quot;
    done
</code></pre>

<p>FRUIT是一个循环变量，第一次循环$FRUIT的取值是apple，第二次取值是banana，第三次取值是pear。再比如，要将当前目录下的chap0、chap1、chap2等文件名改为chap0~、chap1~、chap2~等（按惯例，末尾有~字符的文件名表示临时文件），这个命令可以这样写：</p>

<pre><code>$ for FILENAME in chap?; do mv $FILENAME $FILENAME~; done
</code></pre>

<p><strong>while/do/done</strong><br />
while的用法和C语言类似。比如一个验证密码的脚本：</p>

<pre><code>    #! /bin/sh

    echo &quot;Enter password:&quot;
    read TRY
    while [ &quot;$TRY&quot; != &quot;secret&quot; ]; do
      echo &quot;Sorry, try again&quot;
      read TRY
    done
</code></pre>

<p>下面的例子通过算术运算控制循环的次数：</p>

<pre><code>    #! /bin/sh

    COUNTER=1
    while [ &quot;$COUNTER&quot; -lt 10 ]; do
      echo &quot;Here we go again&quot;
      COUNTER=$(($COUNTER+1))
    done
</code></pre>

<p>Shell还有until循环，类似C语言的do…while循环</p>

<p><strong>break和continue</strong><br />
break[n]可以指定跳出几层循环，continue跳过本次循环步，没跳出整个循环。<br />
break跳出，continue跳过。</p>

<p><strong>位置参数和特殊变量</strong><br />
有很多特殊变量是被Shell自动赋值的，我们已经遇到了 ?和 ? 和 1，现在总结一下：<br />
常用的位置参数和特殊变量</p>

<pre><code>$0  相当于C语言main函数的argv[0]
$1、$2...    这些称为位置参数（Positional Parameter），相当于C语言main函数的argv[1]、argv[2]...
$#  相当于C语言main函数的argc - 1，注意这里的#后面不表示注释
$@  表示参数列表&quot;$1&quot; &quot;$2&quot; ...，例如可以用在for循环中的in后面。
$*  表示参数列表&quot;$1&quot; &quot;$2&quot; ...，同上
$?  上一条命令的Exit Status
$$  当前进程号
</code></pre>

<p>位置参数可以用shift命令左移。比如shift
3表示原来的$4现在变成$1，原来的$5现在变成$2等等，原来的$1、$2、$3丢弃，$0不移动。不带参数的shift命令相当于shift 1。例如：</p>

<pre><code>    #! /bin/sh

    echo &quot;The program $0 is now running&quot;
    echo &quot;The first parameter is $1&quot;
    echo &quot;The second parameter is $2&quot;
    echo &quot;The parameter list is $@&quot;
    shift
    echo &quot;The first parameter is $1&quot;
    echo &quot;The second parameter is $2&quot;
    echo &quot;The parameter list is $@&quot;
</code></pre>

<h3 id="shell输入输出">shell输入输出</h3>

<p><strong>echo</strong><br />
echo显示文本行或变量，或者把字符串输入到文件。</p>

<pre><code>echo [option] string
-e 解析转义字符
-n 不回车换行。默认情况echo回显的内容后面跟一个回车换行。
echo &quot;hello\n\n&quot;
echo -e &quot;hello\n\n&quot;
echo  &quot;hello&quot;
echo -n &quot;hello&quot;
</code></pre>

<p><strong>管道|</strong><br />
可以通过管道把一个命令的输出传递给另一个命令做输入。管道用竖线表示。</p>

<pre><code>cat myfile | more
ls -l | grep &quot;myfile&quot;
df -k | awk '{print $1}' | grep -v &quot;文件系统&quot;
df -k 查看磁盘空间，找到第一列，去除“文件系统”，并输出
</code></pre>

<p><strong>tee</strong><br />
tee命令把结果输出到标准输出，另一个副本输出到相应文件。</p>

<pre><code>df -k | awk '{print $1}' | grep -v &quot;文件系统&quot; | tee a.txt
tee -a a.txt表示追加操作。
df -k | awk '{print $1}' | grep -v &quot;文件系统&quot; | tee -a a.txt
</code></pre>

<p><strong>文件重定向</strong></p>

<pre><code>cmd &gt; file             把标准输出重定向到新文件中
cmd &gt;&gt; file            追加
cmd &gt; file 2&gt;&amp;1        标准出错也重定向到1所指向的file里
cmd &gt;&gt; file 2&gt;&amp;1
cmd &lt; file1 &gt; file2    输入输出都定向到文件里
cmd &lt; &amp;fd              把文件描述符fd作为标准输入
cmd &gt; &amp;fd              把文件描述符fd作为标准输出
cmd &lt; &amp;-               关闭标准输入
</code></pre>

<p><strong>函数</strong><br />
和C语言类似，Shell中也有函数的概念，但是函数定义中没有返回值也没有参数列表。例如：</p>

<pre><code>    #! /bin/sh

    foo(){ echo &quot;Function foo is called&quot;;}
    echo &quot;-=start=-&quot;
    foo
    echo &quot;-=end=-&quot;
</code></pre>

<p>注意函数体的左花括号’{‘和后面的命令之间必须有空格或换行，如果将最后一条命令和右花括号’}’写在同一行，命令末尾必须有;号。</p>

<p>在定义foo()函数时并不执行函数体中的命令，就像定义变量一样，只是给foo这个名字一个定义，到后面调用foo函数的时候（注意Shell中的函数调用不写括号）才执行函数体中的命令。Shell脚本中的函数必须先定义后调用，一般把函数定义都写在脚本的前面，把函数调用和其它命令写在脚本的最后（类似C语言中的main函数，这才是整个脚本实际开始执行命令的地方）。</p>

<p>Shell函数没有参数列表并不表示不能传参数，事实上，函数就像是迷你脚本，调用函数时可以传任意个参数，在函数内同样是用 0、 0 、 1、
2等变量来提取参数，函数中的位置参数相当于函数的局部变量，改变这些变量并不会影响函数外面的 2 等 变 量 来 提 取 参 数 ， 函 数 中 的 位 置
参 数 相 当 于 函 数 的 局 部 变 量 ， 改 变 这 些 变 量 并 不 会 影 响 函 数 外 面 的 0、 1、 1 、
2等变量。函数中可以用return命令返回，如果return后面跟一个数字则表示函数的Exit Status。</p>

<p>下面这个脚本可以一次创建多个目录，各目录名通过命令行参数传入，脚本逐个测试各目录是否存在，如果目录不存在，首先打印信息然后试着创建该目录。</p>

<pre><code>    #! /bin/sh

    is_directory()
    {
      DIR_NAME=$1
      if [ ! -d $DIR_NAME ]; then
        return 1
      else
        return 0
      fi
    }

    for DIR in &quot;$@&quot;; do
      if is_directory &quot;$DIR&quot;
      then :
      else
        echo &quot;$DIR doesn't exist. Creating it now...&quot;
        mkdir $DIR &gt; /dev/null 2&gt;&amp;1
        if [ $? -ne 0 ]; then
          echo &quot;Cannot create directory $DIR&quot;
          exit 1
        fi
      fi
    done
</code></pre>

<p>注意is_directory()返回0表示真返回1表示假。</p>

<p><strong>Shell脚本的调试方法</strong><br />
Shell提供了一些用于调试脚本的选项，如下所示：<br />
-n<br />
读一遍脚本中的命令但不执行，用于检查脚本中的语法错误<br />
-v<br />
一边执行脚本，一边将执行过的脚本命令打印到标准错误输出<br />
-x<br />
提供跟踪执行信息，将执行的每一条命令和结果依次打印出来<br />
使用这些选项有三种方法，一是在命令行提供参数<br />
$ sh -x ./script.sh<br />
二是在脚本开头提供参数</p>

<pre><code> #! /bin/sh -x
</code></pre>

<p>第三种方法是在脚本中用set命令启用或禁用参数</p>

<pre><code> #! /bin/sh
    if [ -z &quot;$1&quot; ]; then
      set -x
      echo &quot;ERROR: Insufficient Args.&quot;
      exit 1
      set +x
    fi
</code></pre>

<p>set -x和set +x分别表示启用和禁用-x参数，这样可以只对脚本中的某一段进行跟踪调试。</p>

<h2 id="shell常用工具">shell常用工具</h2>

<h3 id="grep">grep</h3>

<p><strong>作用</strong><br />
Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular
Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>

<p>grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符，
fgrep就是fixed grep或fast
grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p>

<p><strong>格式</strong><br />
grep [options]</p>

<p><strong>主要参数</strong></p>

<pre><code>grep --help

[options]主要参数：
-c：只输出匹配行的计数。
-i：不区分大小写。
-h：查询多文件时不显示文件名。
-l：查询多文件时只输出包含匹配字符的文件名。
-n：显示匹配行及 行号。
-s：不显示不存在或无匹配文本的错误信息。
-v：显示不包含匹配文本的所有行。
--color=auto ：可以将找到的关键词部分加上颜色的显示。
</code></pre>

<p>pattern正则表达式主要参数：</p>

<pre><code>\： 忽略正则表达式中特殊字符的原有含义。
^：匹配正则表达式的开始行。
$: 匹配正则表达式的结束行。
\：到匹配正则表达式的行结束。
[ ]：单个字符，如[A]即A符合要求 。
[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
.：所有的单个字符。
*：有字符，长度可以为0。
</code></pre>

<p><strong>grep命令使用简单实例</strong></p>

<pre><code>$ grep ‘test’ d*
显示所有以d开头的文件中包含 test的行。

$ grep ‘test’ aa bb cc
显示在aa，bb，cc文件中匹配test的行。

$ grep ‘[a-z]\{5\}’ aa
显示所有包含每个字符串至少有5个连续小写字符的字符串的行。

$ grep ‘w\(es\)t.*\1′ aa
如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.*\1′就可以了。
</code></pre>

<p><strong>grep命令使用复杂实例</strong><br />
明确要求搜索子目录：</p>

<pre><code>grep -r
</code></pre>

<p>或忽略子目录：</p>

<pre><code>grep -d skip
</code></pre>

<p>如果有很多输出时，您可以通过管道将其转到’less’上阅读：</p>

<pre><code>$ grep magic /usr/src/Linux/Documentation/* | less
</code></pre>

<p>这样，您就可以更方便地阅读。</p>

<p>有一点要注意，您必需提供一个文件过滤方式(搜索全部文件的话用 *)。如果您忘了，’grep’会一直等着，直到该程序被中断。如果您遇到了这样的情况，按
，然后再试。</p>

<p>下面还有一些有意思的命令行参数：</p>

<pre><code>grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，
grep -C number pattern files ：匹配的上下文分别显示[number]行，
grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，
例如：grep &quot;abc\|xyz&quot; testfile    表示过滤包含abc或xyz的行
grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。

grep -n pattern files  即可显示行号信息

grep -c pattern files  即可查找总行数
</code></pre>

<p>这里还有些用于搜索的特殊符号：</p>

<pre><code>\&lt; 和 \&gt; 分别标注单词的开始与结尾。
例如：
grep man * 会匹配 ‘Batman’、’manic’、’man’等，
grep ‘\’ 只匹配’man’，而不是’Batman’或’manic’等其他的字符串。
‘^’：指匹配的字符串在行首，
‘$’：指匹配的字符串在行 尾，
</code></pre>

<h3 id="find">find</h3>

<p>由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统(
NFS)，find命令在该文件系统中同样有效，只要你具有相应的权限。</p>

<p>在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。</p>

<p><strong>find 命令格式</strong></p>

<ul>
<li><p>find命令的一般形式为</p>

<p>find pathname -options [-print -exec -ok &hellip;]</p></li>

<li><p>find命令的参数</p>

<p>pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录，递归查找。
-print： find命令将匹配的文件输出到标准输出。
-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&rsquo;command&rsquo; {  } \;，注意{   }和\；之间的空格。
-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p></li>

<li><p>find命令选项</p>

<p>-name   按照文件名查找文件。
-perm   按照文件权限来查找文件。
-prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。
-user   按照文件属主来查找文件。
-group  按照文件所属的组来查找文件。
-mtime -n +n 按照文件的更改时间来查找文件，-n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。
-nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。
-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。
-type   查找某一类型的文件，诸如：
    b - 块设备文件。
    d - 目录。
    c - 字符设备文件。
    p - 管道文件。
    l - 符号链接文件。
    f - 普通文件。
-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
-depth   在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
-fstype  查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。
-mount   在查找文件时不跨越文件系统mount点。
-follow  如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。</p></li>
</ul>

<p>另外,下面三个的区别:</p>

<pre><code>-amin n   查找系统中最后N分钟访问的文件
-atime n  查找系统中最后n*24小时访问的文件
-cmin n   查找系统中最后N分钟被改变文件状态的文件
-ctime n  查找系统中最后n*24小时被改变文件状态的文件
-mmin n   查找系统中最后N分钟被改变文件数据的文件
-mtime n  查找系统中最后n*24小时被改变文件数据的文件
</code></pre>

<p><strong>使用exec或ok来执行shell命令</strong><br />
使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便 在有些操作系统中只允许-exec选项执行诸如ls或ls
-l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。</p>

<p>exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。</p>

<p>例如：为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中</p>

<pre><code># find . -type f -exec ls -l {} \;
</code></pre>

<p>上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。</p>

<p>在/logs目录中查找更改时间在5日以前的文件并删除它们：</p>

<pre><code>$ find logs -type f -mtime +5 -exec rm {} \;
</code></pre>

<p>记住：在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-
exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。</p>

<p>在下面的例子中， find命令在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。</p>

<pre><code>$ find . -name &quot;*.conf&quot;  -mtime +5 -ok rm {  } \;
&lt; rm ... ./conf/httpd.conf &gt; ? n
</code></pre>

<p>按y键删除文件，按n键不删除。</p>

<p>任何形式的命令都可以在-exec选项中使用。</p>

<p>在下面的例子中我们使用grep命令。find命令首先匹配所有文件名为“
passwd*”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个itcast用户。</p>

<pre><code># find /etc -name &quot;passwd*&quot; -exec grep &quot;itcast&quot; {  } \;
itcast:x:1000:1000::/home/itcast:/bin/bash
</code></pre>

<p><strong>选项详解</strong><br />
文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。</p>

<p>可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。</p>

<p>不管当前路径是什么，如果想要在自己的根目录$HOME中查找文件名符合*.txt的文件，使用~作为
‘pathname’参数，波浪号~代表了你的$HOME目录。</p>

<pre><code>$ find ~ -name &quot;*.txt&quot; -print
</code></pre>

<p>想要在当前目录及子目录中查找所有的‘ *.txt’文件，可以用：</p>

<pre><code>$ find . -name &quot;*.txt&quot; -print
</code></pre>

<p>想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：</p>

<pre><code>$ find . -name &quot;[A-Z]*&quot; -print
</code></pre>

<p>想要在/etc目录中查找文件名以host开头的文件，可以用：</p>

<pre><code>$ find /etc -name &quot;host*&quot; -print
</code></pre>

<p>想要查找$HOME目录中的文件，可以用：</p>

<pre><code>$ find ~ -name &quot;*&quot; -print 或find . -print
</code></pre>

<p>要想让系统高负荷运行，就从根目录开始查找所有的文件：</p>

<pre><code>$ find / -name &quot;*&quot; -print
</code></pre>

<p>如果想在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是.txt的文件，下面的命令就能够返回例如名为ax37.txt的文件：</p>

<pre><code>$find . -name &quot;[a-z][a-z][0-9][0-9].txt&quot; -print
</code></pre>

<p><strong>用perm选项</strong><br />
按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。</p>

<p>如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：</p>

<pre><code>$ find . -perm 755 -print
</code></pre>

<p>还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-006相当于666</p>

<pre><code># ls -l
# find . -perm 006
# find . -perm -006

-perm mode:文件许可正好符合mode
-perm +mode:文件许可部分符合mode
-perm -mode: 文件许可完全符合mode
</code></pre>

<p><strong>忽略某个目录</strong><br />
如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-
prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。</p>

<p>如果希望在/apps目录下查找文件，但不希望在/apps/bin目录下查找，可以用：</p>

<pre><code>$ find /apps -path &quot;/apps/bin&quot; -prune -o -print
</code></pre>

<p><strong>使用find查找文件的时候怎么避开某个文件目录</strong><br />
比如要在/home/itcast目录下查找不在dir1子目录之内的所有文件</p>

<pre><code>find /home/itcast -path &quot;/home/itcast/dir1&quot; -prune -o -print
</code></pre>

<p>避开多个文件夹</p>

<pre><code>find /home \( -path /home/itcast/f1 -o -path /home/itcast/f2 \) -prune -o -print
</code></pre>

<p>注意(前的,注意(后的空格。</p>

<p><strong>使用user和nouser选项</strong><br />
按文件属主查找文件，如在$HOME目录中查找文件属主为itcast的文件，可以用：</p>

<pre><code>$ find ~ -user itcast -print
</code></pre>

<p>在/etc目录下查找文件属主为uucp的文件：</p>

<pre><code>$ find /etc -user uucp -print
</code></pre>

<p>为了查找属主帐户已经被删除的文件，可以使用-nouser选项。这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-
nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。</p>

<p>例如，希望在/home目录下查找所有的这类文件，可以用：</p>

<pre><code>$ find /home -nouser -print
</code></pre>

<p><strong>使用group和nogroup选项</strong><br />
就像user和nouser选项一样，针对文件所属于的用户组， find命令也具有同样的选项，为了在/apps目录下查找属于itcast用户组的文件，可以用：</p>

<pre><code>$ find /apps -group itcast -print
</code></pre>

<p>要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件</p>

<pre><code>$ find / -nogroup -print
</code></pre>

<p><strong>按照更改时间或访问时间等查找文件</strong><br />
如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。</p>

<p>用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。</p>

<p>希望在系统根目录下查找更改时间在5日以内的文件，可以用：</p>

<pre><code>$ find / -mtime -5 -print
</code></pre>

<p>为了在/var/adm目录下查找更改时间在3日以前的文件，可以用：</p>

<pre><code>$ find /var/adm -mtime +3 -print
</code></pre>

<p><strong>查找比某个文件新或旧的文件</strong><br />
如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。它的一般形式为：</p>

<pre><code>newest_file_name ! oldest_file_name
其中，！是逻辑非符号。
</code></pre>

<p><strong>使用type选项</strong><br />
在/etc目录下查找所有的目录，可以用：</p>

<pre><code>$ find /etc -type d -print
</code></pre>

<p>还有很多就不一一列举了。</p>

<h3 id="xargs">xargs</h3>

<p>xargs - build and execute command lines from standard input</p>

<p>在使用find命令的-exec选项处理匹配到的文件时，
find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现
溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。</p>

<p>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-
exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p>

<p>在有些系统中，使用-
exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；</p>

<p>而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。</p>

<p>来看看xargs命令是如何同find命令一起使用的，并给出一些例子。<br />
下面的例子查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文 件</p>

<pre><code>#find . -type f -print | xargs file
</code></pre>

<p>在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：</p>

<pre><code># ls -l
# find . -perm -7 -print | xargs chmod o-w
# ls -l
</code></pre>

<p>用grep命令在所有的普通文件中搜索hello这个词：</p>

<pre><code># find . -type f -print | xargs grep &quot;hello&quot;
</code></pre>

<p>用grep命令在当前目录下的所有普通文件中搜索hello这个词：</p>

<pre><code># find . -name \* -type f -print | xargs grep &quot;hello&quot;
</code></pre>

<p>注意，在上面的例子中， \用来取消find命令中的*在shell中的特殊含义。</p>

<p>find命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。</p>

<h3 id="sed">sed</h3>

<p>sed意为流编辑器（Stream
Editor），在Shell脚本和Makefile中作为过滤器使用非常普遍，也就是把前一个程序的输出引入sed的输入，经过一系列编辑命令转换为另一种格式输出。sed和vi都源于早期UNIX的ed工具，所以很多sed命令和vi的末行命令是相同的。<br />
sed命令行的基本格式为</p>

<pre><code>sed option 'script' file1 file2 ...
sed option -f scriptfile file1 file2 ...
</code></pre>

<p>选项含义：</p>

<pre><code>--version            显示sed版本。
--help               显示帮助文档。
-n,--quiet,--silent  静默输出，默认情况下，sed程序在所有的脚本指令执行完毕后，将自动打印模式空间中的内容，这些选项可以屏蔽自动打印。
-e script            允许多个脚本指令被执行。
-f script-file, 
--file=script-file   从文件中读取脚本指令，对编写自动脚本程序来说很棒！
-i,--in-place        直接修改源文件，经过脚本指令处理后的内容将被输出至源文件（源文件被修改）慎用！
-l N, --line-length=N 该选项指定l指令可以输出的行长度，l指令用于输出非打印字符。
--posix             禁用GNU sed扩展功能。
-r, --regexp-extended  在脚本指令中使用扩展正则表达式
-s, --separate      默认情况下，sed将把命令行指定的多个文件名作为一个长的连续的输入流。而GNU sed则允许把他们当作单独的文件，这样如正则表达式则不进行跨文件匹配。
-u, --unbuffered    最低限度的缓存输入与输出。
</code></pre>

<p>这里就简单介绍几个脚本指令操作作为sed程序的例子。</p>

<pre><code>a,append        追加
i,insert        插入
d,delete        删除
s,substitution  替换
</code></pre>

<p>如：$ sed “2a itcast” ./testfile 在输出testfile内容的第二行后添加”itcast”。</p>

<pre><code>$ sed &quot;2,5d&quot; testfile
</code></pre>

<p><strong>常用的sed命令</strong><br />
/pattern/p 打印匹配pattern的行<br />
/pattern/d 删除匹配pattern的行<br />
/pattern/s/pattern1/pattern2/ 查找符合pattern的行，将该行第一个匹配pattern1的字符串替换为pattern2<br />
/pattern/s/pattern1/pattern2/g 查找符合pattern的行，将该行所有匹配pattern1的字符串替换为pattern2</p>

<p>使用p命令需要注意，sed是把待处理文件的内容连同处理结果一起输出到标准输出的，因此p命令表示除了把文件内容打印出来之外还额外打印一遍匹配pattern的行。比如一个文件testfile的内容是</p>

<pre><code>123
abc
456
</code></pre>

<p>打印其中包含abc的行</p>

<pre><code>$ sed '/abc/p' testfile
123
abc
abc
456
</code></pre>

<p>要想只输出处理结果，应加上-n选项，这种用法相当于grep命令</p>

<pre><code>$ sed -n '/abc/p' testfile
abc
</code></pre>

<p>使用d命令就不需要-n参数了，比如删除含有abc的行</p>

<pre><code>$ sed '/abc/d' testfile
123
456
</code></pre>

<p>注意，sed命令不会修改原文件，删除命令只表示某些行不打印输出，而不是从原文件中删去。</p>

<p>使用查找替换命令时，可以把匹配pattern1的字符串复制到pattern2中，比如：</p>

<pre><code>$ sed 's/bc/-&amp;-/' testfile
123
a-bc-
456
pattern2中的&amp;表示原文件的当前行中与pattern1相匹配的字符串
</code></pre>

<p>再比如：</p>

<pre><code>$ sed 's/\([0-9]\)\([0-9]\)/-\1-~\2~/' testfile
-1-~2~3
abc
-4-~5~6
</code></pre>

<p>pattern2中的\1表示与pattern1的第一个()括号相匹配的内容，\2表示与pattern1的第二个()括号相匹配的内容。sed默认使用Basic正则表达式规范，如果指定了-
r选项则使用Extended规范，那么()括号就不必转义了。</p>

<pre><code>$ sed  's/yes/no/;s/static/dhcp/'  ./testfile
注：使用分号隔开指令。

$ sed -e 's/yes/no/' -e 's/static/dhcp/' testfile
注：使用-e选项。
</code></pre>

<h3 id="awk">awk</h3>

<p>sed以行为单位处理文件，awk比sed强的地方在于不仅能以行为单位还能以列为单位处理文件。awk缺省的行分隔符是换行，缺省的列分隔符是连续的空格和Tab，但是行分隔符和列分隔符都可以自定义，比如/etc/passwd文件的每一行有若干个字段，字段之间以:分隔，就可以重新定义awk的列分隔符为:并以列为单位处理这个文件。awk实际上是一门很复杂的脚本语言，还有像C语言一样的分支和循环结构，但是基本用法和sed类似，awk命令行的基本形式为：</p>

<pre><code>awk option 'script' file1 file2 ...
awk option -f scriptfile file1 file2 ...
</code></pre>

<p>和sed一样，awk处理的文件既可以由标准输入重定向得到，也可以当命令行参数传入，编辑命令可以直接当命令行参数传入，也可以用-
f参数指定一个脚本文件，编辑命令的格式为：</p>

<pre><code>/pattern/{actions}
condition{actions}
</code></pre>

<p>和sed类似，pattern是正则表达式，actions是一系列操作。awk程序一行一行读出待处理文件，如果某一行与pattern匹配，或者满足condition条件，则执行相应的actions，如果一条awk命令只有actions部分，则actions作用于待处理文件的每一行。比如文件testfile的内容表示某商店的库存量：</p>

<pre><code>ProductA  30
ProductB  76
ProductC  55
</code></pre>

<p>打印每一行的第二列:</p>

<pre><code>$ awk '{print $2;}' testfile
30
76
55
</code></pre>

<p>自动变量$1、$2分别表示第一列、第二列等，类似于Shell脚本的位置参数，而$0表示整个当前行。再比如，如果某种产品的库存量低于75则在行末标注需要订货：</p>

<pre><code>$ awk '$2&lt;75 {printf &quot;%s\t%s\n&quot;, $0, &quot;REORDER&quot;;} $2&gt;=75 {print $0;}' testfile
ProductA  30    REORDER
ProductB  76
ProductC  55    REORDER
</code></pre>

<p>可见awk也有和C语言非常相似的printf函数。awk命令的condition部分还可以是两个特殊的condition－BEGIN和END，对于每个待处理文件，BEGIN后面的actions在处理整个文件之前执行一次，END后面的actions在整个文件处理完之后执行一次。</p>

<p>awk命令可以像C语言一样使用变量（但不需要定义变量），比如统计一个文件中的空行数</p>

<pre><code>$ awk '/^ *$/ {x=x+1;} END {print x;}' testfile
</code></pre>

<p>就像Shell的环境变量一样，有些awk变量是预定义的有特殊含义的：</p>

<p>awk常用的内建变量</p>

<pre><code>FILENAME  当前输入文件的文件名，该变量是只读的
NR  当前行的行号，该变量是只读的，R代表record
NF  当前行所拥有的列数，该变量是只读的，F代表field
OFS 输出格式的列分隔符，缺省是空格
FS  输入文件的列分融符，缺省是连续的空格和Tab
ORS 输出格式的行分隔符，缺省是换行符
RS  输入文件的行分隔符，缺省是换行符
</code></pre>

<p>例如打印系统中的用户帐号列表</p>

<pre><code>$ awk 'BEGIN {FS=&quot;:&quot;} {print $1;}' /etc/passwd
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>