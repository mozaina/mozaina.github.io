<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linux基础入门基础命令vishell | 开发者问答集锦</title>
    <meta property="og:title" content="linux基础入门基础命令vishell - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linux基础入门基础命令vishell">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4vishell/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linux基础入门基础命令vishell</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="文章目录">文章目录</h3>

<ul>
<li>Part one - 基础命令

<ul>
<li>1、命令</li>
<li>2、导航</li>
<li>4 文件与目录</li>
<li>5 使用命令</li>
<li>6 重定向</li>
<li>7 符号变量</li>
<li>8 高级键盘技巧</li>
<li>9 权限</li>
<li>10 进程</li>
</ul></li>
<li>Part two – 配置与环境变量

<ul>
<li>11 环境</li>
<li>12 vi 简介</li>
<li>13 自定义提示</li>
</ul></li>
<li>Part three – 常见任务和基本工具

<ul>
<li>14 – 包管理</li>
<li>15 存储介质</li>
<li>16 网络</li>
<li>17 文件搜索</li>
<li>18 存档和备份</li>
<li>19 – 正则表达式</li>
<li>20 文本处理</li>
<li>21 格式化输出</li>
<li>22 打印

<ul>
<li>1. CUPS (Common Unix Printing System) ：provides print drivers and print-job management</li>
<li>2. Ghostscript： a PostScript interpreter, acts as a RIP.</li>
<li>3. CUPS 有两种printing，lpr, lp.</li>
</ul></li>
<li>23 程序编译</li>
</ul></li>
<li>Part four - 编写shell脚本

<ul>
<li>24 – 开始你的第一个脚本</li>
<li>25 开始</li>
<li>26 自上而下的设计</li>
<li>27 流程控制：if分支</li>
<li>28 读取键盘输入</li>
<li>29 – 流程控制：while/until</li>
<li>30 – Troubleshooting</li>
<li>31 流程控制 case分支</li>
<li>32 位置参数</li>
<li>33 流程控制:for循环</li>
<li>34 字符与数字</li>
<li>35 数组</li>
<li>36 特殊</li>
<li>37 asynchronous execution</li>
<li>问题</li>
<li>需要了解的知识</li>
</ul></li>
</ul>

<h1 id="part-one-基础命令">Part one - 基础命令</h1>

<h2 id="1-命令">1、命令</h2>

<ol>
<li><p>date</p></li>

<li><p>cal -calendar</p></li>

<li><p>df -current amount of free space on your disk drives</p></li>

<li><p>free -display the amount of free memory</p></li>

<li><p>exit -closing the terminal emulator window</p></li>

<li><p>crontab 定时任务<br />
通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell
script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。<br />
<strong>crontab的文件格式：分 时 日 月 星期 要运行的命令</strong></p></li>
</ol>

<blockquote>
<p>第1列分钟0～59<br />
 第2列小时0～23（0表示子夜）<br />
 第3列日1～31<br />
 第4列月1～12<br />
 第5列星期0～7（0和7表示星期天）<br />
 第6列要运行的命令</p>
</blockquote>

<pre><code>    * * * * * echo &quot;hello&quot; #每1分钟执行hello
3,15 * * * * myCommand #每小时第三分钟和第十五分钟执行
3,15 8-11 * * * myCommand# 在上午8点到11点的第3和第15分钟执行
3,15 8-11 */2  *  * myCommand #每隔两天的上午8点到11点的第3和第15分钟执行
30 21 * * * /etc/init.d/smb restart #每晚的21:30重启smb
0 23 * * 6 /etc/init.d/smb restart #每星期六的晚上11 : 00 pm重启smb
</code></pre>

<p><strong>注意事项:</strong><br />
新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>

<p>当crontab失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f
/var/log/cron。</p>

<pre><code>    $service cron restart
</code></pre>

<h2 id="2-导航">2、导航</h2>

<ol>
<li>pwd - Print name of current working directory</li>
<li>cd - Change directory</li>
<li>ls - List directory contents</li>
<li>file – Determine file type</li>
<li>less – View file contents（和cat的区别？参考）</li>
</ol>

<h2 id="4-文件与目录">4 文件与目录</h2>

<ol>
<li>cp #如果文件已经存在，直接覆盖，没有提示，要提示用-i</li>
<li>mv</li>
<li>mkdir</li>
<li>rm # Remove Files And Directories</li>
<li>ln # Create Links，软链接”和“硬链接”的区别：硬链接指向磁盘区块，软链接指向绝对路径。</li>
</ol>

<p>hard links的缺点：</p>

<blockquote>
<ol>
<li>cannot span physical devices.</li>
<li>cannot reference directories, only files.</li>
</ol>
</blockquote>

<h2 id="5-使用命令">5 使用命令</h2>

<ol>
<li><p>type – Indicate how a command name is interpreted</p></li>

<li><p>which – Display An Executable’s Location</p></li>

<li><p>help – Get help for shell builtins</p>

<pre><code> help cd
</code></pre>

<p>cd: cd [-L|[-P [-e]] [-@]] [dir]
 Change the shell working directory.</p></li>
</ol>

<p>理解注释：[]是可选，|是互斥。</p>

<ol>
<li><p>-help – Display Usage Information</p></li>

<li><p>man – Display a command’s manual page</p></li>

<li><p>info – Display a command’s info entry</p></li>
</ol>

<p>man .info .–help 的用法和区别：help最简单，info最详细，man在两者之间。</p>

<ol>
<li><p>apropos – Display a list of appropriate commands</p></li>

<li><p>whatis – Display a very brief description of a command</p></li>

<li><p>alias – Create an alias for a command</p></li>
</ol>

<p>使用：</p>

<pre><code>    #起别名前先检查是否存在，用type：
tsc@tsc:~$ type test
test is a shell builtin

alias name='string' # name后不能有空格
tsc@tsc:~$ alias foo='cd /usr; ls; cd -'
tsc@tsc:~$ foo
</code></pre>

<p>终端关闭后作用就消失了。</p>

<ol>
<li>unalias &ndash;去除别名</li>
</ol>

<h2 id="6-重定向">6 重定向</h2>

<ol>
<li><p>cat - Concatenate files</p>

<pre><code># cat file1 # 输出文件到屏幕，没有分页
</code></pre>

<p>cat &gt; file.txt # cat没有参数时接受stdin*
this is test.</p>

<h1 id="ctrl-d-结束">ctrl+d 结束*</h1>

<h1 id="接受文件输入">&lt; 接受文件输入*</h1>

<p>tsc@tsc:~$ cat &lt; lazy_dog.txt</p></li>

<li><p>sort - Sort lines of text</p></li>

<li><p>uniq - Report or omit repeated lines</p>

<pre><code># -d 显示重复的
</code></pre>

<p>tsc@tsc:~$ ls /bin /usr/bin | sort | uniq -d | less</p></li>

<li><p>grep - Print lines matching a pattern</p>

<pre><code>#“global regular expression print”,find功能。
</code></pre>

<p>tsc@tsc:~$ ls /bin /usr/bin | sort | uniq | grep zip</p></li>

<li><p>wc - Print newline, word, and byte counts for each file</p>

<pre><code>#联合使用看条目个数：
</code></pre>

<p>tsc@tsc:~$ ls /bin /usr/bin | sort | uniq | wc -l</p></li>

<li><p>head - Output the first part of a file</p></li>

<li><p>tail - Output the last part of a file</p></li>

<li><p>tee - Read from standard input and write to standard output and files</p></li>
</ol>

<p>这个名字很有意思，tee有三通管的意思，配合pipe使用，它的作用是从stdin读入，复制到stdout和文件。</p>

<pre><code>    # 一方面输出到ls.txt，一方面传给grep
tsc@tsc:~$ ls /usr/bin/ | tee ls.txt | grep zip
</code></pre>

<p>I/O redirection 的作用</p>

<p>I/O redirection allows us to change where output goes and where input comes
from.</p>

<blockquote>
<p>重定向</p>
</blockquote>

<pre><code>tsc@tsc:~$ ls -l /usr/bin/ &gt; ls-output.txt
tsc@tsc:~$ &gt; ls-output2.txt  # 创建一个空文件
# 要注意重复&gt;时，原来的文件会被清空。
</code></pre>

<blockquote>
<blockquote>
<p>追加</p>
</blockquote>
</blockquote>

<pre><code>tsc@tsc:~$ ls -l /usr/bin &gt;&gt; ls-output2.txt
#文件不存在会新建。
</code></pre>

<p>error 输出</p>

<pre><code>tsc@tsc:~$ ls -l /bin/usr 2&gt; ls-error.txt
# 我的问题：在不知道有没有error的情况下，&gt;和2&gt;要如何同时执行？
</code></pre>

<p>都输出到一个文件(有两种方法)</p>

<pre><code># 1.老版本
# 顺序很重要
ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;
# 2.新，用&amp;&gt;
ls -l /bin/usr &amp;&gt; ls-output.txt
ls -l /bin/usr &amp;&gt;&gt; ls-output.txt # 追加
</code></pre>

<p>Pipelines</p>

<pre><code>ls -l /usr/bin | less
#千万不要把&gt;用成|，不然有些后果很严重。
</code></pre>

<p>filters</p>

<pre><code>tsc@tsc:~$ ls /bin /usr/bin | sort | less
</code></pre>

<h2 id="7-符号变量">7 符号变量</h2>

<p>这节讲expansion， 就是*、~之类的，本质就是变量。</p>

<ol>
<li>echo – Display a line of text</li>
</ol>

<p>It prints out its text arguments on standard output</p>

<pre><code>    tsc@tsc:~$ echo this is a test
this is a test

# Tilde Expansion
tsc@tsc:~/playground$ echo ~
/home/tsc

#Arithmetic Expansion
#形式：$((expression))
tsc@tsc:~/playground$ echo $((2+2))
4
</code></pre>

<p>brace expansion</p>

<p>括号中间不能有空格。</p>

<p>用途：批量创建有顺序的文件。</p>

<p>Parameter Expansion</p>

<p>Command Substitution</p>

<p>command的结果也可以作为expansion</p>

<pre><code>echo $(ls)
</code></pre>

<p>双引号：Double Quotes</p>

<p>“$”, “\” (backslash), and “`” (backquote) 失效，但是parameter expansion, arithmetic
expansion, and command substitution 仍有效。</p>

<p>注意区别：</p>

<pre><code>echo $(cal)
echo &quot;$(cal)&quot;
# 空格、tab、换行符都被用来分割，双引号则抑制。所以前一个命令不会换行，后一个会。
</code></pre>

<p>单引号：Single Quotes</p>

<p>抑制所有expansions</p>

<p>escape character</p>

<p>和双引号一起使用，抑制部分符号</p>

<h2 id="8-高级键盘技巧">8 高级键盘技巧</h2>

<p>这节讲键盘技巧，提高效率。主要是command line和history的技巧。command line的：移动，删除。history的上下一个命令。</p>

<ol>
<li>clear – Clear the screen</li>
<li>history – Display the contents of the history list</li>
</ol>

<h2 id="9-权限">9 权限</h2>

<p>思考：多用户为什么存在？想想计算中心。</p>

<p>多用户存在要解决的问题：</p>

<blockquote>
<ol>
<li>一个用户的错误操作不能使计算机crash</li>
<li>一个用户不能影响其他用户</li>
</ol>
</blockquote>

<p>几个相关文件夹</p>

<pre><code>/etc/passwd
User accounts .
/etc/group
groups
/etc/shadow
user's password
</code></pre>

<p>rwx Owner Group World</p>

<ol>
<li><p>id – Display user identity</p>

<pre><code>id
</code></pre>

<p>uid=1000(tsc) gid=1000(tsc) groups=1000(tsc),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)</p>

<h1 id="root">root</h1>

<h1 id="id">id</h1>

<p>uid=0(root) gid=0(root) groups=0(root)</p></li>

<li><p>chmod – Change File Mode</p>

<pre><code>chmod 600 foo.txt
</code></pre></li>

<li><p>umask – Set Default Permissions</p></li>

<li><p>su – Run A Shell With Substitute User And Group IDs</p></li>
</ol>

<p>默认是superuser</p>

<pre><code>    su -
exit
</code></pre>

<ol>
<li>sudo – Execute A Command As Another User</li>
</ol>

<p>纠正自己的认识，su,sudo是改变用户的，不一定是super，默认才是。</p>

<ol>
<li><p>chown – Change File Owner And Group</p></li>

<li><p>chgrp – Change Group Ownership</p></li>

<li><p>passwd - change user password</p></li>
</ol>

<h2 id="10-进程">10 进程</h2>

<p>Processes are how Linux organizes the different programs waiting for their
turn at the CPU.</p>

<ol>
<li><p>ps - report a snapshot of the current processes.</p></li>

<li><p>top - display Linux processes</p></li>

<li><p>&amp; - Putting A Process In The Background</p></li>

<li><p>jobs - list the jobs that have been launched from our terminal.</p></li>

<li><p>fg - Returning A Process To The Foreground</p></li>
</ol>

<p>为什么要回到前台来？后台的程序不受terminal的控制。</p>

<p>Ctrl-z - Stopping (Pausing) A Process，注意和ctrl-c的区别，c是结束。</p>

<ol>
<li><p>bg - resume the program’s execution in the background</p></li>

<li><p>kill - “kill” processes</p></li>

<li><p>killall - kill processes by name</p></li>

<li><p>halt</p></li>

<li><p>poweroff</p></li>

<li><p>reboot</p></li>

<li><p>shutdown</p></li>
</ol>

<h1 id="part-two-配置与环境变量">Part two – 配置与环境变量</h1>

<h2 id="11-环境">11 环境</h2>

<p>什么是environment？</p>

<p>configuration的作用：store program settings</p>

<ol>
<li><p>printenv - print all or part of environment</p>

<pre><code># 所有environment
</code></pre>

<p>tsc@tsc:~$ printenv | less</p>

<h1 id="某一个environment">某一个environment</h1>

<p>tsc@tsc:~$ printenv USER
tsc@tsc:~$ echo $HOME</p></li>

<li><p>printenv 显示的一些常见变量：</p>

<pre><code>SHELL
</code></pre>

<p>PATH   # 所有的，最新的</p></li>

<li><p>set #will show both the shell and environment variables</p></li>
</ol>

<p>printenv和set的区别：printenv只显示environment variables，set显示shell和environment
variables.</p>

<p>追加</p>

<pre><code>    PATH=$PATH:$HOME/bin
</code></pre>

<ol>
<li>export # tells the shell to make the contents of PATH available to child processes of this shell.</li>
</ol>

<p>序</p>

<p>Login Shell Sessions ：</p>

<pre><code>/etc/profile     # global
~/.bash_profile
~/.bash_login    # 如果上面那个不存在,读这个
~/.profile       # 如果上面那个不存在,读这个
# .profile文件中有PATH，并且将$HOME/bin添加上了，所以启动系统后$HOME/bin中的命令是直接可以用的。$HOME是用户目录。
</code></pre>

<p>Non-Login Shell Sessions ：</p>

<pre><code>/etc/bash.bashrc # global
~/.bashrc        # user's
</code></pre>

<p>Text Editors</p>

<p>有两种：</p>

<p>1.graphical ：gedit</p>

<p>2.text based ：nano, vi, emacs</p>

<p>nano</p>

<pre><code>ctrl-x : exit
ctrl-o : save, write out
#      : comments
</code></pre>

<p>使.bashrc生效</p>

<p>首先要知道原理，启动流程，在session一开始才会read
.bashrc，所以需要重启terminal才会生效。当然，可以强行重读.bashrc，用source命令：</p>

<pre><code>source .bashrc
</code></pre>

<h2 id="12-vi-简介">12 vi 简介</h2>

<ol>
<li><p>vi 操作</p>

<pre><code>:q
</code></pre>

<p>:q!   *# 强制退出
i     *# insert
esc   *# to command mode
:w    *# save ,有:的命令叫ex command</p>

<h1 id="move">move</h1>

<p>h, j, k, l
ctrl-f/b
numberG
gg # 第一个字符
G last line of the file
0 (zero) 行首
^ To the first non-whitespace character on the current line.
$ end of current line
w beginning of next word or punctuation
W ignoring punctuation
b beginning of previous word or punctuation
B ignoring punctuation</p>

<h1 id="edit">edit</h1>

<p>u    # undo last change
i    # insert</p>

<h1 id="append">append</h1>

<p>a    # append, i是前插
A    # 直接到最后append</p>

<h1 id="opening-a-line">opening a line</h1>

<p>o    # 新建一行在下面
O    # 新建一行在上面</p>

<h1 id="delete">delete</h1>

<p>x    # current character
3x
dd   # current line,d有cut的作用
dw   #
dW   # ignoring punctuation
d$   # current cursor to end
d0   # current cursor to beginning
dG   # current cursor to end of file
d20G # current cursor to 20 line，不是要删除20行
5dd  # 5行</p>

<h1 id="cutting-copying-and-pasting">Cutting, Copying, And Pasting</h1>

<p>p    # 小写粘贴在后一行（dd），普通在光标前
P    # 大写粘贴在前一行（dd），普通在光标后
p    # paste after cursor
P    # upper case, paste before cursor</p>

<h1 id="copy">copy</h1>

<p>yy   # copy current line
5yy  # copy 5 line
yW   # ignoring punctuation
yw   #
y$   # current cursor to end of line
y0   # current cursor to beginning of line
y^   # current cursor to first non-whitespace char
yG   # current cursor to last line of file
y20G # current cursor to 20th line</p>

<h1 id="redo-undo">redo,undo</h1>

<p>u           # undo
ctrl+r  # redo
J           # join line</p>

<h1 id="search-replace">search, replace</h1>

<p>fa          # 行内搜索a，按;继续搜索
/           # 文件内搜索，n继续
:%s/line/Line/g     # 替换
:%s/line/Line/gc    # 有提醒的替换，%代表对所有内容进行操作
:1,2s/line/Line/gc  # 对1-2行进行操作
Ctrl-e, Ctrl-y          # Scroll down and scroll up</p></li>
</ol>

<p>The leading tilde characters (”~”) indicate that no text exists on that line.</p>

<p>modal editor</p>

<p>command mode</p>

<p>Switching case of characters 大小写转换</p>

<p>You can change the case of text:</p>

<p>Toggle case “HellO” to “hELLo” with g~ then a movement.</p>

<p>Uppercase “HellO” to “HELLO” with gU then a movement.</p>

<p>Lowercase “HellO” to “hello” with gu then a movement.</p>

<p>Alternatively, you can visually select text then press ~to toggle case, or U
to convert to uppercase, or u to convert to lowercase.</p>

<p>常规操作</p>

<p><em># 到行尾</em></p>

<p>$ 反：0</p>

<p>A 反：I</p>

<p>Word movement: w, e, b</p>

<h2 id="13-自定义提示">13 自定义提示</h2>

<p>- PS1-prompt string one</p>

<p>就是这个：</p>

<pre><code>tsc@tsc:~$
</code></pre>

<p>更改它：</p>

<pre><code>tsc@tsc:~$ PS1=&quot;\$ &quot;
&lt;tsc@tsc ~&gt;$ 
\u   # username of the current user.
\h   # Hostname of the local machine minus the trailing domain name.
\w   # Name of the current working directory.
\$   # This displays a “$” character unless we have superuser privileges. In that case, it displays a “#” instead.
</code></pre>

<p>改颜色：</p>

<p>通过escape code 实现，escape code 的开头是八进制的033 ，例子：</p>

<pre><code>\033 [0;30m
# \033 是开头
# 0   是optional character attribute，0代表text color是normal，1是bold
# 30m 是instruction
tsc@tsc:~$ PS1=&quot;\[\033[0;31m\]\$\[\033[0m\] &quot;
\033[0m   *# 代表结束修改
</code></pre>

<h1 id="part-three-常见任务和基本工具">Part three – 常见任务和基本工具</h1>

<p>要知道package是什么，如何install, remove, update</p>

<h2 id="14-包管理">14 – 包管理</h2>

<p>linux的哪个发行版才是最好的？考虑的因素不是界面，而是：</p>

<ol>
<li>packaging system</li>
<li>vitality of the distribution’s support community</li>
</ol>

<p>packaging 的两大阵营：</p>

<ul>
<li>Debian “.deb” camp</li>

<li><p>Red Hat “.rpm” camp</p>

<p>Packaging System     Distributions (Partial Listing)
Debian Style (.deb)  Debian, Ubuntu, Linux Mint, Raspbian
Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE</p></li>
</ul>

<p>- package files</p>

<p>- shared libraries</p>

<p>软件都是有依赖的，被依赖的就放在这里</p>

<p>dependency</p>

<p>- package tool</p>

<p>分为high, low-level两种，</p>

<p>high:metadata search, dependency</p>

<p>low-level: installing, removing</p>

<p>Red Hat系列使用同一low-lvel program(rpm), high-level则不同，yum使用者：Fedora, Red Hat
Enter, CentOS.</p>

<p>Distributions Low-Level Tools High-Level Tools</p>

<p>Debian-Style dpkg apt-get, aptitude</p>

<p>Fedora, Red Hat, Enterprise Linux, CentOS rpm yum</p>

<p>查找和ackage的方法</p>

<p>- What is the difference between apt-get update and upgrade?</p>

<h2 id="15-存储介质">15 存储介质</h2>

<p>什么是mounting?</p>

<p>attaching the device to the file system tree.</p>

<ol>
<li>mount – Mount a file system</li>
</ol>

<p>没有参数时，显示已经mounted的文件系统。</p>

<p>如何看？device on mount_point type file_system_type (options).</p>

<p>free - Display amount of free and used memory in the system</p>

<p>partition number 是什么？</p>

<p>Unable to enumerate USB device under virtualbox</p>

<p>usb3.0插的3.0的口上在vm中读不出来，改插在2.0的口上就可以，真是。。。</p>

<p>磁盘、分区及Linux文件系统 [Disk, Partition, Linux File System]</p>

<p>inode的作用：实现文件存储的关键。</p>

<ol>
<li><p>tail的妙用</p>

<h1 id="ubuntu">ubuntu</h1>

<p>tail -f /var/log/syslog</p></li>
</ol>

<p>实时观察系统在做什么。</p>

<p>partition layout 是什么？</p>

<p>IDE、SATA、SCSI、SAS、FC、SSD硬盘类型介绍</p>

<ol>
<li>fsck - check and repair a Linux filesystem</li>
</ol>

<h2 id="16-网络">16 网络</h2>

<p>IP Addresses, Host Names, and Domain Names</p>

<p>明白host name与domain name的区别。</p>

<ol>
<li>ping, ping6 - send ICMP ECHO_REQUEST to network hosts</li>
<li>traceroute - print the route packets trace to network host</li>
<li>ip - show / manipulate routing, devices, policy routing and tunnels</li>
</ol>

<p>DHCP (Dynamic Host Configuration Protocol)</p>

<ol>
<li>netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships</li>
<li>ftp — Internet file transfer program</li>
</ol>

<p>ftp是明文传输。</p>

<ol>
<li>Wget - The non-interactive network downloader.</li>
<li>ssh</li>
</ol>

<p>rlogin and telnet 和ftp有一样的缺陷。</p>

<p>ssh解决了两大问题：First, it authenticates that the remote host is who it says it is
(thus preventing so-called “man in the</p>

<p>middle” attacks), and second, it encrypts all of the communications between
the local and</p>

<p>remote hosts.</p>

<pre><code>ssh root@ip -p 端口号
</code></pre>

<p>windows下的ssh软件：PuTTY</p>

<h2 id="17-文件搜索">17 文件搜索</h2>

<ol>
<li>locate - find files by name</li>
</ol>

<p>locate查找的数据库是如何更新的？由updatedb 程序更新，可以手动更新。</p>

<p>locate vs find: usage, pros and cons of each other</p>

<ol>
<li>find - search for files in a directory hierarchy<br />
find 参数很多，本文只介绍几个常用的</li>
</ol>

<blockquote>
<p>-name 按名字查找<br />
 -type 按类型<br />
 -atime 访问时间</p>
</blockquote>

<pre><code>    $ find ~ -type f | wc
# 文件名有jpg，大小大于1M
$ find ~ -type f -name &quot;*.jpg&quot; -size +1M | wc -l

find . -atime 7 -type f -print
find . -type d -print  //只列出所有目录
find / -name &quot;hello.c&quot; 查找hello.c文件

#test
$ find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)

# 顺序很重要。
# action：把查找的结果作为命令的输入参数

$ find ~ -type f -name 'foo*' -exec ls -l '{}' ';'
$ find ~ -type f -name 'foo*' -exec ls -l '{}' +
$ find ~ -type f -name 'foo*' -print | xargs ls -l
# {} is a symbolic representation of the current pathname
# +：the system only has to execute the ls command once

#文件名中空格的处理
$ find ~ -type f -name '*.jpg' -print0 | xargs --null ls -l
</code></pre>

<ol>
<li>touch - change file timestamps</li>
</ol>

<p>文件不存在时会创建。</p>

<ol>
<li>stat - display file or file system status</li>
</ol>

<p>which is a kind of souped-up version of ls.</p>

<h2 id="18-存档和备份">18 存档和备份</h2>

<p>管理大量的文件-压缩。</p>

<p>本节讲3个内容：</p>

<p>compression(压缩)</p>

<p>archiving(归档)</p>

<p>synchronization(同步)</p>

<ol>
<li>gzip, gunzip, zcat - compress or expand files</li>
</ol>

<p>gzip压缩，gunzip解压。</p>

<p>gzip会替换原来的文件。</p>

<ol>
<li><p>zcat - equivalent to gunzip with the -c option</p></li>

<li><p>zless</p></li>

<li><p>bzip2, bunzip2 - a block-sorting file compressor</p></li>

<li><p>linux压缩和打包是两个要领，分别对应zip和tar，window下面是不是没有区分？</p></li>

<li><p>tar -tape archive</p></li>
</ol>

<p>.tar or .tgz, which indicate a “plain” tar archive and a gzipped archive,
respectively.</p>

<pre><code>    # c create
$ tar cf playground.tar playground

# t list
$ tar tf playground.tar

# x extract
$ tar xf ../playground.tar
# r append

# extract a single file
$ tar xf archive.tar pathname
</code></pre>

<p>注意区分mode与option，c是mode，f是option。mode要先写。</p>

<ol>
<li><p>incremental backups - 增量式备份</p></li>

<li><p>linux shell 重定向 减号-的作用</p></li>
</ol>

<p>studout或者stdin就可以用减号（-）来替代</p>

<ol>
<li>不解压缩直接查看.gz和.bz2命令</li>
</ol>

<p>使用zcat可以查看<em>.gz文件内容，使用bzcat可以直接查看</em>.bz2文件.</p>

<ol>
<li><p>用ssh从远程服务器复制文件到本地</p>

<pre><code>ssh root@xxx.xxx.xx.xx -p 端口号 'tar cf - filename' | tar xf -
</code></pre>

<p>root@xxx.xxx.xx.xx&rsquo;s password:</p></li>
</ol>

<p>先tar，传回来再导出。</p>

<ol>
<li><p>zip - 既压缩也归档</p></li>

<li><p>zip, unzip的作用是交换windows文件，linux用tar, gzip</p></li>

<li><p>rsync - 备份与同步</p>

<pre><code>rsync options source destination
</code></pre>

<p>$ rsync -av playground foo</p></li>
</ol>

<h2 id="19-正则表达式">19 – 正则表达式</h2>

<p>后面几章都是关于文字处理的。先讲regular expression.</p>

<ol>
<li>metacharacters &amp; literal characters</li>
</ol>

<p>metacharacters是^ $ . [ ] { } - ? * + ( ) | \ ，其余就是literal characters。</p>

<ol>
<li>The Any Character</li>
</ol>

<p>就是点号，the dot or period character</p>

<ol>
<li>anchors</li>
</ol>

<p>The caret (^) (只匹配行首出来的)and dollar sign ($) （只匹配行尾出现的）</p>

<pre><code>    $ grep -h '^zip' dirlist*.txt
$ grep -h 'zip$' dirlist*.txt
$ grep -h '^zip$' dirlist*.txt
</code></pre>

<ol>
<li><p>点号不是任意长度吗？加上^$就代表一个？</p>

<pre><code>$ grep -h '.zip' dirlist*.txt
</code></pre>

<p>$ grep -i &lsquo;^..j.r$&rsquo; /usr/share/dict/words</p></li>

<li><p>Bracket Expressions And Character Classes</p></li>
</ol>

<p>[] 用来只匹配一个字符。</p>

<pre><code>    $ grep -h '[bg]zip' dirlist*.txt
^ : negation,只在第一个位置时有效
$ grep -h '[^bg]zip' dirlist*.txt # 注意出现的位置,表示取反
: rang$ grep -h '^[A-Za-z0-9]' dirlist*.txt
# 要匹配-（短横线），就把它放到第一位
$ grep -h '[A-Z]' dirlist*.txt
$ grep -h '[-AZ]' dirlist*.txt
</code></pre>

<ol>
<li>POSIX Character Classes</li>
</ol>

<p>出现的原因：posix和ASCII不一样。</p>

<ol>
<li>alternation</li>
</ol>

<p>[]是单个，它(|)是string</p>

<pre><code>    $ echo &quot;AAA&quot; | grep -E 'AAA|BBB|CCC'
$ grep -Eh '^(bz|gz|zip)' dirlist*.txt
</code></pre>

<ol>
<li>Quantifiers</li>
</ol>

<p>匹配的个数</p>

<pre><code>    # ? - Match An Element Zero Or One Time ,一个字符出现的次数，和word里面的?不同，word里面代表任意一个字符，这里的?不能单独使用，要跟在一个字符后面。
$ echo &quot;(555) 123-4567&quot; | grep -E '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$'

# * - Match An Element Zero Or More Times
$ echo &quot;This works.&quot; | grep -E '[[:upper:]][[:upper:][:lower:] ]*\.'
# 和?一样，前面要有字符。

# + - Match An Element One Or More Times 至少出现一次。
$ echo &quot;This that&quot; | grep -E '^([[:alpha:]]+ ?)+$'

# { } - Match An Element A Specific Number Of Times
$ echo &quot;(555) 123-4567&quot; | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
</code></pre>

<ol>
<li><p>find使用reg</p>

<pre><code>$ find . -regex '.*[^-_./0-9a-zA-Z].*'
</code></pre>

<h1 id="反-0-无穷个字符">反 0-无穷个字符</h1></li>

<li><p>locate使用reg</p>

<pre><code>$ locate --regex 'bin/(bz|gz|zip)'
</code></pre></li>

<li><p>less和vi中也可以使用（注意它们的区别，在vi中reg是basic）</p>

<pre><code># less
</code></pre>

<p>/^([0-9]{3}) [0-9]{3}-[0-9]{4}</p>

<h1 id="vi">vi</h1>

<p>/([0-9]{3}) [0-9]{3}-[0-9]{4}</p></li>
</ol>

<h2 id="20-文本处理">20 文本处理</h2>

<p>真是一切皆文件。</p>

<ol>
<li><p>cat的一些option</p>

<pre><code>$ cat -A foo.txt # 显示所有符号，包括控制符
</code></pre>

<p>$ cat -ns foo.txt # n显示行号，s抑制多余的空行</p></li>

<li><p>sort</p></li>
</ol>

<blockquote>
<p>-n 按数字进行排序 VS -d 按字典序进行排序<br />
 -r 逆序排序<br />
 -k N 指定按第N列排序</p>
</blockquote>

<pre><code>    sort -nrk 1 data.txt
sort -bd data // 忽略像空格之类的前导空白字符

$ sort &gt; foo.txt
c
b
a

# 多个文件
$ sort file1.txt file2.txt file3.txt &gt; final_sorted_list.txt

#按指定列排序(k)：
$ ls -l /usr/bin | sort -nr -k 5 | head

#多个key排序：
$ sort --key=1,1 --key=2n distros.txt

# 一个field内多个排序：
$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt

#指定分割符：
$ sort -t ':' -k 7 /etc/passwd | head
</code></pre>

<ol>
<li><p>du - estimate file space usage</p>

<pre><code>$ du -s /usr/share/* | head # 显示前10个
</code></pre>

<p>$ du -s /usr/share/* | sort -nr | head # 大到小排序后显示前10个</p></li>

<li><p>uniq 去重</p>

<pre><code>$ sort foo.txt | uniq
</code></pre></li>

<li><p>wc 统计</p>

<pre><code>wc -l file // 统计行数
</code></pre>

<p>wc -w file // 统计单词数
wc -c file // 统计字符数</p></li>

<li><p>cut</p>

<pre><code># 取第3列
</code></pre>

<p>$ cut -f 3 distros.txt</p>

<p>#每个field的长度可能不同，如果要取所有行中时间中的年，就不可能用字符位置去表示。而先把field取出来，就规整了。
$ cut -f 3 distros.txt | cut -c 7-10</p></li>

<li><p>expand - 把tab换为等量空格</p>

<pre><code>$ expand distros.txt | cut -c 23-
</code></pre></li>

<li><p>改cut的默认分割符，用d option</p>

<pre><code>$ cut -d ':' -f 1 /etc/passwd | head
</code></pre></li>

<li><p>paste</p></li>
</ol>

<p>adds one or more columns of text to a file</p>

<pre><code>    $ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt &gt; distros-by-date.txt
$ cut -f 1,2 distros-by-date.txt &gt; distros-versions.txt
$ cut -f 3 distros-by-date.txt &gt; distros-dates.txt
$ paste distros-dates.txt distros-versions.txt
</code></pre>

<ol>
<li><p>join<br />
It joins data from multiple files based on a shared key field.</p>

<pre><code>$ join distros-key-names.txt distros-key-vernums.txt | head
</code></pre></li>

<li><p>comm</p>

<pre><code>$ comm file1.txt file2.txt
</code></pre>

<h1 id="n-抑制列">-n 抑制列</h1>

<p>$ comm -12 file1.txt file2.txt</p></li>

<li><p>diff</p>

<pre><code>$ diff file1.txt file2.txt
</code></pre>

<h1 id="context-format-看两个各自都有什么-没有什么">context format 看两个各自都有什么，没有什么</h1>

<p>$ diff -c file1.txt file2.txt</p>

<h1 id="unified-format-看从旧到新的变化">unified format 看从旧到新的变化</h1>

<p>$ diff -u file1.txt file2.txt</p></li>

<li><p>patch 用来更新文件，比如代码。</p></li>
</ol>

<p>apply changes to text files。</p>

<pre><code>    $ diff -Naur file1.txt file2.txt &gt; patchfile.txt

$ patch &lt; patchfile.txt
</code></pre>

<ol>
<li><p>tr 转换</p>

<pre><code>$ echo &quot;lowercase letters&quot; | tr a-z A-Z
</code></pre>

<p>LOWERCASE LETTERS
#　多对一的转换
$ echo &ldquo;lowercase letters&rdquo; | tr [:lower:] A</p>

<h1 id="squeeze">squeeze</h1>

<p>$ echo &ldquo;aaabbbccc&rdquo; | tr -s ab
abccc</p></li>

<li><p>grep<br />
grep match_patten file // 默认访问匹配行<br />
常用参数</p></li>
</ol>

<blockquote>
<p>-o 只输出匹配的文本行 VS -v 只输出没有匹配的文本行<br />
 -c 统计文件中包含文本的次数 grep -c “text” filename<br />
 -n 打印匹配的行号<br />
 -i 搜索时忽略大小写<br />
 -l 只打印文件名</p>
</blockquote>

<pre><code>    # 在多级目录中对文本递归搜索(程序员搜代码的最爱）
grep &quot;class&quot; . -R -n 

#将日志中的所有带where条件的sql查找查找出来
cat LOG.* | tr a-z A-Z | grep &quot;FROM &quot; | grep &quot;WHERE&quot; &gt; b 
</code></pre>

<ol>
<li><p>sed：stream editor<br />
用法：sed [options] ‘command’ file(s)</p>

<pre><code># search-and-replace
</code></pre>

<p>$ echo &ldquo;aaabbbccc&rdquo; | sed &rsquo;s/b/B/&rsquo;   #首处替换
$ echo &ldquo;aaabbbccc&rdquo; | sed &rsquo;s/b/B/g&rsquo;  #全部替换</p>

<h1 id="谁跟在command后面就是delimiter">谁跟在command后面就是delimiter</h1>

<p>$ echo &ldquo;front&rdquo; | sed &rsquo;s_front<em>back</em>&lsquo;</p>

<h1 id="指定要处理的行数">指定要处理的行数</h1>

<p>$ echo &ldquo;front&rdquo; | sed &lsquo;1s/front/back/&rsquo;</p>

<h1 id="p-打印出来">p：打印出来</h1>

<h1 id="n-not-to-print-every-line-by-default">-n：  not to print every line by default</h1>

<p>$ sed -n &lsquo;1,5p&rsquo; distros.txt
$ sed -n &lsquo;/SUSE/p&rsquo; distros.txt
$ sed -n &lsquo;/SUSE/!p&rsquo; distros.txt</p>

<h1 id="一般出输出到屏幕-用i则直接替换原文件">一般出输出到屏幕，用i则直接替换原文件</h1>

<p>$ sed -i &rsquo;s/lazy/laxy/; s/jumped/jimped/&rsquo; foo.txt</p>

<p>#删除空白行
sed &lsquo;/^$/d&rsquo; file</p>

<p>#reg的back references
$ sed &rsquo;s/([0-9]{2})\/([0-9]{2})\/([0-9]{4})$/\3-\1-\2/&rsquo; distros.txt</p></li>

<li><p>awk<br />
详细教程可以查看 <a href="http://awk.readthedocs.io/en/latest/chapter-one.html">http://awk.readthedocs.io/en/latest/chapter-one.html</a></p></li>
</ol>

<p>awk ’ BEGIN{ statements } statements2 END{ statements } ’<br />
工作流程：</p>

<blockquote>
<p>1.执行begin中语句块；<br />
 2.从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕；<br />
 3.执行end语句块；</p>
</blockquote>

<p>特殊变量:</p>

<blockquote>
<p>NR:表示记录数量，在执行过程中对应当前行号；<br />
 NF:表示字段数量，在执行过程总对应当前行的字段数；<br />
 $0:这个变量包含执行过程中当前行的文本内容；<br />
 $1:第一个字段的文本内容；<br />
 $2:第二个字段的文本内容；</p>
</blockquote>

<pre><code>    awk '{print $2, $3}' file
# 日志格式：'$remote_addr - $remote_user [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'

#统计日志中访问最多的10个IP
awk '{a[$1]++}END{for(i in a)print a[i],i|&quot;sort -k1 -nr|head -n10&quot;}' access.log
</code></pre>

<ol>
<li><p>aspell 拼写检查</p>

<pre><code>$ aspell check foo.txt
</code></pre>

<h1 id="h-html-checking-mode-option">-H (HTML) checking-mode option</h1>

<p>$ aspell -H check foo.txt</p></li>
</ol>

<p>改完了会产生一个bak文件，存在原来的文本。</p>

<h2 id="21-格式化输出">21 格式化输出</h2>

<p>讲文本输出格式。</p>

<ol>
<li><p>nl 显示行号</p>

<pre><code>$ nl distros.txt | head
</code></pre>

<h1 id="和cat-n-一样">和cat -n 一样</h1>

<p>$ sort -k 1,1 -k 2n distros.txt | sed -f distros-nl.sed | nl</p></li>

<li><p>fold – Wrap Each Line To A Specified Length</p>

<pre><code>$ echo &quot;The quick brown fox jumped over the lazy dog.&quot; | fold -w 12
</code></pre>

<h1 id="不打断单词">不打断单词</h1>

<p>$ echo &ldquo;The quick brown fox jumped over the lazy dog.&rdquo; | fold -w 12 -s</p></li>

<li><p>fmt – A Simple Text Formatter</p></li>
</ol>

<p>it fills and joins lines in text while preserving blank lines and indentation.</p>

<pre><code>    $ fmt -w 50 fmt-info.txt | head
$ fmt -cw 50 fmt-info.txt
# 一行如果不足50个字符，会把第二行的补过来
# 只对'# '开头的行操作
$ fmt -w 50 -p '# ' fmt-code.txt
</code></pre>

<ol>
<li>pr – Format Text For Printing</li>
</ol>

<p>used to paginate text.</p>

<pre><code>    # l:page length
# w:width
$ pr -l 15 -w 65 distros.txt

#首尾会有空行。
</code></pre>

<ol>
<li><p>printf – Format And Print Data</p>

<pre><code>#使用：printf “format” arguments
</code></pre>

<p>$ printf &ldquo;I formatted the string: %s\n&rdquo; foo
$ printf &ldquo;%d, %f, %o, %s, %x, %X\n&rdquo; 380 380 380 380 380 380</p>

<p>#Multiple optional components ：
%[flags][width][.precision]conversion_specification</p></li>

<li><p>Document Formatting Systems</p></li>
</ol>

<p>tex后来取代了troff.</p>

<ol>
<li><p>groff</p>

<pre><code>$ zcat /usr/share/man/man1/ls.1.gz | head
</code></pre>

<p>$ man ls | head
$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc -T ascii | head</p>

<h1 id="存为postscript到桌面">存为postscript到桌面</h1>

<p>$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc &gt; ~/Desktop/foo.ps</p>

<h1 id="ps转pdf">ps转pdf</h1>

<p>$ ps2pdf ~/Desktop/foo.ps ~/Desktop/ls.pdf</p></li>

<li><p>tbl</p></li>
</ol>

<h2 id="22-打印">22 打印</h2>

<p>介绍了ps的由来。</p>

<h3 id="1-cups-common-unix-printing-system-provides-print-drivers-and-print">1. CUPS (Common Unix Printing System) ：provides print drivers and print-</h3>

<p>job management</p>

<h3 id="2-ghostscript-a-postscript-interpreter-acts-as-a-rip">2. Ghostscript： a PostScript interpreter, acts as a RIP.</h3>

<ol>
<li>pr – Convert Text Files For Printing</li>
</ol>

<p>pr is used to adjust text to fit on a specific page size, with optional page
headers and margins.</p>

<pre><code>    # 3列
$ ls /usr/bin | pr -3 -w 65 | head
</code></pre>

<h3 id="3-cups-有两种printing-lpr-lp">3. CUPS 有两种printing，lpr, lp.</h3>

<ol>
<li><p>lpr – Print Files (Berkeley Style)</p>

<pre><code>$ ls /usr/bin | pr -3 | lpr
</code></pre></li>

<li><p>lpr: Error - no default destination available.</p>

<pre><code># 查看printer
</code></pre>

<p>$ lpstat -a
lpstat: No destinations added.</p></li>

<li><p>lp – Print Files (System V Style)</p></li>

<li><p>a2ps</p>

<pre><code>“Anything to PostScript.”
</code></pre>

<p>$ ls /usr/bin | pr -3 -t | a2ps -o ~/Desktop/ls.ps -L 66 -R</p></li>

<li><p>lpstat – Display Print System Status</p>

<pre><code># 查询printer状态
</code></pre>

<p>$ lpstat -a
$ lpstat -a</p></li>

<li><p>lpq – Display Printer Queue Status</p>

<pre><code>$ lpq
</code></pre>

<p>PDF is ready
no entries</p></li>

<li><p>lprm / cancel – Cancel Print Jobs</p></li>
</ol>

<h2 id="23-程序编译">23 程序编译</h2>

<ol>
<li>compile</li>
</ol>

<p>linker，解决共享问题，用共享库。</p>

<pre><code>    $ which gcc
/usr/bin/gcc
</code></pre>

<ol>
<li><p>用ftp下载source code</p>

<pre><code>$ mkdir src
</code></pre>

<p>$ cd src</p>

<p>$ ftp ftp.gnu.org
Name (ftp.gnu.org:me): anonymous
ftp&gt; cd gnu/diction
ftp&gt; ls
ftp&gt; get diction-1.11.tar.gz
ftp&gt; bye
$ tar xzf diction-1.11.tar.gz</p>

<h1 id="先查看是不是在一个文件夹里-以免解压散开">先查看是不是在一个文件夹里，以免解压散开</h1>

<p>$ tar tzvf diction-1.11.tar.gz | less</p></li>
</ol>

<p>共享的头文件在/usr/include ，The header files in this directory were installed when we
installed the compiler.</p>

<ol>
<li>Building The Program</li>
</ol>

<p>一般需要两步。</p>

<pre><code>    # 由于script不在默认的目录，需要./告诉shell它在当前目录
$ ./configure

config.status: creating Makefile
config.status: creating diction.1
config.status: creating diction.texi
config.status: creating diction.spec
config.status: creating style.1
config.status: creating test/rundiction
config.status: creating config.h

# Makefile is a configuration file that instructs the make program exactly how to build the program. Without it, make will refuse to run.
#make只complie需要complie的文件，省时间。
$ make  &amp;&amp; make install
#Installing The Program
</code></pre>

<h1 id="part-four-编写shell脚本">Part four - 编写shell脚本</h1>

<h2 id="24-开始你的第一个脚本">24 – 开始你的第一个脚本</h2>

<ol>
<li>script开头的#!</li>
</ol>

<p>shebang，指明interpreter，每个script开头都应该加这行。</p>

<ol>
<li><p>让script可以执行</p>

<pre><code>$ chmod 755 hello_world
</code></pre></li>
</ol>

<p>owner的权限是x就可以了。755所有人可以执行，700只有owner可以执行。必须是可读的。</p>

<ol>
<li><p>执行</p>

<pre><code>$ ./hello_world
</code></pre></li>
</ol>

<p>必须要加上./ ,因为文件位置的问题。自动识别的命令的目录都写在了PATH中，可以查看它：</p>

<pre><code>    $ echo $PATH
</code></pre>

<ol>
<li>把某个路径添加到PATH</li>
</ol>

<p>在.bashrc （它在~中）中添加：</p>

<pre><code>    # 把~/bin添加在PATH的前面
export PATH=~/bin:&quot;$PATH&quot;

# 在当前terminal中生效
$ ..bashrc

# 或者
$ source .bashrc
</code></pre>

<ol>
<li><p>script放哪？</p>

<pre><code> ~/bin ： 自己用
</code></pre>

<p>/usr/local/bin ： 同一个系统多人用
 /usr/local/sbin： 系统管理员用
 /usr/local：   locally supplied software，</p></li>

<li><p>line-continuations</p></li>
</ol>

<p>就是 </p>

<ol>
<li><p>vi中对script的配置</p>

<pre><code>:syntax on
</code></pre>

<p>:set hlsearch
:set tabstop=4
:set autoindent</p>

<p>永久：
写在~/.vimrc，没有就创建</p></li>
</ol>

<h2 id="25-开始">25 开始</h2>

<p>shell是动态语言</p>

<p>uppercase letters to designate constants and lower case</p>

<p>letters for true variables.</p>

<pre><code>$ vim ~/bin/sys_info_page
$ chmod 755 ~/bin/sys_info_page
$ sys_info_page
$ sys_info_page &gt; sys_info_page.html
$ firefox sys_info_page.html
</code></pre>

<p>变量(Variables) 与 常量（Constants）</p>

<p>用于指定常量的大写字母和用于真实变量的小写字母（uppercase letters to designate constants and lower
case letters for true variables.）</p>

<p>Note that in an assignment, there must be no spaces between the variable name,
the equals sign, and the value.</p>

<pre><code>a=z                  # Assign the string &quot;z&quot; to variable a.
b=&quot;a string&quot;         # Embedded spaces must be within quotes.
c=&quot;a string and $b&quot;  # Other expansions such as variables can be 

# expanded into the assignment.
d=&quot;$(ls -l foo.txt)&quot; # Results of a command.
e=$((5 * 7))         # Arithmetic expansion.
f=&quot;\t\ta string\n&quot;   # Escape sequences such as tabs and newlines.
</code></pre>

<p>大括号的作用</p>

<pre><code>$ filename=&quot;myfile&quot;
$ touch &quot;$filename&quot;
$ mv &quot;$filename&quot; &quot;$filename1&quot;
mv: cannot move 'myfile' to '': No such file or directory

$ mv &quot;$filename&quot; &quot;${filename}1&quot;
</code></pre>

<p>here document</p>

<pre><code>command &lt;&lt; token
text
token

# shell example
cat &lt;&lt; _EOF_


        $TITLE


_EOF_

# terminal example

$ cat &lt;&lt; _EOF_

\&gt; $foo
\&gt; &quot;$foo&quot;
\&gt; '$foo'
\&gt; \$foo
\&gt; _EOF_
</code></pre>

<h2 id="26-自上而下的设计">26 自上而下的设计</h2>

<p>讲程序设计的思想。</p>

<p>shell functions</p>

<p>两种形式：</p>

<pre><code>function name {
  commands
  return
}

and the simpler (and generally preferred) form:

name () {
  commands
  return
}
</code></pre>

<p>in order for function calls to be recognized as shell functions and not
interpreted as the names of external programs, shell function definitions must
appear in the script before they are called.</p>

<p>local variables</p>

<p>要加local</p>

<pre><code>funct_1 () {
    local foo # variable foo local to funct_1
    foo=1
    echo &quot;funct_1: foo = $foo&quot;
}
</code></pre>

<h2 id="27-流程控制-if分支">27 流程控制：if分支</h2>

<p>shell的if语句挺复杂的。</p>

<pre><code>if commands; then
    commands
[elif commands; then
    commands...]
[else
    commands]
fi

x=5

if [ &quot;$x&quot; -eq 5 ]; then
    echo &quot;x equals 5.&quot;
else
    echo &quot;x does not equal 5.&quot;
fi  
</code></pre>

<p>exit status</p>

<p>程序结果后返回给系统的。查询：</p>

<pre><code>$ ls -d /usr/bin
$ echo $?
</code></pre>

<p>true - do nothing, successfully</p>

<p>false - do nothing, unsuccessfully</p>

<p>test</p>

<p>语法：</p>

<pre><code>test expression
and the more popular:
[ expression ]
</code></pre>

<p>expression是true时返回0，否则返回1</p>

<p>test和[ 本质上是一样的。</p>

<p>使用：</p>

<pre><code>#!/bin/bash
# test-file: Evaluate the status of a file

FILE=~/.bashrc

if [ -e &quot;$FILE&quot; ]; then
    if [ -f &quot;$FILE&quot; ]; then
        echo &quot;$FILE is a regular file.&quot;
    fi

    if [ -d &quot;$FILE&quot; ]; then
        echo &quot;$FILE is a directory.&quot;
    fi

    if [ -r &quot;$FILE&quot; ]; then
        echo &quot;$FILE is readable.&quot;
    fi

    if [ -w &quot;$FILE&quot; ]; then
        echo &quot;$FILE is writable.&quot;
    fi

    if [ -x &quot;$FILE&quot; ]; then
        echo &quot;$FILE is executable/searchable.&quot;
    fi
else
    echo &quot;$FILE does not exist&quot;
    exit 1
fi

exit  # ?
</code></pre>

<p>When a script “runs off the end” (reaches end of file), it terminates with an
exit status of the last command executed.</p>

<p>String Expressions</p>

<pre><code>#!/bin/bash
# test-string: evaluate the value of a string

ANSWER=maybe

if [ -z &quot;$ANSWER&quot; ]; then
    echo &quot;There is no answer.&quot; &gt;&amp;2
    exit 1
fi

if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then
    echo &quot;The answer is YES.&quot;
elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then
    echo &quot;The answer is NO.&quot;
elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then
    echo &quot;The answer is MAYBE.&quot;
else
    echo &quot;The answer is UNKNOWN.&quot;
</code></pre>

<p>Integer Expressions</p>

<p>test的选项真多！！！</p>

<p>test用regex</p>

<p>[[]]</p>

<pre><code># 检验是不是数
if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
</code></pre>

<p>(( )) - Designed For Integers</p>

<pre><code>$ if ((1)); then echo &quot;It is true.&quot;; fi

It is true.

if ((INT == 0)); 

if ((INT &lt; 0)); 

if (( ((INT % 2)) == 0)); 
</code></pre>

<p>Combining Expressions</p>

<pre><code>Operation   test   [[ ]] and (( ))
AND         -a           &amp;&amp;
OR          -o           ||
NOT         !            !
</code></pre>

<p>例子：</p>

<pre><code># [[]]
if [[ &quot;$INT&quot; -ge &quot;$MIN_VAL&quot; &amp;&amp; &quot;$INT&quot; -le &quot;$MAX_VAL&quot; ]];

# test
if [ &quot;$INT&quot; -ge &quot;$MIN_VAL&quot; -a &quot;$INT&quot; -le &quot;$MAX_VAL&quot; ];
</code></pre>

<p>Control Operators: Another Way To Branch</p>

<p>The &amp;&amp; (AND) and || (OR)</p>

<pre><code>$ mkdir temp &amp;&amp; cd temp
$ [[ -d temp ]] || mkdir temp
</code></pre>

<p>[]和[[]]的区别</p>

<p>[[]]和[]一样，不过有两个新特性，：</p>

<p>string1 =~ regex</p>

<p>== operator</p>

<p>[[]]和表达式之间要有空格</p>

<pre><code>[[ &quot;$count&quot; -gt 5 ]]
[[ &quot;$count&quot; -gt 5]] # 会报错，执行起来会很可怕
</code></pre>

<h2 id="28-读取键盘输入">28 读取键盘输入</h2>

<p>read – Read Values From Standard Input</p>

<p>read a single line of standard input.</p>

<p>read [-options] [variable…]</p>

<pre><code># -n option,suppresses the trailing newline on output
echo -n &quot;Please enter an integer -&gt; &quot;

read int
read var1 var2 var3 var4 var5 # 多个

# -p prompt
read -p &quot;Enter one or more values &gt; &quot;

# -t seconds
# -s Silent mode. 
if read -t 10 -sp &quot;Enter secret passphrase &gt; &quot; secret_pass; 
</code></pre>

<p>IFS</p>

<p>Internal Field Separator</p>

<pre><code>file_info=$(grep &quot;^$user_name:&quot; $FILE)
# 写在一行，IFS只改变跟在后面的 command
IFS=&quot;:&quot; read user pw uid gid name home shell &lt;&lt;&lt; &quot;$file_info&quot;
</code></pre>

<p>here string</p>

<p>The &lt;&lt;&lt; operator indicates a here string.</p>

<p>You Can’t Pipe read</p>

<p>就像函数与子函数，凡是这一类都不能pip。</p>

<p>Validating Input</p>

<p>Menus</p>

<h2 id="29-流程控制-while-until">29 – 流程控制：while/until</h2>

<p>有3各loop</p>

<p>while</p>

<p>语法：</p>

<pre><code>while commands; do commands; done

#!/bin/bash

# while-count: display a series of numbers
count=1

while [[ &quot;$count&quot; -le 5 ]]; do
    echo &quot;$count&quot;
    count=$((count + 1))
done
echo &quot;Finished.&quot;
</code></pre>

<p>Breaking Out Of A Loop：break、continue、until</p>

<p>和while相反</p>

<pre><code>count=1
until [[ &quot;$count&quot; -gt 5 ]]; do
    echo &quot;$count
    count=$((count + 1))
done
echo &quot;Finished.
</code></pre>

<p>read file with loop</p>

<pre><code>#!/bin/bash
# while-read

while read distro version release; do
    printf &quot;distro: %s\tversion: %s\treleased: %s\n&quot; \
        &quot;$distro&quot; \
        &quot;$version&quot; \
        &quot;$release&quot;
done &lt; distros.txt
</code></pre>

<h2 id="30-troubleshooting">30 – Troubleshooting</h2>

<p>讲错误的处理。</p>

<p>引号不对称</p>

<p>特定符号缺失</p>

<p>意外的expansion</p>

<p>是否报错取决于expansion的值。</p>

<p>双引号的作用</p>

<pre><code># number为空时会报错
number=
if [ $number = 1 ]; then

# 这样就不会了  “”=1
[ &quot;$number&quot; = 1 ]
</code></pre>

<p>Multi-word string也应该用双引号括起来。</p>

<p>所以，总是用双引号把变量括起来。</p>

<p>logical error</p>

<p>给出错误信息是比较好的做法</p>

<p>unix文件名称什么字符都可以用，有两个例外</p>

<p>/ , null character(a zero byte)</p>

<p>the POSIX Portable Filename Character Set</p>

<p>uppercase letters A-Z, lowercase letters a-z, numerals 0-9, period (.), hyphen
(-), and underscore(_).</p>

<p>检查input</p>

<p>要会写测试</p>

<p>利用echo输出</p>

<p>在更改的地方加注释，方便恢复。</p>

<p>test case</p>

<p>case要反映edge and corner</p>

<p>debug技术</p>

<p>commenting out :部分注释</p>

<p>tracing :在一些关键点增加输出，查看是否执行到这里了</p>

<p>可以在script的第一行加入x option:</p>

<pre><code>#!/bin/bash -x
</code></pre>

<p>也可以用set设置部分tracing</p>

<pre><code>set -x # turn on
...
set +x # turn off
</code></pre>

<p>输出中间过程中变量的值</p>

<p>推荐《The Art of Unix Programming》</p>

<h2 id="31-流程控制-case分支">31 流程控制 case分支</h2>

<p>case的用法</p>

<pre><code>  #!/bin/bash
  # case-menu

  clear
  echo &quot;
  please select:

1. display system information
2. display disk space
3. display home space utilization
0. quit
&quot;
read -p &quot;enter selection [0-3] &gt; &quot;

case &quot;$REPLY&quot; in
    0)  echo &quot;program terminated&quot;
        exit
        ;;
    1)  echo &quot;hostname: $HOSTNAME&quot;
        uptime
        ;;
    2)  df -h
        ;;
    3) if [[ &quot;$(id -u)&quot; -eq 0 ]]; then
            echo &quot;home space utilization (all users)&quot;
            du -sh /home/*
        else
            echo &quot;home space utilization ($USER)&quot;
            du -sh &quot;$HOME&quot;
        fi
        ;;
    *)  echo &quot;invalid entry&quot; &gt;&amp;2
        exit 1
        ;;
esa
</code></pre>

<h2 id="32-位置参数">32 位置参数</h2>

<p>讲处理command的option</p>

<p>positional parameter</p>

<p>$0是当前命令的路径。</p>

<p>注意它的含义：</p>

<p>Note that $0 always contains the full pathname of the first item on the
command line (i.e., the name of the program) and does not contain the name of
the shell function as we might expect.</p>

<p>是整个路径，不是命令的名字。</p>

<p>大于9时用大括号括起来。</p>

<p>参数个数：$#</p>

<p>shift</p>

<p>让$1下次变成 2 ， 所 有 参 数 都 移 动 ， 2，所有参数都移动， 2，所有参数都移动，#减1</p>

<p>basename</p>

<p>去除文件名前面的字符，只要文件名。</p>

<p>positional parameter也可以用在function中</p>

<p>Difference between echo -e “” and echo $“”</p>

<p>e的意思就是扩展，支持转义，e和$支持的符号部分不相同。</p>

<p>∗ 和 *和 ∗和@的区别</p>

<p>不加双引号时是一样的，遇到空格就拆分，加双引号时不一样， ∗ 会 将 所 有 参 数 放 到 一 个 字 符 串 中 ， *会将所有参数放到一个字符串中，
∗会将所有参数放到一个字符串中，@会将每个输入的参数分别当作参数，也就是不区分输入时的空格。</p>

<p>$@经常用。</p>

<h2 id="33-流程控制-for循环">33 流程控制:for循环</h2>

<p>讲for</p>

<pre><code># 两种风格

for variable [in words]; do
    commands
done

# c语言的

for (( expression1; expression2; expression3 )); do
    commands
done
</code></pre>

<p>例子：</p>

<pre><code>[me@linuxbox ~]$ for i in A B C D; do echo $i; done
</code></pre>

<p>Create list:</p>

<pre><code>itscs-MacBook-Pro:~ itsc$ for i in {A..D}; do echo $i; done

# 文件列表 pathname expansion
itscs-MacBook-Pro:learnCommandLine itsc$ for i in dis*.txt; do echo &quot;$i&quot;; done
</code></pre>

<h2 id="34-字符与数字">34 字符与数字</h2>

<p>一般情况下将变量括起来，防止被拆分</p>

<p>parameter expansion是什么？</p>

<p>变量是其中的一种</p>

<p>大括号的作用</p>

<pre><code>$a
${a}
a=&quot;foo&quot;
echo &quot;${a}_file&quot; # 和其它字符相连时防止形成不存在的变量
</code></pre>

<p>处理空的和不存在的字符</p>

<pre><code>parameter为空或者不存在就用word，存在就用它自己。
${parameter:-word}

和上面基本一样，区别：要赋值。
${parameter:=word}

unset和empty就发发送word到error
${parameter:?word}

${parameter:+word}
</code></pre>

<p>String operation(字符串操作符)</p>

<pre><code>${#parameter} # 换成长度

$ foo=&quot;This string is long.&quot;
$ echo &quot;'$foo' is ${#foo} characters long.
'This string is long.' is 20 characters long

${parameter:offset}
${parameter:offset:length}
[me@linuxbox ~]$ foo=&quot;This string is long.&quot;
[me@linuxbox ~]$ echo ${foo:5}
string is long.
[me@linuxbox ~]$ echo ${foo:5:6}
string

删除一部分
${parameter#pattern}
${parameter##pattern}
[me@linuxbox ~]$ foo=file.txt.zip
[me@linuxbox ~]$ echo ${foo#*.}
txt.zip
[me@linuxbox ~]$ echo ${foo##*.}
zip

反着删除
${parameter%pattern}
${parameter%%pattern}
[me@linuxbox ~]$ foo=file.txt.zip
[me@linuxbox ~]$ echo ${foo%.*}
file.txt
[me@linuxbox ~]$ echo ${foo%%.*}
file

替换
${parameter/pattern/string}
${parameter//pattern/string}
${parameter/#pattern/string}
${parameter/%pattern/string}
</code></pre>

<p>可以用expansion来提高script的效率</p>

<p>大小写转换</p>

<p>可以用来做什么？比如数据库的查找，匹配的时候把输入和数据库中的都统一大小写。</p>

<p>declare</p>

<p>shell不能进行浮点运算</p>

<pre><code>itscs-MacBook-Pro:learnCommandLine itsc$ echo $((3.3+4.2))
-bash: 3.3+4.2: syntax error: invalid arithmetic operator (error token is &quot;.3+4.2&quot;)
</code></pre>

<p>解决：perl, awk.书里用最简单的bc</p>

<p>为什么连浮点运算都不支持？真是麻烦。</p>

<h2 id="35-数组">35 数组</h2>

<p>scalar variables</p>

<p>Single value</p>

<p>shell的array只能一维</p>

<pre><code>[me@linuxbox ~]$ a[1]=foo
[me@linuxbox ~]$ echo ${a[1]}
foo
[me@linuxbox ~]$ declare -a a

\# assign
name[subscript]=value
name=(value1 value2 ...)
[me@linuxbox ~]$ days=(Sun Mon Tue Wed Thu Fri Sat)
[me@linuxbox ~]$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)
</code></pre>

<p>遍历array</p>

<pre><code>[me@linuxbox ~]$ animals=(&quot;a dog&quot; &quot;a cat&quot; &quot;a fish&quot;)
[me@linuxbox ~]$ for i in ${animals[*]}; do echo $i; done
[me@linuxbox ~]$ for i in ${animals[@]}; do echo $i; done
[me@linuxbox ~]$ for i in &quot;${animals[*]}&quot;; do echo $i; done
[me@linuxbox ~]$ for i in &quot;${animals[@]}&quot;; do echo $i; done
</code></pre>

<p>bash的array不一定是要连续的</p>

<p>所以需要有方法知道哪些位置上有值</p>

<pre><code>[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)

[me@linuxbox ~]$ for i in &quot;${foo[@]}&quot;; do echo $i; done
a
b
c

[me@linuxbox ~]$ for i in &quot;${!foo[@]}&quot;; do echo $i; done
2
4
6
</code></pre>

<p>array的追加</p>

<pre><code>$ foo=(a b c)
$ foo[100]=e
$ echo ${foo[@]}
a b c e
$ foo+=(k l)
$ echo ${foo[@]}
a b c e k l
$ for i in &quot;${foo[@]}&quot;; do echo $i; done
a
b
c
e
k
l
$ for i in &quot;${!foo[@]}&quot;; do echo $i; done
0
1
2
100
101
102
</code></pre>

<p>subscript不是连续的</p>

<p>associative arrays</p>

<p>下标可以是字符</p>

<h2 id="36-特殊">36 特殊</h2>

<p>讲一些不常用的，在特定场景下使用的</p>

<p>Group Commands And Subshells</p>

<pre><code>Group command:
{ command1; command2; [command3; ...] }
Subshell:
(command1; command2; [command3;...])
</code></pre>

<p>它们是做什么的？</p>

<p>manage redirection</p>

<pre><code>{ ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt; } &gt; output.txt
(ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt) &gt; output.txt
</code></pre>

<p>结合pip</p>

<pre><code>{ ls -l; echo &quot;Listing of foo.txt&quot;; cat foo.txt; } | lpr
</code></pre>

<p>注意大括号的使用</p>

<p>due to the way bash implements</p>

<p>group commands, the braces must be separated from the commands by a space and
the</p>

<p>last command must be terminated with either a semicolon or a newline prior to
the closing brace.</p>

<p>group和subshell的区别</p>

<p>subshell和它的名字一样，返回时enviroment会丢失，所以一般情况下用group.</p>

<pre><code>echo &quot;foo&quot; | read
echo $REPLY # 这就是subshell的例子，reply是空的
</code></pre>

<p>commands in pipelines are always executed in subshells</p>

<p>process substitution</p>

<p>用来解决subshell的问题</p>

<pre><code>read &lt;&lt;(echo &quot;foo&quot;)
echo $REPLY
</code></pre>

<h2 id="37-asynchronous-execution">37 asynchronous execution</h2>

<p>什么是异步？</p>

<p>什么是阻塞，非阻塞，同步，异步？</p>

<p>举个打电话的例子：</p>

<p>阻塞/同步：打一个电话一直到有人接为止</p>

<p>非阻塞：打一个电话没人接，每隔10分钟再打一次，知道有人接为止</p>

<p>异步：打一个电话没人接，转到语音邮箱留言（注册），然后等待对方回电（call back)</p>

<p>看起来异步是最高效，充分利用资源，可以想像整个系统能支持大规模并发。但问题是调试很麻烦，不知道什么时候call back。</p>

<p>Named pipes</p>

<p>create a connection between two processes and can be</p>

<p>used just like other types of files.</p>

<p>named pipe是一个文件起着pipe的作用</p>

<pre><code>[me@linuxbox ~]$ mkfifo pipe1

[me@linuxbox ~]$ ls -l pipe1
prw-r--r-- 1 me me 0 2009-07-17 06:41 pipe1

# terminal 1
[me@linuxbox ~]$ ls -l &gt; pipe1

# terminal2
[me@linuxbox ~]$ cat &lt; pipe1
</code></pre>

<h2 id="问题">问题</h2>

<p>[[:upper:]]哪一节的？</p>

<p>每个文件夹下的.和…的作用？为什么必须要有它们？</p>

<p>它们代表当前和前一级目录，这个大家都知道，可以为什么要有它们？设计原理是什么？</p>

<p>参考：SO，只说了有，没有说什么为什么。</p>

<p>shell中各种括号[]、[[]]的作用与区别？</p>

<p>参考。</p>

<h2 id="需要了解的知识">需要了解的知识</h2>

<p>linux文件系统</p>

<p>磁盘、分区及Linux文件系统 [Disk, Partition, Linux File System</p>

<p>硬盘接口</p>

<p>IDE、SATA、SCSI、SAS、FC、SSD硬盘类型介绍</p>

<p>Understand synopsis in manpage</p>

<p>可以直接在命令man man中看。</p>

<p>vi color</p>

<p>ENABLING VI SYNTAX COLORS</p>

<pre><code>cd ~
vi .vimrc
syntax on
colorscheme desert
</code></pre>

<p>vi indent</p>

<pre><code># 添加到vimrc中即永久：
set tabstop=4
</code></pre>

<p>标准错误输出&gt;&amp;2输出到哪了？屏幕。</p>

<p>vim color</p>

<p>/usr/share/vim/vim74/colors/</p>

<p>我觉得还不错的：</p>

<p>koehler</p>

<p>industry</p>

<p>murphy</p>

<p>ron</p>

<p>ls如何按文件类型排序？</p>

<pre><code>ls -lX
</code></pre>

<p>vi comment</p>

<p>Reveal the line numbers:</p>

<pre><code>:set number

#then 
:5,$s/^/#/g     comment 
#or
:5,$s/^/#/      uncomment
</code></pre>

<p>单引号、双引号区别</p>

<pre><code>echo $1
echo &quot;$1&quot;
echo '$1'

$ ./longest words
words
words
</code></pre>

<p>双引号与无引号在这里是一样的，双引号的作用体现在字符串为空的时候，为空的时候是空字符串，可以判断，而无引号就麻烦了，比如等号，一边为空会报错，说等号是个二元操作符两边都要有值。单引号的作用就是禁止转义，全部为字符串。</p>

<p>linux中shell变量#,#,@,0,0,1,$2的含义解释</p>

<p>转自 通过《 The Linux Command Line》入门linux命令行</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>