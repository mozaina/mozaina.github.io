<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux之Shell脚本自动化编程二bash脚本混合编程和子shell | 开发者问答集锦</title>
    <meta property="og:title" content="Linux之Shell脚本自动化编程二bash脚本混合编程和子shell - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux之Shell脚本自动化编程二bash脚本混合编程和子shell">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E7%A8%8B%E4%BA%8Cbash%E8%84%9A%E6%9C%AC%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E5%92%8C%E5%AD%90shell/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux之Shell脚本自动化编程二bash脚本混合编程和子shell</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="bash脚本混合编程">bash脚本混合编程</h1>

<p>脚本混合编程说的是在bash的脚本里面可以加入python等其他编程脚本语言的，但是根据我们上一讲所讲的内容，#!这种shebang只在第一行才有效果，那也就说只能指定一个解释器，那么如何混合编程呢？其实c和汇编混合编程还是很常见的，不过我也没有实际去编过，我们前面学了python，我们就来看bash脚本里如何运行一段python。其实就是用了之前学过的一个输入重定向，没有那么难。</p>

<p><a href="https://img.it610.com/image/info8/29ad507400cb49ddaa9142b1dec778fa.png"><img src="https://img.it610.com/image/info8/29ad507400cb49ddaa9142b1dec778fa.png" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第1张图片" /></a></p>

<p>看到我们也就是用了一个输入重定向给/usr/bin/python去解释执行。 &lt;</p>

<p><a href="https://img.it610.com/image/info8/c781408ed2ce44f2b4e4cd5d96b19d08.jpg"><img src="https://img.it610.com/image/info8/c781408ed2ce44f2b4e4cd5d96b19d08.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第2张图片" /></a></p>

<p>如果代码有缩进。</p>

<p><a href="https://img.it610.com/image/info8/3e6695428818497083aea65fd9903334.jpg"><img src="https://img.it610.com/image/info8/3e6695428818497083aea65fd9903334.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第3张图片" /></a></p>

<p>不加-，EOF顶头的话，就会显示缩进错误。如果加一个-，就没有问题了。</p>

<p><a href="https://img.it610.com/image/info8/449b491008fd49069c0d16b6b947214f.jpg"><img src="https://img.it610.com/image/info8/449b491008fd49069c0d16b6b947214f.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第4张图片" /></a></p>

<p>下面这样也是不行的。</p>

<p><a href="https://img.it610.com/image/info8/d4c4b4ef599547d880e0f009e498b798.jpg"><img src="https://img.it610.com/image/info8/d4c4b4ef599547d880e0f009e498b798.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第5张图片" /></a></p>

<p>加了-的话前面有缩进也是可以的。</p>

<p><a href="https://img.it610.com/image/info8/580d46f5aa9a4b108546f3f622e5f95c.jpg"><img src="https://img.it610.com/image/info8/580d46f5aa9a4b108546f3f622e5f95c.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第6张图片" /></a></p>

<p>这种写法就很方便了，因为你不需要写完python之后再在下一行顶头写了，看着也很整齐，对于有强迫症的人来说是很重要的，就像我。另外如果你看bash脚本的执行结果，就会发现，即使上一行有错误，下一行还是可以执行，这和python是不一样的。</p>

<p><a href="https://img.it610.com/image/info8/927264fb001c48faa1b2d81a1c74b40a.gif"><img src="https://img.it610.com/image/info8/927264fb001c48faa1b2d81a1c74b40a.gif" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第7张图片" /></a></p>

<p>python脚本里面是第一行错了第二行不可能执行的，在bash里面也是。</p>

<p><a href="https://img.it610.com/image/info8/7a95b94d260e44d39850efeacefc04f1.jpg"><img src="https://img.it610.com/image/info8/7a95b94d260e44d39850efeacefc04f1.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第8张图片" /></a></p>

<p>在python脚本里面是不能执行bash代码的，因为bash的命令不是python的关键字，在python脚本里面是不识别的。</p>

<p><a href="https://img.it610.com/image/info8/3eb0c24c1302417b945914c68a199ebc.png"><img src="https://img.it610.com/image/info8/3eb0c24c1302417b945914c68a199ebc.png" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第9张图片" /></a></p>

<p>执行bash脚本的时候还需要注意一个问题，就是哪个shell执行的问题。</p>

<h1 id="子shell">子shell</h1>

<p><a href="https://img.it610.com/image/info8/7e451add2a03469d81c94cee36110e25.png"><img src="https://img.it610.com/image/info8/7e451add2a03469d81c94cee36110e25.png" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第10张图片" /></a></p>

<p>看到脚本执行的cd并没有改变当前shell的路径。但是我们如果在前面加.或者source就是在当前shell里面执行。</p>

<p><a href="https://img.it610.com/image/info8/542b3ee63b9440d7ae76611dd71d2ced.jpg"><img src="https://img.it610.com/image/info8/542b3ee63b9440d7ae76611dd71d2ced.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第11张图片" /></a></p>

<p>source和.可以让脚本在当前shell里面执行。</p>

<p><a href="https://img.it610.com/image/info8/aec2ded3f1a74340abd4ba513e82d5e4.jpg"><img src="https://img.it610.com/image/info8/aec2ded3f1a74340abd4ba513e82d5e4.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第12张图片" /></a></p>

<p>那前面没有加.或者source的时候脚本去哪里执行了呢？其实是去子shell里面执行了。什么是子shell呢？参考了<a href="https://www.linuxidc.com/Linux/2017-08/146606.htm">https://www.linuxidc.com/Linux/2017-08/146606.htm</a></p>

<p>子shell的概念贯穿整个shell，写shell脚本时更是不可不知。所谓子shell，即从当前shell环境新开一个shell环境，这个新开的shell环境就称为子shell(subshell)，而开启子shell的环境称为该子shell的父shell。子shell和父shell的关系其实就是子进程和父进程的关系，只不过子shell和父shell是关联的进程是bash进程。子shell会从父shell中继承很多环境，如变量、命令全路径、文件描述符、当前工作目录、陷阱等等，但子shell有很多种类型，不同类型的子shell继承的环境不相同。可以使用
<strong>$BASH_SUBSHELL</strong> 变量来查看从当前进程开始的子shell层数， <strong>$BASHPID</strong>
查看当前所处BASH的PID，这不同于特殊变量&rdquo;$$&ldquo;值，因为&rdquo;$$&ldquo;会从父进程继承。</p>

<p><strong>何时产生子shell?</strong></p>

<p>要解释清楚子shell以及产生何种类型的子shell，需要搞清楚Linux中如何产生子进程。Linux上创建子进程的方式有三种：一种是fork出来的进程，一种是exec出来的进程，一种是clone出来的进程。此处无需关心clone，因为它用来实现Linux中的线程。</p>

<p>(1).fork是复制进程，它会复制当前进程的副本(不考虑写时复制的模式)，以适当的方式将这些资源交给子进程。所以子进程掌握的资源和父进程是一样的，包括内存中的内容，所以也包括环境变量和变量。但父子进程是完全独立的，它们是一个程序的两个实例。</p>

<p>(2).exec是加载另一个应用程序，替代当前运行的进程，也就是说在不创建新进程的情况下加载一个新程序。exec还有一个动作：在进程执行完毕后，退出exec所在的shell环境。</p>

<p>所以为了保证进程安全， <strong>若要形成新的且独立的子进程，都会先fork一份当前进程，然后在fork出来的子进程上调用exec来加载新程序替代该子进程</strong>
。例如在bash下执行cp命令，会先fork出一个bash，然后再exec加载cp程序覆盖子bash进程变成cp进程。再来说明子shell的问题。一般fork出来的子进程，内容和父进程是一样的(包括变量)，例如执行cp命令时也能获取到父进程的变量。但是cp命令在哪里执行呢？执行cp命令敲入回车后，当前的bash进程fork出一个子bash，然后子bash通过exec加载cp程序替代子bash。这算是进入了子shell吗？更通用的问题是：什么情况下会进入子shell环境，什么时候不进入子shel环境呢？判断是否进入了子shell的方式非常简单，执行&rdquo;echo
$BASHPID&rdquo;，如果该值和父bash进程的pid值不同，则表示进入了子shell。在shell中是否进入子shell的情况可以分为几种：</p>

<p><a href="https://img.it610.com/image/info8/494fb6b2c4e341e180911940e1811a6f.jpg"><img src="https://img.it610.com/image/info8/494fb6b2c4e341e180911940e1811a6f.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第13张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/afc7e51bfb1c4ee3b061db7b7527bd27.jpg"><img src="https://img.it610.com/image/info8/afc7e51bfb1c4ee3b061db7b7527bd27.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第14张图片" /></a></p>

<p>$$变量被继承了，expr是以标准输出格式打印表达式的值，表达式也有很多格式，里面还会有逻辑运算，比较运算，算术运算，这不是我们今天的重点，并且其实也不难，并且其实用echo也可以输出，这里稍微补充一下下面的内容，参考了<a href="https://www.cnblogs.com/hyc-">https://www.cnblogs.com/hyc-</a>
blog/p/7880163.html</p>

<p><a href="https://img.it610.com/image/info8/71dae5bfe7df4282b4401e100e5f85cc.jpg"><img src="https://img.it610.com/image/info8/71dae5bfe7df4282b4401e100e5f85cc.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第15张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/89eea82cc1cc4f559e50fa2a5ce38cbe.jpg"><img src="https://img.it610.com/image/info8/89eea82cc1cc4f559e50fa2a5ce38cbe.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第16张图片" /></a></p>

<p>|的意思是如果arg1不是null或者0，就返回arg1，否则返回arg2。&amp;的意思是如果参数都不是null或者0，换句话说就是有一个参数是0或者null，那么就返回arg1，否则返回0。</p>

<p><a href="https://img.it610.com/image/info8/e48769cffa3446fdb9b2243009b80cf5.jpg"><img src="https://img.it610.com/image/info8/e48769cffa3446fdb9b2243009b80cf5.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第17张图片" /></a></p>

<p>let上面是用来给变量赋值，但是其实let也可以完成一些运算。</p>

<p><a href="https://img.it610.com/image/info8/9f89052873584cc59f08bf7ecdc01e9e.jpg"><img src="https://img.it610.com/image/info8/9f89052873584cc59f08bf7ecdc01e9e.jpg" alt="" /></a></p>

<p>我们下面先来体会一下echo和expr区别。</p>

<p><a href="https://img.it610.com/image/info8/59b53d3d32d14a52a33bd7ba60e0b7db.png"><img src="https://img.it610.com/image/info8/59b53d3d32d14a52a33bd7ba60e0b7db.png" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第18张图片" /></a></p>

<p>区别应该已经显而易见了，expr是可以进行运算的，不过格式是运算符前后都要有空格，否则也不认为是要运算，echo是根本就不能进行运算，只是照本宣科。其实let也是可以进行运算的，而且根据<a href="http://daizj.iteye.com/blog/2255906">http://daizj.iteye.com/blog/2255906</a></p>

<p>let执行的效率要高于expr，但是let有一点缺点就是不能直接输出。</p>

<p><a href="https://img.it610.com/image/info8/2c32451d42b54d71806b179504381f34.jpg"><img src="https://img.it610.com/image/info8/2c32451d42b54d71806b179504381f34.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第19张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/e4accafdf2894f7ea8b7bb32f0274480.jpg"><img src="https://img.it610.com/image/info8/e4accafdf2894f7ea8b7bb32f0274480.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第20张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/cb1d65b6ed4548f388293c9633d37628.jpg"><img src="https://img.it610.com/image/info8/cb1d65b6ed4548f388293c9633d37628.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第21张图片" /></a></p>

<p>&amp;这个符号在前面作业管理那里见过，在一个命令后面加这个，就会把进程放在后台运行。|是要进程管道的连接符，它们都需要转义或者说修饰。</p>

<p><a href="https://img.it610.com/image/info8/f39662964ca14ccba48d09ed1db3311d.jpg"><img src="https://img.it610.com/image/info8/f39662964ca14ccba48d09ed1db3311d.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第22张图片" /></a></p>

<p>好了好了，我们先扯回去，我们现在说的是子shell这个事情。上面看到的结果是进程管道后面的命令确实是在子shell里面执行的，而不是在当前shell下面执行的。</p>

<p><a href="https://img.it610.com/image/info8/0bb0068abc884028b31ad27597c6c1b6.jpg"><img src="https://img.it610.com/image/info8/0bb0068abc884028b31ad27597c6c1b6.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第23张图片" /></a></p>

<p>并且子shell进程很快就会结束了，而且子shell里面的变量是没有传到父shell里面的，这其实很好理解，一般都是子承父业。</p>

<p><a href="https://img.it610.com/image/info8/51de19044b564f0aadac0182f8de416e.jpg"><img src="https://img.it610.com/image/info8/51de19044b564f0aadac0182f8de416e.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第24张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/7bedc5a5730544268b714e1dd962764e.jpg"><img src="https://img.it610.com/image/info8/7bedc5a5730544268b714e1dd962764e.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第25张图片" /></a></p>

<p>给定的变量被自动标记导出到之后的执行的命令环境中，也就是之后的命令都会按照新赋给这个变量的值来打印。</p>

<p><a href="https://img.it610.com/image/info8/6950653f4fc541f4aa00b3a251ee70eb.jpg"><img src="https://img.it610.com/image/info8/6950653f4fc541f4aa00b3a251ee70eb.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第26张图片" /></a></p>

<p>可以看到这个2869的bash
shell确实是2339的一个子进程，$$这个变量没有被继承，我们用exit可以退出这个子shell，然后这个对应的子进程就被处理掉了。</p>

<p><a href="https://img.it610.com/image/info8/afd5c08b1fa94675b9eb849c279910d4.jpg"><img src="https://img.it610.com/image/info8/afd5c08b1fa94675b9eb849c279910d4.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第27张图片" /></a></p>

<p>但是看到$BASH_SUBSHELL的值好像一直都是0，不知道出什么问题了。</p>

<p><a href="https://img.it610.com/image/info8/719bb3c5a6e04cb89facb6b791ec07c9.jpg"><img src="https://img.it610.com/image/info8/719bb3c5a6e04cb89facb6b791ec07c9.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第28张图片" /></a></p>

<p>上面第一句断句要断好，意思应该是这样的，脚本中第一行总是#!/bin/bash，这样会可以执行，或者我们直接在bash而不是脚本输入bash
脚本名，就像下面那样，放着不管会造成无限循环，最后out of memory。</p>

<p><a href="https://img.it610.com/image/info8/6a6a9d4266d4497e872f39a337065665.jpg"><img src="https://img.it610.com/image/info8/6a6a9d4266d4497e872f39a337065665.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第29张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/e91e2fa4abec4200be6773f2a96a6865.png"><img src="https://img.it610.com/image/info8/e91e2fa4abec4200be6773f2a96a6865.png" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第30张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/03d1bd0564d445b0a9d829ea78c28646.jpg"><img src="https://img.it610.com/image/info8/03d1bd0564d445b0a9d829ea78c28646.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第31张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/42100331e05a492591a04a30c68cc800.jpg"><img src="https://img.it610.com/image/info8/42100331e05a492591a04a30c68cc800.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第32张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/1a8e46fb13b141f7aa03931f6e182c8e.jpg"><img src="https://img.it610.com/image/info8/1a8e46fb13b141f7aa03931f6e182c8e.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第33张图片" /></a></p>

<p>用sleep来看一下。</p>

<p><a href="https://img.it610.com/image/info8/b51d445c1877495697896d48383db991.gif"><img src="https://img.it610.com/image/info8/b51d445c1877495697896d48383db991.gif" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第34张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/1572c9ea67d84837a4f00ae204993ee6.jpg"><img src="https://img.it610.com/image/info8/1572c9ea67d84837a4f00ae204993ee6.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第35张图片" /></a></p>

<p>这和函数里面打出来的$BASH_SUBSHELL是对的，但是真的不知道为什么其它的方式这个深度有问题，我们也不需要掌握那么深。</p>

<p><a href="https://img.it610.com/image/info8/5ccde22caf6042c09d58ee430869fa43.jpg"><img src="https://img.it610.com/image/info8/5ccde22caf6042c09d58ee430869fa43.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第36张图片" /></a></p>

<p>感觉这位博主应该是把内置和非内置写反了。参考了<a href="https://www.cnblogs.com/pingzhe/p/7077685.html和">https://www.cnblogs.com/pingzhe/p/7077685.html和</a></p>

<p><a href="https://www.cnblogs.com/11hwu2/p/3724986.html">https://www.cnblogs.com/11hwu2/p/3724986.html</a></p>

<p><a href="https://img.it610.com/image/info8/908a4ec0dc9a45219a05f3d7230876b6.jpg"><img src="https://img.it610.com/image/info8/908a4ec0dc9a45219a05f3d7230876b6.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第37张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/afc2e65f115d4fd6a0d57e73158963e2.jpg"><img src="https://img.it610.com/image/info8/afc2e65f115d4fd6a0d57e73158963e2.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第38张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/9d84db0946bc46049de6446bc6aafc00.jpg"><img src="https://img.it610.com/image/info8/9d84db0946bc46049de6446bc6aafc00.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第39张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/971d301326b94784a8c57a86abfb236d.jpg"><img src="https://img.it610.com/image/info8/971d301326b94784a8c57a86abfb236d.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第40张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/dd70a9fe06be4f54a7ed047e70869690.jpg"><img src="https://img.it610.com/image/info8/dd70a9fe06be4f54a7ed047e70869690.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第41张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/5412f687144d463f877f67b7c3fb6a18.jpg"><img src="https://img.it610.com/image/info8/5412f687144d463f877f67b7c3fb6a18.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第42张图片" /></a></p>

<p>上面的博主确实是把写反了，grep是个外部命令，按照上面博主的想法，应该是没有新的bash
的，从下图看，它就是当前BASHPID的进程的一个子进程而已。这和上面函数的情况是不一样的。</p>

<p><a href="https://img.it610.com/image/info8/7551dc3aaf4144ecb3f7ed71fc3815a3.jpg"><img src="https://img.it610.com/image/info8/7551dc3aaf4144ecb3f7ed71fc3815a3.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第43张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/f06f4ab82d354b17ae259cbacd0a846d.jpg"><img src="https://img.it610.com/image/info8/f06f4ab82d354b17ae259cbacd0a846d.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第44张图片" /></a></p>

<p>我猜想这应该也是我上面所说的只有子承父业，子进程被处理以后，a的值又被父进程的shell接管。其实我们没有必要去了解那么深。</p>

<p><a href="https://img.it610.com/image/info8/06e011221eea43ad8805154845fcf88d.jpg"><img src="https://img.it610.com/image/info8/06e011221eea43ad8805154845fcf88d.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第45张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/b2401e4646fa4b8d84c582bd2d575a95.jpg"><img src="https://img.it610.com/image/info8/b2401e4646fa4b8d84c582bd2d575a95.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第46张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/a390f5f1801c49e0b148c5754ff09f3b.jpg"><img src="https://img.it610.com/image/info8/a390f5f1801c49e0b148c5754ff09f3b.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第47张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/402aa58252334209b67e2a9f4f1640fa.jpg"><img src="https://img.it610.com/image/info8/402aa58252334209b67e2a9f4f1640fa.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第48张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/0842f7dd97dd4c61a89ce036d5d0c067.jpg"><img src="https://img.it610.com/image/info8/0842f7dd97dd4c61a89ce036d5d0c067.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第49张图片" /></a></p>

<p>这种也看不见新的bash，而是sleep进程的父进程直接就是3816。</p>

<p><a href="https://img.it610.com/image/info8/dbb609794aaa479695466fdbce4d613c.jpg"><img src="https://img.it610.com/image/info8/dbb609794aaa479695466fdbce4d613c.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第50张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/879f4b2dd844470a83ed3819dfefaaa6.jpg"><img src="https://img.it610.com/image/info8/879f4b2dd844470a83ed3819dfefaaa6.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第51张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/5b14139ab5124608bfdbfb209a017a88.jpg"><img src="https://img.it610.com/image/info8/5b14139ab5124608bfdbfb209a017a88.jpg" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第52张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/2b478a8208ce4eaa8f8c8eb07f310071.png"><img src="https://img.it610.com/image/info8/2b478a8208ce4eaa8f8c8eb07f310071.png" alt="Linux之Shell脚本自动化编程二（bash脚本混合编程和子shell）_第53张图片" /></a></p>

<p>整个顺下来其实有点懵，这篇文章写于2017-8-13，可能我们现在用的centos7，它用的可能不是，这篇已经算是比较新的了，不过还是有参考价值的，它已经把我们上面执行脚本cd的疑问解决了，那么这一讲就先到这里。</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>