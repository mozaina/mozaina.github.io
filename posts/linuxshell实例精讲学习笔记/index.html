<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>LinuxShell实例精讲学习笔记 | 开发者问答集锦</title>
    <meta property="og:title" content="LinuxShell实例精讲学习笔记 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="LinuxShell实例精讲学习笔记">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E5%AE%9E%E4%BE%8B%E7%B2%BE%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">LinuxShell实例精讲学习笔记</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>第一章：shell基础</p>

<p><del>●umask &ndash;查看当前用户创建文件或文件夹时的默认权限</del></p>

<p><del>eg：</del></p>

<p><del>[test@szbirdora 1]$umask</del></p>

<p><del>0002</del></p>

<p><del>[test@szbirdora 1]$ls -lh</del></p>

<p><del>-rw-rw-r&ndash; test test myfile</del></p>

<p><del>drwxrwxr-x test test 1</del></p>

<p><del>上面的例子中我们看到由test默认创建的文件myfile和文件夹1的权限分别为664，775.而通过umask查到的默认权限为0002.所以可以推断出umask的计算算法为：</del></p>

<p><del>umask file directory</del></p>

<p><del>0 6 7</del></p>

<p><del>1 5 6</del></p>

<p><del>2 4 5</del></p>

<p><del>3 3 4</del></p>

<p><del>4 2 3</del></p>

<p>~~5 ~~~~ 1 2~~</p>

<p><del>6 0 1</del></p>

<p><del>7 0 0</del></p>

<p>●连接ln</p>

<p>硬连接 ln sourcefile targetfile 连接后的target文件大小和source文件一样</p>

<p>软连接 ln -s sourcefile targetfile 类似于windows的快捷方式</p>

<p>●shell script 基本结构</p>

<p>#!/bin/bash &mdash;&mdash;&ndash;bash shell开头必须部分</p>

<h1 id="description-注释部分-可有可无-为了阅读方便最好加以说明">description &mdash;&mdash;&ndash;注释部分（可有可无，为了阅读方便最好加以说明）</h1>

<p>variable name=value &mdash;&mdash;&mdash;变量部分，声明变量，赋值</p>

<p>control segment &mdash;&mdash;&mdash;流程控制结构，如判断、循环、顺序</p>

<p>eg.</p>

<p>helloworld.sh</p>

<p>#!/bin/bash</p>

<h1 id="this-is-a-helloworld-shell-script">This is a helloworld shell script</h1>

<p>printchar = &ldquo;hello world&rdquo;</p>

<p>echo $printchar</p>

<p>[test@szbirdora 1]$sh helloworld.sh</p>

<p>hello world</p>

<p>●shell 特性</p>

<p>①别名 alias eg. alias ll = “ls -l”</p>

<p>②管道 a |b 将a命令的输出作为b命令的输入</p>

<p>eg.</p>

<p>ls |sort 将ls列举的项排序</p>

<p>③命令替换 a <code>b</code> 将b命令的输出作为a命令的输入</p>

<p>eg.</p>

<p>ls <code>cat myfile</code> 列举出cat myfile的输出项</p>

<p>④后台运行 nohup command&amp; 可通过jobs -l查看后台运行的脚本</p>

<p>⑤重定向 &gt;,</p>

<p>⑥变量 可以用$varname 来调用变量</p>

<p>⑦特殊字符</p>

<p>`用来替换命令</p>

<p>\用来使shell无法认出其后的特殊字符，使其失去特殊含义</p>

<p>;允许一行放多个命令</p>

<p>() 创建成组的命令 ？？</p>

<p>{} 创建命令块 ？？</p>

<p>第二章：变量和运算符</p>

<p>●本地变量：在用户现在的shell生命期的脚本中使用。设置变量：various_name=value.可用set 来查看。用readonly可以使变量只读。</p>

<p>●环境变量：用于当前用户下所有用户进程（不限于现在的shell）。</p>

<p>设置变量：export various_name=value。用env查看。</p>

<p>用readonly可以使变量只读。</p>

<p>●变量替换</p>

<p>echo ${variable name} 显示实际值到variable name</p>

<p>echo ${variable name:+value} 如果设置了variable name，则显示其值，否则为空</p>

<p>echo ${variable name:?value} 如果未设置variable name，则显现用户定义错误信息value</p>

<p>echo ${variable name:-value} 如果未设置，则显示其值</p>

<p>echo ${variable name:=value} 如果未设置，则设置其值，并显示</p>

<p>●清除变量 unset variable name</p>

<p>●位置变量</p>

<p>位置变量表示$0,$1,$2&hellip;$9</p>

<p>$0 &mdash;-脚本名字</p>

<p>$1 &mdash;-根据参数位置表示参数1</p>

<p>eg.</p>

<p>#! /bin/bash</p>

<p>#parm.sh</p>

<p>echo &ldquo;This is script name : $0&rdquo;</p>

<p>echo &ldquo;This is parameter 1: $1&rdquo;</p>

<p>echo &ldquo;This is parameter 2: $2&rdquo;</p>

<p>[test@szbirdora 1]$sh parm.sh a b</p>

<p>This is script name : parm.sh</p>

<p>This is parameter 1: a</p>

<p>This is parameter 2: b</p>

<p>●向系统中传递位置变量</p>

<p>#!/bin/bash</p>

<p>#parm.sh</p>

<p>find /u01/test/1 -name $1 -print</p>

<p>[test@szbirdora 1]$ sh parm.sh myfile</p>

<p>/u01/test/1/myfile</p>

<p>●标准变量 bash默认建立了一些标准环境变量，可在/etc/profile中定义</p>

<p>EXINIT</p>

<p>HOME</p>

<p>IFS</p>

<p>LOGNAME &ndash;当前登录用户名</p>

<p>MAIL</p>

<p>MAILPATH</p>

<p>PATH</p>

<p>TERM &ndash;终端信息</p>

<p>TZ &ndash;时区</p>

<p>PS1 &ndash;登录提示，如[test@szbirdora 1]$</p>

<p>[test@szbirdora 1]$ echo $PS1</p>

<p>[\u@\h \W]\$ &ndash;\u -user &ndash;\h -host &ndash;\W -document</p>

<p>PS2 &ndash;一命令多行，换行提示,如&gt;</p>

<p>PWD &ndash;当前目录</p>

<p>MAILCHECK &ndash;每隔多少秒检查是否有新邮件</p>

<p>[test@szbirdora 1]$ echo $MAILCHECK</p>

<p>60</p>

<p>SHELL</p>

<p>MANPATH &ndash;帮助文档位置</p>

<p>TERMINFO &ndash;终端信息</p>

<p>●特殊变量</p>

<p>$# 传递到脚本的参数个数</p>

<p>$* 以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</p>

<p>$$ 脚本运行的当前进程ID号</p>

<p>$! 后台运行的最后一个进程的进程ID号</p>

<p>$@ 传递到脚本的参数列表，并在引号中返回每个参数</p>

<p>$- 显示shell使用的当前选项，与set命令功能相同</p>

<p>$? 显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>

<p>eg.</p>

<p>#!/bin/bash</p>

<p>#parm</p>

<p>echo &ldquo;this is shellname: $0&rdquo;</p>

<p>echo &ldquo;this is parm1 : $1&rdquo;</p>

<p>echo &ldquo;this is parm2 : $2&rdquo;</p>

<p>echo &ldquo;show parm number : $#&rdquo;</p>

<p>echo &ldquo;show parm list : $*&rdquo;</p>

<p>echo &ldquo;show process id: $$&rdquo;</p>

<p>echo &ldquo;show precomm stat: $?&rdquo;</p>

<p>[test@szbirdora 1]$ sh parm.sh a b</p>

<p>this is shellname: parm.sh</p>

<p>this is parm1 : a</p>

<p>this is parm2 : b</p>

<p>show parm number : 2</p>

<p>show parm list : a b</p>

<p>show process id: 24544</p>

<p>show precomm stat: 0</p>

<p>●影响变量的命令</p>

<p>declare 设置或显示变量</p>

<p>-f 只显示函数名</p>

<p>-r 创建只读变量</p>

<p>-x 创建转出变量</p>

<p>-i 创建整数变量</p>

<p>使用+替代-，可以颠倒选项的含义</p>

<p>export</p>

<p>-p 显示全部全局变量</p>

<p>shift[n] 移动位置变量，调整位置变量，使$3赋予$2,使$2赋予$1 n 前移n</p>

<p>typeset 和declare同义</p>

<p>注意：双引号不能解析$,\,`三个字符，所以在双引号中可以引用变量、转义字符、替换变量</p>

<p>单引号可以解析，所以单引号中引用变量等无效</p>

<p>[test@szbirdora 1]$ echo &ldquo;$test&rdquo;</p>

<p>test</p>

<p>[test@szbirdora 1]$ echo &lsquo;$test&rsquo;</p>

<p>$test</p>

<p>●运算符类型</p>

<p>⒈按位运算符</p>

<p>~ 取反</p>

<p>&lt;</p>

<blockquote>
<blockquote>
<p>右移运算符</p>
</blockquote>
</blockquote>

<p>&amp; 与</p>

<p>| 或</p>

<p>^ 异或</p>

<p>$[ ] 表示形式告诉shell对方括号中表达式求值 $[a+b]</p>

<p>2.逻辑运算符</p>

<p>&amp;&amp;</p>

<p>||</p>

<blockquote>
<p>,</p>
</blockquote>

<p>3.赋值运算符</p>

<p>let variablename1 +=variablename1+ varablename2</p>

<p>第三章 shell的输入和输出</p>

<p>1.echo echo [option] string</p>

<p>-e 解析转移字符</p>

<p>-n 回车不换行，linux系统默认回车换行</p>

<p>转移字符 \c \t \f \n</p>

<p>#!/bin/bash</p>

<p>#echo</p>

<p>echo -e &ldquo;this echo&rsquo;s 3 newlne\n\n\n&rdquo;</p>

<p>echo &ldquo;OK&rdquo;</p>

<p>echo</p>

<p>echo &ldquo;this is echo&rsquo;s 3 ewline\n\n\n&rdquo;</p>

<p>echo &ldquo;this log file have all been done&rdquo;&gt;mylogfile.txt</p>

<p>[test@szbirdora ~]$ sh echod.sh</p>

<p>this echo&rsquo;s 3 newlne</p>

<p>OK</p>

<p>this is echo&rsquo;s 3 ewline\n\n\n</p>

<p>上面可以看到有-e则可以解析转移字符，没有不能解析。echo空输出为空</p>

<p>2.read 可以从键盘或文件的某一行文本中读入信息，并将其赋给一个变量</p>

<p>read variable1 variable2</p>

<p>eg.</p>

<p>#!/bin/bash</p>

<p>#readname</p>

<p>echo -n &ldquo;first name:&rdquo;</p>

<p>read firstname</p>

<p>echo -n &ldquo;last name:&rdquo;</p>

<p>read lastname</p>

<p>echo &ldquo;this name is $firstname $lastname&rdquo;</p>

<p>3.cat 显示文件的内容，创建内容，还可以显示控制字符</p>

<p>cat [options]filename1 filename2</p>

<p>-v 显示控制字符（Windows文件）</p>

<p>cat命令不会分页显示，要分页可以采用more、less</p>

<p>4.管道|</p>

<p>5.tee 把输出的一个副本输送到标准输出，另一个副本拷贝到相应的文件中,一般与管道合用</p>

<p>tee [options] files</p>

<p>-a 在文件中追加</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ echo |tee myfile</p>

<p>[test@szbirdora 1]$ cat myfile</p>

<p>将myfile文件置空</p>

<p>6.文件重定向</p>

<p>command&gt;filename &mdash;覆盖输出</p>

<p>command&gt;&gt;filename &mdash;追加输出</p>

<p>command&gt;filename&gt;&amp;1 &mdash;把标准输出和标准错误重定向</p>

<p>command&lt;</p>

<p>command</p>

<p>command</p>

<blockquote>
<p>nullfile.txt &mdash;创建字节为0的文件</p>
</blockquote>

<p>command1command3 &mdash;按从左到右顺序执行</p>

<p>eg.</p>

<p>说明：myfile为空间</p>

<p>[test@szbirdora 1]$ df -lh&gt;myfile</p>

<p>[test@szbirdora 1]$ cat myfile</p>

<p>Filesystem Size Used Avail Use% Mounted on</p>

<p>/dev/sda1 20G 3.3G 16G 18% /</p>

<p>none 2.0G 0 2.0G 0% /dev/shm</p>

<p>/dev/sda2 79G 17G 59G 23% /u01</p>

<p>/dev/sda4 28G 3.9G 22G 15% /u02</p>

<p>[test@szbirdora 1]$ df -lh&gt;myfile</p>

<p>[test@szbirdora 1]$ cat myfile</p>

<p>Filesystem Size Used Avail Use% Mounted on</p>

<p>/dev/sda1 20G 3.3G 16G 18% /</p>

<p>none 2.0G 0 2.0G 0% /dev/shm</p>

<p>/dev/sda2 79G 17G 59G 23% /u01</p>

<p>/dev/sda4 28G 3.9G 22G 15% /u02</p>

<p>[test@szbirdora 1]$ df -lh&gt;&gt;myfile</p>

<p>[test@szbirdora 1]$ cat myfile</p>

<p>Filesystem Size Used Avail Use% Mounted on</p>

<p>/dev/sda1 20G 3.3G 16G 18% /</p>

<p>none 2.0G 0 2.0G 0% /dev/shm</p>

<p>/dev/sda2 79G 17G 59G 23% /u01</p>

<p>/dev/sda4 28G 3.9G 22G 15% /u02</p>

<p>Filesystem Size Used Avail Use% Mounted on</p>

<p>/dev/sda1 20G 3.3G 16G 18% /</p>

<p>none 2.0G 0 2.0G 0% /dev/shm</p>

<p>/dev/sda2 79G 17G 59G 23% /u01</p>

<p>/dev/sda4 28G 3.9G 22G 15% /u02</p>

<p>[test@szbirdora 1]$ cat &gt;&gt;myfile&lt;</p>

<blockquote>
<p>China</p>

<p>Hubei</p>

<p>Suizhou</p>

<p>exit</p>
</blockquote>

<p>[test@szbirdora 1]$ cat myfile</p>

<p>China</p>

<p>Hubei</p>

<p>Suizhou</p>

<p>7.exec 可以用来替代当前shell。现有任何环境变量都会清除</p>

<p>第四章 控制流结构</p>

<p>1.if语句</p>

<p>if 条件1</p>

<p>then</p>

<p>命令1</p>

<p>elif 条件2</p>

<p>then</p>

<p>命令2</p>

<p>else</p>

<p>命令3</p>

<p>fi</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>if 条件</p>

<p>then 命令</p>

<p>fi</p>

<p>eg：</p>

<p>#!/bin/bash</p>

<p>#if test</p>

<p>#this is a comment line</p>

<p>if [ &ldquo;10&rdquo; -lt &ldquo;12&rdquo; ];then</p>

<p>#yes 10 is less than 12</p>

<p>echo &ldquo;yes,10 is less than 12&rdquo;</p>

<p>else</p>

<p>echo &ldquo;no&rdquo;</p>

<p>fi</p>

<p>注意：if语句必须以fi终止</p>

<p>&ldquo;10&rdquo; 前一个空格，“12”后也有一个空格。这个条件都是通过test命令来指定。条件表达为test expression或者[expression]</p>

<p>条件表达式中的比较函数</p>

<p>man test</p>

<p>NAME</p>

<p>test - check file types and compare values</p>

<p>SYNOPSIS</p>

<p>test EXPRESSION</p>

<p>[ EXPRESSION ]</p>

<p>[ OPTION</p>

<p>DESCRIPTION</p>

<p>Exit with the status determined by EXPRESSION.</p>

<p>--help display this help and exit</p>

<p>--version</p>

<p>output version information and exit</p>

<p>EXPRESSION is true or false and sets exit status. It is one of:</p>

<p>( EXPRESSION )</p>

<p>EXPRESSION is true</p>

<p>! EXPRESSION</p>

<p>EXPRESSION is false</p>

<p>EXPRESSION1 -a EXPRESSION2</p>

<p>both EXPRESSION1 and EXPRESSION2 are true</p>

<p>EXPRESSION1 -o EXPRESSION2</p>

<p>either EXPRESSION1 or EXPRESSION2 is true</p>

<p>[-n] STRING</p>

<p>the length of STRING is nonzero</p>

<p>-z STRING</p>

<p>the length of STRING is zero</p>

<p>STRING1 = STRING2</p>

<p>the strings are equal</p>

<p>STRING1 != STRING2</p>

<p>the strings are not equal</p>

<p>INTEGER1 -eq INTEGER2</p>

<p>INTEGER1 is equal to INTEGER2</p>

<p>INTEGER1 -ge INTEGER2</p>

<p>INTEGER1 is greater than or equal to INTEGER2</p>

<p>INTEGER1 -gt INTEGER2</p>

<p>INTEGER1 is greater than INTEGER2</p>

<p>INTEGER1 -le INTEGER2</p>

<p>INTEGER1 is less than or equal to INTEGER2</p>

<p>INTEGER1 -lt INTEGER2</p>

<p>INTEGER1 is less than INTEGER2</p>

<p>INTEGER1 -ne INTEGER2</p>

<p>INTEGER1 is not equal to INTEGER2</p>

<p>FILE1 -ef FILE2</p>

<p>FILE1 and FILE2 have the same device and inode numbers</p>

<p>FILE1 -nt FILE2</p>

<p>FILE1 is newer (modification date) than FILE2</p>

<p>FILE1 -ot FILE2</p>

<p>FILE1 is older than FILE2</p>

<p>-b FILE</p>

<p>FILE exists and is block special</p>

<p>-c FILE</p>

<p>FILE exists and is character special</p>

<p>-d FILE</p>

<p>FILE exists and is a directory</p>

<p>-e FILE</p>

<p>FILE exists</p>

<p>-f FILE</p>

<p>FILE exists and is a regular file</p>

<p>-g FILE</p>

<p>FILE exists and is set-group-ID</p>

<p>-h FILE</p>

<p>FILE exists and is a symbolic link (same as -L)</p>

<p>-G FILE</p>

<p>FILE exists and is owned by the effective group ID</p>

<p>-k FILE</p>

<p>FILE exists and has its sticky bit set</p>

<p>-L FILE</p>

<p>FILE exists and is a symbolic link (same as -h)</p>

<p>-O FILE</p>

<p>FILE exists and is owned by the effective user ID</p>

<p>-p FILE</p>

<p>FILE exists and is a named pipe</p>

<p>-r FILE</p>

<p>FILE exists and is readable</p>

<p>-s FILE</p>

<p>FILE exists and has a size greater than zero</p>

<p>-S FILE</p>

<p>FILE exists and is a socket</p>

<p>-t [FD]</p>

<p>file descriptor FD (stdout by default) is opened on a terminal</p>

<p>-u FILE</p>

<p>FILE exists and its set-user-ID bit is set</p>

<p>-w FILE</p>

<p>FILE exists and is writable</p>

<p>-x FILE</p>

<p>FILE exists and is executable</p>

<p>eg.</p>

<p>#!/bin/bash</p>

<p>#if test</p>

<p>#this is a comment line</p>

<p>echo &ldquo;Enter your filename:&rdquo;</p>

<p>read myfile</p>

<p>if [ -e $myfile ]</p>

<p>then</p>

<p>if [ -s $myfile ];then</p>

<p>echo &ldquo;$myfile exist and size greater than zero&rdquo;</p>

<p>else</p>

<p>echo &ldquo;$myfile exist but size is zero&rdquo;</p>

<p>fi</p>

<p>else</p>

<p>echo &ldquo;file no exist&rdquo;</p>

<p>fi</p>

<p>[test@szbirdora 1]$ sh iftest.sh</p>

<p>Enter your filename:</p>

<p>11</p>

<p>11 exist but size is zero</p>

<p>2.case语句</p>

<p>case语句为多选择语句。</p>

<p>case 值 in</p>

<p>模式1）</p>

<p>命令1</p>

<p>;;</p>

<p>模式2)</p>

<p>命令2</p>

<p>;;</p>

<p>esac</p>

<p>eg.</p>

<p>#!/bin/bash</p>

<p>#case select</p>

<p>echo -n &ldquo;enter a number from 1 to 3:&rdquo;</p>

<p>read ans</p>

<p>case $ans in</p>

<p>1)</p>

<p>echo &ldquo;you select 1&rdquo;</p>

<p>;;</p>

<p>2)</p>

<p>echo &ldquo;you select 2&rdquo;</p>

<p>;;</p>

<p>3)</p>

<p>echo &ldquo;you select 3&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;<code>basename $0</code>:this is not between 1 and 3&rdquo;&gt;&amp;2</p>

<p>exit;</p>

<p>;;</p>

<p>esac</p>

<p>3.for 循环</p>

<p>for循环一般格式：</p>

<p>for 变量名 in 列表 (列表以空格作为分割)</p>

<p>do</p>

<p>命令1</p>

<p>命令2</p>

<p>done</p>

<p>eg：</p>

<p>#!/bin/bash</p>

<p>#forlist1</p>

<p>for loop in 1 2 3 4 5</p>

<p>do</p>

<p>echo $loop</p>

<p>done</p>

<p>4.until循环</p>

<p>until 条件</p>

<p>do</p>

<p>命令1</p>

<p>命令2</p>

<p>&hellip;</p>

<p>done</p>

<p>条件测试发生在循环末尾，所以循环至少可以执行一次。</p>

<p>5.</p>

<p>while循环</p>

<p>while 命令 （可以是一个命令也可以是多个，做条件测试）</p>

<p>do</p>

<p>命令1</p>

<p>命令2</p>

<p>&hellip;</p>

<p>done</p>

<p>注意：如果从文件中读入变量</p>

<p>6.break和continue控制</p>

<p>break跳出，continue跳过</p>

<p>第五章 文本过滤</p>

<p>1.正则表达式</p>

<p>一种用来描述文本模式的特殊语法，由普通字符以及特殊字符（元字符）组成</p>

<p>^ &mdash;-只匹配行首</p>

<p>$ &mdash;-只匹配行尾</p>

<ul>
<li>&mdash;-匹配0个或多个此单字符</li>
</ul>

<p>[] &mdash;-只匹配[]内字符，可以使用-表示序列范围[1-5]</p>

<p>\ &mdash;-屏蔽一个元字符的特殊含义</p>

<p>. &mdash;-匹配任意单字符</p>

<p>pattern\{n\} 只用来匹配前面pattern出现的次数，n为次数</p>

<p>pattern\{n，\}只用来匹配前面pattern出现的次数，至少为n</p>

<p>pattern\{n，m\}只用来匹配前面pattern出现的次数，次数在n-m之间</p>

<p>eg：</p>

<p>A\{3\}B AAAB</p>

<p>A\{3,\}B AAAB AAAAB &hellip;</p>

<p>A\{3,5\}B AAAB AAAAB AAAAAB</p>

<p>2.find命令 &mdash;-查找文件和目录</p>

<p>find pathname -options [-print -exec -ok]</p>

<p>pathname &ndash;查找的目录路径. .&ndash;表示当前目录，/表示根目录</p>

<p>-print 输出</p>

<p>-exec 对匹配的文件执行该参数所给出的shell命令，相应命令形式为&rsquo;command&rsquo;{} \;&rsquo; 注意{}和\;之间的空格</p>

<p>-ok 与-exec相同，不过执行命令前会有提示</p>

<p>options ：</p>

<p>-name</p>

<p>-perm</p>

<p>-user</p>

<p>-group</p>

<p>-mtime -n +n (atime,-ctime) 修改时间（访问时间，创建时间）</p>

<p>-size n[c]</p>

<p>-type 查找某一类型的文件</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ find ./ -mtime +5</p>

<p>./helloworld.sh</p>

<p>./nohup.out</p>

<p>查看./目录（当前）下修改时间超过5天的文件</p>

<p>3.grep介绍</p>

<p>grep -c 输出匹配行计数</p>

<p>grep -i 不区分大小写</p>

<p>grep -h 查询多文件时不显示文件名</p>

<p>grep -H 显示文件名</p>

<p>grep -l 查询多文件时只输出包含匹配字符的文件名</p>

<p>grep -n 显示匹配行及行号</p>

<p>grep -s 不显示不存在或不匹配文本的错误信息</p>

<p>grep -v 显示不包含匹配文本的所有行（过滤文本）</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ grep -n &rsquo;s.a&rsquo; myfile</p>

<p>2:/dev/sda1 20G 3.3G 16G 18% /</p>

<p>4:/dev/sda2 79G 18G 58G 23% /u01</p>

<p>5:/dev/sda4 28G 3.9G 22G 15% /u02</p>

<p>[test@szbirdora 1]$ grep -n &lsquo;2$&rsquo; myfile</p>

<p>5:/dev/sda4 28G 3.9G 22G 15% /u02</p>

<p>grep -options &lsquo;正则表达式&rsquo; filename</p>

<p>4.sed介绍</p>

<p>sed不与初始化文件打交道，它操作的只是一个拷贝，然后所有的改动如果没有重定向到一个文件将输出到屏幕</p>

<p>sed是一种重要的文本过滤工具，使用一行命令或使用管道与grep与awk相结合。</p>

<p>sed调用：</p>

<p>1.命令 sed [options] &lsquo;正则表达式sedcommand&rsquo; input-files</p>

<p>2.script :sed [options] -f sedscript input-files</p>

<p>sed在文本中查询文本的方式</p>

<p>-行号，可以是简单数字，或一个行号范围</p>

<p>-使用正则表达式</p>

<p>x &mdash;-行号</p>

<p>x,y &mdash;-行号范围从x到y</p>

<p>x,y! &mdash;不包含行号x到y</p>

<p>sed命令选项：</p>

<p>-n 不打印</p>

<p>-c 下一个命令是编辑命令</p>

<p>-f 如果正在调用sed脚本文件</p>

<p>基本sed命令</p>

<p>p 打印匹配行</p>

<p>= 显示文本行号</p>

<p>a\ 在定位行号后附加新文本信息</p>

<p>i\在定位行号前插入新文本信息</p>

<p>d 删除定位行</p>

<p>c\用新文本替换定位文本</p>

<p>s 使用替换模式替换相应模式</p>

<p>r 从另一个文件中读文本</p>

<p>w 写文本到一个文件</p>

<p>q 第一个模式匹配完成后退去</p>

<p>l 显示与八进制ascii代码等价的控制字符</p>

<p>{}在定位行执行命令组</p>

<p>n 从一个文件中读文本下一行，并附加在下一行</p>

<p>g 将模式2粘贴到/pattern n/</p>

<p>y 传送字符</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ sed -n &lsquo;2p&rsquo; myfile</p>

<p>c</p>

<p>打印myfile第2行</p>

<p>[test@szbirdora 1]$ sed -n &lsquo;2,4p&rsquo; myfile</p>

<p>c</p>

<p>f</p>

<p>b</p>

<p>打印第二行到第四行</p>

<p>[test@szbirdora 1]$ sed -n &lsquo;/a/p&rsquo; myfile</p>

<p>a</p>

<p>打印匹配a的行</p>

<p>[test@szbirdora 1]$ sed -n &lsquo;2,/2/p&rsquo; myfile</p>

<p>c</p>

<p>f</p>

<p>b</p>

<p>1</p>

<p>2</p>

<p>打印第二行到匹配&rsquo;2&rsquo;的行</p>

<p>s命令替换</p>

<p>[test@szbirdora 1]$ sed &rsquo;s/b/a/p&rsquo; myfile</p>

<p>a</p>

<p>a</p>

<p>a</p>

<p>c</p>

<p>d</p>

<p>e</p>

<p>替换b为a</p>

<p>多点编辑 -e</p>

<p>eg. （myfile包含a-e）</p>

<p>[test@szbirdora 1]$ sed -e &lsquo;2d&rsquo; -e &rsquo;s/c/d/&rsquo; myfile 11</p>

<p>a</p>

<p>d</p>

<p>d</p>

<p>e</p>

<p>sed命令r &mdash;从文件中读取选定的行，读入输入文件中，显示在匹配的行后面</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ cat 11</p>

<p>****************<strong><em>Alaska</em></strong>************</p>

<p>[test@szbirdora 1]$ sed &lsquo;/a/r 11&rsquo; myfile</p>

<p>a</p>

<p>****************<strong><em>Alaska</em></strong>************</p>

<p>b</p>

<p>c</p>

<p>d</p>

<p>e</p>

<p>写入命令：w 将输入文件中的匹配行写入到指定文件中</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ cat 11</p>

<p>b</p>

<p>[test@szbirdora 1]$ sed -n &lsquo;/a/w 11&rsquo; myfile</p>

<p>[test@szbirdora 1]$ cat 11</p>

<p>a</p>

<p>追加：a 将文本追加到匹配行的后面。sed要求在a后加\,不止一行的以\连接</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ sed
&lsquo;/b/a\*************<strong><em>hello</em></strong>**********\&mdash;&mdash;&mdash;&mdash;-china&mdash;&mdash;&mdash;&rsquo; myfile</p>

<p>a</p>

<p>b</p>

<p>*************<strong><em>hello</em></strong>**********&mdash;&mdash;&mdash;&mdash;-china&mdash;&mdash;&mdash;</p>

<p>c</p>

<p>d</p>

<p>e</p>

<p>插入命令：i 将文本插入到匹配行的前面。sed要求在a后加\,不止一行的以\连接</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ sed &lsquo;/b/i</p>

<blockquote>
<p>THE CHARACTER B IS BEST</p>

<p>*******************************&rsquo; myfile</p>
</blockquote>

<p>a</p>

<p>THE CHARACTER B IS BEST</p>

<hr />

<p>b</p>

<p>c</p>

<p>d</p>

<p>e</p>

<p>下一个：n 从一个文件中读文本下一行，并附加在下一行</p>

<p>退出命令 q 打印多少行后退出</p>

<p>eg.</p>

<p>[test@szbirdora 1]$ sed &lsquo;3q&rsquo; myfile</p>

<p>a alert</p>

<p>b best</p>

<p>c cook</p>

<p>sed script:</p>

<p>sed -f scriptfile myfile</p>

<p>5.awk介绍</p>

<p>awk可从文件或字符串值基于指定规则浏览和抽取信息</p>

<p>awk三种调用方式：</p>

<p>1.命令行方式</p>

<p>awk [-F field-sperator]&lsquo;pattern{active}&rsquo; input-files</p>

<p>awk [-F field-sperator]&lsquo;command&rsquo; input-files</p>

<p>awk脚本</p>

<p>所有awk命令插入一个文件，并使awk程序可执行，然后用awk命令解析器作为脚本的首行，以便通过键入脚本名称来调用。</p>

<p>awk命令插入一个单独文件</p>

<p>awk -f awk-script-file input-files</p>

<p>awk脚本由模式和动作组成</p>

<p>分隔符、域、记录</p>

<p>注意这里的$1,$2是域与位置变量$1,$2不一样。$0文件中的所有记录</p>

<p>eg：</p>

<p>awk &lsquo;{print $0}&rsquo; myfile</p>

<p>awk &lsquo;BEGIN {print &ldquo;IP DATE &mdash;-&rdquo;}{print $1&rdquo;\t&rdquo;$4}END{print &ldquo;end-of -report&rdquo;}</p>

<p>[test@szbirdora 1]$ df |awk &lsquo;$1!~&ldquo;dev&rdquo;&lsquo;|grep -v Filesystem</p>

<p>none 1992400 0 1992400 0% /dev/shm</p>

<p>[test@szbirdora 1]$ df |awk &lsquo;{if ($1==&ldquo;/dev/sda1&rdquo;) print $0}&rsquo;</p>

<p>/dev/sda1 20641788 3367972 16225176 18% /</p>

<p>[test@szbirdora shelltest]$ cat employee</p>

<p>Tom Jones 4424 5/12/66 543354</p>

<p>Mary Adams 5346 11/4/63 28765</p>

<p>Sally Chang 1654 7/22/54 650000</p>

<p>Billy Black 1683 9/23/44 336500</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;/[Aa]dams/&rsquo; employee</p>

<p>Mary Adams 5346 11/4/63 28765</p>

<p>[test@szbirdora shelltest]$ sed -n &lsquo;/[Aa]dams/p&rsquo; employee</p>

<p>Mary Adams 5346 11/4/63 28765</p>

<p>[test@szbirdora shelltest]$ grep &lsquo;[Aa]dams&rsquo; employee</p>

<p>Mary Adams 5346 11/4/63 28765</p>

<p>三种命令方式下，使用模式匹配查询</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;{print $1}&rsquo; employee</p>

<p>Tom</p>

<p>Mary</p>

<p>Sally</p>

<p>Billy</p>

<p>打印文件第一列</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;/Sally/{print $1&rdquo;\t&rdquo;$2}&rsquo; employee</p>

<p>Sally Chang</p>

<p>打印匹配Sally的行的第一列和第二列</p>

<p>[test@szbirdora shelltest]$ df |awk &lsquo;$4&gt;20884623&rsquo;</p>

<p>Filesystem 1K-blocks Used Available Use% Mounted on</p>

<p>/dev/sda2 82567220 17488436 60884616 23% /u01</p>

<p>/dev/sda4 28494620 4589172 22457992 17% /u02</p>

<p>打印df输出第四列大于××的行</p>

<p>格式输出：</p>

<p>打印函数—</p>

<p>[test@szbirdora shelltest]$ date</p>

<p>Mon Mar 10 15:15:47 CST 2008</p>

<p>[test@szbirdora shelltest]$ date |awk &lsquo;{print &ldquo;Month:&rdquo; $2&rdquo;\nYear:&rdquo; $6}&rsquo;</p>

<p>Month:Mar</p>

<p>Year:2008</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;/Sally/{print &ldquo;\t\tHave a nice
day,&ldquo;$1&rdquo;\t&rdquo;$2}&rsquo; employee</p>

<p>Have a nice day,Sally Chang</p>

<p>printf函数</p>

<p>[test@szbirdora shelltest]$ echo &ldquo;LINUX&rdquo;|awk &lsquo;{printf &ldquo;|%-10s|\n&rdquo;,$1}&rsquo;</p>

<p>|LINUX |</p>

<p>[test@szbirdora shelltest]$ echo &ldquo;LINUX&rdquo;|awk &lsquo;{printf &ldquo;|%10s|\n&rdquo;,$1}&rsquo;</p>

<p>| LINUX|</p>

<p>～匹配符</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;$1~/Tom/{print $1,$2}&rsquo; employee</p>

<p>Tom Jones</p>

<p>awk 给表达式赋值</p>

<p>关系运算符：</p>

<blockquote>
<p>大于</p>
</blockquote>

<p>== 等于</p>

<p>!= 不等于</p>

<blockquote>
<p>= 大于等于</p>
</blockquote>

<p>&lt;= 小于等于</p>

<p>~ 匹配</p>

<p>!~ 不匹配</p>

<p>eg.</p>

<p>[test@szbirdora shelltest]$ cat employee</p>

<p>Tom Jones 4424 5/12/66 543354</p>

<p>Mary Adams 5346 11/4/63 28765</p>

<p>Sally Chang 1654 7/22/54 650000</p>

<p>Billy Black 1683 9/23/44 336500</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;$2~/Adams/&rsquo; employee</p>

<p>Mary Adams 5346 11/4/63 28765</p>

<p>条件表达式：</p>

<p>condition expression1?expression2:expression3</p>

<p>eg.</p>

<p>awk &lsquo;{max=($1&gt;$2) ? $1:$2;print max}&rsquo; filename</p>

<p>运算符</p>

<p>+，-，*，/,%,^,&amp;&amp;,||,!</p>

<p>[test@szbirdora shelltest]$ cat /etc/passwd |awk -F: &lsquo;</p>

<p>NF!=7{</p>

<p>printf(&ldquo;line %d does not have 7 fields:%s\n&rdquo;,NR,$0)}</p>

<p>$1!~/[A-Za-z0-9]/{printf(&ldquo;line %d,nonalphanumberic user id:%s\n&rdquo;,NR,$0)}</p>

<p>$2==&rdquo;*&ldquo;{printf(&ldquo;line %d,no password:%s\n&rdquo;,NR,$0)}&rsquo;</p>

<p>awk编程</p>

<p>递增操作符 x++，++x</p>

<p>递减操作符 x&ndash;，&ndash;x</p>

<p>BEGIN模块</p>

<p>BEGIN模块后面紧跟着动作块，在读入文件前执行。通常被用来改变内建变量的值，如：FS\RS\OFS,初始化变量的值和打印输出标题。</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{print &ldquo;HELLO WORLD&rdquo;}&rsquo;</p>

<p>HELLO WORLD</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{print &ldquo;&mdash;&mdash;&mdash;
LIST&mdash;&mdash;&mdash;&ldquo;}{print}END{print &ldquo;&mdash;&mdash;END&mdash;&mdash;&ndash;&rdquo;}&rsquo; donors</p>

<p>-&mdash;&mdash;&ndash;LIST&mdash;&mdash;&mdash;</p>

<p>Mike Harrington:(510) 548-1278:250:100:175</p>

<p>Christian Dobbins:(408) 538-2358:155:90:201</p>

<p>Susan Dalsass:(206) 654-6279:250:60:50</p>

<p>Archie McNichol:(206) 548-1348:250:100:175</p>

<p>Jody Savage:(206) 548-1278:15:188:150</p>

<p>Guy Quigley:(916) 343-6410:250:100:175</p>

<p>Dan Savage:(406) 298-7744:450:300:275</p>

<p>Nancy McNeil:(206) 548-1278:250:80:75</p>

<p>John Goldenrod:(916) 348-4278:250:100:175</p>

<p>Chet Main:(510) 548-5258:50:95:135</p>

<p>Tom Savage:(408) 926-3456:250:168:200</p>

<p>Elizabeth Stachelin:(916) 440-1763:175:75:300</p>

<p>-&mdash;&ndash;END&mdash;&mdash;&ndash;</p>

<p>重定向和管道</p>

<p>输出重定向</p>

<p>awk输出重定向到一个文件需要使用输出重定向符，输出文件名需要用双引号括起来。</p>

<p>[test@szbirdora shelltest]$ awk -F: &lsquo;{print $1,$2&gt;&ldquo;note&rdquo;}&rsquo; donors</p>

<p>[test@szbirdora shelltest]$ cat note</p>

<p>Mike Harrington (510) 548-1278</p>

<p>Christian Dobbins (408) 538-2358</p>

<p>Susan Dalsass (206) 654-6279</p>

<p>Archie McNichol (206) 548-1348</p>

<p>Jody Savage (206) 548-1278</p>

<p>Guy Quigley (916) 343-6410</p>

<p>Dan Savage (406) 298-7744</p>

<p>Nancy McNeil (206) 548-1278</p>

<p>John Goldenrod (916) 348-4278</p>

<p>Chet Main (510) 548-5258</p>

<p>Tom Savage (408) 926-3456</p>

<p>Elizabeth Stachelin (916) 440-1763</p>

<p>输入重定向</p>

<p>getline函数</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{&ldquo;date +%Y&rdquo;|getline d;print d}&rsquo;</p>

<p>2008</p>

<p>[test@szbirdora shelltest]$ awk -F&rdquo;[ :]&rdquo; &lsquo;BEGIN{printf &ldquo;What is your name?&rdquo;;</p>

<p>getline name</p>

<p>$1~ name{print &ldquo;Found\t&rdquo; name &ldquo;\ton line&rdquo;,NR&rdquo;.&ldquo;}</p>

<p>END{print &ldquo;see ya,&rdquo; name &ldquo;.&rdquo;}&rsquo; donors</p>

<p>What is your name?Jody</p>

<p>Found Jody on line 5.</p>

<p>see ya,Jody.</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{while(getline0)lc++;print lc}&rsquo;</p>

<p>36</p>

<p>从文件中输入，如果得到一个记录，getline函数就返回1，如果文件已经到了末尾，则返回0，如果文件名错误则返回-1.</p>

<p>管道：</p>

<p>awk命令打开一个管道后要打开下一个管道需要关闭前一个管道，管道符右边可以使用“”关闭管道。在同一时间只有一个管道存在</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;{print $1,$2|&ldquo;sort -r +1 -2 +0 -1&rdquo;}&rsquo; names</p>

<p>tony tram</p>

<p>john smith</p>

<p>dan savage</p>

<p>john oldenrod</p>

<p>barbara nguyen</p>

<p>elizabeth lone</p>

<p>susan goldberg</p>

<p>george goldberg</p>

<p>eliza goldberg</p>

<p>alice cheba</p>

<p>|后用&rdquo;&ldquo;关闭管道</p>

<p>system函数</p>

<p>system（&rdquo;LINUX command&rdquo;）</p>

<p>system(&ldquo;cat&rdquo; $1)</p>

<p>system(&ldquo;clear&rdquo;)</p>

<p>条件语句</p>

<p>1.if（）{}</p>

<p>2.if(){}</p>

<p>else{}</p>

<p>3.if(){}</p>

<p>else if(){}</p>

<p>else if(){}</p>

<p>else{}</p>

<p>[test@szbirdora shelltest]$ awk -F: &lsquo;{if ($3&gt;250){printf &ldquo;%-2s%13s\n&rdquo;,$1,&rdquo;
&mdash;&mdash;&mdash;&ndash;good partman&rdquo;}else{print $1}}&rsquo; donors</p>

<p>循环语句</p>

<p>[test@szbirdora shelltest]$ awk -F: &lsquo;{i=1;while(i&lt;=NF){print NF,$i;i++}}&rsquo;
donors</p>

<p>循环控制语句break、continue</p>

<p>程序控制语句</p>

<p>next从输入文件中读取下一行，然后从头开始执行awk脚本</p>

<p>{if($1~/Peter/){next}</p>

<p>else{print}}</p>

<p>exit 结束awk语句，但不会结束END模块的处理。</p>

<p>数组：</p>

<p>awk &lsquo;{name[x++]=$1;for(i=0;i</p>

<p>(P177)&mdash;2008.3.11</p>

<p>awk内建函数</p>

<p>sub（正则表达式，替换字符[，$n]） &mdash;域n匹配正则表达式的字符串将被替换。</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;{sub(/Tom/,&ldquo;Jack&rdquo;,$1);print}&rsquo; employee</p>

<p>Jack Jones 4424 5/12/66 543354</p>

<p>Mary Adams 5346 11/4/63 28765</p>

<p>Sally Chang 1654 7/22/54 650000</p>

<p>Billy Black 1683 9/23/44 336500</p>

<p>Jack He 3000 8/22/44 320000</p>

<p>index函数 index（字符串，子字符串） 子字符串在字符串中的位置</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{a=index(&ldquo;hello&rdquo;,&ldquo;llo&rdquo;);print a}&rsquo;</p>

<p>3</p>

<p>length函数 length（string） 字符串的长度</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{a=length(&ldquo;hello world&rdquo;);print a}&rsquo;</p>

<p>11</p>

<p>substr函数 substr（字符串，开始位置[，子字符串长度]）</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{a=substr(&ldquo;hello world&rdquo;,7);print a}&rsquo;</p>

<p>world</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{a=substr(&ldquo;hello world&rdquo;,7,3);print a}&rsquo;</p>

<p>wor</p>

<p>match(string,正则表达式) 找出字符串中第一个匹配正则表达式的位置,其内建变量RSTART为匹配开始位置，RLENGTH为匹配开始后字符数</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;{a=match($0,/Jon/);if (a!=0){print NR,a}}&rsquo;
employee</p>

<p>1 5</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;{a=match($0,/Jon/);if (a!=0){print
NR,a,RSTART,RLENGTH}}&rsquo; employee</p>

<p>1 5 5 3</p>

<p>toupper和tolower函数</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{a=toupper(&ldquo;hello&rdquo;);print a}&rsquo;</p>

<p>HELLO</p>

<p>split函数 split（string,array,fieldseperator）</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{&ldquo;date&rdquo;|getline d;split(d,date);print
date[2]}&rsquo;</p>

<p>Mar</p>

<p>时间函数</p>

<p>systime（） &mdash;-1970年1月1日到当前忽略闰年得出的秒数。</p>

<p>strftime(格式描述，时间戳)</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{d=strftime(&ldquo;%T&rdquo;,systime());print d}&rsquo;</p>

<p>13:08:09</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{d=strftime(&ldquo;%D&rdquo;,systime());print d}&rsquo;</p>

<p>03/12/08</p>

<p>[test@szbirdora shelltest]$ awk &lsquo;BEGIN{d=strftime(&ldquo;%Y&rdquo;,systime());print d}&rsquo;</p>

<p>2008</p>

<p>6.sort介绍</p>

<p>sort：</p>

<p>-c 测试文件是否已经排序</p>

<p>-m 合并两个排序文件</p>

<p>-u 删除所有复制行</p>

<p>-o 存储sort结果的输出文件名</p>

<p>-t 域分隔符；用非空格或tab键分割域</p>

<p>+n n为域号，使用此域号开始排序 （注意0是第一列）</p>

<p>-r 逆序排序</p>

<p>n 指定排序是域上的数字排序项</p>

<p>[test@szbirdora 1]$ df -lh|grep -v &lsquo;Filesystem&rsquo;|sort +1</p>

<p>none 2.0G 0 2.0G 0% /dev/shm</p>

<p>/dev/sda1 20G 3.3G 16G 18% /</p>

<p>/dev/sda4 28G 3.9G 22G 15% /u02</p>

<p>/dev/sda2 79G 17G 59G 23% /u01</p>

<p>uniq [option]files 从一个文本文件中去除或禁止重复行</p>

<p>-u 只显示不重复行</p>

<p>-d 只显示有重复数据行，每重复行只显示其中一行</p>

<p>-c 打印每一重复行出现次数</p>

<p>-f n为数字，前n个域被忽略</p>

<p>注意要先排序</p>

<p>7.split cut join 分割和合并文件命令</p>

<p>[test@szbirdora 1]$ split -l 2 myfile split （每两行分割为一个以split名称开头的文件）</p>

<p>[test@szbirdora 1]$ ls</p>

<p>case.sh df.out helloworld.sh iftest.sh myfile nohup.out nullfile.txt parm.sh
splitaa splitab splitac splitad splitae</p>

<p>[test@szbirdora 1]$ cat splitaa</p>

<p>Filesystem Size Used Avail Use% Mounted on</p>

<p>/dev/sda1 20G 3.3G 16G 18% /</p>

<p>第六章 shell函数</p>

<p>1.定义函数</p>

<p>funcation name()</p>

<p>{</p>

<p>command1</p>

<p>&hellip;.</p>

<p>}</p>

<p>或</p>

<p>函数名()</p>

<p>{</p>

<p>command1</p>

<p>&hellip;</p>

<p>}</p>

<p>eg.</p>

<p>#!/bin/bash</p>

<p>#hellofun</p>

<p>function hello()</p>

<p>{</p>

<p>echo &ldquo;hello,today is <code>date</code>&ldquo;</p>

<p>return 1</p>

<p>}</p>

<p>2.函数调用</p>

<p>#!/bin/bash</p>

<p>#hellofun</p>

<p>function hello()</p>

<p>{</p>

<p>echo &ldquo;hello,today is <code>date</code>&ldquo;</p>

<p>return 1</p>

<p>}</p>

<p>echo &ldquo;now going to the function hello&rdquo;</p>

<p>hello</p>

<p>echo &ldquo;back from the function&rdquo;</p>

<p>所以调用函数只需要在脚本中使用函数名就可以了。</p>

<p>3.参数传递</p>

<p>像函数传递参数就像在脚本中使用位置变量$1,$2&hellip;$9</p>

<p>4.函数文件</p>

<p>函数可以文件保存。在调用时使用&rdquo;. 函数文件名&rdquo;(.+空格+函数文件名)</p>

<p>如：</p>

<p>hellofun.sh</p>

<p>#!/bin/bash</p>

<p>#hellofun</p>

<p>function hello()</p>

<p>{</p>

<p>echo &ldquo;hello,today is <code>date</code>&ldquo;</p>

<p>return 1</p>

<p>}</p>

<p>func.sh</p>

<p>#!/bin/bash</p>

<p>#func</p>

<p>. hellofun.sh</p>

<p>echo &ldquo;now going to the function hello&rdquo;</p>

<p>echo &ldquo;Enter yourname:&rdquo;</p>

<p>read name</p>

<p>hello $name</p>

<p>echo &ldquo;back from the function&rdquo;</p>

<p>[test@szbirdora 1]$ sh func.sh</p>

<p>now going to the function hello</p>

<p>Enter yourname:</p>

<p>hh</p>

<p>hello,hh today is Thu Mar 6 15:59:38 CST 2008</p>

<p>back from the function</p>

<p>5.检查载入函数 set</p>

<p>删除载入函数 unset 函数名</p>

<p>6.函数返回状态值 return 0、return 1</p>

<p>7.脚本参数的传递</p>

<p>shift命令</p>

<p>shift n 每次将参数位置向左偏移n</p>

<p>#!/bin/bash</p>

<p>#opt2</p>

<p>usage()</p>

<p>{</p>

<p>echo &ldquo;usage:<code>basename $0</code> filename&rdquo;</p>

<p>}</p>

<p>totalline=0</p>

<p>if [ $# -lt 2 ];then</p>

<p>usage</p>

<p>fi</p>

<p>while [$# -ne 0]</p>

<p>do</p>

<p>line=<code>cat $1|wc -l</code></p>

<p>echo &ldquo;$1 : ${line}&rdquo;</p>

<p>totalline=$[$totalline+$line]</p>

<p>shift # $# -1</p>

<p>done</p>

<p>echo &ldquo;&mdash;&ndash;&rdquo;</p>

<p>echo &ldquo;total:${totalline}&rdquo;</p>

<p>[test@szbirdora 1]$ sh opt2.sh myfile df.out</p>

<p>myfile : 10</p>

<p>df.out : 4</p>

<p>-&mdash;-</p>

<p>total:14</p>

<p>8.getopts命令</p>

<p>获得多个命令行参数</p>

<p>getopts ahfvc OPTION &ndash;从ahfvc一个一个读出赋值给OPTION.如果参数带有：则把变量赋值给：前的参数&ndash;:只能放在末尾。</p>

<p>该命令可以做获得命令的参数</p>

<p>#!/bin/bash</p>

<p>#optgets</p>

<p>ALL=false</p>

<p>HELP=false</p>

<p>FILE=false</p>

<p>while getopts ahf OPTION</p>

<p>do</p>

<p>case $OPTION in</p>

<p>a)</p>

<p>ALL=true</p>

<p>echo &ldquo;ALL is $ALL&rdquo;</p>

<p>;;</p>

<p>h)</p>

<p>HELP=true</p>

<p>echo &ldquo;HELP is $HELP&rdquo;</p>

<p>;;</p>

<p>f)</p>

<p>FILE=true</p>

<p>echo &ldquo;FILE is $FILE&rdquo;</p>

<p>;;</p>

<p>\?)</p>

<p>echo &ldquo;<code>basename $0</code> -[a h f] file&rdquo;</p>

<p>;;</p>

<p>esac</p>

<p>done</p>

<p>[test@szbirdora 1]$ sh optgets.sh -a -h -m</p>

<p>ALL is true</p>

<p>HELP is true</p>

<p>optgets.sh: illegal option &ndash; m</p>

<p>optgets.sh -[a h f] file</p>

<p>getopts表达式：</p>

<p>while getopts p1p2p3&hellip; var do</p>

<p>case var in</p>

<p>..)</p>

<p>&hellip;.</p>

<p>esac</p>

<p>done</p>

<p>如果在参数后面还需要跟自己的参数，则需要在参数后加：</p>

<p>如果在参数前面加：表示不想将错误输出</p>

<p>getopts函数自带两个跟踪参数的变量：optind，optarg</p>

<p>optind初始值为1，在optgets处理完一次命令行参数后加1</p>

<p>optarg包含合法参数的值，即带：的参数后跟的参数值</p>

<p>有了前面的学习，下面只记载一些在学习的过程中又忘了了一些知识点。所以记录是零散的。</p>

<p>1.</p>

<p>shopt bash2.0以上新的命令，功能和set类似。</p>

<p>给变量赋值时等号两边不可留空格。</p>

<p>环境变量一般使用大写。</p>

<p>2.</p>

<p>$# 传递到脚本的参数个数</p>

<p>$* 以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</p>

<p>$$ 脚本运行的当前进程ID号</p>

<p>$! 后台运行的最后一个进程的进程ID号</p>

<p>$@ 传递到脚本的参数列表，并在引号中返回每个参数</p>

<p>$- 显示shell使用的当前选项，与set命令功能相同</p>

<p>$? 显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>

<p>3.</p>

<p>echo 命令中使用&rdquo; &ldquo;无法直接识别转义字符，必须使用选项 -e，但可以使用$和`引用变量和命令替换。</p>

<p>$[] 告诉shell对方括号中表达式求值 $[a+b]，如$[1+8]</p>

<p>4.</p>

<p>tee</p>

<p>把输出的一个副本输送到标准输出，另一个副本拷贝到相应的文件中</p>

<p>tee -a file &mdash;&ndash;a表示在文件末尾追加，不要-a则覆盖</p>

<p>该命令一般与管道合用</p>

<p>5.</p>

<p>command&gt;filename&gt;&amp;1 &mdash;把标准输出和标准错误重定向</p>

<p>command&lt;</p>

<p>eg：</p>

<p>sqlplus / as sysdba &lt;</p>

<p>show parameters</p>

<p>exit</p>

<p>EOF</p>

<p>6.命令替换有两种方式，老的korn风格的<code>linux command</code>和新的bash风格$(linux command)</p>

<p>7.定义数组</p>

<p>declare -a arry=(a1 a2 a3 &hellip;)</p>

<p>echo ${a[n]}</p>

<p>8.read使用</p>

<p>read -a arryname &mdash;读入为数组</p>

<p>read -p prompt &mdash;-输出提示，并把提示后的输入存到REPLY内建变量中</p>

<p>[test@szbirdora 1]$ read -p &ldquo;Enter your name:&rdquo;</p>

<p>Enter your name:jack</p>

<p>[test@szbirdora 1]$ echo $REPLY</p>

<p>jack</p>

<p>[test@szbirdora 1]$ read -a name</p>

<p>jack tom susan</p>

<p>[test@szbirdora 1]$ echo ${name[2]}</p>

<p>susan</p>

<p>[test@szbirdora 1]$ echo ${name[0]}</p>

<p>jack</p>

<p>9.多进制整型变量表示</p>

<p>declare -i number</p>

<p>number=base#number_in_the_base</p>

<p>如：</p>

<p>declare -i number</p>

<p>number=2#101</p>

<p>number=16#A9</p>

<p>10.条件语句if then
fi中if后的表达式可以是条件表达式（布尔表达式）或一组命令，如果是布尔表达式则表达式为真执行then后的语句，如果是命令组，则命令组状态（$?）为0执行then后面的语句。但如果是C
shell则if后只能跟布尔表达式。</p>

<p>11.here文档和case建立菜单：</p>

<p>eg.</p>

<p>echo &ldquo;Select a terminal type:&rdquo;</p>

<p>cat &lt;</p>

<p>1) linux</p>

<p>2)xterm</p>

<p>3)sun</p>

<p>EOF</p>

<p>read choice</p>

<p>case $choice in</p>

<p>1)TERM=linux</p>

<p>export TERM</p>

<p>;;</p>

<p>2)TERM=xterm</p>

<p>export TERM</p>

<p>;;</p>

<p>3)TERM=sun</p>

<p>export TERM</p>

<p>;;</p>

<p>*) echo &ldquo;please select correct chioce,ths!&rdquo;</p>

<p>;;</p>

<p>esac</p>

<p>echo &ldquo;TERM is $TERM&rdquo;</p>

<p>12.循环比较：</p>

<p>for variable in wordlist;do &mdash;从文件或列表中给定的值循环</p>

<p>while command；do &mdash;-当command的返回值为0时做循环</p>

<p>until command；do &mdash;-当command的返回值不为0时作循环</p>

<p>select循环菜单</p>

<p>用 select建立菜单，需要用PS3来提示用户输入，输入保存在REPLY内建变量中,REPLY的值与内建菜单关联。在构建菜单过程中可以使用
COLUMNS和LINES两个变量，COLUMNS决定菜单的列宽度，LINES决定可显示的行数。select和case命令联用可以有效的构造循环 菜单。</p>

<p>eg</p>

<p>#!/bin/bash</p>

<p>#Author: hijack</p>

<p>#Usage:Menu</p>

<p>t=0</p>

<p>j=0</p>

<p>d=0</p>

<p>PS3=&ldquo;Please choose one of the three boys or quit:&rdquo;</p>

<p>select choice in Tom Jack David Quit</p>

<p>do</p>

<p>case $choice in</p>

<p>Tom)</p>

<p>t=$t+1</p>

<p>if (($t==5));then</p>

<p>echo &ldquo;Tom win&rdquo;</p>

<p>break</p>

<p>fi</p>

<p>;;</p>

<p>Jack)</p>

<p>j=$j+1</p>

<p>if (($j==5));then</p>

<p>echo &ldquo;Jack win&rdquo;</p>

<p>break</p>

<p>fi</p>

<p>;;</p>

<p>David)</p>

<p>d=$d+1</p>

<p>if (($d==5));then</p>

<p>echo &ldquo;David win&rdquo;</p>

<p>break</p>

<p>fi</p>

<p>;;</p>

<p>Quit) exit 0;;</p>

<p>*) echo &ldquo;$REPLY is invalide choice&rdquo; 1&gt;&amp;2</p>

<p>echo &ldquo;Try again!&rdquo;</p>

<p>;;</p>

<p>esac</p>

<p>done</p>

<p>[test@szbirdora 1]$ sh menu</p>

<p>1) Tom</p>

<p>2) Jack</p>

<p>3) David</p>

<p>4) Quit</p>

<p>Please choose one of the three boys or quit:1</p>

<p>Please choose one of the three boys or quit:2</p>

<p>Please choose one of the three boys or quit:1</p>

<p>Please choose one of the three boys or quit:1</p>

<p>Please choose one of the three boys or quit:1</p>

<p>Please choose one of the three boys or quit:1</p>

<p>Tom win</p>

<p>12.set 设置位置变量,shift移动位置变量。</p>

<p>set tom jack david &mdash;&ndash;$1 tom $2 jack $3 david</p>

<p>echo $*</p>

<p>tom jack david</p>

<p>shift 2 &mdash;&ndash;移动两个位置，$1,$2删除</p>

<p>echo $*</p>

<p>david</p>

<p>eg：</p>

<p>#!/bin/bash</p>

<p>#Name:shift</p>

<p>#Author : Hijack</p>

<p>#Usage:shift test</p>

<p>#Date:080320</p>

<p>while (($#&gt;0))</p>

<p>do</p>

<p>echo &ldquo;$*&rdquo;</p>

<p>shift</p>

<p>done</p>

<p>[test@szbirdora 1]$ ./shift 1 2 3 4 5 6 7</p>

<p>1 2 3 4 5 6 7</p>

<p>2 3 4 5 6 7</p>

<p>3 4 5 6 7</p>

<p>4 5 6 7</p>

<p>5 6 7</p>

<p>6 7</p>

<p>7</p>

<p>13。 break n &mdash;n 代表退出第几层循环，默认退出一层。continue n 类似</p>

<p>#!/bin/bash</p>

<p>#Name : Mulloop</p>

<p>#Author : Hijack</p>

<p>#Usage : break test</p>

<p>declare -i x=0</p>

<p>declare -i y=0</p>

<p>while true</p>

<p>do</p>

<p>while (( x&lt;20 ))</p>

<p>do</p>

<p>x=$x+1</p>

<p>echo $x</p>

<p>if (( $x==10 ));then</p>

<p>echo &ldquo;if&rdquo;</p>

<p>break</p>

<p>fi</p>

<p>done</p>

<p>echo &ldquo;loop end&rdquo;</p>

<p>y=$y+1</p>

<p>if (($y&gt;5));then</p>

<p>break</p>

<p>fi</p>

<p>done</p>

<p>[test@szbirdora 1]$ sh mulloop</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>4</p>

<p>5</p>

<p>6</p>

<p>7</p>

<p>8</p>

<p>9</p>

<p>10</p>

<p>if</p>

<p>loop end</p>

<p>11</p>

<p>12</p>

<p>13</p>

<p>14</p>

<p>15</p>

<p>16</p>

<p>17</p>

<p>18</p>

<p>19</p>

<p>20</p>

<p>loop end</p>

<p>loop end</p>

<p>loop end</p>

<p>loop end</p>

<p>loop end</p>

<p>#!/bin/bash</p>

<p>#Name : Mulloop</p>

<p>#Author : Hijack</p>

<p>#Usage : break test</p>

<p>declare -i x=0</p>

<p>declare -i y=0</p>

<p>while true</p>

<p>do</p>

<p>while (( x&lt;20 ))</p>

<p>do</p>

<p>x=$x+1</p>

<p>echo $x</p>

<p>if (( $x==10 ));then</p>

<p>echo &ldquo;if&rdquo;</p>

<p>break 2</p>

<p>fi</p>

<p>done</p>

<p>echo &ldquo;loop end&rdquo;</p>

<p>y=$y+1</p>

<p>if (($y&gt;5));then</p>

<p>break</p>

<p>fi</p>

<p>done</p>

<p>[test@szbirdora 1]$ sh mulloop</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>4</p>

<p>5</p>

<p>6</p>

<p>7</p>

<p>8</p>

<p>9</p>

<p>10</p>

<p>if</p>

<p>14.循环的IO重定向</p>

<p>使用&rdquo;&gt;&ldquo;,&rdquo;|&ldquo;等重定向符实现循环的IO重定向</p>

<p>如 while ;do</p>

<p>done &gt;temp$$</p>

<p>for in</p>

<p>do</p>

<p>done |sort</p>

<p>eg</p>

<p>给文件的每行加一个行号，写入文件中</p>

<p>#!/bin/bash</p>

<p>#Name : loopred</p>

<p>#Author : Hijack</p>

<p>#Usage : add linenum to the file</p>

<p>#Program : read line to loop from file,add linenum,output to tempfile,mv
tempfile to file</p>

<p>declare -i count=0</p>

<p>declare -i total=0</p>

<p>total=<code>sed -n &quot;$=&quot; $1</code></p>

<p>cat $1 | while read line</p>

<p>do</p>

<p>(($count==0))&amp;&amp; echo -e &ldquo;Processing file $1&hellip;..\n&rdquo;&gt; /dev/tty</p>

<p>count=$count+1</p>

<p>echo -e &ldquo;$count\t$line&rdquo;</p>

<p>(($count==$total))&amp;&amp; echo &ldquo;Process finish,total line number is $count&rdquo; &gt;
/dev/tty</p>

<p>done &gt;temp$$</p>

<p>mv temp$$ $1</p>

<p>[test@szbirdora 1]$ sh loopred testmv</p>

<p>Processing file testmv&hellip;..</p>

<p>Process finish,total line number is 19</p>

<p>[test@szbirdora 1]$ vi testmv</p>

<p>1 /u01/test</p>

<p>2 /u01/test/1</p>

<p>3 /u01/test/1/11</p>

<p>4 /u01/test/1/forlist.sh</p>

<p>5 /u01/test/1/optgets.sh</p>

<p>6 /u01/test/1/whiletest.sh</p>

<p>7 /u01/test/1/func.sh</p>

<p>8 /u01/test/1/helloworld.sh</p>

<p>9 /u01/test/1/df.out</p>

<p>10 /u01/test/1/nullfile.txt</p>

<p>11 /u01/test/1/iftest.sh</p>

<p>12 /u01/test/1/myfile</p>

<p>13 /u01/test/1/opt2.sh</p>

<p>14 /u01/test/1/0</p>

<p>15 /u01/test/1/case.sh</p>

<p>16 /u01/test/1/nohup.out</p>

<p>17 /u01/test/1/hellfun.sh</p>

<p>18 /u01/test/1/parm.sh</p>

<p>19 /u01/test/1/test</p>

<p>15。在done后面加&amp;使循环在后台运行，程序继续执行。</p>

<p>16.在函数内可以使用local定义本地变量，local variable。</p>

<p>17.陷阱信号 trap &ndash;当一个信号发出传递给进程时，进程进行相关操作，信号包括中断等</p>

<p>trap ‘command；command’ signal-num #trap设置时执行命令</p>

<p>trap “command；command” signal-num #信号到达时执行命令</p>

<p>eg：</p>

<p>[root@linux2 ~]# trap &ldquo;echo -e &lsquo;hello world\n&rsquo;;ls -lh&rdquo; 2</p>

<p>[root@linux2 ~]# hello world &mdash;ctrl+c</p>

<p>total 100K</p>

<p>-rw-r&ndash;r&ndash; 1 root root 1.4K Nov 14 16:53 anaconda-ks.cfg</p>

<p>drwxr-xr-x 2 root root 4.0K Nov 23 13:11 Desktop</p>

<p>-rw-r&ndash;r&ndash; 1 root root 53K Nov 14 16:53 install.log</p>

<p>-rw-r&ndash;r&ndash; 1 root root 4.9K Nov 14 16:53 install.log.syslog</p>

<p>drwxr-xr-x 2 root root 4.0K Nov 22 13:03 vmware</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>