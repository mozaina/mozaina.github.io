<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linuxshell脚本速记 | 开发者问答集锦</title>
    <meta property="og:title" content="linuxshell脚本速记 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linuxshell脚本速记">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linuxshell%E8%84%9A%E6%9C%AC%E9%80%9F%E8%AE%B0/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linuxshell脚本速记</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="shell-script">shell script</h3>

<pre><code>#!/bin/bash
# do something
</code></pre>

<h3 id="run-shell-script">run shell script</h3>

<pre><code>sh script.sh

or

chmod a+x script.sh
./script.sh
# 会读取首行的解释器, 执行
</code></pre>

<p>cmd</p>

<pre><code>cmd1; cmd2

or

cmd1
cmd2
</code></pre>

<h3 id="echo">echo</h3>

<p>echo 的功能正如其名，就是基于标准输出打印一段文本</p>

<pre><code>echo &quot;welcome to bash&quot;
echo welcome to bash
</code></pre>

<p>使用不带引号的echo时，无法显示分号</p>

<p>使用单引号echo时，bash不会对单引号中变量求值 &lsquo;$var&rsquo;</p>

<p>echo 中转义换行符</p>

<p>默认情况，echo将换行标志追加到文本尾部，可以忽略结尾换行符</p>

<pre><code>echo -n 'test\n'
</code></pre>

<p>对字符串进行转义</p>

<pre><code>echo -e '1\t2\t3'
</code></pre>

<p>打印彩色输出</p>

<pre><code>文字颜色码
    重置0
    黑色30
    红色31
    绿色32
    黄色33
    蓝色34
    洋红35
    青色36
    白色37

echo -e &quot;\e[1;31m This is red test \e[0m&quot;

背景颜色码
    重置0
    黑色40
    红色41
    绿色42
    黄色43
    蓝色44
    洋红45
    青色46
    白色47

echo -e &quot;\e[1;42m Green Background \e[0m&quot;
</code></pre>

<h3 id="printf">printf</h3>

<p>可以格式化字符串, 使用参数同c中printf一样</p>

<pre><code>printf &quot;hello world&quot;
</code></pre>

<p>默认不会加换行符, 需要手动添加</p>

<pre><code>printf &quot;%-5s %-10s %-4.2f\n&quot; 3 Jeff 77.564

3    Jeff      77.56
</code></pre>

<h3 id="环境变量和变量">环境变量和变量</h3>

<p>bash中，每个变量的值都是字符串，无论你给变量赋值时是否使用引号，值都会以字符串的形式存储</p>

<p>环境变量</p>

<p>查看所有与此终端进程相关的环境变量</p>

<pre><code>env
</code></pre>

<p>查看某个进程的环境变量</p>

<pre><code>cat /proc/$PID/environ
</code></pre>

<p>变量赋值</p>

<pre><code>var=value
var='the value'
var=&quot;the $PARAM&quot;

echo $var
echo ${var}

var = value非变量赋值是相等操作
</code></pre>

<p>环境变量</p>

<pre><code>未在当前进程中定义，而是从父进程中继承而来的变量
export 设置环境变量,之后,从当前shell 执行的任何程序都会继承这个变量

export PYTHONPATH=$PYTHONPATH:/home/ken/workspace
</code></pre>

<p>常用的环境变量</p>

<pre><code>PATH 查找可执行文件路径, 通常定义在/etc/environment or /ect/profile or ~/.bashrc
修改:        export PATH=$PATH:/new/path/
HOME
PWD
USER
UID
SHELL
</code></pre>

<p>获取字符串长度</p>

<pre><code>length=${#var}
</code></pre>

<p>识别当前shell版本</p>

<pre><code>echo $SHELL
    /bin/bash
echo $0
    bash
</code></pre>

<p>检查是否为超级用户 or 普通用户</p>

<pre><code>root的UID=0

if [ $UID -ne 0 ]
then
    echo &quot;not root user&quot;
else
    echo &quot;root&quot;
fi
</code></pre>

<p>修改bash的提示字符</p>

<pre><code>设置PS1变量
\u用户名
\h主机名
\w当前工作目录
</code></pre>

<h3 id="pgrep">pgrep</h3>

<p>获取某个进程名对应进程id</p>

<pre><code>pgrep gedit
</code></pre>

<h3 id="shell数学运算">shell数学运算</h3>

<p>整数运算</p>

<p>let</p>

<pre><code>no1=4
no2=5
let result=no1+no2

let no1++
let no2--
let no1+=7
let no2-=7
</code></pre>

<p>expr(少用)</p>

<pre><code>result=`expr 3 + 4`
result=$(expr $no1 + 5)
</code></pre>

<p>其他方法</p>

<pre><code>result=$[ no1 + no2 ]
result=$[ $no + 5 ]

result=$(( no1 + 5 ))
</code></pre>

<p>浮点数</p>

<pre><code>echo &quot;4 * 0.56&quot; | bc
设定精度
echo &quot;scale=2;3/8&quot; | bc
进制转换
echo &quot;obase=2;100&quot; | bc
平方
echo &quot;10^10&quot; | bc
平方根
echo &quot;sqrt(100)&quot; | bc
</code></pre>

<h3 id="命令状态">命令状态</h3>

<p>当命令成功完成, 返回0</p>

<p>发生错误并退回, 返回非0</p>

<p>可以从$?中获取 cmd; echo $?</p>

<h3 id="文件描述符和重定向">文件描述符和重定向</h3>

<p>文件描述符: 与文件输入/输出相关联的整数, 用来跟踪已打开的文件</p>

<pre><code>0 stdin  标砖输入
1 stdout 标准输出
2 stderr 标准错误
</code></pre>

<p>重定向到文件</p>

<pre><code>清空文件写入新内容
echo &quot;test&quot; &gt; temp.txt
追加
echo &quot;test&quot; &gt;&gt; temp.txt

&gt;等价于1&gt;
&gt;&gt;等价于 1&gt;&gt;
</code></pre>

<p>输出分离或合并</p>

<pre><code>分离
cmd 2&gt;stderr.txt  1&gt;stdout.txt

合并
cmd &gt; output.txt 2&gt;&amp;1
or
cmd &amp;&gt; output.txt
</code></pre>

<p>扔到垃圾桶</p>

<pre><code>/dev/null 特殊设备文件, 接收到的任何数据都会被丢弃(位桶/黑洞)

只有标准错误
cmd 2 &gt; /dev/null

标准输出和标准错误
cmd &gt;/dev/null 2&gt;&amp;1
</code></pre>

<p>同时输出到终端和文件</p>

<pre><code>cmd | tee file1

tee默认覆盖，可以-a选项追加
cmd | tee -a file1
</code></pre>

<p>将stdin作为命令参数</p>

<pre><code>cmd1 | cmd2 | cmd3 -
</code></pre>

<p>将文件重定向到命令</p>

<pre><code>cmd &lt; file
</code></pre>

<p>自定义文件描述符</p>

<pre><code>使用文件描述符3打开并读取文件
exec 3.txt
cat 3

使用文件描述符4进行写入
exec 4&gt;output.txt
echo newline &gt;&amp;4
</code></pre>

<h3 id="cat">cat</h3>

<p>cat, concatenate(拼接)</p>

<p>“cat”代表了连结（Concatenation），连接两个或者更多文本文件或者以标准输出形式打印文件的内容</p>

<p>一般格式</p>

<pre><code>cat file1 file2 file3

从管道中读取
OUTPUT_FROM_SOME_CMDS | cat

echo &quot;test&quot; | cat - file1
</code></pre>

<p>压缩空白行, 多个连续空行变成单个</p>

<pre><code>cat -s  file
</code></pre>

<p>配合tr移除空白行</p>

<pre><code>cat file | tr -s '\n' #连续多个\n -&gt; \n
</code></pre>

<p>加行号</p>

<pre><code>cat -n file
</code></pre>

<p>显示制表符等</p>

<pre><code>cat -T file

cat f &gt; t
注意：“&gt;&gt;”和“&gt;”调用了追加符号。它们用来追加到文件里，而不是显示在标准输出上。
“&gt;”符号会删除已存在的文件，然后创建一个新的文件。
所以因为安全的原因，建议使用“&gt;&gt;”，它会写入到文件中，而不是覆盖或者删除。
</code></pre>

<p>输入多行文字(CTRL + d 退出)</p>

<pre><code>cat &gt; test.txt
</code></pre>

<h3 id="数组和关联数组">数组和关联数组</h3>

<p>普通数组，整数作为数组索引, 借助索引将多个独立的数据存储为一个集合(list)</p>

<p>关联数组，可以使用字符串作为索引(map)</p>

<p>数组</p>

<p>定义</p>

<pre><code>array_var=(1 2 3 4 5)

or
array_var[0]=&quot;test1&quot;
array_var[3]=&quot;test3&quot;
</code></pre>

<p>读取</p>

<pre><code>echo ${array_var[0]}
</code></pre>

<p>以清单形式打印</p>

<pre><code>echo ${array_var[*]}
echo ${array_var[@]}
</code></pre>

<p>长度</p>

<pre><code>echo ${#array_var[*]}
</code></pre>

<p>获取索引列表</p>

<pre><code>echo ${!array_var[*]}
</code></pre>

<p>关联数组</p>

<pre><code>declare -A ass_array

内嵌索引-值
ass_array=([index1]=value1 [index2]=value2)

独立
ass_array[index3]=value3

echo ${ass_array[index1]}
</code></pre>

<h3 id="alias">alias</h3>

<p>alias是一个系统自建的shell命令，允许你为名字比较长的或者经常使用的命令指定别名。</p>

<pre><code>alias new_command='command seq'
unalias new_command

使用原生命令
\new_command
</code></pre>

<h3 id="date">date</h3>

<p>“date”命令使用标准的输出打印当前的日期和时间，也可以深入设置</p>

<p>读取日期</p>

<pre><code>date
</code></pre>

<p>时间戳</p>

<pre><code>date +%s
</code></pre>

<p>日期转换为时间戳</p>

<pre><code>date --date &quot;Thu Nov 18 08:07:21 IST 2010&quot; +%s
</code></pre>

<p>日期格式化</p>

<pre><code>星期  %a  Sat
      %A  Saturday
月    %b  Nov
      %B  November
日    %d  31
固定日期格式mm/dd/yy     %D
年    %y  10
      %Y  2010
小时  %I/%H    08
分钟  %M  33
秒    %S  10
纳秒  %N  696308515
Unix纪元时  %s
</code></pre>

<p>格式化</p>

<pre><code>date &quot;+%Y %B %d&quot;

date +%Y-%m-%d
输出： 2011-07-28
date +&quot;%Y-%m-%d %H:%M:%S&quot;
</code></pre>

<p>设置日期和时间</p>

<pre><code>date -s &quot;格式化日期字符串&quot;

date -s &quot;21 June 2009 11:01:22&quot;
</code></pre>

<p>延时</p>

<pre><code>sleep number_of_seconds
</code></pre>

<p>两天后及两天前</p>

<pre><code>date -d '2 days' +%Y%m%d
date -d '2 days ago' +%Y%m%d
</code></pre>

<p>某一天的几天前</p>

<pre><code>TODAY=`date +%Y%m%d`
DAY_1_AGO=`date -d &quot;$TODAY 1 days ago&quot; +%Y%m%d`
</code></pre>

<p>时间戳日期转换</p>

<pre><code>date -d @1193144433
date -d @1193144433 &quot;+%Y-%m-%d %T&quot;

反向:
date -d &quot;2007-10-23 15:00:23&quot; &quot;+%s&quot;
</code></pre>

<p>赋值给变量</p>

<pre><code>DATE=$(date +%Y%m%d)
DATE=`date +%Y%m%d`
</code></pre>

<h3 id="调试脚本">调试脚本</h3>

<p>打印出所执行的每一行命令</p>

<pre><code>bash -x script.sh
sh -x script.sh
</code></pre>

<p>在脚本中设置开关</p>

<pre><code>set -x 在执行时显示参数和命令
set +x 关闭调试
set -v 当命令进行读取时显示输入
set +v 禁止打印输入
</code></pre>

<p>直接修改脚本</p>

<pre><code>#!/bin/bash -xv
</code></pre>

<h3 id="函数和参数">函数和参数</h3>

<p>定义函数</p>

<pre><code>function fname()
{
    statements;
}
or
fname()
{
    statements;
}
</code></pre>

<p>调用</p>

<pre><code>fname;
传参
fname arg1 arg2;
</code></pre>

<p>接收参数</p>

<pre><code>$1第一个参数
$2第二个参数
$n第n个参数

&quot;$@&quot;被扩展成 &quot;$1&quot; &quot;$2&quot; &quot;$3&quot;
&quot;$*&quot;扩展成&quot;$1c$2c$3&quot;, 其中c是IFS第一个字符

&quot;$@&quot;使用最多, $*将所有的参数当做单个字符串
</code></pre>

<p>bash支持递归</p>

<p>导出函数,可以作用到子进程中</p>

<pre><code>export -f fname
</code></pre>

<p>函数及命令返回值</p>

<pre><code>cmd;
echo $?

退出状态，成功退出，状态为0，否则，非0

cmd
if [ $? -eq 0 ]
then
    echo &quot;success&quot;
else
    echo &quot;fail&quot;
fi
</code></pre>

<h3 id="管道">管道</h3>

<p>前一个命令的输出作为后一个命令的输入</p>

<pre><code>$cmd1 | cmd2 | cmd3
</code></pre>

<h3 id="读取命令输出">读取命令输出</h3>

<pre><code>子shell  subshell
cmd_output=$(COMMANDS)
or
反引用
cmd_output=`COMMANDS`
</code></pre>

<p>子shell本身是独立进程, 不会对当前shell有任何影响</p>

<pre><code>pwd;
(cd /bin; ls)
pwd #同上一个pwd
</code></pre>

<p>保留空格和换行符</p>

<pre><code>out=$(cat text.txt)
echo $out  #丢失所有换行符

out=&quot;$(cat text.txt)&quot;
echo $out  #保留

cat a
1
2
3
echo $(cat a)
1 2 3
echo &quot;$(cat a)&quot;
1
2
3
</code></pre>

<h3 id="read">read</h3>

<p>read, 用于从键盘或标准输入中读取文本</p>

<p>读取n个字符存入变量</p>

<pre><code>read -n number_of_chars variable_name
</code></pre>

<p>不回显的方式读取密码</p>

<pre><code>read -s var
</code></pre>

<p>显示提示信息</p>

<pre><code>read -p &quot;Enter input:&quot; var
</code></pre>

<p>限时输入</p>

<pre><code>read -t  timeout var
</code></pre>

<p>设置界定符</p>

<pre><code>read -d delim_char var
read -d &quot;:&quot; var
hello:
</code></pre>

<h3 id="字段分隔符和迭代器">字段分隔符和迭代器</h3>

<p>内部字段分隔符，Internal Field Separator, IFS</p>

<p>IFS默认为空白字符（换行符，制表符，空格）</p>

<pre><code>data=&quot;name,sex,rollno&quot;
oldIFS=$IFS
IFS=,
for item in $data
do
        echo $item
done

IFS=$oldIFS
</code></pre>

<h3 id="循环">循环</h3>

<p>for循环</p>

<pre><code>echo {1..50}

for i in {a..z}; do actions; done;

or

for((i=0;i&lt;10;i++))
{
    commands;
}
</code></pre>

<p>while循环</p>

<pre><code>while condition
do
    commands;
done
</code></pre>

<p>until循环</p>

<pre><code>until condition
do
    commands;
done
</code></pre>

<h3 id="比较和测试">比较和测试</h3>

<p>if条件</p>

<pre><code>if condition;
then
    commands;
elif condition;
then
    commands;
else
    commands;
fi
</code></pre>

<p>逻辑运算符进行简化, 短路运算更简洁</p>

<pre><code>[ condition ] &amp;&amp; action;
[ condition ] || action;
</code></pre>

<p>算术比较</p>

<pre><code>-gt 大于
-lt 小于
-ge 大于等于
-le 小于等于
-ne 不等于
-eq 等于

注意[]和操作数之间的空格
[ $var -eq 0 ]

and
[ $var -ne 0 -a $var2 -ge 2 ]
or
[ $var -ne 0 -o $var2 -ge 2 ]
</code></pre>

<p>文件测试</p>

<pre><code>[ -f $file_var ] 正常文件路径或文件名
[ -x $var ] 可执行
-d 目录
-e 存在
-c 字符设备文件
-b 块设备文件
-w 可写
-r 可读
-L 符号链接
</code></pre>

<p>字符串比较</p>

<pre><code>[[ $str1 = $str2 ]]
[[ $str1 == $str2 ]]

[[ $str1 != $str2 ]] 不等

[[ $str1 &gt; $str2 ]]
[[ $str1 &lt; $str2 ]]

[[ -z $str1 ]]  空
[[ -n $str1 ]]  非空

if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]]
then
    commands;
fi
</code></pre>

<h3 id="find">find</h3>

<p>搜索指定目录下的文件，从开始于父目录，然后搜索子目录</p>

<p>基本</p>

<pre><code>find base_path

# 打印文件和目录列表
find . -print  #默认\n分割文件名
</code></pre>

<p>文件名</p>

<pre><code>find path -name &quot;*.txt&quot; -print
          -iname  忽略大小写

多个条件 or
find . \( -name &quot;*.txt&quot; -o -name &quot;*.py&quot; \)
</code></pre>

<p>文件路径</p>

<pre><code>通配符
find /home/users -path &quot;*slynux*&quot; -print

正则
find . -regex &quot;.*\(\.py\|\.sh\)$&quot;
       -iregex 忽略大小写
</code></pre>

<p>否定参数</p>

<pre><code>find . ! -name &quot;*.txt&quot; -print
</code></pre>

<p>根据文件类型</p>

<pre><code>find . -type d -print
f 普通文件
l 符号链接
d 目录
c 字符设备
b 块设备
s 套接字
p Fifo
</code></pre>

<p>设定目录深度</p>

<pre><code>find . -maxdepth 1 -type f -print
find . -mindepth 2 -type f -print
</code></pre>

<p>根据文件时间搜索</p>

<pre><code>计量单位 天
-atime 最近一次访问时间
-mtime 最后一次被修改时间
-ctime 文件元数据，最近一次修改时间

find . -type f -atime -7 -print #最近七天内被访问的
find . -type f -atime 7 -print  #恰好在七天前
                      +7 -print #超过七天

计量单位 分钟
-amin 访问时间
-mmin 修改时间
-cmin 变化时间

find . -type f -amin +7 -print #访问时间超过7分钟的

find . -type f -newer file.txt -print  #用于比较时间戳的参考文件，比参考文件更新的文件
</code></pre>

<p>基于文件大小的搜索</p>

<pre><code>find . -type f -size +2k
+ 大于  -小于   无符号，恰好等于

b 块
c 字节
w 字（2字节）
k 千字节
M 兆字节
G 吉字节
</code></pre>

<p>删除匹配的文件</p>

<pre><code>find . -type f -name &quot;*.swp&quot; -delete
#注意：-delete位置一定是最后
</code></pre>

<p>文件权限及所有权</p>

<pre><code>find . -type f -perm 644 -print

find . -type f -user slynux -print
</code></pre>

<p>执行命令或动作(最强大的命令)</p>

<pre><code>find . -type f -user root -exec chown slynux {} \;
find . -type f -exec cp {} OLD \;
find . -iname &quot;abc.txt&quot; -exec md5sum {} \;

{} 江北替换成对应文件名
exec无法结合多个命令，可以将多个命令放入脚本，调用之
</code></pre>

<p>跳过指定目录</p>

<pre><code>find . \( -name &quot;.git&quot; -prune \) -name '*.txt'
</code></pre>

<h3 id="xargs">xargs</h3>

<p>将标准输入数据转化成命令行参数</p>

<p>将stdin接收到的数据重新格式化，再将其作为参数传给其他命令</p>

<p>多行输入转化成单行输出</p>

<pre><code>cat  example.txt | xargs  #空格替换掉\n
</code></pre>

<p>切成多行，每行n个参数</p>

<pre><code>cat examplet.txt | xargs -n 3
</code></pre>

<p>可以指定分隔符</p>

<pre><code>echo &quot;aaaXbbbXccc&quot; | xargs -d 'X'
</code></pre>

<p>将参数传递给脚本(类似循环)</p>

<pre><code>cat args.txt | xargs -n 1 ./cecho.sh

./cecho.sh -p arg1 1
需要变更
cat args.txt | xargs -I {} ./cecho.sh -p {} 1
</code></pre>

<p>find与xargs组合</p>

<pre><code>find . -type f -name &quot;*.txt&quot; -print | xargs rm -rf
</code></pre>

<p>其他</p>

<pre><code>cat file | ( while read arg; do cat $arg; done )
cat file | xargs -I {} cat {}
</code></pre>

<h3 id="tr">tr</h3>

<p>tr可以对来自标准输入的字符进行替换，删除以及压缩(translate, 可以将一组字符变成另一组字符)</p>

<p>tr只能通过stdin，无法通过其他命令行进行接收参数</p>

<p>格式</p>

<pre><code>tr [options] source-char-set replace-char-set
</code></pre>

<p>选项</p>

<pre><code>-c 取source-char-set补集，通常与-d/-s配合
-d 删除字source-char-set中的所列的字符
-s 浓缩重复字符，连续多个变成一个
</code></pre>

<p>字符替换</p>

<pre><code>cat /proc/12501/environ | tr '\0' '\n'
</code></pre>

<p>大小写替换</p>

<pre><code>echo  &quot;HELLO&quot; | tr 'A-Z' 'a-z'
cat text | tr '\t' ' '
</code></pre>

<p>删除字符</p>

<pre><code>echo &quot;hello 123 world 456&quot;| tr -d '0-9'
hello  world
</code></pre>

<p>字符集补集</p>

<pre><code>echo &quot;hello 1 char 2&quot; | tr -d -c '0-9'  #删除非0-9
12
</code></pre>

<p>压缩字符</p>

<p>连续的重复字符</p>

<pre><code>echo &quot;GNU is    not UNix&quot; | tr -s ' '
</code></pre>

<p>字符类</p>

<pre><code>alnum 字母和数字
alpha 字母
cntrl 控制字符
digit 数字
graph 图形字符
lower 小写字母
print 可打印字符
punct 标点符号
space 空白字符
upper 大写字母
xdigit 十六进制字符

tr '[:lower:]' '[:upper:]'
</code></pre>

<h3 id="md5sum">md5sum</h3>

<p>32个字符的十六进制串</p>

<pre><code>md5sum filename
md5sum filename1 filename2
</code></pre>

<h3 id="sha1sum">sha1sum</h3>

<p>40个字符十六进制串</p>

<pre><code>sha1sum file
</code></pre>

<h3 id="对目录进行校验">对目录进行校验</h3>

<p>需安装md5deep软件包</p>

<pre><code>md5deep/sha1deep
md5deep -rl dirname
         r递归，l相对路径
</code></pre>

<h3 id="sort">sort</h3>

<p>语法</p>

<pre><code>sort [options] [file(s)]

-c 检查是否已排序
-u 丢弃所有具有相同键值的记录

-b 忽略开头空白
-d 字典序
-g 一般数值，以浮点数类型比较字段，仅支持gnu
-i 忽略无法打印的字符

-k 定义排序键值字段
-n 以整数类型比较字段
-r 倒转
-o 输出到指定文件
</code></pre>

<p>排序</p>

<pre><code>sort file1 &gt; file1.sorted
sort -o file1.sored file1
</code></pre>

<p>按数字, 要明确</p>

<pre><code>sort -n file1
</code></pre>

<p>逆序</p>

<pre><code>sort -r file
</code></pre>

<p>测试一个文件是否已经被排过序</p>

<pre><code>sort -C file
if [ $? -eq 0 ]; then
    echo ssss
fi
</code></pre>

<p>合并两个排过序的文件，并不需要对合并后的文件进行再排序</p>

<pre><code>sort -m sorted1 sorted2
</code></pre>

<p>根据键或者列排序(按照哪一个列)</p>

<pre><code>sort -k 1 data
</code></pre>

<p>限定特定范围内一组字符</p>

<pre><code>key=char4-char8
sort -k 2,3 data

sort -k2.4,5.6 file
第二个字段的第四个字符开始比较，直到第五个字段的第六个字符
</code></pre>

<p>忽略前导空白及字典序排序</p>

<pre><code>sort -bd unsorted.txt
</code></pre>

<p>去重</p>

<pre><code>sort a.txt | uniq
sort -u a.txt
</code></pre>

<h3 id="uniq">uniq</h3>

<p>用法</p>

<pre><code>uniq file
</code></pre>

<p>只显示未重复的记录</p>

<pre><code>uniq -u file
</code></pre>

<p>找出重复的行</p>

<pre><code>uniq -d file
-s 可指定跳过前N个字符
-w 指定用于比较的最大字符数
</code></pre>

<p>统计各行出现的次数</p>

<pre><code>uniq -c file
</code></pre>

<p>p57</p>

<h3 id="tempfile">tempfile</h3>

<p>只有在基于Debian的发布版才有(Ubuntu/Debian)</p>

<pre><code>temp_file=$(tempfile)
等同
temp_file=&quot;/tmp/file-$RANDOM&quot;

#$$为进程id
temp_file=&quot;/tmp/var.$$&quot;
</code></pre>

<h3 id="split">split</h3>

<p>按大小分割文件, 单位k(KB), M, G, c(byte), w(word)</p>

<pre><code>split -b 10k data.file
</code></pre>

<p>-d数字后缀，-a后缀长度</p>

<pre><code>split -b 10k data.file -d -a 4
</code></pre>

<p>分割后指定文件名前缀</p>

<pre><code>split -b 10k data.file file_prefix

设置后缀格式
split -b 10k data.file -d -a 4 file_prefix
</code></pre>

<p>根据行数分割</p>

<pre><code>spilt -l 10 data
</code></pre>

<p>其扩展是csplit，可根据文件特性切分，关注</p>

<h3 id="bash变量匹配切分">bash变量匹配切分</h3>

<p>sample.jpg</p>

<pre><code>file_jpg=&quot;sample.jpg&quot;

从右向左匹配
${file_jpg%.*}
#sample

从左向右匹配
${file_jpg#.*}
#jpg

% # 属于非贪婪
%% ## 属于贪婪
</code></pre>

<p>贪婪非贪婪</p>

<pre><code>var=hack.fun.book.txt
${var%.*} #hack.fun.book
${var%%.*} #hack

${var#.*} #fun.book.txt
${var##.*} #txt
</code></pre>

<h3 id="expect">expect</h3>

<p>实现自动化</p>

<pre><code>spawn ./ineractive.sh
expect &quot;Enter the number&quot;
send &quot;1\n&quot;
expect &quot;Enter name:&quot;
send &quot;hello\n&quot;
expect eof

spawn指定需要自动化的命令
expect提供需要等待的消息
send发送消息
expect eof指明命令交互结束
</code></pre>

<h3 id="dd">dd</h3>

<p>生成任意大小的文件</p>

<pre><code># 创建一个1M大小的文件junk.data
bs=2M count=2 则文件大小4M

dd if=/dev/zero of=junk.data bs=1M count=1
   输入文件     输出文件     块大小   复制块数

块大小单位
字节(1B) c
字(2B)   w
块(512B)   b
千字节(1024B) k
兆字节(1024KB) M
吉字节(1024MB) G
</code></pre>

<h3 id="comm">comm</h3>

<p>两个文件之间比较，输出三列</p>

<pre><code>onleA \t onlyB \t bothAB

comm A B -1 -2 #删除第一第二列
-3 删除第三列

可以得到A^B  A-B B-A
</code></pre>

<h3 id="mkdir">mkdir</h3>

<p>“mkdir”(Make
directory)命令在命名路径下创建新的目录。然而如果目录已经存在了，那么它就会返回一个错误信息”不能创建文件夹，文件夹已经存在了”(“cannot
create folder, folder already exists”)</p>

<pre><code>mkdir dirpath

mkdir -p dirpath1/dirpath2

#一次多个目录
mkdir -p /home/user/{test,test1,test2}
</code></pre>

<p>注意：目录只能在用户拥有写权限的目录下才能创建</p>

<h3 id="ls">ls</h3>

<p>ls命令是列出目录内容(List Directory Contents)的意思。运行它就是列出文件夹里的内容，可能是文件也可能是文件夹</p>

<p>ls文件的内容关系</p>

<pre><code>- 普通文件
d 目录
c 字符设备
b 块设备
l 符号链接
s 套接字
p 管道

文件权限序列
rwx
rwS  setuid(S)，特殊权限, 出现在x的位置, 允许用户以其拥有者的权限来执行文件, 即使这个可执行文件是由其他用户运行的

目录
r,允许读取目录中文件和子目录列表
w,允许在目录中创建或删除文件或目录
x,指明是否可以访问目录中的文件和子目录
rwt/rwT 粘滞位，只有创建该目录的用户才能删除目录中的文件，即使用户组和其他用户也有写权限，典型例子/tmp, 写保护
</code></pre>

<p>查看目录</p>

<pre><code>ls -d */
ls -F | grep &quot;/$&quot;
ls -l | grep &quot;^d&quot;
find . -type d -maxdepth 1 -print
</code></pre>

<p>其他</p>

<pre><code>ls -l    命令已详情模式(long listing fashion)列出文件夹的内容
ls -a    命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件
</code></pre>

<h3 id="chmod">chmod</h3>

<p>设置文件权限</p>

<p>“chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p>

<p>设置权限</p>

<pre><code>user group others all
u    g     o      a

chmod u=rwx g=rw o=r filename

chmod u+x filename
chomd a+x filename #所有

chmod a-x filename

chmod 764 filename

#设置粘滞位
chmod a+t dirname

#递归改变

chmod 777 . -R
</code></pre>

<p>注意：对于系统管理员和用户来说，这个命令是最有用的命令之一了。在多用户环境或者服务器上，对于某个用户，如果设置了文件不可访问，那么这个命令就可以解决，如果设置了错误的权限，那么也就提供了为授权的访问。</p>

<h3 id="chown">chown</h3>

<p>每个文件都属于一个用户组和一个用户“chown”命令用来改变文件的所有权，所以仅仅用来管理和提供文件的用户和用户组授权。</p>

<p>改变所有权</p>

<pre><code>chown user.group filename
</code></pre>

<p>递归</p>

<pre><code>chown -R user.group .
</code></pre>

<p>每次都以其他用户身份执行(允许其他用户以文件所有者的身份来执行)</p>

<pre><code>chomod +s executable_file

chown root.root executable_file
chmod +s executable_file
./executable_file
</code></pre>

<h3 id="chattr">chattr</h3>

<p>创建不可修改文件</p>

<pre><code>chattr +i file
</code></pre>

<p>一旦被设置为不可修改, 任何用户包括超级用户都不能删除该文件, 除非其不可修改的属性被移除</p>

<pre><code>chattr -i file
</code></pre>

<h3 id="touch">touch</h3>

<p>“touch”命令代表了将文件的访问和修改时间更新为当前时间。</p>

<p>touch命令只会在文件不存在的时候才会创建它(空白文件)。如果文件已经存在了，它会更新时间戳，但是并不会改变文件的内容。</p>

<p>空白文件</p>

<pre><code>touch filename

for name {1..100}.txt
do
    touch $name
done
</code></pre>

<p>修改文件访问时间</p>

<pre><code>touch -a &quot;Fri Jun 25 20:50:14 IST 1999&quot; filename
touch -m #修改文件内容的修改时间
</code></pre>

<p>修改文件或目录的时间戳(YYMMDDhhmm)</p>

<pre><code>touch -t 0712250000 file
</code></pre>

<p>注意：touch 可以用来在用户拥有写权限的目录下创建不存在的文件。</p>

<h3 id="ln">ln</h3>

<p>建立软连接</p>

<pre><code>ln -s target symbolic_link_name
</code></pre>

<p>如果目的路径已经存在，而没有指定 -f 标志，ln 命令不会创建新的链接，而是向标准错误写一条诊断消息并继续链接剩下的 SourceFiles。</p>

<p>-f 促使 ln 命令替换掉任何已经存在的目的路径</p>

<h3 id="readlink">readlink</h3>

<p>读取链接对应真是路径</p>

<pre><code>readlink web

 readlink ~/.vim
 /Users/ken/github/k-vim
</code></pre>

<h3 id="file">file</h3>

<p>通过查看文件内容来找出特定类型的文件</p>

<p>打印文件类型信息</p>

<pre><code>file filename
</code></pre>

<p>打印不包含文件名在内</p>

<pre><code>file -b filename
</code></pre>

<p>e.g.</p>

<pre><code>file /etc/passwd
/etc/passwd: ASCII English text

file -b /etc/passwd
ASCII English text
</code></pre>

<h3 id="读文件">读文件</h3>

<pre><code>while read line;
do
    something
done &lt; filename
</code></pre>

<h3 id="diff">diff</h3>

<p>生成文件差异</p>

<p>非一体化</p>

<pre><code>diff version1.txt version2.txt
</code></pre>

<p>一体化, 可读性更好</p>

<pre><code>diff -u version.txt
</code></pre>

<p>使用patch将命令应用于任意一个文件</p>

<pre><code>diff -u version1.txt version2.txt &gt; version.patch
patch -p1 version1.txt &lt; version.patch
</code></pre>

<p>递归作用于目录</p>

<pre><code>diff -Naur directory1 directory2

-N 所有缺失的文件作为空文件
-a 所有文件视为文本文件
-u 一体化输出
-r 递归遍历
</code></pre>

<h3 id="head">head</h3>

<p>前10行打印</p>

<pre><code>head file
</code></pre>

<p>前n行</p>

<pre><code>head -n 4 file
</code></pre>

<p>扣除最后N行之外的所有行</p>

<pre><code>head -n -5 file
</code></pre>

<h3 id="tail">tail</h3>

<p>最后10行</p>

<pre><code>tail file
</code></pre>

<p>打印最后五行</p>

<pre><code>tail -n 5 file
tail -5 file
</code></pre>

<p>扣除前n行</p>

<pre><code>tail -n +(N+1)
</code></pre>

<p>实时动态打印</p>

<pre><code>tail -f growing_file
</code></pre>

<p>当某个给定进程结束后, tail随之终结</p>

<pre><code>tail -f file --PID $PID
</code></pre>

<h3 id="pushd-popd">pushd/popd</h3>

<p>将当前路径压入栈</p>

<pre><code>pushd
</code></pre>

<p>压入某个路径</p>

<pre><code>pushd /home/ken
</code></pre>

<p>查看当前路径列表</p>

<pre><code>dirs
</code></pre>

<p>切换到某一个</p>

<pre><code>#dirs从左到右编号 0 -
pushd +3
</code></pre>

<p>移除最近压入栈的路径并切换到下一个目录</p>

<pre><code>popd
</code></pre>

<h3 id="cd">cd</h3>

<p>经常使用的“cd”命令代表了改变目录。它在终端中改变工作目录来执行，复制，移动，读，写等等操作</p>

<p>切换到上一目录</p>

<pre><code>cd -
</code></pre>

<p>会到HOME目录</p>

<pre><code>cd
cd ~
</code></pre>

<p>会到上一级目录</p>

<pre><code>cd ..
</code></pre>

<h3 id="wc">wc</h3>

<p>Word Count</p>

<p>统计行数</p>

<pre><code>wc -l file
</code></pre>

<p>统计单词数</p>

<pre><code>wc -w file
</code></pre>

<p>统计字符数</p>

<pre><code>wc -c file
</code></pre>

<p>统计所有</p>

<pre><code>wc file
</code></pre>

<p>统计最长行的长度</p>

<pre><code>wc file -L
</code></pre>

<h3 id="tree">tree</h3>

<p>以图形化的树状结构打印文件和目录的结构，需要自行安装</p>

<pre><code>tree ~/unixfile
</code></pre>

<p>重点标记出匹配某种样式的文件</p>

<pre><code>tree PATH -P &quot;*.sh&quot;
</code></pre>

<p>只标记符合样式之外的文件</p>

<pre><code>tree path -I PATTERN
</code></pre>

<p>同时打印文件和目录大小</p>

<pre><code>tree -h
</code></pre>

<h3 id="grep">grep</h3>

<p>文本搜索工具, 支持正则表达式和通配符</p>

<p>‘grep‘命令搜索指定文件中包含给定字符串或者单词的行</p>

<p>基本用法</p>

<pre><code>grep &quot;match_pattern&quot; file1 file2
</code></pre>

<p>使用颜色重点标记</p>

<pre><code>grep word filename --color=auto
</code></pre>

<p>扩展型使用正则</p>

<pre><code>grep -E &quot;[a-z]+&quot;
egrep &quot;[a-z]+&quot;
</code></pre>

<p>只输出匹配到的文本部分</p>

<pre><code>grep -o word filename
</code></pre>

<p>除匹配行外的所有行</p>

<pre><code>grep -v word filename
</code></pre>

<p>统计匹配行数</p>

<pre><code>grep -c 'text' filename
</code></pre>

<p>打印出包含匹配字符串的行数</p>

<pre><code>grep linux -n filename
</code></pre>

<p>打印样式匹配所位于的字符或字节的偏移</p>

<pre><code>echo &quot;gnu is not unix&quot; | grep -b -o &quot;not&quot;
</code></pre>

<p>搜索多个文件，找出匹配文本位于哪个文件中</p>

<pre><code>grep -l linux file1 file2
取反
grep -L
</code></pre>

<p>递归搜索目录</p>

<pre><code>grep -R &quot;text&quot; dir
</code></pre>

<p>忽略大小写</p>

<pre><code>grep -i &quot;hello&quot; filename
</code></pre>

<p>匹配多个样式</p>

<pre><code>grep -e &quot;pattern1&quot; -e &quot;pattern2&quot; file
</code></pre>

<p>运行匹配脚本</p>

<pre><code>grep -f pattern_file source_file

pattern_file:
hello
cool
</code></pre>

<p>在搜索中包含、排除文件</p>

<pre><code>grep --include *.{c,cpp} word file
</code></pre>

<p>排除</p>

<pre><code>grep --exclude &quot;Readme&quot; filename
--exclude-dir
</code></pre>

<p>静默输出，用于判断(不会产生任何输出)</p>

<pre><code>grep -q word file
if [ $? -eq 0 ]
</code></pre>

<p>打印匹配行之前，之后的行</p>

<pre><code>grep -A 3 之后3行
grep -B 3 之前
grep -C 3 前后
</code></pre>

<p>使用行缓冲</p>

<pre><code>在使用tail -f命令时是可以及时看到文件的变化的，但是如果再加上一个grep命令，可能看到的就不那么及时了，
因为grep命令在buffer写不满时就不输出，可以通过选项  --line-buffered 来搞定，如：

tail -f file.txt | grep something  --line-buffered
</code></pre>

<h3 id="cut">cut</h3>

<p>语法</p>

<pre><code>cut -c list [ file ... ]
cut -f list [ -d delim ] [ file ...]

-c list 以字符为主，作剪切操作
-f list 以字段为主，作剪切操作
</code></pre>

<p>提取字段或列</p>

<pre><code>#第一列
cut -f1 filenam

#第二三列
cut -f2,3 filename
</code></pre>

<p>提取补集</p>

<pre><code>cut -f1 --complement filename
</code></pre>

<p>指定字段分隔符</p>

<pre><code>cut -d &quot;;&quot; -f2 filename
cut -d : -f 1,5 /etc/passwd
</code></pre>

<p>指定字符</p>

<pre><code>-b 字节
-c 字符
-f 字段

cut -c1-5 filename
N-
N-M
-M

ls -l | cut -c 1-10
</code></pre>

<p>指定输出分隔符</p>

<pre><code>cut -c1-3,6-9 --output-delimiter &quot;,&quot;
</code></pre>

<h3 id="join">join</h3>

<p>语法</p>

<pre><code>join [options] file1 file2

选项
-1 field1
-2 field2
-o file.field
-t separator
</code></pre>

<p>例子</p>

<pre><code>join file1 file2
</code></pre>

<h3 id="sed">sed</h3>

<p>sed(Stream editor)流编辑器, 可以配合正则使用, 进行替换等</p>

<p>sed替换语法</p>

<pre><code>sed 's/pattern/replace_string/' file
</code></pre>

<p>将结果直接运用于源文件</p>

<pre><code>-i 用于, 直接修改源文件

替换第一个
sed -i 's/pattern/replace_string/' file

替换第二个
sed -i 's/pattern/replace_string/2' file

替换所有
sed -i 's/pattern/replace_string/g' file

从第N处开始替换
sed -i 's/pattern/replcae_string/2g' file
</code></pre>

<p>移除空白行</p>

<pre><code>sed '/^$/d' file
</code></pre>

<p>已匹配字符串标记</p>

<pre><code>引用匹配到的
sed 's/\w\+/[&amp;]/g' filename
</code></pre>

<p>组合多个表达式</p>

<pre><code>sed 'exp1' | sed 'exp2'
等价
sed 'exp1;exp2'
</code></pre>

<p>使用引用</p>

<pre><code>sed &quot;s/$text/HELLO/&quot;
</code></pre>

<p>子串匹配标记(后向引用，最多9个)</p>

<pre><code>sed 's/\([a-z]\+\)' \([A-Z\]\+\)/\2 \1/' filename
</code></pre>

<p>保存到文件</p>

<pre><code>sed 's/pattern/replacement/' -i outfile
</code></pre>

<p>使用其他分隔符</p>

<pre><code>sed 's#/home/#/tmp/#'
</code></pre>

<h3 id="awk">awk</h3>

<p>基本结构</p>

<pre><code>awk -F '-' 'BEGIN{statements} {statements} END{statements}' file
表达式中单引号可以换成双引号
BEGIN -&gt; 每一行，执行statements, 执行END
</code></pre>

<p>打印某一列</p>

<pre><code>awk -F '-' '{print $0}' file #全部
awk -F '-' '{print $2}' file #第二列
</code></pre>

<p>print拼接字符</p>

<pre><code>awk '{var=&quot;v1&quot;; var1=&quot;v2&quot;; print var1&quot;-&quot;var2;}'
</code></pre>

<p>特殊变量</p>

<pre><code>NR nuber of records, 记录数
NF number of fields, 字段数
$0 当前行文本
$1 第一字段
$2 第二字段
$NF 最后一个字段

FILENAME 当前输入文件的名称
FNR 当前输入文件记录数
FS 字段分隔字符
OFS 输出字段分隔符，默认&quot; &quot;
ORS 输出记录分隔符，默认&quot;\n&quot;
</code></pre>

<p>统计行数</p>

<pre><code>awk 'END{print NF}'
</code></pre>

<p>将外部变量值传递给awk</p>

<pre><code>awk -v VARIABLE=$VAR '{ print VARIABLE }'
awk '{print v1, v2}' v1=$var1 v2=$var2
</code></pre>

<p>读取行</p>

<pre><code>seq 5 | awk '{ getline var; print var}'
</code></pre>

<p>进行行过滤</p>

<pre><code>awk 'NR&lt;5' #行号小于5
awk 'NR==1,NR==4' #行号在1到5之间
awk '/linux/' #包含样式linux
awk '!/linux/' #不包含
awk '$1 ~/jones/' #第一个字段包含jones

tail file
awk 'NR &lt;= 10' file
</code></pre>

<p>设定分隔符</p>

<pre><code>awk -F: '{ print $NF }' file
</code></pre>

<p>设定输出分隔符</p>

<pre><code>awk -F: -v &quot;OFS=-&quot; '{print $1,$2}' /etc/passwd
</code></pre>

<p>打印空行</p>

<pre><code>awk 'NF&gt;0 {print $0}'
or
awk 'NF&gt;0' #未指定action默认打印
</code></pre>

<p>print和printf</p>

<pre><code>awk -F: '{print &quot;User&quot;, $1, &quot;is really&quot;, $5}' /etc/passwd
awk -F: '{printf &quot;User %s is really %s\n&quot;, $1, $5}' /etc/passwd
</code></pre>

<p>awk中使用循环</p>

<pre><code>for(i=0;i&lt;10;i++) { print $i; }

for(i in array) { print array[i] }
</code></pre>

<p>内建函数</p>

<pre><code>length(str)
index(str,search_str)
split(str,array,delimiter) 用界定符生成一个字符串列表
substr(string, start, end) #子串
sub(regex, replacement_str, str) #正则替换首个匹配位置
gsub(regex, replacement_str, string) #最后一个匹配位置
match(string, regex) #检查是否能够匹配字符串
tolower(string) #转小写
toupper(string) #转大写
</code></pre>

<p>写成脚本文件</p>

<pre><code>BEGIN {}
pattern1 {action1}
pattern2 {action2}
END {}
</code></pre>

<h3 id="文件迭代">文件迭代</h3>

<p>读文件行</p>

<pre><code>while read line;
do
    echo $line;
done &lt; file.txt
</code></pre>

<p>迭代每个单词</p>

<pre><code>for word in $line;
do
    echo $word;
done
</code></pre>

<p>迭代每一个字符</p>

<pre><code>for((i=0;i&lt;${#word};i++))
do
    echo ${word:i:1} ;
done
</code></pre>

<h3 id="paste">paste</h3>

<p>按列合并文件</p>

<pre><code>paste file1 file2 file3
</code></pre>

<p>指定分隔符</p>

<pre><code>paste file1 file2 -d ','
</code></pre>

<h3 id="tac">tac</h3>

<p>逆序打印</p>

<pre><code>tac file1 file2
</code></pre>

<h3 id="rev">rev</h3>

<p>接收一个文件或stdin作为输入, 逆序打印每一行内容</p>

<pre><code>echo &quot;abc&quot; | rev
</code></pre>

<h3 id="wget">wget</h3>

<p>Wget是用于非交互式（例如后台）下载文件的免费工具.支持HTTP, HTTPS, FTP协议和 HTTP 代理(选项多, 用法灵活)</p>

<p>一个用于文件下载的命令行工具</p>

<pre><code>wget URL1 URL2
</code></pre>

<p>指定保存文件名</p>

<pre><code>wget URL -O local.txt
</code></pre>

<p>指定日志，默认达到stdout</p>

<pre><code>wget URL -O local.txt -o log.txt
</code></pre>

<p>指定重复尝试次数</p>

<pre><code>wget -t 5 URL
</code></pre>

<p>下载限速</p>

<pre><code>wget --limit-rate 20k url
</code></pre>

<p>指定限额</p>

<pre><code>wget -Q 100m url
</code></pre>

<p>断点续传</p>

<pre><code>wget -c URL

$ wget -c -t 100 -T 120 http://www.linux.com/xxxx.data

当文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。
wget的断点续传是自动的。
-c 选项的作用为断点续传。
-t 参数表示重试次数(例如重试100次，-t 100，如果设成-t 0，表示无穷次重试，直到连接成功)
-T 参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时
</code></pre>

<p>复制或镜像整个网站</p>

<pre><code>wget --mirror exampledomain.com
wget -r -N -l DEPTH URL
     递归，允许对文件使用时间戳，层级
$ wget -r -np -nd http://www.linux.com/packs/

-np 的作用是不遍历父目录
-nd 表示不在本机重新创建目录结构
</code></pre>

<p>访问需要认证的HTTP/FTP</p>

<pre><code>wget --user username --password pass URL
</code></pre>

<p>post请求</p>

<pre><code>wget url -post-data &quot;name=value&quot; -O output.html
</code></pre>

<p>批量下载</p>

<pre><code>wget -i downloads.txt #将文件地址写入一个文件
</code></pre>

<p>用wget命令执行ftp下载</p>

<pre><code>wget -m ftp://username:password@hostname
</code></pre>

<h3 id="curl">curl</h3>

<p>基本用法</p>

<pre><code>curl url &gt; index.html
</code></pre>

<p>不显示进度信息</p>

<pre><code>curl URL --slient
</code></pre>

<p>将内容写入文件，而非标准输出</p>

<pre><code>curl URL --slient -O
</code></pre>

<p>写入指定文件</p>

<pre><code>curl URL --slient -o filename
</code></pre>

<p>显示进度条</p>

<pre><code>curl url -o index.html --progress
</code></pre>

<p>断点续传</p>

<pre><code>curl -C - URL
</code></pre>

<p>设置参照页字符串</p>

<pre><code>curl --referer Referer_URL target_URL
跳转到target_URL,其头部referer为Referer_URL
</code></pre>

<p>设置cookie</p>

<pre><code>curl url --cookie &quot;user=slynux;pass=hack&quot;
另存为一个文件

curl URL --cookie-jar cookie_file
</code></pre>

<p>设置用户代理</p>

<pre><code>curl URL --user-agent &quot;Mozilla/5.0&quot;
头部信息
curl -H &quot;Host: www.slynux.org&quot; -H &quot;Accept-language: en&quot; url
</code></pre>

<p>限定下载带宽</p>

<pre><code>curl url --limit-rate 20k
</code></pre>

<p>指定最大下载量(可下载的最大文件大小)</p>

<pre><code>curl url --max-filesize bytes
超出限制的话，返回非0
</code></pre>

<p>进行认证</p>

<pre><code>curl -u user:pass url
</code></pre>

<p>只打印头部信息,不下载远程文件</p>

<pre><code>curl -I url
curl -head url
</code></pre>

<p>发送post请求</p>

<pre><code>curl URL -d &quot;va1=1&amp;va2=2&quot;
         --data
</code></pre>

<h3 id="lynx">lynx</h3>

<p>将网页以ascii字符形式下载</p>

<pre><code>lynx -dump URL &gt; webpage_as_text.txt
</code></pre>

<p>打印出网站的文本板块而非html</p>

<pre><code>lynx -dump url
</code></pre>

<p>生成信息文件</p>

<pre><code>lynx -traversal url
</code></pre>

<h3 id="tar">tar</h3>

<p>“tar”命令是磁带归档(Tape Archive)，对创建一些文件的的归档和它们的解压很有用。</p>

<p>将多个文件和文件夹保存成单个文件, 同时还能保留所有的文件属性</p>

<p>对文件进行归档</p>

<pre><code>-c create file,创建文件
-f specify filename,指定文件名

tar -cf output.tar file1 file2 file3
tar -cf output.tar *.txt

tar -cvf output.tar *.txt
</code></pre>

<p>向归档中追加文件</p>

<pre><code>tar -rvf original.tar new_file
-r,追加
</code></pre>

<p>查看过程中更多信息</p>

<pre><code>tar -tvvf archive.tar
-v/-vv, verbose
</code></pre>

<p>提取文件或文件夹</p>

<pre><code>-x, exact
tar -xf archive.tar

-C,指定文件
tar -xf archive.tar -C /path/to/extraction_directory


tar -xvf archive.tar
</code></pre>

<p>提取指定文件</p>

<pre><code>tar -xvf file.tar file1 file4
</code></pre>

<p>拼接两个归档文件</p>

<pre><code>tar -Af file1.tar file2.tar
#file2合并到file1中
</code></pre>

<p>只有在文件内容修改时间更新(newer),才进行添加</p>

<pre><code>tar -uvvf archive.tar filea
</code></pre>

<p>比较归档文件与文件系统中的内容</p>

<pre><code>tar -df archive.tar filename1 filename2
</code></pre>

<p>从归档文件中删除文件</p>

<pre><code>tar -f archive.tar --delete file1 file2
</code></pre>

<p>提取到某个目录</p>

<pre><code> tar zxvf package.tar.gz -C new_dir
</code></pre>

<p>压缩归档文件</p>

<pre><code>gzip/gunzip -&gt; .gz
f.tar.gz   -z
tar -czvf 
tar -xzvf

bzip/bunzip -&gt; .bz2
f.tar.bz2  -j

f.tar.lzma --lzma
f.tar.lzo
</code></pre>

<p>从归档中排除部分文件</p>

<pre><code>tar -cf arch.tar * --exclude &quot;*.txt&quot;
cat list
   filea
   fileb
tar -cf arch.tar * -X list
</code></pre>

<p>排除版本控制文件</p>

<pre><code>tar --exclude-vcs -czvvf source.tar.gz files
</code></pre>

<p>打印总字节数</p>

<pre><code>tar -cf arc.tar * --exclude &quot;*.txt&quot; --totals
</code></pre>

<h3 id="cpio">cpio</h3>

<p>使用频率不高</p>

<p>归档，保留文件属性（权限、所有权等）</p>

<pre><code>echo file1 file2 | cpio -ov &gt; archive.cpio
-o 指定输出
-v 打印归档文件列表
</code></pre>

<p>列出cpio中的文件内容</p>

<pre><code>cpio -it &lt; archive.cpio
-i指定输入
-t列出归档文件中的内容
</code></pre>

<h3 id="gzip">gzip</h3>

<p>压缩，会删除源文件</p>

<pre><code>gzip filename
#got filename.gz
</code></pre>

<p>解压</p>

<pre><code>gunzip filename.gz
</code></pre>

<p>列出文件属性信息</p>

<pre><code>gzip -l text.gz
</code></pre>

<p>stdin读入文件并写出到stdout</p>

<pre><code>cat file | gzip -c &gt; file.gz
</code></pre>

<p>压缩归档文件</p>

<pre><code>tar -czvvf archive.tar.gz [files]
or
tar -cvvf archive.tar.gz [files]
gzip archive.tar
</code></pre>

<p>指定压缩率</p>

<pre><code>1-9,1最低，但速度最快
gzip -9 test.img
</code></pre>

<h3 id="zcat">zcat</h3>

<p>无需解压缩，直接从.gz中提取内容</p>

<pre><code>zcat test.gz
</code></pre>

<h3 id="bzip">bzip</h3>

<p>更大的压缩率</p>

<pre><code>bzip2 filename
</code></pre>

<p>解压缩</p>

<pre><code>bunzip2 filename.bz2
</code></pre>

<p>stdin到stdout</p>

<pre><code>cat file &gt; bzip2 -c &gt; file.tar.bz2
</code></pre>

<p>压缩归档</p>

<pre><code>tar -cjvvf archive.tar.bz2 [files]
or
tar -cvvf archive.tar [files]
bzip2 archive.tar
</code></pre>

<p>保留输入文件</p>

<pre><code>bunzip2 test.bz2 -k
</code></pre>

<p>压缩率</p>

<pre><code>bzip2 -9 test.img
</code></pre>

<h3 id="lzma">lzma</h3>

<p>比gzip/bzip2更好的压缩率</p>

<p>压缩</p>

<pre><code>lzma filename
</code></pre>

<p>解压</p>

<pre><code>unlzma filename.lzma
</code></pre>

<p>stdin到stdout</p>

<pre><code>cat file | lzma -c &gt; file.lzma
</code></pre>

<p>创建归档</p>

<pre><code>tar -cavvf archive.tar.lzma [files]
    -xavf
</code></pre>

<p>保留输入文件</p>

<pre><code>lzma test.bz2 -k
</code></pre>

<p>压缩率</p>

<pre><code>lzma -9 test.img
</code></pre>

<h3 id="zip">zip</h3>

<p>压缩</p>

<pre><code>zip archive_name.zip [source files/dirs]
</code></pre>

<p>对目录和文件进行递归操作</p>

<pre><code>zip -r archive.zip folder1 file2
</code></pre>

<h3 id="base64">base64</h3>

<p>编码</p>

<pre><code>base64 filename &gt; outfile
cat file | base64 &gt; outfile
</code></pre>

<p>解码</p>

<pre><code>base64 -d file &gt; outfile
</code></pre>

<h3 id="md5sum-1">md5sum</h3>

<p>“md5sum”就是计算和检验MD5信息签名。 md5
checksum(通常叫做哈希)使用匹配或者验证文件的文件的完整性，因为文件可能因为传输错误，磁盘错误或者无恶意的干扰等原因而发生改变。</p>

<p>单向散列</p>

<pre><code>md5sum file
sha1sum file
</code></pre>

<h3 id="rsync">rsync</h3>

<p>可以对位于不同位置的文件和目录进行备份, 借助差异计算和压缩技术实现最小化数据传输量</p>

<p>要确保远端安装了 openssh</p>

<p>从一个目录复制到另一个目录</p>

<pre><code>rsync -av source_path dest_path
-a 进行归档  -v打印细节
路径可以使本地，也可以是远端路径

e.g.
rsync -av /home/test /home/backups/ #复制到backups目录下
rsync -av /home/test /home/backups  #创建backups目录, 复制
</code></pre>

<p>备份到远程服务器</p>

<pre><code>rsync -av source_path user@host:PATH
可以反向
</code></pre>

<p>改善传输速度</p>

<pre><code>rsync -avz source destination
</code></pre>

<p>排除文件</p>

<pre><code>rsync -avz source dest --exclude &quot;*.txt&quot;
                       --exclude-from FILEPATH
FILEPATH:
*.bak
</code></pre>

<p>更新备份时，删除不存在的文件</p>

<pre><code>rsync -avz source dest --delete
</code></pre>

<h3 id="git">git</h3>

<p>初始化目录</p>

<pre><code>git init
</code></pre>

<p>配置用户信息</p>

<pre><code>git config --global user.name &quot;wklken&quot;
git config --global user.email &quot;wklken@yeah.net&quot;
</code></pre>

<p>加到远端</p>

<pre><code>git remote add origin user@remotehost:/home/backup/backup.git
git push origin master
</code></pre>

<p>添加</p>

<pre><code>git add *
</code></pre>

<p>删除</p>

<pre><code>git rm *.py
</code></pre>

<p>标记一个检查点</p>

<pre><code>git commit -m &quot;Commit message&quot;
</code></pre>

<p>查看日志</p>

<pre><code>git log
</code></pre>

<p>回滚到某个版本</p>

<pre><code>git checkout hashid [ filename ]
</code></pre>

<p>克隆</p>

<pre><code>git clone url
</code></pre>

<h3 id="dd-1">dd</h3>

<p>Dtat Definiton, 要注意参数顺序, 错误的参数会损毁所有数据</p>

<p>可以用来转换和复制文件，大多数时间是用来复制iso文件(或任何其它文件)到一个usb设备(或任何其它地方)中去，所以可以用来制作USB启动器</p>

<p>语法说明</p>

<pre><code>dd if=SOURCE of=TARGET bs=BLOCK_SIZE count=COUNT
if/of  输入/输出文件或设备路径
bs块大小
count 限制复制到目标的字节数

dd if=/dev/zero of=/dev/sda1

#制作iso 从cdrom设备读取所有数据, 创建iso文件
dd if=/dev/cdrom of=cdrom.iso
</code></pre>

<p>备份恢复</p>

<pre><code>dd if=/dev/sda1 of=x.img

dd if=x.img of=/dev/sda1
</code></pre>

<h3 id="mount">mount</h3>

<p>mount 是一个很重要的命令，用来挂载不能自动挂载的文件系统。你需要root权限挂载设备。 在插入你的文件系统后，</p>

<pre><code>mount --bind /source /destination

首先运行”lsblk”命令，识别出你的设备，然后把分配的设备名记下来。
root@tecmint:~# lsblk
创建一个任何名字的目录，但是最好和引用相关。

root@tecmint:~# su
Password:
root@tecmint:~# cd /dev
root@tecmint:~# mkdir usb
现在将“sdb1”文件系统挂载到“usb”目录.
root@tecmint:~# mount /dev/sdb1 /dev/usb
</code></pre>

<p>挂载镜像</p>

<pre><code>mount -o loop file.img /mnt/mount_point
</code></pre>

<h2 id="网络相关">网络相关</h2>

<h3 id="ifconfig">ifconfig</h3>

<p>显示网络接口、子网掩码等详细信息</p>

<pre><code>ifconfig
/sbin/ifconfig
</code></pre>

<p>打印某个特定网络接口</p>

<pre><code>ifconfig iface_name

e.g.
ifconfig en1

HWaddr     MAC地址
inet addr  ip地址
Bcast      广播地址
Mask       子网掩码
</code></pre>

<p>设置网络接口ip</p>

<pre><code>ifconfig wlan0 192.168.0.80
</code></pre>

<p>dns</p>

<pre><code>cat /etc/resolv.conf

host google.com #Dns查找

nslookup google.com #更详细信息
</code></pre>

<p>修改dns/host</p>

<pre><code>echo nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf

echo ip domain &gt;&gt; /etc/hosts
</code></pre>

<p>ping</p>

<pre><code>ping www.baidu.com
</code></pre>

<p>路由信息</p>

<pre><code>显示路由表
route

以数字形式显示地址
route -n
</code></pre>

<p>设置默认网关</p>

<pre><code>route add default gw 192.168.0.1 wlan0
</code></pre>

<p>trace_route, 显示分组途径的所有网关的地址</p>

<pre><code>traceroute google.com
</code></pre>

<h3 id="ping">ping</h3>

<p>基本</p>

<pre><code>ping ADDRESS  #主机名，域名或ip
</code></pre>

<p>PING命令可以得到RTT(Round Trip Time), 分组从源到目的主机的往返时间, 单位ms</p>

<p>限制发送分组数</p>

<pre><code>ping ADDRESS -c COUNT

ping
</code></pre>

<h3 id="fping">fping</h3>

<p>同时ping一组ip, 而且响应非常快</p>

<pre><code>fping -a ip1 ip2 -g
fping -a 192.160.1/24 -g
fping -a &lt; ip.list

-a, 所有活动主机的ip
-g, 从IP/mask生成的ip地址范围
</code></pre>

<p>进行dns查询</p>

<pre><code>fping -a -d 2 &gt; /dev/null  &lt; ip.list
</code></pre>

<h3 id="lftp">lftp</h3>

<p>基本用法</p>

<pre><code>lftp username@ftphost
cd dir
lcd改变本地主机目录
mkdir 创建目录
get/put 下载上传
quit退出
</code></pre>

<h3 id="scp">scp</h3>

<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>

<p>linux的scp命令可以在linux服务器之间复制文件和目录.</p>

<p>拷贝文件</p>

<pre><code>scp filename user@remotehost:/home/pat
ip或主机名均可

scp SOURCE DESTINATION
</code></pre>

<p>递归复制</p>

<pre><code>scp -r dir1 user@remotehost:/home/backup
</code></pre>

<p>提高拷贝速度</p>

<pre><code>scp  -c arcfour -r -P20755 dir/ 192.168.2.*:/**/**/data/
-c arcfour 这个算法没有加校验不保证完整性，注意慎用，内网1000M带宽，默认算法速度只能达到30M/s，用arcfour这个算法速度可以达到50-80M/s
</code></pre>

<h3 id="ssh">SSH</h3>

<p>连接远程</p>

<pre><code>ssh username@remote_host

ssh -p port username@remote_host
</code></pre>

<p>执行命令</p>

<pre><code>ssh username@remote_host 'cmd1; cmd2' &gt; stdout.txt 2&gt;errors.txt
</code></pre>

<p>压缩功能</p>

<pre><code>ssh -C user@hostname 'cmds'
</code></pre>

<p>打通ssh</p>

<pre><code>1.创建SSH密钥
  ssh-keygen -t rsa
  公钥, ~/.ssh/id_rsa.pub
2.登陆远端服务器, 将公钥写入 ~/.ssh/authorized_keys
</code></pre>

<h3 id="lsof">lsof</h3>

<p>列出系统中开放端口及运行在端口上的服务</p>

<pre><code>lsof -i
</code></pre>

<p>配合grep, 获取需要的信息</p>

<h3 id="netstat">netstat</h3>

<p>查看开放端口和服务</p>

<pre><code>netstat -tnp
</code></pre>

<h2 id="磁盘和系统">磁盘和系统</h2>

<h3 id="du">du</h3>

<p>du = disk usage</p>

<p>估计文件的空间占用。 逐层统计文件（例如以递归方式）并输出摘要。</p>

<p>查看占用磁盘空间</p>

<pre><code>du FILENAME1 FILENAME2
</code></pre>

<p>查看目录</p>

<pre><code>du -a dir
</code></pre>

<p>以KB,MB或块为单位展示</p>

<pre><code>du -h FILENAME1
</code></pre>

<p>显示总计情况</p>

<pre><code>du -c FILENAME1
</code></pre>

<p>只显示合计</p>

<pre><code>du -s FILENAME1
</code></pre>

<p>以特定单位打印</p>

<pre><code>du -b/-k/-m/-B FILES
</code></pre>

<p>排除部分文件</p>

<pre><code>du --exclude &quot;*.txt&quot; DIR
   --exclude-from EXCLUDE.txt DIR
</code></pre>

<p>指定最深层级</p>

<pre><code>du --max-depth 2 DIR
</code></pre>

<p>指定目录最大的10个文件</p>

<pre><code>du -ak S_DIR | sort -nrk 1 | head
</code></pre>

<h3 id="df">df</h3>

<p>df = disk free</p>

<p>报告系统的磁盘使用情况。在跟踪磁盘使用情况方面对于普通用户和系统管理员都很有用。 ‘df‘ 通过检查目录大小工作，但这一数值仅当文件关闭时才得到更新。</p>

<p>查看磁盘可用空间</p>

<pre><code>df
df -h
</code></pre>

<h3 id="time">time</h3>

<p>计算命令执行时间</p>

<pre><code>time COMMAND

real 挂钟时间, 从开始执行到结束的时间
user 进程花费在用户模式中的cpu时间, 真正用于执行进程所花得时间
sys  进程花费在内核模式中的cpu时间
</code></pre>

<p>写入文件</p>

<pre><code>time -o output.txt COMMAND
time -a output.txt COMMAND #追加
</code></pre>

<p>格式化输出</p>

<pre><code>time -f &quot;Time: %U&quot;  -a -o timing.log uname
real %e
user %U
sys %S
</code></pre>

<h3 id="who">who</h3>

<p>获取当前用户登陆信息</p>

<pre><code>who / w
</code></pre>

<p>当前登陆主机的用户列表</p>

<pre><code>users
</code></pre>

<h3 id="uptime">uptime</h3>

<p>查看系统已经通电运行多长时间了</p>

<pre><code>uptime
#也可以看到负载
</code></pre>

<h3 id="last">last</h3>

<p>显示上次用户登录信息- 前一次启动会话信息</p>

<pre><code>last
</code></pre>

<p>获取单个用户</p>

<pre><code>last USER
</code></pre>

<h3 id="watch">watch</h3>

<p>在终端中以固定间隔监视命令输出</p>

<pre><code>#default 2s
watch ls

# 5s
watch -n 5 ls
</code></pre>

<p>颜色标示</p>

<pre><code>watch -d 'COMMAND'
</code></pre>

<h2 id="进程和线程">进程和线程</h2>

<h3 id="ps">ps</h3>

<p>ps命令给出正在运行的某个进程的状态，每个进程有特定的id成为PID。</p>

<p>ps命令主要查看系统中进程的状态</p>

<pre><code>USER              PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
USER表示启动进程用户
PID表示进程标志号

%CPU表示运行该进程占用CPU的时间与该进程总的运行时间的比例
%MEM表示该进程占用内存和总内存的比例。

VSZ表示占用的虚拟内存大小，以KB为单位。
RSS为进程占用的物理内存值，以KB为单位。

TTY表示该进程建立时所对应的终端，&quot;?&quot;表示该进程不占用终端。
STAT表示进程的运行状态，包括以下几种代码：
    D，不可中断的睡眠；
    R，就绪（在可运行队列中）；
    S，睡眠；
    T，被跟踪或停止；
    Z，终止（僵死）的进程，Z不存在，但暂时无法消除；
    W，没有足够的内存分页可分配；&lt;高优先序的进程；
    N，低优先序的进程；
    L，有内存分页分配并锁在内存体内（实时系统或I/O）。

START为进程开始时间。
TIME为执行的时间。
COMMAND是对应的命令名。
</code></pre>

<p>查看进程信息</p>

<pre><code>#当前终端
ps

PID TTY TIME CMD
PID  进程ID
TTY  终端
TIME 进程启动后过去的时间
CMD  进程对应的命令
</code></pre>

<p>显示更多信息</p>

<pre><code>#当前终端
ps -f
</code></pre>

<p>查看所有进程</p>

<pre><code>ps aux
ps -ef
</code></pre>

<p>查看某个用户的所有进程</p>

<pre><code>ps U ken
</code></pre>

<p>命令格式</p>

<pre><code>ps [OTHER OPTIONS] -o par1,par2,par3
ps -eo comm,pcpu | head
pmem 内存使用率，comm可执行文件名,user启动进程的用户,etime启动后度过的时间
</code></pre>

<p>设置升序降序</p>

<pre><code>ps -eo comm,pcpu --sort -pcpu | head
+升序，-降序
</code></pre>

<p>找出给定命令名对应进程ID</p>

<pre><code>ps -C COMMAND_NAME
ps -C bash -o pid=
</code></pre>

<p>进程线程相关</p>

<pre><code>ps -eLf --sort -nlwp | head
</code></pre>

<p>查看子进程树</p>

<pre><code>ps axwef
</code></pre>

<p>注意：当你要知道有哪些进程在运行或者需要知道想杀死的进程PID时ps命令很管用。你可以把它与‘grep‘合用来查询指定的输出结果，例如：</p>

<pre><code># ps -A | grep -i ssh
</code></pre>

<h3 id="pgrep-1">pgrep</h3>

<p>pgrep只需要命令名的一部分, ps需要准确的全名</p>

<p>基本用法</p>

<pre><code>pgrep bash
</code></pre>

<p>指定进程的用户</p>

<pre><code>pgrep -u root,slynux COMMAND
</code></pre>

<p>返回匹配进程数</p>

<pre><code>pgrep -c COMANND
</code></pre>

<h3 id="top">top</h3>

<p>查看占用cpu最多的进程列表</p>

<pre><code>top
</code></pre>

<h3 id="kill">kill</h3>

<p>kill是用来杀死已经无关紧要或者没有响应的进程,杀死一个进程需要知道进程的PID</p>

<p>列出可用信号</p>

<pre><code>kill -l
</code></pre>

<p>终止一个进程</p>

<pre><code>kill PROCESS_ID_LIST
</code></pre>

<p>强杀进程</p>

<pre><code>kill -9 PROCESS_ID
</code></pre>

<p>杀死一组命令</p>

<pre><code>killall process_name
killall -9 process_name

指定用户
killall -u USERNAME process_name
</code></pre>

<h3 id="pkill">pkill</h3>

<p>杀，接受进程名</p>

<pre><code>pkill process_name
pkill -s SIGNAL process_name
</code></pre>

<h3 id="which">which</h3>

<p>查找PATH下某个命令位置</p>

<pre><code>which ls
</code></pre>

<h3 id="whereis">whereis</h3>

<p>whereis的作用是用来定位命令的二进制文件\资源\或者帮助页.举例来说,获得ls和kill命令的二进制文件/资源以及帮助页:</p>

<pre><code>whereis ls
whereis kill
</code></pre>

<p>类似which，多了命令手册位置，源代码位置</p>

<p>注意:当需要知道二进制文件保存位置时有用.</p>

<h3 id="file-1">file</h3>

<p>确定文件类型</p>

<h3 id="whatis">whatis</h3>

<p>对命令的简短描述</p>

<h3 id="hostname">hostname</h3>

<p>当前主机名</p>

<h3 id="uname">uname</h3>

<pre><code>主机名
uname -n

#内核版本，硬件架构等
uname -a

#内核发行版本
uname -r

主机类型(32位/64位)
uname -m

cpu相关信息
cat /proc/cpuinfo

内存信息
cat /proc/meminfo
</code></pre>

<p>例子</p>

<pre><code>#uname -a
Linux tecmint 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i686 i686 GNU/Linux

1. “Linux“: 机器的内核名
2. “tecmint“: 机器的分支名
3. “3.8.0-19-generic“: 内核发布版本
4. “#30-Ubuntu SMP“: 内核版本
5. “i686“: 处理器架构
6. “GNU/Linux“: 操作系统名
</code></pre>

<h3 id="crontab">crontab</h3>

<p>格式</p>

<pre><code>* * * * * cmd
分钟(0-59)，小时(0-23)，天(1-31)，月份(1-12)，工作日(0-6)

A,B  A and B
*/C  every C
</code></pre>

<p>查看</p>

<pre><code>crontab -l
crontab -l -u slynux
</code></pre>

<p>编辑</p>

<pre><code>crontab -e
</code></pre>

<p>移除</p>

<pre><code>crontab -r
crontab -u slynux -r
</code></pre>

<p>可以在crontab 中加入环境变量</p>

<h3 id="getopts">getopts</h3>

<p>命令行参数处理</p>

<pre><code>while getopts :f:vql opt
do
    case $opt in
    f)  file=$OPTARG
        ;;
    v)  verbose=true
        ;;
    ....
</code></pre>

<h3 id="history">history</h3>

<p>“history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史</p>

<pre><code>history
</code></pre>

<p>注意：按住“CTRL + R”就可以搜索已经执行过的命令，它可以你写命令时自动补全</p>

<h3 id="sudo">sudo</h3>

<p>“sudo”(super user do)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p>

<p>注意：sudo 允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。
并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事，这就是为什么在linux社区流行一句话：</p>

<p>“To err is human, but to really foul up everything, you need root password.”
“人非圣贤孰能无过，但是拥有root密码就真的万劫不复了。”</p>

<h3 id="cal">cal</h3>

<p>“cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份</p>

<pre><code>cal
cal 02 1835
</code></pre>

<h3 id="cp">cp</h3>

<p>“copy”就是复制。它会从一个地方复制一个文件到另外一个地方</p>

<pre><code>cp file1 file2
cp -r dir1 dir2
</code></pre>

<p>快速备份一个文件：</p>

<pre><code>cp some_file_name{,.bkp}
</code></pre>

<p>注意： cp，在shell脚本中是最常用的一个命令，而且它可以使用通配符（在前面一块中有所描述），来定制所需的文件的复制。</p>

<h3 id="mv">mv</h3>

<p>“mv”命令将一个地方的文件移动到另外一个地方去。</p>

<p>“mv”命令将一个地方的文件移动到另外一个地方去。</p>

<h3 id="pwd">pwd</h3>

<p>“pwd”（print working directory），在终端中显示当前工作目录的全路径。</p>

<p>注意： 这个命令并不会在脚本中经常使用，但是对于新手，当从连接到nux很久后在终端中迷失了路径，这绝对是救命稻草。</p>

<h3 id="free">free</h3>

<pre><code>free -m
             total       used       free     shared    buffers     cached
Mem:          7982       6811       1171          0        350       5114
-/+ buffers/cache:       1346       6636
Swap:        16935         11      16924
</code></pre>

<p>显示剩余内存</p>

<pre><code>free -m | grep cache | awk '/[0-9]/{ print $4&quot; MB&quot; }'
</code></pre>

<p>在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.</p>

<p>一些简单的计算方法：</p>

<p>物理已用内存 = 实际已用内存 - 缓冲 - 缓存 = 6811M - 350M - 5114M</p>

<p>物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 + 缓存</p>

<p>应用程序可用空闲内存 = 总物理内存 - 实际已用内存</p>

<p>应用程序已用内存 = 实际已用内存 - 缓冲 - 缓存</p>

<p>原始解释：转至互联网：
Linux的基本原则是没有资源应该被浪费.因此核心会使用尽可能多的RAM,来缓存来自本地和远程的文件系统的信息.系统做读写操作的时候,会将与当前运行的进程相关的数据尽量存储在RAM里.系统报告的缓存是缓冲和页缓存两者之和.缓存并不是在进程结束的时候被回收(你可能很快会启动另外一个进程,需要同样的数据),而是随需回收–比如,当你启动一个需要大量内存的进程时,Linux核心会从内存中回收缓存,将得到的内存分配给新的进程.</p>

<p>有些区域,比如匿名内存映射(mmps)和共享内存区域,它们被报告为缓存,但不是被核心直接释放.一般的缓存不映射到进程的地址空间,仅仅是简单的核心映射,而这些特别的缓存映射到所有挂接到它们上面的进程.</p>

<h3 id="eval">eval</h3>

<pre><code>eval &quot;ls -l&quot;
</code></pre>

<h3 id="basename">basename</h3>

<p>获取路径中文件部分</p>

<pre><code>basename resolv.conf #resolv.conf
basename /etc/resolv.conf # resolv.conf
</code></pre>

<h3 id="cmp">cmp</h3>

<p>比较两个任意类型的文件并将结果输出至标准输出。如果两个文件相同， ‘cmp‘默认返回0；如果不同，将显示不同的字节数和第一处不同的位置。</p>

<pre><code>cmp file1 file2
diff file1 file2
</code></pre>

<h3 id="rm">rm</h3>

<p>‘rm’ 标准移除命令。 rm 可以用来删除文件和目录</p>

<pre><code>rm file1
rm -r dir1  #递归删除空目录
</code></pre>

<p>强删</p>

<pre><code>rm -rf fileordir
</code></pre>

<p>警告: ”rm -rf” 命令是一个破坏性的命令,假如你不小心删除一个错误的目录。 一旦你使用’rm -rf’
删除一个目录,在目录中所有的文件包括目录本身会被永久的删除,所以使用这个命令要非常小心。</p>

<h3 id="service">service</h3>

<p>‘service‘命令控制服务的启动、停止和重启，它让你能够不重启整个系统就可以让配置生效以开启、停止或者重启某个服务。</p>

<p>注意：要想使用service命令，进程的脚本必须放在‘/etc/init.d‘，并且路径必须在指定的位置。 如果要运行“service apache2
start”实际上实在执行“service /etc/init.d/apache2 start”.</p>

<h3 id="man">man</h3>

<p>‘man‘是系统帮助页。Man提供命令所有选项及用法的在线文档。几乎所有的命令都有它们的帮助页</p>

<pre><code>man thecommand
</code></pre>

<p>注意：系统帮助页是为了命令的使用和学习而设计的。</p>

<h3 id="passwd">passwd</h3>

<p>这是一个很重要的命令，在终端中用来改变自己密码很有用。显然的，因为安全的原因，你需要知道当前的密码。</p>

<h3 id="gcc">gcc</h3>

<p>gcc 是Linux环境下C语言的内建编译器。下面是一个简单的C程序，在桌面上保存为Hello.c （记住必须要有‘.c‘扩展名</p>

<pre><code>gcc Hello.c
./a.out
gcc -o Hello Hello.c
./Hello
</code></pre>

<p>注意: 编译C程序时，输出会自动保存到一个名为“a.out”的新文件，因此每次编译C程序 “a.out”都会被修改。
因此编译期间最好定义输出文件名.，这样就不会有覆盖输出文件的风险了。</p>

<h3 id="g">g++</h3>

<p>g++是C++的内建编译器</p>

<pre><code>g++ Add.cpp
./a.out
g++ -o Add Add.cpp
./Add
</code></pre>

<h3 id="java">java</h3>

<p>Java 是世界上使用最广泛的编程语言之一. 它也被认为是高效, 安全和可靠的编程语言. 现在大多数基于网络的服务都使用Java实现.</p>

<pre><code>javac tecmint.java
java tecmint
</code></pre>

<p>注意: 几乎所有的Linux发行版都带有gcc编译器, 大多数发行版都内建了g++ 和 java 编译器, 有些也可能没有. 你可以用apt 或 yum
安装需要的包.</p>

<h3 id="关于-dev-null">关于/dev/null</h3>

<p>特别有用的特殊文件，位桶，传送到此文件的数据都会被系统丢弃。</p>

<h3 id="语言及乱码">语言及乱码</h3>

<p>查看变量值</p>

<pre><code>echo $LANG   未设置任何LC_XXX时使用的默认值
echo $LC_ALL 覆盖所有LC_XXX变量，总控开关
</code></pre>

<p>好的做法是，避免为任何LC_XXX变量赋值，使用LC_ALL和LANG来控制</p>

<p>避免乱码：从编辑器到语言，再到系统，统一编码为UTF-8</p>

<h3 id="shell的版本">shell的版本</h3>

<pre><code>bash --version
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>