<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell脚本之路 | 开发者问答集锦</title>
    <meta property="og:title" content="shell脚本之路 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell脚本之路">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E8%84%9A%E6%9C%AC%E4%B9%8B%E8%B7%AF/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell脚本之路</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="shell分类">shell分类</h2>

<ul>
<li><p>Bourne Shell（/usr/bin/sh或/bin/sh）</p></li>

<li><p>Bourne Again Shell（/bin/bash）</p></li>

<li><p>C Shell（/usr/bin/csh）</p></li>

<li><p>K Shell（/usr/bin/ksh）</p></li>

<li><p>Shell for Root（/sbin/sh）</p></li>
</ul>

<p>注意：</p>

<pre><code>1. 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。
2. #!告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序
</code></pre>

<h2 id="shell脚本的编写">shell脚本的编写</h2>

<ol>
<li><p>创建shell文本</p>

<h1 id="查看linux系统中shell位置-cat-etc-shells-cat-etc-shell">查看linux系统中shell位置：cat /etc/shells ||  cat /etc/shell</h1>

<p>/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh<br />
/usr/bin/bash //常用
/usr/sbin/nologin
/bin/tcsh
/bin/csh //c语言风格</p>

<h1 id="创建shell脚本文件">创建shell脚本文件</h1>

<p>vi/vim fileName.sh</p></li>

<li><p>shell脚本书写格式</p>

<p>#!/bin/bash
echo &ldquo;Hello World !&rdquo;</p>

<p>注: shell中变量赋值没有空格，输出变量时，格式为echo $variableName</p></li>

<li><p>shell脚本赋予执行权限</p>

<p>chmod +x ./test.sh  #使脚本具有执行权限</p></li>

<li><p>执行命令</p>

<h1 id="方法一">方法一</h1>

<p>./test.sh 或 .test.sh  #执行脚本</p>

<h1 id="方法二-适用于其他路径执行shell脚本">方法二(适用于其他路径执行shell脚本)</h1>

<p>/bin/bash /study/shell_study/my_first.sh</p>

<h1 id="方法三-在当前进程中运行-shell-脚本">方法三(在当前进程中运行 Shell 脚本)</h1>

<p>source filename 或者 . filename
或
bash /study/shell_study/my_second.sh
注：</p>

<h1 id="在新进程中运行-shell-脚本">在新进程中运行 Shell 脚本</h1>

<p>bash test.sh</p>

<h1 id="在当前进程中运行-shell-脚本">在当前进程中运行 Shell 脚本</h1>

<p>. ./test.sh</p>

<p>备注：
    1.作为解释器参数这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名， 如：
        /bin/sh test.sh
        /bin/php test.php
    2.循环linux下的目录时，注意引号&rdquo;&lsquo;&ldquo;,使用&rdquo;`&ldquo;。
    3.注意变了输出 $name 或者 ${name}</p>

<pre><code>linux中查看当前进程pid命令: echo $$
</code></pre></li>
</ol>

<p>5.shell命令</p>

<ul>
<li><p>readyonly,只读模式。</p>

<p>#!/bin/bash
myUrl=&ldquo;<a href="http://www.google.com&quot;">http://www.google.com&quot;</a>
readonly myUrl</p></li>

<li><p>unset,删除变量。注:unset 命令不能删除只读变量。</p>

<p>#!/bin/sh
myUrl=&ldquo;<a href="http://www.runoob.com&quot;">http://www.runoob.com&quot;</a>
unset myUrl
echo $myUrl</p></li>

<li><p>获取字符串长度</p>

<p>#!/bin/sh
string=&ldquo;<a href="http://www.runoob.com&quot;">http://www.runoob.com&quot;</a>
echo ${#string}</p></li>

<li><p>截取字符串</p>

<p>#!/bin/bash
string=&ldquo;<a href="http://www.runoob.com&quot;">http://www.runoob.com&quot;</a>
echo ${string:1:4} #截取字符串1-4位</p>

<ul>
<li>字符串截取总结
    格式                                  说明
${string: start :length}    从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。
${string: start}            从 string 字符串的左边第 start 个字符开始截取，直到最后。
${string: 0-start :length}  从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。
${string: 0-start}          从 string 字符串的右边第 start 个字符开始截取，直到最后。
${string#*chars}            从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。
${string##*chars}           从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。
${string%*chars}            从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。
${string%%*chars}           从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。
<br /></li>
</ul></li>

<li><p>查找子字符串</p>

<p>string=&ldquo;runoob is a great site&rdquo;
echo <code>expr index &quot;$string&quot; io</code>  # 输出 4</p>

<p>注:
    1.截取字符串与调用命令分别：${string:start:length},$(&lsquo;command&rsquo;);
    2.从右边开始截取${string:0-start:length}
    3.从指定字符串开始截取 ${string#*start_string}
    4.直到最后一个指定字符（子字符串）再匹配结束 ${string##*start_string}</p></li>

<li><p>字符串拼接</p>

<p>eg:
    #! /bin/bash
    str1=&lsquo;china&rsquo;
    str2=&lsquo;广东&rsquo;
    str3=&lsquo;广州&rsquo;
    str4=&lsquo;白云区&rsquo;
    str5=&lsquo;番禺区&rsquo;
    str6=&lsquo;腾讯大厦&rsquo;</p>

<pre><code>str_new1=$str1$str2
str_new2=&quot;$str2 $str3&quot;
str_new3=$str4&quot;:&quot;$str5
str_new4=&quot;$str5:$str6&quot;
str_new5=&quot;${str1} test: ${str2} index.html&quot;

echo $str_new1
echo $str_new2
echo $str_new3
echo $str_new4
echo $str_new5
</code></pre>

<p>结果：
    [root@localhost shell_study]# bash string_merge.sh
    china广东
    广东 广州
    白云区:番禺区
    番禺区:腾讯大厦
    china test: 广东 index.html</p></li>

<li><p>数组定义</p>

<p>数组名=(值1 值2 &hellip; 值n)</p>

<p>如：
    array_name=(value0 value1 value2 value3)
        或者
    array_name=(
    value0
    value1
    value2
    value3
    )</p>

<p>还可以单独定义数组的各个分量：
    array_name[0]=value0
    array_name[1]=value1
    array_name[n]=valuen</p></li>
</ul>

<blockquote>
<p>读取</p>
</blockquote>

<pre><code>读取数组元素值的一般格式:
${数组名[下标]}

使用 @ 或者 * 符号可以获取数组中的所有元素
echo ${array_name[@]}
</code></pre>

<ul>
<li><p>获取数组长度</p>

<h1 id="取得数组元素的个数">取得数组元素的个数</h1>

<p>length=${#array_name[@]}
或者
length=${#array_name[*]}</p>

<h1 id="取得数组单个元素的长度">取得数组单个元素的长度</h1>

<p>length=${#array_name[n]}</p></li>

<li><p>拼接数组</p>

<p>array_new=(${arr[@]} ${array[*]})</p>

<p>eg:
    arr=(1 2 &lsquo;test&rsquo;)
    array=(&lsquo;zhang&rsquo; &lsquo;li&rsquo; &lsquo;wang&rsquo;)
    arr_new=(${arr[<em>]} ${array[@]})
    #获取拼接的数组
    echo ${arr_new[</em>]}
结果:
    [root@localhost shell_study]# bash arr_merge.sh
    1 2 test zhang li wang</p></li>

<li><p>删除数组</p>

<p>删除数组中的元素
unset array_new[index]</p>

<p>删除全部元素
unset array_new</p>

<p>eg:
    #! /bin/bash
    arr_del=(&lsquo;test&rsquo; &lsquo;new&rsquo; &lsquo;hello&rsquo;)
    unset arr_del[0]
    echo ${arr_del[*]}
    unset arr_del
    echo ${arr_del[@]}
结果:
    [root@localhost shell_study]# bash arr_del.sh
    new hello</p></li>

<li><p>注释</p></li>
</ul>

<blockquote>
<p>单行注释</p>
</blockquote>

<pre><code>#--------------------------------------------
# 这是一个注释
# author：t_fengyun
# site：www.51about.com
# slogan：个人博客
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
# 
#
##### 用户配置区 结束  #####
</code></pre>

<blockquote>
<p>多行注释</p>
</blockquote>

<pre><code>:&lt;
</code></pre>

<blockquote>
<p>代码多行备注</p>
</blockquote>

<pre><code>代码中多行代码需要注释断点并进行测试,要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。
</code></pre>

<ul>
<li>参数的传递</li>
</ul>

<blockquote>
<p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2
为执行脚本的第二个参数，以此类推……</p>
</blockquote>

<pre><code>#!/bin/bash
echo &quot;Shell 传递参数实例！&quot;;
echo &quot;执行的文件名：$0&quot;;
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
</code></pre>

<blockquote>
<p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：</p>
</blockquote>

<pre><code>$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
</code></pre>

<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>

<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。如&rdquo;$*“用「”」括起来的情况、以&rdquo;$1 $2 … $n&rdquo;的形式输出所有参数。</td>
</tr>

<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>

<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>

<tr>
<td>$@</td>
<td>与 ∗ 相 同 ， 但 是 使 用 时 加 引 号 ， 并 在 引 号 中 返 回 每 个 参 数 。 如 &ldquo;</td>
</tr>
</tbody>
</table>

<p>*相同，但是使用时加引号，并在引号中返回每个参数。如&rdquo; ∗相同，但是使用时加引号，并在引号中返回每个参数。如&rdquo;@“用「”」括起来的情况、以&rdquo;$1&rdquo; “ 2
&ldquo; … &rdquo; 2&rdquo; … &ldquo; 2&rdquo;…&rdquo;n” 的形式输出所有参数。<br />
$- | 显示Shell使用的当前选项，与set命令功能相同<br />
$? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p>

<pre><code>#!/bin/bash

val=`expr 2 + 2`
echo &quot;两数之和为 : $val&quot;

a=10
b=20

val=`expr $a + $b`
echo &quot;a + b : $val&quot;
</code></pre>

<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>

<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $a + $b</code> 结果为 30。</td>
</tr>

<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $a - $b</code> 结果为 -10。</td>
</tr>

<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $a \* $b</code> 结果为 200。</td>
</tr>

<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $b / $a</code> 结果为 2。</td>
</tr>

<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $b % $a</code> 结果为 0。</td>
</tr>

<tr>
<td>=</td>
<td>赋值</td>
<td>a=$b 将把变量 b 的值赋给 a。</td>
</tr>

<tr>
<td>==</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td>[ $a == $b ] 返回 false。</td>
</tr>

<tr>
<td>!=</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td>[ $a != $b ] 返回 true</td>
</tr>
</tbody>
</table>

<pre><code>val=`expr $b % $a`
echo &quot;b % a : $val&quot;

if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
fi
</code></pre>

<ul>
<li><p>shell其他</p>

<ul>
<li>将命令的结果赋值给变量
variable=<code>test.sh</code>
variable=$(test.sh)
<br /></li>
</ul>

<p>eg:
#! /bin/bash
variable=$(cat variable_first.sh)
echo $variable
variable_second=<code>cat variable_second.sh</code>
echo $variable_second</p>

<ul>
<li><p>删除变量unset
unset variable
eg:
myUnset=&lsquo;unset&rsquo;
echo $myUnset</p></li>

<li><p>变量分类:全局变量,局部变量，环境变量
注：1.shell中变量都默认为全局变量，要想变成局部变量，使用local。
2.进入子进程，执行bash。退出子进程，执行exit。
3.进程类似于windows下一个应用窗口就是一个进程，进程是互不相干扰的。
4.导出环境变量export，通过 export 导出的环境变量只对当前 Shell 进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。</p></li>
</ul></li>

<li><p>shell命令替换(重点)</p>

<p>命令:
variable=<code>command</code>或者variable=$(command)
注:多个命令之间用&rsquo;;&lsquo;隔开</p></li>

<li><p>shell特殊参数和参数位置</p>

<p>eg:
#!/bin/bash
echo &ldquo;Language: $1&rdquo;
echo &ldquo;URL: $2&rdquo;</p>

<p>运行test.sh：
[mozhiyan@localhost ~]$ cd demo
[mozhiyan@localhost demo]$ . ./test.sh Shell <a href="http://c.baidu.net/shell/">http://c.baidu.net/shell/</a>
Language: Shell
URL: <a href="http://c.biancheng.net/shell/">http://c.biancheng.net/shell/</a></p>

<p>eg1:
#!/bin/bash
#定义函数
function func(){
    echo &ldquo;Language: $1&rdquo;
    echo &ldquo;URL: $2&rdquo;
}
#调用函数
func C++ <a href="http://c.biancheng.net/cplus/">http://c.biancheng.net/cplus/</a></p>

<p>运行test.sh:
[mozhiyan@localhost ~]$ cd demo
[mozhiyan@localhost demo]$ . ./test.sh
Language: C++
URL: <a href="http://c.biancheng.net/cplus/">http://c.biancheng.net/cplus/</a></p>

<p>特殊参数
变量            |           说明
&mdash;&mdash;&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
$0          | 当前脚本的文件名
$n(n≥1)         | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。
$#              | 传递给脚本或函数的参数个数
$*              | 传递给脚本或函数的所有参数。
$@              | 传递给脚本或函数的所有参数。当被双引号&rdquo; &ldquo;包含时，$@ 与 $* 稍有不同<br />
$?              | 上个命令的退出状态，或函数的返回值<br />
$$              | 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID
注释：</p></li>

<li><p>备注</p>

<ul>
<li><p>$()与`<code>针对数学计算的使用
1.使用shell自带的函数时,$(expr $($1 + $2)) 或者</code>expr $1 + $2`
2.注意数学计算时，参数之间的间隔</p></li>

<li><p>shell脚本转义
echo &ldquo;print each param from \&rdquo;\$<em>\&ldquo;&rdquo; 注：转义使用\&rdquo;\$</em>&ldquo;</p></li>

<li><p>$<em>与$@都是打印传递给脚本或者函数的所有参数，但是在双引号中，两者有着本质区别，&rdquo;$</em>&rdquo;&ldquo;的循环次数要比&rdquo;$@&ldquo;少</p></li>

<li><p>shell脚本中字符串可以用“”或者&rdquo;包裹使用,也可以不带引号的使用
eg:
#! /bin/bash</p>

<p>a=test
echo $a</p>

<p>结果：
[root@localhost shell_study]# bash string.sh
test</p></li>
</ul></li>

<li><p>shell的内置命令和外部命令</p>

<ul>
<li>bash shell内置命令汇总
命令                  说明</li>

<li><p>扩展参数列表，执行重定向操作
.               读取并执行指定文件中的命令（在当前 shell 环境中）
alias           为指定命令定义一个别名
bg              将作业以后台模式运行
bind            将键盘序列绑定到一个 readline 函数或宏
break           退出 for、while、select 或 until 循环
builtin         执行指定的 shell 内建命令
caller          返回活动子函数调用的上下文
cd              将当前目录切换为指定的目录
command         执行指定的命令，无需进行通常的 shell 查找
compgen         为指定单词生成可能的补全匹配
complete        显示指定的单词是如何补全的
compopt         修改指定单词的补全选项
continue        继续执行 for、while、select 或 until 循环的下一次迭代
declare         声明一个变量或变量类型。
dirs            显示当前存储目录的列表
disown          从进程作业表中刪除指定的作业
echo            将指定字符串输出到 STDOUT
enable          启用或禁用指定的内建shell命令
eval            将指定的参数拼接成一个命令，然后执行该命令
exec            用指定命令替换 shell 进程
exit            强制 shell 以指定的退出状态码退出
export          设置子 shell 进程可用的变量
fc              从历史记录中选择命令列表
fg              将作业以前台模式运行
getopts         分析指定的位置参数
hash            查找并记住指定命令的全路径名
help            显示帮助文件
history         显示命令历史记录
jobs            列出活动作业
kill            向指定的进程 ID(PID) 发送一个系统信号
let             计算一个数学表达式中的每个参数
local           在函数中创建一个作用域受限的变量
logout          退出登录 shell
mapfile         从 STDIN 读取数据行，并将其加入索引数组
popd            从目录栈中删除记录
printf          使用格式化字符串显示文本
pushd           向目录栈添加一个目录
pwd             显示当前工作目录的路径名
read            从 STDIN 读取一行数据并将其赋给一个变量
readarray       从 STDIN 读取数据行并将其放入索引数组
readonly        从 STDIN 读取一行数据并将其赋给一个不可修改的变量
return          强制函数以某个值退出，这个值可以被调用脚本提取
set             设置并显示环境变量的值和 shell 属性
shift           将位置参数依次向下降一个位置
shopt           打开/关闭控制 shell 可选行为的变量值
source          读取并执行指定文件中的命令（在当前 shell 环境中）
suspend         暂停 Shell 的执行，直到收到一个 SIGCONT 信号
test            基于指定条件返回退出状态码 0 或 1
times           显示累计的用户和系统时间
trap            如果收到了指定的系统信号，执行指定的命令
type            显示指定的单词如果作为命令将会如何被解释
typeset         声明一个变量或变量类型。
ulimit          为系统用户设置指定的资源的上限
umask           为新建的文件和目录设置默认权限
unalias         刪除指定的别名
unset           刪除指定的环境变量或 shell 属性
wait            等待指定的进程完成，并返回退出状态码</p></li>

<li><p>使用type命令检测是否shell内置命令
[root@localhost ~]# type cd
cd is a Shell builtin
[root@localhost ~]# type ifconfig
ifconfig is /sbin/ifconfig</p></li>

<li><p>alias&amp;&amp; unalias 给命令创建(删除)别名,格式alias new_name=&lsquo;command&rsquo;
eg:
关机命令:
alias myShutdown=&lsquo;shutdown -h now&rsquo;</p></li>

<li><p>read 读取键盘输入
read命令格式:read [-options] [variables]</p></li>
</ul>

<p>read相关参数
        选项              说明
    -a array        把读取的数据赋值给数组 array，从下标 0 开始。
    -d delimiter    用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。
    -e              在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。
    -n num          读取 num 个字符，而不是整行字符。
    -p prompt       显示提示信息，提示内容为 prompt。
    -r              原样读取（Raw mode），不把反斜杠字符解释为转义字符。
    -s              静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。
    -t seconds      设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。
    -u fd           使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。
eg:
#! /bin/bash</p>

<p>read -p &ldquo;enter params:&rdquo; name url total
echo &ldquo;网站名: $name&rdquo;
echo &ldquo;网站地址: $url&rdquo;
echo &ldquo;网站访问量: $total&rdquo;</p>

<p>结果:
[root@localhost shell_study]# bash read_info.sh
enter params:自学网 51about.com 1000
网站名: 自学网
网站地址: 51about.com
网站访问量: 1000</p>

<ul>
<li><p>exit退出当前进程，$?查看退出当前进程状态</p></li>

<li><p>declare 和 typeset(废弃)：设置变量属性
declare命令格式:declare [+/-] [aAfFgilprtux] [变量名=变量值]
其中，-表示设置属性，+表示取消属性，aAfFgilprtux都是具体的选项，它们的含义如下表所示:
    选项                  含义
-f [name]           列出之前由用户在脚本中定义的函数名称和函数体。
-F [name]           仅列出自定义函数名称。
-g name             在 Shell 函数内部创建全局变量。
-p [name]           显示指定变量的属性和值。
-a name             声明变量为普通数组。
-A name             声明变量为关联数组（支持索引下标为字符串）。
-i name             将变量定义为整数型。
-r name[=value]     将变量定义为只读（不可修改和删除），等价于 readonly name。
-x name[=value]     将变量设置为环境变量，等价于 export name[=value]。</p></li>
</ul>

<p>eg:
#! /bin/bash</p>

<p>declare -a arr array result
arr=(1 2 3 4 5)
array=(&lsquo;aa&rsquo; &lsquo;bb&rsquo; &lsquo;cc&rsquo;)</p>

<p>result=(${arr[<em>]} ${array[</em>]})
echo ${result[@]}</p>

<p>结果：
[root@localhost shell_study]# bash string_declare.sh
1 2 3 4 5 aa bb cc</p>

<ul>
<li><p>逻辑运算时，注意如下
[root@localhost shell_study]# a=100
[root@localhost shell_study]# echo $((a++))
100 //注意输出结果为100
[root@localhost shell_study]# echo $a
101 //注意输出结果为101
[root@localhost shell_study]# a=10
[root@localhost shell_study]# echo $((a&ndash;))
10 //输出结果为10
[root@localhost shell_study]# echo $a
9 //输出结果为9</p></li>

<li><p>多项逻辑运算，格式：((a=3+5, b=a+10))</p></li>

<li><p>test
1.用法：test expression,当 test 判断 expression 成立时，退出状态为 0，否则为非 0 值。</p>

<p>2.文件类型判断
选 项     作 用
-b filename 判断文件是否存在，并且是否为块设备文件。
-c filename 判断文件是否存在，并且是否为字符设备文件。
-d filename 判断文件是否存在，并且是否为目录文件。
-e filename 判断文件是否存在。
-f filename 判断文件是否存在，井且是否为普通文件。
-L filename 判断文件是否存在，并且是否为符号链接文件。
-p filename 判断文件是否存在，并且是否为管道文件。
-s filename 判断文件是否存在，并且是否为非空。
-S filename 判断该文件是否存在，并且是否为套接字文件。</p>

<p>3.文件权限判断
 选 项        作 用
-r filename 判断文件是否存在，并且是否拥有读权限。
-w filename 判断文件是否存在，并且是否拥有写权限。
-x filename 判断文件是否存在，并且是否拥有执行权限。
-u filename 判断文件是否存在，并且是否拥有 SUID 权限。
-g filename 判断文件是否存在，并且是否拥有 SGID 权限。
-k filename 判断该文件是否存在，并且是否拥有 SBIT 权限</p>

<p>4.文件比较
        选 项                 作 用
filename1 -nt filename2     判断 filename1 的修改时间是否比 filename2 的新。
filename -ot filename2      判断 filename1 的修改时间是否比 filename2 的旧。
filename1 -ef filename2     判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</p></li>
</ul>

<p>eg:
#! /bin/bash</p>

<p>read a
read b
if test $a&gt;$b
then
    echo 1
else
    echo 0
fi
结果:
[root@localhost shell_study]# bash test.sh
1
2
1</p></li>

<li><p>选择结构</p>

<p>1.if elif结构
if  condition1
then
   statement1
elif condition2
then
    statement2
elif condition3
then
    statement3
……
else
   statementn
fi
2.if else结构
if  condition
then
   statement1
else
   statement2
fi</p>

<p>3.case结构
case expression in
    pattern1)
        statement1
        ;;
    pattern2)
        statement2
        ;;
    pattern3)
        statement3
        ;;
    ……
    *)
        statementn
esac</p></li>

<li><p>循环结构</p>

<p>1.while循环
while condition
do
    statements
done</p>

<p>2.until循环（条件不成立时才进行循环，一旦判断条件成立，就终止循环）
until condition
do
    statements
done</p>

<p>3.for循环
for((exp1; exp2; exp3))
do
    statements
done</p>

<p>4.for in循环
for variable in value_list
do
    statements
done</p>

<p>5.select in循环
select variable in value_list
do
    statements
done</p></li>

<li><p>函数定义与调用</p>

<p>格式一：
function name() {
    statements
    [return value]
}</p>

<p>格式二:
name() {
    statements
    [return value]
}</p>

<p>格式三：
function name {
    statements
    [return value]
}</p>

<p>eg:
#! /bin/bash</p>

<p>function getsum(){
    local sum=0
    for n in $@
    do
        ((sum+=n))
    done
    return $sum
}</p>

<p>getsum 10 20 30 40 50 #调用函数并传递参数
echo $?</p>

<p>运行结果：150</p>

<p>eg:
#!/bin/bash
function getsum(){
    local sum=0
    for n in $@
    do
         ((sum+=n))
    done
    echo $sum
    return 0
}
#调用函数并传递参数，最后将结果赋值给一个变量
total=$(getsum 10 20 55 15)
echo $total
#也可以将变量省略
echo $(getsum 10 20 55 15)</p></li>
</ul>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;shell未完待续&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>