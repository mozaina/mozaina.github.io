<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linux基础文本处理工具和shell编程基础 | 开发者问答集锦</title>
    <meta property="og:title" content="linux基础文本处理工具和shell编程基础 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linux基础文本处理工具和shell编程基础">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%9F%BA%E7%A1%80%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%92%8Cshell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linux基础文本处理工具和shell编程基础</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<ul>
<li>1、定义一个对所有用户都生效的命令别名，如：lftps=‘lftp 172.168.0.1/pub’</li>
<li>2、显示/etc/passwd文件中不以/bin/bash结尾的行</li>
<li>3、找出/etc/passwd文件中，包含二位数字或者三位数的行</li>
<li>4、显示/proc/meminfo文件中以大写或小写S开头的行；三种方式</li>
<li>5、使用echo输出一个绝对路径，使用egrep取出路径名，类型执行dirname /etc/passwd 的结果</li>
<li>6、找出ifconfig中的ip地址。要求结果只显示IP地址</li>
<li>7、vim定制自动缩进四个字符</li>
<li>8、实现自动添加三个用户，并计算这三个用户的uid之和</li>
<li>9、find用法以及常用用法的实例演示</li>
<li>10、locate用法以及常用用法的实例演示</li>
<li>11、参数替换xargs</li>
<li>12、各种文本工具查看，分析，统计，grep用法以及常用用法的实例演示</li>
<li>13、正则表达式</li>
<li>14、egrep及扩展的正则表达式</li>
<li>15、vim简介</li>
<li>16、shell编程基础</li>
<li>17、环境变量</li>
<li>18、bash的环境设置</li>
</ul>

<h2 id="定义一个对所有用户都生效的命令别名-如-lftps-lftp-172-168-0-1-pub">定义一个对所有用户都生效的命令别名，如：lftps=‘lftp 172.168.0.1/pub’</h2>

<p>alias（中文称为“别名”）允许使用更加简短的名称来重新定义 Linux 中的 Shell 命令，从而简化命令行的输入。<br />
<strong>通常都是用bashrc来访别名和函数</strong></p>

<pre><code>[root@centos7 ~]#cat .bash_profile  
 .bash_profile  

 Get the aliases and functions  获取别名和函数
if [ -f ~/.bashrc ]; then     （-f判断是否是不同文件，
        . ~/.bashrc
fi

 User specific environment and startup programs   用户特定的环境和启动程序

PATH=$PATH:$HOME/bin   path路径

export PATH  导出路径
</code></pre>

<p>单个用户永久生效是放在家目录里的配置文件.bashrc里，针对所有用户就需要放在etc/profile或者/etc/bahsrc里</p>

<pre><code>[root@centos7 ~]#echo &quot;alias lftps='lftp 172.168.0.1/pub'&quot; &gt;&gt; /etc/bashrc 也可以是/etc/profile
[root@centos7 ~]#. /etc/bashrc
[root@centos7 ~]#alias
alias lftps='lftp 172.168.0.1/pub'
</code></pre>

<h2 id="显示-etc-passwd文件中不以-bin-bash结尾的行">显示/etc/passwd文件中不以/bin/bash结尾的行</h2>

<p><strong>-v 显示没有匹配到的行</strong></p>

<pre><code>[root@centos7 ~]#grep  &quot;/bin/bash$&quot; /etc/passwd   
root:x:0:0:root:/root:/bin/bash
memcachaed:x:2001:2001::/home/memcachaed:/bin/bash
alice:x:2005:2005:alice2,lll,223333,12333:/home/alice:/bin/bash
bob:x:2006:100::/home/bob:/bin/bash
bash:x:2007:2007::/home/bash:/bin/bash
[root@centos7 ~]#grep -v &quot;/bin/bash$&quot; /etc/passwd   
sync:x:5:0:sync:/sbin:/bin/sync
</code></pre>

<h2 id="找出-etc-passwd文件中-包含二位数字或者三位数的行">找出/etc/passwd文件中，包含二位数字或者三位数的行</h2>

<p><strong>grep 正则表达式</strong></p>

<pre><code>[root@centos6 ~]#grep -w  &quot;[[:digit:]]\{2,3\}&quot;  /etc/passwd 或者grep -w &quot;[0-9]\{2,3\}&quot;  /etc/passwd    或者  grep   &quot;\
</code></pre>

<h2 id="显示-proc-meminfo文件中以大写或小写s开头的行-三种方式">显示/proc/meminfo文件中以大写或小写S开头的行；三种方式</h2>

<pre><code>[root@centos6 ~]#grep &quot;^[a-z]\|^[A-Z]&quot; /proc/meminfo   或者 grep -e &quot;^[a-z]&quot; -e &quot;^[A-Z]&quot;   /proc/meminfo 或者grep -e &quot;^[[:upper:]]&quot; -e &quot;^[[:lower:]]&quot; /data/test  或者  grep &quot;^[[:upper:]]\|^[[:lower:]]&quot; /data/test  
MemTotal:        2037260 kB
MemFree:         1207672 kB
Buffers:          113940 kB
Cached:           339768 kB
扩展正则表达式
[root@centos6 ~]#grep -E &quot;^[[:upper:]]|^[[:lower:]]&quot; /data/test    或者 grep -E &quot;^([[:upper:]]|[[:lower:]])&quot; /data/test  
HugePages_Total:       0
HugePages_Free:        0
</code></pre>

<h2 id="使用echo输出一个绝对路径-使用egrep取出路径名-类似执行dirname-etc-passwd-的结果">使用echo输出一个绝对路径，使用egrep取出路径名，类似执行dirname /etc/passwd 的结果</h2>

<p><strong>扩展正则表达式种 ^:行首；$行尾 ；,\b：词尾,<br />
绝对路径后面为一个单词就可以认为是一个单词的词首，所以如下：</strong></p>

<pre><code>[root@centos6 ~]#echo /etc/passwd/alice/bb |grep -Eo &quot;.*\
</code></pre>

<h2 id="找出ifconfig中的ip地址-结果只显示ip地址">找出ifconfig中的ip地址。结果只显示IP地址</h2>

<pre><code> [root@centos6 ~]#ifconfig  |grep -Eo &quot;inet addr:([0-9]{1,3}\.){3}([0-9]){1,3}&quot;|grep -Eo &quot;([0-9]{1,3}\.){3}([0-9]){1,3}&quot;
    192.168.30.6
    127.0.0.1
  [root@centos6 ~]#ifconfig |sed -rn &quot;s/.*inet (addr:)?(([0-9]{1,3}\.){3}[0-9])  .*/\2/p&quot;
  192.168.30.6
  127.0.0.1
</code></pre>

<p><strong>127.0.0.1为巡回地址可以筛选出来，不做使用</strong></p>

<h2 id="vim定制自动缩进四个字符">vim定制自动缩进四个字符</h2>

<p><strong>vim配置文件全局：/etc/vimrc 个人：~/.vimrc</strong></p>

<pre><code>root@centos7 ~]#echo set  tabstop=4 &gt;&gt; .vimrc 设置缩进为4个字符
    [root@centos7 ~]#echo set  ai  &gt;&gt; .vimrc  #设置自动缩减
    [root@centos7 ~]#vim /etc/centos-release #查看效果
CentOS Linux release 7.6.1810 (Core) 
ddd
    d;; 
    ddd   
</code></pre>

<h2 id="实现自动添加三个用户-并计算这三个用户的uid之和">实现自动添加三个用户，并计算这三个用户的uid之和</h2>

<pre><code>#!/bin/bash
for i in {1..3} ; do
        read -p &quot;Plsease input your username: &quot; username
       if    [ -z &quot;$username&quot; ]
                then
                { echo $username is empty;exit;  }
        else
                useradd $username &amp;&gt; /dev/null &amp;&amp; echo ok || echo The user$username was be created
        fi                                                                       
done
        user1id=&quot; `getent passwd |cut -d: -f3 |tail -n3 `&quot;
echo &quot;id count is `echo $user1id |tr &quot; &quot; +|bc `&quot;
[root@centos7 ~]#./createuser3.sh    #执行效果
Plsease input your username: r
ok
Plsease input your username: t
ok
Plsease input your username: y
ok
id count is 6039
</code></pre>

<h2 id="find用法以及常用用法的实例演示">find用法以及常用用法的实例演示</h2>

<p><strong>sysnopsis 简单概述</strong><br />
find是实时查找工具，通过遍历指定路径完成文件查找<br />
<strong>工作特点：</strong><br />
1.查找速度略慢<br />
2.精确查找<br />
3.实时查找<br />
4.可能只搜索用户具备读取和执行权限的目录<br />
5.find占用性能比较大<br />
<strong>语法：</strong><br />
1. find [option]…[查找路径][查找条件][处理动作]<br />
2.查找路径：指定具体目标路径；默认为当前目录<br />
3.查找条件：指定的查找标准，可以文件名、大小、类型、权限等标准进行；默认为找出指定路径下的所有文件<br />
4.处理动作：对符合条件的文件做操作，默认输出至屏幕<br />
5.查找路径可以省略 默认为当前目录<br />
6.默认就是把文件名打印出来<br />
<strong>查找条件：</strong></p>

<ol>
<li><p>指搜索层级</p>

<pre><code>                -maxdepth level 最大搜索目录深度，指定目录为第1级
            -mindepth level 最小搜索目录深度
</code></pre></li>

<li><p>根据文件名和inode查找</p>

<pre><code>                -name &quot;文件名称&quot;：支持使用glob(通配符)  默认是精确匹配
                            *,?,[],[^]
            -iname &quot;文件名称&quot;：不区分字母大小写
            -inum n 按inode（节点编号）号查找（ll -i 可以查看节点编号）
            -samefile name 相同inode号的文件
            -links n 链接数为n的文件
            -regex &quot;PATTERN（模式）&quot;：以PATTERN匹配整个文件路径字符串，而不仅仅是文件名称
             默认查找是递归的
</code></pre></li>

<li><p>根据属主、数组查找</p>

<pre><code>                 -user USERNAME：查找属主为指定用户(UID)的文件
             -group GRPNAME：查找属组为指定组(GID)的文件
             -uid UserID：查找属主为指定的UID号的文件
             -gid GroupID：查找属组为指定的GID号的文件
             -nouser：查找没有属主的文件
             -nogroup：查找没有数组的文件
</code></pre></li>

<li><p>根据文件类型查找</p>

<pre><code>                 -type  TYPE:
                        f：普通文件
                        d：目录文件
                        l：符号链接文件
                        s：套接字文件
                        b：块设备文件
                        c：字符设备文件
                        p：管道文件
</code></pre></li>

<li><p>组合条件</p>

<pre><code>                 与：-a
             或：-o
             非：-not，！
</code></pre></li>

<li><p>德摩根定律</p>

<pre><code>                 (非A)或(非B)=非(A且B)          !A   -o   !b =!(A -a  B)
             (非A)且(非B)=非(A或B)             !A   -a   !b =!(A -o  B)
</code></pre></li>

<li><p>根据文件大小来查找</p>

<pre><code>                 -size[+|-]#UNIT
                        常用单位：k,M,G,c(byte)
             #UNIT：（#-1,#]
                        如：6k 表示(5k,6k]    不包括5k，包括6k    5k
</code></pre></li>

<li><p>根据时间戳查找</p>

<pre><code>                 以&quot;天&quot;为单位；
                    -atime [+|-]#，
                            #：[#，#+1)
                          +#：(#+1，∞)
                           -#：[0,#）
                    -mtime
                    -ctime
             以&quot;分钟&quot;为单位：
                    -amin
                    -mmin
                    -cmin
</code></pre></li>

<li><p>根据权限查找</p>

<pre><code>                 -perm[/|-]MODE
                    MODE：精确权限匹配
                   /MODE：任何一类（u,g,o）对象的权限中只要能一位匹配即可，或关系，+从centos7开始淘汰
                   -MODE：每一类对象都必须同时拥有指定权限，与关系
                   0表示不关注
                   / -的符号时，0代表不检查，-表示交集，/并集
</code></pre></li>

<li><p>find -perm 755 会匹配权限模式恰好是755的文件</p></li>

<li><p>只要当任意人有写权限时，find -perm +222就会匹配</p></li>

<li><p>只有当每个人都有写权限时，find -perm -222才会匹配</p></li>

<li><p>只有当其它人（other）有写权限时，find -perm -002才会匹配</p></li>

<li><p>find [option]…[查找路径][查找条件][处理动作]</p></li>

<li><p>处理动作</p>

<pre><code>                    -print：默认的处理动作，显示至屏幕

                -ls：类似于对查找到的文件执行&quot;ls -l&quot;命令

                -delete：删除查找到的文件（一般不用，比较危险，没有提示信息）

                -fls file：查找到的所有文件的长格式信息保存至指定文件中（结果存到文件去）

                -ok COMMAND {}\;对查找到的每个文件执行由COMMAND指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认（{}代表前面find命令搜索出来的文件名；带ok选项 要后面加 \;语法需要）

                -exec COMMAND {}\;对查找到的每个文件执行由COMMAND指定的命令
                {}：用于引用查找到的文件名称自身
                find传递查找到的文件至后面指定的命令时，查找到所有符合条件的文件一次性传递给后面的命令
                **必须要\；结束**
</code></pre></li>
</ol>

<p><strong>{}有文件名称本身，有可能里面带路径、<br />
-ok和exec都要加 ;</strong></p>

<p><strong>find示例</strong></p>

<p>备份配置文件，添加.orig这个扩展名<br />
fine -name “*conf” -exec cp {} {}.orig ;</p>

<p>提示删除存在时间超过3天以上的joe的临时文件<br />
find /tmp -ctime +3 -user joe -ok rm {} ;</p>

<p>在主目录中寻找可被其它用户写入的文件，把写权限<br />
find ~ -perm -002 -exec chmod o-w {} ;</p>

<p>查找/data下的权限为644，后缀为sh的普通文件，增加执行权限<br />
find /data -type f -perm 644 -name &ldquo; (通配符).sh&rdquo; -exec chmod 755 {} ;</p>

<p>查看/home 的目录<br />
find /home -type d -ls</p>

<p>查找/var目录下属主为root，且属组为mail的所有文件<br />
find /var -user “root” -a -group “mail” -ls</p>

<p>查找/var目录下不属于root、lp、gdm的所有文件<br />
find /var !( -user “root” -o -user “lp” -o -user “gdm” ) -l</p>

<p>查找/var目录下最近一周内其内容修改过，同时属主不为root,也不是pstfix的文件<br />
find /var -a mtime 7 ! -user “root” -a ! -user “pstfix”</p>

<p>查找当前系统当没有属主或属组，且最近一周内曾被访问的文件<br />
find /var ! ( -nouser -a -nogroup ) -a -atime 7 -ls</p>

<p>查找/etc目录下大于1M且类型为普通文件的所有文件<br />
find /etc/ -type f -a -size +1M</p>

<p>查找/etc目录下所有用户都没有写权限的文件<br />
find /etc -perm 111 -o -perm 444 -ls</p>

<p>查找/etc目录下至少有一类用户没有执行权限的文件<br />
find /etc -perm /111 -ls</p>

<p>查找/etc/init.d目录下，所有用户都有执行权限，且其它用户有写权限的文件<br />
find /etc/init.d -perm 111 -a -perm 001 -ls</p>

<h2 id="locate用法以及常用用法的实例演示">locate用法以及常用用法的实例演示</h2>

<p><strong>sysnopsis 简单概述</strong><br />
locate是非实时查找（数据库查找）查询系统上预建的文件索引数据库(/var/lib/mlocate/mlocate.db)<br />
工作特点：</p>

<p>依赖于实现构建的索引<br />
索引的构建是在系统较为空闲时自动进行（周期性任务）,管理员手动更新数据库（updatedb）<br />
索引构建过程需要遍历整个根文件系统，极消耗资源。<br />
查找速度快<br />
模糊查找<br />
非实时查找<br />
搜索的是文件的全路径，不仅仅是文件名<br />
可能只搜索用户具备读取和执行权限的目录</p>

<pre><code>    常用的选项：
            -i  不区分大小写的搜索
            -n  N   只列举前N个匹配项目
            -r  使用正则表达式
    locate示例：
            搜索名称或路径带有&quot;conf&quot;的文件

[root@centos7 ~]#locate conf
/var/lib/yum/history/2018-12-24/7/config-repos
/var/lib/yum/history/2018-12-24/8/config-main
/var/lib/yum/history/2018-12-24/8/config-repos
</code></pre>

<p>使用扩展正则表达式来搜索以&rdquo;.conf&rdquo;结尾的文件</p>

<pre><code> [root@centos7 ~]#locate -r '\.conf$'
/var/lib/NetworkManager/dhclient6-eth1.conf
/var/lib/libvirt/dnsmasq/default.conf
</code></pre>

<h2 id="参数替换xargs">参数替换xargs</h2>

<p>由于很多命令不支持管道’|&lsquo;来传递参数，而日常工作中有这个必要，所以就有了xargs命令<br />
xargs用于产生某个命令的参数，xargs 可以读入stdin（标准输入）的数据，并且以空格符或回车符将stdin的数据分割成为arguments<br />
注意：文件名或者是其他意义的名字内包含有空格符的情况<br />
有些命令不能接受过多参数，命令执行可能会失败，xargs可以解决<br />
find和xargs格式：find | xargs COMMAND<br />
xargs默认是把前面一个输出的信息用空格隔开<br />
echo f{1…10} | xargs -n2 echo #-n2 2个一组 n表示一次传几个参数过去</p>

<h2 id="各种文本工具查看-分析-统计-grep用法以及常用用法的实例演示">各种文本工具查看，分析，统计，grep用法以及常用用法的实例演示</h2>

<p><strong>抽取文本的工具：</strong><br />
文件内容：less和cat<br />
文件截取：head和tail<br />
按列抽取：cut<br />
按关键字抽取：grep<br />
<strong>1.文件查看的命令：cat</strong><br />
cat，tac，rev<br />
rev是一行反，tac是从头到尾反<br />
<strong>cat语法：</strong><br />
cat [option]…[file]…<br />
-E：显示行结束符 （ （ （是回车键）<br />
-n：对显示出的每一行进行编号<br />
-A：显示所有控制符<br />
-b：非空行编号<br />
-s：压缩连续的空行成一行</p>

<p><strong>2.分页查看文件内容：more</strong><br />
more：分页查看文件<br />
<strong>more语法：</strong><br />
more [option…]file…<br />
-d：显示翻页及退出提示<br />
less：一页一页地查看文件或STDIN输出<br />
<strong>查看时用的命令包括：</strong><br />
/文本 搜索 文本<br />
n/N 跳到下一个或上一个匹配<br />
<strong>less 命令是man命令使用的分页器<br />
对于显示的信息过多，可以用less和more</strong></p>

<p><strong>3.显示文本前或后行内容：head，tail</strong><br />
<strong>head语法：</strong><br />
head [option]…[file]…<br />
-c #：指定获取前#字节<br />
-n #：指定获取前#行<br />
- #：指定行数<br />
<strong>tail语法：</strong><br />
tail [option]…[file]…<br />
-c #：指定获取前#字节<br />
-n #：指定获取前#行<br />
- #：<br />
- f：跟踪显示文件fd新追加的内容，常用日志监控，相当于–follow=descriptor<br />
- F：跟踪文件名，相当于—follow=name–reytry<br />
tail 类似 tail -f,当文件不增长时并不访问文件</p>

<p><strong>tail命令一般用在日志中，默认后 10行，因为日志都是追加的，查询最新的记录只要tail最后几行就可以了<br />
tail -f 类似tailf 可以监听这个文件的变化</strong></p>

<p><strong>4.按列抽取文本cut和合并文件paste：</strong><br />
<strong>cut语法：</strong><br />
tail [option]…[file]…<br />
-d DELIMITER：指明分隔符，默认tab<br />
-f FILEDS：<br />
#：第#个字段<br />
#，#[,#]：离散的多个字段，例如1,3，6<br />
#-#：连续的：连续的多个字段，例如1-6<br />
混合使用：1-3，7<br />
-c 按字符切割<br />
--output-delimiter=STRING指定输出分隔符（delimiter 分隔符，域，列）<br />
<strong>find示例</strong><br />
显示文件或STDIN数据的指定列<br />
cut -d: -f1 /etc/passwd<br />
cat /etc/passwd | cut -d: -f7</p>

<pre><code>                      **paste语法：**
                      paste 合并两个文件同行号的列到一行
                          paste [option]...[file]...
                                        -d 分隔符：指定分隔符，默认用TAB
                                        -s：所有行合成一行显示
                                        paste f1  f2
                                        paste -s  f1  f2
                      **cut可以把文件中特定列固定出来**
                      **paste合并两个文件同一行的内容合并**
</code></pre>

<p><strong>5.分析文本的工具：wc，sort，diff和patch</strong><br />
文本数据统计：wc 是word count字数计数<br />
整理文本：sort<br />
比较文件：diff和patch<br />
<strong>收集文本统计数据wc：</strong><br />
计数单词总数、行总数、字节数和字符总数<br />
可以对文件或STDIN中的数据运行<br />
wc story.txt<br />
39 237 1901 story.txt<br />
行数 字数 字节数<br />
<strong>wc命令选项：</strong><br />
-l：只计数行数<br />
-w：只计数单词总数<br />
-c：只计数字节总数<br />
-m：只计数字符总数<br />
-L：显示文件中最长行的长度<br />
<strong>文本排序sort：</strong><br />
把整理过的文本显示在STDOUT，不改变原始文件<br />
<strong>sort语法：</strong><br />
sort [option] file(s)<br />
<strong>sort常用命令选项：</strong><br />
-r：执行反方向（由上至下）整理（倒序）<br />
-R：随机排序<br />
-n：执行按数字大小整理<br />
-f：选项忽略（fold）字符串中的字符大小写<br />
-u：选项（独特，unique）删除输出中的重复行（去重）<br />
-t c：选项使用c做为字段界定符<br />
-k x：选项按照使用c字符分隔的x列来整理能够使用多次<br />
<strong>uniq：</strong><br />
从输出中删除前后相接的重复的行<br />
<strong>uniq语法：</strong><br />
uniq[option]…[file]…<br />
-c：显示每行重复出现的次数<br />
-d：仅显示重复过的行<br />
-u：仅显示不曾重复过的行<br />
注意：连续且完全相同才为重复<br />
<strong>重复是指相邻的重复，隔开的就不算重复</strong><br />
<strong>uniq默认是把相邻的重复行合并成一个</strong><br />
常和sort命令一起配合使用：<br />
sort abc.txt | uniq -c<br />
<strong>比较文件：diff</strong><br />
比较两个文件之间的区别</p>

<pre><code>[root@centos7 /data]#cat &gt;123.text
1
1
2
[root@centos7 /data]#cat &gt;1234.text
1
2
2
[root@centos7 /data]#diff 123
1234.text  123.text   
[root@centos7 /data]#diff 123.text 1234.text 
2c2
&lt; 1
---
&gt; 2
 #第2行有变化           
</code></pre>

<p><strong>复制对文件改变：path</strong><br />
diff 命令的输出被保存在一种叫做&rdquo;补丁&rdquo;的文件中<br />
使用 -u 选项来输出&rdquo;统一的（unified）&rdquo;diff格式文件，最适用于补丁文件<br />
path 复制在其它文件中进行的改变（要谨慎使用）<br />
使用 -b 选项来自动备份改变了的文件<br />
diff -u foo.conf foo2.conf &gt;foo.path<br />
path -b foo.conf foo.path<br />
<strong>文本处理示例：</strong></p>

<p>1、找出ifconfig &ldquo;网卡名&rdquo;命令结果中的ipv4地址<br />
ifconfig eth0 |grep -Eo “([0-9]+.){3}[0-9]”|head -n1 192.168.30.7</p>

<p>2、查出分区空间使用率的最大百分比值<br />
df | tr -s ’ ’ | cut -d ’ ’ -f5 |sort -nr |head -n1</p>

<p>3、查出用户uid最大值的用户名、uid及shell类型<br />
sort -nr /etc/passwd |head -n1</p>

<p>4、查出/tmp的权限，以数字方式显示<br />
stat -c%a /tmp</p>

<p>5、统计当前链接本机的每个远程主机ip的连接数，并按从大到小排序<br />
cat -d’ ’ -f1 /var/log/httpd/access_log | uniq -c |sort -nr</p>

<p><strong>6.文本过滤（模式：pattern）工具：grep （Global search REgular expression and Print out
the line）</strong><br />
fgrep不支持正则表达式 egrep支持扩展正则表达式<br />
作用：文本搜索工具，根据用户指定的&rdquo;模式&rdquo;对目标文本逐行进行匹配检查；打印匹配到的行<br />
模式：由正则表达式字符及文本字符所编写的过滤条件<br />
<strong>grep语法：</strong><br />
grep [options] pattern [file…]<br />
<strong>grep命令选项：</strong><br />
--color=auto：对匹配到的文本着色显示<br />
-v：显示不被pattern匹配到的行<br />
-i：忽略字符大小写<br />
-n：显示匹配的行号<br />
-c：统计匹配的行数<br />
-o：仅显示匹配到的字符串<br />
-q：静默模式，不输入任何信息（静默就关心包含是否，而不关心包含的是什么 ，会存在返回结果，放在$?里会帮助我们判断前面的执行结果0找到，1不找到）<br />
-A #：after，后#行<br />
-B #：before，前#行<br />
-C #：context，前后各#行<br />
-e：实现多个选项间的逻辑or关系<br />
grep -e ‘cat’ -e ‘dog’ file<br />
-w：匹配整个单词<br />
-E：使用ERE<br />
-F：相当于fgrep，不支持正则表达式</p>

<h2 id="正则表达式">正则表达式</h2>

<p><strong>REGEXP ：</strong> 由一类特殊字符及文本字符所编写的模式，其中有些字符 （元字符）不表示字符字面意义，而表示控制或通配的功能</p>

<p><strong>程序支持：</strong> grep，sed，awk，vim，less，nginx，varnish等</p>

<p><strong>分两类：</strong><br />
基本正则表达式：BRE<br />
扩展正则表达式：ERE<br />
grep -E，egrep</p>

<p><strong>正则表达式引擎：</strong><br />
采用不同算法，检查处理正则表达式的软件模块<br />
PCRE（Perl Compatible Regular Expressions）</p>

<p><strong>元字符分类（正则表达式分4种）：</strong> 字符匹配、匹配次数、位置锚定、分组<br />
查看man帮助 man 7 regex</p>

<p><strong>字符匹配：</strong></p>

<pre><code>. 匹配任意单个字符
【】匹配指定范围内的任意单个字符
【^】匹配指定范围外的任意单个字符
【:digit:】任意数字
【:lower:】任意小写字母
【:upper:】任意大写字母
【:alpha:】任意大小写字母，即A-Z,a-z
【:alnum:】任意数字或字母
【:blank:】空白字符（空格和制表符）
【:space:】水平或垂直空白字符 包括blank
【:punct:】标点符号
【:print:】可打印字符
【:cntrl:】不可打印的控制字符（退格、删除、警铃...）
【:graph:】可打印的非空白字符
</code></pre>

<p><strong>匹配次数：</strong></p>

<pre><code>用在要指定次数的字符后面，用于指定前前面的字符要出现的次数
* 匹配前面的字符任意次，包括0次
            贪婪模式：尽可能长的匹配
. 星号 任意长度的任意字符
\? 匹配其前面的字符0或1次
\+ 匹配其前面的字符至少1次
\{n\}匹配前面的字符n次
\{m,n\}匹配前面的字符至少m次，之多n次
\{,n\}匹配前面的字符至多n次
\{n,\}匹配前面的字符至少n次
</code></pre>

<p><strong>位置锚定，定位出现的位置：</strong></p>

<pre><code>  ^ 行首锚定，用于模式的最左侧
  $ 行尾锚定，用于模式的最右侧
  ^PATTERN$ 用于模式匹配整行
                ^$ 空行
                ^ [[:space:]]*$ 空白行
  \&lt; 或 \b 词首锚定，用于单词模式的左侧
  \&gt; 或 \b 词尾锚定，用于单词模式的右侧
  \ 匹配整个单词
</code></pre>

<p><strong>分组：</strong><br />
()将一个或多个字符捆绑在一起，当做一个整体进行处理，如：(root)+</p>

<p>分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量命名方式为:<br />
\1,\2,\3,…</p>

<p>\1表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符</p>

<p><strong>分区示例</strong></p>

<pre><code>    \(string1\+\(string2\)*\)
    \1:string1\+\(string2\)*
    \2:string2
</code></pre>

<p>后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身<br />
或者：|<br />
示例：a|b：a或b C|cat：C或cat (C|c\）at：Cat 或cat</p>

<h2 id="egrep及扩展的正则表达式">egrep及扩展的正则表达式</h2>

<p>egrep =grep -E<br />
<strong>grep语法：</strong><br />
egrep [options]PATTERN[file…]<br />
<strong>扩展正则表达式的元字符：</strong><br />
<strong>字符匹配：</strong><br />
.任意单个字符<br />
[]指定范围的字符<br />
[^]不在指定范围的字符<br />
<strong>次数匹配：</strong><br />
*：匹配前面字符任意次<br />
？：0或1次<br />
+：1次或多次<br />
{m}：匹配m次<br />
{m,n}：至少m，至多n次<br />
1 <strong>位置锚定：</strong><br />
^：行首<br />
$：行尾<br />
&gt;,\b：语尾<br />
<strong>分组：</strong><br />
（）<br />
后向引用：\1,\2,…<br />
<strong>或者：</strong><br />
a|b：a或b<br />
C|cat：C或cat<br />
（C|c）at：Cat或cat<br />
<strong>扩展表达式示例：</strong><br />
1、显示三个用户root、mage、wang的UID和默认shell<br />
grep -Ew “(root|mage|alice)” /etc/passwd|cut -d: -f1,7</p>

<p>2、找出/etc/rc.d/init.d/functions文件中行首为某单词(包括下划线)后面跟一个小括号的行<br />
grep -Ew “^(_ <em>[[:alpha:]]+</em>?._ |[[:alpha:]]+_?.*)()”
/etc/rc.d/init.d/functions</p>

<p>3、使用egrep取出/etc/rc.d/init.d/functions中其基名<br />
echo /etc/rc.d/init.d/functions |grep -Ewo “[^/] <em>$&rdquo;<br />
4、使用egrep取出上面路径的目录名<br />
echo /etc/rc.d/init.d/functions |grep -Eo &ldquo;.</em> 5、统计last命令中以root登录的每个主机IP地址登录次数<br />
last |grep -Eo &ldquo; [0-9.]{7,}&rdquo; |uniq -c |sort -nr<br />
6、利用扩展正则表达式分别表示0-9、10-99、100-199、200-249、250-255<br />
【0-9】|【1-9】【0-9】|1【0-9】【0-9】|2【0-4】【0-9】|2【0-5】【0-5】<br />
7、显示ifconfig命令结果中所有IPv4地址<br />
ifconfig | grep -wE &lsquo;【1-9】【0-9】|1【0-9】【0-9】|2【0-4】【0-9】|2【0-5】【0-5】<br />
8、将此字符串：welcome to xxxxxx 中的每个字符去重并排序，重复次数多的排到前面<br />
echo welcome to xxxxxx |grep -Eo “[[:alpha:]]”|uniq -c|sort -nr</p>

<h2 id="vim简介">vim简介</h2>

<p><strong>vi：Visual Interface,文本编辑器<br />
文本：ASCII，Unicode</strong></p>

<p><strong>文本编辑种类：</strong><br />
行编辑：sed<br />
全屏编辑期：nano，vi<br />
vim-Vi Improved<br />
<strong>其他编辑器：</strong><br />
gedit 简单的图像编辑器<br />
gvim 一个vim编辑器的图像版本<br />
<strong>vim用法：</strong><br />
vim [option]…file<br />
+#：打开文件后，让光标处于第#行的行首，+默认行尾<br />
+/PATTERN：打开文件后，直接让光标处于第一个被PATTERN匹配到的行的行首<br />
-b file：二进制方式打开文件<br />
-d file file2…：比较多个文件<br />
-m file：只读打开文件<br />
ex file 或 vim -e 直接进入ex模式<br />
如果该文件存在，文件打开并显示 内容；如果该文件不存在，当编辑后第一次存盘时创建它<br />
<strong>模式编辑器：vim</strong><br />
击键行为时依赖于vim的&rdquo;模式&rdquo;<br />
<strong>三种主要模式：</strong><br />
命令（Normal）模式：默认模式，移动光标，剪切/粘贴文本<br />
插入（insert）或编辑模式：修改文本<br />
扩展命令（extend command）模式：保存，退出等<br />
Esc键 退出当前模式<br />
Esc键 Esc 总是返回到命令模式<br />
<strong>模式转换：vim</strong><br />
<strong>命令模式– &gt;插入模式</strong><br />
i是原地切换修改模式<br />
L：是行首修改模式<br />
a：在光标之后修改<br />
A：在行尾模式<br />
o：在下面插入一行修改<br />
O：在上面插入一行修改**<br />
按 ：进入ex模式<br />
wq：存盘退出<br />
q：不做修改直接退出<br />
q！：直接强制退出<br />
w： anoter（w后面跟空格和文件名）把修改后的存入另外一个文件<br />
w！：强制<br />
r ：another（把另外一个文件的内容读入到当前内容）</p>

<pre><code>  插入模式-----------------------&gt;命令模式
             ESC
  命令模糊-----------------------&gt;扩展命令模式
                 ：
  扩展命令模式------------------&gt;命令模式
                ESC，enter
</code></pre>

<p><strong>扩展模式：</strong><br />
：q 不做修改直接退出<br />
： q！直接强制退出<br />
： w anoter（w后面跟空格和文件名）把修改后的存入另外一个文件<br />
：w！ 强制<br />
：x 保存退出</p>

<h1 id="vim命令模式">vim命令模式：</h1>

<p>按&rdquo;：&rdquo;进入Ex模式<br />
创建一个命令提示符：处于底部的屏幕左侧<br />
命令：<br />
w 写（存）磁盘文件<br />
wq 写入并退出<br />
x 写入并退出<br />
q 退出<br />
q！ 不存盘退出<br />
r filename 读文件内容到当前文件中<br />
w filename 将当前文件内容写入另一个文件<br />
！command 执行命令<br />
r！command 读入命令的输出<br />
<strong>写入颜色：</strong><br />
<strong>把颜色写进去CTRL+v+[ vim中的^[相当于echo中的\e=\033</strong><br />
1<br />
<strong>命令模式光标跳转：</strong><br />
<strong>字符间跳转：</strong><br />
h:左 l:右 j:下 k:上<br />
#COMMAND：跳转由#指定的个数的字符<br />
<strong>单词间跳转：</strong><br />
w：下一个单词词首（空格隔开为一个单词）<br />
e：当前或下一单词的词尾（如果这个单词就一个字符就是当前单词或者后面是空白字符）<br />
b：当前或前一个单词的词尾（如果这个单词就一个字符或者前面有空白字符那就是当前单词）<br />
#COMMAND：由#指定一次跳转的单词数<br />
<strong>当前页跳转：</strong><br />
H：页首 M：页中间行 L：页底<br />
<strong>行首行尾跳转：</strong><br />
^：跳转至行首的第一个非空白字符<br />
0：跳转至行首<br />
$：跳转至行尾<br />
<strong>行间移动：</strong><br />
#G、扩展模式：#：跳转至由#指定行<br />
G：最后一行<br />
1G，gg：第一行<br />
<strong>句间移动：</strong><br />
)：下一句<br />
（：上一句<br />
<strong>段落间移动：</strong><br />
}：下一段 （.+空格为判断一个句子）<br />
{：上一段 （中间有空行的叫段落）<br />
<strong>命令模式翻屏操作：</strong><br />
ctrl+f：向文件尾部翻一屛<br />
ctrl+b：向文件首部翻一屛<br />
ctrl+d：向文件尾巴翻半屛<br />
ctrl+u 向文件首部翻半屛<br />
<strong>命令模式操作：</strong><br />
<strong>字符编辑：</strong><br />
x：删除光标处的字符<br />
#x：删除光标处起始的#个字符<br />
xp：交换光标所在处的字符及其后面字符的位置<br />
~：转换大小写<br />
J：删除当前行后的换行符<br />
<strong>替换命令：(r，replace)</strong><br />
r：替换光标所在处的字符<br />
R：切换成REPLACE模式<br />
<strong>删除命令：d</strong><br />
d：删除命令，可结合光标跳转字符，实现范围删除<br />
d￥：从光标（包括光标）删除到行尾<br />
d0：从光标（不包括光标）之前删除到行首<br />
d^：从光标（不包括光标）之前删除到非空行首<br />
dw：删除到当前或下一个单词词首<br />
de：删除到当前或下一个单词词尾<br />
db：删除到当前上一个单词词首<br />
dd：删除所在的行<br />
dd：多行删除<br />
D=d’dollar’；删到行尾留空行<br />
<strong>复制命令：y，yank</strong><br />
y：复制，行为相似于d命令<br />
y￥：从光标（包括光标）复制到行尾<br />
y0：从光标（不包括光标）之前复制到行首<br />
y^：从光标（不包括光标）之前复制到非空行首<br />
yw：复制到当前或下一个单词词首<br />
ye：复制到当前或下一个单词词尾<br />
yb：复制到当前上一个单词词首<br />
#yy：多行复制<br />
yy：复制行<br />
Y：复制整行<br />
pP黏贴位置上下之分<br />
<strong>黏贴命令：p，paste</strong><br />
p：缓冲区存的如果为整行，则黏贴当前光标所在行的下方；否则，则粘贴至当前光标所在处的后面<br />
P：缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，则粘贴至当前光标所在处的前面<br />
<strong>改变命令：c，change</strong><br />
c：修改后切换成插入模式<br />
<strong>命令模式&mdash;- &gt;插入模式</strong><br />
c￥：删除光标之后的行后，进入insert模式<br />
c0：从光标删除到行首（）<br />
c^：从光标删除到非空行首（不包括光标）<br />
cw：删除所在单词<br />
ce：删除到后一个单词<br />
cb：删除到上一个单词<br />
#cc：多行插入<br />
cc：删除当前行并输入新内容，相当于S<br />
C：删除当前光标到行尾并进入insert模式=从c $<br />
<strong>其他：</strong><br />
100iwang[ESC]粘贴&rdquo;wang&rdquo;100次</p>

<p>Command：<br />
y复制、d删除、gU变大写、gu变小写<br />
比如0y￥命令意味着：<br />
0：先到行头<br />
y：从这里开始拷贝<br />
￥：拷贝到本行最后一个字符<br />
ye从当前位置拷贝到本单词的最后一个字符</p>

<h2 id="扩展命令模式-地址定界">扩展命令模式：地址定界</h2>

<p>1 <strong>地址定界：</strong><br />
：start_pos，end_pos<br />
#：具体第#行，例如2表示第2行<br />
#，#：从左侧#表示起始行，到右侧#表示结尾行<br />
#，+#：从左侧#表示的起始行，加上右侧#表示结尾行<br />
：2，+3表示2到5行<br />
.：当前行<br />
$：最后一行<br />
.，￥-1当前行到倒数第二行<br />
2，.d ：从第2行删出到光标处<br />
2，+3 d：删除第2行到第5行<br />
%：全文，相当于1，￥<br />
<strong>/pat1/,/pat2/：</strong><br />
从第一次被pat1模式匹配到的行开始，一直到第一次被pat2匹配到的行结束<br />
#,/pat/<br />
/pat/,￥<br />
<strong>使用方法：后跟一个编辑命令</strong><br />
d：删除<br />
y：复制<br />
w file：将范围内的行另存至指定文件中<br />
r file：在指定位置插入指定文件中的所有内容<br />
<strong>查找：</strong><br />
/PATTERN：从当前光标所在处向文件尾部查找<br />
?PATTERN：从当前光标所在处向文件首部查找<br />
n：与命令同方向<br />
N：与命令反方向<br />
<strong>查找并替换：</strong><br />
s：在扩展模式下完成查找替换操作<br />
格式：s/要查找的内容/替换为的内容/修饰符<br />
要查找的内容：可使用模式<br />
替换为的内容：不能使用模式，但可以使用\1,\2,…等后向引用符号；还可以使用&rdquo;&amp;&ldquo;引用前面查找时查找到的整个内容<br />
修饰符：<br />
i：忽略大小写<br />
g：全局替换；默认情况下，每一行只替换第一次出现<br />
gc：全局替换，每次替换前询问<br />
查找替换中的分隔符/可替换为其他字符，例如：<br />
s@/etc@/var@g<br />
s#/boot#/#i<br />
<strong>撤销更改：</strong><br />
u ：撤销最近的更改<br />
#u：撤销之前多次更改<br />
U ：撤销光标落在这行后所有此行的更改<br />
. ：重复前一个操作<br />
n.：重复前一个操作n次<br />
按ctrl +r 重做最后的’撤销更改</p>

<h2 id="vim的寄存器">vim的寄存器</h2>

<p>1 有26个命令寄存器和1个无命名寄存器，常存放不同的剪贴板内容，可以不同会话间共享<br />
2 寄存器名称a，b，…，z,格式：&rdquo;寄存器&rdquo;放在数字和命令之间<br />
如：3&rdquo;tty&rdquo;表示复制3行到t寄存器中<br />
&ldquo;tp&rdquo;表示将t寄存器内容粘贴<br />
3 未指定，将使用无命名寄存器<br />
4 有10个数字寄存器，用0,1，…9表示，0
存放最近复制内容，1存放最近删除内容，当心的文本变更和删除时，1转存到2,2转存到3，以此类推。数字寄存器不能在会话间共享<br />
<strong>编辑二进制文件：</strong><br />
以二进制方式打开文件<br />
vim-b binaryfile<br />
扩展命令模式下，利用xxd命令转换为可读的十六进制<br />
：%！xxd<br />
编辑二进制文件<br />
扩展命令模式下，利用xxd命令转换回二进制<br />
：%！xxd -r<br />
保存退</p>

<h1 id="可视化模式">可视化模式</h1>

<p>1 允许选择的文本快<br />
v面向字符<br />
V面向行<br />
ctrl -v 面向块<br />
2 可视化键可用于与移动键结合使用：<br />
w ) }箭头等<br />
3 突出显示的文字可被删除，复制，变更，过滤，搜索，替换等<br />
<strong>编辑二进制文件：</strong><br />
vim file1 file2 file3 …<br />
：next 下一个<br />
：prev 前一个<br />
：first 第一个<br />
：last 最后一个<br />
：wall 保存所有<br />
：qall 退出所有<br />
：wqall<br />
<strong>使用多个窗口：</strong><br />
<strong>多文件分割：</strong><br />
vim -o|-O file1 file2 …<br />
-o：水平分割<br />
-O：垂直分割<br />
在窗口间切换：ctrl +w，arrow<br />
<strong>单文件窗口分割：</strong><br />
ctrl+w，s：split,水平分割<br />
ctrl+w，v：vertical，垂直分割<br />
ctrl+w，q：取消相邻窗口<br />
ctrl+w，o：取消全部窗口<br />
：wqall 退出</p>

<h1 id="定制vim的工作特性">定制vim的工作特性</h1>

<p>1 <strong>配置文件：永久有效</strong><br />
全局：/etc/vimrc<br />
个人：~/.vimrc<br />
<strong>扩展模式：当前vim进程有效</strong><br />
<strong>行号</strong><br />
显示：set number, 简写为set nu<br />
取消显示：set nonumber, 简写为set nonu<br />
<strong>忽略字符的大小写</strong><br />
启用：set ic<br />
不忽略：set noic<br />
<strong>自动缩进</strong><br />
启用：set ai<br />
禁用：set noai<br />
<strong>智能缩进</strong><br />
启用：smartindent 简写 set si<br />
禁用：set nosi<br />
<strong>高亮搜索</strong><br />
启用：set hlsearch<br />
禁用：set nohlsearch<br />
<strong>语法高亮</strong><br />
启用：syntax on<br />
禁用：syntax off<br />
<strong>显示Tab和换行符 ^I 和$显示</strong><br />
启用：set list<br />
禁用：set nolist<br />
<strong>配置 vi and vim文件格式</strong><br />
启用windows格式：set fileformat=dos<br />
启用unix格式：set fileformat=unix<br />
简写： set ff=dos|unix<br />
<strong>设置文本宽度</strong><br />
启用: set textwidth=65 (vim only)<br />
禁用: set wrapmargin=15<br />
<strong>设置光标所在行的标识线</strong><br />
启用:set cursorline，简写cul<br />
禁用:set no cursorline<br />
<strong>复制保留格式</strong><br />
启用: set paste<br />
禁用: set nopaste<br />
<strong>Set 帮助</strong><br />
:help option-list<br />
:set or :set all<br />
<strong>vi/vim内置帮助</strong><br />
:help<br />
:help topic<br />
Use :q to exit help<br />
vimtutor</p>

<h1 id="shell编程基础">shell编程基础</h1>

<p>1 <strong>程序</strong> ：指令+数据<br />
2 <strong>程序变成风格：</strong><br />
过程式：以指令为中心，数据服务于指令<br />
对象式：以数据为中心，指令服务于数据<br />
<strong>shell程序格：</strong>提供了编程能力，解释执行<br />
<strong>程序的执行方式</strong><br />
计算机：运行二进制指令<br />
编程语言：<br />
低级：汇编<br />
高级：<br />
编译：高级语言–&gt;编译器–&gt;目标代码<br />
java，C#<br />
解释：高级语言–&gt;解释器–&gt;机器代码<br />
shell，perl，python<br />
<strong>程序的执行方式</strong><br />
<strong>编程逻辑处理方式：</strong><br />
顺序执行<br />
循环执行<br />
选择执行<br />
<strong>shell编程：</strong> 过程式、解释执行<br />
编程语言的基本结构：<br />
各种系统命令的组合<br />
数据存储：变量、数组<br />
表达式：a+b<br />
语句：if<br />
<strong>shell脚本：</strong><br />
包含一些命令或声明，并符合一定格式的文本文件<br />
<strong>格式要求：首行shebang机制</strong><br />
#！/bin/bash<br />
#！/usr/bin/python<br />
#！/usr/bin/perl<br />
<strong>shell脚本的用途有：</strong><br />
自动化常用命令<br />
执行系统管理和故障排除<br />
创建简单的应用程序<br />
处理文本或文件<br />
<strong>创建shell脚本：</strong><br />
<strong>第一步：使用文本编辑器来创建文本文件</strong><br />
第一行必须包括shell声明序列：#！<br />
#!/bin/bash<br />
添加注释<br />
注释以#开头<br />
<strong>第二步：运行脚本</strong><br />
给予执行权限，在命令行上指定脚本的绝对或相对路径<br />
直接运行解释器，将脚本作为解释器程序的参数运行<br />
<strong>脚本规范：</strong><br />
<strong>脚本代码开头约定</strong><br />
1、第一行一般为调用使用的语言<br />
2、程序名，避免更改文件名为无法找到正确的文件<br />
3、版本号<br />
4、更改后的时间<br />
5、作者相关信息<br />
6、该程序的作用，及注意事项<br />
7、最后是各版本的更新简要说明</p>

<pre><code>#!/bin/bash
#===============================================
#Author:                MMMMM
#QQ:                xxxxxxx
#Date:              2019-02-22
#Filename:          aa.sh
#URL:               xxxxxxxxxx
#Description:           The test script
#Copyright(c):  2019ALL rights reserved
#================================================
</code></pre>

<p>1 <strong>脚本调试：</strong><br />
1、检测脚本中的语法错误<br />
bash -n /path/to/some_script<br />
2、调试执行<br />
bash -x /path/to/some_script（bash -x 两个+号表示嵌套深度）</p>

<pre><code>[root@centos7 ~]#bash -x createuser3.sh 
+ username=0
+ for i in '{1..3}'
+ read -p 'Plsease input your username: ' username
Plsease input your username: a
+ '[' -z a ']'
+ useradd a
+ echo The usera was be created
The usera was be created
</code></pre>

<p>1 <strong>变量：命名的内存空间</strong><br />
<strong>数据存储方式：</strong><br />
字符：<br />
数值：整形，浮点型<br />
<strong>变量：变量类型</strong><br />
作用：<br />
1、数据存储格式<br />
2、参与的运算<br />
3、表示的数据范围<br />
类型：<br />
字符<br />
数值：整形、浮点型<br />
<strong>引用变量要加$符号；shell脚本语言，i=10会认为10是字符串</strong><br />
<strong>变量</strong><br />
强类型：变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。一般定义变量时必须指定类型、参与运算必须符合类型要求；调用未声明变量会产生错误。<br />
如 java，c#<br />
弱类型：语言的运行时会隐式做数据类型转换。无须指定类型，默认均为字符型；参与运算会自动进行隐式类型转换；变量无须事先定义可直接调用<br />
如：bash不支持浮点数，php<br />
变量命名法则：<br />
1、不能使程序中的保留字：例如if，for<br />
2、只能使用数字、字母及下划线，且不能以数字开头<br />
3、见名知义<br />
4、统一命名规则：驼峰命名法</p>

<h2 id="bash中变量的种类">bash中变量的种类</h2>

<p>1 <strong>根据变量的生效范围等标准划分下面变量类型：</strong><br />
局部变量：生效范围为当前shell进程；对当前shell之外的其他shell进程，包括当前shell的子shell进程均无效（局部变量
有一定范围，只能在当前终端会话）<br />
环境（全局）变量：生效范围为当前shell进程及其子进程（export 全局（环境）变量定义。父进程可以往下传给子进程，子进程不能往上传）<br />
本地变量：生效范围为shell进程中某代码片段，通常指函数<br />
位置变量：$1,2，。。。。来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数<br />
特殊变量：￥？（判断命令返回值），￥0，￥*，￥@，￥#（有几个参数），￥￥进程的编号<br />
<strong>set命令可以显示所有变量，包括全局变量还是局部变量，函数</strong><br />
<strong>一般建议编写脚本时候，用完变量要用unset删除变量，不然不会释放内存空间</strong><br />
<strong>1、局部变量 有一定范围，只能在当前终端会话<br />
2、局部变量无法在其他进程体现，只能在当前shell，不能往上传，往下传<br />
3、export 全局（环境）变量定义。父进程可以往下传给子进程，子进程不能往上传<br />
4、declare -x 和export都有可以申明全局变量<br />
5、env，export也能显示所有的环境变量</strong></p>

<h2 id="环境变量">环境变量</h2>

<p>1 <strong>变量声明、赋值：</strong><br />
export name=VALUE<br />
declare -x name=VALUE<br />
2 <strong>变量引用：</strong> $name，${name}<br />
3 <strong>显示所有环境变量：</strong><br />
env<br />
printenv<br />
export<br />
declare -x<br />
4 <strong>删除变量：</strong><br />
unset name<br />
5 <strong>环境变量：</strong><br />
PATH<br />
SHELL<br />
USER<br />
UID<br />
HOME<br />
PWD<br />
SHLVLshell 嵌套深度，嵌套几次<br />
LANG<br />
MAIL<br />
HOSTNAME<br />
HISTSIZE<br />
_前一个命令最后参数<br />
6 <strong>只读和位置变量：</strong><br />
只读变量：只能声明，但不能修改和删除<br />
声明只读变量：<br />
readonly name<br />
declare -r name<br />
查看只读变量：<br />
readonly -p<br />
位置变量：在脚本代码种调用通过命令行传递给脚本的参数<br />
$1,$2,…：对应第1 、第2等参数，shift[n]换位置<br />
$0：命令本身<br />
￥*：传递给脚本的所有参数，全部参数合为一个字符串<br />
￥@：传递给脚本的所有参数，每个参数为独立字符串<br />
￥#：传递给脚本的参数的个数<br />
￥@￥\8：只在被双引号包起来的时候才会有差异<br />
set &ndash;清空所有位置变量<br />
<strong>1、常量的生命期就是这个进程的有效期<br />
declare -r 显示系统常量|readonly -p</strong><br />
<strong>2、（）小括号用法，只是一次性，因为开启了一次小shell，就在当前生效，以后不生效</strong><br />
<strong>3、（）在命令结束后不去影响这个环境<br />
4、{}会影响当前的shell环境<br />
5、小括号开启的shell不影响当前shell环境，而大括号不开启shell，会影响当前环境，共同点是把括号里的多个命令作为整体执行<br />
6、{}要加空格</strong></p>

<h2 id="shell编程基础逻辑运算">shell编程基础逻辑运算</h2>

<p>1 <strong>退出状态：</strong><br />
进程使用退出状态来报告成功或失败<br />
0：代表成功，1-255代表失败<br />
$?变量保存最近的命令退出状态<br />
如：</p>

<pre><code>ping -c1 -w1 hostdown &amp;&gt;/dev/null
echo $?
</code></pre>

<p><strong>$?返回的结果是否为0是最后一条命令决定的，但是语法错误，前面就错误了后面不执行，</strong></p>

<p><strong>exit就是退出后面写多少就是返回多少，可以不让$?为0</strong><br />
2 <strong>退出状态码：</strong><br />
bash自定义退出状态码<br />
exit[n]：自定义退出状态码<br />
注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字<br />
注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令 的状态码<br />
<strong>exit退出当前shell 在脚本就是退出当前脚本</strong></p>

<p>3 <strong>算数运算：</strong><br />
bash中的算数运算：help let<br />
+,-, <em>,/,%取模（取余）,**（乘方）<br />
实现算数运算：<br />
1、let var =算术表达式<br />
2、var=￥[算术表达式]<br />
3、var=￥((算术表达式))<br />
4、var=￥(expr arg1 arg2 arg3 …)<br />
5、declare -i var =数值<br />
6、echo ‘算数表达式’ |bc<br />
乘法符号有些场景中需要转义，如</em><br />
bash有内建的随机数生成器：$RANDOM（0-32767）<br />
echo $[￥RANDOM%50]:0-49之间随机数</p>

<p><strong>expr命令本身就是做运算</strong></p>

<p>0 false<br />
1 true<br />
&amp; 并且and<br />
| 或者 or<br />
0&amp;0=0<br />
0&amp;1=0<br />
1&amp;0=0<br />
1&amp;1=1<br />
0|0=0<br />
1|0=1<br />
0|1=1<br />
1|1=1<br />
短路与 &amp;&amp;<br />
0&amp;&amp;0=0<br />
0&amp;&amp;1=0<br />
1&amp;&amp;0=0<br />
1&amp;&amp;1=1<br />
cmd1 &amp;&amp; cmd2<br />
<strong>如果cmd1=0为假， cmd2不需要执行，反之cmd1为真，需要cmd2执行<br />
短路或 | |<br />
如果cmd1为真，cmd2不需要执行，反之cmd1为假，需要cmd2执行</strong><br />
XOR 异或<br />
0^1=1<br />
0^0=0<br />
1^0=1<br />
1^1=0<br />
<strong>一样就假，不一样就真，同性相斥，异性相吸</strong></p>

<p>4 <strong>赋值：</strong><br />
增强型赋值：<br />
+ =,- =,/=/%=<br />
let varOPERvalue：<br />
例如：let count+=3<br />
自加3后自赋值<br />
自增，自减：<br />
let var+=1<br />
let var ++<br />
let var -=1<br />
let var –</p>

<p>5 <strong>逻辑运算：</strong><br />
非：！<br />
！1=0<br />
！0=1<br />
短路运算<br />
短路与<br />
第一个为0，结果必定为0<br />
定一个为1，第二个必须要参与运算<br />
短路或<br />
第一个为1，结果必定为1<br />
定一个为0，第二个必须要参与运算<br />
异或：^<br />
异或d 两个值，相同为假，不同为真</p>

<p>6 <strong>bash的快捷键：</strong><br />
ctrl +a：光标移到命令行首，相当于Home<br />
ctrl +e：光标移到命令行尾，相当End<br />
ctrl +f：光标向右移动一个字符<br />
ctrl +b：光标向左移动一个字符<br />
alt +f：光标向右移动一个单词尾<br />
alt +b：光标向左移动一个单词首<br />
ctrl +xx：光标在命令行首和光标之间移动<br />
ctrl +u：从光标处删除至命令行首<br />
ctrl +k：从光标处删除至命令行尾<br />
alt +r：删除当前整行<br />
ctrl +w：从光标处向左删除至单词首<br />
alt +d：从光标处向右删除至单词尾<br />
ctrl +d：删除光标处的一个字符<br />
ctrl +h：删除光标前的一个字符<br />
ctrl +y：将删除的字符粘贴至光标后<br />
atl +c：从光标处开始向右更改位首字母大写的单词<br />
alt +u：从光标处开始,将右边一个单词更改为大写<br />
alt +l：从光标处开始,将右边一个单词更改为小写<br />
ctrl +t：交换光标处和之前的字符位置<br />
alt+t：交换光标处和之前的单词位置<br />
alt+N：提示输入指定字符后，重复显示该字符N次<br />
注意：alt组合快捷键经常和其他软件冲突</p>

<p>7 <strong>条件测试：</strong><br />
判断某需求是否满足，需要由测试机制来实现<br />
专用的测试表达式需要由测试命令复制完成测试过程<br />
评估布尔声明，以便用在条件性执行中<br />
若真，则返回0<br />
若假，则返回1<br />
测试命令：<br />
test EXPRESSION<br />
[EXPRESSION]<br />
[[EXPRESSION]]<br />
注意：EXPRESSION 前后必须有空白字符</p>

<p>8 <strong>bash的字符串测试：</strong><br />
=：是否等于<br />
&gt;：ascii码是否大于ascii码<br />
!=：是否不等于<br />
=~：左侧字符串是否能够被右侧的PATTERN所匹配，注意：此表达式一般用于[[]]中；扩展的正则表达式<br />
-z&rdquo;STRING&rdquo;字符串是否为空，空为真，不空为假<br />
-n&rdquo;STRING&rdquo;字符串是否不空，不空为真，空为假<br />
<strong>注意：用于字符串比较时 用到的操作数都应该使用引号</strong></p>

<p>9 <strong>逻辑运算：</strong><br />
非：！<br />
！1=0<br />
！0=1<br />
短路运算<br />
短路与<br />
第一个为0；结果必定为0<br />
第一个为1；第二个必须要参与运算<br />
短路或<br />
第一个为1；结果必定为1<br />
第一个为0；第二个必须要参与运算<br />
异或：^<br />
异或的两个值，相同为假，不同为真</p>

<p>10 <strong>条件性的执行操作符：</strong><br />
根据退出状态而定，命令可以有条件地运行<br />
&amp;&amp;代表条件性的 and then<br />
||代表条件性的or else<br />
例如：<br />
grep -q no_such_user /etc/passwd ||echo ‘no such user’<br />
no such user<br />
ping -c1 -w2 station1 &amp;&gt;/dev/null &amp;&amp; echo ‘station1 is up’ || (echo ‘station
is unreachable’ ;exit 1)<br />
station is up<br />
长格式的例子：<br />
test “ A &ldquo; = &rdquo; A&rdquo; =&rdquo; A&rdquo;=&ldquo;B” &amp;&amp;echo “String are equal”<br />
test “ A &ldquo; − e q &rdquo; A&rdquo; -eq &ldquo; A&rdquo;−eq&rdquo;B” &amp;&amp; echo “Integers are equal”<br />
简写格式的例子：<br />
[ “ A &ldquo; = &rdquo; A&rdquo; = &ldquo; A&rdquo;=&ldquo;B” ] &amp;&amp;echo “String are equal”<br />
[ “ A &ldquo; − e q &rdquo; A&rdquo; -eq &ldquo; A&rdquo;−eq&rdquo;B” ] &amp;&amp; echo “Integers are equal”</p>

<p>11 <strong>bash的文件权限测试：</strong><br />
文件权限测试：<br />
-r FILE：是否存在且可读<br />
-w FILE：是否存在且可写<br />
-x FILE：是否存在且可执行<br />
文件特殊权限测试：<br />
-u FILE：是否存在且拥有suid权限<br />
-g FILE：是否存在且拥有sgid权限<br />
-k FILE：是否存在且拥有sticky权限<br />
存在性测试：<br />
-a FILE：同-e<br />
-e FILE：文件存在测试，存在为真，否则为假<br />
存在性及类别测试：<br />
-b FILE：是否存在且为块设备文件<br />
-c FILE：是否存在且为字符设备文件<br />
-d FILE：是否存在且为目录文件<br />
-f FILE：是否存在且为普通文件<br />
-h FILE 或 -l FILEE：存在且为符号链接文件<br />
-p FILE：是否存在且为命名管道文件<br />
-S FILE：是否存在且为套接字文件<br />
文件大小测试：<br />
-s FILE：是否存在且非空<br />
文件是否打开<br />
-t fd：fd文件描述符是否在某终端<br />
-N FILE：文件自从上一次被读取之后是否被修改过<br />
-O FILE：当前有效用户是否为文件属主<br />
-G FILE：当前有效用户是否为文件数组<br />
双目测试：<br />
FILE -ef FILE2：FILE1是否是FILE2的硬链接<br />
FILE -nt FILE2：FILE1是否新于FILE2（mtime）<br />
FILE -ot FILE2：FILE1是否旧于FILE2</p>

<p>12 <strong>bash的文件权限测试：</strong><br />
第一种方式：<br />
COMMAND1&amp;&amp; COMMAND2 并且<br />
COMMAND1|| COMMAND2 或者<br />
!COMMAND非<br />
如： [[-r FILE]] &amp;&amp; [[-w FILE]]<br />
第二种方式：<br />
EXPRESSION1 -a EXPRESSION2 并且<br />
EXPRESSION1 -o EXPRESSION2 或者<br />
!EXPRESSION<br />
必须使用测试命令进行<br />
示例：<br />
[ -z “$HOSTNAME” -o $HOSTNAME == “localhost”] &amp;&amp; hostname 1111<br />
[ -f /bin/cat -a -x /bin/cat ] &amp;&amp; cat /etc/fstab</p>

<p>13 <strong>使用read命令来接受输入：</strong><br />
使用read来把输入值分配给一个或多个shell变量<br />
-p 指定要显示的提示<br />
-s 静默输入，一般用于密码<br />
-n N指定输入的字符长度N<br />
-d &lsquo;字符’输入结束符<br />
-t N TIMEOUT为N秒<br />
read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量<br />
read -p &ldquo;Enter a filename:&ldquo;FILE<br />
<strong>read默认是给变量赋值</strong></p>

<p>14 <strong>防止扩展：</strong><br />
反斜线()会使随后的字符按原意解释<br />
$ echo Your cost : \￥5.00<br />
Your cost : \￥5.00<br />
加引号来防止扩展<br />
单引号(’)防止所有扩展<br />
双引号(&ldquo;)也防止所有扩展，但是一下情况例外：<br />
￥（美元符号） -变量扩展<br />
`（反引号）-命令替换<br />
(反斜线) - 禁止单个字符扩展<br />
！（叹号） -历史命令替换<br />
15 <strong>注意：</strong><br />
<strong>检查参数个数和是否是数字要用[[]]和扩展正则表达式</strong><br />
<strong>test =[]中括号，=两边要空格，不空为赋值</strong><br />
<strong>-eq相等，-ne不相等，-lt小于，-le小于等于，-gt大于，-ge大于等于</strong><br />
<strong>test 还支持文件系统<br />
-f是否是不同文件（前面是-的就是普通文件）<br />
-a从-e判断文件是否存在<br />
-b判断文件是否块文件<br />
-d是否是文件夹<br />
-L是否是软连接<br />
-w是否可写，针对普通用户<br />
-x是否可执行，针对普通用户</strong><br />
<strong>会判断指向的，而不是判断本身的</strong><br />
<strong>-n是否不为空</strong><br />
<strong>-v是判断这个变量是否设置了，是否有值</strong><br />
<strong>-z判断长度是否为0是否为空</strong><br />
<strong>-eq是比较数字的 =是比较字符串的</strong><br />
<strong>【【】】是正则表达式，不用正则表达式一般用[]一个中括号</strong><br />
总结：<br />
shell<br />
变量：局部（当前shell）和环境（可以传给子shell）<br />
1 , 1, 1,@当做单个参数， ∗ 当 作 整 个 参 数 , * 当作整个参数, ∗当作整个参数,#参数个数，$0脚本名字<br />
set unset export declare -i定义数字变量 -r只读的 -x环境变量 env</p>

<p>16 <strong>实例：判断一个用户否存在，且用112233做密码</strong><br />
id $1 &amp;&gt;/dev/null<br />
[ $? -eq 0 ] &amp;&amp; echo user is exist &amp;&amp; exit<br />
useradd $1<br />
echo 112233| passwd &ndash;stdin &amp;&gt;/dev/null<br />
echo “$1” is created<br />
<strong>小括号会开启子shell，大括号不会退出当前脚本</strong></p>

<h2 id="bash的配置文件">bash的配置文件</h2>

<p>按生效范围划分，存在两类：<br />
全局配置：<br />
/etc/profile<br />
/etc/profile.d/*.sh<br />
/etc/bashrc<br />
个人配置：<br />
~/.bash_profile<br />
~/.bashrc<br />
<strong>etc全局<br />
~家目录 单个用户</strong><br />
<strong>bash——profile 可改PATH路径</strong><br />
<strong>profile配置文件</strong></p>

<p><strong>/etc/profile 和 .bash_profile /etc/bashrc和.bashrc中的区别<br />
登录时的执行顺序</strong></p>

<p>1 <strong>shell登录两种方式</strong><br />
交互式登录：<br />
（1）直接通过终端输入账号密码登录<br />
（2）使用&rdquo;su -UserName&rdquo;切换的用户<br />
执行顺序：/etc/profile–&gt;/etc/profile.d/*.sh–&gt;/.bash_profile–&gt;/.bashrc–&gt;/etc/bshrc<br />
非交互式登录：<br />
（1）su UserName<br />
（2）图形界面下打开的终端<br />
（3）执行脚本<br />
（4）任何其他的bash实例<br />
执行顺序：~/.bashrc–&gt;/etc/bashrc–&gt;/etc/profile.d/*sh</p>

<p>2 <strong>Profile类</strong><br />
按功能，存在两类：<br />
profile类额bashrc类<br />
profile类：为交互式登录的shell提供配置<br />
全局：/etc/profile,/etc/profile.d/*.sh<br />
个人：~/.bash_profile<br />
功用<br />
1、用于定义环境变量<br />
2、运行命令或脚本<br />
<strong>profile 放环境变量和启动程序</strong><br />
<strong>bashrc放别名和函数</strong></p>

<p>3 <strong>Bash 退出任务</strong><br />
保存在~/.bash_logout文件中（用户）<br />
在退出登录shell时运行<br />
用于<br />
创建自动备份<br />
清楚临时文件<br />
<strong>注销初始化<br />
希望退出的时候 初始化 ，自动执行某个操作</strong><br />
<strong>vim 。bash_logout</strong></p>

<p>4 <strong>$-变量</strong><br />
h：hashall，打开这个选项后，shell会将命令所在的路径hash下来，避免每次都要查询。通过set +h将h选项关闭<br />
i：interactive-comments，包含这个选项说明当前的shell是一个交互式的shell。所谓的交互式shell，在脚本中，i选项是关闭的。<br />
m：monitor，打开监控模式，就可以通过Job control来控制进程的停止、继续，后台或者前台执行等。<br />
B：braceexpand，大括号扩展<br />
H：history，H选项打开，可以展开历史列表中的命令，可以通过！感叹号来完成，例如“！！”返回上最近的一个历史命令，&rdquo;!n&rdquo;返回第n个历史命令</p>

<p><strong>上 一 个 命 令 的 最 后 参 数 ∗ ∗ ∗ ∗ _上一个命令的最后参数</strong> ** 上​一个命令的最后参数∗∗∗∗-代表一些功能的复合**<br />
<strong>h=hash</strong><br />
<strong>i=当前是否是一个交互式的shell 可查看脚本批量执行还是交互式会问你是否执行</strong><br />
<strong>m=前后执行<br />
b大括号扩展<br />
H扩展代表history历史</strong></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>