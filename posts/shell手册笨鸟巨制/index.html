<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell手册笨鸟巨制 | 开发者问答集锦</title>
    <meta property="og:title" content="shell手册笨鸟巨制 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell手册笨鸟巨制">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E6%89%8B%E5%86%8C%E7%AC%A8%E9%B8%9F%E5%B7%A8%E5%88%B6/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell手册笨鸟巨制</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>============================================================================================================================</p>

<p>09年，鸟人刚接触linux环境，用ssh终端连上服务器，两眼一黑（啥命令也不会）&hellip;..</p>

<p>每次把成老师在我电脑上操作的命令用history找到记录下来，避免重复问他相同的问题&hellip;</p>

<p>后来把工作中用到的新命令、从《shell编程..》学到的用法也记录下来&hellip;</p>

<p>于是，一个临时的txt文件变成了现在这个样子(日常命令几乎都可以搜到)&hellip;.</p>

<p>============================================================================================================================</p>

<p>#! /bin/sh<br />
Shell脚本中用#表示注释，相当于C语言的//注释。但如果#位于第一行开头，并且是#!（称为Shebang）则例外，它表示该脚本使用后面指定的解释器/bin/sh解释执行。</p>

<p>shell注释&ndash;&gt;<br />
A、方法一<br />
:&lt; &hellip;.注释内容<br />
&lsquo;BLOCK<br />
B、方法二<br />
:&lt; &hellip;.注释内容<br />
BLOCK&rsquo;<br />
C、方法三</p>

<p>:&lt; &hellip;.注释内容<br />
&rsquo;<br />
以上三种方法都是通过在:&lt;</p>

<p>BLOCK为Here Documents中的定义符号可以随意起名，只要前后匹配就行了</p>

<dl>
<dt>或者：<br /></dt>
<dd>cat &lt; this<br />
is<br />
a<br />
multi-<br />
line<br />
comment<br />
EOF<br />
<br />
<br /></dd>
</dl>

<dl>
<dt>或者：<br /></dt>
<dd>cat &lt; this<br />
is<br />
a<br />
multi-<br />
line<br />
comment<br />
EOF<br />
<br />
<br /></dd>
</dl>

<p>EOF</p>

<p>eval的作用是再次执行命令行处理，也就是说，对一个命令行，执行两次命令行处理。<br />
eval echo &ldquo;\$$#&rdquo; 输出最后一个参数，不用eval的话只能输出$number,还不是$number中存储的数据</p>

<p>getopts一般格式为：<br />
getopts option_string OPTION
将所有以连字符开头的参数作为变量与option_string对比，如果匹配成功，变量设置成OPTION的值，如果未发现匹配字符，把？设置成其值<br />
getopts ahfvc: OPTION 选项a、h、f、v可以不加实际值进行传递，而选项c必须取</p>

<p>sort -u -n xx.log |wc -l</p>

<p>du -sh * | sort -h #sort -h &ndash;human-numeric-sort<br />
compare human readable numbers (e.g., 2K 1G)</p>

<p>ls /home/mysql/bigman/wom_weibo_sina* | xargs du -cb 统计指定文件的总大小<br />
vi 中添加和去除行号<br />
显示行号 :set number 或 :set nu<br />
去除行号 :set nonumber 或 :set nonu</p>

<p>vi中水平分页编辑 :vsplit another_file<br />
vi中竖直分页编辑 :sp another_file<br />
上述两种，用ctrl+w+w进行切换 ctrl+w再加hjkl方向键可以选择tab页</p>

<dl>
<dt>vi中用标签页编辑 :</dt>
</dl>

<p>:tabe[dit] another_file</p>

<dl>
<dt>向后切换 {num}gt =&gt; gt3gt 4gt 5gt （带数字的是以第一个标签页为基准，而不是当前标签页为基准）</dt>
</dl>

<p>:tabn[ext] {num} =&gt;:tabnext 2;:tabnext</p>

<dl>
<dt>向前切换 {num}gT =&gt; gT 3gT4gT 5gT （带数据的是以当前标签页为基准，不是以第一个标签页为基准）</dt>
</dl>

<p>:tabN[ext] {num} =&gt;:tabNext 2;:tabNext</p>

<p>切到第一个标签页 :tabfir[st]</p>

<p>切到最后一个标签页 :tabl[ast]</p>

<p>把当前标签页移到第N个标签页之后 :tabm[ove] [N]</p>

<p>对所有标签页执行命令 :tabd[o] {cmd}</p>

<p>关闭标签页 :tabc[lose] {num}</p>

<p>关闭其他所有标签页 :tabonly</p>

<p>关闭所有标签页:qa</p>

<p>把复制(yank)的文本粘贴到文件中用p就行了(要粘贴到上一行用P)，那么如果要粘贴到:命令行里面呢&ndash;&gt; ctrl+r &ldquo;</p>

<p>一次性打开多个文件用标签页编辑 vi -p one_file anther_file third_file</p>

<dl>
<dt>有时候文件过多，一次没法全部打开（vim -p 默认一次最多打开9或10个），可以用set tabpagemax=30修改默认的最大tab页限制，或者：</dt>
<dt>:tab ball show each buffer in a tab (up to &lsquo;tabpagemax&rsquo; tabs)</dt>
<dt>:tab help open a new help window in its own tab page</dt>
<dt>:n 编辑下一个文档。<br />
:2n 编辑下两个文档。<br />
:N 编辑上一个文档。注意，该方法只能用于同时打开多个文档。<br />
:e 文档名 这是在进入vim后，不离开 vim 的情形下打开其他文档。<br />
:e# 或 Ctrl+ˆ 编辑上一个文档,用于两个文档相互交换编辑时使用。?# 代表的是编辑前一次编辑的文档<br />
:files 或 :buffers 或 :ls 可以列出目前 缓冲区 中的所有文档。加号 + 表示
缓冲区已经被修改过了。＃代表上一次编辑的文档，%是目前正在编辑中的文档<br />
:b 文档名或编号 移至该文档。<br />
:f 或 Ctrl+g 显示当前正在编辑的文档名称。<br />
:f 檔名 改变编辑中的文档名。(file)</dt>
</dl>

<p>想要grep在代码目录中查找目标片段，并编辑所有命中的文件？ grep -rn &lsquo;Utils&rsquo; . | awk -F: &lsquo;{print $1}&rsquo; |sort
-u | tr &lsquo;\n&rsquo; &lsquo; &rsquo; 对于结果，执行vim -p即可</p>

<p>vim查看一个正在被其他进程修改的文件时需要reload文件，:e</p>

<p>vi中执行shell命令 :!your_cmd 这样可以用:!ls :!gcc 等等 很方便</p>

<p>在普通模式下，可使用 yaw 命令复制当前光标所在单词,用daw删除光标所在单词</p>

<p>bash下用!your_cmd_header可以调用上一个以这个开头的命令，比如你签名用了yum search xx，现在!yum就可以调用这个命令</p>

<p>和上面类似的命令是ctrl+r，输入命令头&hellip;（mysql命令行也有这个功能,只是mysql在没找到想要sql而非预期SQL把命令行占据时不能用ctrl+c取消，应该用ctrl+a,ctrl+k，Linux下命令行一般不是vim兼容的就是emacs兼容的）</p>

<p>ctrl+a 跳到mysql命令行开头</p>

<p>ctrl+u 从光标位置删到行首</p>

<p>ctrl+k 从光标位置删到行末</p>

<p>crtl+v列的virtual模式<br />
v是行的virtual模式<br />
在vi里面 gd是找定义位置或当前文件第一次出现的位置 可以用于高亮文本（类似于/sss查找）<br />
在vi里面 shift+k可以直接打开当前函数的man 1页面</p>

<dl>
<dt>折叠(<a href="http://vim.wikia.com/wiki/Folding">http://vim.wikia.com/wiki/Folding</a>)</dt>
</dl>

<p>:set fdm=indent
按照同样的缩进折叠，极适合Lua，所有function都折起来了(<code>foldmethod</code>，默认foldmethod=<code>manual</code>，即用zf手动折叠；其他方式是<code>syntax</code>、<code>expr(</code>自定义折叠规则))</p>

<p>zR一次性打开所有折叠</p>

<p>在Visual模式建立选中代码块的折叠 zf</p>

<p>建立折叠(对光标所在的大括号的代码块建立折叠) zfa{</p>

<p>zf + 数字 + 方向键，折叠</p>

<p>展开折叠 zo</p>

<p>zO 对所在范围内所有嵌套的折叠点展开</p>

<p>关闭折叠 zc</p>

<p>zC 对所在范围内所有嵌套的折叠点进行折叠</p>

<p>视情况展开或关闭折叠 za</p>

<p>删除光标处折叠 zdr</p>

<p>x 删除当前光标下的字符<br />
dw 删除光标之后的单词剩余部分（跟按w向前按照单词移动一样）</p>

<p>db 删除光标之前的单词剩余部分（跟按b向后按照单词移动一样）<br />
d$ 删除光标之后的该行剩余部分（跟按￥移到行末一样）</p>

<p>d0 删除光标之前的该行剩余部分（跟按0移到行首一样）<br />
dd 删除当前行。</p>

<p>v加方向键选中内容后，可用d将选中部分删除</p>

<p>d + num + 方向键 向上或向下（箭头或者jk都行哦）删除num行（num去除自身以外的行数）</p>

<p>y 复制也有上述使用方法</p>

<p>vim设置字体颜色</p>

<p>[root@localhost server]# ls /usr/share/vim/vim72/colors/<br />
blue.vim default.vim desert.vim evening.vim morning.vim pablo.vim README.txt
shine.vim torte.vim<br />
darkblue.vim delek.vim elflord.vim koehler.vim murphy.vim peachpuff.vim
ron.vim slate.vim zellner.vim<br />
[root@localhost server]# cat ~/.vimrc<br />
:colorscheme desert</p>

<p>在vim已打开的状态下，用:colorscheme desert也可切换到对应的颜色方案！</p>

<p>对于公用的机器和用户，不想忍受别人的颜色方案可以在当前连接上建立一个别名，这样就可以自己用自己喜欢的样式了</p>

<p>alias vim=&lsquo;vim &ndash;cmd &ldquo;:colorscheme desert&rdquo;&rsquo;</p>

<p>alias vim=&lsquo;vim &ndash;cmd &ldquo;:colorscheme desert&rdquo; &ndash;cmd &ldquo;:set number&rdquo;&rsquo;</p>

<p>vim &ndash;cmd &ldquo;:colorscheme desert&rdquo; &ndash;cmd &ldquo;:set number&rdquo; &ndash;cmd &ldquo;:set tabstop=4
shiftwidth=4 expandtab&rdquo;</p>

<p>vim设置折叠的颜色<br />
默认是一个灰白条，有些干扰思维，可在 $HOME/.vimrc 这样设置</p>

<p>:highlight Folded term=standout ctermfg=4 ctermbg=0</p>

<p>把vim tab的长度设成4个空格：在.vimrc中加入set tabstop=4</p>

<p>vim中的tab自动用四个空格替换：set tabstop=4 shiftwidth=4 expandtab</p>

<p>不要用空格替换tab的命令 :set noexpandtab</p>

<p>vim中空格(2个/4个)跟tab之间切换： :%s/ /\t/g :%s/\t/ /g</p>

<p>遇到疑难可参考：<a href="http://stackoverflow.com/questions/426963/replace-tab-with-spaces-in-">http://stackoverflow.com/questions/426963/replace-tab-with-spaces-in-</a>
vimhttp://stackoverflow.com/questions/9104706/how-can-i-convert-spaces-to-
tabs-in-vim-or-linux</p>

<p>vim中方向键移动光标很慢：</p>

<p>w（word）往前按单词移动</p>

<p>b（back）往后按单词移动</p>

<p>0跳至行首（等同于home键）</p>

<p>$跳至行末（等同于end键）</p>

<p>%跳至对应的符号另一端，比如从{到}，从(到)</p>

<p>&lsquo;0 回到上次编辑的位置<br />
vim +n urfile // n为行号，打开后光标定位到指定行<br />
vim + urfile //打开文件后光标定位到最后一行</p>

<p>nl fileName 列出文件内容和行号(后面可以跟多个文件)<br />
11 ln -sf /home/team/www html 后面的是连接文件，前面的是实际文件<br />
185 passwd xudongsong 修改密码（此为root用法） 普通用户修改自己的密码时，只需passwd<br />
332 tar zvxf /tmp/ldapman.tar.gz 解压缩<br />
tar jvxf ffmpeg-git-01fcbdf.tar.bz2<br />
tar zvcf xxx.tar.gz xxx/ 压缩 （想快速打包而不压缩就去掉z）<br />
/usr/bin/unrar x civ-server.rar 解压缩rar压缩文件</p>

<p>unzip xxx.zip 解压缩zip压缩文件</p>

<p>zip -r xxx.zip a.txt bDir 压缩文件</p>

<p>更全面的压缩、解压缩可参考这位仁兄的博客<a href="http://blog.csdn.net/zzcv_/article/details/2801582">http://blog.csdn.net/zzcv_/article/details/2801582</a></p>

<p>448 netstat -lntp 查看监听端口<br />
mysql -h10.4.4.1 -u root -p &ndash;default-character-set=utf8<br />
562 id 显示登陆者的信息</p>

<p>LINUX、BSD的echo需要用-n阻止自动换行、用-e提醒bash处理转义字符\ (用了-e，可以用\c阻止自动换行)，系统V可以直接用\c阻止自动换行<br />
echo -n &ldquo;hello&rdquo; 阻止输出后自动换行<br />
echo -e &ldquo;hello\tworld\c&rdquo; 使得输出的转义字符生效<br />
echo &ldquo;hello,world&rdquo; &gt; /tmp/test.log 重定向，覆盖<br />
echo &ldquo;hello,world&rdquo; &gt;&gt; /tmp/test.log 重定向，追加<br />
shell脚本前面最好加上#!/bin/bash<br />
因为在当前bash下用./tt.sh执行tt.sh脚本当然使用当前bash执行<br />
如果在python用popen(&ldquo;./tt.sh&rdquo;)执行就不一定了，可能是/bin/sh在执行脚本哦，/bisn/sh是dash不是bash。这样的话脚本里面的echo
&ldquo;abc\ndef&rdquo;对&rsquo;\n&rsquo;的处理是一样的（肯定还有其他的区别，只是我栽在这个\n上面了）<br />
cat file1 file2<br />
cat file1 file2 &gt; /tmp/allfile<br />
cat &gt; /tmp/newfile (ctrl+D结束新文件输入)<br />
cat -v file 显示控制字符(检查ftp从DOS传过来的文件)<br />
dos2unix file 把dos下的那些控制符转换成linux格式</p>

<p>paste file1 file2 把两个文件的各行连在一起作为新行打印出来<br />
split -1 file1.txt 文件分割，按照一行一个文件分割<br />
611 rpm -ql httpd<br />
[dongsong@tm4ctt143 ~]$ who<br />
dongsong pts/0 2011-02-18 10:08 (10.4.6.120)</p>

<p>awk 在<br />
awk 有很多字符串处理函数、数字处理函数、时间函数等，功能强大，用man可以看到，length(),
substr(),tolower(),toupper()&hellip;<br />
[dongsong@tm4ctt143 ~]$ who | awk &lsquo;{print $1&rdquo;\t&rdquo;$3&rdquo;\t&rdquo;$2}&rsquo;
awk可以控制输出那个字段(域标记从$1开始，如果用$0则表示所有域，$NF表示最后一个域$(NF-1)表示倒数第二个域)<br />
dongsong 2011-02-18 pts/0</p>

<p>cat /etc/passwd | awk -F: &lsquo;{print $1}&rsquo; awk -F 是以字符分割<br />
awk &lsquo;{print $2}&rsquo; data..f<br />
awk &lsquo;{if($1==&ldquo;265919437&rdquo;) print $1}&rsquo; active_22_122999_20110209.log<br />
awk &lsquo;{if($1~/265919437/) print $1}&rsquo; active_22_122999_20110209.log<br />
awk &lsquo;{if($1!~/265919437/) print $1}&rsquo; active_22_122999_20110209.log<br />
cat /tmp/debug_ips.log |sort |awk &lsquo;{if($1==line){count++;} else{if(count&gt;0)
print count;count=1;} line=$1;} END {print count;}&lsquo;|awk &lsquo;{if($1&gt;1) print
$1}&lsquo;|wc -l</p>

<p>[dongsong@tm4ctt143 shell_study]$ echo adsfafds|awk &lsquo;{print substr($0, 1)}&rsquo;<br />
adsfafds<br />
[dongsong@tm4ctt143 shell_study]$ echo adsfafds|awk &lsquo;{print substr($0, 1, 2)}&rsquo;<br />
ad</p>

<p>cat /tmp/t | awk &lsquo;{t=t&rdquo;info[\&ldquo;&rdquo;$2&rdquo;\&ldquo;],&rdquo;} END {print t;}&rsquo;</p>

<p>[dongsong@localhost kl-robot]$ echo
&lsquo;entryId,pos,count,remainTime,isBinding,type&rsquo; | tr &lsquo;,&rsquo; &lsquo;\n&rsquo; | awk
&lsquo;{t=t&rdquo;info[\&ldquo;&rdquo;$0&rdquo;\&ldquo;],&rdquo;} END {print t;}&rsquo;<br />
info[&ldquo;entryId&rdquo;],info[&ldquo;pos&rdquo;],info[&ldquo;count&rdquo;],info[&ldquo;remainTime&rdquo;],info[&ldquo;isBinding&rdquo;],info[&ldquo;type&rdquo;],</p>

<p>两种计算字符串长度的方法，注意区别，awk取得的是准确值</p>

<p>[dongsong@tm4ctt143 shell_study]$ echo &ldquo;sfff&rdquo;|wc -c<br />
5<br />
[dongsong@tm4ctt143 shell_study]$ echo &ldquo;sfff&rdquo;|awk &lsquo;{print length($0)}&rsquo;<br />
4<br />
[dongsong@tm4ctt143 shell_study]$ read testStr<br />
a(后面四个空格)<br />
[dongsong@tm4ctt143 shell_study]$ echo $testStr|awk &lsquo;{print length($0)}&rsquo;<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ echo $testStr|wc -c</p>

<p>2</p>

<p>grep -i 忽略大小写<br />
tail -f api.log -n 100 | grep -e statuses__mentions -e eats 根据多个短语过滤<br />
[dongsong@tm4ctt143 ~]$ df | awk &lsquo;{print $1}&rsquo;| grep -v &ldquo;Filesystem&rdquo; grep -v xx
不显示包含xx的条目<br />
/dev/sda3<br />
/dev/sda1<br />
tmpfs<br />
dongsong@tm4ctt143 ~]$ df | awk &lsquo;{print $1}&rsquo;| grep -v &ldquo;Filesyst&rdquo; | sed
s&rsquo;/\/dev\///g&rsquo; 再用管道传过去给sed处理一下<br />
sda3<br />
sda1<br />
tmpfs</p>

<p>[dongsong@tm4ctt143 ~]$ who | tee who.out tee，谐音T，输出到screen的同时输出一个副本到文件中去</p>

<p>tee -a #append</p>

<p>dongsong pts/0 2011-02-18 10:08 (10.4.6.120)</p>

<p>tee -a file -a追加到文件末尾</p>

<p>command &gt; filename 把把标准输出重定向到一个新文件中<br />
command &gt;&gt; filename 把把标准输出重定向到一个文件中(追加)<br />
command 1 &gt; fielname 把把标准输出重定向到一个文件中<br />
command &gt; filename 2&gt;&amp;1 把把标准输出和标准错误一起重定向到一个文件中<br />
command 2 &gt; filename 把把标准错误重定向到一个文件中<br />
command 2 &gt;&gt; filename 把把标准输出重定向到一个文件中(追加)<br />
command &gt;&gt; filename 2&gt;&amp;1 把把标准输出和标准错误一起重定向到一个文件中(追加)<br />
command &lt; filename &gt;filename2 把c o m m a n d命令以f i l e n a m e文件作为标准输入，以f i l
e n a m e 2文件<br />
作为标准输出<br />
command &lt; filename 把c o m m a n d命令以f i l e n a m e文件作为标准输入<br />
command &lt;&lt; delimiter 把从标准输入中读入，直至遇到d e l i m i t e r分界符<br />
command command &gt;&amp;m 把把标准输出重定向到文件描述符m中<br />
command<br />
&gt; file 创建一个长度为0的文件</p>

<p>command&lt; [dongsong@tm4ctt143 ~]$ read var1 &lt;&lt; hello<br />
&gt; look<br />
&gt; hello<br />
[dongsong@tm4ctt143 ~]$ echo $var1<br />
look<br />
777 netstat -a<br />
ls -l | grep ^d 只显示目录文件<br />
972 histpry |less<br />
973 touch hello.php</p>

<p>touch -t 05042140 test.txt 创建一个更改时间是5月4号21：90的文件<br />
find . -newer test.txt 寻找比test.txt更新的文件<br />
find . -newer !test.txt 与上面相反<br />
find . -type d 查找当前目录下的目录<br />
find . ! -type d | sort 查找当前目录下除目录以外的文件，后面管道加上sort是排序<br />
find . -type f -mtime -10 -print -mount -exec wc -l {} \;<br />
find . -type f -mtime -10 -print -mount |xargs wc -l
与上面等同，只是xargs一批一批的执行，exec把前面所有的当成参数一次执行()<br />
find . -name &ldquo;*.cpp&rdquo; | xargs grep &ldquo;int&rdquo; 在文件中查找int<br />
ls *.sql | grep -v 2011-11-17 | xargs rm 删除名字不含2011-11-17字样的sql文件<br />
ifconfig<br />
netstat -lntp<br />
tcpdump -i lo port 389 -s 1000000 -A -vv<br />
tcpdump -i lo -s 10000 -A -w /home/team/ddd port 389 抓包<br />
tcpdump -i eth0 -s 10000 -A -nnn host 10.0.4.133 and port 80</p>

<p>tcpdump -i eth0 -nnn port 1234</p>

<p>-nnn是显示数字，便于直接观看结果</p>

<p>find . -name &ldquo;*server.conf&rdquo; | xargs -I {} cp {} /tmp/
对符合条件的文件做copy，-I是做替换，把管道输出东西替换到后面位置上（man xargs)。也可以尝试下面的方式</p>

<p>find dir1 -maxdepth 1 -type f -exec cp -t dir2 {} +</p>

<p>今天（2014.7.17）遇到一个问题是系统有tcpdump但是用yum
list看发现不是yum源里面的，而系统自带的这个只能打印非常简陋的信息，从yum装一个就正常了</p>

<p>/usr/sbin/tcpdump -i eth0 -s 1000 -nnn host 10.6.10.140 and port 5630 &gt;
/tmp/tcpdump.log 2&gt;&amp;1 &amp;</p>

<p>tcpdump -i eth0 port 1234 -w xxx.txt<br />
-w把抓包的数据写入文件，可以在win下面用wireshark查看网络数据</p>

<p>netstat -lntp<br />
stty -a<br />
kill -s<br />
kill -a<br />
kill -l<br />
205 gcc -o server Makefile<br />
206 ./server<br />
218 cscope -b -R *.cpp<br />
239 mv ../gamechat ./<br />
251 stty -a<br />
252 kill -9 进程号<br />
280 make deps<br />
281 make<br />
290 scripts/ctt_chatserver.sh start<br />
294 scripts/ctt_chatserver.sh status<br />
312 ./chat_client -k xdfeWscTsx434KXDscdESxm_wXd 10.4.3.143:8800</p>

<p>whereis gnome-terminal</p>

<p>把整个文件夹 folderTared 的内容打包成一个gz文件：<br />
tar zvcf folderTared.tar.gz /theDir/folderTared<br />
把压缩的gz文件恢复到指定目录下：<br />
tar zvxf folderTared.tar.gz /theDir/</p>

<p>gunzip t_wiki_doc-2011-10-12.sql.gz</p>

<p>svn checkout ./gamechat <a href="http://10.4.3.143/subversion/gamechat/">http://10.4.3.143/subversion/gamechat/</a></p>

<p>svnserve &ndash;root /data/svn/svn &ndash;daemon
把其他仓库的svn数据目录的文件夹直接拷贝到/data/svn/svn下面，运行启动后可正常工作！</p>

<p>svn详细配置：<a href="http://wiki.ubuntu.org.cn/SubVersion">http://wiki.ubuntu.org.cn/SubVersion</a></p>

<p>svn log -v | head -n 10</p>

<p>svn diff -r 4016:4017 connectserver.conf</p>

<p>chmod a+x xx/*</p>

<p>tail -f xxx.txt 动态显示变化着的文件</p>

<p>[dongsong@tm4ctt143 udplogger]$ md5sum udplogger<br />
23ee4c96305af409d8092e2553ff4357 udplogger</p>

<p>535 cat /etc/issue 查询系统版本<br />
file /sbin/init 查询系统是32位还是64位等相关信息<br />
541 wget <a href="http://mirror.centos.org/centos/5/os/SRPMS/glibc-2.5-34.src.rpm">http://mirror.centos.org/centos/5/os/SRPMS/glibc-2.5-34.src.rpm</a> 下载<br />
543 rpm -qp glibc-2.5-34.src.rpm |less<br />
546 rpm -ivh glibc-2.5-34.src.rpm<br />
559 rpmbuild -bp SPECS/glibc.spec<br />
560 yum install -y audit-libs-devel 自动下载安装软件<br />
566 find . -name &ldquo;ldconfig*&rdquo; 在当前目录.寻找文件<br />
locate ldconfig 全盘查找文件ldconfig<br />
568 vi ldconfig.c<br />
vi另存为 :w newFileName</p>

<p>523 php -r &lsquo;fc_set(&ldquo;aaa&rdquo;, &ldquo;OK&rdquo;);&rsquo;<br />
524 php -r &lsquo;echo fc_get(&ldquo;aaa&rdquo;);&rsquo;</p>

<p>519 fg</p>

<p>520 grep -d recurse in_pktinfo /usr/include/*<br />
grep -E &lsquo;216|219&rsquo; data..f<br />
ps aux|grep game|grep -v grep</p>

<p>484 cp -ar dbadmin.bak dbadmin<br />
496 find dbadmin -name &ldquo;*.php.org&rdquo; -exec rm {} \;</p>

<p>nc -u 10.4.3.143 873 向143机器的873端口发送UDP数据<br />
nc -l 2010 监听当前机器的2010端口并显示连接建立起来后受到的数据，需要回复数据可以直接输入</p>

<p>top 查看系统状况（1cpu展开 O进入排序选择界面&ndash;&gt;q按照内存使用排序）</p>

<p>c 显示完整command</p>

<p>O 选择排序的列（q内存使用排序）</p>

<p>H 列出所有进程的线程，然后pstack pid(进程或者线程ID)打印线程的调用栈就知道各线程分别是什么线程了</p>

<p>pstack pid 如果pid是线程ID则打印当前线程调用栈，如果是进程ID则打印其所有线程的调用栈</p>

<p>top -H -p pid</p>

<p>top -p pid</p>

<p>top -p <code>ps h -o pid -C 进程名</code></p>

<p>top看不到所有进程，可以用top -b -d 1 -n 1 | less (-d delay延迟1秒更新，-n抓一次快照)</p>

<p>pstree -p 显示系统内所有进程构成的进程树（除了用ps axo &lsquo;ppid,pid,cmd&rsquo;来找进程的父进程以外还可以从进程树里面找）</p>

<p>To print a process tree:<br />
ps -ejH<br />
ps axjf</p>

<p>To get info about threads:<br />
ps -eLf<br />
ps axms</p>

<p>僵尸进程会占用一部分内存（保存进程退出信息的结构体），可以杀掉其父进程以回收资源（当然，这样干可能会影响父进程的业务）</p>

<p>cat /proc/sys/kernel/shmmax 查看系统单个共享内存段最大字节数</p>

<p>cat /proc/sys/kernel/shmmni 查看系统共享内存段最大个数<br />
cat /proc/sys/kernel/shmall 查看系统中共享内存页总数<br />
python 使用linux的计算功能<br />
ipcs -lm 查看系统共享内存的参数<br />
ctrl+z 转到后台运行<br />
fg 调到前台来<br />
tail -f operate_push.log 动态查看文件<br />
tail -n 2 eee &gt; test.php 将文件eee的最后2行输出重定向到test.php<br />
519 for f in <code>find lab -name &quot;*.org&quot;</code>; do echo ${f%.org}; done</p>

<p>520 for f in <code>find lab -name &quot;*.org&quot;</code>; do mv $f ${f%.org}; done</p>

<p>[weibofengyun@localhost tfengyun_calc]$ for i in {1..5} ; do echo $i; done<br />
1<br />
2<br />
3<br />
4<br />
5<br />
[dongsong@tm4ctt143 ~]$ vvv=&ldquo;Hello world&rdquo;<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv}<br />
Hello world<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv:-xxxxx}<br />
Hello world<br />
[dongsong@tm4ctt143 ~]$ echo ${vvvv:-xxxxx}<br />
xxxxx<br />
[dongsong@tm4ctt143 ~]$ echo $vvvv</p>

<p>[dongsong@tm4ctt143 ~]$ echo ${vvvv}</p>

<p>[dongsong@tm4ctt143 ~]$ echo ${vvvv:=xxxxx}<br />
xxxxx<br />
[dongsong@tm4ctt143 ~]$ echo ${vvvv}<br />
xxxxx<br />
[dongsong@tm4ctt143 ~]$ echo ${vvva:?EEEEEEErrrrrrr}<br />
bash: vvva: EEEEEEErrrrrrr<br />
[dongsong@tm4ctt143 ~]$ echo ${aa:+hello}</p>

<p>[dongsong@tm4ctt143 ~]$ echo $aa</p>

<p>[dongsong@tm4ctt143 ~]$ echo ${va:+hello}</p>

<p>[dongsong@tm4ctt143 ~]$ echo ${vvv:+hello}<br />
hello<br />
[dongsong@tm4ctt143 ~]$ echo $vvv<br />
Hello world<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv:0:4}<br />
Hell<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv:0:2}<br />
He<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv: -3}<br />
rld<br />
[dongsong@tm4ctt143 ~]$ echo ${!v<em>}<br />
vvv vvvv<br />
[dongsong@tm4ctt143 ~]$ echo ${#vvv}<br />
11<br />
[dongsong@tm4ctt143 ~]$ echo $vvv<br />
Hello world<br />
[dongsong@tm4ctt143 ~]$ vvv=&ldquo;a.b.php.org&rdquo;<br />
[dongsong@tm4ctt143 ~]$ vvv=&ldquo;/home/yy/a.b.php.org&rdquo;<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv%.org}<br />
/home/yy/a.b.php<br />
[dongsong@tm4ctt143 ~]$ echo $vvv<br />
/home/yy/a.b.php.org<br />
[dongsong@tm4ctt143 ~]$ vvv=&ldquo;/home/yy/a.b.org.php.org&rdquo;<br />
[dongsong@tm4ctt143 ~]$ echo $vvv<br />
/home/yy/a.b.org.php.org<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv%%.org</em>}<br />
/home/yy/a.b<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv%%.org}<br />
/home/yy/a.b.org.php<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv%%.org<em>}<br />
/home/yy/a.b<br />
[dongsong@tm4ctt143 ~]$ echo ${vvv%.org</em>}<br />
/home/yy/a.b.org.php<br />
[dongsong@tm4ctt143 ~]$ man bash</p>

<p>curl <a href="http://www.baidu.com">http://www.baidu.com</a> 对指定url发出请求，可以-d用post方式、-G用get方式；用于测试比较方便，省去打开浏览器的麻烦</p>

<p>siege -f myurls.txt -t 60S [-r 100000] -d 3 -i -c 128 （128 users;3 delay
）测试http性能(做压力测试时-d可指为零；内网测试机212的apache用siege和ab测试结果差不多，每秒处理2W+请求)</p>

<p>ab -n 10000 -c 10 <a href="http://192.168.1.212:8088/">http://192.168.1.212:8088/</a> apache提供的http测试工具</p>

<p>ab -v 显示参数及说明</p>

<p>sar -n DEV 2 5 网卡流量实时监控，2s一次，总共打印五次</p>

<p>sar -r 显示当天的内存(其他的见sar -h)</p>

<p>sar -n DEV 显示当天的网卡流量数据(这些还未写盘到/var/log/sa/sar[day]，只能这样看)</p>

<p>关于sysstat</p>

<p>sysstat = sar + iostat + mpstat + pidstat + sadf
(<a href="http://www.blackmoreops.com/2014/06/18/sysstat-sar-examples-usage/">http://www.blackmoreops.com/2014/06/18/sysstat-sar-examples-usage/</a>)</p>

<p>man sar 可以看到日志中各项指标和衡量单位的含义</p>

<p>设置打日志的间隔: vim /etc/cron.d/sysstat</p>

<p>设置日志保留的时间: vim /etc/sysconf/sysstat HISTORY</p>

<p>重启sysstat: service sysstat restart 或者 /etc/init.d/sysstat restart</p>

<p>ls -lhrt /var/log/sa/ 查看sysstat的日志<br />
sar -f /var/log/sa/sa13<br />
sar -f /var/log/sa/sa13 |less</p>

<p>675 sar -o data.bin 1 记录cpu等信息<br />
676 sar -o data2.bin 1<br />
677 ls<br />
678 sar -f data.bin 显示cpu等信息<br />
679 sar -f data.bin -A | less<br />
stat filename 显示文件的设备号和inode<br />
uname -a 查看系统版本的几种方法<br />
cat /proc/version<br />
cat /etc/issue<br />
lsb_release -a<br />
/sbin/ip link 查看系统网卡信息的几种方法<br />
netstat -i<br />
/sbin/ifconfig<br />
ls -l /proc/进程ID/fd 查看进程打开的读写的文件<br />
554 GLIB_CFLAGS=&ldquo;-I/usr/local/include&rdquo; GLIB_LIBS=&ldquo;-L/usr/local/lib&rdquo;
./configure<br />
556 export CFLAGS=&ldquo;-I/usr/local/include&rdquo;<br />
557 export LDFLAGS=&ldquo;-L/usr/local/lib&rdquo;<br />
559 export GLIB_CFLAGS=&ldquo;-I/usr/local/include&rdquo;<br />
560 export GLIB_LIBS=&ldquo;-L/usr/local/lib&rdquo;<br />
569 make clean<br />
570 ./configure &ndash;help | less<br />
571 export CPPFLAGS=&ldquo;-I/usr/local/include&rdquo;<br />
573 export LDFLAGS=&ldquo;-L/usr/local/lib&rdquo;<br />
574 export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig/ 设置环境变量<br />
577 man pkg-config<br />
$pkg-config &ndash;modversion gtk+ (查看1.2.x版本)</p>

<p>$pkg-config &ndash;modversion gtk+-2.0 (查看 2.x 版本)</p>

<p>$pkg-config &ndash;version (查看pkg-config的版本)</p>

<p>$pkg-config &ndash;list-all |grep gtk (查看是否安装了gtk)</p>

<p>env 显示所有环境变量</p>

<p>grep -rn &lsquo;class EkigaMainWindow&rsquo; ./*<br />
grep -d recurse TopDocs * 递归查找<br />
pstree |grep bash<br />
582 vi test.c<br />
583 ls<br />
584 man gcc<br />
585 ls<br />
586 gcc -E test.c 预处理 处理头文件、宏<br />
587 gcc -E test.c | less<br />
588 gcc -S test.c 编译 生成汇编代码<br />
589 ls<br />
590 less test.s<br />
591 gcc -c test.c 汇编 生成目标代码<br />
592 ls test.o<br />
593 gcc -o test test.o 链接 生成可执行文件<br />
594 ls<br />
595 ./ test<br />
596 ./test<br />
597 nm test<br />
598 nm test | less<br />
599 ldd test 列出该可执行文件加载的动态库<br />
600 export LD_PRELOAD=yes<br />
601 ./test<br />
602 man ld<br />
603 unset LD_PRELOAD<br />
604 ls<br />
605 strace test 列出动态库<br />
606 sudo yum install strace<br />
607 ls<br />
608 strace test<br />
609 readelf -h test 列出可执行文件（elf文件）的具体信息<br />
610 file test<br />
611 man readelf<br />
612 readelf -l test<br />
613 readelf -S test<br />
614 objdump -d test<br />
615 which objdump<br />
616 rpm -qf /usr/bin/objdump<br />
617 rpm -ql binutils<br />
618 rpm -ql binutils | | less<br />
619 rpm -ql binutils | less<br />
620 man strip<br />
621 man ranlib</p>

<p>给磁盘分区可以用fdisk -u /dev/sdb 根据提示往下走</p>

<p>cat /proc/partitions查看目前机器中的所有磁盘及分区情况</p>

<p>后台运行领命：crontab at &amp; nohup (前两个是定时执行脚本)</p>

<p>umask是从权限中“拿走”相应的位(具体见 linux与unix shell编程指南 001.pdf)<br />
(系统不允许你在创建一个文本文件时就赋予它执行权限，必须在创建后用chmod命令增加这一权限)<br />
shutdown -h now 关机<br />
halt -p 关机<br />
[dongsong@localhost soft]$ du -sh 查看目录大小<br />
3.5G .<br />
[dongsong@localhost soft]$ df -Th 查看挂载点<br />
文件系统 类型 容量 已用 可用 已用% 挂载点<br />
/dev/mapper/VolGroup00-LogVol00<br />
ext3 6.7G 4.6G 1.8G 73% /<br />
/dev/hda1 ext3 99M 12M 83M 13% /boot<br />
tmpfs tmpfs 252M 0 252M 0% /dev/shm<br />
/dev/hdd5 ext3 14G 4.0G 9.2G 30% /home</p>

<p>[dongsong@localhost soft]$ sudo fdisk -l 查看磁盘空间<br />
Password:</p>

<p>Disk /dev/hda: 8589 MB, 8589934592 bytes<br />
255 heads, 63 sectors/track, 1044 cylinders<br />
Units = cylinders of 16065 * 512 = 8225280 bytes</p>

<p>Device Boot Start End Blocks Id System<br />
/dev/hda1 * 1 13 104391 83 Linux<br />
/dev/hda2 14 1044 8281507+ 8e Linux LVM</p>

<p>重启后自动挂载：vi /etc/fstab<br />
添加：/dev/sdb1 /mnt/d ext3 default 0 0</p>

<p>gcc -L/usr/local/lib test_sqlite.c -lsqlite3</p>

<p>for i in <code>find ./ -name &quot;*.[ch]&quot; -exec wc -l {} \;|cut -d ' ' -f1;</code>; do
sum=$(($sum+$i));done 统计目录下.c .h文件行数（代码行数）</p>

<p>或者 find ./ |egrep &ldquo;<em>.[ch]$|</em>.cpp$|*.hpp$&rdquo; |xargs wc -l</p>

<p>find pathname -options <a href="具体见 linux与unix shell编程指南 002.pdf">-print -exec -ok</a><br />
find . -perm -007 数字前面有-时，只根据非零项进行筛选<br />
find . -perm 667 数字前面没有-时，严格按照权限筛选<br />
cut -f1,2,3<br />
cut -f2,3,4 chat-20110122.log | grep &lsquo;^100075&rsquo;<br />
ls -l proc/2345/cwd 查看进程2345运行的目录<br />
cat cityBuild-20110118.log | grep ^5 输出以5开头的数据<br />
xudongsong@sysdev:~$ ls | egrep &ldquo;pub$|^test|2000&rdquo; 正则匹配<br />
id_rsa.pub<br />
test.cpp<br />
test.log<br />
test.txt<br />
top_3001-3500_1501-2000</p>

<p>-&mdash;&mdash;&mdash;-cp start&mdash;&mdash;&mdash;&mdash;&ndash;<br />
copy 本地的档案到远程的机器上<br />
scp /etc/lilo.conf k@net67.ee.oit.edu.tw:/home/k<br />
会将本地的 /etc/lilo.conf 这个档案 copy 到 net67.ee.oit.edu.tw，使用者 k 的家目录下。<br />
copy远程机器上的档案到本地来<br />
scp k@net67.ee.oit.edu.tw:/etc/lilo.conf /etc<br />
会将 net67.ee.oitdu.tw 中 /etc/lilo.conf 档案 copy 到本地的 /etc 目录下。<br />
保持从来源 host 档案的属性<br />
scp –p k@net67.ee.tw:/etc/lilo.conf /etc</p>

<p>如果想使用特定端口 使用 scp –P（大写） 如 scp –P 1234 k@net67.ee.tw:/etc/lilo.conf /etc</p>

<p>在此必须注意使用者的权限是否可读取远程上的档案，若想知道更多关于 scp 的使用方法，可去看看 scp 的使用手册。<br />
ssh-keygen<br />
产生公开钥 (pulib key) 和私人钥 (private key)，以保障 ssh 联机的安性， 当 ssh 连 shd
服务器，会交换公开钥上，系统会检查 /etc/ssh_know_hosts 内储存的 key，如果找到客户端就用这个 key
产生一个随机产生的session key 传给服务器，两端都用这个 key 来继续完成 ssh 剩下来的阶段。</p>

<p>它会产生 identity.pub、identity 两个档案，私人钥存放于identity，公开钥 存放于 identity.pub 中，接下来使用
scp 将 identity.pub copy 到远程机器的家目录下.ssh下的authorized_keys。
.ssh/authorized_keys(这个 authorized_keys 档案相当于协议的 rhosts
档案)，之后使用者能够不用密码去登入。RSA的认证绝对是比 rhosts
认证更来的安全可靠。想让多台机器都不输密码直接往A上拷数据，可以把这几台机器的identity.pub追加到A得authorized_keys文件后面。<br />
执行：<br />
scp identity.pub k@linux1.ee.oit.edu.tw:.ssh/authorized_keys</p>

<p>若在使用 ssh-keygen 产生钥匙对时没有输入密码，则如上所示不需输入密码即可从 net67.ee.oit.edu.tw 去登入
linux1.ee.oit.edu.tw。在此，这里输入的密码可以跟帐号的密码不同，也可以不输入密码。<br />
-&mdash;&mdash;&mdash;-scp end&mdash;&mdash;&mdash;&mdash;&mdash;-<br />
ssh -p 7710 root@220.181.83.115 -v ssh登录<br />
nohup ********* &amp; 转后台运行</p>

<p>date +%s 在bash上输出unixtime<br />
date &ndash;date &ldquo;1 days ago&rdquo; 获取一天前的时间<br />
date +%G-%m-%d 输出2011-11-17<br />
date -R 查看服务器时区设置</p>

<p>show global variables like &lsquo;%time_zone%&rsquo; 查看mysql时区设置<br />
select current_timestamp; 查看mysql当前的时间戳</p>

<p>编码问题：<br />
iconv -f GB2312 -t UTF-8 NationLogInterface.h &gt; NationLonInterface.h_utf-8
bash上对文件进行编码转换<br />
在Vim中可以直接查看文件编码 :set fileencoding 即可显示文件编码格式</p>

<p>autoreconf -fi<br />
./configure &ndash;prefix=/home/myciv/civ-server/trunk/run</p>

<p>linux编译问题，因为系统时间导致编译不正常：find .|xargs touch</p>

<p>添加sudo权限 vi /etc/sudoers</p>

<p>设置sudo不输入密码：sudo visudo 或者 sudo vi /etc/sudoers, 按如下修改<br />
%admin ALL=(ALL)NOPASSWD:NOPASSWD ALL //admin组的用户sudo所有命令都不用输入密码<br />
%guy ALL=NOPASSWD:ALL //用户guy sudo 所有命令都不用输入密码<br />
%guy ALL=NOPASSWD:/usr/bin/tt.sh,/usr/sbin/adduser //用户guy sudo指令命令不用输入密码</p>

<p>fg、bg、jobs、&amp;、ctrl + z都是跟系统任务有关的，虽然现在基本上不怎么需要用到这些命令，但学会了也是很实用的<br />
一。&amp; 最经常被用到<br />
这个用在一个命令的最后，可以把这个命令放到后台执行<br />
二。ctrl + z<br />
可以将一个正在前台执行的命令放到后台，并且暂停<br />
三。jobs<br />
查看当前有多少在后台运行的命令<br />
四。fg<br />
将后台中的命令调至前台继续运行<br />
如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)<br />
五。bg<br />
将一个在后台暂停的命令，变成继续执行<br />
如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</p>

<p>gdb调试core文件：<br />
gdb -core core.*** XXX(可执行文件)<br />
gdb&gt;&gt; bt<br />
gdb&gt;&gt; f XX(第几个栈)<br />
gdb&gt;&gt; list filename:lineNumber<br />
gdb&gt;&gt; info threads 列出线程</p>

<p>gdb&gt;&gt; thread n 跳转到线程</p>

<p>gdb -p pid 切入一个进程，generate-core-file生成core文件，然后quit detach进程</p>

<p>源代码之间建立跳转链接<br />
ctags -R<br />
cscope -b -R *.cpp *.hpp</p>

<p>ctags建立之后可以用ctrl+] 和ctrl+t进行正反向跳转（ <strong>前面加上ctrl+w就可以在新tab页中显示</strong> ），在bash下面之间用vi
-t name可以打开函数或者变量定义的文件（功能真风骚，貌似我只用了ctags的1%）</p>

<p>vim xxx.c之前要把当前路径切换到ctags所在目录去，否则找不到符号</p>

<p>ctags的用法：<a href="http://oreilly.com/catalog/vi6/chapter/ch08.html#ch08_05.htm">http://oreilly.com/catalog/vi6/chapter/ch08.html#ch08_05.htm</a></p>

<p>ctags的官网：<a href="http://ctags.sourceforge.net/">http://ctags.sourceforge.net/</a></p>

<p><strong>ctags &ndash;c-types=+px //缺省不能对函数声明建立tag，加这个参数可以解决</strong></p>

<p>常规的对lua建立ctag: ctags &ndash;langdef=MYLUA &ndash;langmap=MYLUA:.lua &ndash;regex-
MYLUA=&ldquo;/^.*\s<em>function\s</em>(\w+):(\w+).<em>$/\2/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s</em>(\w+)\s<em>=\s</em>[0-9]+.<em>$/\1/e/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^.</em>\s<em>function\s</em>(\w+)\.(\w+).<em>$/\2/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^.</em>\s<em>function\s</em>(\w+)\s<em>\(.</em>$/\1/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s<em>(\w+)\s</em>=\s<em>\{.</em>$/\1/e/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s<em>module\s+\&ldquo;(\w+)\&ldquo;.</em>$/\1/m,module/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s<em>module\s+\&rdquo;[a-zA-Z0-9._]+\.(\w+)\&ldquo;.</em>$/\1/m,module/&rdquo;
&ndash;languages=MYLUA &ndash;excmd=pattern -R .</p>

<p>要对文件名也建tag的话需要增加参数 <code>--extra=f</code></p>

<p><code>要对external.createNormalMap = function (plr,mid)中的createNormarlMap建tag:
--regex-MYLUA=&quot;/^.*\w+\.(\w+)\s*=\s*function\s*\(.*$/\1/f/&quot;</code></p>

<p><code>要对middleclass的类Player = class(&quot;Player&quot;)建tag: --regex-
MYLUA=&quot;/^\s*(\w+)\s*=\s*class\s*\(.*$/\1/f/&quot;</code></p>

<p><code>要对middleclass的类初始化函数 function Player:initialize(...)建立tag: --regex-
MYLUA=&quot;/^\s*function\s*(\w+):initialize\s*\(.*$/\1/f/&quot;</code></p>

<p><code>把全局变量加进去 --regex-MYLUA=&quot;/^\s*(\w+)\s*=/\1/f/&quot;</code></p>

<p>ctags &ndash;langdef=MYLUA &ndash;langmap=MYLUA:.lua &ndash;regex-
MYLUA=&ldquo;/^\s<em>(\w+)\s</em>=\s<em>class\s</em>\(.<em>$/\1/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^.</em>\w+\.(\w+)\s*=\s<em>function\s</em>\(.<em>$/\1/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^.</em>\s<em>function\s</em>(\w+):(\w+).<em>$/\2/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s</em>(\w+)\s<em>=\s</em>[0-9]+.<em>$/\1/e/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^.</em>\s<em>function\s</em>(\w+)\.(\w+).<em>$/\2/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^.</em>\s<em>function\s</em>(\w+)\s<em>\(.</em>$/\1/f/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s<em>(\w+)\s</em>=\s<em>\{.</em>$/\1/e/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s<em>module\s+\&ldquo;(\w+)\&ldquo;.</em>$/\1/m,module/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s<em>module\s+\&rdquo;[a-zA-Z0-9._]+\.(\w+)\&ldquo;.</em>$/\1/m,module/&rdquo; &ndash;regex-
MYLUA=&ldquo;/^\s<em>function\s</em>(\w+):initialize\s<em>\(.</em>$/\1/f/&rdquo; &ndash;languages=MYLUA
&ndash;excmd=pattern <code>--extra=f</code> -R .</p>

<p>find lualib-src/ service-src/ skynet-src/ connectserver/ -name &ldquo;<em>.</em>&rdquo; | egrep
&lsquo;<em>.c$|</em>.h$|*.cpp$&rsquo; | xargs ctags</p>

<p>vim -t functionName 打开tag定义的文件，并定位到该位置</p>

<p><strong>ctrl+w 让ctrl+]在标签页中打开</strong></p>

<p>ctrl+] 跳转到定义的位置</p>

<p>ctrl+t 回到跳转的位置</p>

<p>ctrl+o 回到光标上次所在的位置</p>

<p>ctrl+i 前进到光标回跳前的位置</p>

<p>ctrl+e 保持光标不动把页面向上移动</p>

<p>ctrl+y 保持光标不动把页面向下移动</p>

<p>ctrl+f 向下滚一屏</p>

<p>ctrl+b向上滚一屏</p>

<p>ctrl+d向下滚半屏</p>

<p>ctrl+u向上滚半屏</p>

<p>/xxx&gt; 匹配以xxx结尾的单词</p>

<p>/</p>

<dl>
<dt>/\ 匹配xxx单词</dt>
<dt>:set ignorecase 忽略大小写</dt>
</dl>

<p>:set noignorecase 恢复到大小写敏感</p>

<p>如何让ctags支持php的语法跳转：<br />
以下命令可放到~/.bash<em>profile中<br />
alias phptags=&lsquo;ctags &ndash;langmap=php:.engine.inc.module.theme.php &ndash;php-
kinds=cdf &ndash;languages=php &ndash;extra=f&rsquo;<br />
以下设置放到 ~/.ctags文件中<br />
$ cat ~/.ctags<br />
--regex-php=/<sup class="footnote-ref" id="fnref:t"><a href="#fn:t">1</a></sup>*[(private|public|static)( \t)]*function[
\t]+([A-Za-z0-9</em>]+)[ \t]<em>\(/\1/f, function, functions/<br />
--regex-php=/<sup class="footnote-ref" id="fnref:t"><a href="#fn:t">2</a></sup></em>[(private|public|static)]+[ \t]+\$([A-Za-z0-9<em>]+)[
\t]<em>/\1/p, property, properties/<br />
--regex-php=/<sup class="footnote-ref" id="fnref:t"><a href="#fn:t">3</a></sup></em>(const)[ \t]+([A-Za-z0-9</em>]+)[ \t]*/\2/d, const,
constants/<br />
使用时，在代码目录中：<br />
$ phptags -R</p>

<p>就可以生成比较可用的tags文件了。</p>

<p>对于有多个tag文件，可以指定要使用的tag(也可以结合alias来用，或者直接放入.vimrc中，或者直接不带目标文件的启动vim然后用:命令来设置和跳转)
:set tags=$SRC/tags</p>

<dl>
<dt>vim &ndash;cmd &ldquo;:set tag=&hellip;/tags&rdquo;</dt>
<dt>:set tags 显示当前加载的tag文件</dt>
<dt>:tags 显示当前tag stack(tag跳转历史)，更多命令可以用:help tag-commands来查看</dt>
<dt>:tag xxx 跳到xxx这个tag的位置去</dt>
<dt>:tag /^xxx 跳到以xxx打头的tag位置</dt>
<dt>:ts /^xxx 列出以xxx打头的tag</dt>
<dt>:tag /xxx 跳到包含xxx的tag位置</dt>
<dt>:ts /xxx 列出包含xxx的tag</dt>
<dt>:ts xxx</dt>
<dt>:ts[elect][!] [ident] 列出所有跟目标相符的tag</dt>
<dt>:ta[g] 功能跟ctrl+]类似</dt>
</dl>

<p>:po[p] 功能跟ctrl+t类似</p>

<p><strong>:tn, :tp是在符号的多个定义之间跳转</strong></p>

<p>对Python文件建ctags跳转标记</p>

<p><a href="http://www.held.org.il/blog/2011/02/configuring-ctags-for-python-and-vim/">http://www.held.org.il/blog/2011/02/configuring-ctags-for-python-and-vim/</a></p>

<pre><code>[root@test-22 kl-robot]# cat ~/.ctags
--python-kinds=-i
root@test-22 kl-robot]# ctags --list-kinds=python
ctags: Warning: Unsupported parameter 'i' for --python-kinds option
c  classes
f  functions
m  class members
[root@test-22 kl-robot]# ctags -R --extra=f .   
ctags: Warning: Unsupported parameter 'i' for --python-kinds option
[root@test-22 kl-robot]# ls -lhrt tags 
-rw-r--r-- 1 root root 162K 06-11 16:05 tags
</code></pre>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;查看系统配置&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<p>系统</p>

<h1 id="uname-a-查看内核-操作系统-cpu信息">uname -a # 查看内核/操作系统/CPU信息</h1>

<h1 id="head-n-1-etc-issue-查看操作系统版本">head -n 1 /etc/issue # 查看操作系统版本</h1>

<h1 id="cat-proc-cpuinfo-查看cpu信息">cat /proc/cpuinfo # 查看CPU信息</h1>

<h1 id="hostname-查看计算机名">hostname # 查看计算机名</h1>

<h1 id="lspci-tv-列出所有pci设备">lspci -tv # 列出所有PCI设备</h1>

<h1 id="lsusb-tv-列出所有usb设备">lsusb -tv # 列出所有USB设备</h1>

<h1 id="lsmod-列出加载的内核模块">lsmod # 列出加载的内核模块</h1>

<h1 id="env-查看环境变量">env # 查看环境变量</h1>

<p>资源</p>

<h1 id="free-m-查看内存使用量和交换区使用量">free -m # 查看内存使用量和交换区使用量</h1>

<h1 id="df-h-查看各分区使用情况">df -h # 查看各分区使用情况</h1>

<h1 id="du-sh-查看指定目录的大小">du -sh # 查看指定目录的大小</h1>

<h1 id="grep-memtotal-proc-meminfo-查看内存总量">grep MemTotal /proc/meminfo # 查看内存总量</h1>

<h1 id="grep-memfree-proc-meminfo-查看空闲内存量">grep MemFree /proc/meminfo # 查看空闲内存量</h1>

<h1 id="uptime-查看系统运行时间-用户数-负载">uptime # 查看系统运行时间、用户数、负载</h1>

<h1 id="cat-proc-loadavg-查看系统负载">cat /proc/loadavg # 查看系统负载</h1>

<p>ss -s 查看TCP连接数</p>

<p>磁盘和分区</p>

<h1 id="mount-column-t-查看挂接的分区状态">mount | column -t # 查看挂接的分区状态</h1>

<h1 id="fdisk-l-查看所有分区">fdisk -l # 查看所有分区</h1>

<h1 id="swapon-s-查看所有交换分区">swapon -s # 查看所有交换分区</h1>

<h1 id="hdparm-i-dev-hda-查看磁盘参数-仅适用于ide设备">hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)</h1>

<h1 id="dmesg-grep-ide-查看启动时ide设备检测状况">dmesg | grep IDE # 查看启动时IDE设备检测状况</h1>

<p>网络</p>

<h1 id="ifconfig-查看所有网络接口的属性">ifconfig # 查看所有网络接口的属性</h1>

<h1 id="iptables-nl-查看防火墙设置-不加n的话看不到端口">iptables -nL # 查看防火墙设置(不加n的话看不到端口 )</h1>

<h1 id="route-n-查看路由表">route -n # 查看路由表</h1>

<h1 id="netstat-lntp-查看所有监听端口">netstat -lntp # 查看所有监听端口</h1>

<h1 id="netstat-antp-查看所有已经建立的连接">netstat -antp # 查看所有已经建立的连接</h1>

<p>netstat -A inet -n -p #-A协议(inet:raw tcp udp) -n显示数字端口 -p显示程序名</p>

<h1 id="netstat-s-查看网络统计信息">netstat -s # 查看网络统计信息</h1>

<p>netstat -a | grep 5630 查看跟5630端口相关的所有连接（已建立的连接以及正在监听的端口信息）</p>

<p>进程</p>

<h1 id="ps-ef-查看所有进程">ps -ef # 查看所有进程</h1>

<h1 id="top-实时显示进程状态">top # 实时显示进程状态</h1>

<p>查看进程是否死循环或者僵尸 R+就是死循环</p>

<p>ps axo
&ldquo;lstart,etime,stat,vsize,rss,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm,cmd&rdquo;
| egrep &ldquo;server|cross&rdquo;</p>

<p>rss实际内存（KB）</p>

<p>vsize虚拟内存（虚拟地址空间大小，new出来没有使用的内存空间都属于虚拟内存，不占实际物理内存；这个跟交换分区又不是同一个概念，交换分区是指把实际物理内存交换到磁盘上）（KB）</p>

<p>start_time 程序启动日期</p>

<p>lstart 启动的准确时间</p>

<p>etime 已运行时长</p>

<p>pgrep &ldquo;lz2_mapserver|lz2_baseserver&rdquo; | xargs kill -USR2 #比ps axo + 过滤更精准一点
不会被进程的命令行参数干扰。 是类似于killall的命令。</p>

<p>用户</p>

<h1 id="w-查看活动用户">w # 查看活动用户</h1>

<h1 id="id-查看指定用户信息">id # 查看指定用户信息</h1>

<h1 id="last-查看用户登录日志">last # 查看用户登录日志</h1>

<h1 id="cut-d-f1-etc-passwd-查看系统所有用户-用户名-口令-用户标识号-组标识号">cut -d: -f1 /etc/passwd # 查看系统所有用户 ( <strong>用户名</strong> : <strong>口令</strong> : <strong>用户标识号</strong> : <strong>组标识号</strong></h1>

<dl>
<dd><p><strong>注释性描述</strong> : <strong>主目录</strong> : <strong>登录Shell</strong> )</p>

<h1 id="cut-d-f1-etc-group-查看系统所有组-组名-口令-组标识号-组内用户列表">cut -d: -f1 /etc/group # 查看系统所有组( <strong>组名:口令:组标识号:组内用户列表</strong> )</h1>

<h1 id="crontab-l-查看当前用户的计划任务">crontab -l # 查看当前用户的计划任务</h1></dd>
</dl>

<p>服务</p>

<h1 id="chkconfig-list-列出所有系统服务">chkconfig &ndash;list # 列出所有系统服务</h1>

<h1 id="chkconfig-list-grep-on-列出所有启动的系统服务">chkconfig &ndash;list | grep on # 列出所有启动的系统服务</h1>

<p>程序</p>

<h1 id="rpm-qa-查看所有安装的软件包">rpm -qa # 查看所有安装的软件包</h1>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;end of 查看系统配置&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;source命令&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />
source命令的作用就是用来执行一个脚本，那么：<br />
source a.sh 同直接执行 ./a.sh 有什么不同呢，比如你在一个脚本里export $KKK=111
,如果你用./a.sh执行该脚本，执行完毕后，你运行 echo $KKK ,发现没有值，如果你用source来执行 ，然后再echo
,就会发现KKK=111。因为调用./a.sh来执行shell是在一个子shell里运行的，所以执行后，结构并没有反应到父shell里，但是
source不同它就是在本shell中执行的，所以可以看到结果<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;end of source命令&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>使用man时可以指定不同的section来浏览，各个section意义如下：<br />
1 - commands<br />
2 - system calls<br />
3 - library calls<br />
4 - special files<br />
5 - file formats and convertions<br />
6 - games for linux<br />
7 - macro packages and conventions<br />
8 - system management commands<br />
(man 1是shell命令，man 2是系统调用，man 3是库函数)</p>

<p>windows绑定host的文件：C:\WINDOWS\system32\drivers\etc</p>

<p>linux绑定houst的文件：/etc/hosts</p>

<h2 id="suid-guis">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;suid/guis</h2>

<p>start&mdash;&mdash;&mdash;&mdash;&mdash;<br />
suid意味着如果A用户对属于他自己的shell脚本文件设置了这种权限，那么其他用户在执行这个脚本的时候就拥有了A用户的权限。所以，如果
root用户对某一脚本设置了这一权限的话则其他用户执行该脚本的时候则拥有了root用户权限。同理，guid意味着执行相应脚本的用户则拥有了该文件所属用户组中用户的权限。<br />
为什么使用suid/guid？<br />
举个例子：要对数据库系统进行备份需要有系统管理权限，那么我可以写几个脚本，并设置了它们的guid，这样我指定的一些用户只要执行这些脚本就能够完成相应的工作，而无须以数据库管理员的身份登录，以免不小心破坏了数据库服务器。通过执行这些脚本，他们可以完成数据库备份及其他管理任务，但是在这些脚本运行结束之后，他们就又回复到他们作为普通用户的权限。<br />
有相当一些命令也设置了suid和guid。如果想找出这些命令，可以进入/bin或/sb in目录，执行下面的命令：<br />
$ ls -l | grep &lsquo;^&hellip;s&rsquo;<br />
上面的命令是用来查找suid文件的；<br />
$ ls -l | grep &lsquo;^&hellip;s..s&rsquo;<br />
上面的命令是用来查找suid和guid的。<br />
如何设置suid/guid？<br />
如果希望设置suid，那么就将相应的权限位之前的那一位设置为4；如果希望设置guid，那么就将相应的权限位之前的那一位设置为2；如果希望两者都置位，那么将相应的权限位之前的那一位设置为4+2。<br />
一旦设置了这一位，一个s将出现在x的位置上。记住：在设置suid或guid的同时，相应的执行权限位必须要被设置。例如，如果希望设置guid，那么必须要让该用户组具有执行权限。<br />
如果想要对文件login设置suid，它当前所具有的权限为rwx rw- r&ndash;
(741)，需要在使用chmod命令时在该权限数字的前面加上一个4，即chmod 4741，这将使该文件的权限变为rws rw- r&ndash;。<br />
$ chmod 4741 login<br />
还可以使用符号方式来设置suid/guid。如果某个文件具有这样的权限： rwx r-x r-x，那么可以这样设置其suid/guid：<br />
chmod u+s<br />
chmod u+g</p>

<h2 id="suid-guis-1">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;suid/guis</h2>

<p>end&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<h2 id="mysql">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;mysql</h2>

<p>start&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
select * from t_battle_mails where iStartX = 245 AND iStartY = 102 into
outfile &ldquo;/tmp/battlemail.txt&rdquo;;<br />
load data infile &ldquo;/home/myciv/login_logs/login_22_122999_20110112.log&rdquo; into
table t_test1 fields terminated by &ldquo;\t&rdquo;;</p>

<p>select count(sActivityCode) from t_user_info where activate = 1 and
sActivityCode != &ldquo; and first_time &gt; &ldquo;2011-01-12 00:00:00&rdquo; and first_time &lt;
&ldquo;2011-01-12 23:59:59&rdquo;;<br />
SELECT UNIX_TIMESTAMP(&ldquo;20110114000000&rdquo;);<br />
SELECT UNIX_TIMESTAMP(&ldquo;2011-01-14 00:00:00&rdquo;);<br />
SELECT FROM_UNIXTIME(12312689349);</p>

<p>datetime字段设置当前值为默认值的问题（参考<a href="http://wotf23771.iteye.com/blog/721013）：">http://wotf23771.iteye.com/blog/721013）：</a><br />
MySQL的datetime设置当前时间为默认值,由于MySQL目前字段的默认值不支持函数，所以用create_time datetime default
now()的形式设置默认值是不可能的。</p>

<p>代替的方案是使用TIMESTAMP类型代替DATETIME类型。<br />
CURRENT_TIMESTAMP ：当我更新这条记录的时候，这条记录的这个字段不会改变。<br />
CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
：当我更新这条记录的时候，这条记录的这个字段将会改变。即时间变为了更新时候的时间。（注意一个UPDATE设置一个列为它已经有的值，这将不引起TIMESTAMP列被更新，因为如果你设置一个列为它当前的值，MySQL为了效率而忽略更改。）如果有多个TIMESTAMP列，只有第一个自动更新。</p>

<p>同一个表中上述两种类型字段不能出现任意两个！</p>

<p>mysql&gt; select count(<em>) from t_raw_img where time &lt; NOW();<br />
+&mdash;&mdash;&mdash;-+<br />
| count(</em>) |<br />
+&mdash;&mdash;&mdash;-+<br />
| 2452 |<br />
+&mdash;&mdash;&mdash;-+<br />
1 row in set (0.02 sec)</p>

<p>mysql&gt; select NOW();<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+<br />
| NOW() |<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+<br />
| 2012-05-02 10:35:57 |<br />
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+<br />
1 row in set (0.00 sec)</p>

<p>mysql&gt; select count(<em>) from t_raw_img where time &gt; &ldquo;2012-04-27 00:00:00&rdquo;;<br />
+&mdash;&mdash;&mdash;-+<br />
| count(</em>) |<br />
+&mdash;&mdash;&mdash;-+<br />
| 2452 |<br />
+&mdash;&mdash;&mdash;-+<br />
1 row in set (0.03 sec)</p>

<p>mysqldump备份：mysqldump -u用户名 -p密码 -h主机 数据库 数据表 -w &ldquo;sql条件&rdquo; &ndash;lock-all-tables &gt;
路径<br />
mysqldump -h 127.0.0.1 -uroot -proot123 civ_hujiajie t_battle_mails -w &ldquo;1&rdquo;
&ndash;lock-all-tables &gt; /tmp/testdump.txt;</p>

<p>mysqldump还原：mysql -u用户名 -p密码 -h主机 数据库 &lt; 路径<br />
source 文件;</p>

<p>导出<br />
-t 导数据不导结构</p>

<p>-d 导结构不导数据</p>

<p>--replace 用replace into替代insert into</p>

<p>--where=&ldquo;id&gt;100 order by id limit 0,10&rdquo;</p>

<p>-r, &ndash;result-file=nameDirect output to a given file. This option should be used on Windows to prevent newline&rdquo;\n&rdquo; characters from being converted to&rdquo;\r\n&rdquo; carriage return/newline sequences. The result file is created and its previous contents overwritten, even if an error occurs while generating the dump.</p>

<p>-c or - complete_insert</p>

<p>这个选项使得结果sql中携带列信息，不加该选项是 replace/insert into table t
values(&hellip;)，加了以后是replace/insert into table t(c1,c2,&hellip;) values (&hellip;)</p>

<p>--compact Give less verbose output (useful for debugging). Disables<br />
structure comments and header/footer constructs. Enables<br />
options &ndash;skip-add-drop-table &ndash;skip-add-locks<br />
--skip-comments &ndash;skip-disable-keys &ndash;skip-set-charset.
很多时候我们只想要inser/replace语句，其他都不要，那么这个参数可以把很多多余信息干掉</p>

<p>1.导出整个数据库</p>

<p>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</p>

<p>mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql</p>

<p>2.导出一个表</p>

<p>mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名</p>

<p>mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql</p>

<p>3.导出一个数据库结构</p>

<p>mysqldump -u wcnc -p -d &ndash;add-drop-table smgp_apps_wcnc &gt;d:wcnc_db.sql</p>

<p>-d 没有数据 &ndash;add-drop-table 在每个create语句之前增加一个drop table</p>

<p>4. 导出txt文件<br />
环境变量 path<br />
cmd<br />
mysql -uroot -proot 数据库 表名 &gt; save path</p>

<p>mysql -uroot -proot db 表名&gt;e:/a.txt</p>

<p>导入数据库 sql ,txt</p>

<p>1. 导入sql格式<br />
source 命令</p>

<p>进入mysql数据库控制台，</p>

<p>如mysql -u root -p</p>

<p>mysql&gt;use 数据库</p>

<p>然后使用source命令，后面参数为脚本文件(如这里用到的.sql)</p>

<p>mysql&gt;source d:wcnc_db.sql<br />
2. txt格式<br />
mysql -uroot -proot db&lt; .txt</p>

<p>把查询结果直接导入另一个表中<br />
insert into tb2 (单据编号, 物品编号, 物品名称, 物品数量) select &lsquo;10001&rsquo;,物品编号 ,物品名称, 物品数量 from
tb1</p>

<h2 id="mysql-1">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;mysql</h2>

<p>end&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
元字符(正则表达式)<br />
^ 只匹配行首<br />
$ 只匹配行尾<br />
* 一个单字符后紧跟*，匹配0个或多个此单字符<br />
[] 只匹配[ ]内字符。可以是一个单字符，也可以是字符序列。可以使用-
表示[]内字符序列范围，如用[1-5]代替[12345]，[^1-5]匹配1-5以外的字符<br />
\ 只用来屏蔽一个元字符的特殊含义。因为有时在s h e l l中一些元字符有<br />
特殊含义。\可以使其失去应有意义<br />
. 只匹配任意单字符<br />
pattern\{n\} 用来匹配前面pattern出现次数。n为次数<br />
pattern\{n,\} 含义同上，但次数最少为n<br />
pattern\{n,m\} 含义同上，但pattern出现次数在n与m之间</p>

<p>tr命令的使用<br />
tr特定控制字符的不同表达方式<br />
速记符 含义 八进制方式<br />
\a Ctrl-G 铃声 \007<br />
\b Ctrl-H 退格符 \010<br />
\f Ctrl-L 走行换页 \014<br />
\n Ctrl-J 新行 \012<br />
\r Ctrl-M 回车 \015<br />
\t Ctrl-I tab键 \011<br />
\v Ctrl-X \030</p>

<p>tr -s &ldquo;[a-z]&rdquo; &lt; oops.txt &gt; results.txt 去除连续重复的字符,比如“ddsssssssssss”=》“ds”<br />
tr -s &ldquo;[a-z]&rdquo; &lt; oops.txt 和上面的命令意义等同,只是输出到准备输出了<br />
tr -s &ldquo;[\n]&rdquo; &lt; oops.txt 去除换行<br />
tr -s &ldquo;[\012]&rdquo; &lt; oops.txt 和上面的命令等同<br />
[dongsong@tm4ctt143 ~]$ echo &ldquo;May Day, May Day, Going Down..&rdquo; | tr &ldquo;[a-z]&rdquo;
&ldquo;[A-Z]&rdquo; 小写转大写<br />
MAY DAY, MAY DAY, GOING DOWN..<br />
tr &ldquo;[A-Z]&rdquo; &ldquo;[a-z]&rdquo; &lt; oops.txt 大小到小写</p>

<p>使用trap命令<br />
trap命令用于捕获指定的信号并执行预定义的命令。<br />
其基本的语法是:<br />
trap &lsquo;command&rsquo; signal<br />
其中signal是要捕获的信号，command是捕获到指定的信号之后，所要执行的命令。可以用kill
–l命令看到系统中全部可用的信号名，捕获信号后所执行的命令可以是任何一条或多条合法的shell语句，也可以是一个函数名。<br />
shell脚本在执行时，会产生三个所谓的“伪信号”，(之所以称之为“伪信号”是因为这三个信号是由shell产生的，而其它的信号是由操作系统产生的)，通过使用trap命令捕获这三个“伪信号”并输出相关信息对调试非常有帮助。</p>

<p>shift命令每执行一次，变量的个数($#)减一，而变量值提前一位,shift number去掉number个参数</p>

<p>特定shell变量 还有本地变量、环境变量、位置变量的完整介绍<br />
$# 传递到脚本的参数个数<br />
$* 以一个单字符串显示所有向脚本传递的参数。与位置变量不同，此选项参数可超过9个<br />
$$ 脚本运行的当前进程ID号<br />
$! 后台运行的最后一个进程的进程ID号<br />
$@ 与$#相同，但是使用时加引号，并在引号中返回每个参数,for循环用$@取参数可以一次得到各个参数(不需要用shift)<br />
$- 显示shell使用的当前选项，与set命令功能相同<br />
$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p>

<p>[dongsong@tm4ctt143 shell_study]$ expr 1 &gt; 0<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ expr 1 \* 10<br />
10</p>

<p>条件测试<br />
test一般有两种格式，即：<br />
test condition<br />
或<br />
[ c o n d i t i o n ]<br />
使用方括号时，要注意在条件两边加上空格。<br />
表17-1 文件状态测试<br />
-d 目录<br />
-s 文件长度大于0、非空<br />
-f 正规文件<br />
-w 可写<br />
-L 符号连接<br />
-u 文件有suid位设置<br />
-r 可读<br />
-x 可执行</p>

<p>-a 逻辑与，操作符两边均为真，结果为真，否则为假。<br />
-o 逻辑或，操作符两边一边为真，结果为真，否则为假。<br />
! 逻辑否，条件为假，结果为真。</p>

<p>[dongsong@tm4ctt143 shell_study]$ ls -lh file1.txt<br />
-rw-rw-r&ndash; 1 dongsong dongsong 123 Feb 25 16:43 file1.txt<br />
[dongsong@tm4ctt143 shell_study]$ test -d file1.txt<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ [ -d file1.txt ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ test -x file1.txt -a -x x_shift.sh<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ test -f file1.txt -a -x x_shift.sh<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ [ -f file1.txt -a -x x_shift.sh ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0</p>

<p>测试字符串<br />
= 两个字符串相等。<br />
!= 两个字符串不等。<br />
-z 空串。<br />
-n 非空串。</p>

<p>[dongsong@tm4ctt143 shell_study]$ test &ldquo;hello&rdquo; = hello<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ test &ldquo;hello &rdquo; = &ldquo;hello&rdquo;<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ test &ldquo;hello &rdquo; != &ldquo;hello&rdquo;<br />
[dongsong@tm4ctt143 shell_study]$<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ test -z &ldquo;&rdquo;<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ test -z &ldquo; &rdquo;<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ test -n &ldquo; &rdquo;<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0</p>

<p>测试数值<br />
-eq 数值相等。<br />
-ne 数值不相等。<br />
-gt 第一个数大于第二个数。<br />
-lt 第一个数小于第二个数。<br />
-le 第一个数小于等于第二个数。<br />
-ge 第一个数大于等于第二个数。<br />
[dongsong@tm4ctt143 shell_study]$ test 20 -eq 30<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ test 30 -eq 30<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ [ 20 -eq 30 ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ [ 20 -ne 30 ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ [ &ldquo;20&rdquo; -le &ldquo;30&rdquo; ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ [ &ldquo;20&rdquo; -ge &ldquo;30&rdquo; ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ [ &ldquo;20&rdquo; -lt &ldquo;30&rdquo; ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
0<br />
[dongsong@tm4ctt143 shell_study]$ [ &ldquo;20&rdquo; -gt &ldquo;30&rdquo; ]<br />
[dongsong@tm4ctt143 shell_study]$ echo $?<br />
1</p>

<p>[dongsong@tm4ctt143 shell_study]$ LOOP=1<br />
[dongsong@tm4ctt143 shell_study]$ echo $LOOP<br />
1<br />
[dongsong@tm4ctt143 shell_study]$ LOOP=<code>expr $LOOP + 1</code><br />
[dongsong@tm4ctt143 shell_study]$ echo $LOOP<br />
2</p>

<p>expr命令一般用于整数值，但也可用于字符串。一般格式为：<br />
expr argument operator argument<br />
expr也是一个手工命令行计数器。</p>

<p>注意：<br />
expr 自身有返回值，返回1表示成功<br />
$? 取命令执行结果时，0表示成功</p>

<p>. CheckItIsADirectory 将shell文件载入到shell中(点-空格-
文件名),然后可以用set查看载入的函数,用unset可以去掉载入的函数<br />
也可以用这种方式把一个shell脚本加载到另一个脚本中，类似于C++中的include<br />
还可以把把配置文件之类的文件中的变量包含到其他脚本文件中</p>

<p>dd命令常用于对磁带或一般的磁带解压任务中出现的数据问题提出质疑或转换，但也可<br />
用于创建定长文件。下面创建长度为1兆的文件m y f i l e。<br />
dd if=/dev/zero of=myfile count=512 bs=2048</p>

<p>dd if=file1.txt of=file2.txt conv=lcase 大写字母换成小写字母<br />
dd if=file1.txt of=file3.txt conv=ucase 小写字母换成大写字母</p>

<dl>
<dd>${_ANS:=$_DEFAULT}请教前辈这名话的意思。<br />
如果变量_ANS为空，将变量_DEFAULT的值赋给它<br />
最前面:是空操作 （相当于nop?）<br />
这样shell就只对命令行处理完成赋值，其它啥也不干,去掉冒号会发现bash把$_ANS当命令进行执行并报错了<br />
<br />
<br /></dd>
</dl>

<p>tput</p>

<p>tput init 使用前初始化</p>

<p>字符串输出&mdash;&mdash;&ndash;&gt;<br />
名字 含义<br />
bel 警铃<br />
blink 闪烁模式<br />
bold 粗体<br />
civis 隐藏光标<br />
clear 清屏<br />
cnorm 不隐藏光标<br />
cup 移动光标到屏幕位置(x，y)<br />
el 清除到行尾<br />
ell 清除到行首<br />
smso 启动突出模式<br />
rmso 停止突出模式<br />
smul 开始下划线模式<br />
rmul 结束下划线模式<br />
sc 保存当前光标位置<br />
rc 恢复光标到最后保存位置<br />
sgr0 正常屏幕<br />
rev 逆转视图</p>

<p>数字输出&mdash;&mdash;&mdash;&ndash;&gt;<br />
名字 含义<br />
cols 列数目<br />
ittab 设置宽度<br />
lines 屏幕行数</p>

<p>布尔输出&mdash;&mdash;&mdash;&ndash;&gt;<br />
名字 含义<br />
chts 光标不可见<br />
hs 具有状态行<br />
echo -e &ldquo;&rdquo;\033[?25l&rdquo; 关闭光标<br />
echo -e &ldquo;\033[?25h&rdquo;</p>

<p>查找子串<br />
cat /tmp/debug.log | perl -e &lsquo;while(&lt;&gt;) { if ($_ =~ /hd_uid=(\d+)/) { print
&ldquo;$1\n&rdquo;; } } &lsquo; 匹配每行&rdquo;hd_uid=&ldquo;后面的数字<br />
if [ &hellip; ]<br />
then<br />
&hellip;<br />
fi</p>

<p>exit num</p>

<p>case $i in<br />
1)<br />
echo 1111;;<br />
2)<br />
echo 2222;;<br />
*)<br />
echo other;;<br />
esac</p>

<p>basename 返回shell脚本名</p>

<p>var=$(n=1;while ((n&lt;=$num));do echo $n;((n++));done) 双小括号表示算数运算<br />
echo $var</p>

<blockquote>
<blockquote>
<p>1 2</p>
</blockquote>
</blockquote>

<p>可以把$var拿来做for循环用</p>

<p>整数运算：<br />
[weibofengyun@localhost tfengyun_calc]$ ((a=a+1))<br />
[weibofengyun@localhost tfengyun_calc]$ echo $a<br />
1<br />
[weibofengyun@localhost tfengyun_calc]$ ((a=a+1))<br />
[weibofengyun@localhost tfengyun_calc]$ echo $a<br />
2<br />
[weibofengyun@localhost tfengyun_calc]$ echo $((a=a+1))<br />
3<br />
[weibofengyun@localhost tfengyun_calc]$ a=$((a=a+1))<br />
[weibofengyun@localhost tfengyun_calc]$ echo $a</p>

<p>4</p>

<p>[weibofengyun@localhost tfengyun_calc]$ a=$((a+1))<br />
[weibofengyun@localhost tfengyun_calc]$ echo $a<br />
5<br />
:s/procat/law/ 替换当前行第一个 procat为 law；</p>

<p>:s/procat/law/g 替换当前行所有 procat为 law；</p>

<p>:n,$s/procat/law/ 替换第n行开始到最后一行中每一行的第一个procat为law；</p>

<p>:n,$s/procat/law/g 替换第n行开始到最后一行中每一行所有 procat为law，其中n
为数字，若n为“.”，则表示从当前行开始到最后一行；</p>

<p>:.,200 s/^/xxx/g 把当前行到200行开头都加上xxx</p>

<p>:%s/procat/law/（等同于 :g/procat/s//law/） 替换每一行的第一个procat为law；</p>

<p>:%s/procat/law/g（等同于 :g/procat/s//law/g） 替换每一行中所有procat为law；
&mdash;&ndash;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;常用&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br />
:%s/procat/law/gc（等同于 :g/procat/s//law/gc） 一查询方式替换每一行中所有procat为law；</p>

<dl>
<dt>若替换字符串中需要替换“/”，则不能使用“/”在命令中作分割符，此时可以可以使用“#”作为分隔符，当命令中出现“#”，则“/”不再被系统认作分隔符</dt>
<dt>:s#procat/#law/# 替换当前行第一个procat/为 law/</dt>
</dl>

<p>:%s/fields:get\w*(&ldquo;/fd./g 正则替换 fields:getUIntField(&rdquo; fields:getStringField(&rdquo;
&mdash;-&gt; fd.</p>

<p>rpm -qpi rabbitmq-server-2.4.1-1.noarch.rpm</p>

<p>516 yum search python26<br />
517 yum install python26-devel.x86_64<br />
518 easy_install-2.6 MySQL-python<br />
519 yum install myql-devel<br />
520 yum install mysql-devel<br />
521 yum install mysql-devel.x86_64<br />
522 easy_install-2.6 MySQL-python<br />
1008 rpm -qa | grep mysql<br />
1009 rpm -qa | grep python<br />
1010 rpm -ql MySQL-python<br />
[xudongsong@zhuzhan_mg13 code_calculator]$ file filter.dic<br />
filter.dic: UTF-8 Unicode text 查看编码</p>

<p>while [ $var -qe 23 ]<br />
while [[ $var -qe 23 ]]<br />
while (($var&lt;23))</p>

<p>diff file1 file2</p>

<p>diff &ndash;strip-trailing-cr file1 file2 忽略windows下行末^M和linux下行末的区别</p>

<p>-N &ndash;new-file<br />
Treat absent files as empty. 不要放过新文件</p>

<p>-r 不要放过子目录</p>

<p>查看系统性能、磁盘io等指标的命令：<br />
489 vmstat -xdm 2<br />
490 iostat -xdm 2<br />
491 df -h<br />
492 top<br />
493 vmstat 2<br />
494 top</p>

<p>495 dstat<br />
mysql -h172.16.1.217 -usimilar -pqwer1234 similaranalysis<br />
mysql -h172.16.1.217 -usimilar -pqwer1234 similaranalysis &lt; result_sql_file &gt;
/dev/null 相当于在mysql命令行下执行source命令</p>

<p>load data infile &lsquo;/tmp/result_file_00&rsquo; replace into table t_results_00 fields
terminated by &lsquo;,&rsquo; (iArticleID1,iArticleID2,iSimilar);</p>

<p>echo &ldquo;load data infile &lsquo;/tmp/result<em>file</em>$index_hex&rsquo; replace into table
t<em>results</em>$index_hex fields terminated by &lsquo;,&rsquo;
(iArticleID1,iArticleID2,iSimilar);&rdquo; | mysql -h172.16.1.217 -usimilar
-pqwer1234 similaranalysis 相当于在mysql命令行下执行load命令</p>

<p>也可以用mysql -e &lsquo;xxx&rsquo; (However, if the MySQL client software is installed on the
remote machine, you can instead use a client command such asmysql -e &ldquo;SELECT
&hellip;&rdquo; &gt;file_name to generate the file on the client host.)</p>

<p>MySQL replace into 有三种形式：<br />
1. replace into tbl_name(col_name, &hellip;) values(&hellip;)<br />
2. replace into tbl_name(col_name, &hellip;) select &hellip;</p>

<p>3. replace into tbl_name set col_name=value, &hellip;</p>

<p>sync是个非常好的工具用来增量备份和把网站做镜像(mirror).</p>

<p>1. 同步一台机子中的两个文件夹.<br />
引用<br />
rsync –av /path/to/source /home/nixtutor/rsync/daily<br />
2. 同步一个机子中的文件夹到另外一台机子<br />
引用<br />
rsync –av /path/to/source user@nixutor.com:/home/nixtutor/rsync/daily<br />
3. 默认的rsync只会传输新的文件和文件增量,但是不会删除不存在的文件.如果你确实想要删除已经不存在文件,你需要加上&rdquo;–delete&rdquo;参数.<br />
引用<br />
rsync –av –delete /path/to/source user@nixutor.com:/home/nixtutor/rsync/daily<br />
4. 下面这个例子,我们只同步.iso文件.<br />
引用<br />
rsync -zrv –include=&rdquo;*.iso&rdquo; host:/home/nixtutor /home/denny</p>

<p>但是如果遇到ssh不是22端口的呢？man了半天，其实很简单<br />
rsync -zvrtopg -e ‘ssh -p 端口</p>

<p>同步报错</p>

<p>rsync: failed to set permissions on &ldquo;/data
jj/gameserver/startsh/conf/refreshConn.sh&rdquo;: Operation not permitted (1)</p>

<p>解决：Replace -avz with -rltvz. (The -a option is equivalent to -rlptgoD.)</p>

<p>CHANGE MASTER TO
MASTER_HOST=&lsquo;172.16.1.217&rsquo;,MASTER_USER=&lsquo;repl&rsquo;,MASTER_PASSWORD=&lsquo;repl&rsquo;,MASTER_LOG_FILE=&lsquo;mysql-
bin.000224&rsquo;,MASTER_LOG_POS=669460601;</p>

<p>show create table t_titles \G;</p>

<p>show index from wom_comment_sina; 列出数据表的索引</p>

<p>cat tmp_2 | uniq -c 统计各相同行出现的次数<br />
cat 1.txt |awk &lsquo;{sum += $1};END</p>

<p>GRANT SELECT, INSERT ON mydb.* TO &lsquo;someuser&rsquo;@&lsquo;somehost&rsquo;;<br />
grant all privileges on vtdc.* to joe@10.163.225.87 identified by ‘123′;</p>

<p>grant all privileges on vtsimilaranalysis.* to similar@&lsquo;%&rsquo; identified by
&lsquo;qwer1234&rsquo;;</p>

<p>对于需要执行select into outfile 语句的用户需要授予FILE权限：GRANT FILE ON <em>.</em> TO &lsquo;XXX&rsquo;@&lsquo;%&rsquo;
IDENTIFIED BY &lsquo;XXX&rsquo;;</p>

<p>对于需要执行grant语句的用户需要授权的时候加上with grant option： grant all privileges on <em>.</em> to
root@&lsquo;%&rsquo; identified by &lsquo;123456&rsquo; with grant option;</p>

<p>如果root密码忘记怎么办呢？可以去/etc/my.cnf中加入选项skip-grant-
tables，重启mysql，用root登录进去以后直接修改mysql.user表中的数据（带skip-grant-
tables选项启动的mysql不能执行grant语句），密码要用password(&lsquo;xxxx&rsquo;)加密更新到对应列</p>

<p>revoke all privileges on <em>.</em> from mastert@&lsquo;%&rsquo;;
取消授权（该用户还是可以连上Mysql，只是没有操作权限，在mysql.user表中还是可以看到该用户）</p>

<p>drop user weibofengyun; 删除用户（mysq.user表中该用户信息也会消失）</p>

<p>drop user weibofengyun@&lsquo;%&rsquo;;</p>

<p>mysql授权后要flush privileges;才能生效<br />
CREATE USER &lsquo;jeffrey&rsquo;@&lsquo;localhost&rsquo; IDENTIFIED BY &lsquo;mypass&rsquo;;<br />
sar -n DEV 2 网卡流量<br />
iostat -xkd 3<br />
ALTER TABLE t_results_9c ADD INDEX ( iSimilar );<br />
ALTER TABLE t_results_9c DROP INDEX iSimilar;<br />
mysql -e &ldquo;kill 172222&rdquo;</p>

<p>mysqlcheck -c -r dbname tablename</p>

<p>等效于mysql命令行下执行repair table tablename</p>

<p>在大数据量load data时候为加快速度可以先把key屏蔽掉，入库完成后再开启key:<br />
方案1：<br />
a. Execute a FLUSH TABLES statement or a mysqladmin flush-tables command.</p>

<p>b. Use myisamchk &ndash;keys-used=0 -rq /path/to/db/tbl_name to remove all use of
indexes for the table.</p>

<p>c. Insert data into the table with LOAD DATA INFILE. This does not update any
indexes and therefore is very fast.</p>

<p>d. If you intend only to read from the table in the future, use myisampack to
compress it. See Section 13.5.3.3, “Compressed Table Characteristics”.</p>

<p>e. Re-create the indexes with myisamchk -rq /path/to/db/tbl_name. This creates
the index tree in memory before writing it to disk, which is much faster that
updating the index during LOAD DATA INFILE because it avoids lots of disk
seeks. The resulting index tree is also perfectly balanced.</p>

<p>f. Execute a FLUSH TABLES statement or a mysqladmin flush-tables command.<br />
方案2：<br />
ALTER TABLE tbl_name DISABLE KEYS;<br />
ALTER TABLE tbl_name ENABLE KEYS;</p>

<p>crontab<br />
分钟(0-59) 小时(0-23) 日(1-31) 月(1-12) 星期(1-7) 命令</p>

<p>awk字符串处理：<br />
gsub(r,s) 在整个$0中用s替代r<br />
gsub(r,s,t) 在整个t中用s替代r<br />
index(s,t) 返回s中字符串t的第一位置<br />
length(s) 返回s长度<br />
match(s,r) 测试s是否包含匹配r的字符串<br />
split(s,a,fs) 在fs上将s分成序列a<br />
sprint(fmt,exp) 返回经fmt格式化后的exp<br />
sub(r,s) 用$0中最左边最长的子串代替s<br />
substr(s,p) 返回字符串s中从p开始的后缀部分<br />
substr(s,p,n) 返回字符串s中从p开始长度为n的后缀部分</p>

<p>cat tuiguang.urlip.data.12 | awk &lsquo;{url=substr($2,0,index($2,&ldquo;hf=&rdquo;)-2); if
(url!=last){print $0;} last=url;}&rsquo;<br />
cat tuiguang.urluid.data.12 | awk &lsquo;{url=substr($2,0,index($2,&ldquo;hf=&rdquo;)-2); if
(url!=last){print $1,count&rdquo;-&ldquo;$2,$3,$4,$5;count++;} last=url;}&lsquo;&gt;urluid.12<br />
cat result.txt | awk -F&rsquo;\t&rsquo; &lsquo;{docId=$2; $1=&ldquo;&rdquo;; $2=&ldquo;&rdquo;; print docId,&rdquo;:&ldquo;,$0}&rsquo; &gt;
new_result.txt</p>

<p>mysql命令行下使用load data命令时加上LOCAL选项会从命令行的客户端机器寻找数据文件，不加LOCAL选项会从server端寻找文件。</p>

<p>source命令是mysql客户端的功能，不是sql语句，所以source处理的sql文件只能是客户端机器上的文件</p>

<p>source后接的文件路径不需要用引号</p>

<p>strace -p 23656</p>

<p>python /usr/lib64/python2.4/site-packages/jcc/<strong>init</strong>.py<br />
python /usr/lib64/python2.4/site-packages/jcc/<strong>init</strong>.py &ndash;jar paoding-
analysis.jar &ndash;classpath lib/lucene-core-2.2.0.jar &ndash;classpath lib/commons-
logging.jar &ndash;classpath lib/lucene-analyzers-2.2.0.jar &ndash;classpath lib/lucene-
highlighter-2.2.0.jar &ndash;python paoding &ndash;build<br />
sudo python /usr/lib64/python2.4/site-packages/jcc/<strong>init</strong>.py &ndash;jar paoding-
analysis.jar &ndash;classpath lib/lucene-core-2.2.0.jar &ndash;classpath lib/commons-
logging.jar &ndash;classpath lib/lucene-analyzers-2.2.0.jar &ndash;classpath lib/lucene-
highlighter-2.2.0.jar &ndash;python paoding &ndash;install</p>

<p>bash下面寻找历史命令：ctrl+r</p>

<p>某些输入状态下不能删除时可以用crtl+backspace删除</p>

<p>show staus; 查看状态<br />
show status like &lsquo;%Open_tables%&lsquo;; 打开的数据表数量</p>

<p>show processlist; 查看mysql正在执行的操作(进程)</p>

<p>show full processlist;</p>

<p>SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST; 与上一行等效，可做过滤等操作（如下所示）</p>

<p>SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST where USER = &lsquo;womht&rsquo; and command
!= &lsquo;Sleep&rsquo; order by time asc\G</p>

<p>select * from information_schema.processlist where info is not null\G</p>

<p>sudo mysqladmin processlist 与上述查询等效</p>

<p>查看Mysql执行的所有SQL语句：<a href="http://stackoverflow.com/questions/568564/how-can-i-view-">http://stackoverflow.com/questions/568564/how-can-i-view-</a>
live-mysql-queries</p>

<p>show processlist看不到很快就结束的SQL</p>

<p>慢查询日志又只能看到耗时达到阀值的SQL</p>

<p>要看实时的、所有的SQL就得从general_log_file来看了，SHOW VARIABLES LIKE &ldquo;general_log%&ldquo;; SET
GLOBAL general_log = &lsquo;ON&rsquo;;</p>

<p>show engines; 查询mysql的引擎</p>

<p>show variables; 查看所有的配置变量</p>

<p>show variables like &lsquo;%log%&rsquo;; 查看包含log的配置变量</p>

<p>上述两个mysql交互模式下的命令跟bash命令行下的如下命令等效：</p>

<p>$ mysqladmin variables</p>

<p>mysql打开log_slow_queries记录慢查询，用&ndash;log-slow-queries[=file_name]
&ndash;long_query_time=# 启动mysqld</p>

<p>或者把这些条目添加到my.cnf，然后用/etc/init.d/mysqld启动服务也是一个效果（貌似新版本改成slow_query_log了）</p>

<p>参考：<a href="http://dev.mysql.com/doc/refman/5.1/en/slow-query-log.html">http://dev.mysql.com/doc/refman/5.1/en/slow-query-log.html</a></p>

<p>sudo /sbin/tune2fs -l /dev/sda2 | grep inodes 查看剩余节点数</p>

<p>rename table t_wiki_doc_text_1w to t_wiki_doc_text; #数据表的重命名</p>

<p>数据表的复制怎么搞呢？（create table like可以创建一个相同结构的表！）</p>

<p>mysql&gt; select * from xds;<br />
+&mdash;-+&mdash;&mdash;+&mdash;&ndash;+<br />
| id | a | b |<br />
+&mdash;-+&mdash;&mdash;+&mdash;&ndash;+<br />
| 1 | good | 100 |<br />
+&mdash;-+&mdash;&mdash;+&mdash;&ndash;+<br />
1 row in set (0.01 sec)<br />
mysql&gt; create table xds_2 like xds;<br />
Query OK, 0 rows affected (0.06 sec)<br />
mysql&gt; insert into xds_2 select * from xds;<br />
Query OK, 1 row affected (0.00 sec)<br />
Records: 1 Duplicates: 0 Warnings: 0<br />
mysql&gt; rename table xds_2 to xds_1;<br />
Query OK, 0 rows affected (0.00 sec)</p>

<p>拷贝大文件命令nc,不需要加密所以比scp快<br />
nc -l port &gt; filename 接收方<br />
nc destip port &lt; filename 发送方</p>

<p>导出csv格式文件：<br />
select * from t_wiki_doc_text into outfile &lsquo;/data/t_wiki_doc_text&rsquo; fields
terminated by &lsquo;,&rsquo; optionally enclosed by &lsquo;&ldquo;&rsquo; lines terminated by &lsquo;\n&rsquo;;
#换行有问题，会破坏csv格式<br />
select iDocID, replace(replace(ifnull(sTitle,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as title,
replace(replace(ifnull(sContent,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as content from
t_wiki_doc_text limit 0,1000 into outfile &lsquo;/data/t_wiki_doc_text&rsquo; fields
terminated by &lsquo;,&rsquo; escaped by &lsquo;\\&rsquo; optionally enclosed by &lsquo;&ldquo;&rsquo; lines terminated
by &lsquo;\n&rsquo;; #回车和换行都替换成了空格</p>

<p>nc和tar可以用来快速的在两台机器之间传输文件和目录，比ftp和scp要来得简单的多。由于nc是一个超轻量的命令，所以一般busybox都会集成它。当一个linux终端，比如linux
pda, 通过usblan的方式连接到另一台linux主机的时候，这样的嵌入式终端上一般不会集成ftp server, ssh
server这样比较笨重的服务，这个时候， nc可能成为唯一的上传手段。</p>

<p>比如将机器A上的mytest目录上传到到机器 B(192.168.0.11)上，只需要：</p>

<p>在机器B上，用nc来监听一个端口，随便就好，只要不被占用；并且将收到的数据用tar展开。-l代表监听模式。<br />
#nc -l 4444 |tar -C /target/dir -xf -</p>

<p>然后，在A上通过nc和 tar发送mytest目录。使用一致的4444的端口。<br />
#tar -C mytest|nc 192.168.0.11 4444</p>

<p>g++编译c++程序时如何解决动态库的问题<br />
拿clucene举例，cmake、make
install之后clucene动态库在/usr/local/lib/下面(libclucene_core.so),静态库在/usr/local/include/下面<br />
编译g++ -o test test.cpp -L/usr/local/lib -lclucene_core (把so文件的前缀lib和后缀名去掉然后用-
l连接上)<br />
运行前把动态库的位置设置到环境变量中，export LD_LIBRARY_PATH=/usr/local/lib, 然后./test即可<br />
g++ -DTEST 加入预编译宏TEST</p>

<p>g++ -g 加入调试信息，可用gdb调试</p>

<p>如何避免每次都export LD_LIBRARY_PATH:</p>

<p>[root@localhost tutorial]# cat /etc/ld.so.conf.d/boost_python.conf<br />
/usr/local/boost/lib/<br />
[root@localhost tutorial]# sudo ldconfig</p>

<p>vim /etc/rc.local 开机启动<br />
chkconfig &ndash;list 查看开机启动的项目，对应/etc/init.d下面的程序<br />
/etc/rc0.d .. /etc/rc6.d 对应的是六个运行级别(runlevel)要启动的程序</p>

<p>samba文件共享<br />
apt-get install samba (在ubuntu上做的共享)<br />
vi /etc/samba/smb.conf<br />
smbapasswd -a username<br />
从其他机器访问： \\ip\username</p>

<p>vi ~/.bashrc , add :<br />
alias sss=&lsquo;ssh -p 50718&rsquo;<br />
alias sss217=&lsquo;ssh -p 50718 172.16.1.217&rsquo;</p>

<p>ubuntu下安装软件 apt-get install xxx<br />
ubuntu下查询已安装软件 aptitude search xxx<br />
ubuntu下查询仓库里的软件 apt-cache search xxx</p>

<p>在ubuntu下用ctrl+alt+[f1..f6]可以打开各个tty终端，用ctrl+alt+f7是图形界面终端,用putty等连接上去的是pts终端（模拟终端，不是真正的终端）</p>

<p>if [ $# -lt 8 ]<br />
then<br />
echo -e &ldquo;\nUsage:./create_csv.sh host port user passwd db csv_file_dir
docs_per_dir docs_per_file\n&rdquo;<br />
exit 1<br />
fi</p>

<p>db_host=$1<br />
db_port=$2<br />
db_user=$3<br />
db_passwd=$4<br />
db_name=$5<br />
csv_file_dir=$6<br />
docs_per_dir=$7<br />
docs_per_file=$8</p>

<p>verf=<code>expr $docs_per_dir % $docs_per_file</code><br />
if [ $verf -ne 0 ]<br />
then<br />
echo &ldquo;$docs_per_dir%$docs_per_file != 0 &ldquo;<br />
exit 1<br />
fi</p>

<p>filename=&ldquo;/tmp/t_wiki_doc_text&rdquo;<br />
if [ -f $filename -o -d $filename ]<br />
then<br />
echo &ldquo;&lsquo;$filename&rsquo; exists alreadly. rm it first.&rdquo;<br />
exit 1<br />
fi</p>

<p>starttime=<code>date</code><br />
echo &ldquo;started at $starttime..&rdquo;</p>

<p>sql=&ldquo;select a.DOC_ID, b.DOC_SCORE as score,
replace(replace(ifnull(a.DOC_TITLE,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as title,
replace(replace(ifnull(a.DOC_TEXT,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as content from
t_wiki_doc_text as a, t_wiki_doc as b where a.DOC_ID = b.DOC_ID and
b.DOC_STATE = 1 into outfile &lsquo;$filename&rsquo; fields terminated by &lsquo;,&rsquo; escaped by
&lsquo;\\\&rsquo; optionally enclosed by &lsquo;\&ldquo;&rsquo; lines terminated by &lsquo;\n&rsquo;;&rdquo;<br />
echo $sql | mysql -h$db_host -P$db_port -u$db_user -p$db_passwd $db_name</p>

<p>endtime=<code>date</code><br />
echo &ldquo;$endtime dump t_wiki_doc_text to &lsquo;$filename&rsquo; done.&rdquo;</p>

<p>if [ -d $csv_file_dir -o -f $csv_file_dir ]<br />
then<br />
rm -rf $csv_file_dir<br />
fi<br />
mkdir $csv_file_dir</p>

<p>files_per_dir=<code>expr $docs_per_dir / $docs_per_file</code><br />
lineNum=<code>wc -l $filename |awk '{print $1;}'</code><br />
fileNum=<code>expr ${lineNum} + ${docs_per_file} - 1</code><br />
fileNum=<code>expr ${fileNum} / ${docs_per_file}</code><br />
dirNum=<code>expr ${fileNum} + ${files_per_dir} - 1</code><br />
dirNum=<code>expr ${dirNum} / ${files_per_dir}</code></p>

<p>for ((i=1; i&lt;=$fileNum; i++))<br />
do<br />
dirIndex=<code>expr $i + $files_per_dir - 1</code> #1,2,3&hellip;<br />
dirIndex=<code>expr $dirIndex / $files_per_dir</code><br />
dirNum2=<code>expr $dirIndex \\* $docs_per_dir</code><br />
dirNum1=<code>expr $dirNum2 - $docs_per_dir + 1</code><br />
dirPath=&ldquo;$csv_file_dir/$dirNum1-$dirNum2&rdquo;<br />
if [ ! -d $dirPath ]<br />
then<br />
mkdir $dirPath<br />
fi<br />
fileNum2=<code>expr $i \\* $docs_per_file</code><br />
fileNum1=<code>expr $fileNum2 - $docs_per_file + 1</code><br />
sed -n &ldquo;${fileNum1},${fileNum2}p&rdquo; $filename &gt; &ldquo;$dirPath/$fileNum1-$fileNum2&rdquo;<br />
done</p>

<p>endtime=<code>date</code><br />
echo -e &ldquo;$endtime cut file to small files &lsquo;$csv_file_dir&rsquo; done.\n&rdquo;</p>

<p>echo &ldquo; set @seqid:=0;select @seqid:=@seqid+1 as seqid,id from t_test into
outfile &lsquo;/tmp/t_test&rsquo;;&rdquo; | mysql -hlocalhost -uroot -pqwer1234 test
给select的结果加上行号</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;一个导出csv文件的小脚本，虽小却耗我不少时间&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
set -e 设置之后，脚本出错(异常)即停止，不会继续往下执行（set +e 作用相反）</p>

<p>#!/bin/bash<br />
if [ $# -lt 2 ]<br />
then<br />
echo -e &ldquo;\nUsage:/bash/sh $0 input(&lsquo;host,port,user,passwd,db,docs_per_file&rsquo;)
output(&lsquo;csv_file_dir&rsquo;)\n&rdquo;<br />
exit 1<br />
fi</p>

<p>input=$1<br />
output=$2</p>

<p>db_host=<code>echo $input | awk -F, '{print $1}'</code><br />
db_port=<code>echo $input | awk -F, '{print $2}'</code><br />
db_user=<code>echo $input | awk -F, '{print $3}'</code><br />
db_passwd=<code>echo $input | awk -F, '{print $4}'</code><br />
db_name=<code>echo $input | awk -F, '{print $5}'</code><br />
docs_per_file=<code>echo $input | awk -F, '{print $6}'</code><br />
csv_file_dir=$output</p>

<p>filename=&ldquo;/tmp/t_wiki_doc_text&rdquo;<br />
if [ -f $filename -o -d $filename ]<br />
then<br />
echo &ldquo;&lsquo;$filename&rsquo; exists alreadly. rm it first.&rdquo;<br />
exit 1<br />
fi</p>

<p>starttime=<code>date</code><br />
echo &ldquo;started at $starttime..&rdquo;</p>

<p>sql=&ldquo;set @seqid:=0; select @seqid:=@seqid+1 as seqid, a.DOC_ID, b.DOC_SCORE as
score, replace(replace(ifnull(a.DOC_TITLE,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as title,
replace(replace(ifnull(a.DOC_TEXT,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as content from
t_wiki_doc_text as a, t_wiki_doc as b where a.DOC_ID = b.DOC_ID and
b.DOC_STATE = 1 into outfile &lsquo;$filename&rsquo; fields terminated by &lsquo;,&rsquo; escaped by
&lsquo;\\\&rsquo; optionally enclosed by &lsquo;\&ldquo;&rsquo; lines terminated by &lsquo;\n&rsquo;;&rdquo;<br />
echo &ldquo;$sql&rdquo; | mysql -h$db_host -P$db_port -u$db_user -p$db_passwd $db_name</p>

<p>endtime=<code>date</code><br />
echo &ldquo;$endtime dump t_wiki_doc_text to &lsquo;$filename&rsquo; done.&rdquo;</p>

<p>if [ -d $csv_file_dir -o -f $csv_file_dir ]<br />
then<br />
rm -rf $csv_file_dir<br />
fi<br />
mkdir $csv_file_dir</p>

<p>lineNum=<code>wc -l $filename |awk '{print $1;}'</code><br />
fileNum=<code>expr ${lineNum} + ${docs_per_file} - 1</code><br />
fileNum=<code>expr ${fileNum} / ${docs_per_file}</code><br />
for ((i=1; i&lt;=$fileNum; i++))<br />
do<br />
fileNum2=<code>expr $i \\* $docs_per_file</code><br />
fileNum1=<code>expr $fileNum2 - $docs_per_file + 1</code><br />
if [ $fileNum2 -gt $lineNum ]<br />
then<br />
fileNum2=$lineNum<br />
fi<br />
sed -n &ldquo;${fileNum1},${fileNum2}p&rdquo; $filename &gt;
&ldquo;$csv_file_dir/$fileNum1-$fileNum2&rdquo;<br />
done</p>

<p>endtime=<code>date</code><br />
echo -e &ldquo;$endtime cut file to small files &lsquo;$csv_file_dir&rsquo; done.\n&rdquo;</p>

<p>if [ $# -lt 7 ]<br />
then<br />
echo -e &ldquo;\nUsage:./create_csv.sh host port user passwd db csv_file_dir
docs_per_file\n&rdquo;<br />
exit 1<br />
fi</p>

<p>db_host=$1<br />
db_port=$2<br />
db_user=$3<br />
db_passwd=$4<br />
db_name=$5<br />
csv_file_dir=$6<br />
docs_per_file=$7</p>

<p>filename=&ldquo;/tmp/t_wiki_doc_text&rdquo;<br />
if [ -f $filename -o -d $filename ]<br />
then<br />
echo &ldquo;&lsquo;$filename&rsquo; exists alreadly. rm it first.&rdquo;<br />
exit 1<br />
fi</p>

<p>starttime=<code>date</code><br />
echo &ldquo;$starttime started..&rdquo;<br />
if [ -f $filename ]<br />
then<br />
rm $filename<br />
echo &ldquo;remove old file &lsquo;$filename&rsquo;&rdquo;<br />
fi</p>

<p>sql=&ldquo;select a.DOC_ID, b.DOC_SCORE as score,
replace(replace(ifnull(a.DOC_TITLE,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as title,
replace(replace(ifnull(a.DOC_TEXT,&ldquo;),&rsquo;\n&rsquo;,&rsquo; &lsquo;),&rsquo;\r&rsquo;,&rsquo; &lsquo;) as content from
t_wiki_doc_text as a, t_wiki_doc as b where a.DOC_ID = b.DOC_ID and
b.DOC_STATE = 1 into outfile &lsquo;$filename&rsquo; fields terminated by &lsquo;,&rsquo; escaped by
&lsquo;\\\&rsquo; optionally enclosed by &lsquo;\&ldquo;&rsquo; lines terminated by &lsquo;\n&rsquo;;&rdquo;<br />
echo $sql | mysql -h$db_host -P$db_port -u$db_user -p$db_passwd $db_name</p>

<p>endtime=<code>date</code><br />
echo &ldquo;$endtime dump t_wiki_doc_text to &lsquo;$filename&rsquo; done.&rdquo;</p>

<p>if [ -d $csv_file_dir -o -f $csv_file_dir ]<br />
then<br />
rm -rf $csv_file_dir<br />
fi<br />
mkdir $csv_file_dir</p>

<p>lineCount=0<br />
file=&ldquo;$csv_file_dir/1-$docs_per_file&rdquo;<br />
if [ -f $file -o -d $file ]<br />
then<br />
rm -rf $file<br />
if [ $? -ne 0 ]<br />
then<br />
echo &ldquo;rm &lsquo;$file&rsquo; failed.&rdquo;<br />
exit 1<br />
fi<br />
fi<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;一个导出csv文件的小脚本，虽小却耗我不少时间&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>dpkg显示安装包的头文件以及库的路径</p>

<p>dpkg -L libalberta2-dev</p>

<p>MySQL只在认为走索引可以筛去85%以上数据的时候，才使用索引，如果达不到这个标准，索引是无意义的。<br />
前缀索引：MySQL可以利用索引的前向部分，但不可以利用后向部分，不支持反向索引。<br />
例如：SELECT col2 FROM table WHERE col1=1;可以使用索引(col1,col2)，但不可以使用(col2,col1).<br />
不等比较的优化：如果索引的前向部分在WHERE中是等于，那么可以使用索引，如果索引的前向部分再WHERE中是不等比较，那么不可以为后面的等于比较使用索引<br />
例如：SELECT col1 FROM table WHERE col2=1 AND col3
&gt;10;可以完全使用索引(col2,col3)，但只可以使用(col3,col2)的前缀，<br />
排序的优化：可以在条件是等于的时候继续使用索引排序，或者条件中的不等于字段就是排序字段。<br />
例如：SELECT col1 FROM table WHERE col2=1 AND col3&gt;0 ORDER BY
col3，可以完全使用索引(col2,col3)避免排序。但条件是col2&lt;1 AND col3=0 ORDER BY
col3时则只能使用col2排除记录，不可以用来排序。<br />
GROUP BY/DISTINCT也是以排序为基础，优化同上。</p>

<p>ubuntu下alt+f2可以运行应用程序，gnome-terminal可以启动终端</p>

<p>sudo yum install python-setuptools<br />
sudo easy_install virtualenv<br />
virtualenv venv<br />
cd venv/<br />
bin/easy_install django</p>

<p>要安装的库有多个版本时，可以用easy_install
PackageName==1.2.3指定版本号做安装<a href="http://peak.telecommunity.com/DevCenter/EasyInstall#changing-">http://peak.telecommunity.com/DevCenter/EasyInstall#changing-</a>
the-active-version</p>

<p>python有多个版本时候，如何用easy_install把包安装到指定的python版本中去：/usr/local/bin/python2.6 -m
easy_install ThePkgName</p>

<p>~/venv/bin/python manage.py runserver 0.0.0.0:8000<br />
~/venv/bin/easy_install python-memcached<br />
~/venv/bin/python manage.py fetchfollowers &ndash;screen_name 吓人的鸟<br />
~/venv/bin/python manage.py syncdb<br />
~/venv/bin/python manage.py runserver 0.0.0.0:8000</p>

<p>python -m easy_install twisted 用easy_install把twisted库安装到指定的Python环境下(which
python可以看到这条命令的python是什么环境下的python)</p>

<p>python程序数据库入库报错</p>

<p>Traceback (most recent call last):<br />
File &ldquo;main.py&rdquo;, line 225, in<br />
(hashlib.md5(imgUrl).hexdigest(), imgUrl, database.MySQLdb.Binary(imgData)))<br />
File &ldquo;/home/dongsong/boosencms/src/boosenspider/database.py&rdquo;, line 108, in
execute<br />
affects = cursor.execute(sql, args)<br />
File &ldquo;build/bdist.linux-x86_64/egg/MySQLdb/cursors.py&rdquo;, line 174, in execute<br />
File &ldquo;build/bdist.linux-x86_64/egg/MySQLdb/connections.py&rdquo;, line 36, in
defaulterrorhandler<br />
_mysql_exceptions.OperationalError: (1153, &ldquo;Got a packet bigger than
&lsquo;max_allowed_packet&rsquo; bytes&rdquo;)</p>

<p>解决办法：设置max_allowed_packet</p>

<p>[root@bogon dongsong]#<br />
[root@bogon dongsong]# vi /etc/my.cnf</p>

<p>[mysqld]<br />
datadir=/var/lib/mysql<br />
socket=/var/lib/mysql/mysql.sock<br />
user=mysql</p>

<h1 id="disabling-symbolic-links-is-recommended-to-prevent-assorted-security-risks">Disabling symbolic-links is recommended to prevent assorted security risks</h1>

<p>symbolic-links=0<br />
max_allowed_packet=10485760</p>

<p>[mysqld_safe]<br />
log-error=/var/log/mysqld.log<br />
pid-file=/var/run/mysqld/mysqld.pid</p>

<p>不中止服务程序进程直接将日志文件移走，两种方法：</p>

<p>1.在程序中提供对信号SIGUS1的处理程序，收到SIGUS1重新打开输出文件out.txt</p>

<p>mv out.txt xx/xx (inode不会改变)</p>

<p>kill SIGUS1 进程ID</p>

<p>2.程序是别人写的，没有收到信号则重新打开文件的处理逻辑</p>

<p>cp out.txt xx/xx (inode不会改变)</p>

<p>echo -n &gt;out.txt 截断out.txt，out.txt的inode不会改变，内容被清空</p>

<p>ntpdate time.windows.com &amp;&amp; hwclock -w</p>

<p>ntpdate pool.ntp.org</p>

<p>linux设置时间 date -s</p>

<p>写入bios神马的 clock -w</p>

<p>linux时间校准（网络同步）ntpdate</p>

<p>如果是virtualBox中的linux系统，就算关闭网络时间同步可能也不行，因为virtualBox会自动根据宿主机器对虚拟系统做时间校正，这种情况可以修改实体机时间来做测试</p>

<p>cat /proc/partitions 查看分区信息</p>

<p>yum install安装的包可以用 yum remove删除</p>

<p>easy_install 安装的python包可以用easy_install -m 删除，貌似更好的方式使用<code>pip uninstall</code> pkg_name
(<a href="http://stackoverflow.com/questions/1231688/how-do-i-remove-packages-">http://stackoverflow.com/questions/1231688/how-do-i-remove-packages-</a>
installed-with-pythons-easy-install)</p>

<pre><code>$ wget https://bootstrap.pypa.io/get-pip.py
$ python get-pip.py
</code></pre>

<p>源码编译的包信息无法通过工具查询到和管理，需要自行记住安装路径，卸载时也需要手动从安装目录删除，所以应该尽量使用yum rpm apt等包管理工具</p>

<p>检查本地某端口是否在监听</p>

<p>[dongsong@bogon api]$ telnet localhost 9306<br />
Trying 127.0.0.1&hellip;<br />
telnet: connect to address 127.0.0.1: Connection refused</p>

<p>rpm -ivh <a href="http://mirrors.sohu.com/fedora-epel/6/i386/epel-">http://mirrors.sohu.com/fedora-epel/6/i386/epel-</a>
release-6-7.noarch.rpm 从url安装rpm包</p>

<p>神奇的sql，神马意思你懂的</p>

<p>update t_site_bbs set count = (select count(*) from t_raw_data where
t_raw_data.site = t_site_bbs.site and t_raw_data.bbs = t_site_bbs.bbs) where
(site,bbs) in (select site,bbs from t_raw_data)</p>

<p>Image包的问题</p>

<p>#IOError: decoder jpeg not available<br />
#Fix:<br />
#First remove your last install!<br />
rm -rf /usr/lib/python2.4/site-packages/PIL<br />
rm /usr/lib/python2.4/site-packages/PIL.pth<br />
rm ~/Imaging-1.1.6</p>

<p>#Make sure you install at the libraries for both JPEG support and FreeType2:<br />
yum install libjpeg<br />
yum install libjpeg-devel<br />
yum install freetype<br />
yum install freetype-devel</p>

<p>#Get PIL again and do the install:<br />
wget <a href="http://effbot.org/media/downloads/Imaging-1.1.6.tar.gz">http://effbot.org/media/downloads/Imaging-1.1.6.tar.gz</a><br />
tar -zxvf Imaging-1.1.6.tar<br />
cd Imaging-1.1.6/<br />
python setup.py build_ext -i</p>

<p>#Run the included test to make sure everything now works:<br />
python selftest.py</p>

<p>#If everything worked do the real install:<br />
$ python setup.py install</p>

<p>create database official_boosencms CHARACTER SET utf8;</p>

<p>用history找到的命令可以用 !命令号 再次执行，类似于 !xxx 执行以xxx开头的上一条命令</p>

<p>ls -l /proc/8634/task/ 可以看到进程的线程信息</p>

<p>连接数决定了MySQL并发处理的能力，查看连接数<br />
show variables like &ldquo;max_connections&rdquo;;<br />
把最大连接数更新到600：<br />
set global max_connections = 200;<br />
也可以在配置文件中改（见mysql调优，只是要重启）</p>

<p>set global general_log = ON; 把常规查询日志打开，所有查询都会记录到 general_log_file指定的文件中</p>

<p>查看memcached状态(参考<a href="http://www.xmsigh.com/node/61">http://www.xmsigh.com/node/61</a>)</p>

<p>printf &ldquo;stats\r\n&rdquo; | nc 127.0.0.1 11211</p>

<p>stats | stats slabs | slabs items (more is here
<a href="http://lzone.de/articles/memcached.htm)">http://lzone.de/articles/memcached.htm)</a></p>

<p>要让mamcached的老数据不被新数据用“最近最少使用”原则挤出去，应该在启动memcached的时候加上参数-M，具体可参照memcache -h</p>

<p>要修改memcached的默认启动参数，可查看/etc/rc.d/init.d/memcached
（/etc/rc.d/init.d等同于/etc/init.d，二者由符号链接关联在了一起）找到相关配置或配置文件路径并做修改（默认配置文件是/etc/sysconfig/memcached）</p>

<p>select version(); 显示mysql版本</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&gt;</p>

<p>wget
<a href="http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.25a.tar.gz/from/http://cdn.mysql.com/">http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.25a.tar.gz/from/http://cdn.mysql.com/</a><br />
tar zvxf mysql-5.5.25a.tar.gz<br />
cd mysql-5.5.25a<br />
sudo yum install cmake -y<br />
sudo yum install ncurses ncurses-devel -y<br />
sudo yum install bison -y<br />
rm CMakeCache.txt<br />
cmake -DCMAKE_INSTALL_PREFIX=/home/xudongsong/apps/mysql-5.5.25/ .<br />
make -j 4 #利用4核CPU提速<br />
make install<br />
cd ~/apps/mysql-5.5.25/scripts/<br />
./mysql_install_db &ndash;help<br />
sudo ./mysql_install_db &ndash;datadir=/home/xudongsong/apps/mysql-5.5.25/data/
&ndash;user=mysql &ndash;basedir=/home/xudongsong/apps/mysql-5.5.25/ &ndash;no-defaults<br />
cd ../bin/<br />
./mysqld &ndash;verbose &ndash;help | less<br />
sudo chown -R mysql:mysql ../data<br />
sudo ./mysqld &ndash;no-defaults -u mysql -P3308
-h/home/xudongsong/apps/mysql-5.5.25/data/</p>

<p>sudo ./mysqld_safe &ndash;defaults-file=../my.cnf (相对于上一行的启动方式，更推荐这种)</p>

<p>mkfs -t ext3 /dev/sdc 磁盘格式化</p>

<p>mount -t ext3 /dev/sdc /data/ 挂载</p>

<p>vi /etc/fstab 自动挂载</p>

<p>/dev/sdc /data ext3 defaults 0 0</p>

<p>后面两个数字的含义：第一个表示dump 。一个备份工具。0就表示从不备份；第2个0表示fsck检查的顺序。0表示不检查。</p>

<p>[dongsong@bogon python_study]$ mail -s &ldquo;hello,吓人的鸟&rdquo; xudongsong0102@163.com<br />
hello,can you received it ?<br />
EOT</p>

<p>centos安装中文输入法</p>

<p>sudo yum install ibus ibus-pinyin -y</p>

<p>系统&mdash;首选项&mdash;输入法 启动ibus输入法</p>

<p>cat /proc/pid/status 各参数意义(man proc)</p>

<p>Name 应用程序或命令的名字<br />
State 任务的状态，运行/睡眠/僵死/<br />
SleepAVG 任务的平均等待时间(以nanosecond为单位)，交互式任务因为休眠次数多、时间长，它们的 sleep_avg
也会相应地更大一些，所以计算出来的优先级也会相应高一些。<br />
Tgid 线程组号<br />
Pid 任务ID<br />
Ppid 父进程ID<br />
TracerPid 接收跟踪该进程信息的进程的ID号<br />
Uid Uid euid suid fsuid<br />
Gid Gid egid sgid fsgid<br />
FDSize 文件描述符的最大个数，file-&gt;fds<br />
Groups<br />
VmSize(KB) 任务虚拟地址空间的大小 (total_vm-
reserved_vm)，其中total_vm为进程的地址空间的大小，reserved_vm：进程在预留或特殊的内存间的物理页<br />
VmLck(KB) 任务已经锁住的物理内存的大小。锁住的物理内存不能交换到硬盘 (locked_vm)<br />
VmRSS(KB) 应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss)<br />
VmData(KB) 程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据； (total_vm-shared_vm-stack_vm)<br />
VmStk(KB) 任务在用户态的栈的大小 (stack_vm)<br />
VmExe(KB) 程序所拥有的可执行虚拟内存的大小，代码段，不包括任务使用的库 (end_code-start_code)<br />
VmLib(KB) 被映像到任务的虚拟内存空间的库的大小 (exec_lib)<br />
VmPTE 该进程的所有页表的大小，单位：kb<br />
Threads 共享使用该信号描述符的任务的个数，在POSIX多线程序应用程序中，线程组中的所有线程使用同一个信号描述符。<br />
SigQ 待处理信号的个数<br />
SigPnd 屏蔽位，存储了该线程的待处理信号<br />
ShdPnd 屏蔽位，存储了该线程组的待处理信号<br />
SigBlk 存放被阻塞的信号<br />
SigIgn 存放被忽略的信号<br />
SigCgt 存放被俘获到的信号<br />
CapInh Inheritable，能被当前进程执行的程序的继承的能力<br />
CapPrm
Permitted，进程能够使用的能力，可以包含CapEff中没有的能力，这些能力是被进程自己临时放弃的，CapEff是CapPrm的一个子集，进程放弃没有必要的能力有利于提高安全性<br />
CapEff Effective，进程的有效能力</p>

<p>要使用终端的rz和sz功能上传下载文件：sudo yum install lrzsz</p>

<p>配置yum源（yum不好使了&hellip;）：</p>

<p>-&ndash;&gt;start</p>

<p>YumRepo Error: All mirror URLs are not using ftp, http[s] or file. Eg.
$releasever is not a valid release or hasnt been released yet/</p>

<p>wget <a href="http://download.fedoraproject.org/pub/epel/6/i386/epel-">http://download.fedoraproject.org/pub/epel/6/i386/epel-</a>
release-6-7.noarch.rpm<br />
sudo rpm -ivh epel-release-6-7.noarch.rpm<br />
yum repolist<br />
sudo yum install yum-priorities -y<br />
在/etc/yum.repos.d/epel.repo的epel部分加入<br />
priority=10<br />
yum check-update</p>

<p>参考：<a href="http://www.linuxmail.info/add-epel-centos-6/">http://www.linuxmail.info/add-epel-centos-6/</a></p>

<p>查看自己的出口公网ip</p>

<p>Windows: tracert www.google.com</p>

<p>Linux: wget <a href="http://members.3322.org/dyndns/getip">http://members.3322.org/dyndns/getip</a></p>

<p>cat getip /<em>got the ip</em>/</p>

<p>局域网IP段</p>

<p>A类：10.0.0.0 后三位自由分配<br />
B类：172.16.0.0 至172.31.0.0 后两位自由分配<br />
C类：192.168.0.0 后两位自由分配</p>

<p>shell做文件内容替换（下述是一个文件的例子，多个文件自己用for循环）</p>

<p>sed &rsquo;s/sinaweibo/weibo/g&rsquo; ./templates/weibo/maintain/reposts.html &gt; t.html</p>

<p>names=<code>cat /tmp/rename.txt | awk -F: '{print $1}'</code>;for name in $names; do sed
&rsquo;s/sinaweibo/weibo/g&rsquo; $name &gt; tmpfile; cp -f tmpfile $name;done;</p>

<p>2013-01-27成老师分享：</p>

<p>start&mdash;&gt;</p>

<p>lsmod<br />
modinfo<br />
lspci<br />
ls /sys<br />
ls /proc<br />
mount<br />
runlevel #运行级别<br />
telinit 3 #切换运行级别<br />
init 3<br />
dmesg #系统开机信息<br />
last #登录、开关机历史<br />
ls /var/log/message #内核和一些用户日志<br />
ls /etc #系统配置<br />
rpm -qf /etc/localtime #查看一个文件是由哪个软件包安装的<br />
rpm -ql glibc #查看一个软件包安装了哪些文件</p>

<p>ldd #查看一个程序链接了哪些动态库</p>

<p>用nm external.so查看动态库中的符号</p>

<p>查看带宽使用情况 nethogs</p>

<p>linux下把文件和目录用树状结构显示出来</p>

<p>sudo yum install tree -y</p>

<p>tree -d 把所有目录用树状结构显示</p>

<p>tree -a 把所有目录和文件用树状结构显示</p>

<p>tree -afsDF</p>

<p>tree -afsDtF</p>

<p>-f 打印每个文件和目录的全路径</p>

<p>-s 打印文件大小</p>

<p>-D 打印文件最后修改时间</p>

<p>-t 按照最后修改时间排序(默认降序，不知道咋按升序排)</p>

<p>-r 按照名字反序排(默认是按照名字的字母升序排)</p>

<p>-F 把目录后面加上/，便于区分文件和目录</p>

<p>-L 2 只递归两层</p>

<p>删除linux下文件结尾的^M： :%s/^M$//g (^M要用ctrl+V，ctrl+m来输入，不能用键盘上的^和M来拼凑)
其他方式参见：<a href="http://blog.csdn.net/huganle/article/details/7821199">http://blog.csdn.net/huganle/article/details/7821199</a></p>

<p>vim打开文件的时候不显示^M? 用vim -b xxx</p>

<p>dos2unix file也可以做上述转换</p>

<p>或者用vim filename, :set ff=unix</p>

<p>grep -rn &lsquo;^M&rsquo; 2 | grep php | grep -v &ldquo;.svn&rdquo; | grep -v 二进制 | awk -F: &lsquo;{print
$1}&rsquo; | uniq | xargs dos2unix</p>

<p>防火墙配置端口转发(/etc/sysconfig/iptables)：</p>

<p>-A PREROUTING -p tcp -m tcp &ndash;dport 80 -j DNAT &ndash;to-destination 172.20.0.xxx:15672<br />
-A POSTROUTING -p tcp -m tcp &ndash;dport 15672 -j SNAT &ndash;to-source 192.168.1.xxx</p>

<p>PREROUTING 是进来的， &ndash;dport ：如果目的端口是80端口， DANT:目的端口，就转发到 172.。。。的15672端口</p>

<p>POSTROUTONG是出去的，&ndash;dport:如果目的端口是15672端口，
&ndash;SNAT：改变源地址。就把源地址变成192.168.1.xxx(因为172.。。上面设置了 只有192.168.1.xxx可以访问这个15672端口)<br />
再在211上设置端口转发功能 echo 1 &gt; /proc/sys/net/ipv4/ip_forward 。默认是0。每次重启都要运行这个命令。</p>

<p>防火墙在指定端口接受指定IP机器的tcp连接</p>

<p>-A INPUT -p tcp &ndash;dport 80 -j ACCEPT</p>

<p>-A INPUT -s 192.168.1.211 -p tcp &ndash;dport 15672 -j ACCEPT</p>

<p>经过我的试验（2014.9.12）表明：防火墙把端口访问关闭，在该端口已经建立的连接没被立马掐断，只是数据不再继续转发了，所以客户端连接应该会在没收到ping包的情况下（对我们游戏项目而言）被掐断</p>

<p>[root@localhost skynet]# cat /etc/sysconfig/iptables</p>

<h1 id="firewall-configuration-written-by-system-config-firewall">Firewall configuration written by system-config-firewall</h1>

<h1 id="manual-customization-of-this-file-is-not-recommended">Manual customization of this file is not recommended.</h1>

<p>*filter<br />
:INPUT ACCEPT [0:0]<br />
:FORWARD ACCEPT [0:0]<br />
:OUTPUT ACCEPT [0:0]<br />
-A INPUT -m state &ndash;state ESTABLISHED,RELATED -j ACCEPT<br />
-A INPUT -p icmp -j ACCEPT<br />
-A INPUT -i lo -j ACCEPT<br />
-A INPUT -m state &ndash;state NEW -m tcp -p tcp &ndash;dport 22 -j ACCEPT<br />
#-A INPUT -m state &ndash;state NEW -m tcp -p tcp &ndash;dport 9999 -j ACCEPT
#必须加在REJECT（也就是下面那两行)之前！否则无效！！！<br />
-A INPUT -j REJECT &ndash;reject-with icmp-host-prohibited<br />
-A FORWARD -j REJECT &ndash;reject-with icmp-host-prohibited<br />
COMMIT</p>

<p>如何确定某个端口是被什么进程占用(监听)的？lsof -i :port</p>

<p>[dongsong@localhost twisted]$ netstat -lntp<br />
(No info could be read for &ldquo;-p&rdquo;: geteuid()=500 but you should be root.)<br />
Active Internet connections (only servers)<br />
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br />
tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN -<br />
tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN -<br />
tcp 0 0 0.0.0.0:35698 0.0.0.0:* LISTEN -<br />
tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN -<br />
tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN -<br />
tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN -<br />
tcp 0 0 :::111 :::* LISTEN -<br />
tcp 0 0 :::80 :::* LISTEN -<br />
tcp 0 0 :::22 :::* LISTEN -<br />
tcp 0 0 ::1:631 :::* LISTEN -<br />
tcp 0 0 :::40856 :::* LISTEN -<br />
[dongsong@localhost twisted]$ lsof -i :80<br />
[dongsong@localhost twisted]$ sudo lsof -i :80<br />
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br />
httpd 2020 root 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2080 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2081 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2082 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2083 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2084 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2085 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2086 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)<br />
httpd 2087 apache 4u IPv6 11856 0t0 TCP *:http (LISTEN)</p>

<p>lsof是用来列出已打开文件的</p>

<p>[dongsong@localhost boosencms]$ lsof | grep deleted<br />
vim 2383 dongsong 3u REG 253,0 12288 59742 /tmp/.tt.swp (deleted)</p>

<p>mutt发送邮件：<br />
echo &lsquo;哈罗，哈罗，能收到么？&rsquo;| mutt -s &lsquo;debug: can you see it&rsquo; xudongsong@boosen.com</p>

<p>数组：<br />
[weibofengyun@localhost tfengyun_calc]$ arr[0]=&lsquo;a&rsquo;<br />
[weibofengyun@localhost tfengyun_calc]$ arr[1]=&lsquo;b&rsquo;<br />
[weibofengyun@localhost tfengyun_calc]$ arr[2]=&lsquo;c&rsquo;<br />
[weibofengyun@localhost tfengyun_calc]$ echo $arr<br />
a<br />
[weibofengyun@localhost tfengyun_calc]$ echo ${arr[0]}<br />
a<br />
[weibofengyun@localhost tfengyun_calc]$ echo ${arr[1]}<br />
b<br />
[weibofengyun@localhost tfengyun_calc]$ echo ${arr[2]}<br />
c<br />
[weibofengyun@localhost tfengyun_calc]$ echo ${arr[<em>]}<br />
a b c<br />
[weibofengyun@localhost tfengyun_calc]$ arr[10]=&lsquo;cccccc&rsquo;<br />
[weibofengyun@localhost tfengyun_calc]$ echo ${arr[</em>]}<br />
a b c cccccc<br />
[weibofengyun@localhost tfengyun_calc]$ echo ${arr[10]}<br />
cccccc</p>

<p>函数：<br />
[weibofengyun@localhost ~]$ func() { if [[ $1 != 0 ]]; then echo Good bye.;
exit; fi }<br />
[weibofengyun@localhost ~]$ func 0<br />
[weibofengyun@localhost ~]$</p>

<p>drop table if exists tmp_user_followers_ids;
如果表存在就删除，貌似创建删除数据库、创建删除数据表都有对应语法，具体参考官方文档</p>

<p>查看binlog<br />
mysqlbinlog &ndash;start-position=205222565 &ndash;stop-position=205223589 104-relay-
bin.000198</p>

<p>od 格式化输出文件中的数据，此命令主要用来查看保存在二进制文件中的值。-c 按照字符输出</p>

<p>cat - getip.1 &lt; 25.sql #“-”表示标准输入<br />
cat /dev/fd/0 getip.1 &lt; 25.sql #“/dev/fd/0”和这个等效，在c程序中也可以用/dev/fd/0作为标准输入文件来打开</p>

<p>Unix环境高级编程第三章的习题：<br />
shell从左到右执行命令行，所以<br />
a.out &gt; outfile 2&gt;&amp;1<br />
首先设置标准输出到outfile,然后执行dups将标准输出复制到描述符2(标准错误)上，其结果是将标准输出和标准错误设置为相同的文件，即描述符1和2指向相同的文件表项。<br />
而对于命令行，<br />
a.out 2&gt;&amp;1 &gt; outfile<br />
由于首先执行dups，所以描述符2成为终端（假设命令是交互执行的），标准输出重定向到outfile。结果是描述符1指向outfile的文件表项，描述符2指向终端的文件表项。</p>

<p>今天（2013.9.18）遇到一个小问题<br />
吓人的鸟 16:17:09<br />
为什么我用myql -P不管指定3303还是3318都进到同一个数据库去了？<br />
成老师 16:19:35<br />
可能用的是socket连进去的，你指定 -h 127.0.0.1 -P 3303 试试看？<br />
吓人的鸟 16:19:43<br />
还真是&hellip;.</p>

<p>apache(httpd)虚拟主机配置（多个端口提供不同服务）</p>

<p>DocumentRoot /var/www/html/normal</p>

<p>Order allow,deny<br />
Allow from all</p>

<p>DocumentRoot /data/weibofengyun/workspace-php/tfengyunmgr/2<br />
ServerName www.tfengyun.com<br />
ErrorLog logs/www.tfengyun.com-error_log<br />
CustomLog logs/www.tfengyun.com-access_log common</p>

<p>Order allow,deny<br />
Allow from all</p>

<p>DocumentRoot /data/weibofengyun/workspace-php/tfengyun140-migrant/<br />
ServerName vip2.tfengyun.com<br />
ErrorLog logs/vip2.tfengyun.com-error_log<br />
CustomLog logs/vip2.tfengyun.com-access_log common</p>

<p>Order allow,deny<br />
Allow from all</p>

<p>同时在httpd.conf中加入<br />
Listen 80<br />
Listen 8080</p>

<p>perror error_number 显示系统错误码的信息<br />
一个复制并修改编码的小脚本</p>

<p>[dongsong@localhost proj.android]$ cat copy_file.sh<br />
#!/bin/sh<br />
fromDir=/media/sf_cocos2d-x/cocos2d-2.0-x-2.0.3/bomb/Classes/<br />
toDir=/data/android/cocos2d-2.0-x-2.0.3/bomb/Classes/<br />
fromFiles=<code>ls $fromDir</code><br />
for fromFile in $fromFiles<br />
do<br />
#echo $fromFile<br />
encoding=<code>file $fromDir$fromFile | awk '{print $2}'</code><br />
#echo $encoding<br />
if [[ $encoding -eq &ldquo;UTF-8&rdquo; ]]<br />
then<br />
/bin/cp -rf $fromDir$fromFile $toDir$fromFile<br />
echo copied file $fromDir$fromFile<br />
else<br />
iconv -f GB2312 -t UTF-8 $fromDir&rdquo;$fromFile&rdquo; &gt; $toDir&rdquo;$fromFile&rdquo;<br />
echo iconved file $fromDir$fromFile<br />
fi<br />
done<br />
#/bin/cp -rf /media/sf_cocos2d-x/cocos2d-2.0-x-2.0.3/bomb/Classes/*
/data/android/cocos2d-2.0-x-2.0.3/bomb/Classes/<br />
/bin/cp -rf /media/sf_cocos2d-x/cocos2d-2.0-x-2.0.3/bomb/Resources/*
/data/android/cocos2d-2.0-x-2.0.3/bomb/Resources/</p>

<p>chown dongsong:dongsong /data/android/cocos2d-2.0-x-2.0.3/bomb/Classes/*<br />
chown dongsong:dongsong /data/android/cocos2d-2.0-x-2.0.3/bomb/Resources/*</p>

<p>xhost +si:localuser:apache 授予apache用户访问X的权限<br />
配置在 /etc/X11下的xinitrc.d/localuser.sh里面<br />
ssh超时问题 <a href="http://docs.oseems.com/general/application/ssh/disable-timeout">http://docs.oseems.com/general/application/ssh/disable-timeout</a><br />
/etc/ssh/ssh_config<br />
客户端ServerAliveInterval 100<br />
服务端<br />
ClientAliveInterval 30<br />
TCPKeepAlive yes<br />
ClientAliveCountMax 99999<br />
重启<br />
sudo /etc/init.d/sshd restart</p>

<p>设置sshd开机自启动:<br />
chkconfig sshd on<br />
或者<br />
ntsysv （图形界面，好多其他服务都可以在这里管理）</p>

<p>内网IP: 10.x.x.x 172.16.x.x至172.31.x.x 192.168.x.x</p>

<p>git提交修改的文件：（至于新建的项目，在项目首页有详细的上传说明）</p>

<p>[xiarendeniao@localhost aoi]$ git add TowerAoi.h test.cpp<br />
[xiarendeniao@localhost aoi]$ git commit -m &ldquo;fix bug; modify check
consistency&rdquo;<br />
[master 51f5864] fix bug; modify check consistency<br />
2 files changed, 15 insertions(+), 9 deletions(-)<br />
[xiarendeniao@localhost aoi]$ git push origin master<br />
Counting objects: 7, done.<br />
Compressing objects: 100% (<sup>4</sup>&frasl;<sub>4</sub>), done.<br />
Writing objects: 100% (<sup>4</sup>&frasl;<sub>4</sub>), 719 bytes, done.<br />
Total 4 (delta 2), reused 0 (delta 0)<br />
To ssh://git@github.com/xiarendeniao/pomelo-aoi.git<br />
c7fcad0..51f5864 master -&gt; master</p>

<p>git恢复删除的文件：git ls-files -d | xargs git checkout &ndash;</p>

<pre><code>[dongsong@localhost robot]$ git push origin master 
error: The requested URL returned error: 403 Forbidden while accessing https://github.com/xiarendeniao/robot.git/info/refs
fatal: HTTP request failed
[dongsong@localhost robot]$ cat .git/config 
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote &quot;origin&quot;]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = https://github.com/xiarendeniao/robot.git
[branch &quot;master&quot;]
        remote = origin
        merge = refs/heads/master
----修改 url = ...        
[dongsong@localhost robot]$ cat .git/config  
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote &quot;origin&quot;]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = https://xiarendeniao@github.com/xiarendeniao/robot.git
[branch &quot;master&quot;]
        remote = origin
        merge = refs/heads/master
[dongsong@localhost robot]$ git push origin master 
(gnome-ssh-askpass:3020): Gtk-WARNING **: cannot open display: 
[dongsong@localhost robot]$ unset SSH_ASKPASS
[dongsong@localhost robot]$ git push origin master 
Password: 
Counting objects: 19, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (18/18), done.
Writing objects: 100% (19/19), 8.47 KiB, done.
Total 19 (delta 0), reused 0 (delta 0)
To https://xiarendeniao@github.com/xiarendeniao/robot.git
 * [new branch]      master -&gt; master
</code></pre>

<p>[root@localhost server]# cat start.sh</p>

<p>#!/bin/sh<br />
waitserver() {<br />
while [[ 1 ]]<br />
do<br />
if [[ $1 != 0 ]]<br />
then<br />
echo &ldquo;.&rdquo;| nc 0.0.0.0 $1<br />
if [[ $? == 0 ]]<br />
then<br />
break;<br />
else<br />
echo &ldquo;server for port &ldquo;$1&rdquo; not listened&rdquo;<br />
sleep 1<br />
fi<br />
fi<br />
done<br />
}<br />
./dbserver &gt; dbserver.log 2&gt;&amp;1 &amp;<br />
waitserver 6666<br />
./baseserver &gt; baseserver.log 2&gt;&amp;1 &amp;<br />
waitserver 6530<br />
./loginserver &gt; loginserver.log 2&gt;&amp;1 &amp;<br />
waitserver 6430<br />
./connectserver &gt; connectserver.log 2&gt;&amp;1 &amp;<br />
waitserver 5630<br />
#./mapserver &gt; mapserver.log 2&gt;&amp;1 &amp;</p>

<p>valgrind -v &ndash;leak-check=full &ndash;log-file=mem-leak-check.log ./mapserver &gt;
mapserver.log 2&gt;&amp;1 &amp;</p>

<p>（2014.8.21）新学了一招：yum whatprovides &ldquo;*drm/drm.h&rdquo;</p>

<p>编译或者按照时提示找不到某头文件，可以用这种方式找到头文件的提供方</p>

<p>yum grouplist<br />
yum groupinstall “X Window System”<br />
yum groupinstall “Desktop”<br />
yum groupinstall “Fonts”</p>

<p>如何防止sudo rm -rf xx的悲剧？</p>

<p>[root@test-22 tmp]# cat ~/.bashrc</p>

<h1 id="bashrc">.bashrc</h1>

<p>nodel()<br />
{<br />
tmp=<code>date '+%s'</code><br />
if [ ! -d &ldquo;/trash/$tmp&rdquo; ]; then<br />
mkdir &ldquo;/trash/$tmp&rdquo;<br />
fi<br />
echo &ldquo;mv $@ /trash/$tmp&rdquo;<br />
mv $@ /trash/$tmp<br />
}<br />
alias rm=&lsquo;nodel&rsquo;<br />
[root@test-22 tmp]# which rm<br />
alias rm=&lsquo;nodel&rsquo;</p>

<p>生成core dump file：</p>

<p>ulimit -c unlimited</p>

<p>[dongsong@localhost skynet]$ ulimit -a<br />
core file size (blocks, -c) unlimited<br />
data seg size (kbytes, -d) unlimited<br />
scheduling priority (-e) 0<br />
file size (blocks, -f) unlimited<br />
pending signals (-i) 7805<br />
max locked memory (kbytes, -l) 64<br />
max memory size (kbytes, -m) unlimited<br />
open files (-n) 1024<br />
pipe size (512 bytes, -p) 8<br />
POSIX message queues (bytes, -q) 819200<br />
real-time priority (-r) 0<br />
stack size (kbytes, -s) 10240<br />
cpu time (seconds, -t) unlimited<br />
max user processes (-u) 1024<br />
virtual memory (kbytes, -v) unlimited<br />
file locks (-x) unlimited</p>

<p>要在字符串输出中夹杂变量，需要用双引号，而不是单引号</p>

<pre><code>[myciv@xh-4-1 sh]$ echo &quot;sdsdf${a}&quot;
sdsdf1111111
[myciv@xh-4-1 sh]$ echo &quot;sdsdf$a&quot;  
sdsdf1111111
[myciv@xh-4-1 sh]$ echo 'sdsdf$a'
sdsdf$a
</code></pre>

<p>删除文件名乱码的文件（手工无法输入文件名）</p>

<pre><code>[dongsong@localhost python_study]$ ls -inum 
358391 drwxrwxr-x   2 dongsong dongsong 4.0K 11月  2 02:13 ??˦
[dongsong@localhost python_study]$ find . -inum 358391 -exec mv {} /tmp/t/ \;
[dongsong@localhost python_study]$ find . -inum 358391 -exec rm -rf {} \;


[root@test-22 server]# cat /bin/grep.sh  
#!/bin/sh
aimstr=$1
dirstr=$2
#echo $aimstr
#echo $dirstr
#echo '++++'
if [[ -z $dirstr ]]; then dirstr='.'; fi
grep -rn &quot;$aimstr&quot; $dirstr | grep -v &quot;.svn&quot; | grep -v './tags' | grep -v &quot;.swp &quot;


#!/bin/sh
username=&quot;xudongsong&quot;
password=&quot;&quot;
read -p &quot;svn password for $username:&quot; password
svn export --username=$username --password=$password svn://svnip:svnport/svndir/myfile.csv ./myfile.csv
python conv.py 
</code></pre>

<p>监控日志错误并报警</p>

<pre><code>[dongsong@localhost server]$ cat sa.sh 
#!/bin/sh
mails[0]=&quot;youguess@163.com&quot;

ps axo &quot;pid,lstart,etime,stat,vsize,rss,euid,ruid,tty,tpgid,sess,pgrp,ppid,pcpu,comm,cmd&quot; | egrep &quot;xserver|yserver|zserver | grep -v 'egrep' | awk '{print $1}' | xargs kill -USR2

rfile='mailrecord'
if [ ! -f $rfile ]; then touch $rfile; fi

mfile='mailfile'
if [ ! -f $mfile ]; then touch $mfile; fi
echo -n &gt; $mfile

logfiles=`ls -r *log`
tosend=0
for logfile in $logfiles; do
        lastline=`grep -n &quot;$logfile&quot; $rfile | awk -F: '{print $3}'`
        if [ -z $lastline ]; then lastline=0; fi

        lines=`grep -n 'call stack' $logfile | awk -F: '{print $1}'`
        nextline=0
        haserr=0
        for line in $lines; do
                if (($line&gt;$lastline)); then
                        nextline=$line
                        lend=`expr $line + 10`
                        if (($haserr == 0)); then
                                haserr=1
                                echo &quot;------$logfile-------&quot; &gt;&gt; $mfile
                        fi
                        sed -n &quot;$line,${lend}p&quot; $logfile &gt;&gt; $mfile 
                        tosend=1
                fi
        done

        cat $rfile | grep -v $logfile &gt; &quot;${rfile}.new&quot;
        mv &quot;${rfile}.new&quot; $rfile
        echo &quot;${logfile}:${nextline}&quot; &gt;&gt; $rfile
done

if (($tosend == 1)); then
        for addr in ${mails[*]}; do
                mail -s &quot;wsjj server error&quot; $addr &lt; $mfile
        done
fi
rm $mfile
</code></pre>

<p>搜索并替换：</p>

<pre><code>[root@test-22 kl]# function f(){ sed 's/kl-server/kl/g' $1 &gt; /tmp/x; mv -f /tmp/x $1;}                                                              
[root@test-22 kl]# for f in `grep -rn kl-server . |awk -F: '{print $1}' | grep -e &quot;.lua$&quot; | sort -u `; do f $f; done                           
</code></pre>

<p>项目里面的编码好乱，已经告诉大家把编辑器的编码统一成utf8</p>

<pre><code>[root@test-22 mobserver]# cat conv.sh 
#!/bin/sh
for line in `find . -name *.lua| xargs file | awk -F: '{print $1,$2}' | awk '{print $1&quot;|&quot;$2}'`; do
    name=`echo $line| cut -f1 -d\|`
    code=`echo $line| cut -f2 -d\|`
    if [[ $code == &quot;ISO-8859&quot; ]]; then
        iconv -f GB2312 -t UTF-8 $name &gt; /tmp/utf8.tmp
        mv /tmp/utf8.tmp $name
        echo &quot;iconved file $name&quot;
    fi
done
</code></pre>

<p>2016.5.26</p>

<pre><code>[root@test-22 mobkk-client-lua]# cat /bin/gr
#!/bin/sh
aimstr=$1
dirstr=$2
if [[ -z $dirstr ]]; then dirstr='.'; fi
grep -rn --color &quot;$aimstr&quot; $dirstr | grep -v &quot;.svn&quot; | grep -v './tags' | grep -v &quot;.swp &quot; | grep -v &quot;./ctags&quot; | grep -v &quot;Binary file&quot;
[root@test-22 src]# cat /bin/vv
#!/bin/sh
aimindex=$1
aimstr=$2
dirstr=$3
if [[ -z $dirstr ]]; then dirstr='.'; fi
#把shell变量传入awk的方式之一: aimindex=&quot;$aimindex&quot;
if [[ $aimindex -lt 0 ]]; then #支持负数索引
    totalnum=`grep -rn --color &quot;$aimstr&quot; $dirstr | grep -v &quot;.svn&quot; | grep -v './tags' | grep -v &quot;.swp &quot; | grep -v &quot;./ctags&quot; | grep -v &quot;Binary file&quot; | wc -l`
    aimindex=$((totalnum+aimindex+1))
fi
rt=`grep -rn --color &quot;$aimstr&quot; $dirstr | grep -v &quot;.svn&quot; | grep -v './tags' | grep -v &quot;.swp &quot; | grep -v &quot;./ctags&quot; | grep -v &quot;Binary file&quot; | awk -F: '{if(NR==aimindex) print $1,$2}' aimindex=&quot;$aimindex&quot;`
fname=`echo &quot;$rt&quot;| awk '{print $1}'`
line=`echo &quot;$rt&quot;| awk '{print $2}'`
vim --cmd &quot;:colorscheme desert&quot; --cmd &quot;:set number&quot; --cmd &quot;set tabstop=4 shiftwidth=4 expandtab&quot; $fname +$line
[root@test-22 mobkk-client-lua]# gr checkEntity  
./model/object/player_move_entity.lua:105:function MoveEntity:checkEntity(tick, pixelX, pixelZ)
./model/socket/handler/objectHandler.lua:560:                           destPlr.moveEntity:checkEntity(tickCount, x, z)
./model/socket/handler/objectHandler.lua:573:                           if not obj.moveEntity:checkEntity(tickCount, x, z) then
./model/socket/handler/objectHandler.lua:691:           obj.moveEntity:checkEntity(tickCount, pixelX, pixelZ)
[root@test-22 mobkk-client-lua]# vv 2 checkEntity


[root@test-22 skynet-robot]# cat /root/xds/test1_protect.sh
#!/bin/sh
rts=`mysql -h10.4.4.21 -uroot -proot123 --default-character-set=utf8 -e &quot;SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST where db = 'mobkk_test1' and HOST not like '10.4.4.22%' and HOST != 'localhost'&quot;`
#echo $rts 

date
for rt in $rts; do
    if [[ $rt != 'ID' ]]; then
        mysql -h10.4.4.21 -uroot -pxxx --default-character-set=utf8 -e &quot;kill $rt&quot;
        echo &quot;kill $rt&quot;
    fi
done
</code></pre>

<dl>
<dt>:map  :!gr %</dt>
</dl>

<dl>
<dt>:!gr %</dt>
</dl>

<p>:map gr :!gr</p>

<p>expect 解决脚本执行中的交互问题</p>

<pre><code>#!/usr/tcl/bin/expect

set timeout 30
set host &quot;101.200.241.109&quot;
set username &quot;root&quot;
set password &quot;123456&quot;

spawn ssh $username@$host
expect &quot;*password*&quot; {send &quot;$password\r&quot;}
interact
</code></pre>
<div class="footnotes">

<hr />

<ol>
<li id="fn:t"> \t <a class="footnote-return" href="#fnref:t"><sup>[return]</sup></a></li>
<li id="fn:t"> \t <a class="footnote-return" href="#fnref:t"><sup>[return]</sup></a></li>
<li id="fn:t"> \t <a class="footnote-return" href="#fnref:t"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>