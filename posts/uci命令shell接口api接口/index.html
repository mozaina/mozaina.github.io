<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>uci命令shell接口API接口 | 开发者问答集锦</title>
    <meta property="og:title" content="uci命令shell接口API接口 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="uci命令shell接口API接口">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/uci%E5%91%BD%E4%BB%A4shell%E6%8E%A5%E5%8F%A3api%E6%8E%A5%E5%8F%A3/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">uci命令shell接口API接口</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>#</p>

<p>#</p>

<h1 id="uci-命令">uci 命令:</h1>

<p>uci help:</p>

<p>Usage: uci [] []</p>

<p>Commands:</p>

<p>batch</p>

<p>export [] 导出配置文件</p>

<p>import [] 以uci语法导入配置文件</p>

<p>changes [] 列出配置文件分阶段修改的内容（没有commit），若未指定配置文件，则导出所有配置文件的修改</p>

<p>commit [] 对给定的配置文件写入修改，如果没有指定参数则将所有的配置文件写入文件系统</p>

<p>add  增加指定配置文件的类型为section-type的匿名区段</p>

<p>add_list ..= 对已存在的list选项增加字符串</p>

<p>del_list ..= 删除已存在的list选项的字符串</p>

<p>show [[.[.]]] 显示指定的选项、配置节或配置文件</p>

<p>get .[.] 获取指定区段选项的值</p>

<p>set .[.]= 设置指定配置节选项的值，或者是增加一个配置节，类型设置为指定的值</p>

<p>delete [.[[.][=]]] 删除指定配置节或选项</p>

<p>rename .[.]= 对指定的选项或配置节重命名</p>

<p>revert [.[.]] 恢复指定的选项，配置节或配置文件</p>

<p>reorder .=</p>

<p>Options:</p>

<p>-c  设置配置文件的搜索路径 (default: /etc/config)</p>

<p>-d  在uci显示中设置列表值的分隔符 in uci show</p>

<p>-f  使用作为输入，而不是stdin</p>

<p>-m 导入时，将数据合并到现有包中</p>

<p>-n 名称未命名部分导出（默认）</p>

<p>-N 不要命名unname dsections</p>

<p>-p  添加配置更改文件的搜索路径</p>

<p>-P  添加配置更改文件的搜索路径，并使用默认值</p>

<p>-q 安静模式（不打印错误信息）</p>

<p>-s 强制严格模式（停止解析器错误，默认）</p>

<p>-S 停止严格模式</p>

<p>-X 不要在&rsquo;show&rsquo;上使用扩展语法</p>

<h1 id="uci-shell-接口">uci shell 接口：</h1>

<p><strong><em>注：以&rdquo;uci</em>&ldquo;开头的函数和以“config_”开头的函数大多数功能完全相同，唯一不同的是uci_get等函数直接从文件中获取，“config<em>get”函数从环境变量中读取</em></strong></p>

<h2 id="lib-config-uci-sh">/lib/config/uci.sh</h2>

<p>#参考对应的命令实现</p>

<p>uci_load #从uci文件中加载配置并设置到环境变量中</p>

<p>uci_set_default</p>

<p>uci_revert_state</p>

<p>uci_set_state()</p>

<p>uci_toggle_state</p>

<p>uci_set</p>

<p>uci_get_state #指定从/var/state中获取状态值</p>

<p>uci_get #从uci文件中获取值</p>

<p>uci_add</p>

<p>uci_rename</p>

<p>uci_remove</p>

<p>uci_commit</p>

<h2 id="lib-functions-sh">/lib/functions.sh</h2>

<p><strong>_注意：在使用“config_”开头的函数时要先使用config<em>load,将配置文件载入环境变量</em></strong></p>

<pre><code>#在字符串前加‘:’并返回“:123”
w=debug  123
echo $w
输出：&quot;:123&quot;





config 
#将配置节设置到环境变量中，供uci.sh调用
option 
#将配置节中的选项设置到环境变量中，供uci.sh调用
list
#将配置节中的链表设置到环境变量中，供uci.sh调用
</code></pre>

<p>#config_unset</p>

<pre><code>#调用config_set 清空.的value值
#config_unset  





#config_load:  调用uci_load函数从配置文件中读取配置然后设置到环境变量中
config_load 





#config_get:从当前环境变量中获取配置值
# variable:用来存储config值的变量
#section/option:要获取节点/选项的名字
config_get      []





#config_get_bool:从当前环境变量中获取配置值 ,并把值转换成整数
config_get_bool    []





#config_set:将变量设置到环境变量中以便后续读取（注：并未设置到配置文件中）
#section/option
#value:要为该节点设置的值
config_set    





#config_foreach：遍历每个section去调用callback_func函数（callback_func 的入参为section name）


#[]:只遍历这个类型的section......
config_foreach   []





#config_list_foreach:遍历section下list的option值，并调用callback_func函数（入参为list option的值，有多少值调用多少次）
config_list_foreach   





#加载/etc/modus.d/*下面的所有模块
insert_modules





#应用shell脚本
include  [......]
</code></pre>

<p>append</p>

<p>list_contains</p>

<p>reset_cb</p>

<p>package</p>

<p>default_prerm</p>

<p>default_postinst</p>

<p>find_mtd_index</p>

<p>find_mtd_part</p>

<p>group_add</p>

<p>group_exists</p>

<p>group_add_next</p>

<p>group_add_user</p>

<p>user_add</p>

<p>user_exists</p>

<h1 id="uci重要的结构体">uci重要的结构体：</h1>

<p>struct uci_context<br />
{<br />
/* list of config packages */<br />
struct uci_list root;</p>

<p>/* parser context, use for error handling only */<br />
struct uci_parse_context *pctx;</p>

<p>/* backend for import and export */<br />
struct uci_backend *backend;<br />
struct uci_list backends;</p>

<p>/* uci runtime flags */<br />
enum uci_flags flags;</p>

<p>char *confdir;<br />
char *savedir;</p>

<p>/* search path for delta files */<br />
struct uci_list delta_path;</p>

<p>/* private: */<br />
int err;<br />
const char *func;<br />
jmp_buf trap;<br />
bool internal, nested;<br />
char *buf;<br />
int bufsz;<br />
};</p>

<p>_uci<em>context：uci上下文结构，贯彻查询、更改配置文件全过程</em></p>

<p>struct uci_package<br />
{<br />
struct uci_element e;<br />
struct uci_list sections;<br />
struct uci_context *ctx;<br />
bool has_delta;<br />
char *path;</p>

<p>/* private: */<br />
struct uci_backend *backend;<br />
void *priv;<br />
int n_section;<br />
struct uci_list delta;<br />
struct uci_list saved_delta;<br />
};<br />
 _uci<em>package:对应一个配置文件</em></p>

<p>struct uci_section<br />
{<br />
struct uci_element e;<br />
struct uci_list options;<br />
struct uci_package *package;<br />
bool anonymous;<br />
char *type;<br />
};<br />
 _uci<em>section:对应配置文件中的节</em></p>

<p>struct uci_option<br />
{<br />
struct uci_element e;<br />
struct uci_section *section;<br />
enum uci_option_type type;<br />
union {<br />
struct uci_list list;<br />
char *string;<br />
} v;<br />
};</p>

<p>_uci<em>option:对应配置文件节中的option和list</em></p>

<p>struct uci_ptr<br />
{<br />
enum uci_type target;<br />
enum {<br />
UCI_LOOKUP_DONE = (1 &lt;&lt; 0),<br />
UCI_LOOKUP_COMPLETE = (1 &lt;&lt; 1),<br />
UCI_LOOKUP_EXTENDED = (1 &lt;&lt; 2),<br />
} flags;</p>

<p>struct uci_package *p;<br />
struct uci_section *s;<br />
struct uci_option *o;<br />
struct uci_element *last;</p>

<p>const char *package;<br />
const char *section;<br />
const char *option;<br />
const char *value;<br />
};</p>

<p>_uci<em>ptr:元素位置指针结构，用以查询并保存对应的位置元素</em></p>

<h1 id="uci-api">uci API:</h1>

<p><em><strong>/usr/local/include/uci.h</strong></em></p>

<p>/**</p>

<p>*uci_alloc_context: Allocate a new uci context</p>

<p>*动态申请一块内存用于struct uci_context结构。</p>

<p>*/</p>

<pre><code>extern struct uci_context * uci_alloc_context(void);
</code></pre>

<p>/**</p>

<p>*uci_alloc_alternate_context: Allocate new uci context with specific default</p>

<p>*/</p>

<p>extern struct uci_context*uci_alloc_alternate_context(const char *confdir,
const char *savedir);</p>

<p>/**</p>

<p>*uci_free_context: Free the uci context including all of its data</p>

<p>*释放struct uci_context结构内存，以及为其成员申请的所有内存</p>

<p>*/</p>

<pre><code>extern void uci_free_context(structuci_context *ctx);
</code></pre>

<p>/**</p>

<p>*uci_perror: Print the last uci error that occured</p>

<p>*@ctx: uci context</p>

<p>*@str: string to print before the error message</p>

<p>*打印最后一条出错信息，如果在打印出错信息前想打印其他信息，则传入str即可</p>

<p>*/</p>

<pre><code>extern void uci_perror(struct uci_context*ctx, const char *str);
</code></pre>

<p>/**</p>

<p>*uci_geterror: Get an error string for the last uci error</p>

<p>*获取最后一个uci错误的错误字符串</p>

<p>*@ctx: uci context</p>

<p>*@dest: target pointer for the string</p>

<p>*@str: prefix for the error message</p>

<p>*</p>

<p>*Note: string must be freed by the caller</p>

<p>*/</p>

<pre><code>extern void uci_get_errorstr(structuci_context *ctx, char **dest, const char *str);
</code></pre>

<p>/**</p>

<p>*uci_import: Import uci config data from a stream</p>

<p>*从文件流中导入uci的配置数据</p>

<p>*@ctx: uci context</p>

<p>*@stream: file stream to import from</p>

<p>*@name: (optional) assume the config has the given name</p>

<p>*@package: (optional) store the last parsed config package in this variable</p>

<p>*@single: ignore the &lsquo;package&rsquo; keyword and parse everything into a singlepackage</p>

<p>*</p>

<p>*the name parameter is for config files that don&rsquo;t explicitly use the &lsquo;package&lt;&hellip;&gt;&rsquo; keyword</p>

<ul>
<li>if&rsquo;package&rsquo; points to a non-null struct pointer, enable delta tracking and merge</li>
</ul>

<p>*/</p>

<pre><code>extern int uci_import(struct uci_context * ctx, FILE * stream, const char  *name, struct uci_package  **package, boolsingle);
</code></pre>

<p>/**</p>

<p>*uci_export: Export one or all uci config packages</p>

<p>*导出uci的配置文件数据到文件流stream</p>

<p>*@ctx: uci context</p>

<p>*@stream: output stream</p>

<p>*@package: (optional) uci config package to export</p>

<p>*@header: include the package header</p>

<p>*/</p>

<pre><code>extern int uci_export(struct uci_context*ctx, FILE *stream, struct uci_package *package, bool header);
</code></pre>

<p>/**</p>

<p>*uci_load: Parse an uci config file and store it in the uci context</p>

<p>*解析一个uci配置文件并把它存到ctx中</p>

<p>*@ctx: uci context</p>

<p>*@name: name of the config file (relative to the config directory)</p>

<p>*@package: store the loaded config package in this variable</p>

<p>*/</p>

<pre><code>extern int uci_load(struct uci_context*ctx, const char *name, struct uci_package **package);
</code></pre>

<p>/**</p>

<p>*uci_unload: Unload a config file from the uci context</p>

<p>*从ctx中卸载一个配置文件包</p>

<p>*@ctx: uci context</p>

<p>*@package: pointer to the uci_package struct</p>

<p>*/</p>

<pre><code>extern int uci_unload(struct uci_context*ctx, struct uci_package *p);
</code></pre>

<p>/**</p>

<p>*uci_lookup_ptr: Split an uci tuple string and look up an element tree</p>

<p>*分离一个uci类型的字符串元组，且查找对应的元素树</p>

<p>*@ctx: uci context</p>

<p>*@ptr: lookup result struct</p>

<p>*@str: uci tuple string to look up</p>

<p>*@extended: allow extended syntax lookup</p>

<p>*</p>

<ul>
<li>ifextended is set to true, uci_lookup_ptr supports the following</li>
</ul>

<p>*extended syntax:</p>

<p>*</p>

<p>*Examples:</p>

<ul>
<li><p>network.@interface[0].ifname (&lsquo;ifname&rsquo; option of the first interfacesection)</p></li>

<li><p>network.@interface<a href="lastinterface section">-1</a></p></li>
</ul>

<p>*Note: uci_lookup_ptr will automatically load a config package if necessary</p>

<p>*@str must not be constant, as it will be modified and used for the stringsinside @ptr,</p>

<p>*thus it must also be available as long as @ptr is in use.</p>

<p>*</p>

<p>*This function returns UCI_ERR_NOTFOUND if the package specified in the tuple</p>

<p>*string cannot be found. Otherwise itwill return UCI_OK.</p>

<p>*</p>

<p>*Note that failures in looking up other parts, if they are also specfied,</p>

<p>*including section and option, will also have a return value UCI_OK but with</p>

<p>*ptr-&gt;flags * UCI_LOOKUP_COMPLETE not set.</p>

<p>*/</p>

<pre><code>extern int uci_lookup_ptr(structuci_context *ctx, struct uci_ptr *ptr, char *str, bool extended);
</code></pre>

<p>/**</p>

<p>*uci_add_section: Add an unnamed section</p>

<p>*添加一个匿名节点</p>

<p>*@ctx: uci context</p>

<p>*@p: package to add the section to</p>

<p>*@type: section type</p>

<p>*@res: pointer to store a reference to the new section in</p>

<p>*/</p>

<pre><code>extern int uci_add_section(structuci_context *ctx, struct uci_package *p, const char *type, struct uci_section**res);
</code></pre>

<p>/**</p>

<p>*uci_set: Set an element&rsquo;s value; create the element if necessary</p>

<p>*设置一个元素值，必要的话新建这个元素</p>

<p>*@ctx: uci context</p>

<p>*@ptr: uci pointer</p>

<p>*</p>

<p>*The updated/created element is stored in ptr-&gt;last</p>

<p>*/</p>

<pre><code>extern int uci_set(struct uci_context *ctx,struct uci_ptr *ptr);
</code></pre>

<p>/**</p>

<p>*uci_add_list: Append a string to an element list</p>

<p>*附加一个字符串到一个元素列表</p>

<p>*@ctx: uci context</p>

<p>*@ptr: uci pointer (with value)</p>

<p>*</p>

<p>*Note: if the given option already contains a string value,</p>

<ul>
<li>itwill be converted to an 1-element-list before appending the next element</li>
</ul>

<p>*/</p>

<pre><code>extern int uci_add_list(struct uci_context*ctx, struct uci_ptr *ptr);
</code></pre>

<p>/**</p>

<p>*uci_del_list: Remove a string from an element list</p>

<p>*从一个元素列表中删除一个元素</p>

<p>*@ctx: uci context</p>

<p>*@ptr: uci pointer (with value)</p>

<p>*</p>

<p>*/</p>

<pre><code>extern int uci_del_list(struct uci_context*ctx, struct uci_ptr *ptr);
</code></pre>

<p>/**</p>

<p>*uci_reorder: Reposition a section</p>

<p>*改变一个节的（顺序）位置</p>

<p>*@ctx: uci context</p>

<p>*@s: uci section to reposition</p>

<p>*@pos: new position in the section list</p>

<p>*/</p>

<pre><code>extern int uci_reorder_section(structuci_context *ctx, struct uci_section *s, int pos);
</code></pre>

<p>/**</p>

<p>*uci_rename: Rename an element</p>

<p>*重命名一个元素</p>

<p>*@ctx: uci context</p>

<p>*@ptr: uci pointer (with value)</p>

<p>*/</p>

<pre><code>extern int uci_rename(struct uci_context*ctx, struct uci_ptr *ptr);
</code></pre>

<p>/**</p>

<p>*uci_delete: Delete a section or option</p>

<p>*删除一个节或选项</p>

<p>*@ctx: uci context</p>

<p>*@ptr: uci pointer</p>

<p>*/</p>

<pre><code>extern int uci_delete(struct uci_context*ctx, struct uci_ptr *ptr);
</code></pre>

<p>/**</p>

<p>*uci_save: save change delta for a package</p>

<p>*为一个package保存改变的delta</p>

<p>*@ctx: uci context</p>

<p>*@p: uci_package struct</p>

<p>*/</p>

<pre><code>extern int uci_save(struct uci_context*ctx, struct uci_package *p);
</code></pre>

<p>/**</p>

<p>*uci_commit: commit changes to a package</p>

<p>*提交改动到一个package</p>

<p>*@ctx: uci context</p>

<p>*@p: uci_package struct pointer</p>

<p>*@overwrite: overwrite existing config data and flush delta</p>

<p>*</p>

<p>*committing may reload the whole uci_package data,</p>

<p>*the supplied pointer is updated accordingly</p>

<p>*/</p>

<pre><code>extern int uci_commit(struct uci_context*ctx, struct uci_package **p, bool overwrite);
</code></pre>

<p>/**</p>

<p>*uci_list_configs: List available uci config files</p>

<p>*列出可用的uci配置文件</p>

<p>*@ctx: uci context</p>

<p>*</p>

<p>*caller is responsible for freeing the allocated memory behind list</p>

<p>*/</p>

<pre><code>extern int uci_list_configs(structuci_context *ctx, char ***list);
</code></pre>

<p>/**</p>

<p>*uci_set_savedir: override the default delta save directory</p>

<p>*覆盖默认的delta保存的目录</p>

<p>*@ctx: uci context</p>

<p>*@dir: directory name</p>

<p>*</p>

<p>*This will also try adding the specified dir to the end of delta pathes.</p>

<p>*/</p>

<pre><code>extern int uci_set_savedir(structuci_context *ctx, const char *dir);
</code></pre>

<p>/**</p>

<p>*uci_set_confdir: override the default config storage directory</p>

<p>*覆盖默认的配置文件存储目录</p>

<p>*@ctx: uci context</p>

<p>*@dir: directory name</p>

<p>*/</p>

<pre><code>extern int uci_set_confdir(structuci_context *ctx, const char *dir);
</code></pre>

<p>/**</p>

<p>*uci_add_delta_path: add a directory to the search path for change delta files</p>

<p>*为detal文件添加一个目录到搜索路径</p>

<p>*@ctx: uci context</p>

<p>*@dir: directory name</p>

<p>*</p>

<p>*This function allows you to add directories, which contain &lsquo;overlays&rsquo;</p>

<p>*for the active config, that will never be committed.</p>

<p>*</p>

<p>*Adding a duplicate directory will cause UCI_ERR_DUPLICATE be returned.</p>

<p>*/</p>

<pre><code>extern int uci_add_delta_path(structuci_context *ctx, const char *dir);
</code></pre>

<p>/**</p>

<p>*uci_revert: revert all changes to a config item</p>

<p>*恢复一个配置项的所有变更</p>

<p>*@ctx: uci context</p>

<p>*@ptr: uci pointer</p>

<p>*/</p>

<pre><code>extern int uci_revert(struct uci_context*ctx, struct uci_ptr *ptr);
</code></pre>

<p>/**</p>

<p>*uci_parse_argument: parse a shell-style argument, with an arbitrary quotingstyle</p>

<p>*解析一个shell风格的参数</p>

<p>*@ctx: uci context</p>

<p>*@stream: input stream</p>

<p>*@str: pointer to the current line (use NULL for parsing the next line)</p>

<p>*@result: pointer for the result</p>

<p>*/</p>

<pre><code>extern int uci_parse_argument(structuci_context *ctx, FILE *stream, char **str, char **result);
</code></pre>

<p>/**</p>

<p>*uci_set_backend: change the default backend</p>

<p>*@ctx: uci context</p>

<p>*@name: name of the backend</p>

<p>*</p>

<p>*The default backend is &ldquo;file&rdquo;, which uses /etc/config for configstorage</p>

<p>*/</p>

<pre><code>extern int uci_set_backend(structuci_context *ctx, const char *name);
</code></pre>

<p>/**</p>

<p>*uci_validate_text: validate a value string for uci options</p>

<p>*验证uci options中的一个字符串值</p>

<p>*@str: value</p>

<p>*</p>

<p>*this function checks whether a given string is acceptable as value</p>

<p>*for uci options</p>

<p>*/</p>

<pre><code>extern bool uci_validate_text(const char*str);
</code></pre>

<p>/**</p>

<p>*uci_parse_ptr: parse a uci string into a uci_ptr</p>

<p>*解析一个uci字符串到uci_prt结构中</p>

<p>*@ctx: uci context</p>

<p>*@ptr: target data structure</p>

<p>*@str: string to parse</p>

<p>*</p>

<p>*str is modified by this function</p>

<p>*/</p>

<pre><code>int uci_parse_ptr(struct uci_context *ctx,struct uci_ptr *ptr, char *str);
</code></pre>

<p>/**</p>

<ul>
<li>uci_lookup_next:lookup a child element</li>
</ul>

<p>*查找子元素</p>

<p>*@ctx: uci context</p>

<p>*@e: target element pointer</p>

<p>*@list: list of elements</p>

<p>*@name: name of the child element</p>

<p>*</p>

<ul>
<li>ifparent is NULL, the function looks up the package with the given name</li>
</ul>

<p>*/</p>

<pre><code>int uci_lookup_next(struct uci_context*ctx, struct uci_element **e, struct uci_list *list, const char *name);
</code></pre>

<p>/**</p>

<p>*uci_parse_section: look up a set of options</p>

<p>*查找一组选项</p>

<p>*@s: uci section</p>

<p>*@opts: list of options to look up</p>

<p>*@n_opts: number of options to look up</p>

<p>*@tb: array of pointers to found options</p>

<p>*/</p>

<pre><code>void uci_parse_section(struct uci_section*s, const struct uci_parse_option *opts,
                                   int n_opts, struct uci_option **tb);
</code></pre>

<p>/**</p>

<p>*uci_hash_options: build a hash over a list of options</p>

<p>*在选项列表上构建一个散列</p>

<p>*@tb: list of option pointers</p>

<p>*@n_opts: number of options</p>

<p>*/</p>

<pre><code>uint32_t uci_hash_options(struct uci_option**tb, int n_opts);
</code></pre>

<p>/**</p>

<p>*uci_alloc_element: allocate a generic uci_element, reserve a buffer andtypecast</p>

<p>*分配一个通用的uci_element，保留缓冲区和属性</p>

<p>*@ctx: uci context</p>

<p>*@type: {package,section,option}</p>

<p>*@name: string containing the name of the element</p>

<p>*@datasize: additional buffer size to reserve at the end of the struct</p>

<p>*/</p>

<pre><code>#define uci_alloc_element(ctx, type, name,datasize) \
              uci_to_## type (uci_alloc_generic(ctx, uci_type_ ## type, name, sizeof(struct uci_ ##type) + datasize))

#define uci_dataptr(ptr) \
              (((char*) ptr) + sizeof(*ptr))
</code></pre>

<p>/**</p>

<p>*uci_lookup_package: look up a package</p>

<p>*查找package</p>

<p>*@ctx: uci context</p>

<p>*@name: name of the package</p>

<p>*/</p>

<pre><code>static inline struct uci_package *
uci_lookup_package (struct uci_context *ctx,const char *name)
{
              structuci_element *e = NULL;
              if(uci_lookup_next(ctx, &amp;e, &amp;ctx-&gt;root, name) == 0)
                            return uci_to_package(e);
              else
                            return NULL;
}
</code></pre>

<p>/**</p>

<p>*uci_lookup_section: look up a section</p>

<p>*查找section</p>

<p>*@ctx: uci context</p>

<p>*@p: package that the section belongs to</p>

<p>*@name: name of the section</p>

<p>*/</p>

<pre><code>static inline struct uci_section *
uci_lookup_section(struct uci_context *ctx,struct uci_package *p, const char *name)
{
              structuci_element *e = NULL;
              if(uci_lookup_next(ctx, &amp;e, &amp;p-&gt;sections, name) == 0)
                            returnuci_to_section(e);
              else
                            returnNULL;
}
</code></pre>

<p>/**</p>

<p>*uci_lookup_option: look up an option</p>

<p>*查找option</p>

<p>*@ctx: uci context</p>

<p>*@section: section that the option belongs to</p>

<p>*@name: name of the option</p>

<p>*/</p>

<pre><code>static inline struct uci_option *
uci_lookup_option(struct uci_context *ctx,struct uci_section *s, const char *name)
{
              structuci_element *e = NULL;
              if(uci_lookup_next(ctx, &amp;e, &amp;s-&gt;options, name) == 0)
                            returnuci_to_option(e);
              else
                            returnNULL;
}

static inline const char *
uci_lookup_option_string(struct uci_context*ctx, struct uci_section *s, const char *name)
{
              structuci_option *o;

              o= uci_lookup_option(ctx, s, name);
              if(!o || o-&gt;type != UCI_TYPE_STRING)
                            returnNULL;

              returno-&gt;v.string;
}
</code></pre>

<p>#</p>

<h1 id="end">end</h1>

<p>#</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>