<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Ruby快速入门30分钟 | 开发者问答集锦</title>
    <meta property="og:title" content="Ruby快速入门30分钟 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Ruby快速入门30分钟">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/ruby%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A830%E5%88%86%E9%92%9F/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Ruby快速入门30分钟</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>在本教程中，将探讨使用Ruby开始编程所需的基本语法，以及如何在30分钟内学习并使用Ruby编程语言。</p>

<blockquote>
<p>注：如果您还尚未安装Ruby开发环境，请访问环境设置页面并按照说明安装： <a href="http://www.yiibai.com/ruby/ruby-">http://www.yiibai.com/ruby/ruby-</a>
installation.html</p>
</blockquote>

<h2 id="ruby历史">Ruby历史</h2>

<p>Ruby被许多人认为是一种“新”编程语言，但实际上是由一个叫作 <strong>Matz</strong> 的开发人员于1994年发布的。
Matz自我描述是一个“语言极客”，也是Perl大粉丝。 他对Ruby的想法是创建一种像Perl这样灵活而强大的语言，但在其语法上更具表现力 -
甚至可以具有类似于英语那样的可读性。</p>

<p>Ruby在日本迅速成长，直到2000年，真的没有关于除了日本语言以外的任何文档。所以如果想要学习Ruby，那得必须先学习日语。 敏捷编程的先驱 <strong>Dave
Thomas</strong> 被Ruby迷住，并决定创建Ruby的其它语言文档。</p>

<p>自Ruby有了英文开始，Ruby就开始在英语世界中增长，尽管缓慢。 系统管理员变得流行，编写维护和“粘贴”脚本 -
类似Perl的用法。从2000年到2005年美国的Ruby社区已达数百个。</p>

<p>在2004-2005年，一家名为<code>37Signals</code>的芝加哥公司聘请了一名年轻的开发人员来构建一个Web应用程序。 公司给了他几乎完全的执行自由;
他们只关心客户端的设计和功能。 当时主要的Web技术是Perl CGI，PHP，Java的JSP和Microsoft的ASP。
但是他们都是有点痛苦，但DHH的<strong>大卫(DHH)</strong>选择了自己的方向。他在Ruby中写了这个应用程序。
他依靠核心库和少数库的帮助下，同时自己创建了整个堆栈(或多或少)。37Signals在Web应用程序使用Ruby来编写，这个项目今天被称为<code>Basecamp</code>。</p>

<p>当建立了Basecamp，DHH就会从中提取出Web框架。
这是一个非常不同的方法，从<code>Java/Sun</code>或<code>.NET/Microsoft</code>，Web框架都是从高处往下传播。 相反，Rails从现实世界中抽出来。
它侧重于常规配置，使常见问题更容易解决。</p>

<p>这种方法是一个很大的打击，Rails自从以来一直推动了Ruby/Rails社区的发展。
现在，在亚马逊上有数十本书，全球近一百个会议，有成千上万的人是Ruby/Rails开发人员。</p>

<p>如果你想学习Rails，需要先学习Ruby！ 现在就开始咯 …</p>

<h2 id="1-ruby解释器">1. Ruby解释器</h2>

<p>Ruby是一种“解释”的编程语言，它不能直接在处理器上运行，它的代码必须馈送到称为“虚拟机”或虚拟机的中间件。
虚拟机的一方面是Ruby代码，另一方面则是操作系统和处理器。 这种方法的好处是您可以编写一次Ruby代码，就可以在许多不同的操作系统和硬件平台上执行了。</p>

<p>Ruby程序无法运行自己的程序，它需要加载虚拟机。 使用VM执行Ruby的方式有两种：通过<code>IRB</code>和命令行。</p>

<h3 id="从命令行运行ruby代码">从命令行运行Ruby代码</h3>

<p>这是编写Ruby代码的耐用方法，因为要将指令保存到文件中。 该文件可以备份，传输，添加到源代码管理等。</p>

<p><strong>一个Ruby代码文件示例</strong></p>

<p>这里创建一个名称为:<code>first-ruby.rb</code>的文件，如下所示：</p>

<pre><code>#!/usr/bin/ruby   
# filename : first-ruby.rb

class Sample
  def hello
    puts &quot;Hello, World!&quot;
  end
end

s = Sample.new
s.hello
</code></pre>

<p>那么可以这样运行程序：</p>

<p><img src="https://img.it610.com/image/info8/52d8548dbb8e4d7c8b0c1b5213ca4625.png" alt="" /></p>

<p>当您运行<code>ruby first-ruby.rb</code>时，实际上正在加载ruby虚拟机，然后再加载<code>first-ruby.rb</code>文件中的代码。</p>

<h2 id="从irb运行ruby代码">从IRB运行Ruby代码</h2>

<p>Ruby是第一批语言推广所谓“<code>REPL</code>”：阅读，评估，打印，循环的编程语言。想像它就像一个计算器 -
就像在每个完整的指令中，IRB执行这些指令并显示结果。</p>

<p>IRB最好用作实验的便笺簿。 许多开发人员在编写他们的“真实”程序时，一般都保持IRB窗口打开，使用它来记住某个方法如何工作或用于调试某个代码块。</p>

<p>要打开IRB进行实验，可通过打开终端(Mac)或命令提示符(Win)并打开或输入<code>irb</code>来启动IRB。以Windows系统为例，如下所示 -</p>

<p><img src="https://img.it610.com/image/info8/a5e93b45dc3d4d689c3f2b150011a25d.png" alt="" /></p>

<blockquote>
<p>注： 按 Ctrl + D 可退出 <code>irb</code> 模式。</p>
</blockquote>

<h2 id="2-ruby变量">2. Ruby变量</h2>

<p>编程都是要创建抽象的代码来描述和处理数据，要创建抽象，必须要为在代码中分配名称来表示事物。 变量只不过是为数据创建一个名称的一种方式。</p>

<h3 id="创建和分配变量">创建和分配变量</h3>

<p>在某些语言中，需要在为一个变量分配值之前声明这个变量。 当为变量分配值时，会自动创建Ruby变量。下面来试试一个例子：</p>

<p><img src="https://img.it610.com/image/info8/1b42f006a58942639f6c0e8ef93410a8.png" alt="" /></p>

<p><code>a = 250</code>表示创建一个名称为<code>a</code>的变量，并将值<code>250</code>存储到其中。</p>

<p><strong>右边优先</strong></p>

<p>在英文表达式中，是从左到右阅读，所以从左到右读取代码是很自然的。 但是当使用单个等于号(<code>=</code>)评估求值一个赋值时，Ruby实际上首先评估求值右侧。
举个例子：</p>

<pre><code>irb(main):010:0&gt; b = 10 + 20
=&gt; 30
irb(main):011:0&gt; b
=&gt; 30
irb(main):012:0&gt;
</code></pre>

<p>上面示例中，首先对<code>10 + 20</code>进行评估求值，再将求值结果存储到<code>b</code>变量中。</p>

<p><strong>灵活输入</strong></p>

<p>Ruby的变量可以容纳任何类型的数据，甚至可以更改其持有的数据类型。 例如：</p>

<pre><code>irb(main):012:0&gt; c = 200
=&gt; 200
irb(main):013:0&gt; c = &quot;Flexible Typing&quot;
=&gt; &quot;Flexible Typing&quot;
irb(main):014:0&gt; c
=&gt; &quot;Flexible Typing&quot;
irb(main):015:0&gt; c = 0.0001
=&gt; 0.0001
irb(main):016:0&gt; c
=&gt; 0.0001
irb(main):017:0&gt;
</code></pre>

<p>第一次赋予<code>c</code>变量为一个<code>200</code>的整数值。第二次赋值是将<code>c</code>变量的值更改其为“<code>Flexible Typing</code>”。</p>

<p><strong>命名变量</strong></p>

<p>大多数Ruby变量(局部变量)的命名都有一些由<code>VM</code>强制的要求。这些要求约定如下 -</p>

<ul>
<li>始终以小写字母开头(允许下划线，虽然不常见)</li>
<li>不能使用空格</li>
<li>不要包含特殊字符，如<code>$</code>，<code>@</code>和<code>＆</code></li>
</ul>

<p>除了那些虚拟机的要求，Ruby开发者对变量名称有几个常见风格偏好：</p>

<ul>
<li>使用蛇形大小写，即：名称中的每个字都是小写字母，并用下划线(<code>_</code>)连接</li>
<li>以其内容的含义命名，而不是其内容的类型</li>
<li>不使用缩写</li>
</ul>

<p>好的变量名的示例如下：<code>count</code>，<code>total_products</code>，<code>students_in_class</code>或<code>first_lesson</code>。</p>

<p>一些不好的Ruby变量名称的几个例子，如下所示：</p>

<ul>
<li><code>studentsInClass</code> – 使用骆驼案而不是蛇形大小写，应该命名为：<code>students_in_class</code></li>
<li><code>1st_lesson</code> – 变量不能以数字开头，应该命名为：<code>first_lesson</code></li>
<li><code>students_array</code> – 包括名称的数据类型，应该命名为：<code>students</code></li>
<li><code>sts</code> – 不使用缩写，应该命名为：<code>students</code></li>
</ul>

<h3 id="练习">练习</h3>

<p>使用 <em>IRB</em> 存储每个以下变量名称的值。 哪些名字是好的，哪些是是无效的Ruby变量名称，哪些是有效的，哪些是Ruby不建议使用的风格？</p>

<ul>
<li><code>time_machine</code></li>
<li><code>student_count_integer</code></li>
<li><code>homeworkAssignment</code></li>
<li><code>3_sections</code></li>
<li><code>top_ppl</code></li>
</ul>

<h2 id="3-字符串">3. 字符串</h2>

<p>在现实世界中，字符串是将一个个字符串联起来的。 编程中的字符串与真实字符串无关。</p>

<p>编程中的字符串用于存储字母和数字的集合。它可以是一个单一的字母，如“<code>a</code>”，或者像“<code>hi</code>”这样一个单词，或者“<code>Hello my
friends.</code>”这样的一段话。</p>

<h3 id="编写一个字符串">编写一个字符串</h3>

<p>Ruby字符串被定义为一个引号(<code>&quot;</code>)，后跟零个或多个字母，数字或符号，后跟一个闭包引号(<code>&quot;</code>)。 最短的字符串称为空字符串：<code>&quot;&quot;</code>。
单个字符串包含文本的段落甚至页面也很常见。</p>

<h3 id="子字符串">子字符串</h3>

<p>通常使用字符串，可从整个长字符串提取出来的一部分 - 这提取出来的部分称为 <strong>子字符串</strong> 。在 <code>irb</code> 尝试这些例子：</p>

<pre><code>irb(main):017:0&gt; string = &quot;Ruby in 30 Minutes at yiibai.com&quot;
=&gt; &quot;Ruby in 30 Minutes at yiibai.com&quot;
irb(main):018:0&gt; string[0..8]
=&gt; &quot;Ruby in 3&quot;
irb(main):019:0&gt; string[8..16]
=&gt; &quot;30 Minute&quot;
irb(main):020:0&gt; string[8..-1]
=&gt; &quot;30 Minutes at yiibai.com&quot;
irb(main):021:0&gt; string[8..-2]
=&gt; &quot;30 Minutes at yiibai.co&quot;
irb(main):022:0&gt;
</code></pre>

<p><strong>正号和负号的位置</strong></p>

<p>字符串中的字符每个都有一个位置编号，它们从零开始。 所以对于字符串中的开头“Ru”，“R”位置编号为<code>0</code>，“<code>u</code>”所在的位置编号为<code>1</code>。</p>

<p>要在主字符串中提取出一个子串，可指定提取的起始位置和结束位置。
因此，上面的<code>string[0..8]</code>提取出位置从<code>0</code>至<code>8</code>的字母，也就是：“<code>Ruby in 3</code>”。</p>

<p>Ruby解释负的位置从字符串的末尾返回。所以在上面示例中，结尾的字符串“<code>com</code>”的字母分别对应为“<code>m</code>”位于<code>-1</code>，“<code>o</code>”位于<code>-2</code> 和
“<code>c</code>”位于<code>-3</code> 。</p>

<p>所以如果一个字母同时有正数和负数的位置，那么应该使用哪个？ 建议使用正数，因为这样它们更容易理解。
但是，如果要基于字符串末尾查找东西(例如“该字符串的最后一个字符是什么？”)，则使用负数指定位置。</p>

<h3 id="常用的字符串方法">常用的字符串方法</h3>

<p>在IRB中使用字符串(对象)中一些常用的方法。</p>

<p><strong>.length</strong></p>

<p><code>length</code>方法用于求出字符串中有多少个字符(包括空格)：</p>

<pre><code>irb(main):022:0&gt; string = &quot;0123456789&quot;
=&gt; &quot;0123456789&quot;
irb(main):023:0&gt; string.length
=&gt; 10
irb(main):024:0&gt; string = &quot;maxsu&quot;
=&gt; &quot;maxsu&quot;
irb(main):025:0&gt; string.length
=&gt; 5
irb(main):026:0&gt;
</code></pre>

<blockquote>
<p>尝试：计算你的名字的总长度</p>
</blockquote>

<p><strong>.split</strong></p>

<p>有时想要将一个字符串分成几部分。 例如，假设有一个存储为字符串的句子，并将其分解成单词：</p>

<pre><code>C:\Users\Administrator&gt;irb
irb(main):001:0&gt; string = &quot;This is my sample sentence.&quot;
=&gt; &quot;This is my sample sentence.&quot;
irb(main):002:0&gt; string.split
=&gt; [&quot;This&quot;, &quot;is&quot;, &quot;my&quot;, &quot;sample&quot;, &quot;sentence.&quot;]
irb(main):003:0&gt;
</code></pre>

<p><code>.split</code>方法返回一个数组，这将在后面的部分讲解中了解到。 它默认使用空格(“``”)字符将字符串分割成多个部分。</p>

<p><strong>.split使用参数</strong></p>

<p>但有时要分割的不是一个带有空格的字符。 <code>.split</code>方法接受一个参数来指定分隔符，看看下面示例就明白了。</p>

<pre><code>irb(main):003:0&gt; numbers = &quot;1,2,3,4,5,6,7,8&quot;
=&gt; &quot;1,2,3,4,5,6,7,8&quot;
irb(main):004:0&gt; numbers.split
=&gt; [&quot;1,2,3,4,5,6,7,8&quot;]
irb(main):005:0&gt; numbers.split(&quot;,&quot;)
=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;]
irb(main):006:0&gt;
</code></pre>

<p>在第一次分割的调用中，它尝试使用空格作为分隔符，但字符串中没有分隔符，所以得到一个整个字符串的数组。
在第二次尝试中，指定使用逗号(&rdquo;<code>,</code>&rdquo;)作为分隔符，所以得到一个<code>8</code>个数字值的数组。</p>

<p><strong>.sub 和 .gsub</strong></p>

<p>这两种方法可以用来替换字符串的部分。它们就像在文字处理器中使用“查找和替换”。 <code>.sub</code>替换只发生一次。
而<code>.gsub</code>全局替换的缩写，替换所有的发生(如“全部替换”)。</p>

<p>对于<code>.sub</code>和<code>.gsub</code>，需要指定两个参数：首先是要替换的子字符串，然后再替换要替换的字符串。</p>

<pre><code>irb(main):013:0&gt; greeting = &quot;Hello, Hello Everyone!&quot;
=&gt; &quot;Hello, Hello Everyone!&quot;
irb(main):014:0&gt; greeting.sub(&quot;Hello&quot;,&quot;Hi&quot;)
=&gt; &quot;Hi, Hello Everyone!&quot;
irb(main):015:0&gt; greeting.gsub(&quot;Hello&quot;,&quot;Hi&quot;)
=&gt; &quot;Hi, Hi Everyone!&quot;
irb(main):016:0&gt;
</code></pre>

<h3 id="组合字符串和变量">组合字符串和变量</h3>

<p>将变量的值与字符串相结合这是在开发应用程序中最经常使用的。 例如，现在从下面这个例子开始：</p>

<pre><code>&quot;Good morning, ?? !&quot;
</code></pre>

<p>当把上面语句放入<code>IRB</code>时，它只是打印输出同一个字符串。 如果编写一个应用程序，希望它以用户名而不是“<code>??</code>”来跟用户打招呼，那么需要怎么做？</p>

<p>需要做的就是将变量与字符串组合。有两种方法可以做到这一点。</p>

<p><strong>方法-1. 字符串连接</strong></p>

<p>第一种方法，可使用字符串连接，它将字符串与加号连接：</p>

<pre><code>irb(main):021:0&gt; name = &quot;Maxsu&quot;
=&gt; &quot;Maxsu&quot;
irb(main):022:0&gt; puts &quot;Good morning, &quot; + name + &quot; ! &quot;
Good morning, Maxsu !
=&gt; nil
irb(main):023:0&gt;
</code></pre>

<p>在第一行中，设置了一个<code>name</code>变量来保存名称。 在第二行，打印字符串“<code>Good morning</code>&rdquo; 并结合&rdquo;<code>name</code>“变量和字符串”<code>!</code>&ldquo;的值。</p>

<p><strong>方法-2. 字符串插值</strong></p>

<p>第二种方法是使用字符串插值，将数据粘贴到字符串的中间。</p>

<p>字符串插值仅适用于双引号字符串。在字符串内使用插值标记<code>#{}</code>。
在这些括号中可以把任何变量或Ruby代码放入其中，这些变量或Ruby代码将被评估求值，其结果转换为一个字符串，并输出到外部字符串的那个位置。
上面的例子可以这样重写：</p>

<pre><code>irb(main):023:0&gt; name = &quot;Maxsu&quot;
=&gt; &quot;Maxsu&quot;
irb(main):024:0&gt; puts &quot;Good morning, #{name}!&quot;
Good morning, Maxsu!
=&gt; nil
irb(main):025:0&gt;
</code></pre>

<p>如果比较输出结果，就会看到它们输出的是完全相同的结果。
内插样式往往是输入较少的字符类型，较少的双引号打开/关闭，所以可避免加双引号时忘记书写对称(往往有输入多一个，少一个的问题)。</p>

<p><strong>内插插入代码</strong></p>

<p>还可以将任何Ruby代码或计算表达式内置在括号内，如下所示：</p>

<pre><code>irb(main):025:0&gt; modifier = &quot;very &quot;
=&gt; &quot;very &quot;
irb(main):026:0&gt; mood = &quot;excited&quot;
=&gt; &quot;excited&quot;
irb(main):028:0&gt; puts &quot;I am #{modifier * 3 + mood} for today's play!&quot;
I am very very very excited for today's play!
=&gt; nil
irb(main):029:0&gt;
</code></pre>

<p>首先对<code>#{modifier * 3 + mood}</code>代码块进行评估求值，然后将结果注入外部字符串中。</p>

<h2 id="4-符号">4. 符号</h2>

<p>符号有点难以解释，它们是字符串和数字的一半。但是可以很容易识别一个符号，因为它是以冒号开始一个或多个字母，如<code>:flag</code>或<code>:best_friend</code>。</p>

<h3 id="新程序员的符号">新程序员的符号</h3>

<p>如果你是编程的新手，可将一个符号看作是一个几乎没有任何方法和没有字符串插值的被剥离下来的字符串。 将正确的字符串与类似符号的方法列表进行比较，如下所示：</p>

<pre><code>2.1.1 :001&gt; &quot;hello&quot;.methods
2.1.1 :002&gt; &quot;hello&quot;.methods.count
2.1.1 :003&gt; :hello.methods
2.1.1 :004&gt; :hello.methods.count
</code></pre>

<h3 id="有经验的程序员的符号">有经验的程序员的符号</h3>

<p>如果你是一个有经验的程序员，想象一个符号是一个“命名整数”。 符号引用的实际值无关紧要。 我们所关心的是，虚拟机内对该值的任何引用将返回相同的值。
因此，符号在全局符号表中定义，它们的值不能改变。</p>

<h2 id="5-数字值">5. 数字值</h2>

<p>数字有两种基本类型：整数(整数)和浮点数(有小数点)。<br />
整数对于您和计算机来说都要容易一些。 您可以使用包括<code>+</code>， <code>-</code> ，<code>/</code>和<code>*</code>在内的整数的正常数学运算。
整数有一些方法可以用来做数学相关的事情，过调用<code>5.methods</code>方法就可看到一些常用的方法。</p>

<h3 id="重复指令">重复指令</h3>

<p>重复执行指令在其他语言中的常见模式是<code>for</code>循环，用于重复执行某些指令一定次数。 例如，在JavaScript中可以写：</p>

<pre><code>for(var i = 0; i &lt; 5; i++){
  console.log(&quot;Hello, World&quot;);
}
</code></pre>

<p>对于循环是很常见的，但它们的代码不是很容易阅读。 因为Ruby的整数是它们拥有方法的对象。 其中的一个方法：<code>times</code>是重复执行指令的方法。</p>

<p>以Ruby样式重写上述循环：</p>

<pre><code>5.times do
  puts &quot;Hello, World!&quot;
end
</code></pre>

<p>在这个例子中，使用<code>times</code>方法和具体的执行代码块。 在下一节中将讨论块。 但是请先在 <strong>IRB</strong> 中运行这个例子，看看结果会是什么。</p>

<h2 id="6-块">6. 块</h2>

<p>块是Ruby中经常使用的强大概念。 可将块视为一组捆绑在其他地方使用的指令的方式。</p>

<h3 id="块的开始和结束">块的开始和结束</h3>

<p>在上一节中有一个使用<code>.times</code>方法的块用整数表示：</p>

<pre><code>5.times do
  puts &quot;Hello, World!&quot;
end
</code></pre>

<p>该块以关键字<code>do</code>开始，以关键字<code>end</code>结束。 <code>do/end</code>风格总是可以被Ruby解释器所接受的。</p>

<h3 id="支架块">支架块</h3>

<p>当块仅包含单个指令时，经常使用备用标记<code>{</code>和<code>}</code>来标识块的开始和结束：</p>

<pre><code>5.times{ puts &quot;Hello, World!&quot; }
</code></pre>

<h3 id="块被传递给方法">块被传递给方法</h3>

<p>那么使用块来做什么？ 块可以用来作为传递给方法调用的参数。</p>

<p>例如，如果调用了<code>5.times</code>，Ruby就不会知道要执行五次了。当通过块时，就会说“这里是希望每次运行的说明”。</p>

<p>块中有很多的方法。 就像前面看到的<code>.gsub</code>方法一样，字符串早就为每个匹配运行一个块：</p>

<pre><code>irb(main):038:0&gt; &quot;this is a sentence&quot;.gsub(&quot;e&quot;){ puts &quot;Found an E!&quot;}
Found an E!
Found an E!
Found an E!
=&gt; &quot;this is a sntnc&quot;
irb(main):039:0&gt;
</code></pre>

<p>请注意，&rdquo;<code>Found an E!</code>&ldquo;显示了三次，因为字符串中有三个<code>E</code>字母。</p>

<h3 id="块参数">块参数</h3>

<p>通常，在块内指示需要引用正在使用的值。 当在编写块代码时，可以在管道字符中指定一个块参数：</p>

<pre><code>5.times do |i|
  puts &quot;Hello, World! &quot;
end
</code></pre>

<p>什么值应该放入该块参数，这取决于要调用的方法。 在本示例中，<code>times</code>方法放入当前运行的数值。尝试上面的块，观察输出，然后尝试这样修改：</p>

<pre><code>5.times do |i|
  puts &quot;#{i}: Hello, World!&quot;
end
</code></pre>

<p>上面代码输出结果如下 -</p>

<pre><code>irb(main):045:0&gt; 5.times do |i|
irb(main):046:1*   puts &quot;#{i}: Hello, World!&quot;
irb(main):047:1&gt; end
0: Hello, World!
1: Hello, World!
2: Hello, World!
3: Hello, World!
4: Hello, World!
=&gt; 5
irb(main):048:0&gt;
</code></pre>

<p>而<code>.gsub</code>在找到的字符串中传递。 尝试这个(用括号表示法)：</p>

<pre><code>irb(main):048:0&gt; &quot;this is a sentence&quot;.gsub(&quot;e&quot;){|letter| letter.upcase}
=&gt; &quot;this is a sEntEncE&quot;
irb(main):049:0&gt;
</code></pre>

<p>在上面结果中看到<code>gsub</code>正在使用块的结果作为原始匹配的替换。</p>

<h2 id="7-数组">7.数组</h2>

<p>通常当编写程序时，我们需要处理数据的集合。先来看看最常见的数据集合 - 数组。</p>

<h3 id="可视化模型">可视化模型</h3>

<p>数组是数字索引列表。 想象一下，有一张空白的纸，画了三个小盒子：</p>

<pre><code> ---  ---  ---
|   ||   ||   |
 ---  ---  ---
</code></pre>

<p>可以按照从左到右对每一个位置进行编号：</p>

<pre><code> ---  ---  ---
|   ||   ||   |
 ---  ---  ---
  0    1    2
</code></pre>

<p>然后在每个框中放入字符串(或其它值)：</p>

<pre><code> -------------  ---------  ----------
| &quot;Breakfast&quot; || &quot;Lunch&quot; || &quot;Dinner&quot; |
 -------------  ---------  ----------
       0            1           2
</code></pre>

<p>现在变成一个有三元素的数组。 Ruby数组的大小可以增长和缩小，所以如果添加一个元素，它通常会在结束位置添加，索引值也会变递增<code>1</code>：</p>

<pre><code> -------------  ---------  ----------  -----------
| &quot;Breakfast&quot; || &quot;Lunch&quot; || &quot;Dinner&quot; || &quot;Dessert&quot; |
 -------------  ---------  ----------  -----------
       0            1           2           3
</code></pre>

<p>请注意，最后一个元素的位置总是比元素的数量小<code>1</code>。</p>

<p>数组中在索引为<code>2</code>位置对应的数据值为“<code>Dinner</code>”。最后一个元素对应的数据值为“<code>Dessert</code>”。</p>

<h3 id="代码中的数组">代码中的数组</h3>

<p>以下是Ruby代码中相同建模的方法：</p>

<pre><code>irb(main):049:0&gt; meals = [&quot;Breakfast&quot;, &quot;Lunch&quot;, &quot;Dinner&quot;]
=&gt; [&quot;Breakfast&quot;, &quot;Lunch&quot;, &quot;Dinner&quot;]
irb(main):050:0&gt; meals &lt;&lt; &quot;Dessert&quot;
=&gt; [&quot;Breakfast&quot;, &quot;Lunch&quot;, &quot;Dinner&quot;, &quot;Dessert&quot;]
irb(main):051:0&gt; meals[2]
=&gt; &quot;Dinner&quot;
irb(main):052:0&gt; meals.last
=&gt; &quot;Dessert&quot;
irb(main):053:0&gt;
</code></pre>

<p>在上面代码运行结果中，观察到…</p>

<ul>
<li><p>该数组是通过将数据片段放在方括号(<code>[]</code>)之间并用逗号分隔来创建的。</p></li>

<li><p>通过使用“铲子运算符”(<code>&lt;&lt;</code>)添加一个元素到数组的末尾</p></li>

<li><p>通过使用方括号(<code>[]</code>)在指定索引位置来获取元素</p></li>

<li><p>数组中一些方便的方法，如<code>.last</code></p></li>
</ul>

<h3 id="常用数组方法">常用数组方法</h3>

<p>数组有很多很酷的东西。 以下是几个例子：</p>

<p><strong>.sort方法</strong></p>

<p><code>sort</code>方法将返回一个新的数组，其中元素是已经被排序过了。 如果元素是字符串，它们将以字母顺序返回。
如果它们是数字，它们将按升值顺序回来。尝试下面示例：</p>

<pre><code>irb(main):056:0&gt; array1 = [&quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;array&quot;]
=&gt; [&quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;array&quot;]
irb(main):057:0&gt; array1.sort
=&gt; [&quot;an&quot;, &quot;array&quot;, &quot;is&quot;, &quot;this&quot;]
irb(main):058:0&gt; array1
=&gt; [&quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;array&quot;]
irb(main):059:0&gt;
</code></pre>

<p>可以使用<code>sort</code>方法重新排列元素的顺序。使用<code>each</code>方法遍历每个元素。使用<code>join</code>方法将它们一起混合成一个字符串。使用<code>index</code>方法找到特定元素的地址。可以使用<code>include?</code>方法询问数组是否包含指定的元素。</p>

<p>使用数组只要需要一个列表，其中元素是以特定的顺序排序的。</p>

<p><strong>其他的尝试</strong></p>

<p>在数组上尝试下面这些常见的方法：</p>

<ul>
<li><code>each</code></li>
<li><code>collect</code></li>
<li><code>first</code> 和 <code>last</code></li>
<li><code>shuffle</code></li>
</ul>

<p>可以参考这个文档了解更多详细信息：<a href="http://www.ruby-doc.org/core-2.1.2/Array.html">http://www.ruby-doc.org/core-2.1.2/Array.html</a></p>

<h2 id="8-哈希">8.哈希</h2>

<p>哈希是数据的集合，哈希中的数据的每个元素是按名称来寻址。作为一个比喻，想一下冰箱。 如果要跟踪放在冰箱内的东西，我们并不关心它的放在哪里 - 顺序并不重要。
相反只是按名称去组织这些东西。如名称“<code>apples</code>”可能具有值<code>3</code>，则名称“<code>oranges</code>”可能具有值<code>1</code>，并且“<code>carrots</code>”值为<code>12</code>。
在本示例中，就可使用哈希。</p>

<h3 id="键-值对">键/值对</h3>

<p>哈希是无序的集合，其中数据被组织成“ <strong>键/值对</strong> ”。 哈希的语法更复杂，需要一些习惯：</p>

<pre><code>irb(main):001:0&gt; produce = {&quot;apples&quot; =&gt; 3, &quot;oranges&quot; =&gt; 1, &quot;carrots&quot; =&gt; 12}
=&gt; {&quot;apples&quot;=&gt;3, &quot;oranges&quot;=&gt;1, &quot;carrots&quot;=&gt;12}
&lt;e are #{produce['oranges']} oranges in the fridge.&quot;
There are 1 oranges in the fridge.
=&gt; nil
irb(main):003:0&gt;
</code></pre>

<p>键用作为地址，值是该地址的数据。
在<code>produce</code>哈希中有包括“<code>apples</code>”和“<code>oranges</code>”的键，其值分别为<code>12</code>和<code>3</code>。当创建哈希时，键和值使用<code>=&gt;</code>符号链接。
所以哈希从一个大括号<code>{</code>开始，(由一个键，一个<code>=&gt;</code>标识符和一个由逗号分隔的值组成的零个或多个条目，然后以一个关闭的大括号<code>}</code>结束。</p>

<p>再尝试一些代码：</p>

<pre><code>irb(main):006:0&gt; produce[&quot;grapes&quot;] = 219
=&gt; 219
irb(main):007:0&gt; produce
=&gt; {&quot;grapes&quot;=&gt;219}
irb(main):008:0&gt; produce[&quot;oranges&quot;] = 66
=&gt; 66
irb(main):009:0&gt; produce
=&gt; {&quot;grapes&quot;=&gt;219, &quot;oranges&quot;=&gt;66}
irb(main):010:0&gt; produce.keys
=&gt; [&quot;grapes&quot;, &quot;oranges&quot;]
irb(main):011:0&gt; produce.values
=&gt; [219, 66]
irb(main):012:0&gt;
</code></pre>

<p>在这些说明的第一行中，向哈希添加了一个新值。 由于“grapes”键不在原始哈希中，所以它的值为<code>221</code>。
哈希中的键必须是唯一的，所以当对<code>product
[“oranges”]</code>使用相同的语法时，它会看到键“<code>oranges</code>”已经在列表中，并且用<code>6</code>替换值。<code>keys</code> 和
<code>values</code>方法会列出所有键和值。</p>

<h3 id="简化哈希语法">简化哈希语法</h3>

<p>通常会使用符号作为哈希的键。 当所有的键都是符号时，可以使用一个速记语法：</p>

<pre><code>irb(main):012:0&gt; produce = {apples: 3, oranges: 1, carrots: 12}
=&gt; {:apples=&gt;3, :oranges=&gt;1, :carrots=&gt;12}
irb(main):013:0&gt; puts &quot;There are #{produce[:oranges]} oranges in the fridge.&quot;
There are 1 oranges in the fridge.
=&gt; nil
irb(main):014:0&gt;
</code></pre>

<p>请注意，键以冒号结尾，而不是以冒号开始，即使这些是符号。 这个简化的语法能在<code>Ruby
1.9</code>及更高版本配合使用。要了解正在使用的是哪个版本的Ruby，可在控制台中输入“<code>ruby -v</code>”。</p>

<h2 id="9-条件">9. 条件</h2>

<p>条件语句评估求值结果为<code>true</code>或<code>false</code>。
最常见的条件运算符是<code>==</code>(相等)，<code>&gt;</code>(大于)，<code>&gt;=</code>(大于或等于)，<code>&lt;</code>(小于)和<code>&lt;=</code>(小于或等于)。</p>

<p>一些对象也有返回<code>true</code>或<code>false</code>的方法，因此它们在条件语句中使用。 例如，每个对象都有方法<code>.nil？</code>
只有当对象为<code>nil</code>时才返回：<code>true</code>。 数组有一个名称为<code>.include</code>的方法 如果数组包含指定的元素，则返回<code>true</code>。
Ruby中的约定方法名称以<code>？</code>结尾返回<code>true</code>或<code>false</code>。</p>

<h3 id="条件分支-指令">条件分支/指令</h3>

<p>为什么要有条件语句？ 最常见的是控制条件指令，特别是：<code>if</code>/<code>elsif</code>/<code>else</code>结构。在 <strong>IRB</strong> 中添加一个这样的方法来写一个例子：</p>

<pre><code>def water_status(minutes)
  if minutes &lt; 7
    puts &quot;The water is not boiling yet.&quot;
  elsif minutes == 7
    puts &quot;It's just barely boiling&quot;
  elsif minutes == 8
    puts &quot;It's boiling!&quot;
  else
    puts &quot;Hot! Hot! Hot!&quot;
  end
end

# run method with difference parameter
water_status(5)
water_status(7)
water_status(8)
water_status(9)
</code></pre>

<p>尝试使用：<code>water_status(5)</code>，<code>water_status(7)</code>，<code>water_status(8)</code>和<code>water_status(9)</code>运行该方法。</p>

<p><strong>理解执行流程</strong></p>

<p>当<code>minutes</code>值为<code>5</code>时，执行结果是什么？因为<code>minutes = 5</code>小于<code>7</code>，所以打印出来的结果为：“<code>The water is not
boiling yet.</code>”</p>

<p>当<code>minutes</code>值为<code>7</code>时，执行结果是什么？因为<code>minutes</code>值等于<code>7</code>，所以打印出来的结果为：“<code>It's just barely
boiling</code>”</p>

<p>当<code>minutes</code>值为<code>8</code>时，执行结果是什么？因为<code>minutes</code>值等于<code>8</code>，所以打印出来的结果为：“<code>It's boiling!</code>”</p>

<p>当<code>minutes</code>值为<code>9</code>时，执行结果是什么？因为<code>minutes =
9</code>，它比较了前面的几个值：<code>5</code>，<code>7</code>，<code>8</code>，但是都没有匹配项，所以最后执行到<code>else</code>语句块中，打印出来的结果为：“<code>Hot! Hot!
Hot!</code>”</p>

<p><strong>if语句可能的结构</strong></p>

<p><code>if</code>语句有以下可能的结构：</p>

<ul>
<li><code>if</code>语句的指令只有在语句为真时执行。</li>
<li><code>if</code>语句后面可有零或多个<code>elsif</code>语句，其指令仅在语句为真时执行</li>
<li><code>if</code>语句后面零或一个<code>else</code>语句，如果没有一个<code>if</code>或<code>elsif</code>语句为真，则执行<code>else</code>语句中的指令。</li>
</ul>

<p><code>if</code>/<code>else
if</code>/<code>else</code>结构中只能在一个部分可以运行它的指令。例如，如果<code>if</code>是真的，Ruby将永远不会执行<code>elseif</code>或<code>else</code>，也就是说永远只执行其中一块。</p>

<h3 id="相等与分配值">相等与分配值</h3>

<p>编写条件语句时遇到常见错误是书写<code>=</code>和<code>==</code>，以及它们的区别。</p>

<ul>
<li><code>=</code>符号表示赋值。表示“拿右边的东西，把它粘在左边的任何东西”</li>
<li><code>==</code>表示为这是一个问题。表示“右边的东西是等于左边的东西吗？”</li>
</ul>

<p>还可以使用逻辑运算符组合条件语句。 最常见的是“逻辑与”和“逻辑或”。
在Ruby中，您可以使用这样的双符号(<code>&amp;&amp;</code>)来书写表示一个“逻辑和”。可以用这样的双管道(<code>||</code>)书写表示一个“逻辑或”。</p>

<h2 id="10-nil和虚无">10. Nil和虚无</h2>

<p>什么是虚无？ 当我们表达一个东西，没有确定它是什么东西的暂时可以叫它为： <strong>虚无</strong> ，不是没有什么东西吗？ 好的，这太多哲学了，这有确实点难解释了。</p>

<p><code>nil</code>是Ruby中用于表达“虚无”的方式。</p>

<p>如果有三个鸡蛋，您吃三个鸡蛋，那么可能认为现在您“没有什么”蛋了，但是在鸡蛋方面有“<code>0</code>”个。<code>0</code>是什么？它是一个数字，它并不是“ <strong>虚无</strong> ”。</p>

<p>如果使用一个单词，如“<code>hello</code>”这样的字符串，那么删除“<code>h</code>”，“<code>e</code>”，“<code>l</code>”和“<code>o</code>”，你可能会认为没有什么，但是现在真的有<code>“”</code>，它是一个空字符串，并不是“
<strong>虚无</strong> ”。</p>

<p><code>nil</code>是Ruby的虚无的想法的表示。 当要求不存在的东西时，通常会遇到这种情况。
例如，当查看数组时，创建了一个包含五个元素的列表，然后要获取列表中添加第六个元素。但是没有第六个元素，所以Ruby给了<code>nil</code>。
在第六个元素的地方它并不是空白(<code>“”</code>)，也不是数字<code>0</code>，它是空/<code>nil</code>。</p>

<p>编写Ruby代码时遇到的大部分错误是涉及<code>nil</code>值的。以为某个位置有数据值，试图使用使用这个数据值去做一些事情，但没有这样的数据值，不能做任何事情，所以Ruby引发了一个错误。</p>

<h2 id="11-对象-属性和方法">11. 对象，属性和方法</h2>

<h3 id="ruby是面向对象的编程语言">Ruby是面向对象的编程语言</h3>

<p>Ruby是一种面向对象的编程语言，在与 <strong>VM</strong> 内部交互的所有东西都是对象。 每条数据都是一个对象。 对象保存的信息称为属性，可以执行对象的方法。</p>

<p>作为一个对象的例子，想像你是一个人。 你有像高度，重量和眼睛颜色的属性。
你有“走路”，“跑步”，“洗碗”和“白日梦”的方法。不同类型的对象具有不同的属性和方法。 在接下来的章节中，将介绍一些Ruby中常见的特定类型的对象。</p>

<h3 id="类和实例">类和实例</h3>

<p>在面向对象编程中，我们定义了类，它们是类别或类型的东西的抽象描述。 它定义了该类型的所有对象的属性和方法。</p>

<p><strong>定义一个类</strong></p>

<p>例如，考虑对一个学校信息建模。要创建一个名为“<code>Student</code>”的类，表示学生的抽象。
<code>Student</code>类将定义如：<code>first_name</code>，<code>last_name</code>和<code>primary_phone_number</code>的属性。
它可以定义一个用于学生自我介绍的方法：<code>introduction</code>。</p>

<p>尝试在 <em>IRB</em> 编写上面代码：</p>

<pre><code>class Student
  attr_accessor :first_name, :last_name, :primary_phone_number

  def introduction
    puts &quot;Hi, I'm #{first_name}!&quot;
  end
end
</code></pre>

<p><code>attr_accessor</code>方法是用于定义类的实例的属性。</p>

<p><strong>创建类的实例</strong></p>

<p><code>Student</code>类本身不代表学生，这是学生信息表示模型。 要表示一个实际的学生，需要创建一个<code>Student</code>类的实例。</p>

<p>想像你就是一个学生，不是一个抽象的概念，因为你是一个实际的人。这个实际的人是<code>Student</code>类的一个实例 -
它是一个抽象思想的实现。一个实际的人具有属性：<code>first_name</code>，<code>last_name</code> 和 <code>primary_phone_number</code>
的实际数据(比如：你的<code>first_name</code>是“<code>爱华</code>”，<code>last_name</code>是“<code>李</code>”等等)。</p>

<p>另一方面，<code>Student</code>类有几个抽象的属性： <code>first_name</code>，<code>last_name</code> 和
<code>primary_phone_number</code>，我们不能提前确定它们。</p>

<h3 id="从文件运行ruby">从文件运行Ruby</h3>

<p>一般情况下，很少在<code>IRB</code>中定义类。这是因为<code>IRB</code>只是一个便签本(不能很好的保存代码)，记得吗？ 下面来看看如何从文件中运行Ruby。</p>

<ul>
<li>退出IRB会话(输入：<code>exit</code>或 <code>Ctrl + D</code>)</li>
<li>注意终端当前在哪个文件夹，进入你的“工作目录”(本教程中，代码都是写在：<code>F:\worksp\ruby</code>)</li>
<li>使用纯文本编辑器创建一个名为<code>student.rb</code>的文件。</li>
<li>将文件保存在<code>student.rb</code>文件中。</li>

<li><p>从终端运行文件：</p>

<p>ruby student.rb</p></li>
</ul>

<p>由于这个文件是空的，所以不应该得到任何输出。</p>

<p>创建<code>Student</code>类</p>

<p>在文本编辑器中，开始编写类的结构：</p>

<pre><code>class Student

end
</code></pre>

<p>在类的内部，通常使用<code>def</code>关键字定义一个或多个方法，如下：</p>

<pre><code>class Student
  def introduction
    puts &quot;Hi, I'm #{first_name}!&quot;
  end
end
</code></pre>

<p>请注意，<code>puts</code>行正在计算求值一个名为<code>first_name</code>的方法，该方法返回学生的名字。下面可以进一步添加之前使用的三个属性：</p>

<pre><code>class Student
  attr_accessor :first_name, :last_name, :primary_phone_number

  def introduction
    puts &quot;Hi, I'm #{first_name}!&quot;
  end
end
</code></pre>

<h3 id="运行文件">运行文件</h3>

<p>回到终端，尝试用<code>ruby student.rb</code>运行文件。应该不会看到有结果输出。</p>

<p>这是为什么呢？ 上面步骤中已经定义了一个<code>Student</code>类，并表示一个学生有一个名为<code>introduction</code>的方法以及一些属性 -
但是实际上并没有创建<code>Student</code>类的实例或调用任何方法。</p>

<p><strong>创建实例</strong></p>

<p>当定义一个类后，还要创建类的一个实例，如下所示：</p>

<pre><code>frank = Student.new
</code></pre>

<p>在<code>Student</code>类上调用<code>new</code>方法并将其存储到变量<code>frank</code>中。当有了这个类的实例以后，就可以调用实例的方法来设置或获取其属性。</p>

<p>使用以下语法调用方法：<code>object.method_name</code>。在上面示例中，创建一个实例变量：<code>frank</code>，现在可以通过调用
<code>frank.introduction</code> 来获取学生的介绍信息了。</p>

<p><strong>在文件中创建一个实例</strong></p>

<p>在<code>student.rb</code>文件的底部，在Student类的<code>end</code>关键字之后，添加以下内容：</p>

<pre><code>frank = Student.new
frank.first_name = &quot;Frank&quot;
frank.introduction
</code></pre>

<p>最终完整的代码如下所示 -</p>

<pre><code>class Student
  attr_accessor :first_name, :last_name, :primary_phone_number

  def introduction
    puts &quot;Hi, I'm #{first_name}!&quot;
  end
end

frank = Student.new
frank.first_name = &quot;Max&quot;
frank.introduction
</code></pre>

<p>保存代码并返回到终端，再次执行<code>ruby student.rb</code>。 现在应该输出：“<code>Hi, I'm Max!</code>”</p>

<h3 id="方法参数">方法参数</h3>

<p>有时，方法使用一个或多个参数来完成一些事情。 例如，可以调用
<code>frank.introduction('Minlee')</code>，让它向<code>Minlee</code>介绍自己。参数可以是数字，字符串或任何种类的对象，下面修改<code>introduction</code>方法，以使用一个参数：</p>

<pre><code>class Student
  attr_accessor :first_name, :last_name, :primary_phone_number

  def introduction(target)
    puts &quot;Hi #{target}, I'm #{first_name}!&quot;
  end
end

frank = Student.new
frank.first_name = &quot;Maxsu&quot;
frank.introduction('Minlee')
</code></pre>

<p>保存代码并返回到终端，再次执行<code>ruby student.rb</code>。 现在应该输出：“<code>Hi Minlee, I'm Maxsu!</code>”</p>

<h3 id="返回值">返回值</h3>

<p>在Ruby中，每次调用方法时都会得到一个值。 默认情况下，Ruby方法返回其评估求值的最后一个表达式的值。</p>

<p>现在向<code>Stuent</code>类中添加一个方法：<code>favorite_number</code>，如下所示 -</p>

<pre><code>class Student
  attr_accessor :first_name, :last_name, :primary_phone_number

  def introduction(target)
    puts &quot;Hi #{target}, I'm #{first_name}!&quot;
  end

  def favorite_number
    7
  end
end

frank = Student.new
frank.first_name = &quot;Maxsu&quot;
puts &quot;Maxsu's favorite number is #{frank.favorite_number}.&quot;
</code></pre>

<p>打开终端运行上面代码，应该看到：“<code>Maxsu's favorite number is
7</code>”。文件的最后一行调用的是<code>favorite_number</code>方法。
该方法的最后一行(只有)行是第<code>7</code>行。这个表达式作为方法的返回值，该值返回给调用该方法的任何人。在例子中，这<code>7</code>数字值返回并被插入到字符串中。</p>

<p><strong>注意</strong> ：写在最后，需要注意的是：这篇教程包教不包会！</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a></li>
        
        <li><a href="/posts/051rubyonrails%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%981hellorails/">051RubyonRails學習筆記1Hellorails</a></li>
        
        <li><a href="/posts/053rubyonrails%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%986%E9%87%8D%E6%A7%8B%E5%88%AA%E9%99%A4%E7%95%99%E8%A8%80%E5%AE%89%E5%85%A8/">053RubyonRails學習筆記6重構刪除留言安全</a></li>
        
        <li><a href="/posts/055rubyonrails%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%987carrierwaveimplementation/">055RubyonRails學習筆記7CarrierwaveImplementation</a></li>
        
        <li><a href="/posts/065rubyonrails%E7%AD%86%E8%A8%9810showtargetinfoongooglemaps/">065Rubyonrails筆記10showtargetinfoongooglemaps</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/ruby'>ruby</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>