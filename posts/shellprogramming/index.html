<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>ShellProgramming | 开发者问答集锦</title>
    <meta property="og:title" content="ShellProgramming - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="ShellProgramming">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shellprogramming/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">ShellProgramming</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>转自：<a href="http://blog.csdn.net/lovechen508/archive/2006/04/08/655305.aspx">http://blog.csdn.net/lovechen508/archive/2006/04/08/655305.aspx</a></p>

<p>shell programming</p>

<p>Shell</p>

<p>当我们登入 Linux 之後, 第一个接触到的, 便是 Shell. 我们必须对它有点初步的认识才行.</p>

<p>一. Shell 简介.</p>

<p>Linux 系统分成三个重要的部份</p>

<p>核心<br />
Shell<br />
工具程式<br />
核心的部份相当低阶, 操作者不易和它直接沟通, 因此, 必须要有一个友善的介面(interface), 使得操作时能更为方便, 这个介面便是 Shell.</p>

<p>换言之, Shell 就是一个居於核心和操作者之间的一层使用者介面.</p>

<p>那麽, 为何称它为 Shell 呢? Shell 的本意是 &ldquo;壳&rdquo; 的意思呢!</p>

<p>没错, 在核心的外面, 包覆着一层外壳, 用来负责接收使用者输入的指令, 然後将指令解译成核心能够了解的方式, 传给核心去执行,
再将结果传回至预设的输出周边.</p>

<p>如图所示:</p>

<p>例如: 键入</p>

<p>ls -l</p>

<p>shell 给你以下回应:</p>

<p>拥<br />
档 有<br />
案 档<br />
种 案 档案大小 最近修改的<br />
类 档案权限 数 拥有人 组别 (byte单位)日期及时间 档案名称<br />
drwxr-xr-x 14 root root 1024 Jul 21 21:31 .<br />
drwxr-xr-x 17 root root 1024 Apr 11 12:01 ..<br />
drwxr-xr-x 8 82 82 1024 Feb 25 19:23 apache<br />
-rw-r&ndash;r&ndash; 1 root root 1335460 Feb 25 17:45 apache_1_3_4.tar.gz<br />
drwxr-xr-x 6 root root 1024 Aug 31 1998 ftp<br />
drwxr-xr-x 5 root root 1024 Aug 31 1998 httpd<br />
drwx&mdash;&mdash; 2 james james 1024 Apr 23 06:47 james<br />
drwxr-xr-x 2 root root 12288 Aug 31 1998 lost+found<br />
drwxr-xr-x 2 msql nobody 1024 Dec 28 1998 msql<br />
drwxr-xr-x 28 ols3 ols3 2048 Jul 19 21:38 ols3<br />
drwxr-xr-x 3 1022 nobody 1024 Jan 25 23:40 ols3cgi<br />
drwxrwxr-x 3 perl ols3 1024 Feb 2 07:11 perl<br />
-rw&mdash;&mdash;- 1 root root 2097152 Jul 21 18:39 quota.group<br />
-rw&mdash;&mdash;- 1 root root 1278656 Jul 21 18:39 quota.user<br />
drwxrwxr-x 2 root nobody 1024 May 11 1998 samba<br />
drwxr-xr-x 3 apache nobody 1024 Feb 25 16:58 temp<br />
drwxrwxr-x 2 webadm nobody 1024 Mar 14 16:34 webadm</p>

<p>其实不只是 Linux 有这一层 Shell, 其它作业系统也有.<br />
比如 DOS 的 command.com, Windows 的 GUI(Graphical User Interface), Mac 的 GUI.</p>

<p>Shell 按着表现的方式与读取使用者输入种类的不同, 可分为二大类:</p>

<p>Text base : 文字导向<br />
Graph base: 图型导向<br />
所谓 &ldquo;读取使用者输入种类不同&rdquo; 是指: 读取自键盘, 或读取自滑鼠, 其它 serial input, 萤幕触控等.</p>

<p>这样说来, Shell 好像只是命令直译器罢了?!<br />
嗯, 这倒要按不同的 OS 所附给的 Shell 其功能和选择性的自由度而定.</p>

<p>以 DOS 的 COMMAND.COM 而言, 它就是一个十足的命令直译器, 除了一点点 batch 档的能力之外, 它的功能并不多. Win 平台的
GUI, 则是一个图型式的命令直译器, 介面十分友善. 不过, 这二种 OS, 不能让你自由而简单地选择 Shell.(以前 DOS 有 4dos 可选用)</p>

<p>Linux 的 shell, 除了做为命令直译器之外, 它也是一个不错的程式语言, 是系统管理维护时的重要工具.</p>

<p>由於 Unix 家族, 对 Shell 的处理, 采独立自由开放的方式, 因此, Shell 的种类相当地多, 更可以让人自由地更换(chsh).</p>

<p>目前流行的 shell 有:</p>

<p>Bourne shell : sh<br />
C shell : csh<br />
Korn shell: ksh (商业软体)<br />
tcsh (free)<br />
Bourne Again shell: bash (GNU)<br />
Linux 的标准 shell 是采用 bash. 它也是我们要学习的主要对象.</p>

<p>二. Shell 的简史</p>

<p>第一个重要的 shell 是 Bourne shell (如此命名是为了纪念此 shell 的发明者 Steven Bourne), 1979
年第一个流行的 Unix 版本 7 发行时, 开始使用 Bourne shell.</p>

<p>Bourne shell 的主档名为 sh, 因此, 日後人们便以 sh 为 Bourne shell 的主要识别名称.</p>

<p>虽然 Unix 上的 shell 有许多种, 但 Bourne shell 的地位至今仍然没有改变. 许多 Unix 系统中仍然使用 sh
做为重要的管理工具. (它的工作从开机到关机, 几乎无所不包)</p>

<p>第一个广为流行使用的 shell 变种是 C shell. C shell 主要附在 BSD 版的 Unix 系统中. 它的作者是柏克莱大学的 Bill
Joy. C shell 主要是因为其语法和 C 语言相类似, 因而得名. 这使得 Unix 系统的程式师, 在学习 C shell 时,
感到相当地方便容易.</p>

<p>以上这二种形成 shell 的二大主流, 後来的变种 shell 大都攫取这二种 shell 的优点.</p>

<p>比如 Korn, tcsh 及 bash.</p>

<p>Bash shell 是 GNU 计划的重要工具软体之一, 也是 GNU 作业系统中标准的 shell.</p>

<p>Bash 相容於 sh, 因此, 许多早期开发出来的 Bourne shell 都可以继续在 bash 中运作. 现在我们安装好的 RedHat Linux
便是完全使用 Bash. (/bin/sh -&gt; /bin/bash)</p>

<p>Bash 在 1988 年诞生, 最初的作者是 Brian Fox, Chet Ramey 於 *** 加入, 现在官方正式的维护者是 Chet
Ramey, 他的工作便是持续不断地增强 bash 的功能.</p>

<p>1995~1996 期间推出 bash 2.0 , 在这之前, 广为使用的版本是 1.14.x, 它增加了许多新的功能, 以及更好的相容性.</p>

<p>当然, Bash 是完全免费的, 它是 Open Source 的一员, 原始码全部开放.</p>

<p>二. Bash 的功能.</p>

<p>Bash 具有以下功能:</p>

<p>相容於 Bourne shell (sh)<br />
包含有 C shell 以及 Korn shell 中最好的功能.<br />
具命令列编修的能力(您记得以前 DOS 中的 doskey 吗?)<br />
工作控制(job control)的能力, 可控制前景及背景程式<br />
具 shell 程式设计的能力, 可让您自订shell及设计程式, 管理系统.<br />
三. 新版的 Bash 哪里抓取?</p>

<p>若欲抓取新版的 bash, 可至 <a href="http://www.gnu.org">http://www.gnu.org</a> 或其 mirror 站台.</p>

<p>中研院 FTP 也是不错的选择. [url=<a href="ftp://ftp.sinica.edu.tw[/url">ftp://ftp.sinica.edu.tw[/url</a>] 或
[url]<a href="ftp://linux.sinica.edu.tw]ftp://ftp.sinica.edu.tw[/......ftp://linux.sinica.edu.tw[/url">ftp://linux.sinica.edu.tw]ftp://ftp.sinica.edu.tw[/......ftp://linux.sinica.edu.tw[/url</a>]</p>

<p>三. 开始使用 Bash</p>

<p>当你 login 进 Linux 主机时, 便开始和 bash 互动, 一直到你 logout 主机(下exit,logout,或按^D) 为止.</p>

<p>Bash 的提示符号为 $ (代表一般身份使用者), 当您具有 root 权限时, 提示符号则变为 #.</p>

<p>一旦出现提示符号时, 您便可以开始键入操作命令列(command line)了.</p>

<p>命令可分为二大类:</p>

<p>bash 内建的指令<br />
程式<br />
如果是 bash 内建的指令, 则由 bash shell 负责回应; 若是程式, 则 shell 会找出该程式, 然後将控制权交给核心,
由核心执行该程式, 执行完之後, 再将控制权交回给 shell.</p>

<p>怎麽知道那些指令是 bash 内建的, 那些是程式呢? 通常用 &ldquo;which 指令&rdquo;, 若没有任何回应, 表示是内建的指令(除非该指令错误、不存在,
或该程式不在预设的搜寻路径之内), 例如下:</p>

<p>[ols3@ols3 /ols3]$ which echo [没有回应, 表示是内建的指令]</p>

<p>[ols3@ols3 /ols3]$ which ls</p>

<p>/bin/ls</p>

<p>四. 命令列的格式.</p>

<p>命令列通常由好几个字串组成, 中间用空白或 tab 键分开. 如下所示:</p>

<p>command options arguments(或称为 parameters)<br />
命令 选项 参数<br />
rm -rf /home/ols3</p>

<p>除了空白和 tab 键之外, 每一部份, 我们称之为 token, 比如上面的例子中, 便有三个 token: rm, -rf, /home/ols3.</p>

<p>当键入此一命令列时, shell 首先将它分解成个别的 token, 然後判断是内建的指令, 或是程式, 再按之前提过的方式去执行.</p>

<p>怎麽知道一个命令或程式, 它有那些选项和参数呢? 通常 man 一下该指令, 就可以得到了. 例如:</p>

<p>man rm</p>

<p>另外, 多行指令也可以一下全部写在同一命令列中, 只要中间用 ; 分开, 如:</p>

<p>ls ; mkdir test ; clear</p>

<p>五. 现行目录和自家目录.</p>

<p>所谓现行目录(current directory)是指: 你现在所处的位置, 又称为工作目录(working directory).</p>

<p>欲知现行目录为何? 可下 pwd 指令便知.</p>

<p>所谓自家目录(home directory)是指: 当初 root 为你建立帐号时, 所指定给你的一个私人专用的目录, 也是你登入系统之後,
第一个进入的地方.</p>

<p>欲知自家目录, 可用下列方式:</p>

<p>cd (然後直接按 Enter)<br />
cd ~ (~ 代表自家目录)<br />
cat /etc/passwd | grep 您的帐号<br />
相关的技巧</p>

<p>cd ./myway (进入目前目录下的 myway 目录中)<br />
cd .. (回到上一层目录)<br />
cd - (回到先前的目录)<br />
六. 万用字元.</p>

<p>如果命令列的参数中, 含有档名, 那麽万用字元(wildcards)可以带来十分便利的操作. (不过若使用不当, 也是恶梦的开始)</p>

<p>如果各位以前有过 DOS 的操作经验, 应该还记得 * 及 ? 所代表的意义吧?!</p>

<p>以下是 bash 中使用的万用字元:</p>

<p>? 代表任何单一字元(character)<br />
* 代表任何字串 (注意: 0 个以上的字元, 例: *yes 将包含 yes 或 yes-or-not)<br />
[字元组合] 在中括号中的字元皆符合, 如: [a-z]代表所有的小写字母<br />
[!字元组合] 不在中括号中的字元皆符合, 如: [!0-9]代表非数字的字元皆符合</p>

<p>七. 输入和输出与重新导向.</p>

<p>当 Linux 系统完成开机之後, 预设上, 便开有三个档案, 这三个档案是做为输入、输出以及显示错误之用的.</p>

<p>我们称之为:</p>

<p>标准输入: 通常是键盘, 档案代码为 0<br />
标准输出: 通常是萤幕, 档案代码为 1<br />
标准错误: 通常标准输出相同(也就是萤幕), 档案代码为 2<br />
虽然系统已帮你设好了这三个档案, 但我们仍然可以视需要, 适时地改变输入,输出,及错误这三者至不同的地方. 这种改变标准输出入的动作, 我们称之为 &ldquo;I/O
重新导向&rdquo; (I/O Redirection).</p>

<p>例如:</p>

<p>ls -la &gt; myfile 就是将查询的结果重新导向至 myfile 中(本来是应该出现在萤幕上的)</p>

<p>cat myfile 便可以看见 ls -la 的结果.</p>

<p>cat &lt; myfile &gt; youfile 就是将 myfile 的内容拷贝给 youfile.</p>

<blockquote>
<p>代表将输出转向</p>
</blockquote>

<p>&lt; 代表将输入转向</p>

<p>另一个会将输出入转向的机制是 &ldquo;管线&rdquo; (Pipelines).</p>

<p>所谓的管线就是将一个程式的输出当成另一个程式的输入.</p>

<p>例如: cat /etc/passwd | grep ols3</p>

<p>上面这段指令的意思是说: 把 /etc/passwd 档的内容显示结果(即输出) 丢给 grep 这个指令当作输入值, 然後由 grep 从中找出包含关键字
ols3 的资料列.</p>

<p>八. 前景与背景工作.</p>

<p>Linux 是多人多工的作业系统, 这意谓 Linux 可以让多人同时使用, 更可以同时执行许多程式.</p>

<p>一般而言, 你所执行的指令会一直握着控制权, 一直到程式结束为止, 我们称为这样的执行工作是在前景工作(foreground jobs), 如果,
执行指令时, 你仍然可以再做其它的事情, 那我们就称它是在背景工作.</p>

<p>通常比较耗时间的工作, 我们会把它丢到背景去执行, 而这期间, 我们仍然可以和 shell 继续沟通, 下达其它命令给 shell 去执行.</p>

<p>例如: 我们想从中研院的 FTP 伺服器下载某一个目录中所有的档案, 但又不想等它执行完毕(因为这样耗时间,也很无聊), 可以用以下的方式来达成:</p>

<p>ncftp -R <a href="ftp://linux.sinica.edu.tw/pub1/redhat/powertools">ftp://linux.sinica.edu.tw/pub1/redhat/powertools</a> &amp;</p>

<p>其中 &amp; 这个符号便是将命令列丢到背景去执行的指令.</p>

<p>如果您想离线之後, 仍然令系统继续传档, 可以在前面再加一个 nohup 的指令, 如下:</p>

<p>nohup ncftp -R <a href="ftp://linux.sinica.edu.tw/pub1/redhat/powertools">ftp://linux.sinica.edu.tw/pub1/redhat/powertools</a> &amp;</p>

<p>nohup 是 no hangup 即不挂断之意.</p>

<p>八. 特殊字元及引号.</p>

<p>有许多字元, 对 shell 来说, 是具有特殊意义的. 详列於下:</p>

<p>符号 意义<br />
~ 自家目录<br />
` 命令取代</p>

<h1 id="解">解</h1>

<p>$ 变数取值<br />
&amp; 背景工作<br />
* 万用字元<br />
( 子shell开始<br />
) 子shell结束<br />
/ 使特殊字元恢复本意<br />
| 管线<br />
[ 字元组合开始<br />
] 字元组合结束<br />
{ 命令区块开始<br />
} 命令区块结束<br />
; 命令分隔号<br />
&rsquo; 单引号(不具变数置换的功能)<br />
&rdquo; 双引号(具置换的功能)<br />
&lt; 输入转向<br />
&gt; 输出转向<br />
/ 路径分隔号<br />
? 万用字元<br />
! 管线逻辑意义上的 NOT</p>

<p>九. 常用控制组合键.</p>

<p>我们在操作 Linux 时, 常会使用一些组合键来控制 shell 的活动.</p>

<p>详列如下:</p>

<p>组合键 意义<br />
Ctrl - C 中止目前的命令<br />
Ctrl - / 同上<br />
Ctrl - D 输入结束, 即 EOF 之意 (如使用 mail 信件结束时); 或 logout 登出 Linux<br />
Ctrl - Z 暂停目前的命令<br />
Ctrl - M 相当按 Enter<br />
Ctrl - S 暂停萤幕输出<br />
Ctrl - Q 恢复萤幕输出<br />
Ctrl - U 将命令列整列删除<br />
Ctrl - ? 删除最後一个字元, 相当於按 Del</p>

<p>十. 指令练习.</p>

<p>指令 选项或参数 意义<br />
ls<br />
pwd<br />
which<br />
more<br />
less<br />
passwd<br />
man<br />
cat<br />
touch<br />
cd<br />
mkdir<br />
rmdir<br />
cp<br />
rm<br />
head<br />
tail<br />
wc<br />
grep<br />
ps</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(2)教学例<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 09:04:01)<br />
&ldquo;Hello world&rdquo; Shell Script<br />
照传统程式教学例，这一节介绍Shell Script的&rdquo;Hello World&rdquo;如何撰写。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>#!/bin/sh</p>

<h1 id="filename-hello">Filename : hello</h1>

<p>echo &ldquo;Hello world!&rdquo;</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>大家应该会注意到第一行的&rdquo;#!/bin/sh&rdquo;。在UNIX下，所有的可执行Script，不管是那一种语言，其开头都是&rdquo;#!&ldquo;，例如Perl
是&rdquo;#!/usr/bin/perl&rdquo;，tcl/tk是&rdquo;#!/usr/bin/wish&rdquo;，看您要执行的Script程式位置在那里。您也可以用&rdquo;#!
/bin/bash&rdquo;、&rdquo;#!/bin/tcsh&rdquo;等等，来指定使用特定的Shell。<br />
echo是个bash的内建指令。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>接下来，执行hello这个script:<br />
要执行一个Script的方式有很多种。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>第一种 : 将hello这个档案的权限设定为可执行。<br />
[foxman@foxman bash]# chmod 755 hello<br />
执行<br />
[foxman@foxman bash]# ./hello<br />
hello world</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>第二种 : 使用bash内建指令&rdquo;source&rdquo;或&rdquo;.&ldquo;。<br />
[foxman@foxman bash]# source hello<br />
hello world<br />
或<br />
[foxman@foxman bash]# . hello<br />
hello world</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>第三种 : 直接使用sh/bash/tcsh指令来执行。<br />
[foxman@foxman bash]# sh hello<br />
hello world<br />
或<br />
[foxman@foxman bash]# bash hello<br />
hello world</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Bash执行选项</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>-c string : 读取string来当命令。<br />
-i : 互动介面。<br />
-s : 由stdin读取命令。<br />
- : 取消往後选项的读取。<br />
-norc : 不要读~/.bashrc来执行。<br />
-noprofile : 不要读/etc/profile、~/.bash_profile、~/.bash_login、~/.profile等等来执行。<br />
-rcfile filename : 执行filename，而非~/.bashrc<br />
-version : 显示版本。<br />
-quiet : 启动时不要哩唆。<br />
-login : 确保bash是个login shell。<br />
-nobraceexpansion : 不要用curly brace expansion({}符号展开)。<br />
-nolineediting : 不用readline来读取命令列。<br />
-posix : 改采Posix 1003.2标准。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>众所皆知地，UNIX上以小工具着名，利用许多简单的小工具，来完成原本需要大量软体开发的工作，这一点特色，使得UNIX成为许多人心目中理想的系统平台。<br />
在众多的小工具中，Shell
Script算得上是最基本、最强大、运用最广泛的一个。它运用围之广，不但从系统启动、程式编译、定期作业、上网连线，甚至安装整个Linux系统，都可以用它来完成。</p>

<p>因为Shell
Script是利用您平日在使用的一些指令，将之组合起来，成为一个&rdquo;程式&rdquo;。如果您平日某些序列的指令下得特别频繁，便可以将这些指令组合起来，成为另
一个新的指令。这样，不但可以简化并加速操作速度，甚至还可以乾脆自动定期执行，大大简化系统管理工作。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Bash(GNU Bourne-Again
SHell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等 等，Shell
Script大致都类同，当您学会一种Shell以後，其它的Shell会很快就上手，大多数的时候，一个Shell
Script通常可以在很多种Shell上使用。<br />
这里我介绍您bash的使用方法。事实上，当您&rdquo;man
bash&rdquo;时，就可以看到bash的说明书，不过对许多人来说，这份说明书犹如&rdquo;无字天书&rdquo;一样难懂。这份文件，主要资料来源为&rdquo;man
bash&rdquo;，我加上一些实际日常的应用例来说明。希望这样能让那些始终不得其门而入的人们，多多少少能有点概念。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(4)档案系统检查<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 11:00:00)<br />
系 统安全一向是大多数电脑用户关心的事，在UNIX系统中，最重视的事，即系统中有没有&rdquo;木马&rdquo;(Trojan horse)。不管Trojan
horse如何放进来的，有一点始终会不变，即被放置木马的档案，其档案日期一定会被改变，甚至会有其它的状态改变。此外，许多状况下，系统会多出一些不
知名的档案。因此，平日检查整个档案系统的状态是否有被改变，将所有状态有改变的档案，以及目前有那些程式正在执行，自动报告给系统管理员，是个避免坐
上&rdquo;木马&rdquo;的良方。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>#!/bin/sh</p>

<h1 id="filename-whatever-you-name-it">Filename : whatever_you_name_it</h1>

<p>DIRS=&ldquo;/etc /home /bin /sbin /usr/bin /usr/sbin /usr/local /var
/your_directory&rdquo;<br />
ADMIN=&ldquo;email@your.domain.com &rdquo;<br />
FROM=&ldquo;admin@your.domain.com &ldquo;</p>

<h1 id="写入sendmail的标头">写入Sendmail的标头</h1>

<p>echo &ldquo;Subject: $HOSTNAME filesystem check&rdquo; &gt; /tmp/today.mail<br />
echo &ldquo;From: $FROM&rdquo; &gt;&gt; /tmp/today.mail<br />
echo &ldquo;To: $ADMIN&rdquo; &gt;&gt; /tmp/today.mail<br />
echo &ldquo;This is filesystem report comes from $HOSTNAME&rdquo; &gt;&gt; /tmp/today.mail</p>

<h1 id="报告目前正在执行的程式">报告目前正在执行的程式</h1>

<p>ps axf &gt;&gt; /tmp/today.mail</p>

<h1 id="档案系统检查">档案系统检查</h1>

<p>echo &ldquo;File System Check&rdquo; &gt;&gt; /tmp/today.mail<br />
ls -alR $DIRS | gzip -9 &gt; /tmp/today.gz<br />
zdiff /tmp/today.gz /tmp/yesterday.gz &gt;&gt; /tmp/today.mail<br />
mv -f /tmp/today.gz /tmp/yesterday.gz</p>

<h1 id="寄出信件">寄出信件</h1>

<p>sendmail -t &lt; /tmp/today.mail</p>

<p>然後把它放到一个不显眼的地方去，让别人找不到。</p>

<p>把它加入crontab中。</p>

<p>30 7 * * * /full_check_script_path/whatever_you_name_it 1&gt; /dev/null 2&gt;
/dev/null #上班前检查</p>

<p>有些档案是固定会更动的，像/var/log/messages、/var/log/syslog、/dev/ttyX等等，不要太大惊小怪。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(5)控制圈for<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 12:10:00)</p>

<p>示了几个简单的Shell Script，相信您应该对Shell Script有点概念了。现在我们开始来仔细研究一些较高等的Shell
Script写作。一些进一步的说明，例如&rdquo;$&ldquo;、&rdquo;&gt;&ldquo;、&rdquo;&gt;&ldquo;、&rdquo;1&gt;&ldquo;、&rdquo;2&gt;&ldquo;符号的使用，会在 稍後解释。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>for name [ in word; ] do list ; done<br />
控制圈。<br />
word是一序列的字，for会将word中的个别字展开，然後设定到name上面。list是一序列的工作。如果[in
word;]省略掉，那麽name将会被设定为Script後面所加的参数。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例一:<br />
#!/bin/sh</p>

<p>for i in a b c d e f ; do<br />
echo $i<br />
done</p>

<p>它将会显示出a到f。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例二: 另一种用法，A-Z<br />
#!/bin/sh<br />
WORD=&ldquo;a b c d e f g h i j l m n o p q r s t u v w x y z&rdquo;</p>

<p>for i in $WORD ; do<br />
echo $i<br />
done</p>

<p>这个Script将会显示a到z。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例三 : 修改副档名<br />
如果您有许多的.txt档想要改名成.doc档，您不需要一个一个来。<br />
#!/bin/sh</p>

<p>FILES=<code>ls /txt/*.txt</code></p>

<p>for txt in $FILES ; do<br />
doc=<code>echo $txt | sed &quot;s/.txt/.doc/&quot;</code><br />
mv $txt $doc<br />
done</p>

<p>这样可以将<em>.txt档修改成</em>.doc档。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例四 : meow<br />
#!/bin/sh</p>

<h1 id="filename-meow">Filename : meow</h1>

<p>for i ; do<br />
cat $i<br />
done</p>

<p>当您输入&rdquo;meow file1 file2 &hellip;&ldquo;时，其作用就跟&rdquo;cat file1 file2 &hellip;&ldquo;一样。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例五 : listbin<br />
#!/bin/sh</p>

<h1 id="filename-listbin">Filename : listbin</h1>

<p>for i in /bin/* ; do<br />
echo $i<br />
done</p>

<p>当您输入&rdquo;listbin&rdquo;时，其作用就跟&rdquo;ls /bin/*&ldquo;一样。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例六 : /etc/rc.d/rc<br />
拿一个实际的例来说，Red Hat的/etc/rc.d/rc的启动程式中的一个片断。</p>

<p>for i in /etc/rc.d/rc$runlevel.d/S*; do</p>

<h1 id="check-if-the-script-is-there">Check if the script is there.</h1>

<p>[ ! -f $i ] &amp;&amp; continue</p>

<h1 id="check-if-the-subsystem-is-already-up">Check if the subsystem is already up.</h1>

<p>subsys=${i#/etc/rc.d/rc$runlevel.d/S??}<br />
[ -f /var/lock/subsys/$subsys ] || /<br />
[ -f /var/lock/subsys/${subsys}.init ] &amp;&amp; continue</p>

<h1 id="bring-the-subsystem-up">Bring the subsystem up.</h1>

<p>$i start<br />
done</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(6)流程控制case<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 13:04:01)<br />
case word in [ pattern [ | pattern ] &hellip; ) list ;; ] &hellip; esac<br />
case/esac的标准用法大致如下:<br />
case $arg in<br />
pattern | sample) # arg in pattern or sample<br />
;;<br />
pattern1) # arg in pattern1<br />
;;<br />
*) #default<br />
;;<br />
esac<br />
arg是您所引入的参数，如果arg内容符合pattern项目的话，那麽便会执行pattern以下的程式码，而该段程式码则以两个分号&rdquo;;;&ldquo;做结尾。</p>

<p>可以注意到&rdquo;case&rdquo;及&rdquo;esac&rdquo;是对称的，如果记不起来的话，把&rdquo;case&rdquo;颠倒过来即可。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例一 : paranoia<br />
#!/bin/sh<br />
case $1 in<br />
start | begin)<br />
echo &ldquo;start something&rdquo;<br />
;;<br />
stop | end)<br />
echo &ldquo;stop something&rdquo;<br />
;;<br />
*)<br />
echo &ldquo;Ignorant&rdquo;<br />
;;<br />
esac</p>

<p>执行<br />
[foxman@foxman bash]# chmod 755 paranoia<br />
[foxman@foxman bash]# ./paranoia<br />
Ignorant<br />
[foxman@foxman bash]# ./paranoia start<br />
start something<br />
[foxman@foxman bash]# ./paranoia begin<br />
start something<br />
[foxman@foxman bash]# ./paranoia stop<br />
stop something<br />
[foxman@foxman bash]# ./paranoia end<br />
stop something</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例二 : inetpanel<br />
许多的daemon都会附上一个管理用的Shell Script，像BIND就附上ndc，Apache就附上apachectl。这些管理程式都是用shell
script来写的，以下示一个管理inetd的shell script。<br />
#!/bin/sh</p>

<p>case $1 in<br />
start | begin | commence)<br />
/usr/sbin/inetd<br />
;;<br />
stop | end | destroy)<br />
killall inetd<br />
;;<br />
restart | again)<br />
killall -HUP inetd<br />
;;<br />
*)<br />
echo &ldquo;usage: inetpanel [start | begin | commence | stop | end | destory |
restart | again]&rdquo;<br />
;;<br />
esac</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>例三 : 判断系统<br />
有时候，您所写的Script可能会跨越好几种平台，如Linux、FreeBSD、Solaris等等，而各平台之间，多多少少都有不同之处，有时候需要判断目前正在那一种平台上执行。此时，我们可以利用uname来找出系统资讯。<br />
#!/bin/sh</p>

<p>SYSTEM=<code>uname -s</code></p>

<p>case $SYSTEM in<br />
Linux)<br />
echo &ldquo;My system is Linux&rdquo;<br />
echo &ldquo;Do Linux stuff here&hellip;&rdquo;<br />
;;<br />
FreeBSD)<br />
echo &ldquo;My system is FreeBSD&rdquo;<br />
echo &ldquo;Do FreeBSD stuff here&hellip;&rdquo;<br />
;;<br />
*)<br />
echo &ldquo;Unknown system : $SYSTEM&rdquo;<br />
echo &ldquo;I don&rsquo;t what to do&hellip;&rdquo;<br />
;;<br />
esac</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(7)流程控制select<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 14:08:00)<br />
select name [ in word; ] do list ; done<br />
select顾名思义就是在word中选择一项。与for相同，如果[in word;]省略，将会使用Script後面所加的参数。<br />
例<br />
#!/bin/sh<br />
WORD=&ldquo;a b c&rdquo;</p>

<p>select i in $WORD ; do<br />
case $i in<br />
a)<br />
echo &ldquo;I am A&rdquo;<br />
;;<br />
b)<br />
echo &ldquo;I am B&rdquo;<br />
;;<br />
c)<br />
echo &ldquo;I am C&rdquo;<br />
;;<br />
*)<br />
break;<br />
;;<br />
esac<br />
done</p>

<p>执行结果<br />
[foxman@foxman bash]# ./select_demo<br />
1) a<br />
2) b<br />
3) c<br />
#? 1<br />
I am A<br />
1) a<br />
2) b<br />
3) c<br />
#? 2<br />
I am B<br />
1) a<br />
2) b<br />
3) c<br />
#? 3<br />
I am C<br />
1) a<br />
2) b<br />
3) c<br />
#? 4</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(8)返回状态Exit<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 15:00:00)<br />
在继续下去之前，我们必须要切入另一个话题，即返回状态值 - Exit Status。因为if/while/until都迁涉到了使用Exit
Status来控制程式流程的问题。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>许多人都知道，在许多语言中(C/C++/Perl&hellip;.)，都有一个exit的函数，甚至连Bash自己都有个exit的内建命令。而exit後面所带的数字，便是返回状态值
- Exit Status。<br />
返回状态值可以使得程式与程式之间，利用Shell script来结合的可能性大增，利用小程式，透过Shell script，来完成很杂的工作。</p>

<p>在shell中，返回值为零表示成功(True)，非零值为失败(False)。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>举例来说，以下这个两个小程式yes/no分别会返回0/1(成功/失败):<br />
/* yes.c <em>/<br />
void main(void) { exit(0); }<br />
/</em> no.c */<br />
void main(void) { exit(1); }<br />
那麽以下这个&rdquo;YES&rdquo;的shell script便会显示&rdquo;YES&rdquo;。<br />
#!/bin/sh</p>

<h1 id="yes">YES</h1>

<p>if yes ; then<br />
echo &ldquo;YES&rdquo;<br />
fi<br />
而&rdquo;NO&rdquo;不会显示任何东西。<br />
#!/bin/sh</p>

<h1 id="no">NO</h1>

<p>if no ; then<br />
echo &ldquo;YES&rdquo;<br />
fi</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>test express<br />
[ express ]<br />
在Shell script中，test express/[ express ]这个语法被大量地使用，它是个非常实用的指令。由於它的返回值即Exit
Status，经常被运用在if/while/until的场合中。而在後面，我们也会大量运用到，在进入介绍if/while/until之前，有必要 先解一下。</p>

<p>其返回值为0(True)或1(False)，要看表述(express)的结果为何。</p>

<p>express格式</p>

<p>-b file : 当档案存在并且属性是Block special(通常是/dev/xxx)时，返回True。<br />
-c file : 当档案存在并且属性是character special(通常是/dev/xxx)时，返回True。<br />
-d file : 当档案存在并且属性是目录时，返回True。<br />
-e file : 当档案存在时，返回True。<br />
-f file : 当档案存在并且是正常档案时，返回True。<br />
-g file : 当档案存在并且是set-group-id时，返回True。<br />
-k file : 当档案存在并且有&rdquo;sticky&rdquo; bit被设定时，返回True。<br />
-L file : 当档案存在并且是symbolic link时，返回True。<br />
-p file : 当档案存在并且是name pipe时，返回True。<br />
-r file : 当档案存在并且可读取时，返回True。<br />
-s file : 当档案存在并且档案大小大於零时，返回True。<br />
-S file : 当档案存在并且是socket时，返回True。<br />
-t fd : 当fd被开启为terminal时，返回True。<br />
-u file : 当档案存在并且set-user-id bit被设定时，返回True。<br />
-w file : 当档案存在并且可写入时，返回True。<br />
-x file : 当档案存在并且可执行时，返回True。<br />
-O file : 当档案存在并且是被执行的user id所拥有时，返回True。<br />
-G file : 当档案存在并且是被执行的group id所拥有时，返回True。<br />
file1 -nt file2 : 当file1比file2新时(根据修改时间)，返回True。<br />
file1 -ot file2 : 当file1比file2旧时(根据修改时间)，返回True。<br />
file1 -ef file2 : 当file1与file2有相同的device及inode number时，返回True。<br />
-z string : 当string的长度为零时，返回True。<br />
-n string : 当string的长度不为零时，返回True。<br />
string1 = string2 : string1与string2相等时，返回True。<br />
string1 != string2 : string1与string2不相等时，返回True。<br />
! express : express为False时，返回True。<br />
expr1 -a expr2 : expr1及expr2为True。<br />
expr1 -o expr2 : expr1或expr2其中之一为True。<br />
arg1 OP arg2 : OP是-eq[equal]、-ne[not-equal]、-lt[less-than]、-le[less-than-or-
equal]、 -gt[greater-than]、-ge[greater-than-or-equal]的其中之一。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>在Bash中，当错误发生在致命信号时，bash会返回128+signal
number做为返回值。如果找不到命令，将会返回127。如果命令找到了，但该命令是不可执行的，将返回126。除此以外，Bash本身会返回最後一个
指令的返回值。若是执行中发生错误，将会返回一个非零的值。<br />
Fatal Signal : 128 + signo<br />
Can&rsquo;t not find command : 127<br />
Can&rsquo;t not execute : 126<br />
Shell script successfully executed : return the last command exit status<br />
Fatal during execution : return non-zero</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(9)流程控制if<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 16:10:00)</p>

<p>if list then list [ elif list then list ] &hellip; [ else list ] fi<br />
几种可能的写法</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>第一种<br />
if list then<br />
do something here<br />
fi<br />
当list表述返回值为True(0)时，将会执行&rdquo;do something here&rdquo;。</p>

<p>例一 : 当我们要执行一个命令或程式之前，有时候需要检查该命令是否存在，然後才执行。<br />
if [ -x /sbin/quotaon ] ; then<br />
echo &ldquo;Turning on Quota for root filesystem&rdquo;<br />
/sbin/quotaon /<br />
fi</p>

<p>例二 : 当我们将某个档案做为设定档时，可先检查是否存在，然後将该档案设定值载入。</p>

<h1 id="filename-etc-ppp-settings">Filename : /etc/ppp/settings</h1>

<p>PHONE=1-800-COLLECT</p>

<p>#!/bin/sh</p>

<h1 id="filename-phonebill">Filename : phonebill</h1>

<p>if [ -f /etc/ppp/settings ] ; then<br />
source /etc/ppp/settings<br />
echo $PHONE<br />
fi<br />
执行<br />
[foxman@foxman ppp]# ./phonebill<br />
1-800-COLLECT</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>第二种<br />
if list then<br />
do something here<br />
else<br />
do something else here<br />
fi<br />
例三 : Hostname<br />
#!/bin/sh<br />
if [ -f /etc/HOSTNAME ] ; then<br />
HOSTNAME=<code>cat /etc/HOSTNAME</code><br />
else<br />
HOSTNAME=localhost<br />
fi</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>第三种<br />
if list then<br />
do something here<br />
elif list then<br />
do another thing here<br />
fi<br />
例四 : 如果某个设定档允许有好几个位置的话，例如crontab，可利用if then elif fi来找寻。<br />
#!/bin/sh</p>

<p>if [ -f /etc/crontab ] ; then<br />
CRONTAB=&ldquo;/etc/crontab&rdquo;<br />
elif [ -f /var/spool/cron/crontabs/root ] ; then<br />
CRONTAB=&ldquo;/var/spool/cron/crontabs/root&rdquo;<br />
elif [ -f /var/cron/tabs/root ] ; then<br />
CRONTAB=&ldquo;/var/cron/tabs/root&rdquo;<br />
fi<br />
export CRONTAB</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>第四种<br />
if list then<br />
do something here<br />
elif list then<br />
do another thing here<br />
else<br />
do something else here<br />
fi<br />
例五 : 我们可利用uname来判断目前系统，并分别做各系统状况不同的事。<br />
#!/bin/sh</p>

<p>SYSTEM=<code>uname -s</code></p>

<p>if [ $SYSTEM = &ldquo;Linux&rdquo; ] ; then<br />
echo &ldquo;Linux&rdquo;<br />
elif [ $SYSTEM = &ldquo;FreeBSD&rdquo; ] ; then<br />
echo &ldquo;FreeBSD&rdquo;<br />
elif [ $SYSTEM = &ldquo;Solaris&rdquo; ] ; then<br />
echo &ldquo;Solaris&rdquo;<br />
else<br />
echo &ldquo;What?&rdquo;<br />
fi</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(10)控制圈while/until<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 17:04:01)<br />
while list do list done<br />
当list为True时，该圈会不停地执行。<br />
例一 : 无限回圈写法<br />
#!/bin/sh</p>

<p>while : ; do<br />
echo &ldquo;do something forever here&rdquo;<br />
sleep 5<br />
done</p>

<p>例二 : 强迫把pppd杀掉。<br />
#!/bin/sh</p>

<p>while [ -f /var/run/ppp0.pid ] ; do<br />
killall pppd<br />
done</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>until list do list done<br />
当list为False(non-zero)时，该圈会不停地执行。<br />
例一 : 等待pppd上线。<br />
#!/bin/sh<br />
until [ -f /var/run/ppp0.pid ] ; do<br />
sleep 1<br />
done</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(11)参数与变数<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 18:08:00)<br />
在继续下去介绍function之前，我们必须停下来介绍&rdquo;参数与变数&rdquo;。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>参数(Parameters)是用来储存&rdquo;值&rdquo;的资料型态，有点像是一般语言中的变数。它可以是个名称(name)、数字(number)、或者是以下所列出来一些特殊符号(Special
Parameters)。<br />
在shell中，变数是由name形式的参数所构成的。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>在前面的许多例中，我们事实上已经看到许多参数的运用。要设定一个Parameter实际很简单:<br />
name=value</p>

<p>例如说:</p>

<p>MYHOST=&ldquo;foxman&rdquo;</p>

<p>而要使用它时，则是加个&rdquo;$&ldquo;符号。</p>

<p>echo $MYHOST</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>位置参数(Positional Parameters)</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>所谓的位置参数便是0,1,2,3,4,5,6,7,8,9&hellip;。使用时，用$0,$1,$2&hellip;。<br />
位置参数是当script被载入时，後面所附加的参数。$0是本身，$1则为第一个参数，$2为第二个，依此类推。而当Positional
Parameters被function所使用时，它们会被暂时取代(下一节会介绍function)。</p>

<p>例如以下这个script:<br />
#!/bin/sh</p>

<h1 id="filename-position">Filename : position</h1>

<p>echo $0<br />
echo $1</p>

<p>执行时:<br />
[foxman@foxman bash]# ./position abc<br />
./position<br />
abc</p>

<p>当位置参数超过两位数时，有特别的方法来展开，称为Expansion。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>特殊参数(Speical Parameters)<br />
这些符号，非常不人性，对新手来说很困扰。但上手後，会觉得方便无比，有些如果您看不懂的话，就&ndash;算了，不用浪费太多时间在上面。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<ul>
<li><p>星号<br />
将Positional Parameters合成一个参数，其间隔为IFS内定参数的第一个字元(见内建变数一节)。<br />
例:<br />
#!/bin/sh</p>

<h1 id="starsig">starsig</h1>

<p>echo $*</p></li>
</ul>

<p>执行:<br />
[foxman@foxman bash]# starsig a b c d e f g<br />
a b c d e f g</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>@ at符号<br />
与*星号类同。不同之处在於不参照IFS。</p>

<p>例:<br />
#!/bin/sh</p>

<h1 id="atsig">atsig</h1>

<p>echo $@</p>

<p>执行:<br />
[foxman@foxman bash]# atsig a b c d e f g<br />
a b c d e f g</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<h1 id="井字号">井字号</h1>

<p>展开Positional parameters的数量。</p>

<p>例:<br />
#!/bin/sh</p>

<h1 id="poundsig">poundsig</h1>

<p>echo $#</p>

<p>执行<br />
[foxman@foxman bash]# poundsig a b c d e f g<br />
7</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>? 问号<br />
最近执行的foreground pipeline的状态。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>- 减号<br />
最近执行的foreground pipeline的选项参数。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>$ 钱钱钱<br />
本身的Process ID。</p>

<p>[foxman@foxman bash]# ps ax | grep bash<br />
1635 p1 S 0:00 /bin/bash</p>

<p>[foxman@foxman bash]# echo $$<br />
1635</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>! 惊号<br />
最近执行背景命令的Process ID。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>0 零<br />
在Positional Parameters一部份已经说明过了，是执行的shell script本身。但如果是用&rdquo;bash -c&rdquo;，则$0被设为第一个参数。</p>

<p>[foxman@foxman bash]# echo $0<br />
/bin/bash</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>_ 底线符号<br />
显示出最後一个执行的命令。</p>

<p>[foxman@foxman bash]# echo $_<br />
bash</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>内建变数(Shell Variables)<br />
Bash有许多内建变数，像PATH、HOME、ENV&hellip;&hellip;等等。这些内建变数将在另一节中，专门一一说明。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(12)函数function<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 19:00:00)<br />
[ function ] name () { list; }<br />
function的参数是Positional Paraments。</p>

<p>例<br />
#!/bin/sh</p>

<p>function func() {<br />
echo $1<br />
echo $2<br />
return 1<br />
}</p>

<p>func &ldquo;Hello&rdquo; &ldquo;function&rdquo;</p>

<p>局部变数可用local来宣告。</p>

<p>函数可export，使用下一层的shell可以使用。</p>

<p>函数可递，没有递层数的限制。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(13)Bash内建指令集<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 20:10:00)<br />
Bash内建指令集<br />
以下的命令，大部份都没有使用例，您可能会看不出所以然，摸不着头脑。在我加入例说明前，建议您&rdquo;man bash&rdquo;，然後自己实际操作一次。</p>

<dl>
<dt>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</dt>
<dd><p>[arguments]<br />
不做任何事，除了[arguments]一些参数展开及一些特定重导向的作业外。</p></dd>
</dl>

<p>永远返回零。它的用法跟true一样。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>. filename [arguments]<br />
source filename [arguments]<br />
由filename中读取命令，并执行。<br />
您会在/etc/rc.d/*中发现很多<br />
. /xxxx<br />
的指令，而xxxx的permission都不是可执行的。事实上，在tcsh中，需要用<br />
source /xxxx<br />
来做同样的指令。<br />
注意到&rdquo;.&ldquo;的後面是有空格的(比较一下&rdquo;. /&ldquo;跟&rdquo;./&ldquo;，不一样)。filename是内含指令的纯文字档即可，无须chmod 755 filename。</p>

<p>例<br />
filename : my_source<br />
DEV=lo<br />
IP=127.0.0.1<br />
NETMASK=255.0.0.0<br />
BROADCAST=127.255.255.255</p>

<p>ifconfig $IP netmask $NETMASK broadcast $BROADCAST dev $DEV</p>

<p>接下来<br />
. my_source<br />
或<br />
source my_source</p>

<p>便可执行该script，而不需要&rdquo;chmod 755 my_source&rdquo;</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>alias [name[=value] &hellip;]<br />
昵称命令<br />
例如您如果来自DOS的世界，对UNIX的指令不习惯，可用alias来修改，以符合您的习惯。</p>

<p>例<br />
alias ls=&ldquo;ls &ndash;color&rdquo;<br />
alias dir=&ldquo;ls&rdquo;<br />
alias cd..=&ldquo;cd ..&rdquo;<br />
alias copy=&ldquo;cp -f&rdquo; # dangerous, recommend, &ldquo;cp -i&rdquo;<br />
alias del=&ldquo;rm -f&rdquo; # dangerous, recommend, &ldquo;rm -i&rdquo;<br />
alias move=&ldquo;mv -f&rdquo; # dangerous, recommend, &ldquo;mv -i&rdquo;<br />
alias md=&ldquo;mkdir&rdquo;<br />
alias rd=&ldquo;rmdir&rdquo;</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>unalias [-a] [name &hellip;]<br />
unalias取消alias的设定。&rdquo;unalias -a&rdquo;将全部alias取消。</p>

<p>例<br />
unalias copy</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>bg [jobspec]<br />
将指定任务放到背景中，如果jobspec未指定，内定为目前的。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>fg [jobspec]<br />
将指定任务放到前景中，如果jobsepc没有指定，那麽内定为目前的。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>jobs [-lnp] [ jobspec &hellip; ]<br />
第一种形式列出目前正在工作的任务。<br />
-l : 除了列出一般资讯外，还列出Process IDs。<br />
-p : 仅列出该工作群&rdquo;首脑&rdquo;(Process group leader)的Process ID.<br />
-n : 则仅列出有改变的jobs的状态。<br />
如果给定jobspec，输出资讯则只有该jobspec。</p>

<p>返回值为零，除非有非法的选项发生。</p>

<p>jobs -x command [ args &hellip; ]</p>

<p>如果使用第二种形式(-x)，jobs取代指定的command及args，并执行返回其Exit Status。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>kill [-s sigspec | -sigspec] [pid | jobspec] &hellip;<br />
将sigspec的信号送到pid或jobspec。<br />
sigspec可以是SIGKILL/KILL这种形式或是信号号码。如果sigspec是signal name，则大小写无关，而且可以没有SIG。<br />
kill -l [signum]<br />
列出信号名称。</p>

<p>[foxman@foxman bash]# kill -l<br />
1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL<br />
5) SIGTRAP 6) SIGIOT 7) SIGBUS 8) SIGFPE<br />
9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2<br />
13) SIGPIPE 14) SIGALRM 15) SIGTERM 17) SIGCHLD<br />
18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN<br />
22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ<br />
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO<br />
30) SIGPWR</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>wait [n]<br />
等待指定的行程，并返回其结束状态。n可以是个jobspec或Process
ID。如果n未指定，则等待所有的子行程，及返回值为零。若n为不存在的job或process，则返回127。否则，返回值为最後一个job/process的Exit
Status。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>bind [-m keymap] [-lvd] [-q name]<br />
bind [-m keymap] -f filename<br />
bind [-m keymap] keyseq:function-name<br />
显示出目前readline的按键及链结函数设定或是巨集。</p>

<p>-m keymap : 设定keymap binding。<br />
-l : 显示出所有readline function的名称。<br />
-v : 显示出目前的function name及bindings。<br />
-d : 显示出function name及bindings。<br />
-f filename : 从filename读取key bindings。<br />
-q function : 询问那个按键触发function。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>break [n]<br />
跳出控制回圈for/while/until中使用。如果有指定n，则跳出n层。n必须是大於等於1。若n大於巢状圈数，则所有的圈都会跳离。返回值回零。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>continue [n]<br />
还原控制回圈for/while/until中使用。如果有指定n，则返回n层。n必须是大於等於1。若n大於巢状圈数，则还原到最上层。返回值回零。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>exit [n]<br />
离开程式。n是Exit Status。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>return [n]<br />
在function中使用。n为返回值，其作用与Exit Status一样。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>builtin shell-builtin [arguments]<br />
执行内建函数。当您定义了与内建函数相同的指令时，可用此命令来执行内建函数。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>cd [dir]<br />
更换目录到dir。如果没有指定，内定为HOME所指定的目录。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>command [-pVv] command [arg &hellip;]<br />
用command指定可取消正常的shell
function寻找。只有内建命令及在PATH中找得到的才会被执行。&rdquo;-p&rdquo;选项，搜寻命令的方式是用PATH来找。&rdquo;-V&rdquo;或&rdquo;-v&rdquo;选项，会显示出该命令的一些简约描述。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>declare [-frxi] [name[=value]]<br />
typeset [-frxi] [name[=value]]<br />
宣告参数并给它们设定属性。如果没有给定名称，将会显示各参数值。</p>

<p>-f : 仅使用函数名称。<br />
-r : 将name设为readonly。<br />
-x : 将name输出给後续环境使用。<br />
-i : 该参数被设为integer来使用，可用於算术表述。</p>

<p>用&rdquo;+&ldquo;时，关闭该属性。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>dirs [-l] [+/-n]<br />
显示目前记忆的目录。目录可透过pushd/popd来操作。</p>

<p>+n : 显示开始的记录n个。<br />
-n : 显示结尾的记录n个。<br />
-l : 显示较多的资讯。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>echo [-neE] [arg &hellip;]<br />
输出显示args，由空白分隔。返回值永为零。</p>

<p>-n : 不跳行。<br />
-e : 启动&rdquo;/&ldquo;符号的解译。<br />
-E : 将ESC解译功能取消。</p>

<p>&rdquo;/a&rdquo; : alert(bell)，发出声响。<br />
&rdquo;/b&rdquo; : backspace，倒退。<br />
&rdquo;/c&rdquo; : suppress trailing newline，不跳行。<br />
&rdquo;/f&rdquo; : form feed，跳行跳格。<br />
&rdquo;/n&rdquo; : new line，新行。<br />
&rdquo;/r&rdquo; : carriage return，回到行起点。<br />
&rdquo;/t&rdquo; : horizontal tab，水平跳位。<br />
&rdquo;/v&rdquo; : vertical tab，垂直跳位。<br />
&rdquo;//&rdquo; : 输出&rdquo;/&ldquo;。<br />
&rdquo;/nnn&rdquo; : 输出ASCII Code号码nnn(八进位)。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>enable [-n] [-all] [name &hellip;]<br />
启动或关闭内建函数命令。使用&rdquo;-n&rdquo;将所有指定命令皆关闭，否则都是启动的。如果只有&rdquo;-n&rdquo;参数，它将会显示所有关闭的函数。如果只有&rdquo;-all&rdquo;，它将会显示所有内建命令。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>eval [arg &hellip;]<br />
读取args，并将args合为一个命令，然後执行。其返回值成为eval的返回值。如果没有参数，eval返回True。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>exec [[-] command [arguments]]<br />
当命令执行时，该命令取代shell，没有新的process产生。如果第一个参数是&rdquo;-&ldquo;，shell会将&rdquo;-&ldquo;放入第零个参数，传给command。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>export [-nf] [name[=word]] &hellip;<br />
export -p<br />
将name输出给环境，给往後的命令使用。&rdquo;-f&rdquo;选项表示name是函数。&rdquo;-p&rdquo;显示出所有export的名称。&rdquo;-n&rdquo;移除name。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>set [&ndash;abefhkmnptuvxldCHP] [-o option] [arg &hellip;]<br />
-a : 自动将变数标记为可让後面环境所使用。<br />
-b : 立即报告被终结的背景程式状态。<br />
-e : 当命令(simple-command，见後面)返回非零值时，立即跳出。<br />
-f : 取消pathname expansion。<br />
-h : 找出所记忆的函数命令位置。<br />
-k : 所有keyword参数都放到环境中。<br />
-m : 监督模式。<br />
-n : 读取命令，但不要执行。可用於语法检查。<br />
-p : 打开privileged模式。<br />
-t : 当读取一个命令并执行後，立即离开。<br />
-u : 当参数展开时，把unset参数当成是错误。<br />
-v : 列出shell input lines。<br />
-x : 在展开每个simple-command後，bash显示展开值在PS4上。<br />
-l : 储存并还原name binding在for语法中。<br />
-d : 关闭hasing command搜寻。<br />
-C : 跟<code>noclobber=</code>一样。请见内定参数一节。<br />
-H : 启动! style history substitution。<br />
-P : 在使用像cd这种指令时，不要跟随symbolic links。<br />
-- : &ldquo;&ndash;&ldquo;之後，没有参数跟在後面。<br />
- : 指定将所有後面的参数当成是位置参数。<br />
-o option-name : option-name可以是以下之一<br />
allexport : 与&rdquo;-a&rdquo;相同。<br />
braceexpand : 启动Brace Expansion。这是内定设定。<br />
emacs : 使用emacs-style命令列编辑界面。<br />
errexit : 与&rdquo;-e&rdquo;相同。<br />
histexpand : 与&rdquo;-H&rdquo;相同。<br />
ignoreeof : 效果跟<code>IGNOREEOF=10</code>一样。<br />
interactive-commands : 允许#做为解。<br />
monitor : 与&rdquo;-m&rdquo;相同。<br />
noclobber : 与&rdquo;-C&rdquo;相同。<br />
noexec : 与&rdquo;-n&rdquo;相同。<br />
noglob : 与&rdquo;-f&rdquo;相同。<br />
nohash : 与&rdquo;-d&rdquo;相同。<br />
notify : 与&rdquo;-b&rdquo;相同。<br />
nounset : 与&rdquo;-u&rdquo;相同。<br />
physical : 与&rdquo;-P&rdquo;相同。<br />
posix : Bash行为修改为Posix 1003.2标准。<br />
privileged : 与&rdquo;-p&rdquo;相同。<br />
verbose : 与&rdquo;-v&rdquo;相同。<br />
vi : 使用vi-style命令列编辑程式。<br />
xtrace : 与&rdquo;-x&rdquo;相同。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>unset [-fv] [name &hellip;]<br />
移除对映於name的参数。要注意PATH、IFS、PPID、PS1、PS2、UID、
EUID不能unset。若RANDOM、SECONDS、LINENO、HISTCMD被unset，它们会丧失原有意义，既始它们後来被重设也一样。
返回值为True，除非name是不能被unset的。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>fc [-e ename] [-nlr] [first] [last]<br />
fc -s [pat=rep] [cmd]<br />
修正命令。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>getopts optstring name [args]<br />
解析位置参数。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>hash [-r] [name]<br />
对每个name命令的完整路径记录下来。&rdquo;-r&rdquo;选项强迫忘记所有命令位置。如果没有给参数，则将会印出所有的资讯。返回值为True。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>help [pattern]<br />
显示协助资讯。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>history [n]<br />
history -rwan [filename]<br />
没有参数时，会显示所下命令的历史记录。带有参数&rdquo;n&rdquo;则显示最後n个。</p>

<p>其它参数如下:<br />
-a : 新增&rdquo;新历史&rdquo;到历史档中。<br />
-n : 读取尚未读到历史中的记录。<br />
-r : 读取filename做为历史档，并用它为目前历史记录。<br />
-w : 将现有历史记录写到filename中。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>let arg [arg &hellip;]<br />
算术表述。请参考算术表述一节。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>local [name[=value] &hellip;]<br />
产生一个局部参数。如果用於function，则其作用围在function内及其子函数。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>logout<br />
离开login shell。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>popd [+/-n]<br />
移除目录堆叠。&rdquo;+n&rdquo;移除上面n个，&rdquo;-n&rdquo;移除下面n个。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>pushd [dir]<br />
pushd +/-n<br />
将目录新增到目录堆叠的最上面。&rdquo;+n&rdquo;旋转该堆叠，使第n个目录变成最上面。&rdquo;-n&rdquo;旋转该堆叠，使倒数第n个目录变成最上面。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>pwd<br />
列出目前工作目录的绝对路径。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>read [-r] [name &hellip;]<br />
读进一行，然後第一个字设到第一个name，第二个设到第二个name，依此类推。如果没有name在参数中，则read会将值设到REPLY。返回值为零，除非遇到End-
Of-File。若有&rdquo;-r&rdquo;选项，则&rdquo;/n&rdquo;被考虑为该行的一部份。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>readonly [-f] [name &hellip;]<br />
readonly -p<br />
将给定的name标记为readonly。如果是&rdquo;-f&rdquo;选项，则函数也一样被标记为readonly。&rdquo;-p&rdquo;会列出所有readonly的name。&rdquo;&ndash;&ldquo;取消检查剩馀的参数。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>shift [n]<br />
Positional
Parameters从n+1&hellip;开始，会被改为$1&hellip;。n若为零，则没有改变。n若未给定，则内定为1。n必须是非负数，并且小於或等於$#。若n大於$#，则没有改变。返回值为零，除非n大於$#或小於零。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>suspend [-f]<br />
暂停这个shell的执行，直到它收到SIGCONT信号。&rdquo;-f&rdquo;选项则是叫login
shell不要抱怨，不过还是一样暂停。返回状态零，除非该shell是个login shell，而且没有&rdquo;-f&rdquo;选项。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>test expr<br />
[ expr ]<br />
我们在Exit Status的部份已经说过了，不再重。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>times<br />
列出该shell的累积的使用者及系统时间及从shell执行的process时间，返回值为零。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>trap [-l] [arg] [sigspec]<br />
当收到sigspec信号时，执行arg命令。&rdquo;-l&rdquo;显示出信号名称及号码。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>type [-all] [-type | -path] name [name &hellip;]<br />
没有参数的状况下，它会显示出shell如何
解译name做为命令。如果有&rdquo;-type&rdquo;，它将会显示alias、keyword、function、builtin或file。如果
有&rdquo;-path&rdquo;的参数，它将会显示该命令的路径，找不到的话，不显示任何东西。如果有&rdquo;-all&rdquo;的参数，它将会显示所有可执行name的可能路径。
type接受&rdquo;-a&rdquo;、&rdquo;-t&rdquo;、&rdquo;-p&rdquo;做为缩写。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>ulimit [-SHacdfmstpnuv [limit]]<br />
ulimit提供了对shell的可获取资源控制的功能。</p>

<p>-a : 报告目前所有限制。<br />
-c : 设定最大可产生的core档案。<br />
-d : 行程资料段(process&rsquo;s data segment)最大值。<br />
-f : 可被这个shell产生的最大档案。<br />
-m : resident set size最大值。<br />
-s : 堆叠最大值。<br />
-t : CPU TIME最大值(以秒计算)。<br />
-p : pipe size in 512-byte blocks的最大值。<br />
-n : 可开启的file descriptors最大值。<br />
-u : 单一使用者可使用的最大process数。<br />
-v : 该shell最大虚拟记忆体可用值。</p>

<p>所有项目是以1024做为单位。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(14)Bash内建参数<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 21:04:01)</p>

<p>PPID : 该bash的呼叫者process ID.<br />
PWD : 目前的工作目录。</p>

<p>OLDPWD : 上一个工作目录。</p>

<p>REPLY : 当read命令没有参数时，直接设在REPLY上。</p>

<p>UID : User ID。</p>

<p>EUID : Effective User ID。</p>

<p>BASH : Bash的完整路径。</p>

<p>BASH_VERSION : Bash版本。</p>

<p>SHLVL : 每次有Bash执行时，数字加一。</p>

<p>RANDOM : 每次这个参数被用到时，就会产生一个乱数在RANDOM上。</p>

<p>SECONDS : 从这个Shell一开始启动後的时间。</p>

<p>LINENO : Script的行数。</p>

<p>HISTCMD : 历史记录数。</p>

<p>OPTARG : getopts处理的最後一个选项参数。</p>

<p>OPTIND : 下一个要由getopts所处理的参数号码。</p>

<p>HOSTTYPE : 机器种类。</p>

<p>OSTYPE : 作业系统名称。</p>

<p>IFS : Internal Field Separator。</p>

<p>PATH : 命令搜寻路径。<br />
PATH=&ldquo;/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.&rdquo;</p>

<p>HOME : 目前使用者的home directory;</p>

<p>CDPATH : cd命令的搜寻路径。</p>

<p>ENV : 如果这个参数被设定，每次有shell script被执行时，将会执行它所设定的档名做为环境设定。</p>

<p>MAIL : 如果这个参数被设定，而且MAILPATH没有被设定，那麽有信件进来时，bash会通知使用者。</p>

<p>MAILCHECK : 设定多久时间检查邮件一次。</p>

<p>MAILPATH : 一串的邮件检查路径。</p>

<p>MAIL_WARNING : 如果有设定的话，邮件被读取後，将会显示讯息。</p>

<p>PS1 : 提示讯息设定，内定为&rdquo;bash/$ &ldquo;。(请详见提示讯息一节。)</p>

<p>PS2 : 第二提示讯息设定，内定为&rdquo;&gt; &ldquo;。</p>

<p>PS3 : select命令所使用的提示讯息。</p>

<p>PS4 : 执行追踪时用的提示讯息设定，内定为&rdquo;+ &ldquo;。</p>

<p>HISTSIZE : 命令历史记录量，内定为500。</p>

<p>HISTFILE : 历史记录档，内定~/.bash_history。</p>

<p>HISTFILESIZE : 历史记录档行数最大值，内定500。</p>

<p>OPTERR : 如果设为1，bash会显示getopts的错误。</p>

<p>PROMPT_COMMAND : 如果设定的话，该值会在每次执行命令前都显示。</p>

<p>IGNOREEOF : 将EOF值当成输入，内定为10。</p>

<p>TMOUT : 如果设为大於零，该值被解译为输入等待秒数。若无输入，当成没有输入。</p>

<p>FCEDIT : fc命令的内定编辑器。</p>

<p>FIGNORE : 请详见READLINE。</p>

<p>INPUTRC : readline的startup file，内定~/.inputrc</p>

<p>notify : 如果设定了，bash立即报告被终结的背景程式。</p>

<p>history_control, HISTCONTROL : history使用。</p>

<p>command_oriented_history : 存入多行指令。</p>

<p>glob_dot_filenames : 如果设定了，bash将会把&rdquo;.&ldquo;包含入档案路径中。</p>

<p>allow_null_glob_expansion : 如果设定了，bash允许路径明称为null string。</p>

<p>histchars : history使用。</p>

<p>nolinks : 如果设定了，执行指令时，不会跟随symbolic links。</p>

<p>hostname_completion_file, HOSTFILE : 包含与/etc/hosts相同格式的档名。</p>

<p>noclobber : 如果设定了，Bash不会覆写任何由&rdquo;&gt;&ldquo;、&rdquo;&gt;&amp;&ldquo;及&rdquo;&lt;&gt;&ldquo;所操作的档案。</p>

<p>auto_resume : 请见任务控制一节。</p>

<p>no_exit_on_failed_exec : 如果该值存在，非互动的shell不会因为exec失败而跳出。</p>

<p>cdable_vars : 如果启动，而cd命令找不到目录，可切换到参数形态指定的目录下。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(15)提示符号<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-25 22:08:01)</p>

<p>Bash使用PS1~PS4来显示提示符号，其格式如下:</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>/t : 现在时间。<br />
/d : 现在日期。<br />
/n : 新行。<br />
/s : shell的名称。<br />
/w : 目前工作目录。<br />
/W : 目前工作目录完整路径。<br />
/u : 使用者名称。<br />
/h : Hostname。<br />
/# : 这个命令的号码。<br />
/! : 历史号码。<br />
/$ : 如果EUID是0，则#，否则为$。<br />
/nnn : 八进位的字元。<br />
// : &ldquo;/&ldquo;符号。<br />
/[ : 开始一序列不可列印的字元。<br />
/] : 结束一序列不可列印的字元。</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(16)算术表述<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-26 07:00:00)</p>

<p>- +<br />
! ~<br />
* / %<br />
+ -<br />
&lt;&lt; &gt;&gt;<br />
&lt;= &gt;= &lt; &gt;<br />
== !=<br />
&amp;<br />
^<br />
|<br />
&amp;&amp;<br />
||<br />
= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(17)重导Redirection<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-26 08:10:00)</p>

<blockquote>
<blockquote>
<p>1&gt;<br />
.<br />
.</p>
</blockquote>
</blockquote>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Linux程式设计-11.Shell Script(bash)&ndash;(18)语法<br />
<a href="http://www.openchess.org/noitatsko/programming/">http://www.openchess.org/noitatsko/programming/</a> (2001-05-26 09:04:00)</p>

<p>Simple Command</p>

<p>Pipelines</p>

<p>Lists</p>

<p>(list)<br />
{ list; }</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>设置Unix启动密码<br />
本文出自: <a href="http://go3.163.com/~axiom999">http://go3.163.com/~axiom999</a> (2001-06-18 22:08:01)<br />
在 DOS和WINDOWS98系统中设置启动密码已经有很多方法和现成的软件可用了，但是，在UNIX系统中，有没有一种方法可以设置启动密码呢？下面我自
编了一个SHELL小程序，可以实现在系统启动过程中加以密码限制，即使启动了机器，在输入密码之前，也不能使系统出现LOGIN的提示符。<br />
这个小程序是加载在/etc/rc2文件中的，rc2文件是unix系统在启动过程中调用的一个shell文件，我们在最后加入如下内容，就可实现启动密码的限制了。程序如下：</p>

<p>在/etc/rc2文件中寻找下面这句话</p>

<p>if [ &ldquo;${BOOT}&rdquo; = &ldquo;yes&rdquo; -a &ldquo;$7&rdquo; = &ldquo;2&rdquo; ]<br />
then</p>

<h1 id="dspmsg-mf-rc-s-ms-rc2-rc2-ready-the-system-is-ready-n">dspmsg $MF_RC -s $MS_RC2 $RC2_READY &lsquo;The System is Ready ! /n&rsquo;</h1>

<p>找到后<br />
屏蔽上面这句话,之后加入下面这个程序：</p>

<h1 id="循环开始">循环开始</h1>

<p>while true<br />
do<br />
clear<br />
setcolor -b black -k lt_red<br />
echo &lsquo;/033[09;18H 系&rsquo;<br />
setcolor -b black -k lt_cyan<br />
echo &lsquo;/033[09;25H 统&rsquo;<br />
setcolor -b black -k lt_magenta<br />
echo &lsquo;/033[09;32H 启&rsquo;<br />
setcolor -b black -k hi_white<br />
echo &lsquo;/033[09;39H 动&rsquo;<br />
setcolor -b black -k yellow<br />
echo &lsquo;/033[09;46H 完&rsquo;<br />
setcolor -b black -k lt_green<br />
echo &lsquo;/033[09;53H 毕&rsquo;<br />
setcolor -b black -k white<br />
echo &lsquo;/n/n/n/n/n/n/n/n/n/n/n/n/n&rsquo;<br />
echo &lsquo; ┏━━━━━━━━━━━━━━━━━┓&rsquo;<br />
echo &lsquo; ┃ 欢 迎 您 使 用 UNIX ┃&rsquo;<br />
echo &lsquo; ┗━━━━━━━━━━━━━━━━━┛&rsquo;<br />
echo &ldquo;/033[17;15H 请输入密码:[****] &ldquo;<br />
setcolor -b black -k black<br />
echo &ldquo;/033[17;42H/c&rdquo;<br />
read ch<br />
setcolor -b black -k white</p>

<h1 id="在上面的两个setcolor语句中-可以使键入的密码不回显">在上面的两个setcolor语句中，可以使键入的密码不回显</h1>

<p>case $ch in</p>

<h1 id="以下括号内为启动密码">以下括号内为启动密码</h1>

<p>2015)<br />
setcolor -b black -k lt_green<br />
echo &ldquo; &rdquo;<br />
echo &ldquo; &rdquo;<br />
echo &ldquo;密码正确,请使用本系统.&rdquo;<br />
setcolor -b black -k white<br />
break<br />
;;<br />
*)<br />
echo &ldquo;/007&rdquo;<br />
echo &ldquo;/033[20;1H&rdquo;<br />
setcolor -b black -k lt_red<br />
echo &ldquo;/007/t/t/t 密码错误!!!,请重新输入/c&rdquo;<br />
setcolor -b black -k white<br />
read s<br />
;;</p>

<p>esac<br />
done</p>

<h1 id="循环结束">循环结束</h1>

<p>elif [ &ldquo;$7&rdquo; = &ldquo;2&rdquo; ]<br />
then<br />
dspmsg $MF_RC -s $MS_RC2 $RC2_COMPLETE &lsquo;Change to state 2 has been
completed./n&rsquo;<br />
fi<br />
如果在while循环中，每一条setcolor语句下面加如sleep 1（延迟1秒），更能获得动态<br />
的效果！</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Shell 递归程序设计-批量转换大写文件名为小写<br />
本文出自: <a href="http://ehnt.net/clansoft/gb/">http://ehnt.net/clansoft/gb/</a> (2001-06-19 14:08:00)</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>shell实现Unix进程间信息交换的几种方法</p>

<p>本文出自:计算机世界2000年第32期 作者: 北京中软同和公司 何绍德 (2001-06-26 22:08:00)<br />
本文将介绍在SCO OpenServer5.0.5系统中使用shell语言来实现进程间信息交换的几种方法：</p>

<p>使用命名管道实现进程间信息交换</p>

<p>使用kill命令和trap语句实现进程间信息交换</p>

<p>使用点命令“.”实现进程间信息交换</p>

<p>使用export语句实现父进程对子进程的信息传递</p>

<p>一、使用命名管道<br />
命名管道是一种先进先出（FIFO）的数据结构，它允许两个进程通过管道联接实现信息交换。<br />
在Unix系统中，命名管道是一种特殊类型的文件，因此可以对命名管道进行读写操作；当然，同样<br />
也会有读写和执行等权限的限制。</p>

<p>通过下面的命令可以创建一个命名管道：<br />
/etc/mknod pipe_name p</p>

<p>其中“pipe_name”是要创建的命名管道的名字，参数p 必须出现在命名管道名字之后。</p>

<p>命名管道文件被创建后，一些进程就可以不断地将信息写入命名管道文件里，而另一些进程也<br />
可以不断地从命名管道文件中读取信息。对命名管道文件的读写操作是可以同时进行的。下面的例子<br />
显示命名管道的工作过程。</p>

<p>进程A、B、C中运行的程序只是一条简单的echo命令，它们不断地把信息写入到命名管道文件<br />
/tmp/pipe1中。与此同时，程序中的“read msg” 命令不断地从命名管道文件/tmp/pipe1中读取这些<br />
信息，从而实现这些进程间的信息交换。</p>

<p>程序执行时，首先创建命名管道文件，此时程序处于等待状态，直到A、B、C进程中某一个进程往<br />
命名管道中写入信息时，程序才继续往下执行。使用rm命令可以删除命名管道文件从而清除已设置的<br />
命名管道。</p>

<p>下面是一个用于记录考勤的例子：</p>

<p>在主机上运行的程序/tmp/text产生命名管道/tmp/pipe1，并不断地从命名管道中读取信息送屏幕<br />
上显示。</p>

<p>/tmp/text程序：<br />
if [ ! －p /tmp/pipe1 ]<br />
then<br />
/etc/mknode /tmp/pipe1 p<br />
fi<br />
while :<br />
do<br />
read msg<br />
if [ “＄msg&rdquo; = “&rdquo; ]<br />
then<br />
continue<br />
else<br />
echo “＄msg&rdquo;<br />
fi<br />
done &lt; /tmp/pipe1</p>

<p>在终端上运行的是雇员签到程序/tmp/text1。每个雇员在任何一台终端上键入自己的名字或代码，<br />
程序/tmp/text1将把这个名字连同当时的签到时间送入命名管道。</p>

<p>/tmp/text1程序：<br />
tty=‘who am I | awk ‘{print ＄2}’’<br />
while :<br />
do<br />
echo “Enter your name: /c&rdquo; &gt; /dev/＄tty<br />
read name<br />
today=‘date’<br />
echo “＄name/t＄today&rdquo;<br />
done &gt; /tmp/pipe1</p>

<p>当雇员从终端上输入自己的姓名后，运行/tmp/text程序的主机将显示类似下面的结果：</p>

<p>wang Thu Jan 28 09:29:26 BTJ 1999<br />
he Thu Jan 28 09:29:26 BTJ 1999<br />
cheng Thu Jan 28 09:30:26 BTJ 1999<br />
zhang Thu Jan 28 09:31:26 BTJ 1999</p>

<p>二、使用kill命令和trap语句<br />
在Unix系统中，当检测到一个异常的内部状态，或者硬件及外部设备发出请求，或者执行某些指令时，<br />
将会向系统中的进程发出信号报告事件产生。当进程捕获到这些信号后，系统便转去执行预先设定的默认<br />
程序，完成指定的动作；这些预先设定的默认程序称之为信号的系统陷阱。</p>

<p>在shell中，使用trap语句为信号设置新的陷阱。当shell 捕获到一个信号时（信号11除外，因为<br />
shell本身要利用这个信号进行内存分配），它将这个信号传递给所有当前正在执行的程序<br />
（父程序和子程序），并分别执行父程序和子程序中已设置的信号陷阱。一旦陷阱程序执行结束，便返<br />
回中断点，继续执行原来的程序流程。</p>

<p>trap语句的基本格式：<br />
trap command_list signal_list</p>

<p>command_list： 由一个或多个命令（或命令组）构成的命令列表。当命令列表中含有多个命令时要<br />
用单引号或双引号括起来，并且各命令间要用分号隔开。</p>

<p>signal_list：由一个或多个信号值构成的信号列表，各信号值间要用空格分开。</p>

<p>在一个shell程序（父程序）中重新设置信号的陷阱并不改变被这个程序所调用的子程序中同名信号<br />
的陷阱。同样，在子程序中设置的信号陷阱也不影响父程序中同名信号的陷阱。</p>

<p>shell在读取trap语句时，要扫描一次命令列表，以便设置陷阱。在捕获信号后，shell再次扫描命令<br />
列表，执行已设置好的陷阱程序（命令或命令组）。因此，如果命令列表中含有变量置换或命令置换表达<br />
式，shell在第一次扫描命令列表时就会用当前的变量值或命令结果置换这些表达式，使得在捕获到信号而<br />
去执行陷阱程序时，陷阱程序已经不是原来设置的陷阱程序了。为了避免这种情况发生，使用单引号而不是<br />
使用双引号把trap语句中含有变量置换或命令置换表达式的命令列表括起来；因为单引号可以消除所有字符<br />
的特殊含义，这样避免了shell在第一次扫描时执行任何置换或替代操作，直到命令列表被执行时才进行置<br />
换或替代。</p>

<p>向一个程序或进程传递信号方法很多，比如在程序执行时按下Ctrl＋c键或Del键，将向程序传递一个<br />
SIGINT信号，执行该信号的系统陷阱将终止程序执行。使用kill命令传递信号是shell语言编程中最为常用<br />
的方法。</p>

<p>kill命令的基本格式是：<br />
kill [ － signal ] PID</p>

<p>通常kill命令用来终止一个进程。但如果使用了带有短划线“－”的信号作为参数时，kill命令就发送<br />
该信号给PID指示的一个或多个进程，而不是终止进程。当trap语句捕获到这个信号后便执行设定的信号陷阱<br />
程序，实现进程间的相互通讯。</p>

<p>下面的例子显示了程序master和slave1、slave2间如何利用信号机制实现相互通讯的。首先在后台运行<br />
程序slave1和slave2，然后运行程序master。在文件/tmp/pro_list中记录了这三个程序的进程号。</p>

<p>程序slave1首先设置信号15的陷阱，然后把自己的当前进程写入文件/tmp/pro_list；在获得master进程<br />
号后，进入循环状态。当接收到master发出的信号15时，执行陷阱程序，显示相关信息后，向master发出信<br />
号15。</p>

<p>程序slave2执行情况与slave1相似。</p>

<p>程序master也是首先设置信号15的陷阱，然后把自己的当前进程写入文件/tmp/pro_list。在取得所有<br />
slave程序进程号后，向这些slave程序发出信号15，然后进入循环等待。当接收到slave1或slave2发出的信<br />
号15时，执行陷阱程序，显示相关信息，杀死所有slave进程，清空文件/tmp/pro_list，然后退出。</p>

<p>程序/tmp/slave1：<br />
slave() {<br />
echo “slave1 has received sighal from master&rdquo;<br />
echo “Request master to kill slave1 process&rdquo;<br />
kill －15 ＄master_pid<br />
}<br />
trap slave 15<br />
echo “slave1_pid ＄＄&rdquo; &gt;&gt; /tmp/pro_list<br />
sleep 1<br />
while :<br />
do<br />
master_pid=‘awk ’＄1 ～/master/<br />
{print ＄2}‘/tmp/pro_list’<br />
if [ “＄master_pid&rdquo; != “&rdquo; ]<br />
then break<br />
fi<br />
done<br />
while :<br />
do<br />
sleep 1<br />
done</p>

<p>程序/tmp/slave2：<br />
slave() {<br />
echo “slave2 has received sighal from master&rdquo;<br />
echo “Request master to kill slave2 process&rdquo;<br />
kill －15 ＄master_pid<br />
}<br />
trap slave 15<br />
echo “slave2_pid ＄＄&rdquo; &gt;&gt; /tmp/pro_list<br />
sleep 1<br />
while :<br />
do<br />
master_pid=‘awk ’＄1 ～/master/<br />
{print ＄2}‘/tmp/pro_list’<br />
if [ “＄master_pid&rdquo; != “&rdquo; ]<br />
then break<br />
fi<br />
done<br />
while :<br />
do<br />
sleep 1<br />
done</p>

<p>程序/tmp/master：<br />
kill_slave() {<br />
echo “Master has received signals<br />
from slave processes&rdquo;<br />
echo “End all slave processes&rdquo;<br />
kill －9 ＄slave_list<br />
&gt;/tmp/pro_list<br />
exit 0<br />
}<br />
trap kill_slave 15<br />
echo “master_pid ＄＄&rdquo; &gt;&gt; /tmp/pro_list<br />
sleep 1<br />
slave_list=‘awk ’＄1 ～/slave/<br />
{print ＄2}‘/tmp/pro_list’<br />
echo “Current slave processes are:&rdquo;<br />
echo “＄slave_list&rdquo;<br />
kill －15 ＄slave_list<br />
while :<br />
do<br />
sleep 1<br />
done</p>

<p>执行程序：<br />
＄ cd /tmp<br />
＄ ./slave1＆<br />
15638<br />
＄ ./slave2＆<br />
16831<br />
＄ ./master<br />
Current slave processes are:<br />
15638<br />
16831<br />
slave1 has received signal 15 from master<br />
Request master to kill slave1 process<br />
slave2 has received signal 15 from master<br />
Request master to kill slave2 process<br />
Master has received signals from slave processes<br />
End all slave processes<br />
15638 Killed<br />
16831 Killed<br />
＄</p>

<p>三、使用点命令“.”<br />
“.”点命令是shell的一个内部命令，它从指定的shell 文件中读入所有命令语句并在当前进程<br />
中执行。 因此当多个shell进程（父子进程或无关进程均可）共享一组变量值时，就可以将这些变量<br />
赋值语句定义到一个shell文件里，并在需要这些变量值的程序中使用点语句来引用这个shell文件，<br />
从而实现变量值共享（对这些变量值的修改仅涉及到这个shell文件）。但要注意的是，这个shell文<br />
件不能包括含有位置参数的语句，即不能接受＄1、＄2等命令行参数。</p>

<p>下面是一个在超市中发布每日商品价格的示范程序片段。发布每日商品价格统一由程序/tmp/jiage<br />
来执行，它为每种商品价格赋值，并把相应的赋值语句写入文件/tmp/jiagebiao中。在各终端上运行的<br />
收款程序/tmp/shoukuan将读入文件 /tmp/jiagebiao中所有赋值语句并在当前进程中执行，从而获取在<br />
程序/tmp/jiage中设定的价格。</p>

<p>价格设定程序/tmp/jiage：</p>

<p>echo “Enter the price of chicken,<br />
duck and fish: /c&rdquo;<br />
read chicken duck fish<br />
exec 3&gt;/tmp/jiagebiao<br />
echo “chicken_price=＄chicken&rdquo; &gt;＆3<br />
echo “duck_price=＄duck&rdquo; &gt;＆3<br />
echo “fish_price=＄fish&rdquo; &gt;＆3</p>

<p>执行/tmp/jiage程序后，文件/tmp/jiagebiao中将有如下内容：</p>

<p>chicken_price=5.4<br />
duck_price=2.5<br />
fish_price=4.2</p>

<p>收款程序/tmp/shoukuan：</p>

<p>. /tmp/jiagebiao<br />
count=0<br />
while :<br />
do<br />
echo “Enter the trade name and<br />
quantities or input q to sum: /c&rdquo;<br />
read trade＄count quantity＄count<br />
eval a=/＄trade＄count<br />
if [ “＄a&rdquo; = “q&rdquo; ]<br />
then if [ ＄count －gt 0 ]<br />
then<br />
count=‘expr ＄count － 1’<br />
fi<br />
break<br />
fi<br />
count=‘expr ＄count ＋ 1 ’<br />
done<br />
echo “/n‘date’&rdquo;<br />
echo “trade name/tquantity/tsum&rdquo;<br />
while [ “＄count&rdquo; －ge 0 ]<br />
do<br />
eval trade=“/＄{trade＄count}&rdquo;<br />
eval trade_price=“＄{trade}_price&rdquo;<br />
eval danjia=/＄{＄trade_price}<br />
eval quantity=“/＄{quantity＄count}&rdquo;<br />
sum=‘echo “scale=2; ＄danjia<br />
＊＄quantity&rdquo;|bc’<br />
echo “＄trade/t/t＄quantity/t/t＄sum&rdquo;<br />
count=‘expr ＄count － 1 ’<br />
done</p>

<p>在终端上执行程序/tmp/shoukuan将有如下显示：</p>

<p>Enter the trade name and quantities<br />
or input q to sum: chicken 2<br />
Enter the trade name and quantities<br />
or input q to sum: fish 3<br />
Enter the trade name and quantities<br />
or input q to sum: duck 4<br />
Enter the trade name and quantities<br />
or input q to sum: q</p>

<p>Thu Jan 28 09:29:29 BJT 1999:<br />
duck 4 10<br />
fish 3 12.6<br />
chicken 2 10.8</p>

<p>四、使用export语句<br />
通常shell变量是局部变量，无论是通过赋值操作还是通过命令赋值，其变量值只在当前进程中<br />
有效。但是经过export语句说明的shell变量就成为一个全局性变量，其变量名和变量值可以传递给<br />
子进程及其后代进程。在子进程中可以修改这个变量的值，但并不影响这个变量在父进程中的取值。</p>

<p>下面的例子中，父进程（/tmp/text）将赋值后的变量 pro_name传递给子进程（/tmp/text_child），<br />
在子进程中对变量pro_name所赋的新值并不影响父进程中该变量的值。</p>

<p>/tmp/text程序：<br />
pro_name=“PARENT&rdquo;<br />
echo “The variable pro_name is<br />
＄pro_name in parent process&rdquo;<br />
export pro_name<br />
/tmp/text_child<br />
echo “The variable pro_name is<br />
＄pro_name after retund to parent process&rdquo;</p>

<p>/tmp/text_child程序：<br />
echo“The variable pro_name (＄pro_name) is<br />
transmited to child process&rdquo;<br />
pro_name=“CHILD&rdquo;<br />
echo “To change the variable pro_name to<br />
＄pro_name in child process&rdquo;<br />
执行程序/tmp/text：<br />
＄ /tmp/text<br />
The variable pro_name is PARENT<br />
in parent process<br />
The variable pro_name (PARENT)<br />
is transmited to child process<br />
To change the variable pro_name to CHILD<br />
in child process<br />
The variable pro_name is PARENT<br />
after retund to parent process<br />
＄</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>介绍B-SHELL的一些运用方法</p>

<p>这里只介绍B-SHELL的一些运用方法，不对B-SHELL的基本知识进行说明（与其他的语言有很多的共性，果你懂一种语言的话，很快就 能上手），如你是对B-
SHELL不是很了解的话，而且又想学的话，建议你去查阅相关的资料（网上有很多关于这方面的东东；当然也可买些书；如果你是一个
借别人的书才能阅读的人，那就去借吧！我就是这样的人之一。）。我的能力有限，若有不足或错误，请多多指教，小弟将感激不尽！所有的介绍适合于内核
2.2.13的及以上的liunx环境。</p>

<p>B-SHELL是一个便捷的开发工具，在紧急情况下要实现产品的某一功能，而用C语言不能很快完成，则可选择B-SHLL实现，日后再用C语言完
成；在产品里对于那些不常运行的程序可用B-SHELL替代，这样可以避免因对C语言使用不当而带来的不良后果；对于一些处理量不大的程序可用B- SHELL实现。</p>

<p>讨论：</p>

<p>#!/bin/sh à B-SHELL的解释器标志</p>

<p>ALL=$@</p>

<p>#{</p>

<p>B-SHELL中带”$”的变量的说明:$0à SHELL命令本身</p>

<p>$nà 位置参数n（n != 0）</p>

<p>$@à 所有的输入变量</p>

<p>$$à 当前进程号</p>

<p>$!à 最近后台进程的PID值</p>

<p>$?à 最近命令执行状态的返回值</p>

<p>$#à 参数的个数</p>

<p>}#</p>

<p>declare -x TIME=0</p>

<p>#{</p>

<p>变量声明的说明：</p>

<p>declare
声明全局变量；如果在函数内声明，则只在函数内有效（局部变量）；-x表明变量值可以传递给后继命令（从函数传值给后继命令）；-i表明变量作为整型处
理；-r表明变量为只度；用“+”代替“-”，原有变量的声明屏蔽，恢复为无定义状态。由第一次赋值决定其参数在脚本中的性质，如果首次是字符，以后都当
字符处理，其它等同。</p>

<p>local声明局部变量;local 变量名 [ = “值”];一般在函数内部运用。</p>

<p>直接定义变量，不用declare 和local指明。由第一次赋值决定其参数在脚本中的性质，如果首次是字符，以后都当字符处理，其它等同。也可在定义确定。</p>

<p>}#</p>

<p>declare -x NUMBEROFFILE=0</p>

<p>#{</p>

<p>关于脚本函数说明：</p>

<p>定义方式：function 函数名（） 或 函数名（）</p>

<p>{</p>

<p>函数体（作你想要作的事）</p>

<p>}</p>

<p>调用方式：函数名 参数列</p>

<p>在脚本里函数的调用就象调用命令一样使用。à 后面将会提到</p>

<p>}#</p>

<p>function hel_ver() à 显示帮助信息或版本号</p>

<p>{</p>

<p>if [ &ldquo;$1&rdquo; = &ldquo;-h&rdquo; ] ;then</p>

<p>echo &ldquo;fstrf -v :show version of shell script.&rdquo;</p>

<p>echo &ldquo;Usages : fstrf -h||-v &ldquo;</p>

<p>echo &ldquo; fstrf ARGUMENTS DIRECTORY STRING || fstrf ARGUMENTS STRING &ldquo;</p>

<p>echo &ldquo; For more informations run man fstrf.&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>if [ &ldquo;$1&rdquo; = &ldquo;-v&rdquo; ] || [ &ldquo;$1&rdquo; = &ldquo;version&rdquo; ];then</p>

<p>echo &ldquo;fstrf version 1.0.1 2001/07/05.&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>}</p>

<p>function find_offer() à 在给定的目录下查找是否有包含指定字串的文件，并显示其路径</p>

<p>{</p>

<p>for file in <code>ls &quot;$1&quot;</code> à for var in command do ………done 的一个典型运用；对$1目录下的目录或文件进行处理</p>

<p>do</p>

<p>if [ -d &ldquo;$1&rdquo;/$file ];then à 判断$file是否为目录</p>

<p>continue</p>

<p>else</p>

<p>string=<code>grep &quot;$2&quot; &quot;$1&quot;/$file</code> à 查找字串</p>

<p>if [ -n &ldquo;$string&rdquo; ];then à 判断字串为非空</p>

<p>echo $string &gt; /str</p>

<p>str=<code>awk '{print $1 }' /str</code> à 取得str 的第一域值</p>

<p>rm /str</p>

<p>if [ &ldquo;$str&rdquo; != &ldquo;Binary&rdquo; ];then à 剔除二进制文件</p>

<p>NUMBEROFFILE=<code>expr $NUMBEROFFILE + 1</code> à 相当于C语言的NUMBEROFFILE +=1；可用</p>

<p>let ‘ NUMBEROFFILE=NUMBEROFFILE + 1‘替换</p>

<p>TIME=<code>expr $TIME + 1</code></p>

<p>echo &ldquo;$1/$file&rdquo; à 显示匹配文件</p>

<p>fi</p>

<p>fi</p>

<p>fi</p>

<p>done</p>

<p>}</p>

<p>#else</p>

<p>function find_curr() à 在当前目录下查找是否有包含指定字串的文件，并显示其路径（相对路径）实现机制与find_offer相同</p>

<p>{</p>

<h1 id="if-eq-1-then-à">if [ &ldquo;$#&rdquo; -eq &ldquo;1&rdquo; ];then à</h1>

<p>for file in <code>ls ./</code> 如果只输入一个参数，则查找当前工作目录下的文件</p>

<p>do</p>

<p>if [ -d &ldquo;$file&rdquo; ];then</p>

<p>continue</p>

<p>else</p>

<p>string=<code>grep &quot;$1&quot; $file</code></p>

<p>if [ -n &ldquo;$string&rdquo; ];then</p>

<p>echo $string &gt; /str</p>

<p>str=<code>awk '{print $1 }' /str</code></p>

<p>rm /str</p>

<p>if [ &ldquo;$str&rdquo; != &ldquo;Binary&rdquo; ];then</p>

<p>NUMBEROFFILE=<code>expr $NUMBEROFFILE + 1</code></p>

<p>TIME=<code>expr $TIME + 1</code></p>

<p>echo &ldquo;./$file&rdquo;</p>

<p>fi</p>

<p>fi</p>

<p>fi</p>

<p>done</p>

<p>}</p>

<p>function print_num() à 显示查找的文件数 (在查多级目录时未能实现，如果你知道，告诉我，我会很高兴的！)</p>

<p>{</p>

<p>if [ &ldquo;$NUMBEROFFILE&rdquo; -gt &ldquo;0&rdquo; ] ;then</p>

<h1 id="echo">echo &ldquo;&rdquo;</h1>

<p>if [ &ldquo;$#&rdquo; -eq &ldquo;1&rdquo; ];then</p>

<p>#{</p>

<p>关于彩色显示的说明：</p>

<p>不同的linux系统，运行的命令的方式都不一样。在LINUX/BSD系统中：echo -e “/033[40;32m”；在V系统中：echo
“/033[40;32m”。本例中采用前一种方式。40位为背景色，取值4047之间；32位为前景色，取值
3037之间；/033是固定用法。彩色显示要成队匹配，如脚本所示。通常后一个色彩控制为</p>

<p>echo -e &ldquo;/033[40;37m&rdquo; （意思是恢复正常色）。彩色显示控制通常是成对出现，例如，</p>

<p><code>echo -e &quot;/033[40;33m&quot;</code>&rdquo;$2&rdquo;<code>echo -e &quot;/033[40;37m&quot;</code></p>

<p>echo -e &ldquo;/033[40;37m&rdquo;à
恢复正常显示（黑背景，白前景）。利用彩色显示控可以作出漂亮的liunx菜单（当然不能与Xwindows和WINDOWS相比）。</p>

<p>}#</p>

<p>echo &ldquo;Finded <code>echo -e &quot;/033[40;32m&quot;</code>$NUMBEROFFILE<code>echo -e &quot;/033[40;37m&quot;</code>
file(s) which have the string <code>echo -e &quot;/033[40;33m&quot;</code>&rdquo;$1&rdquo;<code>echo -e
&quot;/033[40;37m&quot;</code> .&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Finded <code>echo -e &quot;/033[40;32m&quot;</code>$NUMBEROFFILE<code>echo -e &quot;/033[40;37m&quot;</code>
file(s) which have the string <code>echo -e &quot;/033[40;33m&quot;</code>&rdquo;$2&rdquo;<code>echo -e
&quot;/033[40;37m&quot;</code>. &ldquo;</p>

<p>fi</p>

<p>else</p>

<p>if [ -z &ldquo;$2&rdquo; ];then</p>

<p>echo &ldquo;Finded <code>echo -e &quot;/033[40;32m&quot;</code>no <code>echo -e &quot;/033[40;37m&quot;</code>file under
current directory.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Finded <code>echo -e &quot;/033[40;32m&quot;</code>no <code>echo -e &quot;/033[40;37m&quot;</code>file under
directory &ldquo;$1&rdquo;.&rdquo;</p>

<p>fi</p>

<p>fi</p>

<p>}</p>

<p>function fdir() à 从给定的目录开始查找当前目录及其子目录的包含的目录，并存入/tmp/dtmp文件。</p>

<p>{</p>

<blockquote>
<p>/tmp/dtmp</p>
</blockquote>

<p>#cd /</p>

<p>echo &ldquo;$1&rdquo; &gt;/tmp/dtmp</p>

<p>tmp=<code>echo $1 | grep &quot;//proc&quot;</code>à 不查找/proc目录下的目录</p>

<p>if [ ! -z $tmp ];then</p>

<h1 id="echo-proc">echo &ldquo;/proc&rdquo;</h1>

<p>exit</p>

<p>fi</p>

<p>i=<code>expr $i + 1</code> à 记录找到的目录数目，每向/tmp/dtmp文件加一目录记录时此值加一（以下同样）</p>

<p>###first grade</p>

<p>cd $1 à 进入脚本的工作目录（不会改变控制台的工作目录）</p>

<p>for loop in <code>ls ./</code></p>

<p>do</p>

<h1 id="echo-loop">echo $loop</h1>

<p>if [ -d $loop ];then à 判断$loop是否为目录（以下同样）</p>

<p>tmp=<code>echo $loop | grep &quot;proc&quot;</code></p>

<p>if [ ! -z $tmp ];then</p>

<p>continue</p>

<p>fi</p>

<p>i=<code>expr $i + 1</code></p>

<p>echo &ldquo;<code>pwd</code>/$loop&rdquo; &gt;&gt;/tmp/dtmp à 连同目录的绝对路径加入/tmp/dtmp文件（以下同样）</p>

<p>###second grade</p>

<p>cd $loop à 进入脚本二级工作目录</p>

<p>for loop1 in <code>ls ./</code></p>

<p>do</p>

<h1 id="echo-loop1">echo $loop1</h1>

<p>if [ -d $loop1 ];then</p>

<p>tmp=<code>echo $loop1 | grep &quot;proc&quot;</code></p>

<p>if [ ! -z $tmp ];then</p>

<p>continue</p>

<p>fi</p>

<p>i=<code>expr $i + 1</code></p>

<p>echo &ldquo;<code>pwd</code>/$loop1&rdquo; &gt;&gt;/tmp/dtmp</p>

<p>###third grade</p>

<p>cd $loop1à 进入脚本三级工作目录</p>

<p>for loop1 in <code>ls ./</code></p>

<p>do</p>

<h1 id="echo-loop1-1">echo $loop1</h1>

<p>if [ -d $loop1 ];then</p>

<p>i=<code>expr $i + 1</code></p>

<p>echo &ldquo;<code>pwd</code>/$loop1&rdquo; &gt;&gt;/tmp/dtmp</p>

<p>…………</p>

<p>………</p>

<p>………</p>

<p>………</p>

<p>…………</p>

<p>else</p>

<p>continue</p>

<p>fi</p>

<p>done</p>

<p>cd .. à 退出脚本三级工作目录，进入脚本二级工作目录</p>

<p>else</p>

<p>continue</p>

<p>fi</p>

<p>done</p>

<p>cd ..à 退出脚本二级工作目录，进入脚本一级工作目录</p>

<p>else</p>

<p>continue</p>

<p>fi</p>

<p>done</p>

<p>}</p>

<p>#{</p>

<p>test的用法说明：在脚本里，用一对[ ]表示test，如[ &ldquo;$#&rdquo; -eq &ldquo;0&rdquo;
]。注意:参数与[]之间一定要有空格（最好是所有的参数之间都要有空格）。如果不了解test参数的用法，运行man
test,只要你学过英语你一定能看懂；实在没有办法，那就上网去查吧！</p>

<p>}#</p>

<p>##main shell</p>

<p>if [ &ldquo;$#&rdquo; -eq &ldquo;0&rdquo; ];then</p>

<p>echo &ldquo;<code>echo -e &quot;/033[40;33m&quot;</code>run fstrf -h or man fstrf <code>echo -e
&quot;/033[40;37m&quot;</code>to get more help informations.&rdquo;</p>

<p>echo &ldquo;<code>echo -e &quot;/033[40;36m&quot;</code>list current directory:<code>echo -e &quot;/033[40;37m&quot;</code>&ldquo;</p>

<p>ls ./</p>

<p>echo &ldquo;<code>echo -e &quot;/033[40;36m&quot;</code>no string input!!!<code>echo -e &quot;/033[40;37m&quot;</code>&ldquo;</p>

<p>exit</p>

<p>fi</p>

<p>hel_ver $ALL à 调用hel_ver函数</p>

<p>if [ &ldquo;$1&rdquo; = &ldquo;-up&rdquo; ];then à 查找指定当前目录内及字目录内的文件</p>

<p>if [ &ldquo;$#&rdquo; -eq &ldquo;3&rdquo; ];then</p>

<p>fdir $2 $3 2&gt;/dev/null 1&gt;&amp;2 à 将所有的错误输出均输向/dev/null（不在屏幕上回显，以下一样）</p>

<p>#{</p>

<p>while read var do .. done的重定向说明:</p>

<p>有两种方式: 1. while read var do .. done &lt; 重定向文件的路径及文件名</p>

<p>while read var</p>

<p>do</p>

<p>..</p>

<p>done &lt; 重定向文件的路径及文件名</p>

<p>2. dd if=重定向文件的路径及文件名 bs=512 2&gt;/dev/null | while read var do .. done</p>

<p>dd if=重定向文件的路径及文件名 bs=512 2&gt;/dev/null | /</p>

<p>while read var</p>

<p>do</p>

<p>..</p>

<p>done</p>

<p>}#</p>

<p>#{</p>

<p>关于函数调用的说明：</p>

<p>在脚本中函数的调用类似与LINUX命令的调用，只是变量要用“”括起来。函数内部的$n只相对与函数的参数位置，如find_offer &ldquo;$DIR&rdquo;
&ldquo;$3&rdquo;，find_offer内的$1对应于&rdquo;$DIR&rdquo;，$2对应于&rdquo;$3&rdquo;，与SHELL
主程序的$n无对应关系，既函数的$1不一定要等于SHELL主程序的$1。</p>

<p>}#</p>

<p>dd if=/tmp/dtmp bs=512 2&gt;/dev/null | /</p>

<p>while read DIR</p>

<p>do</p>

<p>find_offer &ldquo;$DIR&rdquo; &ldquo;$3&rdquo;</p>

<p>done</p>

<h1 id="print-num-2-3">print_num &ldquo;$2&rdquo; &ldquo;$3&rdquo;</h1>

<p>fi</p>

<p>if [ &ldquo;$#&rdquo; -eq &ldquo;2&rdquo; ];then à 查找指定当前工作目录内及字其目录内的文件</p>

<p>fdir ./ 2&gt;/dev/null 1&gt;&amp;2</p>

<p>dd if=/tmp/dtmp bs=512 2&gt;/dev/null | /</p>

<p>while read DIR</p>

<p>do</p>

<p>find_offer &ldquo;$DIR&rdquo; &ldquo;$2&rdquo;</p>

<p>done</p>

<h1 id="print-num-2">print_num &ldquo;$2&rdquo;</h1>

<p>fi</p>

<p>fi</p>

<p>if [ &ldquo;$1&rdquo; = &ldquo;-cu&rdquo; ];then à 查找当前目录或指定当前目录内的文件</p>

<p>if [ &ldquo;$#&rdquo; -eq &ldquo;2&rdquo; ];then à 查找当前目录匹配的文件</p>

<p>find_curr &ldquo;$2&rdquo;</p>

<p>print_num &ldquo;$2&rdquo; à 显示匹配的文件数</p>

<p>fi</p>

<p>if [ &ldquo;$#&rdquo; -eq &ldquo;3&rdquo; ];then à 查找指定当前目录内的文件</p>

<p>find_offer &ldquo;$2&rdquo; &ldquo;$3&rdquo;</p>

<p>print_num &ldquo;$3&rdquo; à 显示匹配的文件数</p>

<p>fi</p>

<p>fi</p>

<p>if [ -e /tmp/dtmp ];then à 文件存在则删除</p>

<p>rm /tmp/dtmp</p>

<p>fi</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>shell编程例子 &ndash; 一个简单的目录菜单</p>

<p>until<br />
echo List Directory&hellip;&hellip;&hellip;.1<br />
echo Change Directory&hellip;&hellip;..2<br />
echo Edit File&hellip;&hellip;&hellip;&hellip;&hellip;3<br />
echo Remove File&hellip;&hellip;&hellip;&hellip;.4<br />
echo Exit Menu&hellip;&hellip;&hellip;&hellip;&hellip;5</p>

<p>read choice<br />
test $choice = 5<br />
do<br />
case $choice in<br />
1) ls;;<br />
2) echo Enter target directory<br />
read dir<br />
cd $dir<br />
;;<br />
3) echo Enter file name<br />
read file<br />
vi $file<br />
;;<br />
4) echo Enter file name<br />
read file<br />
rm $file<br />
;;<br />
q|Q|5) echo Goodbye;;<br />
*) echo illegal Option<br />
esac<br />
done</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>shell编程例子 &ndash; 一个.cshrc例子</p>

<hr />

<h1 id="toc_34">* *</h1>

<h1 id="toc_35">* *</h1>

<h1 id="toc_36">*****************************************************************</h1>

<h1 id="history">HISTORY</h1>

<h1 id="rcsfile-cshrc-v-revision-4-1-3-3-dec-date-1992-05-11">@(#)$RCSfile: .cshrc,v $ $Revision: 4.1.3.3 $ (DEC) $Date: 1992/05/11</h1>

<p>09:13:09<br />
$</p>

<p>setenv MAIL /usr/spool/mail/$USER<br />
#******************************************************************************<br />
#******************************************************************************</p>

<h1 id="add-by-zzy-2000-08-06">add by zzy 2000.08.06</h1>

<p>#******************************************************************************<br />
#******************************************************************************</p>

<h1 id="set-pics-environment">set pics environment</h1>

<p>#******************************************************************************<br />
#source /etc/pics.d/picsenv.csh<br />
#******************************************************************************</p>

<h1 id="set-innovator-environment">set innovator environment</h1>

<p>#******************************************************************************<br />
#source /usr/innovator/inoenv.csh<br />
#******************************************************************************</p>

<h1 id="set-pcfc-application-environment">set PCFC application environment</h1>

<p>#******************************************************************************<br />
source ${HOME}/app_login<br />
#******************************************************************************</p>

<h1 id="change-path-to-home-path">change path to home path</h1>

<p>#******************************************************************************<br />
cd ${HOME}<br />
#******************************************************************************</p>

<h1 id="app-login">app_login:</h1>

<p>#******************************************************************************<br />
#* module: app_login<br />
#* description: app login<br />
#* This script must be called in the login file<br />
#* with the command &lsquo;source app_login&rsquo;<br />
#* author: zzy<br />
#* version: 31.08.1998<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment">environment</h1>

<p>#******************************************************************************<br />
set say = &ldquo;echo&rdquo;<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="this-path-and-this-script">this path and this script</h1>

<p>#******************************************************************************<br />
set this_path1 = &ldquo;<code>dirname ${HOME}/x</code>&rdquo;<br />
set this_script1 = &ldquo;app_login&rdquo;</p>

<p>if ( ! -f ${this_path1}/${this_script1} ) then<br />
$say &lsquo;this script must be in the directory $HOME&rsquo;<br />
goto exit<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="start-message">start message</h1>

<p>#******************************************************************************<br />
$say &ldquo; %$this_script1, <code>date '+%H:%M:%S'</code> start executing on $node&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="set-project-and-channel-prefix-for-all-user">set project and channel prefix for all user</h1>

<p>#******************************************************************************<br />
if ( &ldquo;$user&rdquo; == &ldquo;root&rdquo; ) then<br />
setenv PROJ pcfc<br />
setenv CPRE &ldquo;&rdquo;<br />
endif</p>

<p>if ( &ldquo;$user&rdquo; == &ldquo;pcfc&rdquo; ) then<br />
setenv PROJ pcfc<br />
setenv CPRE &ldquo;&rdquo;<br />
endif</p>

<p>if ( &ldquo;$user&rdquo; == &ldquo;picsadm&rdquo; ) then<br />
setenv PROJ baoshan<br />
setenv CPRE &ldquo;&rdquo;<br />
endif</p>

<p>if ( &ldquo;$user&rdquo; == &ldquo;picsvis&rdquo; ) then<br />
setenv PROJ baoshan<br />
setenv CPRE &ldquo;&rdquo;<br />
endif</p>

<p>if ( &ldquo;$user&rdquo; == &ldquo;&rdquo; ) then<br />
setenv PROJ pcfc<br />
setenv CPRE &ldquo;&rdquo;<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="set-project-directory">set project directory</h1>

<p>#******************************************************************************<br />
setenv PROJ_DIR /home/$PROJ</p>

<p>#******************************************************************************</p>

<h1 id="call-project-application-login">call project application login</h1>

<p>#******************************************************************************<br />
if ( -f &ldquo;${this_path1}/${this<em>script1}</em>$PROJ&rdquo; ) then<br />
$say &ldquo; %$this_script1, call project application login&rdquo;<br />
source ${this_path1}/${this<em>script1}</em>$PROJ<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="end-message">end message</h1>

<p>#******************************************************************************<br />
#$say &ldquo; %$this_script1, <code>date '+%H:%M:%S'</code> finished&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="exit">exit</h1>

<p>#******************************************************************************<br />
exit:<br />
unset this_path1<br />
unset this_script1<br />
exit</p>

<p>#******************************************************************************</p>

<h1 id="app-login-pcfc">app_login_pcfc</h1>

<p>#******************************************************************************<br />
#* module: application<em>login</em>$PROJ<br />
#* description: application login for a project<br />
#* This script must be called in the login file app_login<br />
#* with the command &lsquo;source app<em>login</em>$PROJ&rsquo;<br />
#* author: Zhou zeyan<br />
#*<br />
#* version: 8.1.2000<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry-1">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment-1">environment</h1>

<p>#******************************************************************************<br />
set say = &ldquo;echo&rdquo;<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="this-path-and-this-script-1">this path and this script</h1>

<p>#******************************************************************************<br />
set this_path2 = &ldquo;<code>dirname ${HOME}/x</code>&rdquo;<br />
set this_script2 = &ldquo;app<em>login</em>$PROJ&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="start-message-1">start message</h1>

<p>#******************************************************************************<br />
$say &ldquo; %$this_script2, <code>date '+%H:%M:%S'</code> start executing on $node&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="history-1">history</h1>

<p>#******************************************************************************<br />
set history=40<br />
alias h history</p>

<p>#******************************************************************************</p>

<h1 id="aliases">aliases</h1>

<p>#******************************************************************************<br />
alias sql sqlplus pcfcadm/pcfcadm</p>

<p>#******************************************************************************</p>

<h1 id="set-environment-for-components">set environment for components</h1>

<p>#******************************************************************************</p>

<p>set cmp = glb<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = utl<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = com<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = log<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = tel<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = mva<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = mtr<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = mm<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = de<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = se<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = comtcp<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
set cmp = sdd<br />
if ( -r &ldquo;${PROJ_DIR}/${cmp}/etc/${cmp}_init&rdquo; ) then<br />
source ${PROJ_DIR}/${cmp}/etc/${cmp}_init<br />
endif<br />
unset cmp</p>

<p>#******************************************************************************</p>

<h1 id="set-environment-for-project">set environment for project</h1>

<p>#******************************************************************************<br />
if ( -r &ldquo;${PROJ_DIR}/login/login&rdquo; ) then<br />
source ${PROJ_DIR}/login/login<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="end-message-1">end message</h1>

<p>#******************************************************************************<br />
#$say &ldquo; %$this_script2, <code>date '+%H:%M:%S'</code> finished&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="unset">unset</h1>

<p>#******************************************************************************<br />
exit:<br />
unset this_path2<br />
unset this_script2<br />
exit<br />
#******************************************************************************</p>

<h1 id="login">login</h1>

<p>#******************************************************************************<br />
#* module: login<br />
#* description: project login definitions<br />
#* author: Zhou zeyan<br />
#* version: 31.08.2000<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry-2">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment-2">environment</h1>

<p>#******************************************************************************<br />
set say = echo<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="pathes">pathes</h1>

<p>#******************************************************************************<br />
set path_project_login = &ldquo;${PROJ_DIR}/login&rdquo;<br />
set path_project_com = &ldquo;${path_project_login}/com&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="definitions-make">definitions make</h1>

<p>#******************************************************************************<br />
if ( -r &ldquo;${path_project_com}/def_make&rdquo; ) then<br />
source ${path_project_com}/def_make<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="definitions-path">definitions path</h1>

<p>#******************************************************************************<br />
if ( -r &ldquo;${path_project_com}/def_path&rdquo; ) then<br />
source ${path_project_com}/def_path<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="definitions-unix-commands">definitions unix commands</h1>

<p>#******************************************************************************<br />
if ( -r &ldquo;${path_project_com}/def_unix&rdquo; ) then<br />
source ${path_project_com}/def_unix<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="definitions-user-commands">definitions user commands</h1>

<p>#******************************************************************************<br />
if ( -r &ldquo;${path_project_com}/def_user&rdquo; ) then<br />
source ${path_project_com}/def_user<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="welcome">welcome</h1>

<p>#******************************************************************************<br />
if ( -r &ldquo;${path_project_com}/welcome&rdquo; ) then<br />
source ${path_project_com}/welcome<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="exit-1">exit</h1>

<p>#******************************************************************************<br />
unset path_project_login<br />
unset path_project_com<br />
exit</p>

<p>#******************************************************************************</p>

<h1 id="def-unix">def_unix</h1>

<p>#******************************************************************************<br />
#* module: def_user<br />
#* description: user command settings<br />
#* author: Zhou zeyan<br />
#* version: 31.08.2000<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry-3">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment-3">environment</h1>

<p>#******************************************************************************<br />
set say = &ldquo;echo&rdquo;<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="pathes-1">pathes</h1>

<p>#******************************************************************************<br />
set path_project_com1 = &ldquo;${PROJ_DIR}/login/com&rdquo;<br />
set path_project_com2 = &ldquo;${path_project_com1}/com&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="user-command-settings">user command settings</h1>

<p>#******************************************************************************<br />
alias cdproj &ldquo;cd ${PROJ_DIR}&rdquo;<br />
alias cdmkf &ldquo;cd ${PROJ_DIR}/mkf&rdquo;<br />
alias cdglb &ldquo;cd ${PROJ_DIR}/glb&rdquo;<br />
alias cdutl &ldquo;cd ${PROJ_DIR}/utl&rdquo;<br />
alias cdcom &ldquo;cd ${PROJ_DIR}/com&rdquo;<br />
alias cdlog &ldquo;cd ${PROJ_DIR}/log&rdquo;<br />
alias cdtel &ldquo;cd ${PROJ_DIR}/tel&rdquo;<br />
alias cdtools &ldquo;cd ${PROJ_DIR}/tools&rdquo;<br />
alias cdcomtcp &ldquo;cd ${PROJ_DIR}/comtcp&rdquo;<br />
alias cdexport &ldquo;cd ${PROJ_DIR}/export&rdquo;<br />
alias cdoracle &ldquo;cd ${PROJ_DIR}/oracle&rdquo;<br />
alias cdsystem &ldquo;cd ${PROJ_DIR}/system&rdquo;<br />
alias cds &ldquo;cd /home/zzy/system&rdquo;<br />
alias cdbuild &ldquo;cd ${PROJ_DIR}/oracle/build&rdquo;<br />
alias cdzzy &ldquo;cd /home/zzy&rdquo;</p>

<h1 id="make-environments">make environments</h1>

<p>alias mkglb &ldquo;make -f ${PROJ_DIR}/glb/work/etc/glb.mkf&rdquo;<br />
alias mkutl &ldquo;make -f ${PROJ_DIR}/utl/work/etc/utl.mkf&rdquo;<br />
alias mkcomtcp &ldquo;make -f ${PROJ_DIR}/comtcp/work/etc/comtcp.mkf&rdquo;<br />
alias mkuserlib &ldquo;make -f ${PROJ_DIR}/userlib/userlib.mkf&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="exit-2">exit</h1>

<p>#******************************************************************************<br />
unset path_project_com1<br />
unset path_project_com2<br />
exit</p>

<p>#******************************************************************************</p>

<h1 id="def-make">def_make</h1>

<p>#******************************************************************************<br />
#* Copyright &copy; BS P4 2000. All Rights Reserved. Confidental *<br />
#******************************************************************************</p>

<p>#******************************************************************************<br />
#* module: def_make<br />
#* description: make settings<br />
#* author: Zhou zeyan<br />
#* version: 31.08.2000<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry-4">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment-4">environment</h1>

<p>#******************************************************************************<br />
set say = &ldquo;echo&rdquo;<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="pathes-2">pathes</h1>

<p>#******************************************************************************<br />
set path_project_com1 = &ldquo;${PROJ_DIR}/login/com&rdquo;<br />
set path_project_com2 = &ldquo;${path_project_com1}/com&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="make-settings">make settings</h1>

<p>#******************************************************************************</p>

<h1 id="add-setenv-debug-1-by-zzy-2000-08-07">Add setenv debug=1 by zzy 2000-08-07</h1>

<p>setenv debug 1<br />
setenv OS unix<br />
setenv OSVERS<br />
setenv GLOBAL_MKF_HOME ${PROJ_DIR}/mkf/</p>

<p>#******************************************************************************</p>

<h1 id="exit-3">exit</h1>

<p>#******************************************************************************<br />
unset path_project_com1<br />
unset path_project_com2<br />
exit</p>

<p>#******************************************************************************<br />
#* Copyright &copy; BS P4 2000. All Rights Reserved. Confidental *<br />
#******************************************************************************</p>

<h1 id="def-path">def_path</h1>

<p>#******************************************************************************<br />
#* Copyright &copy; BS P4 2000. All Rights Reserved. Confidental *<br />
#******************************************************************************</p>

<p>#******************************************************************************<br />
#* module: def_path<br />
#* description: path settings<br />
#* author: Zhou zeyan<br />
#* version: 31.08.2000<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry-5">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment-5">environment</h1>

<p>#******************************************************************************<br />
set say = &ldquo;echo&rdquo;<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="path-settings">path settings</h1>

<p>#******************************************************************************<br />
if ($?path) then<br />
set path=($HOME/userlib $path)<br />
else<br />
set path=($HOME/bin /usr/bin .)<br />
endif</p>

<p>#******************************************************************************</p>

<h1 id="exit-4">exit</h1>

<p>#******************************************************************************<br />
exit</p>

<p>#******************************************************************************<br />
#* Copyright &copy; BS P4 2000. All Rights Reserved. Confidental *<br />
#******************************************************************************</p>

<h1 id="def-user">def_user</h1>

<p>#******************************************************************************<br />
#* Copyright &copy; BS P4 2000. All Rights Reserved. Confidental *<br />
#******************************************************************************</p>

<p>#******************************************************************************<br />
#* module: def_user<br />
#* description: user command settings<br />
#* author: Zhou zeyan<br />
#* version: 31.08.2000<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry-6">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment-6">environment</h1>

<p>#******************************************************************************<br />
set say = &ldquo;echo&rdquo;<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="pathes-3">pathes</h1>

<p>#******************************************************************************<br />
set path_project_com1 = &ldquo;${PROJ_DIR}/login/com&rdquo;<br />
set path_project_com2 = &ldquo;${path_project_com1}/com&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="user-command-settings-1">user command settings</h1>

<p>#******************************************************************************<br />
alias cdproj &ldquo;cd ${PROJ_DIR}&rdquo;<br />
alias cdmkf &ldquo;cd ${PROJ_DIR}/mkf&rdquo;<br />
alias cdglb &ldquo;cd ${PROJ_DIR}/glb&rdquo;<br />
alias cdutl &ldquo;cd ${PROJ_DIR}/utl&rdquo;<br />
alias cdcom &ldquo;cd ${PROJ_DIR}/com&rdquo;<br />
alias cdlog &ldquo;cd ${PROJ_DIR}/log&rdquo;<br />
alias cdtel &ldquo;cd ${PROJ_DIR}/tel&rdquo;<br />
alias cdtools &ldquo;cd ${PROJ_DIR}/tools&rdquo;<br />
alias cdcomtcp &ldquo;cd ${PROJ_DIR}/comtcp&rdquo;<br />
alias cdexport &ldquo;cd ${PROJ_DIR}/export&rdquo;<br />
alias cdoracle &ldquo;cd ${PROJ_DIR}/oracle&rdquo;<br />
alias cdsystem &ldquo;cd ${PROJ_DIR}/system&rdquo;<br />
alias cds &ldquo;cd /home/zzy/system&rdquo;<br />
alias cdbuild &ldquo;cd ${PROJ_DIR}/oracle/build&rdquo;<br />
alias cdzzy &ldquo;cd /home/zzy&rdquo;</p>

<h1 id="make-environments-1">make environments</h1>

<p>alias mkglb &ldquo;make -f ${PROJ_DIR}/glb/work/etc/glb.mkf&rdquo;<br />
alias mkutl &ldquo;make -f ${PROJ_DIR}/utl/work/etc/utl.mkf&rdquo;<br />
alias mkcomtcp &ldquo;make -f ${PROJ_DIR}/comtcp/work/etc/comtcp.mkf&rdquo;<br />
alias mkuserlib &ldquo;make -f ${PROJ_DIR}/userlib/userlib.mkf&rdquo;</p>

<p>#******************************************************************************</p>

<h1 id="exit-5">exit</h1>

<p>#******************************************************************************<br />
unset path_project_com1<br />
unset path_project_com2<br />
exit</p>

<p>#******************************************************************************<br />
#* Copyright &copy; BS P4 2000. All Rights Reserved. Confidental *<br />
#******************************************************************************</p>

<h1 id="welcome-1">welcome</h1>

<p>#******************************************************************************<br />
#* Copyright &copy; BS 2000. All Rights Reserved. Confidental *<br />
#******************************************************************************</p>

<p>#******************************************************************************<br />
#* module: welcome<br />
#* description: welcome<br />
#* author: Zhou zeyan<br />
#* version: 31.08.2000<br />
#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="entry-7">entry</h1>

<p>#******************************************************************************</p>

<p>#******************************************************************************</p>

<h1 id="environment-7">environment</h1>

<p>#******************************************************************************<br />
set say = &ldquo;echo&rdquo;<br />
set mode = &ldquo;&rdquo;<br />
set node = &ldquo;<code>uname -n</code>&rdquo;<br />
set user = &ldquo;<code>logname</code>&ldquo;</p>

<p>#******************************************************************************</p>

<h1 id="pathes-4">pathes</h1>

<p>#******************************************************************************<br />
set path_project_com1 = &ldquo;${PROJ_DIR}/login/com&rdquo;<br />
set path_project_com2 = &ldquo;${path_project_com1}/com&rdquo;</p>

<p>#**********************************************************************</p>

<h1 id="welcome-2">welcome</h1>

<p>#**********************************************************************<br />
set text6=&rdquo; user: $user &ldquo;<br />
set text7=&rdquo; node: $node &ldquo;</p>

<p>echo &ldquo;&rdquo;<br />
echo &ldquo;=======================================================================&rdquo;<br />
echo &ldquo;&rdquo;<br />
echo &ldquo; +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&rdquo;<br />
echo &ldquo; | |&rdquo;<br />
echo &ldquo; | ###### ####### ####### ####### |&rdquo;<br />
echo &ldquo; | # # # # # |&rdquo;<br />
echo &ldquo; | # # # # # |&rdquo;<br />
echo &ldquo; | ###### # ####### # |&rdquo;<br />
echo &ldquo; | # # # # |&rdquo;<br />
echo &ldquo; | # # # # |&rdquo;<br />
echo &ldquo; | # ####### # ####### |&rdquo;<br />
echo &ldquo; | |&rdquo;<br />
echo &ldquo; +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&rdquo;<br />
echo &ldquo;&rdquo;<br />
echo &ldquo;=======================================================================&rdquo;<br />
echo &ldquo; B S&rdquo;<br />
echo &ldquo;=======================================================================&rdquo;<br />
echo &ldquo;$text6&rdquo;<br />
echo &ldquo;&rdquo;<br />
echo &ldquo;$text7&rdquo;<br />
echo &ldquo;=======================================================================&rdquo;<br />
echo &ldquo;&rdquo;<br />
unset text6<br />
unset text7</p>

<p>#**********************************************************************</p>

<h1 id="exit-6">exit</h1>

<p>#**********************************************************************<br />
unset path_project_com1<br />
unset path_project_com2<br />
exit</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>PM 信息 发邮件 复制 引用 回复 编辑 删除 [文艺天地 | 万有科学 | 汗青简牍 | 朝夕问道] 积分: 150 5 10 20 30 40 50
-5 -10 -20 -30 -40 -50</p>

<p>quickleader [同济人]</p>

<p>CS. Tongji Universitat</p>

<p>来自: Tongji UniversitY<br />
积分: 150</p>

<p>注册: 2002-06-20<br />
发贴: 5893<br />
[ 校园布告 | 有问有答 ]<br />
[ 论坛规则 | RSS订阅 ]<br />
Re:shell programming 发表于 : 2004-07-16 17:09:32 来源：BBS.TONGJI.NET</p>

<p>shell编程例子 &ndash; 一个.login例子<br />
本文出自: 作者: (2001-10-01 10:00:00)</p>

<hr />

<h1 id="toc_107">* *</h1>

<h1 id="or-in-far-52-227-19-as-applicable">* or in FAR 52.227-19, as applicable. *</h1>

<h1 id="toc_109">* *</h1>

<h1 id="toc_110">*****************************************************************</h1>

<h1 id="history-2">HISTORY</h1>

<h1 id="rcsfile-login-v-revision-4-1-7-3-dec-date-1995-10-25">@(#)$RCSfile: .login,v $ $Revision: 4.1.7.3 $ (DEC) $Date: 1995/10/25</h1>

<p>20:03:52<br />
$</p>

<p>if ($?path) then<br />
set path=($HOME/bin $path)<br />
else<br />
set path=($HOME/bin /usr/bin .)<br />
endif<br />
if ( ! ${?DT} ) then<br />
stty dec new<br />
tset -I -Q<br />
endif<br />
set mail=/usr/spool/mail/$USER</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>PM 信息 发邮件 复制 引用 回复 编辑 删除 [文艺天地 | 万有科学 | 汗青简牍 | 朝夕问道] 积分: 150 5 10 20 30 40 50
-5 -10 -20 -30 -40 -50</p>

<p>quickleader [同济人]</p>

<p>CS. Tongji Universitat</p>

<p>来自: Tongji UniversitY<br />
积分: 150</p>

<p>注册: 2002-06-20<br />
发贴: 5893<br />
[ 校园布告 | 有问有答 ]<br />
[ 论坛规则 | RSS订阅 ]<br />
Re:shell programming 发表于 : 2004-07-16 17:09:51 来源：BBS.TONGJI.NET</p>

<p>shell编程例子 &ndash; 一个makefile例子<br />
本文出自: 作者: (2001-10-01 12:00:00)</p>

<h1 id="unix-mkf">unix.mkf</h1>

<p>#=============================================================================#</p>

<h1 id="copyright-c-bs-p4-2000-all-rights-reserved-confidential">Copyright &copy; BS P4 2000. All Rights Reserved. Confidential #</h1>

<p>#=============================================================================#</p>

<p>#=============================================================================#</p>

<h1 id="module-unix-mkf">module: unix.mkf #</h1>

<h1 id="description-global-include-for-all-makefiles">description: global include for all makefiles #</h1>

<h1 id="system-unix">system UNIX #</h1>

<h1 id="version-2000-08-01">version: 2000.08.01 #</h1>

<h1 id="author-zhou-zeyan">Author: Zhou zeyan #</h1>

<p>#=============================================================================#</p>

<p>#=============================================================================#</p>

<h1 id="processline">processline #</h1>

<p>#=============================================================================#<br />
PLINE = PCFC</p>

<p>#=============================================================================#</p>

<h1 id="useful">useful #</h1>

<p>#=============================================================================#<br />
NOTHING =<br />
BLANC = $(NOTHING) $(NOTHING)<br />
SAY = $(BLANC)echo$(BLANC)<br />
CONTINUE = $(BLANC)echo&rdquo;&ldquo;&gt;/dev/null$(BLANC)<br />
IF = $(BLANC)if$(BLANC)<br />
THEN = ;then$(BLANC)<br />
FI = ;fi$(BLANC)<br />
FSY = [ -f$(BLANC)<br />
FSN = [ ! -f$(BLANC)<br />
FSE = $(BLANC)]$(BLANC)<br />
CP = cp$(BLANC)<br />
RCP = rcp$(BLANC)<br />
PU = echo&gt;/dev/null&lt;<br />
RM = rm$(BLANC)<br />
DTOU = dos2unix<br />
SS =<br />
SM1 = .*</p>

<p>#=============================================================================#</p>

<h1 id="home-device-and-directory">home device and directory #</h1>

<p>#=============================================================================#<br />
DEVHOME = /<br />
DIRHOME = home/$(PROJ)</p>

<p>#=============================================================================#</p>

<h1 id="global-directories">global directories #</h1>

<p>#=============================================================================#<br />
GLOBALDOS = $(DEVHOME)$(DIRHOME)/dos/<br />
GLOBALMKF = $(DEVHOME)$(DIRHOME)/mkf/</p>

<p>#=============================================================================#</p>

<h1 id="include-application-mkf">Include application mkf #</h1>

<p>#=============================================================================#<br />
include $(GLOBAL_MKF_HOME)$(PROJ).mkf</p>

<p>#=============================================================================#</p>

<h1 id="oracle-directories">oracle directories #</h1>

<p>#=============================================================================#<br />
ORAINC = $(ORACLE_HOME)/precomp/public/</p>

<p>#=============================================================================#</p>

<h1 id="system-directories">system directories #</h1>

<p>#=============================================================================#<br />
SYSINC = /usr/include/<br />
SYSINC2 = /usr/include/sys/</p>

<p>#=============================================================================#</p>

<h1 id="file-extensions">file extensions #</h1>

<p>#=============================================================================#<br />
EXTCOM =<br />
EXTORS = .pc<br />
EXTSRC = .c<br />
EXTINC = .h<br />
EXTOBJ = .o<br />
EXTLIB = .a<br />
EXTSHL =<br />
EXTBIN =<br />
EXTLIS = .lis</p>

<p>#=============================================================================#</p>

<h1 id="all-include-pathes">all include pathes #</h1>

<p>#=============================================================================#<br />
OCALLINC = $(BLANC)include=$(GLBINC) include=$(UTLINC) include=$(COMINC)<br />
include=$(PKSINC) include=$(ORAINC) include=$(SIIXINC) include=$(CCMINC)<br />
include=$(SYSINC) include=$(SYSINC2)</p>

<p>#=============================================================================#</p>

<h1 id="depencies-for-objects">depencies for objects #</h1>

<p>#=============================================================================#<br />
GLBINC_ELE = $(GLBINC)ch_names.h $(GLBINC)cgl_inc.h $(GLBINC)tele_l1.h /<br />
$(GLBINC)tele_l2.h<br />
UTLINC_ELE = $(UTLINC)utl_inc.h $(UTLINC)utl_db_i.h<br />
COMINC_ELE = $(COMINC)comp.h $(COMINC)dbgp.h<br />
PKSINC_ELE = $(PKSINC)pks_comm.h<br />
MVAINC_ELE =<br />
MTINC_ELE =<br />
ORAINC_ELE = $(ORAINC)sqlca.h<br />
SIIXINC_ELE = $(SIIXINC)pdv_errno.h $(SIIXINC)ppx_errno.h<br />
CCMINC_ELE = $(CCMINC)pcm_defs_u.h<br />
SYSINC_ELE = $(SYSINC)stdio.h</p>

<p>#=============================================================================#</p>

<h1 id="depencies-for-binaries">depencies for binaries #</h1>

<p>#=============================================================================#<br />
GLBLIB_ELE =<br />
UTLLIB_ELE = $(UTLLIB)libutl.a<br />
COMLIB_ELE = $(COMLIB)libcom.a<br />
USERLIB_ELE = $(USERLIBHOME)userlib.a<br />
ORALIB_ELE = $(ORACLE_HOME)/lib/libsql.a<br />
SIIXLIB_ELE =<br />
CCMLIB_ELE = /opt/SiiXdvl/lib/libpics.a /opt/SiiXdvl/lib/libpdi.a /<br />
/usr/lib/libnsl.so<br />
SYSLIB_ELE = /usr/lib/libm.a<br />
SOCKLIB_ELE = /usr/lib/libsocket.a /usr/lib/libdl.so /usr/lib/libintl.so</p>

<p>#=============================================================================#</p>

<h1 id="libraries-for-binaries">libraries for binaries #</h1>

<p>#=============================================================================#<br />
LIBGLB =<br />
LIBUTL = $(BLANC)$(UTLLIB)libutl.a<br />
LIBCOM = $(BLANC)$(COMLIB)libcom.a<br />
LIBUSER = $(BLANC)$(USERLIBHOME)userlib.a<br />
LIBMVA =<br />
LIBMT =<br />
LIBORA = $(BLANC)-L$(PROLDLIBS)<br />
LIBSIIX =<br />
LIBCCM = $(BLANC)/opt/SiiXdvl/lib/libpics.a /opt/SiiXdvl/lib/libpdi.a /<br />
/usr/lib/libnsl.so.1<br />
LIBSYS = $(BLANC)/usr/lib/libm.so<br />
LIBSOCK = $(BLANC)/usr/lib/libsocket.so /usr/lib/libdl.so /usr/lib/libintl.so</p>

<p>#=============================================================================#</p>

<h1 id="oracle-compiler">Oracle Compiler #</h1>

<p>#=============================================================================#</p>

<h1 id="name-of-compiler">name of compiler</h1>

<p>OC = $(ORACLE_HOME)/bin/proc</p>

<h1 id="compilerflags-and-switches">compilerflags and -switches</h1>

<p>OCINC = include=<br />
OCOPT = config=$(GLOBALMKF)proc.cfg</p>

<p>#=============================================================================#</p>

<h1 id="compiler">Compiler #</h1>

<p>#=============================================================================#</p>

<h1 id="name-of-compiler-1">name of compiler</h1>

<p>CC = /usr/bin/cc</p>

<h1 id="compilerflags-and-switches-1">compilerflags and -switches</h1>

<p>CCINC = -I<br />
CCDEBUG = $(debug:1=-g)</p>

<h1 id="comment-by-zzy-ccopt-c-ddebug-ccdebug">comment by zzy CCOPT = -c -DDEBUG $(CCDEBUG)</h1>

<p>CCOPT = -c $(CCDEBUG)</p>

<h1 id="flag-for-objectfile">flag for objectfile</h1>

<p>CCOBJ = -o</p>

<p>#=============================================================================#</p>

<h1 id="create-and-make-library">create and make library #</h1>

<p>#=============================================================================#</p>

<h1 id="create-library">create library</h1>

<p>CL = /usr/bin/ar -rc</p>

<h1 id="make-library">make library</h1>

<p>ML = /usr/bin/ar -rcv</p>

<h1 id="separator-between-objectfiles">separator between objectfiles</h1>

<p>MLS =</p>

<p>#=============================================================================#</p>

<h1 id="oracle-linker">Oracle Linker #</h1>

<p>#=============================================================================#</p>

<h1 id="name-of-oracle-linker">name of oracle linker</h1>

<p>OL = cc -o</p>

<h1 id="linkerflags-and-switches">linkerflags and -switches</h1>

<p>OLDEBUG = $(debug:1=-g)<br />
OLOPT = $(OLDEBUG)</p>

<h1 id="librarymark-for-object-library">librarymark for object library</h1>

<p>OLOL =</p>

<h1 id="librarymark-for-shared-library">librarymark for shared-library</h1>

<p>OLSL =</p>

<h1 id="separator-between-objectfiles-1">separator between objectfiles</h1>

<p>OLS = $(BLANC)</p>

<p>#=============================================================================#</p>

<h1 id="linker">Linker #</h1>

<p>#=============================================================================#</p>

<h1 id="name-of-linker">name of linker</h1>

<p>LD = /usr/bin/cc</p>

<h1 id="linkerflags-und-switches">linkerflags und -switches</h1>

<p>LDDEBUG = $(debug:1=-g)<br />
LDOPT = -o $(LDDEBUG)</p>

<h1 id="librarymark-for-object-library-1">librarymark for object library</h1>

<p>LDOL =</p>

<h1 id="librarymark-for-shared-library-1">librarymark for shared-library</h1>

<p>LDSL =</p>

<h1 id="separator-between-objectfiles-2">separator between objectfiles</h1>

<p>LDS =</p>

<p>#=============================================================================#</p>

<h1 id="copyright-c-bs-p4-2000-all-rights-reserved-confidential-1">Copyright &copy; BS P4 2000. All Rights Reserved. Confidential #</h1>

<p>#=============================================================================#</p>

<h1 id="host-mkf">host.mkf</h1>

<p>#=============================================================================#</p>

<h1 id="copyright-c-bs-p4-2000-all-rights-reserved-confidential-2">Copyright &copy; BS P4 2000. All Rights Reserved. Confidential #</h1>

<p>#=============================================================================#</p>

<p>#=============================================================================#</p>

<h1 id="module-pcfc-mkf">module: pcfc.mkf #</h1>

<h1 id="description-application-include-for-all-makefiles">description: application include for all makefiles #</h1>

<h1 id="system-unix-1">system UNIX #</h1>

<h1 id="version-2000-08-01-1">version: 2000.08.01 #</h1>

<h1 id="author-zhou-zeyan-1">Author: Zhou zeyan #</h1>

<p>#=============================================================================#</p>

<p>#=============================================================================#</p>

<h1 id="userlib-directories">USERLIB directories #</h1>

<p>#=============================================================================#<br />
USERLIBHOME = $(DEVHOME)$(DIRHOME)/userlib/</p>

<p>#=============================================================================#</p>

<h1 id="comtcp-directories">COMTCP directories #</h1>

<p>#=============================================================================#<br />
COMTCPHOME = $(DEVHOME)$(DIRHOME)/comtcp/<br />
COMTCPWORKETC = $(COMTCPHOME)work/etc/<br />
COMTCPWORKSRC = $(COMTCPHOME)work/src/<br />
COMTCPWORKINC = $(COMTCPHOME)work/inc/<br />
COMTCPWORKOBJ = $(COMTCPHOME)work/obj/<br />
COMTCPWORKLIB = $(COMTCPHOME)work/lib/<br />
COMTCPWORKBIN = $(COMTCPHOME)work/bin/<br />
COMTCPWORKLIS = $(COMTCPHOME)work/src/<br />
COMTCPSRC = $(COMTCPHOME)work/src/<br />
COMTCPLIS = $(COMTCPHOME)work/src/<br />
COMTCPETC = $(COMTCPHOME)etc/<br />
COMTCPINC = $(COMTCPHOME)inc/<br />
COMTCPOBJ = $(COMTCPHOME)obj/<br />
COMTCPLIB = $(COMTCPHOME)lib/<br />
COMTCPBIN = $(COMTCPHOME)bin/</p>

<p>#=============================================================================#</p>

<h1 id="copyright-c-bs-p4-2000-all-rights-reserved-confidential-3">Copyright &copy; BS P4 2000. All Rights Reserved. Confidential #</h1>

<p>#=============================================================================#</p>

<h1 id="application-mkf">application.mkf</h1>

<p>#=============================================================================#</p>

<h1 id="copyright-c-bs-ag-1998-all-rights-reserved-confidential">Copyright &copy; BS AG 1998. All Rights Reserved. Confidential #</h1>

<p>#=============================================================================#</p>

<p>#=============================================================================#</p>

<h1 id="toc_169">#</h1>

<h1 id="project">Project : #</h1>

<h1 id="bao-crm3-cgl-level-2">BAO CRM3 CGL - Level 2 #</h1>

<h1 id="toc_172">#</h1>

<h1 id="module-name">module name : #</h1>

<h1 id="de-mkf">de.mkf #</h1>

<h1 id="toc_175">#</h1>

<h1 id="task">Task #</h1>

<h1 id="makefile-for-programe-de">Makefile for programe de #</h1>

<h1 id="toc_178">#</h1>

<h1 id="author">Author #</h1>

<h1 id="zhou-zeyan">Zhou zeyan #</h1>

<h1 id="toc_181">#</h1>

<h1 id="begin-of-implementation">Begin of implementation #</h1>

<h1 id="dec-31-1998">Dec.31, 1998 #</h1>

<h1 id="toc_184">#</h1>

<h1 id="update">Update #</h1>

<h1 id="zhou-zeyan-1">Zhou zeyan #</h1>

<h1 id="toc_187">#</h1>

<h1 id="update-date">Update date #</h1>

<h1 id="feb-12-1999">Feb.12, 1999 #</h1>

<h1 id="toc_190">#</h1>

<h1 id="release">Release #</h1>

<h1 id="version-1-00">Version 1.00 #</h1>

<h1 id="toc_193">#</h1>

<h1 id="definition">Definition #</h1>

<h1 id="make-f-de-mkf">make -f de.mkf #</h1>

<h1 id="toc_196">#</h1>

<h1 id="parameters">Parameters #</h1>

<h1 id="no-parameters">No parameters #</h1>

<h1 id="toc_199">#</h1>

<h1 id="return-code">Return code #</h1>

<h1 id="no-return-code">No return code #</h1>

<h1 id="toc_202">#</h1>

<p>#=============================================================================#</p>

<p>#=============================================================================#</p>

<h1 id="global-include">global include #</h1>

<p>#=============================================================================#<br />
include $(GLOBAL_MKF_HOME)$(OS).mkf</p>

<p>#=============================================================================#</p>

<h1 id="directories-files">directories/files #</h1>

<p>#=============================================================================#<br />
DOS = $(DEWORKDOS)<br />
ETC = $(DEWORKETC)<br />
SRC = $(DEWORKSRC)<br />
INC = $(DEWORKINC)<br />
OBJ = $(DEWORKOBJ)<br />
LIB = $(DEWORKLIB)<br />
BIN = $(DEWORKBIN)<br />
MSC = $(DEWORKMSC)<br />
LIS = $(DEWORKLIS)<br />
RUNETC = $(DEETC)<br />
RUNSRC = $(DESRC)<br />
RUNINC = $(DEINC)<br />
RUNOBJ = $(DEOBJ)<br />
RUNLIB = $(DELIB)<br />
RUNBIN = $(DEBIN)<br />
RUNMSC = $(DEMSC)</p>

<p>INAM_1 = qdr_inc</p>

<p>SNAM_1 = qdr<br />
SNAM_2 = qdr_list<br />
SNAM_3 = de</p>

<p>ONAM_1 = $(SNAM_1)<br />
ONAM_2 = $(SNAM_2)<br />
ONAM_3 = $(SNAM_3)</p>

<p>LNAM_1 = qdr</p>

<p>BNAM_2 = $(SNAM_2)<br />
BNAM_3 = $(SNAM_3)x</p>

<p>IMOD_1 = $(INC)$(INAM_1)$(EXTINC)</p>

<p>PMOD_1 = $(SRC)$(SNAM_1)$(EXTORS)<br />
SMOD_1 = $(SRC)$(SNAM_1)$(EXTSRC)<br />
PMOD_2 = $(SRC)$(SNAM_2)$(EXTORS)<br />
SMOD_2 = $(SRC)$(SNAM_2)$(EXTSRC)<br />
PMOD_3 = $(SRC)$(SNAM_3)$(EXTORS)<br />
SMOD_3 = $(SRC)$(SNAM_3)$(EXTSRC)</p>

<p>OMOD_1 = $(OBJ)$(ONAM_1)$(EXTOBJ)<br />
OMOD_2 = $(OBJ)$(ONAM_2)$(EXTOBJ)<br />
OMOD_3 = $(OBJ)$(ONAM_3)$(EXTOBJ)</p>

<p>LMOD_1 = $(LIB)$(LNAM_1)$(EXTLIB)</p>

<p>BMOD_2 = $(BIN)$(BNAM_2)$(EXTBIN)<br />
BMOD_3 = $(BIN)$(BNAM_3)$(EXTBIN)</p>

<p>LIST_1 = $(LIS)$(SNAM_1)$(EXTLIS)</p>

<p>RUN_IMOD_1 = $(RUNINC)$(INAM_1)$(EXTINC)<br />
RUN_BMOD_2 = $(RUNBIN)$(BNAM_2)$(EXTBIN)<br />
RUN_BMOD_3 = $(RUNBIN)$(BNAM_3)$(EXTBIN)<br />
RUN_LMOD_1 = $(RUNLIB)$(LNAM_1)$(EXTLIB)</p>

<p>#=============================================================================#</p>

<h1 id="generate">generate #</h1>

<p>#=============================================================================#<br />
all : src obj lib bin<br />
@ $(SAY) &ldquo;$(@) done !&rdquo;<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>src : $(SMOD_1) $(SMOD_2) $(SMOD_3)<br />
@ $(SAY) &ldquo;$(@) done !&rdquo;<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>obj : $(OMOD_1) $(OMOD_2) $(OMOD_3)<br />
@ $(SAY) &ldquo;$(@) done !&rdquo;<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>lib : $(LMOD_1)<br />
@ $(SAY) &ldquo;$(@) done !&rdquo;<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>bin : $(BMOD_2) $(BMOD_3)<br />
@ $(SAY) &ldquo;$(@) done !&rdquo;<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>#=============================================================================#</p>

<h1 id="sources">sources #</h1>

<p>#=============================================================================#<br />
$(SMOD_1) : $(PMOD_1) $(IMOD_1) /<br />
$(GLBINC_ELE) $(UTLINC_ELE) $(COMINC_ELE) $(PKSINC_ELE) /<br />
$(SIIXINC_ELE) $(CCMINC_ELE) /<br />
$(ORAINC_ELE) $(SYSINC_ELE)<br />
$(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(OC) iname=$(PMOD_1) $(OCINC)$(INC)$(OCALLINC) oname=$(@) /<br />
$(OCOPT)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>$(SMOD_2) : $(PMOD_2) $(IMOD_1) /<br />
$(GLBINC_ELE) $(UTLINC_ELE) $(COMINC_ELE) $(PKSINC_ELE) /<br />
$(SIIXINC_ELE) $(CCMINC_ELE) /<br />
$(ORAINC_ELE) $(SYSINC_ELE)<br />
$(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(OC) iname=$(PMOD_2) $(OCINC)$(INC)$(OCALLINC) oname=$(@) /<br />
$(OCOPT)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>$(SMOD_3) : $(PMOD_3) $(IMOD_1) /<br />
$(GLBINC_ELE) $(UTLINC_ELE) $(COMINC_ELE) $(PKSINC_ELE) /<br />
$(SIIXINC_ELE) $(CCMINC_ELE) /<br />
$(ORAINC_ELE) $(SYSINC_ELE)<br />
$(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(OC) iname=$(PMOD_3) $(OCINC)$(INC)$(OCALLINC) oname=$(@) /<br />
$(OCOPT)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>#=============================================================================#</p>

<h1 id="objects">objects #</h1>

<p>#=============================================================================#<br />
$(OMOD_1) : $(SMOD_1) $(IMOD_1) /<br />
$(GLBINC_ELE) $(UTLINC_ELE) $(COMINC_ELE) $(PKSINC_ELE) /<br />
$(SIIXINC_ELE) $(CCMINC_ELE) /<br />
$(ORAINC_ELE) $(SYSINC_ELE)<br />
@ $(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(CC) $(CCOPT)$(LIS) /<br />
$(CCINC)$(INC) $(CCALLINC) $(CCOBJ)$(@) $(SMOD_1)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>$(OMOD_2): $(SMOD_2) $(IMOD_1) /<br />
$(GLBINC_ELE) $(UTLINC_ELE) $(COMINC_ELE) $(PKSINC_ELE) /<br />
$(SIIXINC_ELE) $(CCMINC_ELE) /<br />
$(ORAINC_ELE) $(SYSINC_ELE)<br />
@ $(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(CC) $(CCOPT)$(LIS) /<br />
$(CCINC)$(INC) $(CCALLINC) $(CCOBJ)$(@) $(SMOD_2)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>$(OMOD_3): $(SMOD_3) $(IMOD_1) /<br />
$(GLBINC_ELE) $(UTLINC_ELE) $(COMINC_ELE) $(PKSINC_ELE) /<br />
$(SIIXINC_ELE) $(CCMINC_ELE) /<br />
$(ORAINC_ELE) $(SYSINC_ELE)<br />
@ $(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(CC) $(CCOPT)$(LIS) /<br />
$(CCINC)$(INC) $(CCALLINC) $(CCOBJ)$(@) $(SMOD_3)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>#=============================================================================#</p>

<h1 id="libraries">libraries #</h1>

<p>#=============================================================================#<br />
$(LMOD_1) : $(OMOD_1)<br />
@ $(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
@ $(IF) $(FSN) $(LMOD_1) $(FSE) $(THEN) $(CL) $(LMOD_1) $(FI)<br />
$(ML) $(LMOD_1) $(OMOD_1)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>#=============================================================================#</p>

<h1 id="binaries">binaries #</h1>

<p>#=============================================================================#<br />
$(BMOD_2) : $(OMOD_2) /<br />
$(MTLIB_ELE) $(COMLIB_ELE) $(CCMLIB_ELE) /<br />
$(ORALIB_ELE) $(SYSLIB_ELE)<br />
@ $(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(OL) $(@) $(OMOD_2) $(LIBCOM) $(LIBUTL) $(LIBCCM) /<br />
$(LIBORA) $(LMOD_1) $(OLOPT)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>$(BMOD_3) : $(OMOD_3) /<br />
$(MTLIB_ELE) $(COMLIB_ELE) $(CCMLIB_ELE) /<br />
$(ORALIB_ELE) $(SYSLIB_ELE)<br />
@ $(SAY) &ldquo;+&mdash; make $(@) &mdash;+&rdquo;<br />
$(OL) $(@) $(OMOD_3) $(LIBCOM) /<br />
$(LIBUTL) $(LIBPKS) $(LIBCCM) $(LIBORA) $(LMOD_1) $(OLOPT)<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>#=============================================================================#</p>

<h1 id="export">export #</h1>

<p>#=============================================================================#<br />
export : /<br />
exportetc exportsrc exportinc exportobj exportlib exportbin exportmsc<br />
@ $(SAY) &ldquo;$(@) done !&rdquo;<br />
@ $(SAY) &ldquo;&rdquo;</p>

<p>exportetc :<br />
@ $(IF)$(FSY)$(RUNETC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(RUNETC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(RUNETC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(RUNETC) $(FI)</p>

<p>exportsrc :<br />
@ $(IF)$(FSY)$(RUNSRC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(RUNSRC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(RUNSRC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(RUNSRC) $(FI)</p>

<p>exportinc : $(RUN_IMOD_1)<br />
@ $(IF)$(FSY)$(RUNINC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(RUNINC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(RUNINC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(RUNINC) $(FI)<br />
$(RUN_IMOD_1) : $(IMOD_1)<br />
$(CP) $(IMOD_1) $(RUN_IMOD_1)</p>

<p>exportobj :<br />
@ $(IF)$(FSY)$(RUNOBJ)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(RUNOBJ)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(RUNOBJ)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(RUNOBJ) $(FI)</p>

<p>exportlib : $(RUN_LMOD_1)<br />
@ $(IF)$(FSY)$(RUNLIB)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(RUNLIB)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(RUNLIB)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(RUNLIB) $(FI)<br />
$(RUN_LMOD_1) : $(LMOD_1)<br />
$(CP) $(LMOD_1) $(RUN_LMOD_1)</p>

<p>exportbin : $(RUN_BMOD_2) $(RUN_BMOD_3)<br />
@ $(IF)$(FSY)$(RUNBIN)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(RUNBIN)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(RUNBIN)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(RUNBIN) $(FI)<br />
$(RUN_BMOD_2) : $(BMOD_2)<br />
$(CP) $(BMOD_2) $(RUN_BMOD_2)<br />
$(RUN_BMOD_3) : $(BMOD_3)<br />
$(CP) $(BMOD_3) $(RUN_BMOD_3)</p>

<p>exportmsc :<br />
@ $(IF)$(FSY)$(RUNMSC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(RUNMSC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(RUNMSC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(RUNMSC) $(FI)</p>

<p>#=============================================================================#</p>

<h1 id="delete-old">delete old #</h1>

<p>#=============================================================================#<br />
delold : /<br />
deloldetc deloldsrc deloldinc deloldobj deloldlib deloldbin deloldmsc /<br />
deloldlis<br />
@ $(SAY) &ldquo;$(@) done !&rdquo;<br />
@ $(SAY) &ldquo;&rdquo;<br />
deloldetc :<br />
@ $(IF)$(FSY)$(ETC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(ETC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(ETC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(ETC) $(FI)<br />
deloldsrc :<br />
@ $(IF)$(FSY)$(SRC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(SRC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(SRC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(SRC) $(FI)<br />
deloldinc :<br />
@ $(IF)$(FSY)$(INC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(INC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(INC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(INC) $(FI)<br />
deloldobj :<br />
@ $(IF)$(FSY)$(OBJ)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(OBJ)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(OBJ)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(OBJ) $(FI)<br />
deloldlib :<br />
@ $(IF)$(FSY)$(LIB)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(LIB)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(LIB)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(LIB) $(FI)<br />
deloldbin :<br />
@ $(IF)$(FSY)$(BIN)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(BIN)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(BIN)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(BIN) $(FI)<br />
deloldmsc :<br />
@ $(IF)$(FSY)$(MSC)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(MSC)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(MSC)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(MSC) $(FI)<br />
deloldlis :<br />
@ $(IF)$(FSY)$(LIS)<em>.</em>$(SM1)$(FSE)$(THEN)$(SAY)&ldquo;$(PU)$(LIS)&rdquo;$(FI)<br />
@ $(IF)$(FSY)$(LIS)<em>.</em>$(SM1)$(FSE)$(THEN) $(PU)$(LIS) $(FI)</p>

<p>#=============================================================================#</p>

<h1 id="clean">clean #</h1>

<p>#=============================================================================#<br />
clean : /<br />
cleanetc cleansrc cleaninc cleanobj cleanlib cleanbin cleanmsc /<br />
cleanlis<br />
@ $(SAY)&ldquo;$(@) done !&rdquo;<br />
@ $(SAY)&ldquo;&rdquo;<br />
cleanetc :<br />
@ $(CONTINUE)<br />
cleansrc :<br />
@ $(IF)$(FSY)$(SMOD_1) $(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(SMOD_1)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(SMOD_1) $(FSE)$(THEN) $(RM)$(SMOD_1)$(SS) $(FI)<br />
@ $(IF)$(FSY)$(SMOD_2) $(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(SMOD_2)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(SMOD_2) $(FSE)$(THEN) $(RM)$(SMOD_2)$(SS) $(FI)<br />
@ $(IF)$(FSY)$(SMOD_3) $(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(SMOD_3)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(SMOD_3) $(FSE)$(THEN) $(RM)$(SMOD_3)$(SS) $(FI)<br />
@ $(CONTINUE)<br />
cleaninc :<br />
@ $(CONTINUE)<br />
cleanobj :<br />
@ $(IF)$(FSY)$(OMOD_1) $(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(OMOD_1)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(OMOD_1) $(FSE)$(THEN) $(RM)$(OMOD_1)$(SS) $(FI)<br />
@ $(IF)$(FSY)$(OMOD_2) $(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(OMOD_2)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(OMOD_2) $(FSE)$(THEN) $(RM)$(OMOD_2)$(SS) $(FI)<br />
@ $(IF)$(FSY)$(OMOD_3) $(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(OMOD_3)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(OMOD_3) $(FSE)$(THEN) $(RM)$(OMOD_3)$(SS) $(FI)<br />
@ $(CONTINUE)<br />
cleanlib :<br />
@ $(IF)$(FSY)$(LMOD_1)$(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(LMOD_1)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(LMOD_1)$(FSE)$(THEN) $(RM)$(LMOD_1)$(SS) $(FI)<br />
@ $(CONTINUE)<br />
cleanbin :<br />
@ $(IF)$(FSY)$(BMOD_2)$(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(BMOD_2)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(BMOD_2)$(FSE)$(THEN) $(RM)$(BMOD_2)$(SS) $(FI)<br />
@ $(IF)$(FSY)$(BMOD_3)$(FSE)$(THEN)$(SAY)&ldquo;$(RM)$(BMOD_3)$(SS)&ldquo;$(FI)<br />
@ $(IF)$(FSY)$(BMOD_3)$(FSE)$(THEN) $(RM)$(BMOD_3)$(SS) $(FI)<br />
@ $(CONTINUE)<br />
cleanmsc :<br />
@ $(CONTINUE)<br />
cleanlis :<br />
@ $(CONTINUE)</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Bash最常见的激活模式</p>

<p>Bash最常见的激活模式是交互式和非交互式:<br />
1.交互式激活<br />
指其标准输入和输出都连接在终端上.又分为三种类型:login,非login,posix<br />
以及受限的shell.<br />
确定一个shell是否是交互式的可以通过检测$PS1环境变量.<br />
(1) 当Bash作为login shell被激活时,它将依次读取并执行以下文件:<br />
/etc/profile,~/.bash_profile,~/.bash_login,~/.profile<br />
使用&ndash;noprofile选项激活Bash可以禁止其读任何初始化文件<br />
在退出时执行 ~/.bash_logout 文件<br />
(2) 当Bash作为非login shell被激活时,它将读取并执行~/.bashrc<br />
使用&ndash;norc选项激活Bash可以禁止执行任何初始化文件,使用<br />
--rcfile file可以指定执行的初始化文件.<br />
(3) 当Bash作为posix模式被激活时,它将先检查$ENV变量是否定义.<br />
若定义,Bash读取并执行有$ENV变量扩展而得到的文件,否则不再<br />
执行任何初始化文件。<br />
(4) 当Bash作为受限模式被激活时,它除了禁止某些操作以外,其他行为<br />
于其他模式相同.受限操作有:改变目录,修改$SHELL和$PATH变量,<br />
运行exec,以绝对路径运行程序以及使用重定向.Bash 1.x中不包含<br />
受限模式.<br />
2.非交互式激活<br />
主要用来运行Shell脚本.启动后,Bash检查$BASH_ENV变量,若定义,<br />
这执行该变量指定文件中包含的命令.</p>

<p>Bash 的激活选项<br />
-c string 该选项表明string中包含了一条命令.如 bash -c ls ~<br />
-i 使Bash以交互式方式运行<br />
-r 使Bash以受限方式运行<br />
--login 使Bash以登录Shell方式运行<br />
--posix 使Bash遵循POSIX标准<br />
--verbose 使Bash显示所有其读入的输入行<br />
--help 打印Bash的使用信息<br />
--version 打印版本信息<br />
--noprofile<br />
--norc<br />
--rcfile file</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Bash中的变量</p>

<p>1.用户定义的变量<br />
用户定义的变量有字母数字及下划线组成,并且变量名的第一个字符不能为数字.<br />
与其它UNIX名字一样,变量名是大小写敏感的.<br />
对于变量,用户可按如下方式赋值:<br />
name = value<br />
在引用变量时,需在前面加$符号，用户也可以在变量间进行相互赋值,如:<br />
(前面的$是命令提示符)</p>

<p>$ JOHN = john<br />
$ NAME = $JOHN<br />
$ echo Hello $NAME<br />
Hello john</p>

<p>也可以用变量和其他字符组成新的字,这时可能需要把变量用{}括起,如:</p>

<p>$ SAT = Satur<br />
$ echo Today is ${SAT}day<br />
Today is Saturday</p>

<p>对于未赋值的变量,Bash以空值对待,用户也可以用unset命令清除给变量<br />
赋的值.</p>

<p>Bash中还可以使用数组变量,其赋值有两种:</p>

<p>(1) name[index] = value<br />
(2) name = (value1 &hellip; valuen) 此时下标从0开始</p>

<p>数组下标的范围没有任何限制,同时也不必使用连续的分量.</p>

<p>Bash中关于变量的内建命令有:</p>

<p>(1) declare和typeset.两者具有一样的功能.其选项有:<br />
[-/+]a 设置/撤消变量的数组属性<br />
[-/+]i 设置/撤消变量的整数属性<br />
[-/+]r 设置/撤消变量的只读属性<br />
[-/+]x 设置/撤消变量的输出属性<br />
-p var 显示变量属性<br />
(2) export和local.<br />
export把变量输出到环境中,用法为:<br />
export name<br />
export name = value</p>

<p>这里需要简单介绍一下export的作用:当Bash shell执行一个<br />
程序时,将首先为该程序建立一个新的执行环境,称为子shell,<br />
在Bash Shell中变量都是局部的,即它们只是在创建它们的子<br />
Shell中是有意义的,使用export后,变量被设置为全局变量,这<br />
时可以被其它子Shell所识别</p>

<p>local标记变量为局部的(如只能被函数内部使用),用法为:<br />
local name<br />
local name = value<br />
(3) readonly.<br />
指定变量为只读,执行后,改变量不能被再次赋值,用法为:<br />
readonly name</p>

<p>2.位置变量或Shell参数<br />
Bash Shell在解释用户命令时,将把命令行的第一个子作为命令,而其它字作为<br />
参数通过位置变量传递给程序.$1,&hellip;,$9分别代表第一,&hellip;,九个参数.其中1-9<br />
是真正的参数名,&ldquo;$&ldquo;符只是用来标识变量的替换.<br />
位置变量$0指命令对应的可执行名.<br />
其它的还有:<br />
$# 送给命令的参数个数<br />
$@ 所有的参数,每个用双括号括起<br />
$* 所有的参数,用双括号括起<br />
3.与Shell有关的变量<br />
(1) Shell自身设置的一些常用变量:<br />
LINENO 正在执行的命令在脚本中的行号<br />
PWD 用户当前目录的全名<br />
OLDPWD 最近一次执行cd之前,用户当前目录的全名<br />
PPID 父进程ID<br />
$ 当前进程ID<br />
RANDOM 随机数(范围0-32767)<br />
SECONDS Bash Shell的运行时间,单位是秒<br />
REPLY select和read命令使用,以后会讲到<br />
OPTARG<br />
ORTIND 这两个变量由getopt命令设置<br />
UID 当前用户的User ID<br />
_ 上一条命令使用的最后一个参数<br />
(2) 影响Shell行为的一些常用环境变量:<br />
PATH 命令搜索路径,以冒号为分隔符.注意与DOS下不同的是,<br />
当前目录不在系统路径里<br />
HOME 用户home目录的路径名,是cd命令的默认参数<br />
COLUMNS 定义了命令编辑模式下可使用命令行的长度<br />
EDITOR 默认的行编辑器<br />
VISUAL 默认的可视编辑器<br />
FCEDIT 命令fc使用的编辑器<br />
HISTFILE 命令历史文件<br />
HISTSIZE 命令历史文件中最多可包含的命令条数<br />
HISTFILESIZE 命令历史文件中包含的最大行数<br />
IFS 定义SHELL使用的分隔符<br />
LOGNAME 用户登录名<br />
MAIL 指向一个需要SHELL监视其修改时间的文件.当该文件修改后,<br />
SHELL将发消息You hava mail给用户<br />
MAILCHECK SHELL检查MAIL文件的周期,单位是秒<br />
MAILPATH 功能与MAIL类似.但可以用一组文件,以冒号分隔,每个文件后<br />
可跟一个问号和一条发向用户的消息<br />
SHELL SHELL的路径名<br />
TERM 终端类型<br />
TMOUT SHELL自动退出的时间,单位为秒,若设为0则禁止SHELL自动退出<br />
PROMPT_COMMAND 指定在主命令提示符前应执行的命令<br />
PS1 主命令提示符<br />
PS2 二级命令提示符,命令执行过程中要求输入数据时用<br />
PS3 select的命令提示符<br />
PS4 调试命令提示符<br />
MANPATH 寻找手册页的路径,以冒号分隔<br />
LD_LIBRARY_PATH 寻找库的路径,以冒号分隔</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>Bash中的特殊字符</p>

<p>1.通配符<br />
* 匹配任何长度的任何串<br />
? 匹配单个字符<br />
[&hellip;] 匹配单个括号内的字符,[]中的-,!具有特殊含义,如:<br />
$ echo [a-z]*<br />
显示首字母在a-z范围内的文件或目录名<br />
$ echo [a,b]*<br />
显示首字母为a或b的文件或目录名<br />
$ echo [!a]*<br />
显示首字母不为a的文件或目录名(使用!时,!必须是[后的第一个字符)<br />
!还可与-和,一起使用</p>

<p>在Bash 2.0以后的版本中,若用shopt打开了extglob选项(shopt -s extglob),<br />
那么还可以扩展的模式表达式(模式表达式是指那些包含了一个或多个shell通配<br />
符的字):<br />
*(pattern [|pattern] &hellip;) 匹配模式的零次或多次出现<br />
+(pattern [|pattern] &hellip;) 匹配模式的一次或多次出现<br />
@(pattern [|pattern] &hellip;) 匹配模式的一次出现<br />
?(pattern [|pattern] &hellip;) 匹配任何一个模式.与*不同的是它不匹配<br />
多个模式或模式的重复出现<br />
!(pattern [|pattern] &hellip;) 与?类似,不过是不包括指定模式的串<br />
应该注意到,模式表达式的定义是递归的,每个表达式都可以包含一个或多个<br />
模式,而且模式表达式也是可以嵌套的.</p>

<p>2.数据或程序控制使用的特殊字符:<br />
主要有:<br />
&gt; (file) 输出重定向到文件<br />
&gt;&gt; (file) 输出重定向到文件,内容加到已存在的文件尾部<br />
&lt; (file) 输入重定向到文件<br />
; 命令分隔符<br />
| 管道符,把一条命令的输出重定向为另一命令的输入<br />
&amp; 放在命令之后强迫命令在后台执行<br />
`` 命令替换,重定向一条命令的输出为另一命令的参数</p>

<p>3.用于引用和逃逸的特殊字符:<br />
逃逸符/ 表示以后的字符不具有特殊的含义或不是Shell的函数,<br />
除此之外,Bash还可以识别一些C语言中的转义序列,如:<br />
/a 响伶<br />
/b 回退<br />
/e Escape<br />
/n 换行<br />
/r 回车<br />
/t 制表<br />
/v 制表<br />
// 反斜线<br />
/nnn 八进制的ASCII编码<br />
/xnnn 十六进制的ASCII编码<br />
但必须以如下方式进行引用:<br />
$&lsquo;string&rsquo;<br />
引用符&rsquo;和&rdquo; 将特殊字符或由空白分隔的字引用起来组成一个简单字符串<br />
两者区别在与,双引号内的内容可以进行参数和变量替换</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>