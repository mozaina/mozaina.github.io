<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell编程笔记文本处理awk | 开发者问答集锦</title>
    <meta property="og:title" content="shell编程笔记文本处理awk - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell编程笔记文本处理awk">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86awk/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell编程笔记文本处理awk</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>##</p>

<h2 id="第八章-文本处理利器-awk">第八章 文本处理利器 AWK</h2>

<p>AWK是一种优良的文本处理工具。它不仅是Linux 中也是任何环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人
Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母）的最大功能取决于一个人所拥有的知识。AWK
提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。实际上
AWK 的确拥有自己的语言：AWK
程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>

<p>最简单地说， AWK 是一种用于处理文本的编程语言工具。AWK 在很多方面类似于 shell 编程语言，尽管 AWK
具有完全属于其本身的语法。它的设计思想来源于 SNOBOL4 、sed 、Marc Rochkind设计的有效性语言、语言工具 yacc 和 lex
，当然还从 C 语言中获取了一些优秀的思想。在最初创造 AWK
时，其目的是用于文本处理，并且这种语言的基础是，只要在输入数据中有模式匹配，就执行一系列指令。该实用工具扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。</p>

<p>尽管操作可能会很复杂，但命令的语法始终是：</p>

<p>awk &lsquo;{pattern + action}&rsquo; 或者 awk&rsquo;pattern {action}&rsquo;</p>

<p>其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号 ({})
不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。</p>

<p>gawk 是 AWK 的 GNU 版本。</p>

<p>一般的UNIX作业系统，本身即附有AWK，不同的UNIX作业系统所附的AWK其版本亦不尽相同，若读者所使用的系统上未附有AWK，可通过anonymous
ftp 到下列地方取得：</p>

<p>phi./pub/gnu</p>

<p>ftp/UNIX/gnu</p>

<p>preppub/gnu</p>

<p>注解：一种编程语言，因其模式匹配语法而特别有用，通常用于数据检索和数据转换。一个GNU版本称为Gawk。</p>

<h4 id="小案例">小案例</h4>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat  /etc/fstab
/dev/VolGroup00/LogVol00 /                       ext3    defaults        1 1
LABEL=/boot             /boot                   ext3    defaults        1 2
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
/dev/VolGroup00/LogVol01 swap                    swap    defaults        0 0
[houchangren@ebsdi-23260-oozie shell]$ awk  '{print $0}'  /etc/fstab
/dev/VolGroup00/LogVol00 /                       ext3    defaults        1 1
LABEL=/boot             /boot                   ext3    defaults        1 2
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                 /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
/dev/VolGroup00/LogVol01 swap                    swap   defaults        0 0
[houchangren@ebsdi-23260-oozie shell]$ awk  '{print}'  /etc/fstab
/dev/VolGroup00/LogVol00 /                       ext3    defaults        1 1
LABEL=/boot             /boot                   ext3    defaults        1 2
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
/dev/VolGroup00/LogVol01 swap                    swap    defaults        0 0
[houchangren@ebsdi-23260-oozie shell]$ awk  '{print $1}'  /etc/fstab
/dev/VolGroup00/LogVol00
LABEL=/boot
tmpfs
devpts
sysfs
proc
/dev/VolGroup00/LogVol01
[houchangren@ebsdi-23260-oozie shell]$ awk  '{print &quot;I am test&quot;}'  /etc/fstab
I am test
I am test
I am test
I am test
I am test
I am test
I am test
[houchangren@ebsdi-23260-oozie shell]$
</code></pre>

<p>在文件 /etc/fstab中有六列</p>

<p>Device 装置名称</p>

<p>MountPoint 挂入点</p>

<p>Fstype 挂入类型</p>

<p>Options 参数</p>

<p>Dump 备份标示</p>

<p>Pass检查顺序，fsck用</p>

<p>关于fstab详细可参考：<br />
<a href="http://hi.baidu.com/iezunhfiybhiour/item/e0348e8ca7c6562e100ef3ce">http://hi.baidu.com/iezunhfiybhiour/item/e0348e8ca7c6562e100ef3ce</a></p>

<p><strong>awk解释：</strong></p>

<p>awk 是默认逐行读取，I am test 打印了，对应的行，</p>

<p>print $0就等于 print</p>

<p>print $1就取第一列。</p>

<h4 id="基本语法">基本语法</h4>

<h5 id="多个字段">多个字段</h5>

<p>awk常常被用于处理字段。所谓字段，就是在文本文件中，每一行分成许多列，列与列之间</p>

<p>用特定的符一号隔开。awk在这方面的处理能力特别强。</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ awk '{print $1}' /etc/fstab
/dev/VolGroup00/LogVol00
LABEL=/boot
tmpfs
devpts
sysfs
proc
/dev/VolGroup00/LogVol01
[houchangren@ebsdi-23260-oozie shell]$ awk '{print $1 &quot;\t &quot; $3}' /etc/fstab
/dev/VolGroup00/LogVol00         ext3
LABEL=/boot      ext3
tmpfs   tmpfs
devpts  devpts
sysfs   sysfs
proc    proc
/dev/VolGroup00/LogVol01         swap
[houchangren@ebsdi-23260-oozie shell]$ awk '{print &quot;device:&quot; $1 &quot;\tfstype: &quot; $3}' /etc/fstab
device:/dev/VolGroup00/LogVol00 fstype:ext3
device:LABEL=/boot      fstype: ext3
device:tmpfs    fstype: tmpfs
device:devpts   fstype: devpts
device:sysfs    fstype: sysfs
device:proc     fstype: proc
device:/dev/VolGroup00/LogVol01 fstype:swap
[houchangren@ebsdi-23260-oozie shell]$
</code></pre>

<h5 id="指定列分隔符">指定列分隔符</h5>

<pre><code>[houchangren@ebsdi-23260-oozie data]$ cat pwd.piece
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
news:x:9:13:news:/etc/news:
#指定冒号作为分隔符
[houchangren@ebsdi-23260-oozie data]$ awk -F&quot;:&quot; '{print &quot;user:&quot;$1 &quot;\t shell:&quot;$7}' pwd.piece
user:root        shell:/bin/bash
user:bin         shell:/sbin/nologin
user:daemon      shell:/sbin/nologin
user:adm         shell:/sbin/nologin
user:lp shell:/sbin/nologin
user:sync        shell:/bin/sync
user:shutdown    shell:/sbin/shutdown
user:halt        shell:/sbin/halt
user:mail        shell:/sbin/nologin
user:news       shell:

#多个字符作为分隔符
[houchangren@ebsdi-23260-oozie data]$ awk -F&quot;[\t ]+&quot; '{print &quot;device:&quot;$1 &quot;\tfstype:&quot;$3}'/etc/fstab
device:/dev/VolGroup00/LogVol00 fstype:ext3
device:LABEL=/boot      fstype:ext3
device:tmpfs    fstype:tmpfs
device:devpts   fstype:devpts
device:sysfs    fstype:sysfs
device:proc     fstype:proc
device:/dev/VolGroup00/LogVol01 fstype:swap

awk输入来源
[houchangren@ebsdi-23260-oozie data]$ head -5 /etc/passwd | awk -F&quot;:&quot; '{print &quot;user:&quot;$1 &quot;\tshell:&quot;$7}'
user:root        shell:/bin/bash
user:bin         shell:/sbin/nologin
user:daemon      shell:/sbin/nologin
user:adm         shell:/sbin/nologin
user:lp shell:/sbin/nologin
</code></pre>

<p>awk命令并不管文本来自何方，准确地说，awk读取标准输入。</p>

<p>当你将文本文件作为参数传递给awk命令时，awk命令打开文本文件，将之作为标准输入传递给awk的主逻辑。</p>

<h4 id="awk语言特性">awk语言特性</h4>

<p>很多在UNIX、Linux中浸淫许久的人都称awk为一门语言。这不仅仅是对awk的恭维，其实awk作为一门语言当之无愧。除了在前面提及的最简单的文本处理功能，awk还具有计算机语言所特有的性质，例如变量、判断、循环，甚至数组。</p>

<h6 id="awk代码结构">awk代码结构</h6>

<p><strong>begin和end</strong></p>

<p>在awk处理数据之前和之后可以添加代码块begin和end</p>

<p>在begin块中设置了，分隔符是冒号，和打印提示。</p>

<p>在end块中打印了结束提示。</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat awk/fs.awk
BEGIN{
FS=&quot;:&quot;
print &quot;I am begin！&quot;
}
{
print &quot;USER:&quot; $1  &quot;\tshell:&quot; $7
}
END{
print &quot;I am end!&quot;
}

[houchangren@ebsdi-23260-oozie shell]$ head -5 /etc/passwd | awk -f awk/fs.awk
I am begin！
USER:root       shell:/bin/bash
USER:bin        shell:/sbin/nologin
USER:daemon     shell:/sbin/nologin
USER:adm        shell:/sbin/nologin
USER:lp shell:/sbin/nologin
I am end!


awk数据处理支持正则表达式如下

[houchangren@ebsdi-23260-oozie shell]$ cat awk/search.awk
BEGIN{
FS=&quot;:&quot;
}
/nologin/ {++sum}
END{
print &quot;'nologin' appears \t&quot; sum  &quot;\ttimes.&quot;

}
[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/search.awk /etc/passwd
'nologin' appears       32     times.


//多项模式匹配
[houchangren@ebsdi-23260-oozie shell]$ cat awk/search.awk
BEGIN{
FS=&quot;:&quot;
}
/nologin/ {++sum}
/bash/{ ++bashs}
END{
print &quot;we have \t&quot; sum  &quot;\t nologin users&quot;
print &quot;we have \t &quot; bashs&quot;\t base  users&quot;
}
[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/search.awk /etc/passwd
we have         32       nologin users
we have          25      base users
</code></pre>

<h6 id="变量与数组">变量与数组</h6>

<p>变量</p>

<p>在awk中有两种变量</p>

<p>1. 用户自定义变量</p>

<p>2. 内建变量</p>

<p>变量只存储字符串，当需要时再转换为其他类型</p>

<p>awk的变量必须以ASCII字母或下划线开始，然后选择性地接上字毋、下划线及数字。如果</p>

<p>用正则表达式来匹配变量名的话，awk的变量名必须匹配[A-Za-z_][A-Za-z_0-9]*。</p>

<p>awk的变量名长度没有限制。</p>

<p>awk的变量名对大小写是敏感。</p>

<p>建议：</p>

<p>局部变量小写，全局变量第一个字母大写，内建变量全部大写。</p>

<p>Awk常用变量</p>

<p><strong>属性</strong></p>

<p>|</p>

<p><strong>说明</strong></p>

<p>&mdash;|&mdash;</p>

<p>$0</p>

<p>|</p>

<p>当前记录（作为单个变量）</p>

<p>$1~$n</p>

<p>|</p>

<p>当前记录的第n个字段，字段间由FS分隔</p>

<p>FS</p>

<p>|</p>

<p>输入字段分隔符 默认是空格</p>

<p>NF</p>

<p>|</p>

<p>当前记录中的字段个数，就是有多少列</p>

<p>NR</p>

<p>|</p>

<p>已经读出的记录数，就是行号，从1开始</p>

<p>RS</p>

<p>|</p>

<p>输入的记录分隔符默 认为换行符</p>

<p>OFS</p>

<p>|</p>

<p>输出字段分隔符 默认也是空格</p>

<p>ORS</p>

<p>|</p>

<p>输出的记录分隔符，默认为换行符</p>

<p>ARGC</p>

<p>|</p>

<p>命令行参数个数</p>

<p>ARGV</p>

<p>|</p>

<p>命令行参数数组</p>

<p>FILENAME</p>

<p>|</p>

<p>当前输入文件的名字</p>

<p>IGNORECASE</p>

<p>|</p>

<p>如果为真，则进行忽略大小写的匹配</p>

<p>ARGIND</p>

<p>|</p>

<p>当前被处理文件的ARGV标志符</p>

<p>CONVFMT</p>

<p>|</p>

<p>数字转换格式 %.6g</p>

<p>ENVIRON</p>

<p>|</p>

<p>UNIX环境变量</p>

<p>ERRNO</p>

<p>|</p>

<p>UNIX系统错误消息</p>

<p>FIELDWIDTHS</p>

<p>|</p>

<p>输入字段宽度的空白分隔字符串</p>

<p>FNR</p>

<p>|</p>

<p>当前记录数</p>

<p>OFMT</p>

<p>|</p>

<p>数字的输出格式 %.6g</p>

<p>RSTART</p>

<p>|</p>

<p>被匹配函数匹配的字符串首</p>

<p>RLENGTH</p>

<p>|</p>

<p>被匹配函数匹配的字符串长度</p>

<p>SUBSEP</p>

<p>|</p>

<p>\034</p>

<p>数组的使用无需声明即可使用。</p>

<p>数组</p>

<p>awk中的数组命名遵循了与变量命名相同的惯例，数组包含了从零到多个数据项，通过紧接着名称的数组索引选定。</p>

<p>大部分程序语言都需要以整数表达式作为索引的数组，但是awk允许在数组名称之后，以方括号将任意数字或字符串表达式括起来作为索引。</p>

<p>数组的元素类型可以为多种类型。</p>

<p>数组的存储空间是稀疏的，比如存储1，和10000索引的数组值，它不会自动填充它们之间的值的。</p>

<pre><code>[houchangren@ebsdi-23260-oozieshell]$ cat awk/array.awk
BEGIN{
arr[0]=0;
arr[10000]=10000;
arr[&quot;baidu&quot;]=&quot;www.baidu.com&quot;;
}

//
{
print&quot;init:\t&quot; arr[&quot;baidu&quot;];
arr[&quot;baidu&quot;]=&quot;www.baidu.cn&quot;;
print&quot;modifyed:\t&quot; arr[&quot;baidu&quot;];
deletearr[&quot;baidu&quot;];
print&quot;deleted:\t&quot; arr[&quot;baidu&quot;];

}

END{

}
[houchangren@ebsdi-23260-oozieshell]$ echo &quot;test&quot; |awk -f awk/array.awk
test
init:   www.baidu.com
modifyed:       www.baidu.cn
deleted:
[houchangren@ebsdi-23260-oozieshell]$
</code></pre>

<p>环境变量操作</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$awk  'BEGIN{printENVIRON[&quot;HOME&quot;];print ENVIRON[&quot;PATH&quot;]}'
/home/houchangren
/usr/local/pig/pig-0.12.0/bin:/usr/java/jdk1.6.0_31/bin:/usr/maven3/bin/:/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/java/jdk1.6.0_31:/usr/apache-ant-1.9.2/bin:/usr/local/hive-0.7.1-cdh3u6/bin:/home/hbase/hbase-0.94.10/bin:/root/bin
</code></pre>

<h6 id="算数运算和运算符">算数运算和运算符</h6>

<p>在awk中直接支持算术运算</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print &quot;3+5=&quot; 3+5}'
3+5=8
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print &quot;2^10=&quot; 2^10}'
2^10=1024
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print &quot;2*(5+10)=&quot; 2*(5+10)}'
2*(5+10)=30
</code></pre>

<p>小例子（判断是闰年还是平年）</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat awk/leap.awk
BEGIN{
print &quot;Pick Your Leap Years&quot;;
}
/**app module*/
{
year =$1
if((year%4==0&amp;&amp;year %100!=0) ||year%400==0)
  print year &quot; is leap year.&quot;
else
  print year &quot;is not a leap year.&quot;

}

END{
print &quot;shell end&quot;
}
[houchangren@ebsdi-23260-oozie shell]$

[houchangren@ebsdi-23260-oozie shell]$ echo '2013' | awk -f awk/leap.awk;
Pick Your Leap Years
2013is not a leap year.
shell end
[houchangren@ebsdi-23260-oozie shell]$ echo '2000' | awk -f awk/leap.awk;
Pick Your Leap Years
2000 is leap year.
shell end
</code></pre>

<p><strong>awk中的运算符</strong></p>

<p><strong>运算符</strong></p>

<p>|</p>

<p><strong>描述</strong></p>

<p>|</p>

<p><strong>用法</strong></p>

<p>&mdash;|&mdash;|&mdash;</p>

<p>= += -= *= /= %= ^= **=</p>

<p>|</p>

<p>赋值语句</p>

<p>|</p>

<p>awk &lsquo;BEGIN{a=10;print a}&rsquo;<br />
awk &lsquo;BEGIN{a+=10;print a}&rsquo;<br />
awk &lsquo;BEGIN{a-=10;print a}&rsquo;<br />
awk &lsquo;BEGIN{a*=10;print a}&rsquo;<br />
awk &lsquo;BEGIN{a/=10;print a}&rsquo;<br />
awk &lsquo;BEGIN{a%=10;print a}&rsquo;<br />
awk &lsquo;BEGIN{a^=10;print a}&rsquo;<br />
awk &lsquo;BEGIN{a**=10;print a}&rsquo;</p>

<p>?:</p>

<p>|</p>

<p>三元运算符</p>

<p>|</p>

<p>awk &lsquo;BEGIN{print (1==1)?&ldquo;true&rdquo;:&ldquo;false&rdquo;}&rsquo;</p>

<p>||</p>

<p>|</p>

<p>逻辑或</p>

<p>|</p>

<p>awk &lsquo;BEGIN{a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);}&rsquo;</p>

<p>&amp;&amp;</p>

<p>|</p>

<p>逻辑与</p>

<p>|</p>

<p>awk &lsquo;BEGIN{a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);}&rsquo;</p>

<p>~ ~!</p>

<p>|</p>

<p>匹配正则表达式和<br />
不匹配正则表达式</p>

<p>|</p>

<p>awk &lsquo;BEGIN{a=&ldquo;IamTest&rdquo;;if(a ~ /^Iam<em>/){print a;}else{print &ldquo;&hellip;..&rdquo;}}&rsquo;<br />
awk &lsquo;BEGIN{a=&ldquo;IamTest&rdquo;;if(a ~! /^Iam</em>/){print a;}else{print &ldquo;&hellip;..&rdquo;}}&rsquo;</p>

<p>&lt; &lt;= &gt; &gt;= != ==</p>

<p>|</p>

<p>关系运算符</p>

<p>|</p>

<p>略.</p>

<p>+ - * / %</p>

<p>|</p>

<p>加减乘除和取余</p>

<p>|</p>

<p>略.</p>

<p>^ **</p>

<p>|</p>

<p>幂函数</p>

<p>|</p>

<p>awk &lsquo;BEGIN{print 10**10}&rsquo;<br />
awk &lsquo;BEGIN{print 10^10}&rsquo;</p>

<p>++ &ndash;</p>

<p>|</p>

<p>加加和减减，<br />
是自身修改，<br />
分前缀和后缀</p>

<p>|</p>

<p>$</p>

<p>|</p>

<p>字段引用</p>

<p>|</p>

<p>echo &ldquo;123123&rdquo; |awk &lsquo;{print $1}&rsquo;</p>

<p>in</p>

<p>|</p>

<p>数组成员 判断 key是不是有</p>

<p>|</p>

<p>awk &lsquo;BEGIN{arr[0]=&ldquo;b&rdquo;;print(0 in arr)}&rsquo;</p>

<h6 id="判断和循环">判断和循环</h6>

<p>Awk中的条件语句主要有if、else循环语句主要是for 和while</p>

<p><strong>If实例</strong></p>

<pre><code>[root@ebsdi-23260-oozie ~]# awk 'BEGIN{a=1;b=2;if(a&gt;b){print&quot;大于&quot;;}else{print&quot;小于&quot;;}}'
小于

[root@ebsdi-23260-oozie ~]# awk 'BEGIN{a=1;b=2;if(a&gt;b){print&quot;大于&quot;;}elseif(a==1){print &quot;a=1&quot;;}else{ print&quot;小于&quot;;}}'
a=1


while循环
[root@ebsdi-23260-oozie ~]# awk 'BEGIN{i=3;while(i&gt;0){print i;i--}}'
3
2
1
Do while 循环
[root@ebsdi-23260-oozie ~]# awk 'BEGIN{i=3;do{print i;i--}while(i&gt;0)}'
3
2
1

For循环
[root@ebsdi-23260-oozie ~]# awk 'BEGIN{for(i=3;i&gt;0;i--){print i;}}'
3
2
1

Break中断循环
[root@ebsdi-23260-oozie ~]# awk 'BEGIN{i=3;while(i&gt;0){if(i==2)break;print i;i--}}'
3

Continue跳过本次循环
[root@ebsdi-23260-oozie ~]# awk 'BEGIN{for(i=3;i&gt;0;i--){if(i==2)continue;print i;}}'
3
1
</code></pre>

<h6 id="多行一条记录fs-和rs">多行一条记录FS 和RS</h6>

<p>在awk中除了有字段还有记录行的概念，默认情况下是一条行是一条记录，但是有时候一条记录可能跨多行。</p>

<p>如下</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat data/boys.txt
Xiaoming
10
Beijing.china

Xiaohou
14
Shanghai.china

Lisha
13
Paris. France
</code></pre>

<p>在上文的awk变量中已经有表格说明了指定行RS和FS是记录分隔符和字段分隔符</p>

<pre><code>[houchangren@ebsdi-23260-oozieshell]$ vim awk/boys.awk
BEGIN{
RS=&quot;&quot;;
FS=&quot;\n&quot;
}
{
print$1 &quot;\t&quot; $2 &quot;\t&quot; $2
}
[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/boys.awk  data/boys.txt
Xiaoming        10     10
Xiaohou 14      14
Lisha  13      13
</code></pre>

<p>设定ORS和OFS</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/boys.awk

BEGIN{
RS=&quot;&quot;;
FS=&quot;\n&quot;;
ORS=&quot;\n\n&quot;;
OFS=&quot;,&quot;;

}
{
print $1&quot;,&quot;$2&quot;,&quot;$3
}

[houchangren@ebsdi-23260-oozie shell]$ awk -f  awk/boys.awk  data/boys.txt
Xiaoming,10,Beijing.china

Xiaohou,14,Shanghai.china

Lisha,13,Paris. France

[houchangren@ebsdi-23260-oozie shell]$

[houchangren@ebsdi-23260-oozie shell]$ cat awk/boys.awk
BEGIN{
RS=&quot;&quot;;
FS=&quot;\n&quot;;
ORS=&quot;&quot;;

}
{
x=1
while(x&lt;=NF){
print $x &quot;\t&quot;
x++
}
print &quot;\n&quot;
}

[houchangren@ebsdi-23260-oozie shell]$ awk -f  awk/boys.awk  data/boys.txt
Xiaoming        10     Beijing.china
Xiaohou 14      Shanghai.china
Lisha  13      Paris. France
</code></pre>

<h4 id="用户自定义函数">用户自定义函数</h4>

<h6 id="格式">格式</h6>

<p>awk的用户自定义函数获取参数，选择性地返回标量值。函数可以定义在程序顶层的任意位置，定义的格式为:</p>

<pre><code>function  functionName (args1,args2,….){
//code block

}
</code></pre>

<p>实例增加函数</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat awk/fun_add.awk
function add(x,y,sum){
sum=x+y;
return sum;
}
BEGIN{
print &quot;test function add&quot;;
m=2;
n=3;
x=add(m,n);
printf (&quot;m:%d\n&quot;,m);
printf (&quot;n:%d\n&quot;,n);

printf (&quot;sum of m and n is%d&quot;,x);

print(&quot;\n&quot;);

}

[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/fun_add.awk
test function add
m:2
n:3
sum of m and n is 5
</code></pre>

<h6 id="参数引用">参数引用</h6>

<p>在awk中也有引用传递和值传递的一说</p>

<p><strong>值引用（执行完swap函数后，值没变）；</strong></p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/fun_swap.awk

function swap(x,y,temp){
temp=x;
x=y;
y=temp;
}
BEGIN {}
{
m=3;
n=2;

printf(&quot;m:%d-----------n:%d\n&quot;,m,n);
swap(m,n);
printf(&quot;m:%d-----------n:%d\n&quot;,m,n);

}
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; |awk -f awk/fun_swap.awk
m:3-----------n:2
m:3-----------n:2
</code></pre>

<p><strong>传递引用（执行完swap函数后，值变了）；</strong></p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; |awk -f awk/fun_swap2.awk
arr[0]:10-----arr[1]11
arr[0]:11-----arr[1]10
[houchangren@ebsdi-23260-oozie shell]$ vim awk/fun_swap2.awk

function swap(arr,temp){

temp=arr[0];
arr[0]=arr[1];
arr[1]=temp;
}
BEGIN{}

{
arr[0]=10;
arr[1]=11;

printf(&quot;arr[0]:%d-----arr[1]%d\n&quot;,arr[0],arr[1]);
swap(arr);
printf(&quot;arr[0]:%d-----arr[1]%d\n&quot;,arr[0],arr[1]);



}

[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; |awk -f awk/fun_swap2.awk
arr[0]:10-----arr[1]11
arr[0]:11-----arr[1]10
</code></pre>

<h6 id="递归调用">递归调用</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ echo -e &quot;1\n3\n5\n10\n20\n35\n40&quot; |awk -f awk/fun_fibonacci.awk
------------
1th of fibonacci sequence is 1
------------
3th of fibonacci sequence is 2
------------
5th of fibonacci sequence is 5
------------
10th of fibonacci sequence is 55
------------
20th of fibonacci sequence is 6765
------------
35th of fibonacci sequence is 9227465
------------
40th of fibonacci sequence is 102334155
</code></pre>

<p>由于上方的斐波那契的算法，特别忙，当执行35时候就得20秒左右40的时候好像就得10分钟左右了。</p>

<p>优化程序改为下方</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/fun_fibonacci2.awk

ind =3'
ind++;
BEGIN{
function fibonacci(array,n,ind){
ind =3;
while(ind&lt;=n){
array[ind]=array[ind-1]+array[ind-2];
ind++;
}

}
BEGIN{}
/**code block*/
{
array[1]=1;
array[2]=1;
n=$1;
fibonacci(array,n);
printf(&quot;%dth of  fibonacci sequence is :%d\n&quot;,n,array[n]);

}



[houchangren@ebsdi-23260-oozie shell]$ echo -e &quot;1\n3\n5\n10\n20\n30\n35\n50&quot; |awk -f awk/fun_fibonacci2.awk
1th of fibonacci sequence is : 1
3th of fibonacci sequence is : 2
5th of fibonacci sequence is : 5
10th of fibonacci sequence is : 55
20th of fibonacci sequence is : 6765
30th of fibonacci sequence is : 832040
35th of fibonacci sequence is : 9227465
50th of fibonacci sequence is : 12586269025
</code></pre>

<h4 id="字符串和算术处理">字符串和算术处理</h4>

<h5 id="格式化输出">格式化输出</h5>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/print.awk

BEGIN{}

{
x=1;
b=&quot;foo&quot;;
printf(&quot;my name is %s,I'm%s\n&quot;,&quot;xiaohouzi&quot;,10);
myout=sprintf(&quot;%s=%s&quot;,b,x);
print myout;
}

[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk -f awk/print.awk
my name is xiaohouzi,I'm 10
foo=1
</code></pre>

<p>在printf和sprintf中操作时一样的，不同的时候sprintf可以将输出写到变量中，为变量赋值而使用。</p>

<h6 id="转义符">转义符</h6>

<p><strong>转移字符</strong></p>

<p>|</p>

<p><strong>解释</strong></p>

<p>&mdash;|&mdash;</p>

<p>%c</p>

<p>|</p>

<p>单个字符</p>

<p>%s</p>

<p>|</p>

<p>字符串</p>

<p>%d</p>

<p>|</p>

<p>十进制有符号整数</p>

<p>%ld</p>

<p>|</p>

<p>十进制长整型</p>

<p>%u</p>

<p>|</p>

<p>十进制无符号整数</p>

<p>%lu</p>

<p>|</p>

<p>十进制无符号长整型数</p>

<p>%x</p>

<p>|</p>

<p>十六进制表示的整数</p>

<p>%lx</p>

<p>|</p>

<p>十六进制表示的长整数</p>

<p>%o</p>

<p>|</p>

<p>八进制整数</p>

<p>%lo</p>

<p>|</p>

<p>八进制长整数</p>

<p>%e</p>

<p>|</p>

<p>指数形式的浮点数</p>

<p>%f</p>

<p>|</p>

<p>浮点数</p>

<p>%g</p>

<p>|</p>

<p>选e或者f中较短的一种形式</p>

<p>\n</p>

<p>|</p>

<p>换行</p>

<p>\f</p>

<p>|</p>

<p>清屏并换页</p>

<p>\r</p>

<p>|</p>

<p>回车</p>

<p>\t</p>

<p>|</p>

<p>Tab符</p>

<p>\xhh</p>

<p>|</p>

<p>表示一个ASCII码用16进表示,<br />
其中hh是1到2个16进制数</p>

<h6 id="修饰符">修饰符</h6>

<hr />

<p>字符</p>

<p>|</p>

<p>定义</p>

<p>-</p>

<p>|</p>

<p>左对齐修饰符</p>

<p>#</p>

<p>|</p>

<p>显示八进制的时候前边加个0，显示十六进制的时候前面加个0x</p>

<p>+</p>

<p>|</p>

<p>显示使用d，e，f和g转换的整数时，加上正负号+或者-</p>

<p>0</p>

<p>|</p>

<p>用0而不是空白符来填充所显示的值</p>

<h6 id="实例">实例</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk '{printf(&quot;|%10s|\n&quot;,&quot;ollir&quot;);}';
|    ollir|
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk '{printf(&quot;|%10s|\n&quot;,&quot;hello,ollir&quot;);}';
|hello,ollir|
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk '{printf(&quot;|%-10s|\n&quot;,&quot;hello&quot;);}';
|hello     |
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk '{printf(&quot;|%10.5g|\n&quot;,&quot;hello&quot;);}';
|        0|
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk '{printf(&quot;|%10.5g|\n&quot;,&quot;023&quot;);}';
|       23|
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk '{printf(&quot;|%10.5g|\n&quot;,23.4454);}';
|   23.445|
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk '{printf(&quot;|%10.5g|\n&quot;,23.445433);}';
|   23.445|
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;10, 6, 19.123232342346345&quot; | awk '{printf(&quot;|%*.*g|\n&quot;,$1,$2,$3);}';
|  19.1232|
</code></pre>

<h5 id="字符串函数">字符串函数</h5>

<p><strong>函数</strong></p>

<p>|</p>

<p><strong>说明</strong></p>

<p>&mdash;|&mdash;</p>

<p>gsub( Ere, Repl, [ In ] )</p>

<p>|</p>

<p>除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行，。</p>

<p>sub( Ere, Repl, [ In ] )</p>

<p>|</p>

<p>用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在
Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In
参数，缺省值是整个记录（$0 记录变量）。</p>

<p>index( String1, String2 )</p>

<p>|</p>

<p>在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在
String1 参数中出现，则返回 0（零）。</p>

<p>length [(String)]</p>

<p>|</p>

<p>返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。</p>

<p>blength [(String)]</p>

<p>|</p>

<p>返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。</p>

<p>substr( String, M, [ N ] )</p>

<p>|</p>

<p>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String
参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</p>

<p>match( String, Ere )</p>

<p>|</p>

<p>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回
0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。</p>

<p>split( String, A, [Ere] )</p>

<p>|</p>

<p>将 String 参数指定的参数分割为数组元素 A[1], A[2], &hellip;, A[n]，并返回 n 变量的值。此分隔可以通过 Ere
参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A
数组中的元素用字符串值来创建。</p>

<p>tolower( String )</p>

<p>|</p>

<p>返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</p>

<p>toupper( String )</p>

<p>|</p>

<p>返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。</p>

<p>sprintf(Format, Expr, Expr, &hellip; )</p>

<p>|</p>

<p>根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。</p>

<p>实例：</p>

<h6 id="字符串查找">字符串查找</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{pos=index(&quot;hello,ollir&quot;,&quot;ollir&quot;);print pos;}'
7
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{pos=index(&quot;hello ,ollir&quot;,&quot;ollir&quot;);print pos;}'
9
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{pos=index(&quot;hello,ollir&quot;,&quot;ollirs&quot;);print pos;}'
0
</code></pre>

<p>自定义一个反向查询索引函数</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/rindex.awk

function rindex(string,find,k,ns,nf){

ns=length(string);
nf=length(find);

for(k=ns+1-nf;k&gt;nf;k--){
 if(substr(string,k,nf)==find){
       return k;
    }
}
return 0;
}
BEGIN{}

{
string=$1;
find=$2;

printf(&quot;Reverse index of  %s in %s is :%d\n&quot;,find,string,rindex(string,find));

}
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;123456789012345 123&quot; | awk -f awk/rindex.awk
Reverse index of  123 in 123456789012345 is :11
</code></pre>

<h6 id="子字符串提取">子字符串提取</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat data/info.txt
1.first is lilei
2.second is liuhai
3.thrid is zhangsan
[houchangren@ebsdi-23260-oozie shell]$ awk '{print substr($1,3);}' data/info.txt
first
second
third
[houchangren@ebsdi-23260-oozie shell]$ awk '{print substr($3,0);}' data/info.txt
lilei
liuhai
zhangsan
[houchangren@ebsdi-23260-oozie shell]$ awk '{print substr($3,0,5);}' data/info.txt
lilei
liuha
zhang
</code></pre>

<h6 id="字符串匹配">字符串匹配</h6>

<p>match函数提供了与正则匹配的操作。</p>

<p>awk除了返回子串的索引外，还有副作用:设置系统变量RSTART和RLENGTH。RSTART在match()函数运行后被设置为匹配上正则表达式的字符串的起始位置
, RLENGTH则被设置为匹配上正则表达式的子字符串的长度。如果无法完成匹配，则RSTART被设置为0，而RLENGTH被设置为-1。</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; |awk '{start=match(&quot;this is a test&quot;,/[a-z]+$/);printstart;}'
11
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; |awk '{start=match(&quot;this is a test&quot;,/[a-z]+$/);printstart &quot;,&quot; RSTART &quot;,&quot; RLENGTH;}'
11,11,4
</code></pre>

<h6 id="子字符串替换">子字符串替换</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ echo &quot;test is test&quot; | awk '{gsub(/test/,&quot;mytest&quot;);print}'
mytest is mytest
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;test is test&quot; | awk '{sub(/test/,&quot;mytest&quot;);print}'
mytest is test
</code></pre>

<h6 id="大小写转换">大小写转换</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/translate.awk
{
printf(&quot;lower:%s\n&quot;,tolower($0));
printf(&quot;UPPER:%s\n&quot;,toupper($0));
}
[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/translate.awk data/info.txt
lower:1.first  is lilei
UPPER:1.FIRST  IS LILEI
lower:2.second is liuhai
UPPER:2.SECOND IS LIUHAI
lower:3.thrid  is zhangsan
UPPER:3.THRID  IS ZHANGSAN
</code></pre>

<h6 id="字符串分割">字符串分割</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$  awk 'BEGIN{info=&quot;this is atest&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA){printk,tA[k];}}'
4
4 test
1 this
2 is
3 a
</code></pre>

<h6 id="字符串重建">字符串重建</h6>

<p>将数组中的元素连接成字符串</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/join.awk
function join (array,n,fs,k,s){
if( n &gt;= 1 ){
 s=array[1];
 for(k=2;k&lt;=n;k++)
   s=s fs array[k];
}
return s;
}

{
arr[1]=&quot;I&quot;;
arr[2]=&quot;am&quot;;
s=join(arr,2,&quot; &quot;);
print s;
}
[houchangren@ebsdi-23260-oozie shell]$ echo &quot;&quot; | awk -f awk/join.awk
I am
</code></pre>

<h5 id="算术函数">算术函数</h5>

<p>脚本经常处理报表所以算术函数是必须的。</p>

<p>Awk支持的算术函数</p>

<hr />

<p><strong>函数名</strong></p>

<p>|</p>

<p><strong>说明</strong></p>

<p>atan2( y, x )</p>

<p>|</p>

<p>返回 y/x 的反正切。</p>

<p>cos( x )</p>

<p>|</p>

<p>返回 x 的余弦；x 是弧度。</p>

<p>sin( x )</p>

<p>|</p>

<p>返回 x 的正弦；x 是弧度。</p>

<p>exp( x )</p>

<p>|</p>

<p>返回 x 幂函数。</p>

<p>log( x )</p>

<p>|</p>

<p>返回 x 的自然对数。</p>

<p>sqrt( x )</p>

<p>|</p>

<p>返回 x 平方根。</p>

<p>int( x )</p>

<p>|</p>

<p>返回 x 的截断至整数的值。</p>

<p>rand( )</p>

<p>|</p>

<p>返回任意数字 n，其中 0 &lt;= n &lt; 1。</p>

<p>srand( [Expr] )</p>

<p>|</p>

<p>将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。</p>

<h6 id="常用函数">常用函数</h6>

<pre><code>//pi的值
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print atan2(0,-1)}'
3.14159
//自然对数
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print exp(1)}'
2.71828
//exp的反函数
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print log(exp(1))}'
1
//平方根
[houchangren@ebsdi-23260-oozie shell]$ awk'BEGIN{print sqrt(2)}'
1.41421
</code></pre>

<h6 id="取整函数">取整函数</h6>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print int(100/3)}'
33
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print 100/3}'
33.3333
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print int(10.7)}'
10
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{printf(&quot;%f\n&quot;,10.7)}'
10.700000
</code></pre>

<h6 id="随机数">随机数</h6>

<p>关于随机数的原理参考：<a href="http://blog.csdn.net/johnhany/article/details/8106564">http://blog.csdn.net/johnhany/article/details/8106564</a></p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print rand(); srand();print rand();}'
0.237788
0.246611
[houchangren@ebsdi-23260-oozie shell]$ awk 'BEGIN{print rand(); srand();print rand();}'
0.237788
0.402041
</code></pre>

<p>部分信息参考</p>

<p>参考：<a href="http://www.cnblogs.com/chengmo/archive/2010/10/08/1845913.html">http://www.cnblogs.com/chengmo/archive/2010/10/08/1845913.html</a></p>

<h4 id="案例分析">案例分析</h4>

<h5 id="生成数据报表">生成数据报表</h5>

<p>源数据</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat data/sale.txt
GDD,9041,39,125288
CGDD,9042,4099,225759
CGDD,9043,4964.525,415723
CGDD,9047,1815.238,569063
CGDD,9053,59,326883
CGDD,9097,56,651912
CGDD,9098,39,953235
CGDD,9017,4099,982040
CGDD,9019,4964.525,1025987
CGDD,9018,1815.238,415723

[houchangren@ebsdi-23260-oozie shell]$ cat awk/sale.awk
#/usr/bin/awk -f
BEGIN{
FS=&quot;,&quot;;OFS=&quot;\t&quot;
print&quot;ORG_NAME\tJan\tFeb\tMar\t\tTotal&quot;;
print&quot;---------------------------------------&quot;;
}

{$5 =$2 +$3 +$4}
{print$1&quot;\t&quot;$2&quot;\t&quot;$3&quot;\t&quot;$4&quot;\t&quot;$5}
{total2+=$2}
{total3+=$3}
{total4+=$4}
END{
print&quot;---------------------------------------&quot;;
print &quot;this is Jan total:&quot;total2;
print &quot;this is Feb total:&quot;total3;
print &quot;this is Mar total:&quot;total4;
}

[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/sale.awk data/sale.txt
ORG_NAME        Jan    Feb     Mar             Total
---------------------------------------
GDD    9041    39      125288 134368
CGDD   9042    4099    225759 238900
CGDD   9043    4964.525        415723 429731
CGDD   9047    1815.238        569063 579925
CGDD   9053    59     326883  335995
CGDD   9097    56      651912 661065
CGDD   9098    39      953235 962372
CGDD   9017    4099    982040 995156
CGDD   9019    4964.525        1025987 1.03997e+06
CGDD   9018    1815.238        415723 426556
                                0
---------------------------------------
this is Jan total:90475
this is Feb total:21950.5
this is Mar total:5691613
</code></pre>

<p>由于上表数据有点乱，下边修改一下脚本</p>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ vim awk/sale.awk

#/usr/bin/awk -f
BEGIN{
FS=&quot;,&quot;;OFS=&quot;\t&quot;
print&quot;ORG_NAME\tJan\tFeb\tMar\t\tTotal&quot;;
print&quot;---------------------------------------&quot;;
}

{$5 =$2 +$3 +$4}
{printf &quot;%-8s%-10s%-10s%-10s%-20f\n&quot;,$1,$2,$3,$4,$5}
{total2+=$2}
{total3+=$3}
{total4+=$4}
END{
print &quot;---------------------------------------&quot;;
print &quot;this is Jan total:&quot;total2;
print &quot;this is Feb total:&quot;total3;
print &quot;this is Mar total:&quot;total4;
}
~
[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/sale.awk data/sale.txt
ORG_NAME        Jan    Feb     Mar             Total
---------------------------------------
GDD    9041      39        125288    134368.000000      
CGDD   9042      4099      225759   238900.000000      
CGDD   9043      4964.525  415723   429730.525000      
CGDD   9047      1815.238  569063   579925.238000      
CGDD   9053      59        326883    335995.000000      
CGDD   9097      56        651912    661065.000000      
CGDD   9098      39        953235    962372.000000      
CGDD   9017      4099      982040   995156.000000      
CGDD   9019      4964.525  1025987  1039970.525000     
CGDD   9018      1815.238  415723   426556.238000      
                                     0.000000           
---------------------------------------
this is Jan total:90475
this is Feb total:21950.5
this is Mar total:5691613
</code></pre>

<h5 id="多文件联合处理">多文件联合处理</h5>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat data/stuff.txt
1      zhangsan
2      lisi
3      wangwu
6      maliu

[houchangren@ebsdi-23260-oozie shell]$ cat data/stuff_phone.txt
13522375325,zhangsan
18500193250,lisi
13421320433,wangwu
18923423443,maliu

[houchangren@ebsdi-23260-oozie shell]$ cat awk/stuffJoin.awk
BEGIN{
FS=&quot;[  |,]&quot;;
OFS=&quot;,&quot;;
}
NR&lt;=FNR{
a[$2]=$1;
}

NR&gt;FNR{
print $1,$2,a[$2]
}


END{}

[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/stuffJoin.awk  data/stuff*
1,zhangsan,13522375325
2,lisi,18500193250
3,wangwu,13421320433
6,maliu,18923423443
[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/stuffJoin.awk  data/stuff.txt data/stuff_phone.txt
13522375325,zhangsan,1
18500193250,lisi,2
13421320433,wangwu,3
18923423443,maliu,6
</code></pre>

<h5 id="检验passwd的正确性">检验passwd的正确性</h5>

<pre><code>[houchangren@ebsdi-23260-oozie shell]$ cat data/passwd.datafile
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
news:x:9:13:news:/etc/news:
new:*:9:13:news:/etc/news:
halt:x:7:0:halt:/sbin:/sbin/halt:test

[houchangren@ebsdi-23260-oozie shell]$ vim awk/passwd.check.awk

BEGIN{
FS=&quot;:&quot;;
}
NF!=7{
printf(&quot;line %d,dose not have 7feilds:%s\n&quot;,NR,$0);
}
$1 !~ /[a-zA-z0-9]/{
printf(&quot;line %d,non alpha and numericuser id :%s\n&quot;,NR,$0);
}
$2==&quot;*&quot;{
printf(&quot;line %d,no password:%s\n&quot;,NR,$0);
}

END{}
[houchangren@ebsdi-23260-oozie shell]$ awk -f awk/passwd.check.awk data/passwd.datafile
line 11,nopassword:new:*:9:13:news:/etc/news:
line 12,dose not have 7feilds:halt:x:7:0:halt:/sbin:/sbin/halt:test
</code></pre>

<h5 id="sed-awk单行脚本">Sed/awk单行脚本</h5>

<p>参考：</p>

<p><a href="http://blog.chinaunix.net/uid-20718384-id-3296639.html">http://blog.chinaunix.net/uid-20718384-id-3296639.html</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>