<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell初级教程备忘录2 | 开发者问答集锦</title>
    <meta property="og:title" content="shell初级教程备忘录2 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell初级教程备忘录2">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%E5%A4%87%E5%BF%98%E5%BD%952/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell初级教程备忘录2</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>﻿3，SHELL脚本基本知识</p>

<p>对于不同的Unix和Linux，使用一段shell脚本将需要一些小小的改动才能运行通过。实际上shell的可迁移性不成问题，但是系统间命令的可迁移性存在差别。<br />
在第二行注释中写入脚本名是一个好习惯。</p>

<p>3.1 条件测试<br />
写脚本时，有时要判断字符串是否相等，可能还要检查文件状态或是数字测试。基于这<br />
些测试才能做进一步动作。Test命令用于测试字符串，文件状态和数字，也很适合于下一章将<br />
提到的if,then,else条件结构。<br />
expr命令测试和执行数值输出。使用最后退出状态命令$?可测知test和expr，二者均以0表正确，1表示返回错误。<br />
测试文件状态<br />
test一般有两种格式，即：<br />
test condition 或 [ condition ]<br />
使用方括号时，要注意在条件两边加上空格。<br />
测试文件状态的条件表达式很多，但是最常用的如下：</p>

<p>- d 目录- s 文件长度大于0、非空<br />
- f 正规文件- w 可写<br />
- L 符号连接- u 文件有suid位设置<br />
- r 可读- x 可执行</p>

<p>使用两种方法测试文件scores.txt是否可写并用最后退出状态测试是否成功。记住， 0表示成功，其他为失败。</p>

<h1 id="ls-l-scores-txt">ls -l scores.txt</h1>

<p>-rw-r&ndash;r&ndash; 1 root root 0 Nov 21 12:15 scores.txt</p>

<h1 id="w-scores-txt">[ -w scores.txt ]</h1>

<h1 id="echo">echo $?</h1>

<p>0</p>

<h1 id="test-w-scores-txt">test -w scores.txt</h1>

<h1 id="echo-1">echo $?</h1>

<p>0</p>

<p>两种状态均返回0，可知文件scores.txt可写，现在测试其是否可执行：</p>

<h1 id="x-scores-txt">[ -x scores.txt ]</h1>

<h1 id="echo-2">echo $?</h1>

<p>1</p>

<p>查看文件scores.txt权限列表，可知结果正如所料。<br />
下面的例子测试是否存在appsbin目录<br />
drwxr-xr-x 2 root root 4096 Nov 21 12:17 appsbin</p>

<h1 id="d-appsbin">[ -d appsbin ]</h1>

<h1 id="echo-3">echo $?</h1>

<p>0</p>

<p>目录appsbin果然存在。<br />
测试文件权限是否设置了suid位</p>

<h1 id="ls-l-xab">ls -l xab</h1>

<p>-rwsr-xr-x 1 root root 0 Nov 21 12:19 xab</p>

<h1 id="u-xab">[ -u xab ]</h1>

<h1 id="echo-4">echo $?</h1>

<p>0<br />
从结果知道suid位已设置。</p>

<p>测试时使用逻辑操作符<br />
测试文件状态是否为O K，但是有时要比较两个文件状态。shell提供三种逻辑操作完成此功能。<br />
-a 逻辑与，操作符两边均为真，结果为真，否则为假。<br />
-o 逻辑或，操作符两边一边为真，结果为真，否则为假。<br />
! 逻辑否，条件为假，结果为真。<br />
下面比较两个文件：</p>

<h1 id="ls-l-results-txt-scores-txt">ls -l results.txt scores.txt</h1>

<p>-rwxr-xr-x 1 root root 0 Nov 21 12:22 results.txt<br />
-rw-r&ndash;r&ndash; 1 root root 0 Nov 21 12:15 scores.txt</p>

<h1 id="w-results-txt-a-w-scores-txt">[ -w results.txt -a -w scores.txt ]</h1>

<h1 id="echo-5">echo $?</h1>

<p>0</p>

<p>scores.txt不可执行，但results.txt可执行。<br />
要测试文件results.txt是否可写、可执行：</p>

<h1 id="w-results-txt-a-x-results-txt">[ -w results.txt -a -x results.txt ]</h1>

<h1 id="echo-6">echo $?</h1>

<p>0<br />
结果为真。</p>

<p>字符串测试<br />
字符串测试是错误捕获很重要的一部分，特别在测试用户输入或比较变量时尤为重要。<br />
字符串测试有5种格式。</p>

<p>test &ldquo;string&rdquo;<br />
test string_operator &ldquo;string&rdquo;<br />
test &ldquo;string&rdquo; string_operator &ldquo;string&rdquo;<br />
[ string_operator string ]<br />
[ string string_operator string]</p>

<p>这里，stringoperator可为：<br />
==两个字符串相等。<br />
！= 两个字符串不等。<br />
-z 空串。<br />
-n 非空串。<br />
要测试环境变量EDITOR是否为空：</p>

<h1 id="z-editor">[ -z $EDITOR ]</h1>

<h1 id="echo-7">echo $?</h1>

<p>1<br />
非空，取值是否是vim？</p>

<h1 id="editor-vim">[ $EDITOR == &ldquo;vim&rdquo; ]</h1>

<h1 id="echo-8">echo $?</h1>

<p>0<br />
是的，用echo命令反馈其值：</p>

<h1 id="echo-editor">echo $EDITOR</h1>

<p>vim<br />
测试变量tape与变量tape2是否相等：</p>

<h1 id="tape-dev-rmt0">TAPE=&ldquo;/dev/rmt0&rdquo;</h1>

<h1 id="tape2-dev-rmt1">TAPE2=&ldquo;/dev/rmt1&rdquo;</h1>

<h1 id="tape-tape2">[ &ldquo;$TAPE&rdquo; == &ldquo;$TAPE2&rdquo; ]</h1>

<h1 id="echo-9">echo $?</h1>

<p>1<br />
不相等。没有规定在设置变量时一定要用双引号，但在进行字符串比较时必须这样做。<br />
测试变量tape与tape2是否不相等。</p>

<h1 id="tape-tape2-1">[ &ldquo;$TAPE&rdquo; != &ldquo;$TAPE2&rdquo; ]</h1>

<h1 id="echo-10">echo $?</h1>

<p>0<br />
是的，它们不相等。</p>

<p>测试数值<br />
测试数值可以使用多操作符，一般格式如下：<br />
&ldquo;number&rdquo;numericoperator&rdquo;number&rdquo;<br />
或者<br />
[ &ldquo;number&rdquo; numericoperator&rdquo; number&rdquo; ]<br />
numericoperator可为：<br />
-eq 数值相等。<br />
-ne 数值不相等。<br />
-gt 第一个数大于第二个数。<br />
-lt 第一个数小于第二个数。<br />
-le 第一个数小于等于第二个数。<br />
-ge 第一个数大于等于第二个数。<br />
下面的例子返回结果都一样。均为测试两个数是否相等（130是否等于130）。</p>

<h1 id="number-130">NUMBER=130</h1>

<h1 id="number-eq-130">[ &ldquo;$NUMBER&rdquo; -eq &ldquo;130&rdquo; ]</h1>

<h1 id="echo-11">echo $?</h1>

<p>0<br />
结果果然正确。<br />
改变第二个数，结果返回失败，状态1（130不等于200）</p>

<h1 id="number-eq-100">[ &ldquo;$NUMBER&rdquo; -eq &ldquo;100&rdquo; ]</h1>

<h1 id="echo-12">echo $?</h1>

<p>1<br />
测试130是否大于100：</p>

<h1 id="number-gt-100">[ &ldquo;$NUMBER&rdquo; -gt &ldquo;100&rdquo; ]</h1>

<h1 id="echo-13">echo $?</h1>

<p>0<br />
当然。<br />
也可以测试两个整数变量。下面测试变量sourcecount是否小于destcount:</p>

<h1 id="source-count-13">SOURCE_COUNT=13</h1>

<h1 id="dest-count-15">DEST_COUNT=15</h1>

<h1 id="dest-count-gt-source-count">[ &ldquo;$DEST_COUNT&rdquo; -gt &ldquo;$SOURCE_COUNT&rdquo; ]</h1>

<h1 id="echo-14">echo $?</h1>

<p>0<br />
可以不必将整数值放入变量，直接用数字比较即可，但要加引号。</p>

<h1 id="990-le-995">[ &ldquo;990&rdquo; -le &ldquo;995&rdquo; ]</h1>

<h1 id="echo-15">echo $?</h1>

<p>0<br />
可以用逻辑操作符将两个测试表达式结合起来。仅需要用到一对方括号，而不能用两个，<br />
否则将返回错误信息“ too many arg u m e n t s”。</p>

<h1 id="990-le-995-a-123-gt-33">[ &ldquo;990&rdquo; -le &ldquo;995&rdquo; ] -a [ &ldquo;123&rdquo; -gt &ldquo;33&rdquo; ]</h1>

<p>-bash: [: too many arguments<br />
下面例子测试两个表达式，如果都为真，结果为真，正确使用方式应为：<br />
#[ &ldquo;990&rdquo; -le &ldquo;995&rdquo; -a &ldquo;123&rdquo; -gt &ldquo;33&rdquo; ]<br />
[root@localhost ~]# echo $?<br />
0</p>

<p>expr命令一般用于整数值，但也可用于字符串。一般格式为：<br />
expr argument operator argument<br />
expr也是一个手工命令行计数器。</p>

<h1 id="expr-10-10">expr 10 + 10</h1>

<p>20</p>

<h1 id="expr-900-600">expr 900 + 600</h1>

<p>1500</p>

<h1 id="expr-30-3">expr 30 / 3</h1>

<p>10</p>

<h1 id="expr-30-3-2">expr 30 / 3 / 2</h1>

<p>5<br />
使用乘号时，必须用反斜线屏蔽其特定含义。因为shell可能会误解显示星号的意义。</p>

<h1 id="expr-30-3-1">expr 30 \* 3</h1>

<p>90</p>

<p>增量计数<br />
expr在循环中用于增量计算。首先，循环初始化为0，然后循环值加1，反引号的用法意<br />
即替代命令。最基本的一种是从（expr）命令接受输出并将之放入循环变量。</p>

<h1 id="loop-0">LOOP=0</h1>

<h1 id="loop-expr-loop-1">LOOP=<code>expr $LOOP + 1</code></h1>

<h1 id="echo-loop">echo $LOOP</h1>

<p>1</p>

<p>数值测试<br />
可以用expr测试一个数。如果试图计算非整数，将返回错误。</p>

<h1 id="expr-rr-1">expr rr + 1</h1>

<p>xpr: non-numeric argument<br />
这里需要将一个值赋予变量（不管其内容如何），进行数值运算，并将输出导入dev/null，然后测试最后命令状态，如果为0，证明这是一个数，其他则表明为非数值。</p>

<h1 id="value-12">VALUE=12</h1>

<h1 id="expr-value-10-dev-null-2-1">expr $VALUE + 10 &gt; /dev/null 2&gt;&amp;1</h1>

<h1 id="echo-16">echo $?</h1>

<p>0<br />
这是一个数。</p>

<h1 id="value-hello">VALUE=hello</h1>

<h1 id="expr-value-10-dev-null-2-1-1">expr $VALUE + 10 &gt; /dev/null 2&gt;&amp;1</h1>

<h1 id="echo-17">echo $?</h1>

<p>3<br />
这是一个非数值字符。<br />
expr也可以返回其本身的退出状态，不幸的是返回值与系统最后退出命令刚好相反，成<br />
功返回1，任何其他值为无效或错误。下面的例子测试两个字符串是否相等，这里字符串为&rdquo;hello&rdquo;和&rdquo;hello&rdquo;。</p>

<h1 id="value-hello-1">VALUE=hello</h1>

<h1 id="expr-value-hello">expr $VALUE = &ldquo;hello&rdquo;</h1>

<p>1</p>

<h1 id="echo-18">echo $?</h1>

<p>0<br />
expr返回1。不要混淆了，这表明成功。现在检验其最后退出状态，返回0表示测试成功，&rdquo;hello&rdquo;确实等于&rdquo;hello&rdquo;。</p>

<p>模式匹配<br />
expr也有模式匹配功能。可以使用expr通过指定冒号选项计算字符串中字符数。. *意即任何字符重复0次或多次。</p>

<h1 id="value-accounts-doc">VALUE=accounts.doc</h1>

<h1 id="expr-value">expr $VALUE : &lsquo;.*&rsquo;</h1>

<p>12<br />
其匹配的方式是，expr 字符串 : 正则表达式</p>

<p>在expr中可以使用字符串匹配操作，这里使用模式. doc抽取文件附属名。</p>

<h1 id="expr-value-doc">expr $VALUE : &lsquo;\(.*\).doc&rsquo;</h1>

<p>accounts</p>

<p>3.2,控制流结构<br />
所有功能脚本必须有能力进行判断，也必须有能力基于一定条件处理相关命令。本章讲述这方面的功能，在脚本中创建和应用控制结构.</p>

<p>退出状态<br />
在书写正确脚本前，大概讲一下退出状态。任何命令进行时都将返回一个退出状态。如果要观察其退出状态，使用最后状态命令：<br />
$ echo $?<br />
主要有4种退出状态。前面已经讲到了两种，即最后命令退出状态$ ?和控制次序命令（
$$,||）。其余两种是处理SHELL脚本或shell退出及相应退出状态或函数返回码。在第19章讲到函数时，也将提到其返回码。<br />
要退出当前进程，s h e l l提供命令e x i t，一般格式为：<br />
exit n<br />
其中，n为一数字。<br />
如果只在命令提示符下键入e x i t，假定没有在当前状态创建另一个s h e l l，将退出当前s h e l l。<br />
如果在脚本中键入e x i t，s h e l
l将试图（通常是这样）返回上一个命令返回值。有许多退出脚本值，但其中相对于脚本和一般系统命令最重要的有两种，即：<br />
退出状态0 退出成功，无错误。<br />
退出状态1 退出失败，某处有错误。<br />
可以在shell脚本中加入自己的退出状态（它将退出脚本）。本书鼓励这样做，因为另一个shell脚本或返回函数可能要从shell脚本中抽取退出脚本。另外，相信加入脚本本身的退出脚本值是一种好的编程习惯。</p>

<p>如果愿意，用户可以在一个用户输入错误后或一个不可覆盖错误后或正常地处理结束后<br />
退出脚本。<br />
注意从现在起，本书所有脚本都将加入注释行。注释行将解释脚本具体含义，帮助用户理解脚本。可以在任何地方加入注释行，因为其本身被解释器忽略。注释行应以#开头。</p>

<p>A,控制结构<br />
几乎所有的脚本里都有某种流控制结构，很少有例外。流控制是什么？假定有一个脚本包含下列几个命令：<br />
#!/bin/sh</p>

<h1 id="make-a-directory">make a directory</h1>

<p>mkdir /home/dave/mydocs</p>

<h1 id="copy-all-doc-files">copy all doc files</h1>

<p>cp *.docs /home/dave/docs</p>

<h1 id="delete-all-doc-files">delete all doc files</h1>

<p>rm *.docs</p>

<p>上述脚本问题出在哪里？如果目录创建失败或目录创建成功文件拷贝失败，如何处理？里需要从不同的目录中拷贝不同的文件。必须在命令执行前或最后的命令退出前决定处理方法。s
h e l l会提供一系列命令声明语句等补救措施来帮助你在命令成功或失败时，或需要处理一个命令清单时采取正确的动作。</p>

<p>1,流控制<br />
i f、t h e n、e l s e语句提供条件测试。测试可以基于各种条件。例如文件的权限、长度、数值或字符串的比较。这些测试返回值或者为真（
0），或者为假（ 1）。基于此结果，可以进行相关操作。在讲到条件测试时已经涉及了一些测试语法。<br />
c a s e语句允许匹配模式、单词或值。一旦模式或值匹配，就可以基于这个匹配条件作其他声明。<br />
2,循环<br />
循环或跳转是一系列命令的重复执行过程，本书提到了3种循环语句：<br />
w<br />
for 循环每次处理依次列表内信息，直至循环耗尽。<br />
Until 循环此循环语句不常使用， u n t i l循环直至条件为真。条件部分在循环末尾部分。<br />
While 循环w h i l e循环当条件为真时，循环执行，条件部分在循环头。流控制语句的任何循环均可嵌套使用，例如可以在一个f o r循环中嵌入另一个f
o r循环。<br />
现在开始讲解循环和控制流，并举一些脚本实例。<br />
从现在起，脚本中e c h o语句使用L I N U X或B S D版本，也就是说使用e c h o方法echo -e -n，意即从e c h
o结尾中下一行执行命令。应用于U N I X（系统V和B S D）的统一的e c h o命令参阅1 9章s h e l l函数。</p>

<p>if then else语句<br />
i f语句测试条件，测试条件返回真（ 0）或假（1）后，可相应执行一系列语句。i f语句结<br />
构对错误检查非常有用。其格式为：<br />
if 条件1<br />
then 命令1<br />
elif 条件2<br />
then 命令2<br />
else 命令3<br />
f i<br />
让我们来具体讲解i f语句的各部分功能。<br />
If 条件1 如果条件1为真<br />
Then 那么<br />
命令1 执行命令1<br />
elif 条件2 如果条件1不成立<br />
then 那么<br />
命令2 执行命令2<br />
else 如果条件1，2均不成立<br />
命令3 那么执行命令3<br />
fi 完成<br />
i f语句必须以单词f i终止。在i f语句中漏写f i是最一般的错误。我自己有时也是这样。e l i f和e l s
e为可选项，如果语句中没有否则部分，那么就不需要e l i f和e l s e部分。I f语句可以有许多e l i f部分。最常用的i f语句是if
then fi结构。<br />
if&hellip;then是最常见的条件判断语句，简而言之，就是符合某个条件判断的时候，就予以进行某项工作就是了，我们可以简单地这样子看：<br />
if [ 条件判断表达式 ]; then<br />
当条件判断表达式成立时可以执行的命令<br />
fi</p>

<p>较特别的是，如果有多个条件判断时，可以将多个判断写入一个中括号，还可以使用多个中括号隔开，而括号和括号之间，则以&amp;&amp;或||来隔开，这个要和命令行中的&amp;&amp;，||区别开来。</p>

<h1 id="cat-iftest">cat iftest</h1>

<p>#!/bin/sh</p>

<h1 id="iftest">iftest</h1>

<h1 id="this-is-a-comment-line-all-commment-lines-start-with-a">this is a comment line, all commment lines start with a #</h1>

<p>if [ &ldquo;10&rdquo; -lt &ldquo;12&rdquo; ]<br />
then</p>

<h1 id="yes-10-is-less-than-12">yes 10 is less than 12</h1>

<p>echo &ldquo;Yes, 10 is less than 12&rdquo;<br />
fi</p>

<p>变量值测试<br />
通过测试设置为接受用户输入的变量可以测知用户是否输入信息。下面的例子中测试用户键入r e t u r n键后变量n a m e是否包含任何信息。</p>

<h1 id="cat-iftest2-sh">cat iftest2.sh</h1>

<p>#!/bin/sh</p>

<h1 id="iftest2">iftest2</h1>

<p>echo -n &ldquo;Enter your name :&rdquo;<br />
read NAME</p>

<h1 id="did-the-user-just-hit-return">did the user just hit return ???</h1>

<p>if [ &ldquo;$NAME&rdquo; == &ldquo;&rdquo; ]; then<br />
echo &ldquo;You did not enter any information&rdquo;<br />
fi<br />
#./iftest2.sh<br />
Enter your name :<br />
You did not enter any information<br />
grep输出检查<br />
不必拘泥于变量或数值测试，也可以测知系统命令是否成功返回。对g r e p使用i f语句找出g r e p是否成功返回信息。下面的例子中g r e
p用于查看D a v e是否在数据文件d a t a . f i l e中，注意‘D a v e \ &gt;’用于精确匹配。</p>

<p>[root@localhost ~]# cat grepif.sh<br />
#!/bin/sh</p>

<h1 id="grepif-sh">grepif.sh</h1>

<p>if grep &lsquo;Dave&gt;&rsquo; data.file &gt; /dev/null 2&gt;&amp;1<br />
then<br />
echo &ldquo;Great Dave is in the file&rdquo;<br />
else<br />
echo &ldquo;No Dave is not in the file&rdquo;<br />
fi<br />
[root@localhost ~]# ./grepif.sh<br />
No Dave is not in the file</p>

<p>用变量测试grep输出<br />
正像前面看到的，可以用g r e p作字符串操作。下面的脚本中，用户输入一个名字列表，g r e p在变量中查找，要求其包含人名P e t e
r。下面是具体的代码情况和运行信息。</p>

<p>[root@localhost ~]# cat grepstr.sh<br />
#!/bin/sh</p>

<h1 id="grepstr">grepstr</h1>

<p>echo -n &ldquo;Enter a list of names:&rdquo;<br />
read list<br />
if echo $list | grep &ldquo;Peter&rdquo; &gt; /dev/null 2&gt;&amp;1<br />
then<br />
echo &ldquo;Peter is here&rdquo;</p>

<h1 id="could-do-some-processing-here">could do some processing here&hellip;</h1>

<p>else<br />
echo &ldquo;Peter&rsquo;s not in the list. No comment!&rdquo;<br />
fi<br />
[root@localhost ~]# ./grepstr.sh<br />
Enter a list of names:John Louise Peter James<br />
Peter is here<br />
文件拷贝输出检查<br />
下面测试文件拷贝是否正常，如果c p命令并没有拷贝文件m y f i l e到m y f i l e . b a k，则打印错误信息。注意错误信息中<code>
basename $0</code>打印脚本名。如果脚本错误退出，一个好习惯是显示脚本名并将之定向到标准错误中。用户应该知道产生错误的脚本名<br />
[root@localhost ~]# cat ifcp.sh<br />
#!/bin/sh</p>

<h1 id="ifcp-sh">ifcp.sh</h1>

<p>if cp myfile myfile.bak; then<br />
echo &ldquo;good copy&rdquo;<br />
else<br />
echo &ldquo;<code>basename $0</code>: error could not copy the file&rdquo; &gt;&amp;2<br />
fi<br />
[root@localhost ~]# ./ifcp.sh<br />
cp: cannot stat `myfile&rsquo;: No such file or directory<br />
ifcp.sh: error could not copy the file<br />
注意，文件可能没找到，系统也产生本身的错误信息，这类错误信息可能与输出混在一起。既然已经显示系统错误信息获知脚本失败，就没必要显示两次。要去除系统产生的错误和系统输出，只需简单的将标准错误和输出重定向即可。修改脚本为：
&gt;/dev/null 2&gt;&amp;1。</p>

<p>[root@localhost ~]# cat ifcp.sh<br />
#!/bin/sh</p>

<h1 id="ifcp-sh-1">ifcp.sh</h1>

<p>if cp myfile myfile.bak &gt; /dev/null 2&gt;&1; then<br />
echo &ldquo;good copy&rdquo;<br />
else<br />
echo &ldquo;<code>basename $0</code>: error could not copy the file&rdquo; &gt;&amp;2<br />
fi<br />
[root@localhost ~]# ./ifcp.sh<br />
ifcp.sh: error could not copy the file</p>

<p>上面当中&gt;/dev/null表示任何标准输出都定向到那个无尽的“黑洞”/de/null中，然后2&gt;&amp;1表示错误输出也是到/dev/null中，&amp;1表示前面的那个/dev/null，脚本运行时，所有输出包括错误重定向至系统垃圾堆。</p>

<p>当前目录测试<br />
当运行一些管理脚本时，可能要在根目录下运行它，特别是移动某种全局文件或进行权限改变时。一个简单的测试可以获知是否运行在根目录下。下面脚本中变量D I R E
C TO RY使用当前目录的命令替换操作，然后此变量值与&rdquo; /&ldquo;字符串比较（
/为根目录）。如果变量值与字符串不等，则用户退出脚本，退出状态为1意味错误信息产生。<br />
[root@localhost ~]# cat ifpwd.sh<br />
#!/bin/sh</p>

<h1 id="ifpwd-sh">ifpwd.sh</h1>

<p>DIRECTORY=<code>pwd</code></p>

<h1 id="grab-the-current-dirctory">grab the current dirctory</h1>

<p>if [ &ldquo;$DIRECTORY&rdquo; != &ldquo;/&rdquo; ]; then</p>

<h1 id="is-it-the-root-directory">is it the root directory ?</h1>

<h1 id="no-the-direct-output-to-standard-error-which-is-the-screen">no, the direct output to standard error, which is the screen</h1>

<h1 id="by-default">by default.</h1>

<p>echo &ldquo;You need to be in the root directory no $DIRECTORY to run<br />
this script&rdquo; &gt;&amp;2</p>

<h1 id="exit-with-a-value-of-1-an-error">exit with a value of 1, an error</h1>

<p>exit 1<br />
fi</p>

<h1 id="ifpwd-sh-1">./ifpwd.sh</h1>

<p>You need to be in the root directory no /root to run this script<br />
文件权限测试<br />
可以用i f语句测试文件权限，下面简单测试文件t e s t . t x t是否被设置到变量L O G N A M
E，测试test.txt文件是否具有写的权限。下面的脚本先建立一个test.txt的空白文档，列出它的相关权限。然后执行脚本测试其是否可以写入，然后显示相关信息。</p>

<h1 id="touch-test-txt">touch test.txt</h1>

<p>[root@localhost ~]# ls -l test.txt<br />
--rw-r&ndash;r&ndash; 1 root root 0 Nov 21 15:21 test.txt<br />
[root@localhost ~]# chmod u+x ifwr.sh<br />
[root@localhost ~]# cat ifwr.sh<br />
#!/bin/sh</p>

<h1 id="ifwr-sh">ifwr.sh</h1>

<p>LOGFILE=test.txt<br />
echo $LOGFILE<br />
if [ ! -w &ldquo;$LOGFILE&rdquo; ];<br />
then<br />
echo &ldquo; You cannot write to $LOGFILE&rdquo; &gt;&amp;2<br />
else<br />
echo &ldquo; You can write to $LOGFILE&rdquo; &gt;&amp;2<br />
fi<br />
[root@localhost ~]# ./ifwr.sh<br />
test.txt<br />
You can write to test.txt</p>

<p>测试传递到脚本中的参数<br />
i f语句可用来测试传入脚本中参数的个数。使用特定变量$
#，表示调用参数的个数。可以测试所需参数个数与调用参数个数是否相等。以下测试确保脚本有三个参数。如果没有，则返回一个可用信息到标准错误，然后代码<br />
退出并显示退出状态。如果参数数目等于3，则显示所有参数。</p>

<p>[root@localhost ~]# cat ifparam.sh<br />
#!/bin/sh</p>

<h1 id="ifparam">ifparam</h1>

<p>if [ $# -lt 3 ]; then</p>

<h1 id="less-than-3-parameters-called-echo-a-usage-message-and-exit">less than 3 parameters called, echo a usage message and exit</h1>

<h1 id="如果少于三个参数则显示使用的信息-然后退出">如果少于三个参数则显示使用的信息，然后退出。</h1>

<p>echo &ldquo;Usage: <code>basename $0</code>arg1 arg2 arg3&rdquo; &gt;&amp;2<br />
exit 1<br />
fi</p>

<h1 id="good-received-3-params-let-s-echo-them">good, received 3 params, let&rsquo;s echo them</h1>

<h1 id="好-现在接受了三个参数-让我们开始显示他们">好，现在接受了三个参数，让我们开始显示他们</h1>

<p>echo &ldquo;arg1: $1&rdquo;<br />
echo &ldquo;arg2: $2&rdquo;<br />
echo &ldquo;arg3: $3&rdquo;<br />
[root@localhost ~]# ./ifparam.sh cup medal<br />
Usage: ifparam.sharg1 arg2 arg3<br />
[root@localhost ~]# ./ifparam.sh cup medal trophy<br />
arg1: cup<br />
arg2: medal<br />
arg3: trophy<br />
从上面的运行信息可以看出，如果只传入两个参数，则显示一可用信息，然后脚本退出。<br />
只有正确传入了三个参数了，才显示所有的参数然后退出。<br />
决定脚本是否为交互模式<br />
有时需要知道脚本运行是交互模式（终端模式）还是非交互模式（ c r o n或a t）。脚本也许<br />
需要这个信息以决定从哪里取得输入以及输出到哪里，使用t e s t命令并带有- t选项很容易确认这一点。如果t e s
t返回值为1，则为交互模式。假如我是在一个终端下运行下面这个脚本。<br />
[root@localhost ~]# cat ifinteractive.sh<br />
#!/bin/sh</p>

<h1 id="ifinteractive-sh">ifinteractive.sh</h1>

<p>if [ -t ]; then<br />
echo &ldquo;We are interactive with a terminal&rdquo;<br />
else<br />
echo &ldquo;We must be running from some background process probably<br />
cron or at&rdquo;<br />
fi<br />
[root@localhost ~]# ./ifinteractive.sh<br />
We are interactive with a terminal<br />
简单的if else语句<br />
下一个i f语句有可能是使用最广泛的：<br />
if 条件<br />
t h e n<br />
命令1<br />
e l s e<br />
命令2<br />
f i<br />
使用i f语句的e l s e部分可在条件测试为假时采取适当动作。</p>

<p>变量设置测试</p>

<p>下面的例子测试环境变量E D I TO R是否已设置。如果E D I TO R变量为空，将此信息通知用<br />
户。如果已设置，在屏幕上显示编辑类型。<br />
[root@localhost ~]# cat ifeditor.sh<br />
#!/bin/sh</p>

<h1 id="ifeditor-sh">ifeditor.sh</h1>

<p>if [ -z $EDITOR ]; then</p>

<h1 id="the-variable-has-not-been-set">the variable has not been set</h1>

<h1 id="变量没有设置">变量没有设置</h1>

<p>echo &ldquo;Your EDITOR environment is not set&rdquo;<br />
else</p>

<h1 id="let-s-see-what-it-is">let&rsquo;s see what it is</h1>

<h1 id="如果设置了-让我们来看看它到底是什么">如果设置了，让我们来看看它到底是什么</h1>

<p>echo &ldquo;Using $EDITOR as the default editor&rdquo;<br />
fi<br />
[root@localhost ~]# ./ifeditor.sh<br />
Your EDITOR environment is not set</p>

<p>将脚本参数传入系统命令<br />
可以向脚本传递位置参数，然后测试变量。这里，如果用户在脚本名字后键入目录名，脚本将重设$ 1特殊变量为一更有意义的名字。即D I R E C TO
RY。这里需测试目录是否为空，如果目录为空，ls -A将返回空，然后对此返回一信息。</p>

<h1 id="ifdirec-sh">ifdirec.sh</h1>

<h1 id="assigning-1-to-directory-variable">assigning $1 to DIRECTORY variable</h1>

<p>DIRECTORY=$1<br />
if [ &ldquo;<code>ls -A $DIRECTORY</code>&rdquo; == &ldquo;&rdquo; ]; then</p>

<h1 id="if-it-s-an-empty-string-then-it-s-empty">if it&rsquo;s an empty string, then it&rsquo;s empty</h1>

<p>echo &ldquo;$DIRECTORY is indeed empty&rdquo;<br />
else</p>

<h1 id="otherwise-it-is-not">otherwise it is not</h1>

<p>echo &ldquo;$DIRECTORY is not empty&rdquo;<br />
fi</p>

<p>null：命令用法<br />
到目前为止，条件测试已经讲完了t h e n和e l s e部分，有时也许使用者并不关心条件为真或为假。<br />
不幸的是i f语句各部分不能为空—一些语句已经可以这样做。为解决此问题， s h e l
l提供了：空命令。空命令永远为真（也正是预想的那样）。回到前面的例子，如果目录为空，可以只在t h e n部分加入命令。<br />
[root@localhost ~]# cat ifdirectory.sh<br />
#!/bin/sh</p>

<h1 id="ifdirectory-sh">ifdirectory.sh</h1>

<p>DIRECTORY=$1<br />
if [ &ldquo;<code>ls -A $DIRECTORY</code>&rdquo; == &ldquo;&rdquo; ]<br />
then<br />
echo &ldquo;$DIRECTORY is indeed empty&rdquo;<br />
else :</p>

<h1 id="do-nothing">do nothing</h1>

<p>fi<br />
[root@localhost ~]# ./ifdirectory.sh testd<br />
testd is indeed empty</p>

<p>测试目录创建结果<br />
现在继续讨论目录，下面的脚本接受一个参数，并用之创建目录，然后参数被传入命令行，重设给变量D I R E C TO RY，最后测试变量是否为空。<br />
if [&ldquo;$DIRECTORY&rdquo;=&ldquo;&rdquo;]<br />
也可以用<br />
if[$# -lt 1]<br />
来进行更普遍的参数测试。<br />
如果字符串为空，返回一可用信息，脚本退出。如果目录已经存在，脚本从头至尾走一遍，什么也没做。创建前加入提示信息，如果键入Y或y，则创建目录，否则使用空命令表示不采取任何动作。使用最后命令状态测试创建是否成功执行，如果失败，返回相应信息。<br />
[root@localhost ~]# cat ifmkdir.sh<br />
#!/bin/sh</p>

<h1 id="ifmkdir-sh">ifmkdir.sh</h1>

<h1 id="parameter-is-passed-as-1-but-reassigned-to-directory">parameter is passed as $1 but reassigned to DIRECTORY</h1>

<p>DIRECTORY=$1</p>

<h1 id="is-the-string-empty">is the string empty ??</h1>

<p>if [ &ldquo;$DIRECTORY&rdquo; == &ldquo;&rdquo; ]<br />
then<br />
echo &ldquo;Usage :<code>basename $0</code> directory to create&rdquo; &gt;&amp;2<br />
exit 1<br />
fi<br />
if [ -d $DIRECTORY ]<br />
then : # do nothing<br />
else<br />
echo &ldquo;The directory does not exist&rdquo;<br />
echo -n &ldquo;Create it now? [y..n] :&rdquo;<br />
read ANS<br />
if [ &ldquo;$ANS&rdquo; == &ldquo;y&rdquo; ] || [ &ldquo;$ANS&rdquo; == &ldquo;Y&rdquo; ]<br />
then<br />
echo &ldquo;creating now&rdquo;</p>

<h1 id="create-directory-and-send-all-output-to-dev-null">create directory and send all output to /dev/null</h1>

<p>mkdir $DIRECTORY &gt; /dev/null 2&gt;&amp;1<br />
if [ $? != 0 ]; then<br />
echo &ldquo;Errors creating the directory $DIRECTORY&rdquo; &gt;&amp;2<br />
exit 1<br />
fi<br />
else : # do nothing<br />
fi<br />
fi<br />
[root@localhost ~]# ./ifmkdir.sh dt<br />
The directory does not exist<br />
Create it now? [y..n] :y<br />
creating now</p>

<p>另一个拷贝实例<br />
在另一个拷贝实例中，脚本传入两个参数（应该包含文件名），系统命令c p将$ 1拷入$ 2，输出至/ d e v / n u l
l。如果命令成功，则仍使用空命令并且不采取任何动作。另一方面，如果失败，在脚本退出前要获知此信息<br />
[root@localhost ~]# cat ifcp2.sh<br />
#!/bin/sh</p>

<h1 id="ifcp2-sh">ifcp2.sh</h1>

<p>if cp $1 $2 &gt; /dev/null 2&gt;&amp;1</p>

<h1 id="successful-great-do-nothing">successful, great do nothing</h1>

<p>then :<br />
else</p>

<h1 id="oh-dear-show-the-user-what-files-they-were">oh dear, show the user what files they were.</h1>

<p>echo &ldquo;<code>basename $0</code>: ERROR failed to copy $1 to $2&rdquo;<br />
exit 1<br />
fi<br />
[root@localhost ~]# ./ifcp2.sh myfile.lex myfile.lex.bak<br />
ifcp2.sh: ERROR failed to copy myfile.lex to myfile.lex.bak<br />
[root@localhost ~]# touch myfile.lex<br />
[root@localhost ~]# ./ifcp2.sh myfile.lex myfile.lex.bak<br />
上面展现了脚本运行成功和脚本运行失败的情况。<br />
下面的脚本用s o r t命令将文件a c c o u n t s . q t r分类，并输出至系统垃圾堆。没人愿意观察屏幕上3 0
0行的分类页。成功之后不采取任何动作。如果失败，通知用户。<br />
[root@localhost ~]# cat ifsort.sh<br />
#!/bin/sh</p>

<h1 id="ifsort">ifsort</h1>

<p>if sort accounts.qtr &gt; /dev/null</p>

<h1 id="sorted-great">sorted. Great</h1>

<p>then :<br />
else</p>

<h1 id="better-let-the-user-know">better let the user know</h1>

<p>echo &ldquo;<code>basename $0</code>: Oops..errors could not sort accounts.qtr&rdquo;<br />
fi<br />
多个if语句<br />
可能有时要嵌入i f语句。为此需注意i f和f i的相应匹配使用。</p>

<p>测试和设置环境变量<br />
前面已经举例说明了如何测试环境变量E D I TO R是否被设置。现在如果未设置，则进一步为其赋值，脚本如下：<br />
#!/bin/sh</p>

<h1 id="ifseted-sh">ifseted.sh</h1>

<h1 id="is-the-editor-set">is the EDITOR set?</h1>

<p>if [ -z $EDITOR ]; then<br />
echo &ldquo;Your EDITOR environment is not set&rdquo;<br />
echo &ldquo;I will assum you want to use vi .. OK&rdquo;<br />
echo -n &ldquo;Do you wish to change it now? [y..n] :&rdquo;<br />
read ANS</p>

<h1 id="check-for-an-upper-or-lower-case-y">check for an upper or lower case &lsquo;y&rsquo;</h1>

<p>if [ &ldquo;$ANS&rdquo; == &ldquo;Y&rdquo; ] || [ &ldquo;$ANS&rdquo; == &ldquo;y&rdquo; ]; then<br />
echo &ldquo;enter you editor type :&rdquo;<br />
read EIDTOR<br />
if [ -z $EDITOR ] || [ &ldquo;$EDITOR&rdquo; == &ldquo;&rdquo; ]; then</p>

<h1 id="if-editor-not-set-and-no-value-in-variable-editor">if EDITOR not set and no value in variable EDITOR,</h1>

<h1 id="then-set-it-to-vi">then set it to vi</h1>

<p>echo &ldquo;No, editor entered, using vi as default&rdquo;<br />
EDITOR=vi<br />
export EDITOR<br />
fi</p>

<h1 id="got-a-value-use-it-for-editor">got a value use it for EDITOR</h1>

<p>EDITOR=$EDITOR<br />
export EDITOR<br />
echo &ldquo;setting $EDITOR&rdquo;<br />
fi<br />
else</p>

<h1 id="user">user</h1>

<p>echo &ldquo;Using vi as the default editor&rdquo;<br />
EDITOR=vi<br />
export EDITOR<br />
fi</p>

<p>脚本工作方式如下：首先检查是否设置了该变量，如果已经赋值，输出信息提示使用v i作为缺省编辑器。v
i被设置为编辑器，然后脚本退出。如果未赋值，则提示用户，询问其是否要设置该值。检验用户输入是否为大写或小写y，输入为其他值时，脚本退出。如果输入Y或y，再提示输入编辑类型。使用$
E D I TO R =“”测试用户是否未赋值和未点击r e t u r n键。一种更有效的方法是使用-z $EDITO
R方法，本文应用了这两种方法。如果测试失败，返回信息到屏幕，即使用v i做缺省编辑器，因而E D I TO R赋值为v i。如果用户输入了一个名字到变量E
D I TO R，则使用它作为编辑器并马上让其起作用，即导出变量E D I TO R。</p>

<p>检测最后命令状态<br />
前面将目录名传入脚本创建了一个目录，脚本然后提示用户是否应创建目录。下面的例子创建一个目录，并从当前目录将所有* . t x
t文件拷入新目录。但是这段脚本中用最后状态命令检测了每一个脚本是否成功执行。如果命令失败则通知户。</p>

<p>#!/bin/sh</p>

<h1 id="ifmkdir2-sh">ifmkdir2.sh</h1>

<p>DIR_NAME=testdirec</p>

<h1 id="where-are-we">where are we?</h1>

<p>THRER=<code>pwd</code></p>

<h1 id="send-all-output-to-the-system-dustbin">send all output to the system dustbin</h1>

<p>mkdir $DIR_NAME &gt; /dev/null 2&gt;&amp;1</p>

<h1 id="is-it-a-directory">is it a directory ?</h1>

<p>if [ -d $DIR_NAME ]; then</p>

<h1 id="can-we-cd-to-the-directory">can we cd to the directory</h1>

<p>cd $DIR_NAME<br />
if [ $? == 0 ]; then</p>

<h1 id="yes-we-can">yes we can</h1>

<p>HERE=<code>pwd</code><br />
cp $THERE/*.txt $HERE<br />
else<br />
echo &ldquo;Cannot cd to $DIR_NAME&rdquo; &gt;&amp;2<br />
exit 1<br />
fi<br />
else<br />
echo &ldquo;Cannnot create directory $DIR_NAME&rdquo; &gt;&amp;2<br />
exit 1<br />
fi</p>

<p>增加和检测整数值<br />
下面的例子进行数值测试。脚本包含了一个计数集，用户将其赋予一个新值就可改变它。脚本然后将当前值1 0 0加入一个新值。工作流程如下：<br />
用户输入一个新值改变其值，如果键入回车键，则不改变它，打印当前值，脚本退出。如果用户用y或Y响应新值，将提示用户输入增量。如果键入回车键，原值仍未变。键入一个增量，首先测试是否为数字，如果是，加入计数C
O U N TO R中，最后显示新值。<br />
#!/bin/sh</p>

<h1 id="ifcounter-sh">ifcounter.sh</h1>

<p>COUNTER=100<br />
echo &ldquo;Do you wish to change the counter value currently set at $COUNTER[y..n]
:&rdquo;<br />
read ANS<br />
if [ &ldquo;$ANS&rdquo; == &ldquo;y&rdquo; ] || [ &ldquo;$ANS&rdquo; == &ldquo;Y&rdquo; ]; then</p>

<h1 id="yes-user-wants-to-change-the-value">yes user wants to change the value</h1>

<p>echo &ldquo;Enter a sensible value &rdquo;<br />
read VALUE</p>

<h1 id="simple-test-to-see-if-it-s-numeric-add-any-number-to-value">simple test to see if it&rsquo;s numeric, add any number to VALUE,</h1>

<h1 id="then-check-out-return">then check out return</h1>

<h1 id="code">code</h1>

<p>expr $VALUE + 10 &gt; /dev/null 2&gt;&amp;1<br />
STATUS=$?</p>

<h1 id="check-return-code-of-expr">check return code of expr</h1>

<p>if [ &ldquo;$VALUE&rdquo; == &ldquo;&rdquo; ] || [ &ldquo;$STATUS&rdquo; != &ldquo;0&rdquo; ]; then</p>

<h1 id="send-errors-to-standard-error">send errors to standard error</h1>

<p>echo &ldquo; You either entered nothing or a non-numeric &rdquo; &gt;&amp;2<br />
echo &ldquo; Sorry now exiting&hellip;counter stays at $COUNTER&rdquo; &gt;&amp;2<br />
exit 1<br />
fi</p>

<h1 id="if-we-are-here-then-it-s-a-number-so-add-it-to-counter">if we are here, then it&rsquo;s a number, so add it to COUNTER</h1>

<p>COUNTER=<code>expr $COUNTER + $VALUE</code><br />
echo &ldquo; Counter now set to $COUNTER&rdquo;<br />
else</p>

<h1 id="if-we-are-here-user-just-hit-return-instead-of-entering-a-number">if we are here user just hit return instead of entering a number</h1>

<h1 id="or-anssered-n-to-the-change-a-value-prompt">or anssered n to the change a value prompt</h1>

<p>echo &ldquo; Counter stays at $COUNTER&rdquo;<br />
fi<br />
下面是程序的运行结果：<br />
[root@localhost ~]# ./ifcounter.sh<br />
Do you wish to change the counter value currently set at 100<br />
[y..n] :n<br />
Counter stays at 100<br />
[root@localhost ~]# ./ifcounter.sh<br />
Do you wish to change the counter value currently set at 100<br />
[y..n] :y<br />
Enter a sensible value<br />
fdg<br />
You either entered nothing or a non-numeric<br />
Sorry now exiting&hellip;counter stays at 100<br />
[root@localhost ~]# ./ifcounter.sh<br />
Do you wish to change the counter value currently set at 100<br />
[y..n] :y<br />
Enter a sensible value<br />
250<br />
Counter now set to 350</p>

<p>tty当前设置被保存，以便隐藏passwd域中字符，然后重新保存stty设置。<br />
如果用户ID和密码正确（密码是easypasswd），明亮I N VA L I D U S E R和I N VA L I D PA S S W D设置为n
o表示有效用户或密码，然后执行测试，如果两个变量其中之一为y e s，缺省情况下，脚本退出用户。<br />
键入有效的I D和密码，用户将允许进入。这是一种登录脚本的基本框架。下面的例子中有效用户I D为root。<br />
提示：在实际中千万不要这么做，任何人都知道用root身份进行测试是很危险的。<br />
#!/bin/sh</p>

<h1 id="ifpass-sh">ifpass.sh</h1>

<h1 id="set-the-variables-to-false">set the variables to false</h1>

<p>INVALID_USER=yes<br />
INVALID_PASSWD=yes</p>

<h1 id="save-the-current-stty-settings">save the current stty settings</h1>

<p>SAVEDSTTY=<code>stty -g</code><br />
echo &ldquo;You are logging into a sensitive area&rdquo;<br />
echo -n &ldquo;Enter your ID name :&rdquo;<br />
read NAME</p>

<h1 id="hide-the-characters-typed-in">hide the characters typed in</h1>

<p>stty -echo<br />
echo &ldquo;Enter your password :&rdquo;<br />
read PASSWORD</p>

<h1 id="back-on-again">back on again</h1>

<p>stty $SAVEDSTTY<br />
if [ &ldquo;$NAME&rdquo; == &ldquo;root&rdquo; ]; then</p>

<h1 id="if-a-valid-then-set-variable">if a valid then set variable</h1>

<p>INVALID_USER=no<br />
fi<br />
if [ &ldquo;$PASSWORD&rdquo; == &ldquo;easypasswd&rdquo; ]; then</p>

<h1 id="if-valid-password-then-set-variable">if valid password then set variable</h1>

<p>INVALID_PASSWD=no<br />
fi<br />
if [ &ldquo;$INVALID_USER&rdquo; == &ldquo;yes&rdquo; -o &ldquo;$INVALID_PASSWD&rdquo; == &ldquo;yes&rdquo; ]; then<br />
echo &ldquo;<code>basename $0 :</code> Sorry wrong password or userid&rdquo;<br />
exit 1<br />
fi</p>

<h1 id="if-we-get-here-then-their-id-and-password-are-ok">if we get here then their ID and password are OK.</h1>

<p>echo &ldquo;correct user id an password given&rdquo;<br />
下面是对应两种不同情况的输出结果。<br />
[root@localhost ~]# ./ifpass.sh<br />
You are logging into a sensitive area<br />
Enter your ID name :root<br />
Enter your password :<br />
correct user id an password given<br />
[root@localhost ~]# ./ifpass.sh<br />
You are logging into a sensitive area<br />
Enter your ID name :root<br />
Enter your password :<br />
ifpass.sh Sorry wrong password or userid</p>

<p>elif用法<br />
if then else语句的e l i f部分用于测试两个以上的条件.<br />
使用elif进行多条件检测<br />
使用一个简单的例子，测试输入脚本的用户名。脚本首先测试是否输入一个名字，如果没有，则什么也不做。如果输入了，则用e l i f测试是否匹配r o o t、l
o u i s e或d a v e，如果不匹配其中任何一个，则打印该名字，通知用户不是r o o t、l o u i s e或d a v e。<br />
#!/bin/sh</p>

<h1 id="ifelif-sh">ifelif.sh</h1>

<p>echo -n &ldquo;enter your login name :&rdquo;<br />
read NAME</p>

<h1 id="no-name-entered-do-not-carry-on">no name entered do not carry on</h1>

<p>if [ -z $NAME ] || [ &ldquo;$NAME&rdquo; == &ldquo;&rdquo; ]; then<br />
echo &ldquo;You did not enter a name&rdquo;<br />
elif</p>

<h1 id="is-the-name-root">is the name root</h1>

<p>[ &ldquo;$NAME&rdquo; == &ldquo;root&rdquo; ]; then<br />
echo &ldquo;Hello root&rdquo;<br />
elif</p>

<h1 id="or-is-it-louise">or is it louise</h1>

<p>[ $NAME == &ldquo;louise&rdquo; ]; then<br />
echo &ldquo;Hello louise&rdquo;<br />
elif</p>

<h1 id="or-is-it-dave">or is it dave</h1>

<p>[ &ldquo;$NAME&rdquo; == &ldquo;dave&rdquo; ]; then<br />
echo &ldquo;Hello dave&rdquo;<br />
else</p>

<h1 id="no-it-s-somebody-else">no it&rsquo;s somebody else</h1>

<p>echo &ldquo;You are not root or louise or dave but hi $NAME&rdquo;<br />
fi<br />
运行上述脚本，给出不同信息，得结果如下：<br />
[root@localhost ~]# chmod +x ifelif.sh<br />
[root@localhost ~]# ./ifelif.sh<br />
enter your login name :dave<br />
Hello dave<br />
[root@localhost ~]# ./ifelif.sh<br />
enter your login name :<br />
You did not enter a name<br />
[root@localhost ~]# ./ifelif.sh<br />
enter your login name :Peter<br />
You are not root or louise or dave but hi Peter<br />
多文件位置检测<br />
假定要定位一个用户登录文件，已知此文件在/ u s r / o p t s / a u d i t / l o g s或/ u s r / l o c a
l / a u d i t / l o g
s中，具体由其安装人决定。在定位此文件前，首先确保文件可读，此即脚本测试部分。如果未找件或文件不可读，则返回错误信息。脚本如下：<br />
#!/bin/sh</p>

<h1 id="ifcataudit-sh">ifcataudit.sh</h1>

<h1 id="locations-of-the-log-file">locations of the log file</h1>

<p>LOCAT_1=/usr/opts/audit/logs/audit.log<br />
LOCAT_2=/usr/local/audit/audit.logs  if [ -r $LOCAT_1 ]; then</p>

<h1 id="if-it-is-in-this-directory-and-is-readable-then-cat-is">if it is in this directory and is readable then cat is</h1>

<p>echo &ldquo;Using LOCAT_1&rdquo;<br />
cat $LOCAT_1<br />
elif</p>

<h1 id="else-it-then-must-be-in-this-direcotory-and-is-it-readable">else it then must be in this direcotory, and is it readable</h1>

<p>[ -r $LOCAT_2 ]<br />
then<br />
echo &ldquo;Using LOCAT_2&rdquo;<br />
cat $LOCAT_2<br />
else</p>

<h1 id="not-in-any-of-the-directories">not in any of the directories&hellip;</h1>

<p>echo &ldquo;<code>basename $0</code>: Sorry the audit file is not readable or cannot be<br />
localted.&rdquo; &gt;&amp;2<br />
exit 1<br />
fi<br />
运行上面脚本，如果文件在上述两个目录之一中并且可读，将可以找到它。如果不是，<br />
返回错误并退出，下面结果失败，因为假想的文件并不存在<br />
[root@localhost ~]# ./ifcataudit.sh<br />
ifcataudit.sh: Sorry the audit file is not readable or cannot be<br />
localted.<br />
提示键入y或n<br />
c a s e的一个有效用法是提示用户响应以决定是否继续进程。这里提示输入y以继续处理，n退出。如果用户输入Y、y或y e s，处理继续执行c a s
e语句后面部分。如果用户输入N、n或n o或其他响应，用户退出脚本。<br />
#!/bin/sh</p>

<h1 id="caseans-sh">caseans.sh</h1>

<p>echo -n &ldquo;Do you wish to proceed [y..n] :&rdquo;<br />
read ANS<br />
case $ANS in<br />
y|Y|yes|Yes) echo &ldquo;yes is selected&rdquo;<br />
n|N) echo &ldquo;no is selected&rdquo;<br />
exit 0 # no error so only use exit 0 to terminate<br />
*) echo &ldquo;<code>basename $0</code> : Unknow response&rdquo; &gt;&amp;2<br />
exit 1<br />
esac</p>

<h1 id="if-we-are-here-then-a-y-y-yes-yes-was-selected-only">if we are here then a y|Y|yes|Yes was selected only.</h1>

<p>运行脚本，输入无效响应，得结果：<br />
[root@localhost ~]# ./caseans.sh<br />
Do you wish to proceed [y..n] :df<br />
caseans.sh : Unknow response<br />
给出有效响应：<br />
[root@localhost ~]# ./caseans.sh<br />
Do you wish to proceed [y..n] :y<br />
yes is selected<br />
case与命令参数传递<br />
可以使用c a s e控制到脚本的参数传递。<br />
下面脚本中，测试特定变量$ #，它包含传递的参数个数，如果不等于1，退出并显示可用<br />
信息。<br />
然后c a s e语句捕获下列参数： p a s s w d、s t a r t、s t o p或h e l
p，相对于每一种匹配模式执行进一步处理脚本。如果均不匹配，显示可用信息到标准错误输出。<br />
#!/bin/sh</p>

<h1 id="caseparam-sh">caseparam.sh</h1>

<p>if [ $# != 1 ]; then<br />
echo &ldquo;Usage:<code>basename $0</code>[start|stop|help]&rdquo; &gt;&amp;2<br />
exit 1<br />
fi</p>

<h1 id="assign-the-parameter-to-the-variable-opt">assign the parameter to the variable OPT</h1>

<p>OPT=$1<br />
case $OPT in<br />
start) echo &ldquo;starting.. <code>basename $0</code>&ldquo;</p>

<h1 id="code-here-to-start-a-process">code here to start a process</h1>

<p>stop) echo &ldquo;stopping.. <code>basename $0</code>&ldquo;</p>

<h1 id="code-here-to-stop-a-process">code here to stop a process</h1>

<p>help)</p>

<h1 id="code-here-to-display-a-help-page">code here to display a help page</h1>

<p>*) echo &ldquo;Usage:<code>basename $0</code>[start|stop|help]&rdquo;<br />
esac<br />
运行脚本，输入无效参数。<br />
[root@localhost ~]# ./caseparam.sh what<br />
Usage:caseparam.sh[start|stop|help]<br />
入有效参数，结果为：<br />
[root@localhost ~]# ./caseparam.sh stop<br />
stopping.. caseparam.sh</p>

<p>捕获输入并执行空命令<br />
不一定要在匹配模式后加入命令，如果你原本不想做什么，只是在进一步处理前过滤出意外响应，这样做是一种好办法。<br />
如果要运行对应于一个会计部门的帐目报表，必须首先在决定运行报表的类型前确认用户输入一个有效的部门号，匹配所有可能值，其他值无效。用c a s
e可以很容易实现上述功能。<br />
下面的脚本中如果用户输入部门号不是2 3 4、4 5 3、6 5 5或4 5
4，用户退出并返回可用信息。一旦响应了用户的有效部门号，脚本应用同样的技术取得报表类型，在c a s e语句末尾显示有效的部门号和报表类型。脚本如下：</p>

<p>#!/bin/sh</p>

<h1 id="casevaild-sh">casevaild.sh</h1>

<p>echo -n &ldquo;Enter the account dept No: :&rdquo;<br />
read ACC<br />
case $ACC in<br />
234);;<br />
453);;<br />
655);;<br />
454);;<br />
*) echo &ldquo;<code>basename $0</code>: Unknown dept No:&rdquo; &gt;&amp;2<br />
echo &ldquo;try &hellip; 234,453,655,454&rdquo;<br />
exit 1<br />
esac</p>

<h1 id="if-we-are-here-then-we-have-validated-the-dept-no">if we are here, then we have validated the dept no</h1>

<p>echo &ldquo;1 . post&rdquo;<br />
echo &ldquo;2 . prior&rdquo;<br />
echo -n &ldquo;Enter the type of report:&rdquo;<br />
read ACC_TYPE<br />
case $ACC_TYPE in<br />
1) TYPE=post<br />
2) TYPE=prior;;<br />
*) echo &ldquo;<code>basename $0</code>: Unknown account type.&rdquo; &gt;&amp;2<br />
exit 1<br />
esac</p>

<h1 id="if-we-are-here-the-we-are-validated">if we are here the we are validated!</h1>

<p>echo &ldquo;now running report for dept $ACC for the type $TYPE&rdquo;</p>

<h1 id="run-the-command-reprot">run the command reprot&hellip;</h1>

<p>下面是该脚本不同运行输入情况的显示结果。<br />
输入有效部门号：<br />
[root@localhost ~]# ./casevalid.sh<br />
Enter the account dept No: :234<br />
1 . post<br />
2 . prior<br />
Enter the type of report:2<br />
now running report for dept 234 for the type prior<br />
输入无效部门号：<br />
[root@localhost ~]# ./casevalid.sh<br />
Enter the account dept No: :432<br />
casevalid.sh: Unknown dept No:<br />
try &hellip; 234,453,655,454<br />
输入无效的报表类型：<br />
[root@localhost ~]# ./casevalid.sh<br />
Enter the account dept No: :655<br />
1 . post<br />
2 . prior<br />
Enter the type of report:4<br />
casevalid.sh: Unknown account type.<br />
缺省变量值<br />
如果在读变量时输入回车键，不一定总是退出脚本。可以先测试是否已设置了变量，如果未设置，可以设置该值。下面的脚本中，要求用户输入运行报表日期。如果用户输入回车键，则使用缺省日期星期六，设置为变量w
h e n的取值。 如果用户输入另外一天，这一天对于c a s
e语句是运行的有效日期，即星期六、星期四、星期一。注意，这里结合使用了日期缩写作为捕获的可能有效日期。<br />
脚本如下：<br />
#!/bin/sh</p>

<h1 id="caserep-sh">caserep.sh</h1>

<p>echo &ldquo; Weekly Report&rdquo;<br />
echo -n &ldquo;What day do you want to run report [Saturday] :&rdquo;</p>

<h1 id="if-just-a-return-is-hit-then-except-default-which-is-saturday">if just a return is hit then except default which is Saturday</h1>

<p>read WHEN<br />
echo &ldquo;validating .. ${WHEN:=&ldquo;Saturday&rdquo;}&rdquo;<br />
case $WHEN in<br />
Monday|MONDAY|mon)<br />
Sunday|SUNDAY|sun)<br />
Saturday|SATURDAY|sat)<br />
*)echo &ldquo;Are you nuts! this report can only be run on &rdquo; &gt;&amp;2<br />
echo &ldquo; on a Saturday, Sunday or Monday&rdquo; &gt;&amp;2<br />
exit 1<br />
esac<br />
echo &ldquo;Report to run on $WHEN&rdquo;</p>

<h1 id="command-here-to-submitted-actual-report-run">command here to submitted actual report run</h1>

<p>对于正确输入：<br />
[root@localhost ~]# ./caserep.sh<br />
Weekly Report<br />
What day do you want to run report [Saturday] :<br />
validating .. Saturday<br />
Report to run on Saturday</p>

<p>对于错误的输入：<br />
[root@localhost ~]# ./caserep.sh<br />
Weekly Report<br />
What day do you want to run report [Saturday] :Tuesday<br />
validating .. Tuesday<br />
Are you nuts! this report can only be run on<br />
on a Saturday, Sunday or Monday<br />
可以推断出c a s e语句有时与if then else 语句功能相同，在某些条件下，这种假定是正确的。</p>

<p>f o r循环一般格式为：<br />
for 变量名i n列表<br />
d o<br />
命令1<br />
命令2⋯<br />
d o n e</p>

<p>当变量值在列表里， f o r循环即执行一次所有命令，使用变量名访问列表中取值。命令可为任何有效的s h e l l命令和语句。变量名为任何单词。I
n列表用法是可选的，如果不用它， f o r 循环使用命令行的位置参数。i n列表可以包含替换、字符串和文件名，下面看一些例子。<br />
还有一种常见的for循环的格式是：<br />
for ((初值; 循环条件; 执行步长))<br />
do<br />
执行的程序段<br />
done<br />
也就是括号中的内容是平常我们熟悉的C语言的风格。</p>

<p>简单的for循环<br />
此例仅显示列表1 2 3 4 5，用变量名访问列表。<br />
#!/bin/sh</p>

<h1 id="for-i-sh">for_i.sh</h1>

<p>for loop in 1 2 3 4 5<br />
do<br />
echo $loop<br />
done</p>

<p>运行上述脚本，输出：</p>

<p>[root@localhost ~]# ./for_i.sh<br />
1<br />
2<br />
3<br />
4<br />
5</p>

<p>上面中的1 2 3 4 5序列也可以用下面的方式生成。seq 5或者echo {1..5}的方式。<br />
打印字符串列表<br />
下面f o r循环中，列表包含字符串“ orange red blue grey”，命令为e c h o，变量名为l o o p，  e c h
o命令使用$ l o o p反馈出列表中所有取值，直至列表为空。<br />
#!/bin/sh</p>

<h1 id="forlist-sh">forlist.sh</h1>

<p>for loop in &ldquo;orange red blue grey&rdquo;<br />
do<br />
echo &ldquo;$loop&rdquo;<br />
done<br />
运行脚本输出内容是：<br />
orange red blue grey<br />
也可以在循环体中结合使用变量名和字符串。<br />
This is the fruit $loop<br />
其输出结果是：<br />
This is the fruit orange red blue grey<br />
对for循环使用ls命令<br />
这个循环执行l s命令，打印当前目录下所有文件。<br />
#!/bin/sh</p>

<h1 id="forls-sh">forls.sh</h1>

<p>for loop in <code>ls</code><br />
do<br />
echo $loop<br />
done<br />
对for循环使用参数<br />
在f o r循环中省去i n列表选项时，它将接受命令行位置参数作为参数。实际上即指明：<br />
for params in&rdquo;$@&rdquo;<br />
或<br />
for params in&rdquo;$*&rdquo;<br />
下面的例子不使用i n列表选项， f o r循环查看特定参数$ @或$ *，以从命令行中取得参数。<br />
#!/bin/sh</p>

<h1 id="forparam2">forparam2</h1>

<p>for params<br />
do<br />
echo &ldquo;You supplied $params as a command line option&rdquo;<br />
done<br />
下面的脚本包含i n&rdquo;$ @&ldquo;，结果与上面的脚本相同。<br />
#!/bin/sh</p>

<h1 id="forparam3">forparam3</h1>

<p>for params in &ldquo;$@&rdquo;<br />
do<br />
echo &ldquo;You supplied $params as a command line option&rdquo;<br />
done</p>

<p>对上述脚本采取进一步动作。如果要查看一系列文件，可在f o r循环里使用f i n d命令，利用命令行参数，传递所有要查阅的文件。<br />
#!/bin/sh</p>

<h1 id="forfind-sh">forfind.sh</h1>

<p>for loop<br />
do<br />
find / -name $loop -print<br />
done<br />
脚本执行时，从命令行参数中取值并使用f i n d命令，这些取值形成- n a m e选项的参数值。</p>

<p>使用for循环连接服务器<br />
因为f o r循环可以处理列表中的取值，现设变量为网络服务器名称，并使用f o r循环连接每一服务器。<br />
#!/bin/sh</p>

<h1 id="forping-sh">forping.sh</h1>

<p>HOSTS=&ldquo;itserv dnssevr acctsmain ladpd ladwareA&rdquo;<br />
for loop in $HOSTS<br />
do<br />
ping -c 2 $loop<br />
done<br />
使用for循环备份文件<br />
可以用f o r循环备份所有文件，只需将变量作为c p命令的目标参数。这里有一变量. b a k，当在循环中使用c
p命令时，它作为此命令目标文件名。列表命令为l s。<br />
#!/bin/sh</p>

<h1 id="forbak-sh">forbak.sh</h1>

<p>suffix=&ldquo;.bak&rdquo;<br />
for loop in <code>ls</code><br />
do<br />
cp $loop $loop$suffix<br />
done<br />
多文件转换<br />
匹配所有以L P S O开头文件并将其转换为大写。这里使用了l s和c a t命令。l s用于查询出相关文件， c a t用于将之管道输出至t
r命令。目标文件扩展名为.U C，注意在f o r循环中使用l s命令时反引号的用法。<br />
#!/bin/sh</p>

<h1 id="foruc-sh">forUC.sh</h1>

<p>for files in <code>ls LPSO*</code><br />
do<br />
cat $files | tr &ldquo;[a-z]&rdquo; &ldquo;[A-Z]&rdquo; &gt; $file.UC<br />
done<br />
多sed删除操作<br />
下面的例子中， s e d用于删除所有空文件，并将输出导至以. H O L D . m v为扩展名的新文件中，m v将这些文件移至初始文件中。<br />
#!/bin/sh</p>

<h1 id="forsed-sh">forsed.sh</h1>

<p>for files in <code>ls LPSO*</code><br />
do<br />
sed -e &ldquo;/^$/d&rdquo; $files &gt;$files.HOLD<br />
mv $files.HOLD $files<br />
done<br />
循环计数<br />
前面讨论e x p r时指出，循环时如果要加入计数，使用此命令。下面使用l s在f o r循环中列出文件及其数目。<br />
#!/bin/sh</p>

<h1 id="forcount-sh">forcount.sh</h1>

<p>counter=0<br />
for files in *<br />
do</p>

<h1 id="increment">increment</h1>

<p>counter=<code>expr $counter + 1</code><br />
done<br />
echo &ldquo;There are $counter files in <code>pwd</code> we need to process&rdquo;<br />
脚本的输出结果是：<br />
There are 87 files in /root we need to process<br />
使用w c命令可得相同结果。<br />
[root@localhost ~]# ls | wc -l<br />
87</p>

<p>for循环和本地文档<br />
在f o r循环体中可使用任意命令。下面的例子中，一个变量包含所有当前登录用户。使用w h o命令并结合a w k语言可实现此功能。然后f o
r循环循环每一用户，给其发送一个邮件，邮件信息部分用一个本地文档完成。<br />
#!/bin/sh</p>

<h1 id="forbak-sh-1">forbak.sh</h1>

<p>suffix=&ldquo;.bak&rdquo;<br />
for loop in <code>ls</code><br />
do<br />
cp $loop $loop$suffix<br />
done<br />
多文件转换<br />
匹配所有以L P S O开头文件并将其转换为大写。这里使用了l s和c a t命令。l s用于查询出相关文件， c a t用于将之管道输出至t
r命令。目标文件扩展名为.U C，注意在f o r循环中使用l s命令时反引号的用法。<br />
#!/bin/sh</p>

<h1 id="foruc-sh-1">forUC.sh</h1>

<p>for files in <code>ls LPSO*</code><br />
do<br />
cat $files | tr &ldquo;[a-z]&rdquo; &ldquo;[A-Z]&rdquo; &gt; $file.UC<br />
done<br />
多sed删除操作<br />
下面的例子中， s e d用于删除所有空文件，并将输出导至以. H O L D . m v为扩展名的新文件中，m v将这些文件移至初始文件中。<br />
#!/bin/sh</p>

<h1 id="forsed-sh-1">forsed.sh</h1>

<p>for files in <code>ls LPSO*</code><br />
do<br />
sed -e &ldquo;/^$/d&rdquo; $files &gt;$files.HOLD<br />
mv $files.HOLD $files<br />
done<br />
循环计数<br />
前面讨论e x p r时指出，循环时如果要加入计数，使用此命令。下面使用l s在f o r循环中列出文件及其数目。<br />
#!/bin/sh</p>

<h1 id="forcount-sh-1">forcount.sh</h1>

<p>counter=0<br />
for files in *<br />
do</p>

<h1 id="increment-1">increment</h1>

<p>counter=<code>expr $counter + 1</code><br />
done<br />
echo &ldquo;There are $counter files in <code>pwd</code> we need to process&rdquo;</p>

<p>脚本的输出结果是：<br />
There are 87 files in /root we need to process<br />
使用w c命令可得相同结果。<br />
[root@localhost ~]# ls | wc -l<br />
87</p>

<p>for循环和本地文档<br />
在f o r循环体中可使用任意命令。下面的例子中，一个变量包含所有当前登录用户。使用w h o命令并结合a w k语言可实现此功能。然后f o
r循环循环每一用户，给其发送一个邮件，邮件信息部分用一个本地文档完成。</p>

<p>#!/bin/sh</p>

<h1 id="formailit-sh">formailit.sh</h1>

<p>WHOS_ON=<code>who -u | awk '{print $1}'</code><br />
for user in $WHOS_ON<br />
do<br />
mail $user &lt;&lt; MAYDAY<br />
Dear Colleagues,<br />
It&rsquo;s my birthday today, see you down the<br />
club at 17:30 for a drink.<br />
See ya.<br />
$LOGNAME<br />
MAYDAY<br />
Done<br />
这个例子无法实现，可能原书上有错误，或者翻译有错误。<br />
for循环嵌入<br />
嵌入循环可以将一个f o r循环嵌在另一个f o r循环内：<br />
for 变量名1 in列表1<br />
d o<br />
for 变量名2 in 列表2<br />
d o<br />
命令1<br />
done<br />
done<br />
下面脚本即为嵌入f o r循环，这里有两个列表A P P S和S C R I P T
S。第一个包含服务器上应用的路径，第二个为运行在每个应用上的管理脚本。对列表A P P S上的每一个应用，列表S C R I P T
S里的脚本将被运行，脚本实际上为后台运行。脚本使用t e e命令在登录文件上放一条  目，因此输出到屏幕的同时也输出到一个文件。查看输出结果就可以看出嵌入f
o r循环怎样使用列表S C R I P T S以执行列表A P P S上的处理。<br />
#!/bin/sh</p>

<h1 id="audit-run-sh">audit_run.sh</h1>

<p>APPS=&ldquo;/apps/accts /apps/claims /apps/stock /apps/serv&rdquo;<br />
SCRIPTS=&ldquo;audit.check report.run cleanup&rdquo;<br />
LOGFILE=audit.log<br />
MY_DATE=<code>date +%H:%M&quot; on &quot;%d/%m%Y</code></p>

<h1 id="outer-loop">outer loop</h1>

<p>for loop in $APPS<br />
do</p>

<h1 id="inner-loop">inner loop</h1>

<p>for loop2 in $SCRIPTS<br />
do<br />
echo &ldquo;system $loop now running $loop2 at $MY_DATE&rdquo; | tee -a\<br />
$LOGFILE $loop $loop2 &amp;<br />
done<br />
done<br />
程序的运行结果如下：<br />
tee: /apps/accts: No such file or directory<br />
tee: /apps/accts: No such file or directory<br />
system /apps/accts now running report.run at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/accts: No such file or directory<br />
system /apps/accts now running cleanup at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/claims: No such file or directory<br />
system /apps/claims now running audit.check at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/claims: No such file or directory<br />
system /apps/claims now running report.run at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/claims: No such file or directory<br />
system /apps/claims now running cleanup at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/stock: No such file or directory<br />
system /apps/stock now running audit.check at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/stock: No such file or directory<br />
system /apps/stock now running report.run at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/stock: No such file or directory<br />
system /apps/stock now running cleanup at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/serv: No such file or directory<br />
system /apps/serv now running audit.check at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
[root@localhost ~]# system /apps/accts now running audit.check at 20:18 on
<sup>21</sup>&frasl;<sub>11201</sub><br />
tee: /apps/serv: No such file or directory<br />
system /apps/serv now running report.run at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
tee: /apps/serv: No such file or directory<br />
system /apps/serv now running cleanup at 20:18 on <sup>21</sup>&frasl;<sub>112010</sub><br />
until循环<br />
u n t i l循环执行一系列命令直至条件为真时停止。u n t i l循环与w h i l e循环在处理方式上刚好相反。一般w h i l e循环优于u
n t i l循环，但在某些时候—也只是极少数情况下， u n t i l循环更加有用。<br />
u n t i l循环格式为：<br />
until 条件<br />
命令1<br />
d o n e<br />
条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次—请注意这一点。<br />
下面是一些实例。<br />
简单的until循环<br />
这段脚本不断的搜寻w h o命令中用户r o o t，变量I S - R O O T保存g r e p命令结果。如果找到了r o o
t，循环结束，并向用户s i m o n发送邮件，通知他用户r o o t已经登录，注意这里s l e e p命令用法，它经常用于u n t i
l循环中，因为必须让循环体内命令睡眠几秒钟再执行，否则会消耗大量系统资源。<br />
#!/bin/sh</p>

<h1 id="until-who-sh">until_who.sh</h1>

<p>IS_ROOT=<code>who | grep root</code><br />
until [ &ldquo;$IS_ROOT&rdquo; ]<br />
do<br />
sleep 5<br />
done<br />
echo &ldquo;Watch it. roots in &rdquo; | mail simon<br />
监视文件<br />
下面例子中， u n t i l循环不断挂起做睡眠，直至文件/ t m p / m o n i t o r. l c
k被删除。文件删除后，脚本进入正常处理过程。<br />
#!/bin/sh</p>

<h1 id="until-lck-sh">until_lck.sh</h1>

<p>LOCK_FILE=/tmp/process.LCK<br />
until [ ! -f $LOCK_FILE ]<br />
do<br />
sleep 1<br />
done<br />
echo &ldquo;file deleted &ldquo;</p>

<h1 id="normal-processing-now-file-is-present">normal processing now, file is present</h1>

<p>上述例子是使脚本与其他处理过程协调工作的一种方法。还有另外一种方法使脚本相通信。假定有另一段脚本p r o c e s s . m a i
n用于搜集本地网络所有机器的信息并将之放入一个报表文件。<br />
当脚本p r o c e s s . m a i n运行时，创建了一个L C K文件（锁文件），上面脚本必须接收  p r o c e s s . m a
i n搜集的信息，但是如果p r o c e s s仍然在修改报表文件时试图处理该文件就不太好了。<br />
为克服这些问题，脚本p r o c e s s . m a i n创建了一个L C K文件，当它完成时，就删除此文件。<br />
上述脚本将挂起，等待L C K文件被删除，一旦L C K文件删除，上述脚本即可处理报表文件。</p>

<p>监视磁盘空间<br />
u n t i l循环做监视条件也很有用。假定要监视文件系统容量，当它达到一定水平时通知超级用户。<br />
下面的脚本监视文件系统/ l o g s，不断从变量$L O O K_O U T中抽取信息， $ L O O K _ O U T包含使用a w k和g r
e p得到的/ l o g s容量。<br />
如果容量达到9 0 %，触发命令部分，向超级用户发送邮件，脚本退出。必须退出，如果不退出，条件保持为真（例如，容量总是保持在9 0
%以上），将会不断的向超级用户发送邮件。<br />
#!/bin/sh</p>

<h1 id="until-mon-sh">until_mon.sh</h1>

<h1 id="get-present-column-and-strip-off-header-row-from-df">get present column and strip off header row from df</h1>

<p>LOOK_OUT=<code>df | grep /logs | awk '{print $5}' | sed 's/%//g'</code><br />
echo $LOOK_OUT<br />
until [ &ldquo;$LOOK_OUT -gt &ldquo;90&rdquo; ]<br />
do<br />
echo &ldquo;Filesystem..logs is nearly full&rdquo; | mail root<br />
exit 0<br />
done</p>

<p>while循环<br />
w h i l e循环用于不断执行一系列命令，也用于从输入文件中读取数据，其格式为：<br />
while 命令<br />
d o<br />
命令1<br />
命令2<br />
d o n e<br />
虽然通常只使用一个命令，但在w h i l e和d o之间可以放几个命令。命令通常用作测试条件。只有当命令的退出状态为0时，d o和d o n
e之间命令才被执行，如果退出状态不是0，则循环终止。命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。</p>

<p>简单的while循环<br />
以下是一个基本的w h i l e循环，测试条件是：如果C O U N T E R小于5，那么条件返回真。<br />
C O U N T E R从0开始，每次循环处理时， C O U N T E R加1。<br />
#!/bin/sh</p>

<h1 id="whilecount-sh">whilecount.sh</h1>

<p>COUNTER=0</p>

<h1 id="does-the-counter-5">does the counter = 5 ?</h1>

<p>while [ $COUNTER -lt 5 ]<br />
do</p>

<h1 id="add-ono-to-the-counter">add ono to the counter</h1>

<p>COUNTER=<code>expr $COUNTER + 1</code><br />
echo $COUNTER<br />
done<br />
运行上述脚本，返回数字1到5，然后终止。</p>

<p>使用while循环读键盘输入<br />
w h i l e循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量F I L M，按&lt; C t r l -D &gt;结束循环。<br />
#!/bin/sh</p>

<h1 id="whileread-sh">whileread.sh</h1>

<p>echo &ldquo;type  to terminate&rdquo;<br />
echo -n &ldquo;Enter your most liked file :&rdquo;<br />
while read FILE<br />
do<br />
echo &ldquo;Yeah, great film the $FILE&rdquo;<br />
done<br />
程序的运行结果如下：<br />
type  to terminate<br />
Enter your most liked file :Sound of Music<br />
Yeah, great film the Sound of Music</p>

<p>用while循环从文件中读取数据<br />
w h i l e循环最常用于从一个文件中读取数据，因此编写脚本可以处理这样的信息。<br />
假定要从下面包含雇员名字、从属部门及其I D号的一个文件中读取信息。<br />
names.txt<br />
Louise Conrad:Accounts:ACC8987<br />
Peter James:Payroll:PR489<br />
Fred Terms:Customer:CUS012<br />
James Lenod:Accounts:ACC887<br />
Frank Pavely:Payroll:PR489</p>

<p>可以用一个变量保存每行数据，当不再有读取数据时条件为真。w h i l e循环使用输入重定向以保证从文件中读取数据。注意整行数据被设置为单变量$ L I N
E .。<br />
#!/bin/sh</p>

<h1 id="whileread-sh-1">whileread.sh</h1>

<p>while read LINE<br />
do<br />
echo $LINE<br />
done &lt; names.txt</p>

<p>程序的运行结果如下：<br />
[root@localhost ~]# ./whileread.sh<br />
Louise Conrad:Accounts:ACC8987<br />
Peter James:Payroll:PR489<br />
Fred Terms:Customer:CUS012<br />
James Lenod:Accounts:ACC887<br />
Frank Pavely:Payroll:PR489<br />
使用IFS读文件<br />
输出时要去除冒号域分隔符，可使用变量I F S。在改变它之前保存I F S的当前设置。然后在脚本执行完后恢复此设置。使用I F
S可以将域分隔符改为冒号而不是空格或t a b键。这里有3个域需要加域分隔，即N A M E、D E P T和I D。为使输出看起来更清晰，对e c h
o命令使用t a b键将域分隔得更开一些，脚本如下：<br />
#!/bin/sh</p>

<h1 id="whilereadifs">whilereadifs</h1>

<h1 id="save-the-setting-of-ifs">save the setting of IFS</h1>

<p>SAVEDIFS=$IFS</p>

<h1 id="assign-new-separator-to-ifs">assign new separator to IFS</h1>

<p>IFS=:<br />
while read NAME DEPT ID<br />
do<br />
echo -e &ldquo;$NAME\t $DEPT\t $ID&rdquo;<br />
done &lt; names.txt</p>

<h1 id="restore-the-settings-of-ifs">restore the settings of IFS</h1>

<p>IFS=$SAVEDIFS</p>

<p>脚本运行后的输出结果如下，结果清晰多了。<br />
Louise Conrad Accounts ACC8987<br />
Peter James Payroll PR489<br />
Fred Terms Customer CUS012<br />
James Lenod Accounts ACC887<br />
Frank Pavely Payroll PR489<br />
带有测试条件的文件处理<br />
大部分w h i l e循环里都带有一些测试语句，以决定下一步的动作。这里从人员文件中读取数据，打印所有细节到一个保留文件中，直至发现James
Lenod，脚本退出。测试前反馈的信息要确保“ James Lenod”加入保留文件中。<br />
注意，所有变量在脚本顶端被设置完毕。这样当不得不对变量进行改动时可以节省时间和输入。所有编辑都放在脚本顶端，而不是混于整个脚本间。<br />
#!/bin/sh</p>

<h1 id="whileread-file-sh">whileread_file.sh</h1>

<h1 id="initialise-variables">initialise variables</h1>

<p>SAVEDIFS=$IFS<br />
IFS=:<br />
HOLD_FILE=hold_file<br />
NAME_MATCH=&ldquo;James Lenod&rdquo;<br />
INPUT_FILE=names.txt</p>

<h1 id="create-a-new-hold-file-each-time-in-case-script-is-continuously-run">create a new HOLD_FILE each time, in case script is continuously run</h1>

<blockquote>
<p>$HOLD_FILE<br />
while read NAME DEPT ID<br />
do</p>

<h1 id="echo-all-information-into-holdfile-with-redirection">echo all information into holdfile with redirection</h1>

<p>echo $NAME $DEPT $ID &gt;&gt; $HOLD_FILE</p>

<h1 id="is-it-a-match">is it a match ???</h1>

<p>if [ &ldquo;$NAME&rdquo; == &ldquo;$NAME_MATCH&rdquo; ]; then</p>

<h1 id="yes-then-nice-exit">yes then nice exit</h1>

<p>echo &ldquo;all entries up to and including $NAME_MATCH are in $HOLD_FILE&rdquo;<br />
exit 0<br />
fi<br />
done &lt; $INPUT_FILE</p>

<h1 id="restore-ifs">restore IFS</h1>

<p>IFS=$SAVEDIFS</p>
</blockquote>

<p>还可以采取进一步动作，列出多少个雇员属于同一部门。这里保持同样的读方式。假定每个域都有一个变量名，然后在c a s e语句里用e x p
r增加每行匹配脚本。任何发现的未知部门知识反馈到标准错误中，如果一个无效部门出现，没有必要退出。</p>

<p>#!/bin/sh</p>

<h1 id="whileread-cond-sh">whileread_cond.sh</h1>

<h1 id="initialise-variables-1">initialise variables</h1>

<p>ACC_LOOP=0; CUS_LOOP=0; PAY_LOOP=0;<br />
SAVEDIFS=$IFS<br />
IFS=:<br />
while read NAME DEPT ID<br />
do</p>

<h1 id="increment-counter-for-each-matched-dept">increment counter for each matched dept.</h1>

<p>case $DEPT in<br />
Accounts) ACC_LOOP=<code>expr $ACC_LOOP + 1</code><br />
ACC=&ldquo;Accounts&rdquo;<br />
Customer) CUS_LOOP=<code>expr $CUS_LOOP + 1</code><br />
CUS=&ldquo;Customer&rdquo;<br />
Payroll) PAY_LOOP=<code>expr $PAY_LOOP + 1</code><br />
PAY=&ldquo;Payroll&rdquo;<br />
*) echo &ldquo;<code>basename $0</code>: Unknown department $DEPT&rdquo; &gt;&amp;2<br />
esac<br />
done &lt; names.txt<br />
IFS=$SAVEDIFS<br />
echo &ldquo;there are $ACC_LOOP employees assigned to $ACC dept&rdquo;<br />
echo &ldquo;there are $CUS_LOOP employees assigned to $CUS dept&rdquo;<br />
echo &ldquo;there are $PAY_LOOP employees assigned to $PAY dept&rdquo;</p>

<p>程序运行的结果如下所示：<br />
[root@localhost ~]# ./whileread_cond.sh<br />
there are 2 employees assigned to Accounts dept<br />
there are 1 employees assigned to Customer dept<br />
there are 2 employees assigned to Payroll dept<br />
[root@localhost ~]# vim whileread_cond.sh</p>

<p>扫描文件行来进行数目统计<br />
一个常用的任务是读一个文件，统计包含某些数值列的数值总和。下面的文件包含有部门S TAT和G I F T所卖的商品数量。<br />
[root@localhost ~]# cat total.txt<br />
STAT 3444<br />
GIFT 233<br />
GIFT 252<br />
GIFT 932<br />
STAT 212<br />
STAT 923<br />
GIFT 129<br />
现在的任务是要统计部门G I F T所卖的各种商品数量。使用e x p r保存统计和，看下面的e x p r语句。变量L O O P和TO TA
L首先在循环外初始化为0，循环开始后， I T E M S加入TO TA L，第一次循环只包含第一种商品，但随着过程继续， I T E M S逐渐加入TO
TA L。<br />
下面的e x p r语句不断增加计数。<br />
LOOP=0<br />
TOTAL=0<br />
&hellip;<br />
while &hellip;<br />
do<br />
TOTAL=<code>expr $TOTAL + $ITEMS</code><br />
ITEMS=<code>expr $ITEMS + 1</code><br />
done</p>

<p>使用e x p r语句时容易犯的一个错误是开始忘记初始化变量。<br />
LOOP=0<br />
TOTAL=0<br />
如果真的忘了初始化，屏幕上将布满e x p r错误。<br />
如果愿意，可以在循环内初始化循环变量。<br />
TOTAL=<code>expr ${TOAL:=0} + ${ITEMS}</code><br />
上面一行如果变量TO TA L未赋值，将其初始化为0。这是在e x p r里初始化变量的第一个例子。另外在循环外要打印出最后总数。<br />
#!/bin/sh</p>

<h1 id="total-sh">total.sh</h1>

<h1 id="init-variables">init variables</h1>

<p>LOOP=0<br />
TOTAL=0<br />
COUNT=0<br />
echo &ldquo;Items Dept&rdquo;<br />
echo &ldquo;____________&rdquo;<br />
while read DEPT ITEMS<br />
do</p>

<h1 id="keep-a-count-on-total-records-read">keep a count on total records read</h1>

<p>COUNT=<code>expr $COUNT + 1</code><br />
if [ &ldquo;$DEPT&rdquo; == &ldquo;GIFT&rdquo; ]; then</p>

<h1 id="keep-a-running-total">keep a running total</h1>

<p>TOTAL=<code>expr $TOTAL + $ITEMS</code><br />
ITEMS=<code>expr $ITEMS + 1</code><br />
echo -e &ldquo;$ITEMS\t$DEPT&rdquo;<br />
fi</p>

<h1 id="echo-dept-items">echo $DEPT $ITEMS</h1>

<p>done &lt; total.txt<br />
echo &ldquo;============&rdquo;<br />
echo $TOTAL<br />
echo &ldquo;There were $COUNT entries altogether in the file&rdquo;</p>

<p>脚本的运行结果如下所示：<br />
Items Dept</p>

<hr />

<p>234 GIFT<br />
253 GIFT<br />
933 GIFT</p>

<h1 id="130-gift">130 GIFT</h1>

<p>1546<br />
There were 7 entries altogether in the file<br />
每次读一对记录<br />
有时可能希望每次处理两个记录，也许可从记录中进行不同域的比较。每次读两个记录很容易，就是要在第一个w h i l
e语句之后将第二个读语句放在其后。使用这项技术时，不要忘不断进行检查，因为它实际上读了大量的记录。<br />
[root@localhost ~]# cat record.txt<br />
record 1<br />
record 2<br />
record 3<br />
record 4<br />
record 5<br />
record 6<br />
每次读两个记录，下面的例子对记录并不做实际测试。<br />
脚本如下：<br />
#!/bin/sh</p>

<h1 id="readpair-sh">readpair.sh</h1>

<h1 id="first-record">first record</h1>

<p>while read rec1<br />
do</p>

<h1 id="second-record">second record</h1>

<p>read rec2</p>

<h1 id="further-processing-testing-goes-here-to-test-or-compare-both-records">further processing/testing goes here to test or compare both records</h1>

<p>echo &ldquo;This is record on of a pair :$rec1&rdquo;<br />
echo &ldquo;This is record on of a pair :$rec2&rdquo;<br />
echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&rdquo;<br />
done &lt; record.txt<br />
首先来检查确实读了很多记录，可以使用w c命令：<br />
[root@localhost ~]# cat record.txt | wc -l<br />
6<br />
共有6个记录，观察其输出：<br />
This is record on of a pair :record 1<br />
This is record on of a pair :record 2<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
This is record on of a pair :record 3<br />
This is record on of a pair :record 4<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />
This is record on of a pair :record 5<br />
This is record on of a pair :record 6<br />
-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>忽略#字符<br />
读文本文件时，可能要忽略或丢弃遇到的注释行，下面是一个典型的例子。<br />
假定要使用一般的w h i l e循环读一个配置文件，可拣选每一行，大部分都是实际操作语句。有时必须忽略以一定字符开头的行，这时需要用c a s
e语句，因为#是一个特殊字符，最好首先 用反斜线屏蔽其特殊意义，在#符号后放一个星号*，指定*后可包含任意字符。<br />
配置文件如下：<br />
[root@localhost ~]# cat config</p>

<h1 id="this-is-the-sub-system-audit-config-file">THIS IS THE SUB SYSTEM AUDIT CONFIG FILE</h1>

<h1 id="do-not-edit-it-works">DO NOT EDIT!!!!.IT WORKS</h1>

<h1 id="type-of-admin-access">type of admin access</h1>

<p>AUDITSCH=full</p>

<h1 id="lanuch-place-of-sub-systems">lanuch place of sub-systems</h1>

<p>AUDITSUB=/usr/opt/audit/sub</p>

<h1 id="serial-hash-number-of-product">serial hash number of product</h1>

<p>HASHSER=12890AB3</p>

<h1 id="end-of-config-file">END OF CONFIG FILE!!!</h1>

<p>忽略#符号的实现脚本如下：<br />
#!/bin/sh</p>

<h1 id="ignore-hash-sh">ignore_hash.sh</h1>

<p>IT_FILE=config<br />
if [ -s $INPUT_FILE ]; then<br />
while read LINE<br />
do<br />
case $LINE in<br />
\#*);;</p>

<h1 id="ignore-any-hash-signs">ignore any hash signs</h1>

<p>*) echo $LINE<br />
esac<br />
done &lt; $INPUT_FILE<br />
else<br />
echo &ldquo;<code>basename $0</code> : Sorry $INPUT_FILE does not exist or is empty&rdquo;<br />
exit 1<br />
fi<br />
程序的输出结果如下：<br />
AUDITSCH=full<br />
AUDITSUB=/usr/opt/audit/sub<br />
HASHSER=12890AB3</p>

<p>处理格式化报表<br />
读报表文件时，一个常用任务是将不想要的行剔除。以下是库存商品水平列表，我们感兴趣的是那些包含商品记录当前水平的列。<br />
[root@localhost ~]# cat order<br />
################ RE-ORDER REPORT ##############<br />
ITEM ORDERLEVEL LEVEL<br />
####################################################<br />
Pens 14 12<br />
Pencils 15 15<br />
Pads 7 3<br />
Disks 3 2<br />
Sharpeners 5 1<br />
####################################################<br />
我们的任务是读取其中取值，决定哪些商品应重排。如果重排，重排水平应为现在商品的两倍。输出应打印需要重排的每种商品数量及重排总数。<br />
我们已经知道可以忽略以某些字符开始的行，因此这里没有问题。首先读文件，忽略所有注释行和以‘ I T E
M’开始的标注行。读取文件至一临时工作文件中，为确保不存在空行，用s e d删除空行，需要真正做的是过滤文本文件。脚本如下：<br />
#!/bin/sh</p>

<h1 id="whileorder-sh">whileorder.sh</h1>

<p>INPUT_FILE=order<br />
HOLD=order.tmp<br />
if [ -s $INPUT_FILE ]; then</p>

<h1 id="zero-the-output-file-we-do-not-want-to-append">zero the output file, we do not want to append!</h1>

<blockquote>
<p>$HOLD<br />
while read LINE<br />
do<br />
case $LINE in<br />
\#<em>|ITEM</em>);; # ignore any # or the line with ITEM<br />
*)</p>

<h1 id="redirect-the-output-to-a-temp-file">redirect the output to a temp file</h1>

<p>echo $LINE &gt;&gt;$HOLD<br />
esac<br />
done  # use to sed to delete any empty lines, if any<br />
sed -e &lsquo;/^$/d&rsquo; order.tmp &gt;order.$<br />
mv order.$ order.tmp<br />
else<br />
echo &ldquo;<code>basename $0</code> : Sorry $INPUT_FILE does not exist or empty&rdquo;<br />
fi<br />
执行脚本后，输出结果为。<br />
[root@localhost ~]# cat order.tmp<br />
Pens 14 12<br />
Pencils 15 15<br />
Pads 7 3<br />
Disks 3 2<br />
Sharpeners 5 1<br />
现在要在另一个w h i l e循环中读取临时工作文件，使用e x p r对数字进行数值运算。<br />
#!/bin/sh</p>

<h1 id="whileorder2">whileorder2</h1>

<h1 id="init-the-variables">init the variables</h1>

<p>HOLD=order.tmp<br />
RE_ORDER=0<br />
ORDERS=0<br />
STATIONERY_TOT=0<br />
if [ -s $HOLD ]; then<br />
echo &ldquo;========= STOCK RE_ORDER REPORT =========&rdquo;<br />
while read ITEM RECORD LEVEL<br />
do</p>

<h1 id="are-we-below-the-reorder-level-for-this-item">are we below the reorder level for this item ??</h1>

<p>if [ &ldquo;$LEVEL&rdquo; -lt &ldquo;$RECORD&rdquo; ];then</p>

<h1 id="yes-do-the-new-order-amount">yes, do the new order amount</h1>

<p>NEW_ORDER=<code>expr $RECORD + $RECORD</code></p>

<h1 id="running-total-of-orders">running total of orders</h1>

<p>ORDERS=<code>expr $ORDERS + 1</code></p>

<h1 id="running-total-of-stock-levels">running total of stock levels</h1>

<p>STATIONERY_TOT=<code>expr $STATIONERY_TOT + $LEVEL</code><br />
echo &ldquo;$ITEM need reordering to the amount $NEW_ORDER&rdquo;<br />
fi<br />
done echo &ldquo;$ORDERS new items need to be ordered&rdquo;<br />
echo &ldquo;Our reorder total is $STATIONERY_TOT&rdquo;<br />
else<br />
echo &ldquo;<code>basename $0</code> : Sorry $HOLD does not exists or is empty&rdquo;<br />
fi</p>
</blockquote>

<p>以下为依据报表文件运行所得输出结果。<br />
========= STOCK RE_ORDER REPORT =========<br />
Pens need reordering to the amount 28<br />
Pads need reordering to the amount 14<br />
Disks need reordering to the amount 6<br />
Sharpeners need reordering to the amount 10<br />
4 new items need to be ordered<br />
Our reorder total is 18</p>

<p>将两段脚本结合在一起很容易。实际上这本来是一个脚本，为讲解方便，才将其分成两个。</p>

<p>while循环和文件描述符<br />
第5章查看文件描述符时，提到有必要用w h i l e循环将数据读入一个文件。使用文件描述符3和4，下面的脚本进行文件m y f i l e . t x
t到m y f i l e . b a k的备份。注意，脚本开始测试文件是否存在，<br />
如果不存在或没有数据，脚本立即终止。还有w h i l e循环用到了空命令（：），这是一个死循环,  因为n u l
l永远返回真。尝试读至文件结尾将返回错误，那时脚本也终止执行。</p>

<p>#!/bin/sh</p>

<h1 id="copyfile-sh">copyfile.sh</h1>

<p>FILENAME=myfile.txt<br />
FILENAME_BAK=myfile.bak<br />
if [ -s $FILENAME ]; then</p>

<h1 id="open-filename-for-writing">open FILENAME for writing</h1>

<h1 id="open-filename-for-reading">open FILENAME for reading</h1>

<p>exec 4&gt;$FILENAME_BAK<br />
exec 3  # loop forever until no more data and thus an error so we</p>

<h1 id="are-at-end-of-file">are at end of file</h1>

<p>while:<br />
do<br />
read LINE  if [ &ldquo;$?&rdquo; -ne 0 ]; then</p>

<h1 id="errors-then-close-up">errors then close up</h1>

<p>exec 3  exec 4 fi</p>

<h1 id="write-to-filename-bak">write to FILENAME_BAK</h1>

<p>echo $LINE&gt;&amp;4<br />
done<br />
else<br />
echo &ldquo;<code>basename $0</code> : Sorry, $FILENAME is not present or is empty&rdquo; &gt;&amp;2<br />
fi</p>

<p>使用break和continue控制循环<br />
有时需要基于某些准则退出循环或跳过循环步。s h e l l提供两个命令实现此功能。</p>

<p>break<br />
b r e a k命令允许跳出循环。b r e a k通常在进行一些处理后退出循环或c a s e语句。如果是在<br />
个嵌入循环里，可以指定跳出的循环个数。例如如果在两层循环内，用break 2刚好跳出整个循环。</p>

<p>跳出case语句<br />
下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到s h e l l提示符下， b r e a k使用脚本如下：</p>

<p>#!/bin/sh</p>

<h1 id="breakout-sh">breakout.sh</h1>

<h1 id="while-means-loop-forever">while : means loop forever</h1>

<p>while :<br />
do<br />
echo -n &ldquo;Enter any number [1..5] :&rdquo;<br />
read ANS<br />
case $ANS in<br />
1|2|3|4|5) echo &ldquo;great you entered a number 1 and 5&rdquo;<br />
;;<br />
*) echo &ldquo;Wrong number &hellip; bye&rdquo;<br />
break<br />
;;<br />
esac<br />
done<br />
continue<br />
c o n t i n u e命令类似于b r e a k命令，只有一点重要差别，它不会跳出循环，只是跳过这个循<br />
环步。</p>

<p>浏览文件行<br />
下面是一个前面用过的人人文件列表，但是现在加入了一些头信息。<br />
[root@localhost ~]# cat name2.txt<br />
-&mdash;&mdash;LISTING OF PERSONNEL FILE&mdash;&mdash;-<br />
-&mdash; TAKEN AS AT 06/1999 &mdash;&ndash;<br />
Louise Conrad:Accounts:ACC8987<br />
Peter James:Payroll:PR489<br />
Fred Terms:Customer:CUS012<br />
James Lenod:Accounts:ACC887<br />
Frank Pavely:Payroll:PR489<br />
假定现在需要处理此文件，看过文件之后知道头两行并不包含个人信息，因此需要跳过这两行。也不需要处理雇员Peter
James，这个人已经离开公司，但没有从人员文件中删除。对于头信息。只需简单计算所读行数，当行数大于2时开始处理，如果处理人员名字为Peter
James，也将跳过此记录。脚本如下：<br />
#!/bin/sh</p>

<h1 id="whilecontinue-sh">whilecontinue.sh</h1>

<p>SAVEDIFS=$IFS<br />
IFS=:<br />
INPUT_FILE=name2.txt<br />
NAME_HOLD=&ldquo;Peter James&rdquo;<br />
LINE_NO=0<br />
if [ -s $INPUT_FILE ]; then<br />
while read NAME DEPT ID<br />
do<br />
LINE_NO=<code>expr $LINE_NO + 1</code><br />
if [ &ldquo;$LINE_NO&rdquo; -le 2 ]; then</p>

<h1 id="skip-if-the-count-is-less-than-2">skip if the count is less than 2</h1>

<p>continue<br />
fi<br />
if [ &ldquo;$NAME&rdquo; == &ldquo;$NAME_HOLD&rdquo; ]; then</p>

<h1 id="skip-if-the-name-in-name-hold-is-peter-james">skip if the name in NAME_HOLD is Peter James</h1>

<p>continue<br />
else<br />
echo &ldquo;Now processing &hellip; $NAME $DEPT $ID&rdquo;</p>

<h1 id="all-the-processing-goes-here">all the processing goes here</h1>

<p>fi<br />
done &lt; $INPUT_FILE<br />
IFS=$SAVEDIFS<br />
else<br />
echo &ldquo;<code>basename $0</code> : Sorry file not found or there is no data in the<br />
file&rdquo; &gt;&amp;2<br />
exit 1<br />
fi<br />
运行上面的脚本，输出如下的内容<br />
Now processing &hellip; Louise Conrad Accounts ACC8987<br />
Now processing &hellip; Fred Terms Customer CUS012<br />
Now processing &hellip; James Lenod Accounts ACC887<br />
Now processing &hellip; Frank Pavely Payroll PR489</p>

<p>菜单<br />
创建菜单时，在w h i l e循环里n u l l空命令很合适。h i l e加空命令n u l
l意即无限循环，这正是一个菜单所具有的特性。当然除非用户选择退出或是一个有效选项。创建菜单只需用w h i l e循环和c a s
e语句捕获用户输入的所有模式。如果输入无效，则报警，反馈错误信息，然后继续执行循环直到用户完成处理过程，选择退出选项。<br />
菜单界面应是友好的，不应该让用户去猜做什么，主屏幕也应该带有主机名和日期，并伴随有运行此菜单的用户名。由于测试原因，所有选项使用的是系统命令。<br />
下面是即将显示的菜单。<br />
首先，使用命令替换设置日期，主机名和用户。日期格式为/ D D / M M / Y Y Y Y，参数格式为：<br />
$ date +%d/%m/%y<br />
3 2 / 0 5 / 1 9 9 9<br />
对于主机名，使用h o s t n a m e - s选项只抽取主机名部分。主机名有时也包括了完全确认的域<br />
名。当然如果要在屏幕上显示这些，那就更好了。<br />
可以给变量一个更有意义的名字：<br />
MYDATE=<code>date +%d/%m/%Y</code><br />
THIS_HOST=<code>hostname -s</code><br />
USER=<code>whoami</code></p>

<p>对于w h i l e循环，只需将空命令直接放在w h i l e后，即为无限循环，格式为：<br />
while ：<br />
d o<br />
命令<br />
d o n e<br />
要注意实际屏幕显示，不要浪费时间使用大量的e c h o语句或不断地调整它们。这里使用<br />
本地文档，在分界符后面接受输入，直至分界符被再次定位。格式为：<br />
command &lt;&lt; WORD<br />
any input<br />
WORD<br />
此技术用于菜单屏幕，也将用于帮助屏幕。帮助屏幕不像这样复杂。<br />
用c a s e语句控制用户选择。菜单选择有：<br />
1 : List files in current directory<br />
2 : Use the vi editor<br />
3 : See who is on the system<br />
H : Help screen<br />
Q : Exit Menu<br />
c a s e语句应控制所有这些模式，不要忘了将大写与小写模式并列在一起，因为有时用户会关闭或打开CAPS
LOCK键。因为菜单脚本不断循环，所以应该允许用户退出，如果用户选择Q或q键，脚本应退出，此时脚本带有0值。<br />
如果用户选择无效，应发出警报并带有警告信息。虽然本章开始说过从现在开始一直使用L I N U X或BSD echo语句版本，这里必须使用系统V版本发出警报：<br />
echo &ldquo;\007 the bell ring&rdquo;<br />
用一个简单的e c h o和读语句锁屏直到用户点击回车键，这样任何信息或命令输出将可视。<br />
也需要清屏，为此可使用t p u t命令（后面讨论t p u t），如果不这样做，使用c l e a r命令也可以。<br />
到此所有功能已经具备了，脚本如下：<br />
#!/bin/sh</p>

<h1 id="menu-sh">menu.sh</h1>

<h1 id="set-the-date-user-and-hostname-up">set the date, user and hostname up</h1>

<p>MYDATE=<code>date +%d/%m/%Y</code><br />
THIS_HOST=<code>hostname -s</code><br />
USER=<code>whoami</code></p>

<h1 id="loop-forever">loop forever !</h1>

<p>while:<br />
do</p>

<h1 id="clear-the-screen">clear the screen</h1>

<p>input clear</p>

<h1 id="here-documents-starts-here">here documents starts here</h1>

<p>cat &lt; _________________________________________________________<br />
User: $USER Host:$THIS_HOST Date:$MYDATE</p>

<hr />

<p>1 : List files in current directory<br />
2 : Use the vi editor<br />
3 : See who is on the system<br />
H : Help screen<br />
Q : Exit Menu</p>

<hr />

<p>MAYDAY</p>

<h1 id="here-document-finished">here document finished</h1>

<p>echo -e -n &ldquo;\tYour Choice [1,2,3,H,Q] &gt;&rdquo;<br />
read CHOICE<br />
case $CHOICE in<br />
1) ls<br />
;;<br />
2) vi<br />
3) who<br />
H|h)</p>

<h1 id="use-a-here-document-for-the-help-screen">use a here document for the help screen</h1>

<dl>
<dt>MAYDAY<br /></dt>
<dd>;;<br />
Q|q) exit 0<br />
*) echo -e &ldquo;\t\007unknown user response&rdquo;<br />
esac<br />
echo -e -n &ldquo;\tHit the return key to continue&rdquo;<br />
read DUMMY<br />
done<br /></dd>
</dl>

<p>-n &ldquo;\tHit the return key to continue&rdquo;<br />
read DUMMY<br />
done</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>