<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell相关命令 | 开发者问答集锦</title>
    <meta property="og:title" content="shell相关命令 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell相关命令">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell相关命令</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><strong>shell script</strong></p>

<p>#!/bin/bash</p>

<p><em># do something</em></p>

<p><strong>run shell script</strong></p>

<p>sh script.sh</p>

<p>or</p>

<p>chmod a+x script.sh</p>

<p>./script.sh</p>

<h1 id="会读取首行的解释器-执行">会读取首行的解释器, 执行</h1>

<p>cmd</p>

<p>cmd1; cmd2</p>

<p>or</p>

<p>cmd1</p>

<p>cmd2</p>

<p><strong>echo</strong></p>

<p>echo 的功能正如其名，就是基于标准输出打印一段文本</p>

<p>echo &ldquo;welcome to bash&rdquo;</p>

<p>echo welcome to bash</p>

<p>使用不带引号的echo时，无法显示分号</p>

<p>使用单引号echo时，bash不会对单引号中变量求值 &lsquo;$var&rsquo;</p>

<p>echo 中转义换行符</p>

<p>默认情况，echo将换行标志追加到文本尾部，可以忽略结尾换行符</p>

<p>echo -n &lsquo;test\n&rsquo;</p>

<p>对字符串进行转义</p>

<p>echo -e &lsquo;1\t2\t3&rsquo;</p>

<p>打印彩色输出</p>

<p>文字颜色码</p>

<p>重置0</p>

<p>黑色30</p>

<p>红色31</p>

<p>绿色32</p>

<p>黄色33</p>

<p>蓝色34</p>

<p>洋红35</p>

<p>青色36</p>

<p>白色37</p>

<p>echo -e &ldquo;\e[1;31m This is red test \e[0m&rdquo;</p>

<p>背景颜色码</p>

<p>重置0</p>

<p>黑色40</p>

<p>红色41</p>

<p>绿色42</p>

<p>黄色43</p>

<p>蓝色44</p>

<p>洋红45</p>

<p>青色46</p>

<p>白色47</p>

<p>echo -e &ldquo;\e[1;42m Green Background \e[0m&rdquo;</p>

<p><strong>printf</strong></p>

<p>可以格式化字符串, 使用参数同c中printf一样</p>

<p>printf &ldquo;hello world&rdquo;</p>

<p>默认不会加换行符, 需要手动添加</p>

<p>printf &ldquo;%-5s %-10s %-4.2f\n&rdquo; 3 Jeff 77.564</p>

<p>3 Jeff 77.56</p>

<p><strong>环境变量和变量</strong></p>

<p>bash中，每个变量的值都是字符串，无论你给变量赋值时是否使用引号，值都会以字符串的形式存储</p>

<p>环境变量</p>

<p>查看所有与此终端进程相关的环境变量</p>

<p>env</p>

<p>查看某个进程的环境变量</p>

<p>cat /proc/$PID/environ</p>

<p>变量赋值</p>

<p>var=value</p>

<p>var=&lsquo;the value&rsquo;</p>

<p>var=&ldquo;the $PARAM&rdquo;</p>

<p>echo $var</p>

<p>echo <strong>${</strong> var <strong>}</strong></p>

<p>var = value非变量赋值是相等操作</p>

<p>环境变量</p>

<p>未在当前进程中定义，而是从父进程中继承而来的变量</p>

<p>export 设置环境变量,之后,从当前shell 执行的任何程序都会继承这个变量</p>

<p>export PYTHONPATH=$PYTHONPATH:/home/ken/workspace</p>

<p>常用的环境变量</p>

<p>PATH 查找可执行文件路径, 通常定义在/etc/environment or /ect/profile or ~/.bashrc</p>

<p>修改: export PATH=$PATH:/new/path/</p>

<p>HOME</p>

<p>PWD</p>

<p>USER</p>

<p>UID</p>

<p>SHELL</p>

<p>获取字符串长度</p>

<p>length= <strong>${</strong> <em>#var</em> <strong>}</strong></p>

<p>识别当前shell版本</p>

<p>echo $SHELL</p>

<p>/bin/bash</p>

<p>echo $0</p>

<p>bash</p>

<p>检查是否为超级用户 or 普通用户</p>

<p>root的UID=0</p>

<p>if [ $UID -ne 0 ]</p>

<p>then</p>

<p>echo &ldquo;not rootuser&rdquo;</p>

<p>else</p>

<p>echo&rdquo;root&rdquo;</p>

<p>fi</p>

<p>修改bash的提示字符</p>

<p>设置PS1变量</p>

<p>\u用户名</p>

<p>\h主机名</p>

<p>\w当前工作目录</p>

<p><strong>pgrep</strong></p>

<p>获取某个进程名对应进程id</p>

<p>pgrep gedit</p>

<p><strong>shell 数学运算</strong></p>

<p>整数运算</p>

<p>let</p>

<p>no1=4</p>

<p>no2=5</p>

<p>let result=no1+no2</p>

<p>let no1++</p>

<p>let no2&ndash;</p>

<p>let no1+=7</p>

<p>let no2-=7</p>

<p>expr(少用)</p>

<p>result=<code>expr 3 + 4</code></p>

<p>result=$(expr $no1 +  5)</p>

<p>其他方法</p>

<p>result=$[ no1 + no2 ]</p>

<p>result=$[ $no + 5 ]</p>

<p>result=$(( no1 + 5))</p>

<p>浮点数</p>

<p>echo &ldquo;4 * 0.56&rdquo; | bc</p>

<p>设定精度</p>

<p>echo &ldquo;scale=2;<sup>3</sup>&frasl;<sub>8</sub>&rdquo; | bc</p>

<p>进制转换</p>

<p>echo &ldquo;obase=2;100&rdquo; | bc</p>

<p>平方</p>

<p>echo &ldquo;10^10&rdquo; | bc</p>

<p>平方根</p>

<p>echo &ldquo;sqrt(100)&rdquo; | bc</p>

<p><strong>命令状态</strong></p>

<p>当命令成功完成, 返回0</p>

<p>发生错误并退回, 返回非0</p>

<p>可以从$?中获取 cmd; echo $?</p>

<p><strong>文件描述符和重定向</strong></p>

<p>文件描述符: 与文件输入/输出相关联的整数,用来跟踪已打开的文件</p>

<p>0 stdin 标砖输入</p>

<p>1 stdout 标准输出</p>

<p>2 stderr 标准错误</p>

<p>重定向到文件</p>

<p>清空文件写入新内容</p>

<p>echo &ldquo;test&rdquo; &gt; temp.txt</p>

<p>追加</p>

<p>echo &ldquo;test&rdquo; &gt;&gt; temp.txt</p>

<blockquote>
<p>等价于1&gt;</p>

<blockquote>
<p>等价于 1&gt;&gt;</p>
</blockquote>
</blockquote>

<p>输出分离或合并</p>

<p>分离</p>

<p>cmd 2&gt;stderr.txt 1&gt;stdout.txt</p>

<p>合并</p>

<p>cmd &gt; output.txt 2&gt;&amp;1</p>

<p>or</p>

<p>cmd &amp;&gt; output.txt</p>

<p>扔到垃圾桶</p>

<p>/dev/null 特殊设备文件, 接收到的任何数据都会被丢弃(位桶/黑洞)</p>

<p>只有标准错误</p>

<p>cmd 2 &gt; /dev/null</p>

<p>标准输出和标准错误</p>

<p>cmd &gt;/dev/null 2&gt;&amp;1</p>

<p>同时输出到终端和文件</p>

<p>cmd | tee file1</p>

<p>tee默认覆盖，可以-a选项追加</p>

<p>cmd | tee -a file1</p>

<p>将stdin作为命令参数</p>

<p>cmd1 | cmd2 | cmd3 -</p>

<p>将文件重定向到命令</p>

<p>cmd &lt; file</p>

<p>自定义文件描述符</p>

<p>使用文件描述符3打开并读取文件</p>

<p>exec 3</p>

<p>cat</p>

<p>使用文件描述符4进行写入</p>

<p>exec 4&gt;output.txt</p>

<p>echo newline &gt;&amp;4</p>

<p><strong>cat</strong></p>

<p>cat, concatenate(拼接)</p>

<p>“cat”代表了连结（Concatenation），连接两个或者更多文本文件或者以标准输出形式打印文件的内容</p>

<p>一般格式</p>

<p>cat file1 file2 file3</p>

<p>从管道中读取</p>

<p>OUTPUT_FROM_SOME_CMDS | cat</p>

<p>echo &ldquo;test&rdquo; | cat - file1</p>

<p>压缩空白行, 多个连续空行变成单个</p>

<p>cat -s file</p>

<p>配合tr移除空白行</p>

<p>cat file | tr -s &lsquo;\n&rsquo; #连续多个\n -&gt; \n</p>

<p>加行号</p>

<p>cat -n file</p>

<p>显示制表符等</p>

<p>cat -T file</p>

<p>cat f &gt; t</p>

<p>注意：“&gt;&gt;”和“&gt;”调用了追加符号。它们用来追加到文件里，而不是显示在标准输出上。</p>

<p>“&gt;”符号会删除已存在的文件，然后创建一个新的文件。</p>

<p>所以因为安全的原因，建议使用“&gt;&gt;”，它会写入到文件中，而不是覆盖或者删除。</p>

<p>输入多行文字(CTRL + d 退出)</p>

<p>cat &gt; test.txt</p>

<p><strong>数组和关联数组</strong></p>

<p>普通数组，整数作为数组索引, 借助索引将多个独立的数据存储为一个集合(list)</p>

<p>关联数组，可以使用字符串作为索引(map)</p>

<p>数组</p>

<p>定义</p>

<p>array_var=(1 2 3 4 5)</p>

<p>or</p>

<p>array_var[0]=&ldquo;test1&rdquo;</p>

<p>array_var[3]=&ldquo;test3&rdquo;</p>

<p>读取</p>

<p>echo <strong>${</strong> array_var[0] <strong>}</strong></p>

<p>以清单形式打印</p>

<p>echo <strong>${</strong> array_var[*] <strong>}</strong></p>

<p>echo <strong>${</strong> array_var[@] <strong>}</strong></p>

<p>长度</p>

<p>echo <strong>${</strong> _#array<em>var[*]</em> <strong>}</strong></p>

<p>获取索引列表</p>

<p>echo <strong>${</strong>!array_var[*] <strong>}</strong></p>

<p>关联数组</p>

<p>declare -A ass_array</p>

<p>内嵌索引-值</p>

<p>ass_array=([index1]=value1 [index2]=value2)</p>

<p>独立</p>

<p>ass_array[index3]=value3</p>

<p>echo <strong>${</strong> ass_array[index1] <strong>}</strong></p>

<p><strong>alias</strong></p>

<p>alias是一个系统自建的shell命令，允许你为名字比较长的或者经常使用的命令指定别名。</p>

<p>alias new_command=&lsquo;command seq&rsquo;</p>

<p>unalias new_command</p>

<p>使用原生命令</p>

<p>\new_command</p>

<p><strong>date</strong></p>

<p>“date”命令使用标准的输出打印当前的日期和时间，也可以深入设置</p>

<p>读取日期</p>

<p>date</p>

<p>时间戳</p>

<p>date +%s</p>

<p>日期转换为时间戳</p>

<p>date &ndash;date &ldquo;Thu Nov 18 08:07:21 IST 2010&rdquo; +%s</p>

<p>日期格式化</p>

<p>星期 %a Sat</p>

<p>%A Saturday</p>

<p>月 %b Nov</p>

<p>%B November</p>

<p>日 %d 31</p>

<p>固定日期格式mm/dd/yy %D</p>

<p>年 %y 10</p>

<p>%Y 2010</p>

<p>小时 %I/%H 08</p>

<p>分钟 %M 33</p>

<p>秒 %S 10</p>

<p>纳秒 %N 696308515</p>

<p>Unix纪元时 %s</p>

<p>格式化</p>

<p>date &ldquo;+%Y %B %d&rdquo;</p>

<p>date +%Y-%m-%d</p>

<p>输出： 2011-07-28</p>

<p>date +&ldquo;%Y-%m-%d %H:%M:%S&rdquo;</p>

<p>设置日期和时间</p>

<p>date -s &ldquo;格式化日期字符串&rdquo;</p>

<p>date -s &ldquo;21 June 2009 11:01:22&rdquo;</p>

<p>延时</p>

<p>sleep number_of_seconds</p>

<p>两天后及两天前</p>

<p>date -d &lsquo;2 days&rsquo; +%Y%m%d</p>

<p>date -d &lsquo;2 days ago&rsquo; +%Y%m%d</p>

<p>某一天的几天前</p>

<p>TODAY=<code>date +%Y%m%d</code></p>

<p>DAY_1_AGO=<code>date -d &quot;$TODAY 1 daysago&quot; +%Y%m%d</code></p>

<p>时间戳日期转换</p>

<p>date-d@1193144433</p>

<p>date-d@1193144433&rdquo;+%Y-%m-%d%T&rdquo;</p>

<p>反向:</p>

<p>date-d&rdquo;2007-10-2315:00:23&rdquo;&ldquo;+%s&rdquo;</p>

<p>赋值给变量</p>

<p>DATE=$(date +%Y%m%d)</p>

<p>DATE=<code>date +%Y%m%d</code></p>

<p><strong>调试脚本</strong></p>

<p>打印出所执行的每一行命令</p>

<p>bash -x script.sh</p>

<p>sh -x script.sh</p>

<p>在脚本中设置开关</p>

<p>set -x 在执行时显示参数和命令</p>

<p>set +x 关闭调试</p>

<p>set -v 当命令进行读取时显示输入</p>

<p>set +v 禁止打印输入</p>

<p>直接修改脚本</p>

<p>#!/bin/bash -xv</p>

<p><strong>函数和参数</strong></p>

<p>定义函数</p>

<p>function fname()</p>

<p>{</p>

<p>statements;</p>

<p>}</p>

<p>or</p>

<p>fname()</p>

<p>{</p>

<p>statements;</p>

<p>}</p>

<p>调用</p>

<p>fname;</p>

<p>传参</p>

<p>fname arg1 arg2;</p>

<p>接收参数</p>

<p>$1第一个参数</p>

<p>$2第二个参数</p>

<p>$n第n个参数</p>

<p>&rdquo;$@&ldquo;被扩展成&rdquo;$1&rdquo;&ldquo;$2&rdquo;&ldquo;$3&rdquo;</p>

<p>&rdquo;$*&ldquo;扩展成&rdquo;$1c$2c$3&rdquo;,其中c是IFS第一个字符</p>

<p>&rdquo;$@&ldquo;使用最多, $*将所有的参数当做单个字符串</p>

<p>bash支持递归</p>

<p>导出函数,可以作用到子进程中</p>

<p>export -f fname</p>

<p>函数及命令返回值</p>

<p>cmd;</p>

<p>echo $?</p>

<p>退出状态，成功退出，状态为0，否则，非0</p>

<p>cmd</p>

<p>if [ $? -eq 0 ]</p>

<p>then</p>

<p>echo&rdquo;success&rdquo;</p>

<p>else</p>

<p>echo&rdquo;fail&rdquo;</p>

<p>fi</p>

<p><strong>管道</strong></p>

<p>前一个命令的输出作为后一个命令的输入</p>

<p>$cmd1 | cmd2 |cmd3</p>

<p><strong>读取命令输出</strong></p>

<p>子shell subshell</p>

<p>cmd_output=$(COMMANDS)</p>

<p>or</p>

<p>反引用</p>

<p>cmd_output=<code>COMMANDS</code></p>

<p>子shell本身是独立进程, 不会对当前shell有任何影响</p>

<p>pwd;</p>

<p>(cd /bin; ls)</p>

<p>pwd #同上一个pwd</p>

<p>保留空格和换行符</p>

<p>out=$(cat text.txt)</p>

<p>echo $out #丢失所有换行符</p>

<p>out=&ldquo;$(cat text.txt)&rdquo;</p>

<p>echo $out #保留</p>

<p>cat a</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p>echo $(cat a)</p>

<p>1 2 3</p>

<p>echo &ldquo;$(cat a)&rdquo;</p>

<p>1</p>

<p>2</p>

<p>3</p>

<p><strong>read</strong></p>

<p>read, 用于从键盘或标准输入中读取文本</p>

<p>读取n个字符存入变量</p>

<p>read -n number_of_chars variable_name</p>

<p>不回显的方式读取密码</p>

<p>read -s var</p>

<p>显示提示信息</p>

<p>read -p &ldquo;Enter input:&rdquo; var</p>

<p>限时输入</p>

<p>read -t timeout var</p>

<p>设置界定符</p>

<p>read -d delim_char var</p>

<p>read -d &ldquo;:&rdquo; var</p>

<p>hello:</p>

<p><strong>字段分隔符和迭代器</strong></p>

<p>内部字段分隔符，Internal Field Separator, IFS</p>

<p>IFS默认为空白字符（换行符，制表符，空格）</p>

<p>data=&ldquo;name,sex,rollno&rdquo;</p>

<p>oldIFS=$IFS</p>

<p>IFS=,</p>

<p>for item in $data</p>

<p>do</p>

<p>echo $item</p>

<p>done</p>

<p>IFS=$oldIFS</p>

<p><strong>循环</strong></p>

<p>for循环</p>

<p>echo {1..50}</p>

<p>for i in {a..z}; do actions; done;</p>

<p>or</p>

<p>for((i=0;i&lt;10;i++))</p>

<p>{</p>

<p>commands;</p>

<p>}</p>

<p>while循环</p>

<p>while condition</p>

<p>do</p>

<p>commands;</p>

<p>done</p>

<p>until循环</p>

<p>until condition</p>

<p>do</p>

<p>commands;</p>

<p>done</p>

<p><strong>比较和测试</strong></p>

<p>if条件</p>

<p>if condition;</p>

<p>then</p>

<p>commands;</p>

<p>elif condition;</p>

<p>then</p>

<p>commands;</p>

<p>else</p>

<p>commands;</p>

<p>fi</p>

<p>逻辑运算符进行简化, 短路运算更简洁</p>

<p>[ condition ] &amp;&amp; action;</p>

<p>[ condition ] || action;</p>

<p>算术比较</p>

<p>-gt 大于</p>

<p>-lt 小于</p>

<p>-ge 大于等于</p>

<p>-le 小于等于</p>

<p>-ne 不等于</p>

<p>-eq 等于</p>

<p>注意[]和操作数之间的空格</p>

<p>[ $var -eq 0 ]</p>

<p>and</p>

<p>[ $var -ne 0 -a $var2 -ge 2 ]</p>

<p>or</p>

<p>[ $var -ne 0 -o $var2 -ge 2 ]</p>

<p>文件测试</p>

<p>[ -f $file_var ] 正常文件路径或文件名</p>

<p>[ -x $var ] 可执行</p>

<p>-d 目录</p>

<p>-e 存在</p>

<p>-c 字符设备文件</p>

<p>-b 块设备文件</p>

<p>-w 可写</p>

<p>-r 可读</p>

<p>-L 符号链接</p>

<p>字符串比较</p>

<p>[[ $str1 = $str2 ]]</p>

<p>[[ $str1 == $str2 ]]</p>

<p>[[ $str1 !=$str2 ]] 不等</p>

<p>[[ $str1 &gt; $str2 ]]</p>

<p>[[ $str1 &lt; $str2 ]]</p>

<p>[[ -z $str1 ]]  空</p>

<p>[[ -n $str1 ]]  非空</p>

<p>if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]]</p>

<p>then</p>

<p>commands <em>;</em></p>

<p>fi</p>

<p><strong>find</strong></p>

<p>搜索指定目录下的文件，从开始于父目录，然后搜索子目录</p>

<p>基本</p>

<p>find base_path</p>

<h1 id="打印文件和目录列表">打印文件和目录列表</h1>

<p>find . -print #默认\n分割文件名</p>

<p>文件名</p>

<p>find path -name &ldquo;*.txt&rdquo; -print</p>

<p>-iname  忽略大小写</p>

<p>多个条件 or</p>

<p>find . \( -name &ldquo;<em>.txt&rdquo; -o -name &ldquo;</em>.py&rdquo;\)</p>

<p>文件路径</p>

<p>通配符</p>

<p>find /home/users -path &ldquo;<em>slynux</em>&rdquo; -print</p>

<p>正则</p>

<p>find . -regex &ldquo;.*\(\.py|\.sh\)$&rdquo;</p>

<p>-iregex 忽略大小写</p>

<p>否定参数</p>

<p>find . ! -name &ldquo;*.txt&rdquo; -print</p>

<p>根据文件类型</p>

<p>find . -type d -print</p>

<p>f 普通文件</p>

<p>l 符号链接</p>

<p>d 目录</p>

<p>c 字符设备</p>

<p>b 块设备</p>

<p>s 套接字</p>

<p>p Fifo</p>

<p>设定目录深度</p>

<p>find . -maxdepth 1 -type f -print</p>

<p>find . -mindepth 2 -type f -print</p>

<p>根据文件时间搜索</p>

<p>计量单位天</p>

<p>-atime 最近一次访问时间</p>

<p>-mtime 最后一次被修改时间</p>

<p>-ctime 文件元数据，最近一次修改时间</p>

<p>find . -type f -atime -7 -print #最近七天内被访问的</p>

<p>find . -type f -atime 7 -print #恰好在七天前</p>

<p>+7 -print #超过七天</p>

<p>计量单位分钟</p>

<p>-amin 访问时间</p>

<p>-mmin 修改时间</p>

<p>-cmin 变化时间</p>

<p>find . -type f -amin +7 -print #访问时间超过7分钟的</p>

<p>find . -type f -newer file.txt -print #用于比较时间戳的参考文件，比参考文件更新的文件</p>

<p>基于文件大小的搜索</p>

<p>find . -type f -size +2k</p>

<p>+ 大于 -小于 无符号，恰好等于</p>

<p>b 块</p>

<p>c 字节</p>

<p>w 字（2字节）</p>

<p>k 千字节</p>

<p>M 兆字节</p>

<p>G 吉字节</p>

<p>删除匹配的文件</p>

<p>find . -type f -name &ldquo;*.swp&rdquo; -delete</p>

<p>#注意：-delete位置一定是最后</p>

<p>文件权限及所有权</p>

<p>find . -type f -perm 644 -print</p>

<p>find . -type f -user slynux -print</p>

<p>执行命令或动作(最强大的命令)</p>

<p>find . -type f -user root -exec chown slynux {} \;</p>

<p>find . -type f -exec cp {} OLD \;</p>

<p>find . -iname &ldquo;abc.txt&rdquo; -exec md5sum {} \;</p>

<p>{} 江北替换成对应文件名</p>

<p>exec无法结合多个命令，可以将多个命令放入脚本，调用之</p>

<p>跳过指定目录</p>

<p>find . \( -name &ldquo;.git&rdquo; -prune \) -name &lsquo;*.txt&rsquo;</p>

<p><strong>xargs</strong></p>

<p>将标准输入数据转化成命令行参数</p>

<p>将stdin接收到的数据重新格式化，再将其作为参数传给其他命令</p>

<p>多行输入转化成单行输出</p>

<p>cat example.txt |xargs #空格替换掉\n</p>

<p>切成多行，每行n个参数</p>

<p>cat examplet.txt | xargs -n 3</p>

<p>可以指定分隔符</p>

<p>echo &ldquo;aaaXbbbXccc&rdquo; | xargs -d &lsquo;X&rsquo;</p>

<p>将参数传递给脚本(类似循环)</p>

<p>cat args.txt | xargs -n 1 ./cecho.sh</p>

<p>./cecho.sh -p arg1 1</p>

<p>需要变更</p>

<p>cat args.txt | xargs -I {} ./cecho.sh -p {} 1</p>

<p>find与xargs组合</p>

<p>find . -type f -name &ldquo;*.txt&rdquo; -print | xargs rm -rf</p>

<p>其他</p>

<p>cat file | ( while read arg; do cat $arg; done )</p>

<p>cat file | xargs -I {} cat {}</p>

<p><strong>tr</strong></p>

<p>tr可以对来自标准输入的字符进行替换，删除以及压缩(translate, 可以将一组字符变成另一组字符)</p>

<p>tr只能通过stdin，无法通过其他命令行进行接收参数</p>

<p>格式</p>

<p>tr [options] source-char-set replace-char-set</p>

<p>选项</p>

<p>-c 取source-char-set补集，通常与-d/-s配合</p>

<p>-d 删除字source-char-set中的所列的字符</p>

<p>-s 浓缩重复字符，连续多个变成一个</p>

<p>字符替换</p>

<p>cat /proc/12501/environ | tr &lsquo;\0&rsquo; &lsquo;\n&rsquo;</p>

<p>大小写替换</p>

<p>echo &ldquo;HELLO&rdquo;| tr &lsquo;A-Z&rsquo; &lsquo;a-z&rsquo;</p>

<p>cat text | tr &lsquo;\t&rsquo; &lsquo; &lsquo;</p>

<p>删除字符</p>

<p>echo &ldquo;hello 123 world 456&rdquo;| tr -d &lsquo;0-9&rsquo;</p>

<p>hello world</p>

<p>字符集补集</p>

<p>echo &ldquo;hello 1 char 2&rdquo; | tr -d -c &lsquo;0-9&rsquo; #删除非0-9</p>

<p>12</p>

<p>压缩字符</p>

<p>连续的重复字符</p>

<p>echo &ldquo;GNU is not UNix&rdquo; | tr -s &lsquo; &lsquo;</p>

<p>字符类</p>

<p>alnum 字母和数字</p>

<p>alpha 字母</p>

<p>cntrl 控制字符</p>

<p>digit 数字</p>

<p>graph 图形字符</p>

<p>lower 小写字母</p>

<p>print 可打印字符</p>

<p>punct 标点符号</p>

<p>space 空白字符</p>

<p>upper 大写字母</p>

<p>xdigit 十六进制字符</p>

<p>tr &lsquo;[:lower:]&rsquo; &lsquo;[:upper:]&rsquo;</p>

<p><strong>md5sum</strong></p>

<p>32个字符的十六进制串</p>

<p>md5sum filename</p>

<p>md5sum filename1 filename2</p>

<p><strong>sha1sum</strong></p>

<p>40个字符十六进制串</p>

<p>sha1sum file</p>

<p><strong>对目录进行校验</strong></p>

<p>需安装md5deep软件包</p>

<p>md5deep/sha1deep</p>

<p>md5deep -rl dirname</p>

<p>r递归，l相对路径</p>

<p><strong>sort</strong></p>

<p>语法</p>

<p>sort [options] [file(s)]</p>

<p>-c 检查是否已排序</p>

<p>-u 丢弃所有具有相同键值的记录</p>

<p>-b 忽略开头空白</p>

<p>-d 字典序</p>

<p>-g 一般数值，以浮点数类型比较字段，仅支持gnu</p>

<p>-i 忽略无法打印的字符</p>

<p>-k 定义排序键值字段</p>

<p>-n 以整数类型比较字段</p>

<p>-r 倒转</p>

<p>-o 输出到指定文件</p>

<p>排序</p>

<p>sort file1 &gt; file1.sorted</p>

<p>sort -o file1.sored file1</p>

<p>按数字, 要明确</p>

<p>sort -n file1</p>

<p>逆序</p>

<p>sort -r file</p>

<p>测试一个文件是否已经被排过序</p>

<p>sort -C file</p>

<p>if [ $? -eq 0 ]; then</p>

<p>echo ssss</p>

<p>fi</p>

<p>合并两个排过序的文件，并不需要对合并后的文件进行再排序</p>

<p>sort -m sorted1 sorted2</p>

<p>根据键或者列排序(按照哪一个列)</p>

<p>sort -k 1 data</p>

<p>限定特定范围内一组字符</p>

<p>key=char4-char8</p>

<p>sort -k 2,3 data</p>

<p>sort -k2.4,5.6 file</p>

<p>第二个字段的第四个字符开始比较，直到第五个字段的第六个字符</p>

<p>忽略前导空白及字典序排序</p>

<p>sort -bd unsorted.txt</p>

<p>去重</p>

<p>sort a.txt | uniq</p>

<p>sort -u a.txt</p>

<p><strong>uniq</strong></p>

<p>用法</p>

<p>uniq file</p>

<p>只显示未重复的记录</p>

<p>uniq -u file</p>

<p>找出重复的行</p>

<p>uniq -d file</p>

<p>-s 可指定跳过前N个字符</p>

<p>-w 指定用于比较的最大字符数</p>

<p>统计各行出现的次数</p>

<p>uniq -c file</p>

<p>p57</p>

<p><strong>tempfile</strong></p>

<p>只有在基于Debian的发布版才有(Ubuntu/Debian)</p>

<p>temp_file=$(tempfile)</p>

<p>等同</p>

<p>temp_file=&ldquo;/tmp/file-$RANDOM&rdquo;</p>

<p>#$$为进程id</p>

<p>temp_file=&ldquo;/tmp/var.$$&rdquo;</p>

<p><strong>split</strong></p>

<p>按大小分割文件, 单位k(KB), M, G, c(byte), w(word)</p>

<p>split -b 10k data.file</p>

<p>-d数字后缀，-a后缀长度</p>

<p>split -b 10k data.file -d -a 4</p>

<p>分割后指定文件名前缀</p>

<p>split -b 10k data.file file_prefix</p>

<p>设置后缀格式</p>

<p>split -b 10k data.file -d -a 4 file_prefix</p>

<p>根据行数分割</p>

<p>spilt -l 10 data</p>

<p>其扩展是csplit，可根据文件特性切分，关注</p>

<p><strong>bash 变量匹配切分</strong></p>

<p>sample.jpg</p>

<p>file_jpg=&ldquo;sample.jpg&rdquo;</p>

<p>从右向左匹配</p>

<p><strong>${</strong> file_jpg%.* <strong>}</strong></p>

<p>#sample</p>

<p>从左向右匹配</p>

<p><strong>${</strong> file_jpg <em>#.*</em> <strong>}</strong></p>

<p>#jpg</p>

<p>% # 属于非贪婪</p>

<p>%% ## 属于贪婪</p>

<p>贪婪非贪婪</p>

<p>var=hack.fun.book.txt</p>

<p><strong>${</strong> var%.* <strong>}</strong> #hack.fun.book</p>

<p><strong>${</strong> var%%.* <strong>}</strong> #hack</p>

<p><strong>${</strong> var <em>#.*</em> <strong>}</strong> #fun.book.txt</p>

<p><strong>${</strong> var <em>##.*</em> <strong>}</strong> #txt</p>

<p><strong>expect</strong></p>

<p>实现自动化</p>

<p>spawn ./ineractive.sh</p>

<p>expect &ldquo;Enter the number&rdquo;</p>

<p>send &ldquo;1\n&rdquo;</p>

<p>expect &ldquo;Enter name:&rdquo;</p>

<p>send &ldquo;hello\n&rdquo;</p>

<p>expect eof</p>

<p>spawn指定需要自动化的命令</p>

<p>expect提供需要等待的消息</p>

<p>send发送消息</p>

<p>expect eof指明命令交互结束</p>

<p><strong>dd</strong></p>

<p>生成任意大小的文件</p>

<h1 id="创建一个1m大小的文件junk-data">创建一个1M大小的文件junk.data</h1>

<p>bs=2M count=2 则文件大小4M</p>

<p>dd if=/dev/zero of=junk.data bs=1M count=1</p>

<p>输入文件 输出文件 块大小 复制块数</p>

<p>块大小单位</p>

<p>字节(1B) c</p>

<p>字(2B) w</p>

<p>块(512B) b</p>

<p>千字节(1024B) k</p>

<p>兆字节(1024KB) M</p>

<p>吉字节(1024MB) G</p>

<p><strong>comm</strong></p>

<p>两个文件之间比较，输出三列</p>

<p>onleA \t onlyB \t bothAB</p>

<p>comm A B -1 -2 #删除第一第二列</p>

<p>-3 删除第三列</p>

<p>可以得到A^B A-B B-A</p>

<p><strong>mkdir</strong></p>

<p>“mkdir”(Make
directory)命令在命名路径下创建新的目录。然而如果目录已经存在了，那么它就会返回一个错误信息”不能创建文件夹，文件夹已经存在了”(“cannot
create folder, folderalready exists”)</p>

<p>mkdir dirpath  针对本身就存在的，</p>

<p>mkdir -p dirpath1/dirpath2 针对本身不存在的</p>

<p>#一次多个目录</p>

<p>mkdir -p /home/user/{test,test1,test2}</p>

<p>注意：目录只能在用户拥有写权限的目录下才能创建</p>

<p><strong>ls</strong></p>

<p>ls命令是列出目录内容(List Directory Contents)的意思。运行它就是列出文件夹里的内容，可能是文件也可能是文件夹</p>

<p>ls文件的内容关系</p>

<p>- 普通文件</p>

<p>d 目录</p>

<p>c 字符设备</p>

<p>b 块设备</p>

<p>l 符号链接</p>

<p>s 套接字</p>

<p>p 管道</p>

<p>文件权限序列</p>

<p>rwx</p>

<p>rwS setuid(S)，特殊权限, 出现在x的位置, 允许用户以其拥有者的权限来执行文件, 即使这个可执行文件是由其他用户运行的</p>

<p>目录</p>

<p>r,允许读取目录中文件和子目录列表</p>

<p>w,允许在目录中创建或删除文件或目录</p>

<p>x,指明是否可以访问目录中的文件和子目录</p>

<p>rwt/rwT 粘滞位，只有创建该目录的用户才能删除目录中的文件，即使用户组和其他用户也有写权限，典型例子/tmp, 写保护</p>

<p>查看目录</p>

<p>ls -d */</p>

<p>ls -F | grep &ldquo;/$&rdquo;</p>

<p>ls -l | grep &ldquo;^d&rdquo;</p>

<p>find . -type d -maxdepth 1 -print</p>

<p>其他</p>

<p>ls -l 命令已详情模式(longlisting fashion)列出文件夹的内容</p>

<p>ls -a 命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件</p>

<p><strong>chmod</strong></p>

<p>设置文件权限</p>

<p>“chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p>

<p>设置权限</p>

<p>user group others all</p>

<p>u g o a</p>

<p>chmod u=rwx g=rw o=r filename</p>

<p>chmod u+x filename</p>

<p>chomd a+x filename #所有</p>

<p>chmod a-x filename</p>

<p>chmod 764 filename</p>

<p>#设置粘滞位</p>

<p>chmod a+t dirname</p>

<p>#递归改变</p>

<p>chmod 777 . –R //给其所有权限；</p>

<p>注意：对于系统管理员和用户来说，这个命令是最有用的命令之一了。在多用户环境或者服务器上，对于某个用户，如果设置了文件不可访问，那么这个命令就可以解决，如果设置了错误的权限，那么也就提供了为授权的访问。</p>

<p><strong>chown</strong></p>

<p>每个文件都属于一个用户组和一个用户“chown”命令用来改变文件的所有权，所以仅仅用来管理和提供文件的用户和用户组授权。</p>

<p>改变所有权</p>

<p>chown user.group filename</p>

<p>递归</p>

<p>chown -R user.group .</p>

<p>每次都以其他用户身份执行(允许其他用户以文件所有者的身份来执行)</p>

<p>chomod +s executable_file</p>

<p>chown root.root executable_file</p>

<p>chmod +s executable_file</p>

<p>./executable_file</p>

<p><strong>chattr</strong></p>

<p>创建不可修改文件</p>

<p>chattr +i file</p>

<p>一旦被设置为不可修改, 任何用户包括超级用户都不能删除该文件, 除非其不可修改的属性被移除</p>

<p>chattr -i file</p>

<p><strong>touch</strong></p>

<p>“touch”命令代表了将文件的访问和修改时间更新为当前时间。</p>

<p>touch命令只会在文件不存在的时候才会创建它(空白文件)。如果文件已经存在了，它会更新时间戳，但是并不会改变文件的内容。</p>

<p>空白文件</p>

<p>touch filename</p>

<p>for name {1..100}.txt</p>

<p>do</p>

<p>touch $name</p>

<p>done</p>

<p>修改文件访问时间</p>

<p>touch -a &ldquo;Fri Jun 25 20:50:14 IST 1999&rdquo; filename</p>

<p>touch -m #修改文件内容的修改时间</p>

<p>修改文件或目录的时间戳(YYMMDDhhmm)</p>

<p>touch -t 0712250000 file</p>

<p>注意：touch 可以用来在用户拥有写权限的目录下创建不存在的文件。</p>

<p><strong>ln</strong></p>

<p>建立软连接</p>

<p>ln -s target symbolic_link_name</p>

<p>如果目的路径已经存在，而没有指定 -f 标志，ln  命令不会创建新的链接，而是向标准错误写一条诊断消息并继续链接剩下的 SourceFiles。</p>

<p>-f 促使ln 命令替换掉任何已经存在的目的路径</p>

<p><strong>readlink</strong></p>

<p>读取链接对应真是路径</p>

<p>readlink web</p>

<p>readlink ~/.vim</p>

<p>/Users/ken/github/k-vim</p>

<p><strong>file</strong></p>

<p>通过查看文件内容来找出特定类型的文件</p>

<p>打印文件类型信息</p>

<p>file filename</p>

<p>打印不包含文件名在内</p>

<p>file -b filename</p>

<p>e.g.</p>

<p>file /etc/passwd</p>

<p>/etc/passwd: ASCII English text</p>

<p>file -b /etc/passwd</p>

<p>ASCII English text</p>

<p><strong>读文件</strong></p>

<p>while read line;</p>

<p>do</p>

<p>something</p>

<p>done &lt; filename</p>

<p><strong>diff</strong></p>

<p>生成文件差异</p>

<p>非一体化</p>

<p>diff version1.txt version2.txt</p>

<p>一体化, 可读性更好</p>

<p>diff -u version.txt</p>

<p>使用patch将命令应用于任意一个文件</p>

<p>diff -u version1.txt version2.txt &gt; version.patch</p>

<p>patch -p1 version1.txt &lt; version.patch</p>

<p>递归作用于目录</p>

<p>diff -Naur directory1 directory2</p>

<p>-N 所有缺失的文件作为空文件</p>

<p>-a 所有文件视为文本文件</p>

<p>-u 一体化输出</p>

<p>-r 递归遍历</p>

<p><strong>head</strong></p>

<p>前10行打印</p>

<p>head file</p>

<p>前n行</p>

<p>head -n 4 file</p>

<p>扣除最后N行之外的所有行</p>

<p>head -n -5 file</p>

<p><strong>tail</strong></p>

<p>最后10行</p>

<p>tail file</p>

<p>打印最后五行</p>

<p>tail -n 5 file</p>

<p>tail -5 file</p>

<p>扣除前n行</p>

<p>tail -n +(N+1)</p>

<p>实时动态打印</p>

<p>tail -f growing_file</p>

<p>当某个给定进程结束后, tail随之终结</p>

<p>tail -f file &ndash;PID  $PID</p>

<p><strong>pushd/popd</strong></p>

<p>将当前路径压入栈</p>

<p>pushd</p>

<p>压入某个路径</p>

<p>pushd /home/ken</p>

<p>查看当前路径列表</p>

<p>dirs</p>

<p>切换到某一个</p>

<p>#dirs从左到右编号 0 -</p>

<p>pushd +3</p>

<p>移除最近压入栈的路径并切换到下一个目录</p>

<p>popd</p>

<p><strong>cd</strong></p>

<p>经常使用的“cd”命令代表了改变目录。它在终端中改变工作目录来执行，复制，移动，读，写等等操作</p>

<p>切换到上一目录</p>

<p>cd -</p>

<p>会到HOME目录</p>

<p>cd</p>

<p>cd ~</p>

<p>会到上一级目录</p>

<p>cd ..</p>

<p><strong>wc</strong></p>

<p>Word Count</p>

<p>统计行数</p>

<p>wc -l file</p>

<p>统计单词数</p>

<p>wc -w file</p>

<p>统计字符数</p>

<p>wc -c file</p>

<p>统计所有</p>

<p>wc file</p>

<p>统计最长行的长度</p>

<p>wc file -L</p>

<p><strong>tree</strong></p>

<p>以图形化的树状结构打印文件和目录的结构，需要自行安装</p>

<p>tree ~/unixfile</p>

<p>重点标记出匹配某种样式的文件</p>

<p>tree PATH -P &ldquo;*.sh&rdquo;</p>

<p>只标记符合样式之外的文件</p>

<p>tree path -I PATTERN</p>

<p>同时打印文件和目录大小</p>

<p>tree -h</p>

<p><strong>grep</strong></p>

<p>文本搜索工具, 支持正则表达式和通配符</p>

<p>‘grep‘命令搜索指定文件中包含给定字符串或者单词的行</p>

<p>基本用法</p>

<p>grep &ldquo;match_pattern&rdquo; file1 file2</p>

<p>使用颜色重点标记</p>

<p>grep word filename &ndash;color=auto</p>

<p>扩展型使用正则</p>

<p>grep -E &ldquo;[a-z]+&rdquo;</p>

<p>egrep &ldquo;[a-z]+&rdquo;</p>

<p>只输出匹配到的文本部分</p>

<p>grep -o word filename</p>

<p>除匹配行外的所有行</p>

<p>grep -v word filename</p>

<p>统计匹配行数</p>

<p>grep -c &lsquo;text&rsquo; filename</p>

<p>打印出包含匹配字符串的行数</p>

<p>grep linux -n filename</p>

<p>打印样式匹配所位于的字符或字节的偏移</p>

<p>echo &ldquo;gnu is not unix&rdquo; | grep -b -o &ldquo;not&rdquo;</p>

<p>搜索多个文件，找出匹配文本位于哪个文件中</p>

<p>grep -l linux file1 file2</p>

<p>取反</p>

<p>grep -L</p>

<p>递归搜索目录</p>

<p>grep -R &ldquo;text&rdquo; dir</p>

<p>忽略大小写</p>

<p>grep -i &ldquo;hello&rdquo; filename</p>

<p>匹配多个样式</p>

<p>grep -e &ldquo;pattern1&rdquo; -e &ldquo;pattern2&rdquo; file</p>

<p>运行匹配脚本</p>

<p>grep -f pattern_file source_file</p>

<p>pattern_file:</p>

<p>hello</p>

<p>cool</p>

<p>在搜索中包含、排除文件</p>

<p>grep &ndash;include *.{c,cpp} word file</p>

<p>排除</p>

<p>grep &ndash;exclude &ldquo;Readme&rdquo; filename</p>

<p>--exclude-dir</p>

<p>静默输出，用于判断(不会产生任何输出)</p>

<p>grep -q word file</p>

<p>if [ $? -eq 0 ]</p>

<p>打印匹配行之前，之后的行</p>

<p>grep -A 3 之后3行</p>

<p>grep -B 3 之前</p>

<p>grep -C 3 前后</p>

<p>使用行缓冲</p>

<p>在使用tail -f命令时是可以及时看到文件的变化的，但是如果再加上一个grep命令，可能看到的就不那么及时了，</p>

<p>因为grep命令在buffer写不满时就不输出，可以通过选项 --line-buffered 来搞定，如：</p>

<p>tail -f file.txt | grep something &ndash;line-buffered</p>

<p><strong>cut</strong></p>

<p>语法</p>

<p>cut -c list [ file &hellip; ]</p>

<p>cut -f list [ -d delim ] [ file &hellip;]</p>

<p>-c list 以字符为主，作剪切操作</p>

<p>-f list 以字段为主，作剪切操作</p>

<p>提取字段或列</p>

<p>#第一列</p>

<p>cut -f1 filenam</p>

<p>#第二三列</p>

<p>cut -f2,3 filename</p>

<p>提取补集</p>

<p>cut -f1 &ndash;complement filename</p>

<p>指定字段分隔符</p>

<p>cut -d &ldquo;;&rdquo; -f2 filename</p>

<p>cut -d : -f 1,5 /etc/passwd</p>

<p>指定字符</p>

<p>-b 字节</p>

<p>-c 字符</p>

<p>-f 字段</p>

<p>cut -c1-5 filename</p>

<p>N-</p>

<p>N-M</p>

<p>-M</p>

<p>ls -l | cut -c 1-10</p>

<p>指定输出分隔符</p>

<p>cut -c1-3,6-9 &ndash;output-delimiter &ldquo;,&rdquo;</p>

<p><strong>join</strong></p>

<p>语法</p>

<p>join [options] file1 file2</p>

<p>选项</p>

<p>-1 field1</p>

<p>-2 field2</p>

<p>-o file.field</p>

<p>-t separator</p>

<p>例子</p>

<p>join file1 file2</p>

<p><strong>sed</strong></p>

<p>sed(Stream editor)流编辑器, 可以配合正则使用,进行替换等</p>

<p>sed替换语法</p>

<p>sed &rsquo;s/pattern/replace_string/&rsquo; file</p>

<p>将结果直接运用于源文件</p>

<p>-i 用于, 直接修改源文件</p>

<p>替换第一个</p>

<p>sed -i &rsquo;s/pattern/replace_string/&rsquo; file</p>

<p>替换第二个</p>

<p>sed -i &rsquo;s/pattern/replace_string/2&rsquo; file</p>

<p>替换所有</p>

<p>sed -i &rsquo;s/pattern/replace_string/g&rsquo; file</p>

<p>从第N处开始替换</p>

<p>sed -i &rsquo;s/pattern/replcae_string/2g&rsquo; file</p>

<p>移除空白行</p>

<p>sed &lsquo;/^$/d&rsquo; file</p>

<p>已匹配字符串标记</p>

<p>引用匹配到的</p>

<p>sed &rsquo;s/\w\+/[&amp;]/g&rsquo; filename</p>

<p>组合多个表达式</p>

<p>sed &lsquo;exp1&rsquo; | sed &lsquo;exp2&rsquo;</p>

<p>等价</p>

<p>sed &lsquo;exp1;exp2&rsquo;</p>

<p>使用引用</p>

<p>sed &ldquo;s/$text/HELLO/&rdquo;</p>

<p>子串匹配标记(后向引用，最多9个)</p>

<p>sed &rsquo;s/\([a-z]\+\)&rsquo; \([A-Z\]\+\)/\2 \1/&rsquo; filename</p>

<p>保存到文件</p>

<p>sed &rsquo;s/pattern/replacement/&rsquo; -i outfile</p>

<p>使用其他分隔符</p>

<p>sed &rsquo;s#/home/#/tmp/#&rsquo;</p>

<p><strong>awk</strong></p>

<p>基本结构</p>

<p>awk -F &lsquo;-&rsquo; &lsquo;BEGIN{statements} {statements} END{statements}&lsquo;file</p>

<p>表达式中单引号可以换成双引号</p>

<p>BEGIN -&gt; 每一行，执行statements, 执行END</p>

<p>打印某一列</p>

<p>awk -F &lsquo;-&rsquo; &lsquo;{print $0}&rsquo; file #全部</p>

<p>awk -F &lsquo;-&rsquo; &lsquo;{print $2}&rsquo; file #第二列</p>

<p>print拼接字符</p>

<p>awk &lsquo;{var=&ldquo;v1&rdquo;; var1=&ldquo;v2&rdquo;; printvar1&rdquo;-&ldquo;var2;}&rsquo;</p>

<p>特殊变量</p>

<p>NR nuber of records,  记录数</p>

<p>NF number of fields,  字段数</p>

<p>$0 当前行文本</p>

<p>$1 第一字段</p>

<p>$2 第二字段</p>

<p>$NF最后一个字段</p>

<p>FILENAME 当前输入文件的名称</p>

<p>FNR 当前输入文件记录数</p>

<p>FS 字段分隔字符</p>

<p>OFS 输出字段分隔符，默认&rdquo; &ldquo;</p>

<p>ORS 输出记录分隔符，默认&rdquo;\n&rdquo;</p>

<p>统计行数</p>

<p>awk &lsquo;END{print NF}&rsquo;</p>

<p>将外部变量值传递给awk</p>

<p>awk -v VARIABLE=$VAR &lsquo;{ print VARIABLE }&rsquo;</p>

<p>awk &lsquo;{print v1, v2}&rsquo; v1=$var1 v2=$var2</p>

<p>读取行</p>

<p>seq 5 | awk &lsquo;{ getline var; print var}&rsquo;</p>

<p>进行行过滤</p>

<p>awk &lsquo;NR&lt;5&rsquo; #行号小于5</p>

<p>awk &lsquo;NR==1,NR==4&rsquo; #行号在1到5之间</p>

<p>awk &lsquo;/linux/&rsquo; #包含样式linux</p>

<p>awk &lsquo;!/linux/&rsquo; #不包含</p>

<p>awk &lsquo;$1 ~/jones/&rsquo; #第一个字段包含jones</p>

<p>tail file</p>

<p>awk &lsquo;NR &lt;= 10&rsquo; file</p>

<p>设定分隔符</p>

<p>awk -F: &lsquo;{ print  $NF }&rsquo; file</p>

<p>设定输出分隔符</p>

<p>awk -F: -v &ldquo;OFS=-&rdquo; &lsquo;{print $1,$2}&rsquo; /etc/passwd</p>

<p>打印空行</p>

<p>awk &lsquo;NF&gt;0 {print $0}&rsquo;</p>

<p>or</p>

<p>awk &lsquo;NF&gt;0&rsquo; #未指定action默认打印</p>

<p>print和printf</p>

<p>awk -F: &lsquo;{print &ldquo;User&rdquo;, $1, &ldquo;is really&rdquo;,$5}&rsquo; /etc/passwd</p>

<p>awk -F: &lsquo;{printf &ldquo;User %s is really %s\n&rdquo;, $1, $5}&lsquo;/etc/passwd</p>

<p>awk中使用循环</p>

<p>for(i=0;i&lt;10;i++) { print $i; }</p>

<p>for(i in array) { print array[i] }</p>

<p>内建函数</p>

<p>length(str)</p>

<p>index(str,search_str)</p>

<p>split(str,array,delimiter) 用界定符生成一个字符串列表</p>

<p>substr(string, start, end) #子串</p>

<p>sub(regex, replacement_str, str) #正则替换首个匹配位置</p>

<p>gsub(regex, replacement_str, string) #最后一个匹配位置</p>

<p>match(string, regex) #检查是否能够匹配字符串</p>

<p>tolower(string) #转小写</p>

<p>toupper(string) #转大写</p>

<p>写成脚本文件</p>

<p>BEGIN {}</p>

<p>pattern1 {action1}</p>

<p>pattern2 {action2}</p>

<p>END {}</p>

<p><strong>文件迭代</strong></p>

<p>读文件行</p>

<p>while read line;</p>

<p>do</p>

<p>echo $line;</p>

<p>done &lt; file.txt</p>

<p>迭代每个单词</p>

<p>for word in $line;</p>

<p>do</p>

<p>echo $word;</p>

<p>done</p>

<p>迭代每一个字符</p>

<p>for((i=0;i&lt; <strong>${</strong> <em>#word</em> <strong>}</strong> ;i++))</p>

<p>do</p>

<p>echo <strong>${</strong> word:i:1 <strong>}</strong> ;</p>

<p>done</p>

<p><strong>paste</strong></p>

<p>按列合并文件</p>

<p>paste file1 file2 file3</p>

<p>指定分隔符</p>

<p>paste file1 file2 -d &lsquo;,&rsquo;</p>

<p><strong>tac</strong></p>

<p>逆序打印</p>

<p>tac file1 file2</p>

<p><strong>rev</strong></p>

<p>接收一个文件或stdin作为输入, 逆序打印每一行内容</p>

<p>echo &ldquo;abc&rdquo; | rev</p>

<p><strong>wget</strong></p>

<p>Wget是用于非交互式（例如后台）下载文件的免费工具.支持HTTP,HTTPS, FTP协议和 HTTP 代理(选项多, 用法灵活)</p>

<p>一个用于文件下载的命令行工具</p>

<p>wget URL1 URL2</p>

<p>指定保存文件名</p>

<p>wget URL -O local.txt</p>

<p>指定日志，默认达到stdout</p>

<p>wget URL -O local.txt -o log.txt</p>

<p>指定重复尝试次数</p>

<p>wget -t 5 URL</p>

<p>下载限速</p>

<p>wget &ndash;limit-rate 20k url</p>

<p>指定限额</p>

<p>wget -Q 100m url</p>

<p>断点续传</p>

<p>wget -c URL</p>

<p>$ wget -c -t 100 -T 120 <a href="http://www.linux.com/xxxx.data">http://www.linux.com/xxxx.data</a></p>

<p>当文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。</p>

<p>wget的断点续传是自动的。</p>

<p>-c 选项的作用为断点续传。</p>

<p>-t 参数表示重试次数(例如重试100次，-t 100，如果设成-t 0，表示无穷次重试，直到连接成功)</p>

<p>-T 参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时</p>

<p>复制或镜像整个网站</p>

<p>wget &ndash;mirror exampledomain.com</p>

<p>wget -r -N -l DEPTH URL</p>

<p>递归，允许对文件使用时间戳，层级</p>

<p>$ wget -r -np -nd <a href="http://www.linux.com/packs/">http://www.linux.com/packs/</a></p>

<p>-np 的作用是不遍历父目录</p>

<p>-nd 表示不在本机重新创建目录结构</p>

<p>访问需要认证的HTTP/FTP</p>

<p>wget &ndash;user username &ndash;password pass URL</p>

<p>post请求</p>

<p>wget url -post-data &ldquo;name=value&rdquo; -O output.html</p>

<p>批量下载</p>

<p>wget -i downloads.txt #将文件地址写入一个文件</p>

<p>用wget命令执行ftp下载</p>

<p>wget -m <a href="ftp://username:password@hostname">ftp://username:password@hostname</a></p>

<p><strong>curl</strong></p>

<p>基本用法</p>

<p>curl url &gt; index.html</p>

<p>不显示进度信息</p>

<p>curl URL &ndash;slient</p>

<p>将内容写入文件，而非标准输出</p>

<p>curl URL &ndash;slient -O</p>

<p>写入指定文件</p>

<p>curl URL &ndash;slient -o filename</p>

<p>显示进度条</p>

<p>curl url -o index.html &ndash;progress</p>

<p>断点续传</p>

<p>curl -C - URL</p>

<p>设置参照页字符串</p>

<p>curl &ndash;referer Referer_URL target_URL</p>

<p>跳转到target_URL,其头部referer为Referer_URL</p>

<p>设置cookie</p>

<p>curl url &ndash;cookie &ldquo;user=slynux;pass=hack&rdquo;</p>

<p>另存为一个文件</p>

<p>curl URL &ndash;cookie-jar cookie_file</p>

<p>设置用户代理</p>

<p>curl URL &ndash;user-agent &ldquo;Mozilla/5.0&rdquo;</p>

<p>头部信息</p>

<p>curl -H &ldquo;Host: www.slynux.org&rdquo; -H&rdquo;Accept-language: en&rdquo; url</p>

<p>限定下载带宽</p>

<p>curl url &ndash;limit-rate 20k</p>

<p>指定最大下载量(可下载的最大文件大小)</p>

<p>curl url &ndash;max-filesize bytes</p>

<p>超出限制的话，返回非0</p>

<p>进行认证</p>

<p>curl -u user:pass url</p>

<p>只打印头部信息,不下载远程文件</p>

<p>curl -I url</p>

<p>curl -head url</p>

<p>发送post请求</p>

<p>curl URL -d &ldquo;va1=1&amp;va2=2&rdquo;</p>

<p>--data</p>

<p><strong>lynx</strong></p>

<p>将网页以ascii字符形式下载</p>

<p>lynx -dump URL &gt; webpage_as_text.txt</p>

<p>打印出网站的文本板块而非html</p>

<p>lynx -dump url</p>

<p>生成信息文件</p>

<p>lynx -traversal url</p>

<p><strong>tar</strong></p>

<p>“tar”命令是磁带归档(TapeArchive)，对创建一些文件的的归档和它们的解压很有用。</p>

<p>将多个文件和文件夹保存成单个文件, 同时还能保留所有的文件属性</p>

<p>对文件进行归档</p>

<p>-c create file,创建文件</p>

<p>-f specify filename,指定文件名</p>

<p>tar -cf output.tar file1 file2 file3</p>

<p>tar -cf output.tar *.txt</p>

<p>tar -cvf output.tar *.txt</p>

<p>向归档中追加文件</p>

<p>tar -rvf original.tar new_file</p>

<p>-r,追加</p>

<p>查看过程中更多信息</p>

<p>tar -tvvf archive.tar</p>

<p>-v/-vv, verbose</p>

<p>提取文件或文件夹</p>

<p>-x, exact</p>

<p>tar -xf archive.tar</p>

<p>-C,指定文件</p>

<p>tar -xf archive.tar -C /path/to/extraction_directory</p>

<p>tar -xvf archive.tar</p>

<p>提取指定文件</p>

<p>tar -xvf file.tar file1 file4</p>

<p>拼接两个归档文件</p>

<p>tar -Af file1.tar file2.tar</p>

<p>#file2合并到file1中</p>

<p>只有在文件内容修改时间更新(newer),才进行添加</p>

<p>tar -uvvf archive.tar filea</p>

<p>比较归档文件与文件系统中的内容</p>

<p>tar -df archive.tar filename1 filename2</p>

<p>从归档文件中删除文件</p>

<p>tar -f archive.tar &ndash;delete file1 file2</p>

<p>提取到某个目录</p>

<p>tar zxvfpackage.tar.gz -C new_dir</p>

<p>压缩归档文件</p>

<p>gzip/gunzip -&gt; .gz</p>

<p>f.tar.gz -z</p>

<p>tar -czvf</p>

<p>tar -xzvf</p>

<p>bzip/bunzip -&gt; .bz2</p>

<p>f.tar.bz2 -j</p>

<p>f.tar.lzma &ndash;lzma</p>

<p>f.tar.lzo</p>

<p>从归档中排除部分文件</p>

<p>tar -cf arch.tar * &ndash;exclude &ldquo;*.txt&rdquo;</p>

<p>cat list</p>

<p>filea</p>

<p>fileb</p>

<p>tar -cf arch.tar * -X list</p>

<p>排除版本控制文件</p>

<p>tar &ndash;exclude-vcs -czvvf source.tar.gz files</p>

<p>打印总字节数</p>

<p>tar -cf arc.tar * &ndash;exclude &ldquo;*.txt&rdquo; &ndash;totals</p>

<p><strong>cpio</strong></p>

<p>使用频率不高</p>

<p>归档，保留文件属性（权限、所有权等）</p>

<p>echo file1 file2 | cpio -ov &gt; archive.cpio</p>

<p>-o 指定输出</p>

<p>-v 打印归档文件列表</p>

<p>列出cpio中的文件内容</p>

<p>cpio -it &lt; archive.cpio</p>

<p>-i指定输入</p>

<p>-t列出归档文件中的内容</p>

<p><strong>gzip</strong></p>

<p>压缩，会删除源文件</p>

<p>gzip filename</p>

<p>#got filename.gz</p>

<p>解压</p>

<p>gunzip filename.gz</p>

<p>列出文件属性信息</p>

<p>gzip -l text.gz</p>

<p>stdin读入文件并写出到stdout</p>

<p>cat file | gzip -c &gt; file.gz</p>

<p>压缩归档文件</p>

<p>tar -czvvf archive.tar.gz [files]</p>

<p>or</p>

<p>tar -cvvf archive.tar.gz [files]</p>

<p>gzip archive.tar</p>

<p>指定压缩率</p>

<p>1-9,1最低，但速度最快</p>

<p>gzip -9 test.img</p>

<p><strong>zcat</strong></p>

<p>无需解压缩，直接从.gz中提取内容</p>

<p>zcat test.gz</p>

<p><strong>bzip</strong></p>

<p>更大的压缩率</p>

<p>bzip2 filename</p>

<p>解压缩</p>

<p>bunzip2 filename.bz2</p>

<p>stdin到stdout</p>

<p>cat file &gt; bzip2 -c &gt; file.tar.bz2</p>

<p>压缩归档</p>

<p>tar -cjvvf archive.tar.bz2 [files]</p>

<p>or</p>

<p>tar -cvvf archive.tar [files]</p>

<p>bzip2 archive.tar</p>

<p>保留输入文件</p>

<p>bunzip2 test.bz2 -k</p>

<p>压缩率</p>

<p>bzip2 -9 test.img</p>

<p><strong>lzma</strong></p>

<p>比gzip/bzip2更好的压缩率</p>

<p>压缩</p>

<p>lzma filename</p>

<p>解压</p>

<p>unlzma filename.lzma</p>

<p>stdin到stdout</p>

<p>cat file | lzma -c &gt; file.lzma</p>

<p>创建归档</p>

<p>tar -cavvf archive.tar.lzma [files]</p>

<p>-xavf</p>

<p>保留输入文件</p>

<p>lzma test.bz2 -k</p>

<p>压缩率</p>

<p>lzma -9 test.img</p>

<p><strong>zip</strong></p>

<p>压缩</p>

<p>zip archive_name.zip [source files/dirs]</p>

<p>对目录和文件进行递归操作</p>

<p>zip -r archive.zip folder1 file2</p>

<p><strong>base64</strong></p>

<p>编码</p>

<p>base64 filename &gt; outfile</p>

<p>cat file | base64 &gt; outfile</p>

<p>解码</p>

<p>base64 -d file &gt; outfile</p>

<p><strong>md5sum</strong></p>

<p>“md5sum”就是计算和检验MD5信息签名。<br />
md5 checksum(通常叫做哈希)使用匹配或者验证文件的文件的完整性，因为文件可能因为传输错误，磁盘错误或者无恶意的干扰等原因而发生改变。</p>

<p>单向散列</p>

<p>md5sum file</p>

<p>sha1sum file</p>

<p><strong>rsync</strong></p>

<p>可以对位于不同位置的文件和目录进行备份, 借助差异计算和压缩技术实现最小化数据传输量</p>

<p>要确保远端安装了 openssh</p>

<p>从一个目录复制到另一个目录</p>

<p>rsync -av source_path dest_path</p>

<p>-a 进行归档 -v打印细节</p>

<p>路径可以使本地，也可以是远端路径</p>

<p>e.g.</p>

<p>rsync -av /home/test /home/backups/ #复制到backups目录下</p>

<p>rsync -av /home/test /home/backups #创建backups目录, 复制</p>

<p>备份到远程服务器</p>

<p>rsync -av source_path user@host:PATH</p>

<p>可以反向</p>

<p>改善传输速度</p>

<p>rsync -avz source destination</p>

<p>排除文件</p>

<p>rsync -avz source dest &ndash;exclude &ldquo;*.txt&rdquo;</p>

<p>--exclude-from FILEPATH</p>

<p>FILEPATH:</p>

<p>*.bak</p>

<p>更新备份时，删除不存在的文件</p>

<p>rsync -avz source dest &ndash;delete</p>

<p><strong>git</strong></p>

<p>初始化目录</p>

<p>git init</p>

<p>配置用户信息</p>

<p>git config &ndash;global user.name &ldquo;wklken&rdquo;</p>

<p>git config &ndash;global user.email &ldquo;wklken@yeah.net&rdquo;</p>

<p>加到远端</p>

<p>git remote add origin user@remotehost:/home/backup/backup.git</p>

<p>git push origin master</p>

<p>添加</p>

<p>git add *</p>

<p>删除</p>

<p>git rm *.py</p>

<p>标记一个检查点</p>

<p>git commit -m &ldquo;Commit message&rdquo;</p>

<p>查看日志</p>

<p>git log</p>

<p>回滚到某个版本</p>

<p>git checkout hashid [ filename ]</p>

<p>克隆</p>

<p>git clone url</p>

<p><strong>dd</strong></p>

<p>Dtat Definiton,  要注意参数顺序, 错误的参数会损毁所有数据</p>

<p>可以用来转换和复制文件，大多数时间是用来复制iso文件(或任何其它文件)到一个usb设备(或任何其它地方)中去，所以可以用来制作USB启动器</p>

<p>语法说明</p>

<p>dd if=SOURCE of=TARGET bs=BLOCK_SIZE count=COUNT</p>

<p>if/of 输入/输出文件或设备路径</p>

<p>bs块大小</p>

<p>count 限制复制到目标的字节数</p>

<p>dd if=/dev/zero of=/dev/sda1</p>

<p>#制作iso 从cdrom设备读取所有数据, 创建iso文件</p>

<p>dd if=/dev/cdrom of=cdrom.iso</p>

<p>备份恢复</p>

<p>dd if=/dev/sda1 of=x.img</p>

<p>dd if=x.img of=/dev/sda1</p>

<p><strong>mount</strong></p>

<p>mount 是一个很重要的命令，用来挂载不能自动挂载的文件系统。你需要root权限挂载设备。<br />
在插入你的文件系统后，</p>

<p>mount &ndash;bind /source /destination</p>

<p>首先运行”lsblk”命令，识别出你的设备，然后把分配的设备名记下来。</p>

<p>root@tecmint:~# lsblk</p>

<p>创建一个任何名字的目录，但是最好和引用相关。</p>

<p>root@tecmint:~# su</p>

<p>Password:</p>

<p>root@tecmint:~# cd /dev</p>

<p>root@tecmint:~# mkdir usb</p>

<p>现在将“sdb1”文件系统挂载到“usb”目录.</p>

<p>root@tecmint:~# mount /dev/sdb1 /dev/usb</p>

<p>挂载镜像</p>

<p>mount -o loop file.img /mnt/mount_point</p>

<p><strong>网络相关</strong></p>

<p><strong>ifconfig</strong></p>

<p>显示网络接口、子网掩码等详细信息</p>

<p>ifconfig</p>

<p>/sbin/ifconfig</p>

<p>打印某个特定网络接口</p>

<p>ifconfig iface_name</p>

<p>e.g.</p>

<p>ifconfig en1</p>

<p>HWaddr MAC地址</p>

<p>inet addr ip地址</p>

<p>Bcast 广播地址</p>

<p>Mask 子网掩码</p>

<p>设置网络接口ip</p>

<p>ifconfig wlan0 192.168.0.80</p>

<p>dns</p>

<p>cat /etc/resolv.conf</p>

<p>host google.com #Dns查找</p>

<p>nslookup google.com #更详细信息</p>

<p>修改dns/host</p>

<p>echo nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf</p>

<p>echo ip domain &gt;&gt; /etc/hosts</p>

<p>ping</p>

<p>ping www.baidu.com</p>

<p>路由信息</p>

<p>显示路由表</p>

<p>route</p>

<p>以数字形式显示地址</p>

<p>route -n</p>

<p>设置默认网关</p>

<p>route add default gw 192.168.0.1 wlan0</p>

<p>trace_route, 显示分组途径的所有网关的地址</p>

<p>traceroute google.com</p>

<p><strong>ping</strong></p>

<p>基本</p>

<p>ping ADDRESS #主机名，域名或ip</p>

<p>PING命令可以得到RTT(RoundTrip Time), 分组从源到目的主机的往返时间,单位ms</p>

<p>限制发送分组数</p>

<p>ping ADDRESS -c COUNT</p>

<p>ping</p>

<p><strong>fping</strong></p>

<p>同时ping一组ip, 而且响应非常快</p>

<p>fping -a ip1 ip2 -g</p>

<p>fping -a 192.160.<sup>1</sup>&frasl;<sub>24</sub> -g</p>

<p>fping -a &lt; ip.list</p>

<p>-a, 所有活动主机的ip</p>

<p>-g, 从IP/mask生成的ip地址范围</p>

<p>进行dns查询</p>

<p>fping -a -d 2 &gt; /dev/null &lt; ip.list</p>

<p><strong>lftp</strong></p>

<p>基本用法</p>

<p>lftp username@ftphost</p>

<p>cd dir</p>

<p>lcd改变本地主机目录</p>

<p>mkdir 创建目录</p>

<p>get/put 下载上传</p>

<p>quit退出</p>

<p><strong>scp</strong></p>

<p>scp是secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>

<p>linux的scp命令可以在linux服务器之间复制文件和目录.</p>

<p>拷贝文件</p>

<p>scp filename user@remotehost:/home/pat</p>

<p>ip或主机名均可</p>

<p>scp SOURCE DESTINATION</p>

<p>递归复制</p>

<p>scp -r dir1 user@remotehost:/home/backup</p>

<p>提高拷贝速度</p>

<p>scp -c arcfour -r-P20755 dir/ 192.168.2.*:/<strong>/</strong>/data/</p>

<p>-c arcfour 这个算法没有加校验不保证完整性，注意慎用，内网1000M带宽，默认算法速度只能达到30M/s，用arcfour这个算法速度可以达到50-80M/s</p>

<p><strong>SSH</strong></p>

<p>连接远程</p>

<p>ssh username@remote_host</p>

<p>ssh -p port username@remote_host</p>

<p>执行命令</p>

<p>ssh username@remote_host &lsquo;cmd1; cmd2&rsquo; &gt; stdout.txt2&gt;errors.txt</p>

<p>压缩功能</p>

<p>ssh -C user@hostname &lsquo;cmds&rsquo;</p>

<p>打通ssh</p>

<p>1.创建SSH密钥</p>

<p>ssh-keygen -t rsa</p>

<p>公钥, ~/.ssh/id_rsa.pub</p>

<p>2.登陆远端服务器, 将公钥写入 ~/.ssh/authorized_keys</p>

<p><strong>lsof</strong></p>

<p>列出系统中开放端口及运行在端口上的服务</p>

<p>lsof -i</p>

<p>配合grep, 获取需要的信息</p>

<p><strong>netstat</strong></p>

<p>查看开放端口和服务</p>

<p>netstat -tnp</p>

<p><strong>磁盘和系统</strong></p>

<p><strong>du</strong></p>

<p>du = disk usage</p>

<p>估计文件的空间占用。逐层统计文件（例如以递归方式）并输出摘要。</p>

<p>查看占用磁盘空间</p>

<p>du FILENAME1 FILENAME2</p>

<p>查看目录</p>

<p>du -a dir</p>

<p>以KB,MB或块为单位展示</p>

<p>du -h FILENAME1</p>

<p>显示总计情况</p>

<p>du -c FILENAME1</p>

<p>只显示合计</p>

<p>du -s FILENAME1</p>

<p>以特定单位打印</p>

<p>du -b/-k/-m/-B FILES</p>

<p>排除部分文件</p>

<p>du &ndash;exclude &ldquo;*.txt&rdquo; DIR</p>

<p>--exclude-fromEXCLUDE.txt DIR</p>

<p>指定最深层级</p>

<p>du &ndash;max-depth 2 DIR</p>

<p>指定目录最大的10个文件</p>

<p>du -ak S_DIR | sort -nrk 1 | head</p>

<p><strong>df</strong></p>

<p>df = disk free</p>

<p>报告系统的磁盘使用情况。在跟踪磁盘使用情况方面对于普通用户和系统管理员都很有用。 ‘df‘ 通过检查目录大小工作，但这一数值仅当文件关闭时才得到更新。</p>

<p>查看磁盘可用空间</p>

<p>df</p>

<p>df -h</p>

<p><strong>time</strong></p>

<p>计算命令执行时间</p>

<p>time COMMAND</p>

<p>real 挂钟时间, 从开始执行到结束的时间</p>

<p>user 进程花费在用户模式中的cpu时间, 真正用于执行进程所花得时间</p>

<p>sys 进程花费在内核模式中的cpu时间</p>

<p>写入文件</p>

<p>time -o output.txt COMMAND</p>

<p>time -a output.txt COMMAND #追加</p>

<p>格式化输出</p>

<p>time -f &ldquo;Time: %U&rdquo; -a -o timing.log uname</p>

<p>real %e</p>

<p>user %U</p>

<p>sys %S</p>

<p><strong>who</strong></p>

<p>获取当前用户登陆信息</p>

<p>who / w</p>

<p>当前登陆主机的用户列表</p>

<p>users</p>

<p><strong>uptime</strong></p>

<p>查看系统已经通电运行多长时间了</p>

<p>uptime</p>

<p>#也可以看到负载</p>

<p><strong>last</strong></p>

<p>显示上次用户登录信息- 前一次启动会话信息</p>

<p>last</p>

<p>获取单个用户</p>

<p>last USER</p>

<p><strong>watch</strong></p>

<p>在终端中以固定间隔监视命令输出</p>

<p>#default 2s</p>

<p>watch ls</p>

<h1 id="5s">5s</h1>

<p>watch -n 5 ls</p>

<p>颜色标示</p>

<p>watch -d &lsquo;COMMAND&rsquo;</p>

<p><strong>进程和线程</strong></p>

<p><strong>ps</strong></p>

<p>ps命令给出正在运行的某个进程的状态，每个进程有特定的id成为PID。</p>

<p>ps命令主要查看系统中进程的状态</p>

<p>USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND</p>

<p>USER表示启动进程用户</p>

<p>PID表示进程标志号</p>

<p>%CPU表示运行该进程占用CPU的时间与该进程总的运行时间的比例</p>

<p>%MEM表示该进程占用内存和总内存的比例。</p>

<p>VSZ表示占用的虚拟内存大小，以KB为单位。</p>

<p>RSS为进程占用的物理内存值，以KB为单位。</p>

<p>TTY表示该进程建立时所对应的终端，&rdquo;?&ldquo;表示该进程不占用终端。</p>

<p>STAT表示进程的运行状态，包括以下几种代码：</p>

<p>D，不可中断的睡眠；</p>

<p>R，就绪（在可运行队列中）；</p>

<p>S，睡眠；</p>

<p>T，被跟踪或停止；</p>

<p>Z，终止（僵死）的进程，Z不存在，但暂时无法消除；</p>

<p>W，没有足够的内存分页可分配；&lt;高优先序的进程；</p>

<p>N，低优先序的进程；</p>

<p>L，有内存分页分配并锁在内存体内（实时系统或I/O）。</p>

<p>START为进程开始时间。</p>

<p>TIME为执行的时间。</p>

<p>COMMAND是对应的命令名。</p>

<p>查看进程信息</p>

<p>#当前终端</p>

<p>ps</p>

<p>PID TTY TIME CMD</p>

<p>PID 进程ID</p>

<p>TTY 终端</p>

<p>TIME 进程启动后过去的时间</p>

<p>CMD 进程对应的命令</p>

<p>显示更多信息</p>

<p>#当前终端</p>

<p>ps -f</p>

<p>查看所有进程</p>

<p>ps aux</p>

<p>ps -ef</p>

<p>查看某个用户的所有进程</p>

<p>ps U ken</p>

<p>命令格式</p>

<p>ps[OTHEROPTIONS]-opar1,par2,par3</p>

<p>ps-eocomm,pcpu|head</p>

<p>pmem内存使用率，comm可执行文件名,user启动进程的用户,etime启动后度过的时间</p>

<p>设置升序降序</p>

<p>ps -eo comm,pcpu &ndash;sort -pcpu | head</p>

<p>+升序，-降序</p>

<p>找出给定命令名对应进程ID</p>

<p>ps -C COMMAND_NAME</p>

<p>ps -C bash -o pid=</p>

<p>进程线程相关</p>

<p>ps -eLf &ndash;sort -nlwp | head</p>

<p>查看子进程树</p>

<p>ps axwef</p>

<p>注意：当你要知道有哪些进程在运行或者需要知道想杀死的进程PID时ps命令很管用。你可以把它与‘grep‘合用来查询指定的输出结果，例如：</p>

<h1 id="ps-a-grep-i-ssh">ps -A | grep -i ssh</h1>

<p><strong>pgrep</strong></p>

<p>pgrep只需要命令名的一部分, ps需要准确的全名</p>

<p>基本用法</p>

<p>pgrep bash</p>

<p>指定进程的用户</p>

<p>pgrep -u root,slynux COMMAND</p>

<p>返回匹配进程数</p>

<p>pgrep -c COMANND</p>

<p><strong>top</strong></p>

<p>查看占用cpu最多的进程列表</p>

<p>top</p>

<p><strong>kill</strong></p>

<p>kill是用来杀死已经无关紧要或者没有响应的进程,杀死一个进程需要知道进程的PID</p>

<p>列出可用信号</p>

<p>kill -l</p>

<p>终止一个进程</p>

<p>kill PROCESS_ID_LIST</p>

<p>强杀进程</p>

<p>kill -9 PROCESS_ID</p>

<p>杀死一组命令</p>

<p>killall process_name</p>

<p>killall -9 process_name</p>

<p>指定用户</p>

<p>killall -u USERNAME process_name</p>

<p><strong>pkill</strong></p>

<p>杀，接受进程名</p>

<p>pkill process_name</p>

<p>pkill -s SIGNAL process_name</p>

<p><strong>which</strong></p>

<p>查找PATH下某个命令位置</p>

<p>which ls</p>

<p><strong>whereis</strong></p>

<p>whereis的作用是用来定位命令的二进制文件\资源\或者帮助页.举例来说,获得ls和kill命令的二进制文件/资源以及帮助页:</p>

<p>whereis ls</p>

<p>whereis kill</p>

<p>类似which，多了命令手册位置，源代码位置</p>

<p>注意:当需要知道二进制文件保存位置时有用.</p>

<p><strong>file</strong></p>

<p>确定文件类型</p>

<p><strong>whatis</strong></p>

<p>对命令的简短描述</p>

<p><strong>hostname</strong></p>

<p>当前主机名</p>

<p><strong>uname</strong></p>

<p>主机名</p>

<p>uname -n</p>

<p>#内核版本，硬件架构等</p>

<p>uname -a</p>

<p>#内核发行版本</p>

<p>uname -r</p>

<p>主机类型(32位/64位)</p>

<p>uname -m</p>

<p>cpu相关信息</p>

<p>cat /proc/cpuinfo</p>

<p>内存信息</p>

<p>cat /proc/meminfo</p>

<p>例子</p>

<p>#uname -a</p>

<p>Linux tecmint 3.8.0-19-generic #30-Ubuntu SMP Wed May 116:36:13 UTC 2013 i686
i686 i686 GNU/Linux</p>

<p>1. “Linux“: 机器的内核名</p>

<p>2. “tecmint“: 机器的分支名</p>

<p>3. “3.8.0-19-generic“:  内核发布版本</p>

<p>4. “#30-Ubuntu SMP“:  内核版本</p>

<p>5. “i686“: 处理器架构</p>

<p>6. “GNU/Linux“:  操作系统名</p>

<p><strong>crontab</strong></p>

<p>格式</p>

<ul>
<li>* * * * cmd</li>
</ul>

<p>分钟(0-59)，小时(0-23)，天(1-31)，月份(1-12)，工作日(0-6)</p>

<p>A,B A and B</p>

<p>*/C every C</p>

<p>查看</p>

<p>crontab -l</p>

<p>crontab -l -u slynux</p>

<p>编辑</p>

<p>crontab -e</p>

<p>移除</p>

<p>crontab -r</p>

<p>crontab -u slynux -r</p>

<p>可以在crontab 中加入环境变量</p>

<p><strong>getopts</strong></p>

<p>命令行参数处理</p>

<p>while getopts :f:vql opt</p>

<p>do</p>

<p>case $opt in</p>

<p>f) file=$OPTARG</p>

<p>;;</p>

<p>v) verbose=true</p>

<p>;;</p>

<p>&hellip;.</p>

<p><strong>history</strong></p>

<p>“history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史</p>

<p>history</p>

<p>注意：按住“CTRL + R”就可以搜索已经执行过的命令，它可以你写命令时自动补全</p>

<p><strong>sudo</strong></p>

<p>“sudo”(super user do)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p>

<p>注意：sudo 允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。<br />
并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事，这就是为什么在linux社区流行一句话：</p>

<p>“To err is human, but to really foul up everything, you needroot password.”<br />
“人非圣贤孰能无过，但是拥有root密码就真的万劫不复了。”</p>

<p><strong>cal</strong></p>

<p>“cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份</p>

<p>cal</p>

<p>cal 02 1835</p>

<p><strong>cp</strong></p>

<p>“copy”就是复制。它会从一个地方复制一个文件到另外一个地方</p>

<p>cp file1 file2</p>

<p>cp -r dir1 dir2</p>

<p>快速备份一个文件：</p>

<p>cp some_file_name{,.bkp}</p>

<p>注意： cp，在shell脚本中是最常用的一个命令，而且它可以使用通配符（在前面一块中有所描述），来定制所需的文件的复制。</p>

<p><strong>mv</strong></p>

<p>“mv”命令将一个地方的文件移动到另外一个地方去。</p>

<p>“mv”命令将一个地方的文件移动到另外一个地方去。</p>

<p><strong>pwd</strong></p>

<p>“pwd”（printworking directory），在终端中显示当前工作目录的全路径。</p>

<p>注意：这个命令并不会在脚本中经常使用，但是对于新手，当从连接到nux很久后在终端中迷失了路径，这绝对是救命稻草。</p>

<p><strong>free</strong></p>

<p>free -m</p>

<p>total used free shared buffers cached</p>

<p>Mem: 7982 6811 1171 0 350 5114</p>

<p>-/+ buffers/cache: 1346 6636</p>

<p>Swap: 16935 11 16924</p>

<p>显示剩余内存</p>

<p>free -m | grep cache | awk &lsquo;/[0-9]/{ print $4&rdquo; MB&rdquo;}&rsquo;</p>

<p>在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.</p>

<p>一些简单的计算方法：</p>

<p>物理已用内存 = 实际已用内存 -  缓冲 - 缓存 = 6811M - 350M - 5114M</p>

<p>物理空闲内存 = 总物理内存 -  实际已用内存 + 缓冲 + 缓存</p>

<p>应用程序可用空闲内存 = 总物理内存 -  实际已用内存</p>

<p>应用程序已用内存 = 实际已用内存 -  缓冲 - 缓存</p>

<p>原始解释：转至互联网：<br />
Linux的基本原则是没有资源应该被浪费.因此核心会使用尽可能多的RAM,来缓存来自本地和远程的文件系统的信息.系统做读写操作的时候,会将与当前运行的进程相关的数据尽量存储在RAM里.系统报告的缓存是缓冲和页缓存两者之和.缓存并不是在进程结束的时候被回收(你可能很快会启动另外一个进程,需要同样的数据),而是随需回收–比如,当你启动一个需要大量内存的进程时,Linux核心会从内存中回收缓存,将得到的内存分配给新的进程.</p>

<p>有些区域,比如匿名内存映射(mmps)和共享内存区域,它们被报告为缓存,但不是被核心直接释放.一般的缓存不映射到进程的地址空间,仅仅是简单的核心映射,而这些特别的缓存映射到所有挂接到它们上面的进程.</p>

<p><strong>eval</strong></p>

<p>eval &ldquo;ls -l&rdquo;</p>

<p><strong>basename</strong></p>

<p>获取路径中文件部分</p>

<p>basename resolv.conf #resolv.conf</p>

<p>basename /etc/resolv.conf # resolv.conf</p>

<p><strong>cmp</strong></p>

<p>比较两个任意类型的文件并将结果输出至标准输出。如果两个文件相同， ‘cmp‘默认返回0；如果不同，将显示不同的字节数和第一处不同的位置。</p>

<p>cmp file1 file2</p>

<p>diff file1 file2</p>

<p><strong>rm</strong></p>

<p>‘rm’ 标准移除命令。rm 可以用来删除文件和目录</p>

<p>rm file1</p>

<p>rm -r dir1 #递归删除空目录</p>

<p>强删</p>

<p>rm -rf fileordir</p>

<p>警告: ”rm -rf” 命令是一个破坏性的命令,假如你不小心删除一个错误的目录。<br />
一旦你使用’rm -rf’ 删除一个目录,在目录中所有的文件包括目录本身会被永久的删除,所以使用这个命令要非常小心。</p>

<p><strong>service</strong></p>

<p>‘service‘命令控制服务的启动、停止和重启，它让你能够不重启整个系统就可以让配置生效以开启、停止或者重启某个服务。</p>

<p>注意：要想使用service命令，进程的脚本必须放在‘/etc/init.d‘，并且路径必须在指定的位置。<br />
如果要运行“service apache2 start”实际上实在执行“service /etc/init.d/apache2 start”.</p>

<p><strong>man</strong></p>

<p>‘man‘是系统帮助页。Man提供命令所有选项及用法的在线文档。几乎所有的命令都有它们的帮助页</p>

<p>man thecommand</p>

<p>注意：系统帮助页是为了命令的使用和学习而设计的。</p>

<p><strong>passwd</strong></p>

<p>这是一个很重要的命令，在终端中用来改变自己密码很有用。显然的，因为安全的原因，你需要知道当前的密码。</p>

<p><strong>gcc</strong></p>

<p>gcc 是Linux环境下C语言的内建编译器。下面是一个简单的C程序，在桌面上保存为Hello.c （记住必须要有‘.c‘扩展名</p>

<p>gcc Hello.c</p>

<p>./a.out</p>

<p>gcc -o Hello Hello.c</p>

<p>./Hello</p>

<p>注意: 编译C程序时，输出会自动保存到一个名为“a.out”的新文件，因此每次编译C程序 “a.out”都会被修改。<br />
因此编译期间最好定义输出文件名.，这样就不会有覆盖输出文件的风险了。</p>

<p><strong>g++</strong></p>

<p>g++是C++的内建编译器</p>

<p>g++ Add.cpp</p>

<p>./a.out</p>

<p>g++ -o Add Add.cpp</p>

<p>./Add</p>

<p><strong>java</strong></p>

<p>Java 是世界上使用最广泛的编程语言之一. 它也被认为是高效,安全和可靠的编程语言. 现在大多数基于网络的服务都使用Java实现.</p>

<p>javac tecmint.java</p>

<p>java tecmint</p>

<p>注意: 几乎所有的Linux发行版都带有gcc编译器, 大多数发行版都内建了g++ 和 java  编译器, 有些也可能没有. 你可以用apt或 yum
安装需要的包.</p>

<p><strong>关于 /dev/null</strong></p>

<p>特别有用的特殊文件，位桶，传送到此文件的数据都会被系统丢弃。</p>

<p><strong>语言及乱码</strong></p>

<p>查看变量值</p>

<p>echo $LANG 未设置任何LC_XXX时使用的默认值</p>

<p>echo $LC_ALL覆盖所有LC_XXX变量，总控开关</p>

<p>好的做法是，避免为任何LC_XXX变量赋值，使用LC_ALL和LANG来控制</p>

<p>避免乱码：从编辑器到语言，再到系统，统一编码为UTF-8</p>

<p><strong>shell 的版本</strong></p>

<p>bash &ndash;version</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>