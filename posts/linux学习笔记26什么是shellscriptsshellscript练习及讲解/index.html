<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux学习笔记26什么是Shellscriptsshellscript练习及讲解 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux学习笔记26什么是Shellscriptsshellscript练习及讲解 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux学习笔记26什么是Shellscriptsshellscript练习及讲解">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B026%E4%BB%80%E4%B9%88%E6%98%AFshellscriptsshellscript%E7%BB%83%E4%B9%A0%E5%8F%8A%E8%AE%B2%E8%A7%A3/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux学习笔记26什么是Shellscriptsshellscript练习及讲解</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>如果你真的很想要走信息这条路，并且想要管理好属于你的主机，那么，别说鸟哥不告诉你， 可以自动管理系统的好工具： Shell
scripts！这家伙真的是得要好好学习学习的！ 基本上， shell script
有点像是早期的批处理文件，亦即是将一些指令汇整起来一次执行，但是Shell script 拥有更强大的功能，那就是他可以进行类似程序 （program）
的撰写，并且不需要经过编译 （compile） 就能够执行（解释型语言，注意，js也是编译型语言，但是命令行的像shell是解释型），
真的很方便。加上我们可通过 shell script 来简化我们日常的工作管理， 而且，整个 Linux 环境中，一些服务 （services）
的启动都是通过 shellscript 的， 如果你对于 script 不了解，嘿嘿！发生问题时，可真是会求助无门喔！所以，好好的学一学他吧！</p>

<h1 id="一-什么是-shell-scripts">一、什么是 Shell scripts</h1>

<p>什么是 shell script （程序化脚本） 呢？就字面上的意义，我们将他分为两部份。 在“ shell”部分，我们在 十章的 BASH
当中已经提过了，那是一个命令行下面让我们与系统沟通的一个工具接口。那么“ script ”是啥？ 字面上的意义， script
是“脚本、剧本”的意思。整句话是说，shell script 是针对 shell 所写的“剧本！”</p>

<p>什么东西啊？其实， shell script 是利用 shell 的功能所写的一个“程序 （program）”，这个程序是使用纯文本文件，将一些 shell
的语法与指令（含外部指令）写在里面， 搭配正则表达式、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。</p>

<p>所以，简单的说， shell script 就像是早期 DOS 年代的批处理文件 （.bat） ，最简单的功能就是将许多指令汇整写在一起，
让使用者很轻易的就能够 one touch 的方法去处理复杂的动作 （执行一个文件 &ldquo;shell script&rdquo; ，就能够一次执行多个指令）。 而且
shell script 更提供阵列、循环、条件与逻辑判断等重要功能，让使用者也可以直接以 shell 来撰写程序，而不必使用类似 C
程序语言等传统程序撰写的语法呢！</p>

<p>这么说你可以了解了吗？是的！ shell script 可以简单的被看成是批处理文件， 也可以被说成是一个程序语言，且这个程序语言由于都是利用 shell
与相关工具指令， 所以不需要编译即可执行，且拥有不错的除错 （debug）
工具（shell的debug没怎么用过，pl/sql的debug不会用。。还是eclipse的debug用得习惯），所以，他可以帮助系统管理员快速的管理好主机。</p>

<h2 id="1-干嘛学习-shell-scripts">1，干嘛学习 shell scripts</h2>

<p>这是个好问题：“我又干嘛一定要学 shell script ？我又不是信息人，没有写程序的概念， 那我干嘛还要学 shell script
呢？不要学可不可以啊？”呵呵～如果 Linux 对你而言， 你只是想要“会用”而已，那么，不需要学 shell script
也还无所谓，这部分先给他跳过去， 等到有空的时候，再来好好的瞧一瞧。但是，如果你是真的想要玩清楚 Linux 的来龙去脉， 那么 shellscript
就不可不知，为什么呢？因为：（其实对我来说，就是能管服务器咯，顺便弄弄ngnix，装装hadoop）</p>

<h3 id="自动化管理的重要依据">自动化管理的重要依据</h3>

<p>不用鸟哥说你也知道，管理一部主机真不是件简单的事情，每天要进行的任务就有：查询登录文件、追踪流量、监控使用者使用主机状态、主机各项硬件设备状态、
主机软件更新查询、更不要说得应付其他使用者的突然要求了。而这些工作的进行可以分为： （1）自行手动处理，或是
（2）写个简单的程序来帮你每日“自动处理分析”这两种方式，你觉得哪种方式比较好？ 当然是让系统自动工作比较好，对吧！呵呵～这就得要良好的 shell
script 来帮忙的啦！</p>

<h3 id="追踪与管理系统的重要工作">追踪与管理系统的重要工作</h3>

<p>虽然我们还没有提到服务启动的方法，不过，这里可以先提一下，我们 CentOS 6.x 以前的版本中，系统的服务 （services） 启动的接口是在
/etc/init.d/ 这个目录下，目录下的所有文件都是 scripts ； 另外，包括开机 （booting） 过程也都是利用 shell script
来帮忙搜寻系统的相关设置数据， 然后再代入各个服务的设置参数啊！举例来说，如果我们想要重新启动系统登录文件，
可以使用：“/etc/init.d/rsyslogd restart”，那个 rsyslogd 文件就是 script 啦！</p>

<p>另外，鸟哥曾经在某一代的 Fedora 上面发现，启动 MySQL 这个数据库服务时，确实是可以启动的，
但是屏幕上却老是出现“failure”！后来才发现，原来是启动 MySQL 那个 script 会主动的以“空的密码”去尝试登陆 MySQL
，但为了安全性鸟哥修改过 MySQL 的密码啰～当然就登陆失败～ 后来改了改 script ，就略去这个问题啦！如此说来， script
确实是需要学习的啊！</p>

<p>时至今日，虽然 /etc/init.d/* 这个脚本启动的方式 （systemV） 已经被新一代的 systemd 所取代 （从 CentOS 7 开始），
但是很多的个别服务在管理他们的服务启动方面，还是使用 shellscript 的机制喔！所以，最好还是能够熟悉啦！</p>

<h3 id="简单入侵侦测功能">简单入侵侦测功能</h3>

<p>当我们的系统有异状时，大多会将这些异状记录在系统记录器，也就是我们常提到的“系统登录文件”，
那么我们可以在固定的几分钟内主动的去分析系统登录文件，若察觉有问题，就立刻通报管理员，
或者是立刻加强防火墙的设置规则，如此一来，你的主机可就能够达到“自我保护”的聪明学习功能啦～ 举例来说，我们可以通过 shell script
去分析“当该封包尝试几次还是连线失败之后，就予以抵挡住该 IP”之类的举动，例如鸟哥写过一个关于抵挡砍站软件的shell script ，
就是用这个想法去达成的呢！</p>

<h3 id="连续指令单一化">连续指令单一化</h3>

<p>其实，对于新手而言， script 最简单的功能就是：“汇整一些在 command line 下达的连续指令，将他写入 scripts 当中，而由直接执行
scripts 来启动一连串的 command line 指令输入！”例如： 防火墙连续规则 （iptables），开机载入程序的项目 （就是在
/etc/rc.d/rc.local里头的数据） ，等等都是相似的功能啦！ 其实，说穿了，如果不考虑 program 的部分，那么scripts
也可以想成“仅是帮我们把一大串的指令汇整在一个文件里面， 而直接执行该文件就可以执行那一串又臭又长的指令段！”就是这么简单啦！</p>

<h3 id="简易的数据处理">简易的数据处理</h3>

<p>由前一章正则表达式的 awk 程序说明中， 你可以发现， awk 可以用来处理简单的数据数据呢！例如薪资单的处理啊等等的。 shell script
的功能更强大，例如鸟哥曾经用 shell script 直接处理数据数据的比对啊， 文字数据的处理啊等等的，撰写方便，速度又快（因为在
Linux性能较佳），真的是很不错用的啦！</p>

<p>举例来说，鸟哥每学期都得要以学生的学号来创建他们能够操作 Linux 的系统帐号，然后每个帐号还得要能够有磁盘容量的限制 （quota）
以及相关的设置等等， 那因为学校的校务系统提供的数据都是一整串学生信息，并没有单纯的学号字段，所以鸟哥就得要通过前几章的方法搭配 shell script
来自动处理相关设置流程， 这样才不会每学期都头疼一次啊！</p>

<h3 id="跨平台支持与学习历程较短">跨平台支持与学习历程较短</h3>

<p>几乎所有的 Unix Like 上面都可以跑 shell script ，连 MS Windows 系列也有相关的 script 仿真器可以用， 此外，
shell script 的语法是相当友好的，看都看的懂得文字 （虽然是英文），而不是机器码， 很容易学习～这些都是你可以加以考虑的学习点啊！</p>

<p>上面这些都是你考虑学习 shell script 的特点～此外， shell script 还可以简单的以 vim
来直接编写，实在是很方便的好东西！所以，还是建议你学习一下啦。</p>

<p>不过，虽然 shell script 号称是程序 （program） ，但实际上， shell script
处理数据的速度上是不太够的（在学习和使用shell是，应该对比下python，python的脚本也可以实现很多功能）。因为 shell script
用的是外部的指令与 bash shell 的一些默认工具，所以，他常常会去调用外部的函数库，因此，运算速度上面当然比不上传统的程序语言。 所以啰，
shellscript 用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上， 就不够好了，因为 Shell scripts 的速度较慢，且使用的
CPU 资源较多，造成主机资源的分配不良。还好，我们通常利用 shell script 来处理服务器的侦测，倒是没有进行大量运算的需求啊！所以不必担心的啦！</p>

<h2 id="2-第一支-script-的撰写与执行">2，第一支 script 的撰写与执行</h2>

<p>如同前面讲到的，shell script 其实就是纯文本文件，我们可以编辑这个文件，然后让这个文件来帮我们一次执行多个指令，
或者是利用一些运算与逻辑判断来帮我们达成某些功能。所以啦，要编辑这个文件的内容时，当然就需要具备有 bash
指令下达的相关认识。下达指令需要注意的事项在第四章的开始下达指令小节内已经提过，有疑问请自行回去翻阅。 在 shellscript
的撰写中还需要用到下面的注意事项：</p>

<p>1. 指令的执行是从上而下、从左而右的分析与执行；</p>

<p>2. 指令的下达就如同第四章内提到的： 指令、选项与参数间的多个空白都会被忽略掉；</p>

<p>3. 空白行也将被忽略掉，并且 [tab] 按键所推开的空白同样视为空白键；</p>

<p>4. 如果读取到一个 Enter 符号 （CR） ，就尝试开始执行该行 （或该串） 命令；</p>

<p>5. 至于如果一行的内容太多，则可以使用“ [Enter] ”来延伸至下一行；</p>

<p>6. “ # ”可做为注解！任何加在 # 后面的数据将全部被视为注解文字而被忽略！</p>

<p>如此一来，我们在 script 内所撰写的程序，就会被一行一行的执行。现在我们假设你写的这个程序文件名是 /home/dmtsai/shell.sh
好了，那如何执行这个文件？很简单，可以有下面几个方法：</p>

<p>直接指令下达： shell.sh 文件必须要具备可读与可执行 （rx） 的权限，然后：</p>

<p>绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；</p>

<p>相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来执行</p>

<p>变量“PATH”功能：将 shell.sh 放在 PATH 指定的目录内，例如： ~/bin/</p>

<h3 id="以-bash-程序来执行-通过-bash-shell-sh-或-sh-shell-sh-来执行">以 bash 程序来执行：通过“ bash shell.sh ”或“ sh shell.sh ”来执行</h3>

<p>反正重点就是要让那个 shell.sh 内的指令可以被执行的意思啦！ 咦！那我为何需要使用“./shell.sh
”来下达指令？忘记了吗？回去第十章内的指令搜寻顺序察看一下， 你就会知道原因了！同时，由于 CentOS 默认使用者主文件夹下的 ~/bin 目录会被设置到
${PATH} 内，所以你也可以将 shell.sh 创建在 /home/dmtsai/bin/ 下面 （~/bin 目录需要自行设置） 。此时，若
shell.sh 在 ~/bin 内且具有 rx 的权限，那就直接输入 shell.sh 即可执行该脚本程序！</p>

<p>那为何“ sh shell.sh ”也可以执行呢？这是因为 /bin/sh 其实就是 /bin/bash （ 链接文件） ，使用 sh shell.sh
亦即告诉系统，我想要直接以 bash 的功能来执行 shell.sh 这个文件内的相关指令的意思，所以此时你的 shell.sh 只要有 r
的权限即可被执行喔！而我们也可以利用 sh 的参数，如 -n 及 -x 来检查与追踪 shell.sh 的语法是否正确呢！ ^_^</p>

<h3 id="撰写第一支-script">撰写第一支 script</h3>

<p>在武侠世界中，不论是那个门派，要学武功要从扫地与蹲马步做起，那么要学程序呢？呵呵，肯定是由“秀出 Hello World！”
这个字眼开始的！OK！那么鸟哥就先写一支 script 给大家瞧一瞧：</p>

<p>[dmtsai@study ~]$ mkdir bin; cd bin</p>

<p>[dmtsai@study bin]$ vim hello.sh</p>

<p>#!/bin/bash</p>

<h1 id="program">Program:</h1>

<h1 id="this-program-shows-hello-world-in-your-screen">This program shows &ldquo;Hello World!&rdquo; in your screen.</h1>

<h1 id="history">History:</h1>

<h1 id="2015-07-16-vbird-first-release">2015/07/16 VBird First release</h1>

<p>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</p>

<p>export PATH</p>

<p>echo -e &ldquo;Hello World! \a \n&rdquo;</p>

<p>exit 0</p>

<p>在本章当中，请将所有撰写的 script 放置到你主文件夹的 ~/bin
这个目录内，未来比较好管理啦！上面的写法当中，鸟哥主要将整个程序的撰写分成数段，大致是这样：</p>

<p>1. 第一行 #!/bin/bash 在宣告这个 script 使用的 shell 名称： 因为我们使用的是 bash ，所以，必须要以“
#!/bin/bash ”来宣告这个文件内的语法使用 bash 的语法！那么当这个程序被执行时，他就能够载入 bash 的相关环境配置文件 （ 一般来说就是
non-login shell的 ~/.bashrc） ， 并且执行 bash 来使我们下面的指令能够执行！这很重要的！（
在很多状况中，如果没有设置好这一行， 那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么 shell 来执行啊！）</p>

<p>2. 程序内容的说明： 整个 script 当中，除了第一行的“ #! ”是用来宣告 shell 的之外，其他的# 都是“注解”用途！
所以上面的程序当中，第二行以下就是用来说明整个程序的基本数据。一般来说， 建议你一定要养成说明该 script 的：1. 内容与功能； 2. 版本信息；
3.作者与联络方式； 4. 创建日期；5. 历史纪录 等等。这将有助于未来程序的改写与 debug呢！</p>

<p>3. 主要环境变量的宣告： 建议务必要将一些重要的环境变量设置好，鸟哥个人认为，PATH 与 LANG （如果有使用到输出相关的信息时） 是当中最重要的！
如此一来，则可让我们这支程序在进行时，可以直接下达一些外部指令，而不必写绝对路径呢！比较方便啦！</p>

<p>4. 主要程序部分 就将主要的程序写好即可！在这个例子当中，就是 echo 那一行啦！</p>

<p>5. 执行成果告知 （定义回传值） 是否记得我们在第十章里面要讨论一个指令的执行成功与否，可以使用 $? 这个变量来观察～ 那么我们也可以利用 exit
这个指令来让程序中断，并且回传一个数值给系统。 在我们这个例子当中，鸟哥使用 exit 0 ，这代表离开 script并且回传一个 0 给系统，
所以我执行完这个 script 后，若接着下达 echo $? 则可得到 0的值喔！ 更聪明的读者应该也知道了，呵呵！利用这个 exit n （n 是数字）
的功能，我们还可以自订错误讯息， 让这支程序变得更加的 smart 呢！</p>

<p>接下来通过刚刚上头介绍的执行方法来执行看看结果吧！</p>

<p>[dmtsai@study bin]$ sh hello.sh</p>

<p>Hello World !</p>

<p>你会看到屏幕是这样，而且应该还会听到“咚”的一声，为什么呢？还记得前一章提到的 printf吧？用 echo 接着那些特殊的按键也可以发生同样的事情～
不过， echo 必须要加上 -e 的选项才行！呵呵！在你写完这个小 script 之后，你就可以大声的说：“我也会写程序了”！哈哈！很简单有趣吧～ ^_^</p>

<p>另外，你也可以利用：“chmod a+x hello.sh; ./hello.sh”来执行这个 script 的呢！（要是不加的话，会报权限不够的错误）</p>

<h2 id="3-撰写-shell-script-的良好习惯创建">3，撰写 shell script 的良好习惯创建</h2>

<p>一个良好习惯的养成是很重要的～大家在刚开始撰写程序的时候，最容易忽略这部分，
认为程序写出来就好了，其他的不重要。其实，如果程序的说明能够更清楚，那么对你自己是有很大的帮助的。</p>

<p>举例来说，鸟哥自己为了自己的需求，曾经撰写了不少的 script 来帮我进行主机 IP 的侦测啊、
登录文件分析与管理啊、自动上传下载重要配置文件啊等等的，不过，早期就是因为太懒了，
管理的主机又太多了，常常同一个程序在不同的主机上面进行更改，到最后，到底哪一支才是最新的都记不起来，
而且，重点是，我到底是改了哪里？为什么做那样的修改？都忘的一干二净～真要命～</p>

<p>所以，后来鸟哥在写程序的时候，通常会比较仔细的将程序的设计过程给他记录下来，而且还会记录一些历史纪录，
如此一来，好多了～至少很容易知道我修改了哪些数据，以及程序修改的理念与逻辑概念等等，
在维护上面是轻松很多很多的喔！（只要写程序，就要记得加上说明，为什么这么写）。</p>

<p>另外，在一些环境的设置上面，毕竟每个人的环境都不相同，为了取得较佳的执行环境， 我都会自行先定义好一些一定会被用到的环境变量，例如 PATH 这个玩意儿！
这样比较好啦～所以说，建议你一定要养成良好的 script 撰写习惯，在每个 script 的文件开始处记录好：</p>

<p>script 的功能；</p>

<p>script 的版本信息；</p>

<p>script 的作者与联络方式；</p>

<p>script 的版权宣告方式；</p>

<p>script 的 History （历史纪录）；</p>

<p>script 内较特殊的指令，使用“绝对路径”的方式来下达；</p>

<p>script 运行时需要的环境变量预先宣告与设置。</p>

<p>除了记录这些信息之外，在较为特殊的程序码部分，个人建议务必要加上注解说明，可以帮助你非常非常多！
此外，程序码的撰写最好使用巢状方式，在包覆的内部程序码最好能以[tab] 按键的空格向后推， 这样你的程序码会显的非常的漂亮与有条理！在查阅与 debug
上较为轻松愉快喔！ 另外，使用撰写 script 的工具最好使用 vim 而不是 vi ，因为 vim
会有额外的语法检验机制，能够在第一阶段撰写时就发现语法方面的问题喔！</p>

<h1 id="二-简单的-shell-script-练习">二、简单的 shell script 练习</h1>

<p>在第一支 shell script 撰写完毕之后，相信你应该具有基本的撰写功力了。接下来，在开始更深入的程序概念之前，我们先来玩一些简单的小范例好了。
下面的范例中，达成结果的方式相当的多，建议你先自行撰写看看，写完之后再与鸟哥写的内容比对， 这样才能更加深概念喔！好！不啰唆，我们就一个一个来玩吧！</p>

<h2 id="1-简单范例">1，简单范例</h2>

<p>下面的范例在很多的脚本程序中都会用到，而下面的范例又都很简单！值得参考看看喔！</p>

<h3 id="对谈式脚本-变量内容由使用者决定">对谈式脚本：变量内容由使用者决定</h3>

<p>很多时候我们需要使用者输入一些内容，好让程序可以顺利运行。 简单的来说，大家应该都有安装过软件的经验，安装的时候，他不是会问你“要安装到那个目录去”吗？
那个让使用者输入数据的动作，就是让使用者输入变量内容啦。</p>

<p>你应该还记得在十章 bash 的时候，我们有学到一个 read 指令吧？现在，请你以 read 指令的用途，撰写一个 script
，他可以让使用者输入：1. first name 与 2. last name， 最后并且在屏幕上显示：“Your full name is: ”的内容：</p>

<p>[dmtsai@study bin]$ vim showname.sh</p>

<p>#!/bin/bash</p>

<h1 id="program-1">Program:</h1>

<h1 id="user-inputs-his-first-name-and-last-name-program-shows-his-full-name">User inputs his first name and last name. Program shows his full name.</h1>

<h1 id="history-1">History:</h1>

<h1 id="2015-07-16-vbird-first-release-1">2015/07/16 VBird First release</h1>

<p>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</p>

<p>export PATH</p>

<p>read -p &ldquo;Please input your first name: &ldquo; firstname # 提示使用者输入</p>

<p>read -p &ldquo;Please input your last name: &ldquo; lastname # 提示使用者输入</p>

<p>echo -e &ldquo;\nYour full name is: ${firstname} ${lastname}&rdquo; # 结果由屏幕输出</p>

<p>将上面这个 showname.sh 执行一下，你就能够发现使用者自己输入的变量可以让程序所取用，并且将他显示到屏幕上！
接下来，如果想要制作一个每次执行都会依据不同的日期而变化结果的脚本呢？（shell编程应该还是属于函数式的编程，在处理linux服务时比较有用）</p>

<h3 id="随日期变化-利用-date-进行文件的创建">随日期变化：利用 date 进行文件的创建</h3>

<p>想像一个状况，假设我的服务器内有数据库，数据库每天的数据都不太一样，因此当我备份时，希望将每天的数据都备份成不同的文件名，
这样才能够让旧的数据也能够保存下来不被覆盖。哇！不同文件名呢！这真困扰啊？难道要我每天去修改 script ？</p>

<p>不需要啊！考虑每天的“日期”并不相同，所以我可以将文件名取成类似： backup.2015-07-16.data ，
不就可以每天一个不同文件名了吗？呵呵！确实如此。那个 2015-07-16 怎么来的？那就是重点啦！接下来出个相关的例子： 假设我想要创建三个空的文件
（通过 touch），文件名最开头由使用者输入决定，假设使用者输入 filename 好了，那今天的日期是2015/07/16 ，
我想要以前天、昨天、今天的日期来创建这些文件，亦即 filename_20150714,filename_20150715,
filename_20150716 ，该如何是好？（所以日志基本上都是文件名+月份的格式，在linux中文件名都贼长）</p>

<p>[dmtsai@study bin]$ vim create_3_filename.sh</p>

<p>#!/bin/bash</p>

<h1 id="program-2">Program:</h1>

<h1 id="program-creates-three-files-which-named-by-user-s-input-and-date-command">Program creates three files, which named by user&rsquo;s input and date command.</h1>

<h1 id="history-2">History:</h1>

<h1 id="2015-07-16-vbird-first-release-2">2015/07/16 VBird First release</h1>

<p>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</p>

<p>export PATH</p>

<h1 id="1-让使用者输入文件名称-并取得-fileuser-这个变量">1\. 让使用者输入文件名称，并取得 fileuser 这个变量；</h1>

<p>echo -e &ldquo;I will use &lsquo;touch&rsquo; command to create 3 files.&rdquo; # 纯粹显示信息</p>

<p>read -p &ldquo;Please input your filename: &ldquo; fileuser # 提示使用者输入</p>

<h1 id="2-为了避免使用者随意按-enter">2\. 为了避免使用者随意按 Enter</h1>

<p>，利用<a href="../Text/index.html#variable_other_re">变量功能</a>分析文件名是否有设置？</p>

<p>filename=${fileuser:-&ldquo;filename&rdquo;} # 开始判断有否配置文件名</p>

<h1 id="3-开始利用-date-指令来取得所需要的文件名了">3\. 开始利用 date 指令来取得所需要的文件名了；</h1>

<p>date1=$（date &ndash;date=&lsquo;2 days ago&rsquo; +%Y%m%d） # 前两天的日期</p>

<p>date2=$（date &ndash;date=&lsquo;1 days ago&rsquo; +%Y%m%d） # 前一天的日期</p>

<p>date3=$（date +%Y%m%d） # 今天的日期</p>

<p>file1=${filename}${date1} # 下面三行在配置文件名</p>

<p>file2=${filename}${date2}</p>

<p>file3=${filename}${date3}</p>

<h1 id="4-将文件名创建吧">4\. 将文件名创建吧！</h1>

<p>touch &ldquo;${file1}&rdquo; # 下面三行在创建文件</p>

<p>touch &ldquo;${file2}&rdquo;</p>

<p>touch &ldquo;${file3}</p>

<p>上面的范例鸟哥使用了很多在第十章介绍过的概念： 包括小指令“ $（command） ”的取得讯息、变量的设置功能、变量的累加以及利用 touch 指令辅助！
如果你开始执行这个create_3_filename.sh 之后，你可以进行两次执行：一次直接按 [Enter]
来查阅文件名是啥？一次可以输入一些字符，这样可以判断你的脚本是否设计正确喔！</p>

<h3 id="数值运算-简单的加减乘除">数值运算：简单的加减乘除</h3>

<p>各位看官应该还记得，我们可以使用 declare 来定义变量的类型吧？ 当变量定义成为整数后才能够进行加减运算啊！此外，我们也可以利用“ $（（计算式））
”来进行数值运算的。 可惜的是， bash shell 里头默认仅支持到整数的数据而已。OK！那我们来玩玩看，如果我们要使用者输入两个变量，
然后将两个变量的内容相乘，最后输出相乘的结果，那可以怎么做？</p>

<p>[dmtsai@study bin]$ vim multiplying.sh</p>

<p>#!/bin/bash</p>

<h1 id="program-3">Program:</h1>

<h1 id="user-inputs-2-integer-numbers-program-will-cross-these-two-numbers">User inputs 2 integer numbers; program will cross these two numbers.</h1>

<h1 id="history-3">History:</h1>

<h1 id="2015-07-16-vbird-first-release-3">2015/07/16 VBird First release</h1>

<p>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</p>

<p>export PATH</p>

<p>echo -e &ldquo;You SHOULD input 2 numbers, I will multiplying them! \n&rdquo;</p>

<p>read -p &ldquo;first number: &ldquo; firstnu</p>

<p>read -p &ldquo;second number: &ldquo; secnu</p>

<p>total=$（（${firstnu}*${secnu}））</p>

<p>echo -e &ldquo;\nThe result of ${firstnu} x ${secnu} is ==&gt; ${total}&rdquo;</p>

<p>在数值的运算上，我们可以使用“ declare -i total=${firstnu}*${secnu} ”
也可以使用上面的方式来进行！基本上，鸟哥比较建议使用这样的方式来进行运算：</p>

<p>var=$（（运算内容））</p>

<p>不但容易记忆，而且也比较方便的多，因为两个小括号内可以加上空白字符喔！ 未来你可以使用这种方式来计算的呀！至于数值运算上的处理，则有：“ +, -, ,
/, % ”等等。 那个 % 是取余数啦～举例来说， 13 对 3 取余数，结果是 13=43+1，所以余数是 1 啊！就是：</p>

<p>[dmtsai@study bin]$ echo $（（ 13 % 3 ））</p>

<p>1</p>

<p>这样了解了吧？另外，如果你想要计算含有小数点的数据时，其实可以通过 bc 这个指令的协助喔！ 例如可以这样做：</p>

<p>[dmtsai@study bin]$ echo &ldquo;123.123*55.9&rdquo; | bc</p>

<p>6882.575</p>

<p>了解了 bc 的妙用之后，来让我们测试一下如何计算 pi 这个东西呢？</p>

<h3 id="数值运算-通过-bc-计算-pi">数值运算：通过 bc 计算 pi</h3>

<p>其实计算 pi 时，小数点以下位数可以无限制的延伸下去！而 bc 有提供一个运算 pi 的函数，只是想要使用该函数必须要使用 bc -l 来调用才行。
也因为这个小数点以下位数可以无线延伸运算的特性存在，所以我们可以通过下面这只小脚本来让使用者输入一个“小数点为数值”，以让 pi 能够更准确！</p>

<p>[dmtsai@study bin]$ vim cal_pi.sh</p>

<p>#!/bin/bash</p>

<h1 id="program-4">Program:</h1>

<h1 id="user-input-a-scale-number-to-calculate-pi-number">User input a scale number to calculate pi number.</h1>

<h1 id="history-4">History:</h1>

<h1 id="2015-07-16-vbird-first-release-4">2015/07/16 VBird First release</h1>

<p>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</p>

<p>export PATH</p>

<p>echo -e &ldquo;This program will calculate pi value. \n&rdquo;</p>

<p>echo -e &ldquo;You should input a float number to calculate pi value.\n&rdquo;</p>

<p>read -p &ldquo;The scale number （10~10000） ? &ldquo; checking</p>

<p>num=${checking:-&ldquo;10&rdquo;} # 开始判断有否有输入数值</p>

<p>echo -e &ldquo;Starting calcuate pi value. Be patient.&rdquo;</p>

<p>time echo &ldquo;scale=${num}; 4*a(1)&rdquo; | bc -lq</p>

<p>上述数据中，那个 4*a（1） 是 bc 主动提供的一个计算 pi 的函数，至于 scale 就是要 bc 计算几个小数点下位数的意思。当 scale
的数值越大， 代表 pi 要被计算的越精确，当然用掉的时间就会越多！因此，你可以尝试输入不同的数值看看！不过，最好是不要超过 5000 啦！因为会算很久！
如果你要让你的 CPU 随时保持在高负载，这个程序算下去你就会知道有多操CPU 啰！ ^_^</p>

<p>Tips 鸟哥的实验室中，为了要确认虚拟机的效率问题，所以很多时候需要保持虚拟机在忙碌的状态～鸟哥的学生就是丢这只程序进去系统跑！ 但是将 scale
调高一些，那计算就得要花比较多时间～用以达到我们需要 CPU 忙碌的状态喔！</p>

<h2 id="2-script-的执行方式差异-source-sh-script-script">2,script 的执行方式差异 （source, sh script, ./script）</h2>

<p>不同的 script 执行方式会造成不一样的结果喔！尤其影响 bash 的环境很大呢！脚本的执行方式除了前面小节谈到的方式之外，还可以利用 source
或小数点 （.） 来执行喔！那么这种执行方式有何不同呢？当然是不同的啦！让我们来说说！（这一点我也一直不清楚，学习了）</p>

<h3 id="利用直接执行的方式来执行-script">利用直接执行的方式来执行 script</h3>

<p>当使用前一小节提到的直接指令下达 （不论是绝对路径/相对路径还是 ${PATH} 内），或者是利用 bash （或 sh） 来下达脚本时， 该 script
都会使用一个新的 bash 环境来执行脚本内的指令！也就是说，使用这种执行方式时， 其实 script 是在子程序的 bash 内执行的！我们在第十章
BASH 内谈到 export 的功能时，曾经就父程序/子程序谈过一些概念性的问题，
重点在于：“当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中”！这是什么意思呢？</p>

<p>我们举刚刚提到过的 showname.sh 这个脚本来说明好了，这个脚本可以让使用者自行设置两个变量，分别是 firstname 与
lastname，想一想，如果你直接执行该指令时，该指令帮你设置的 firstname 会不会生效？看一下下面的执行结果：</p>

<p>[dmtsai@study bin]$ echo ${firstname} ${lastname}</p>

<p>&lt;==确认了，这两个变量并不存在喔！</p>

<p>[dmtsai@study bin]$ sh showname.sh</p>

<p>Please input your first name: VBird &lt;==这个名字是鸟哥自己输入的</p>

<p>Please input your last name: Tsai</p>

<p>Your full name is: VBird Tsai &lt;==看吧！在 script 运行中，这两个变量有生效</p>

<p>[dmtsai@study bin]$ echo ${firstname} ${lastname}</p>

<p>&lt;==事实上，这两个变量在父程序的 bash 中还是不存在的！</p>

<p>上面的结果你应该会觉得很奇怪，怎么我已经利用 showname.sh 设置好的变量竟然在 bash环境下面无效！怎么回事呢？
如果将程序相关性绘制成图的话，我们以下图来说明。当你使用直接执行的方法来处理时，系统会给予一支新的 bash 让我们来执行 showname.sh
里面的指令，因此你的 firstname, lastname 等变量其实是在下图中的子程序 bash 内执行的。 当showname.sh
执行完毕后，子程序 bash 内的所有数据便被移除，因此上表的练习中，在父程序下面 echo ${firstname} 时，
就看不到任何东西了！这样可以理解吗？</p>

<p><a href="https://img.it610.com/image/info8/61a4be0c0521461ea49a078429220078.jpg"><img src="https://img.it610.com/image/info8/61a4be0c0521461ea49a078429220078.jpg" alt="Linux学习笔记26——什么是 Shell scripts、shell
script练习及讲解_第1张图片" /></a></p>

<h3 id="利用-source-来执行脚本-在父程序中执行">利用 source 来执行脚本：在父程序中执行</h3>

<p>如果你使用 source 来执行指令那就不一样了！同样的脚本我们来执行看看：</p>

<p>[dmtsai@study bin]$ source showname.sh</p>

<p>Please input your first name: VBird</p>

<p>Please input your last name: Tsai</p>

<p>Your full name is: VBird Tsai</p>

<p>[dmtsai@study bin]$ echo ${firstname} ${lastname}</p>

<p>VBird Tsai &lt;==嘿嘿！有数据产生喔！</p>

<p>竟然生效了！没错啊！因为 source 对 script 的执行方式可以使用下面的图示来说明！showname.sh
会在父程序中执行的，因此各项动作都会在原本的 bash 内生效！这也是为啥你不登出系统而要让某些写入 ~/.bashrc 的设置生效时，需要使用“
source ~/.bashrc ”而不能使用“ bash ~/.bashrc ”是一样的啊！</p>

<p><a href="https://img.it610.com/image/info8/ea3773c85e834696a7918587cf6f3d69.jpg"><img src="https://img.it610.com/image/info8/ea3773c85e834696a7918587cf6f3d69.jpg" alt="" /></a></p>

<h3 id="执行script">./执行script</h3>

<p>./会用你脚本中第一行的那个#!XXX的shell来执行语句，而sh 则是用sh来执行语句还有一种可能就是./确定了文件路径，而sh
一定要在scipt所在目录</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>