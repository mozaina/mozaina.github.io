<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell编程之条件判断与流程控制 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell编程之条件判断与流程控制 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell编程之条件判断与流程控制">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell编程之条件判断与流程控制</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>一、条件判断式语句</p>

<p>1-1.概述</p>

<p>用来判断是与否，客观的而非主观判断，用于进行基本的管理</p>

<p>1-2.按文件类型判断</p>

<p>补充：</p>

<p>&amp;&amp; 命令1&amp;&amp;命令2 逻辑与（没有数据传递）<br />
当命令1正确执行，则命令2才会执行<br />
当命令1执行不正确，则命令2不会执行</p>

<p>|| 命令1||命令2 逻辑或（没有数据传递）<br />
当命令1执行不正确时，命令2才会执行<br />
当命令1正确执行时，命令2不会执行</p>

<p>按文件类型判断</p>

<h1 id="记住蓝色部分">记住蓝色部分</h1>

<p>两种判断格式：</p>

<p>test –e /root/install.log<br />
[-e /root/install.log]; e:exist<br />
[-d /root] &amp;&amp; echo “yes” || echo “no”</p>

<h1 id="第一个判断命令如果正确执行-则打印-yes-否则打印-no">第一个判断命令如果正确执行，则打印“yes”，否则打印“no”</h1>

<h1 id="注意linux中0表示命令成功-1-表示命令失败-区别于python中对象为空数字为0代表假-非0非空代表真">注意Linux中0表示命令成功；1，表示命令失败，区别于Python中对象为空数字为0代表假，非0非空代表真。</h1>

<p>例子：</p>

<p>[root@localhost ~]# ls</p>

<p>anaconda-ks.cfg install.log …</p>

<p>[root@localhost ~]# [-e /root/install.log]</p>

<p>[root@localhost ~]# echo $?</p>

<p>0</p>

<p>[root@localhost ~]# [-e /root/install,login] | echo $?</p>

<p>[root@localhost ~]# 1</p>

<p>[root@localhost ~]# [-e /root/install.log] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<p>[root@localhost ~]# [-e /root/install.log] &amp;&amp; echo yes || echo no</p>

<p>no</p>

<h1 id="其实上面是if的单分支语句-注意顺序不可以变化-如果no执行了那么yes也会出现-毕竟正确执行了">其实上面是if的单分支语句,注意顺序不可以变化，如果no执行了那么yes也会出现，毕竟正确执行了</h1>

<p>1-3.按文件权限判断</p>

<p>按文件权限进行判断</p>

<p>例子：[-w student.txt] &amp;&amp; echo “yse” || echo “no”</p>

<h1 id="判断文件是否拥有写权限">判断文件是否拥有写权限</h1>

<p>[root@localhost ~]# ll</p>

<p>总用量 52</p>

<p>-rw-r—r—.1 root root 7690 8月 14 16：34 install.log</p>

<p>…</p>

<p>[root@localhost ~]# [-w install.log] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<h1 id="不会判断是所有者有写权限还是所属者有写权限还是其他人有写权限-当然-我们可以用字符截取三个位置的权限分布情况进行分析">不会判断是所有者有写权限还是所属者有写权限还是其他人有写权限，当然，我们可以用字符截取三个位置的权限分布情况进行分析</h1>

<p>1-4.两个文件之间的比较</p>

<p>测试选项<br />
作用</p>

<p>文件1 –nt 文件2<br />
判断文件1的修改时间是否比文件2的新（如果新则返回真）n，new；t，time<br />
文件1 –ot 文件2<br />
判断文件1的修改时间是否比文件2的旧（如果旧则返回真）o，old；t，time<br />
文件1 –ef 文件2<br />
判断文件1是否和文件2的inode号一直，可以理解为两个文件判断是否属于同一个文件，用于判断硬链接的很好的方法,s</p>

<h1 id="因为硬链接的inode号一致-软链接不一样">因为硬链接的inode号一致，软链接不一样</h1>

<p>[root@localhost ~]# ln /root/student.txt /tmp/stu</p>

<p>[root@localhost ~]# [/root/student.txt –ef /tmp/stu] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<p>[root@localhost ~]# ll –i</p>

<p>262154 -rw-r—r—.2 root root 60 8月 14 16:50 student.txt</p>

<p>[root@localhost ~]# ll –i /tmp/stu</p>

<p>262154 –rw-r—r—.2 root root 60 8月 14 16：50 /tmp/stu</p>

<h1 id="源文件和链接文件的inode是一样的">源文件和链接文件的inode是一样的</h1>

<p>.硬链接特征：<br />
1、拥有相同的i节点和存储block块（一般4KB一个block），可以看做是同一个文件<br />
相当于一个存储文件的不同的获取入口，镜像一样存储double份<br />
2、只能对已经存在的文件进行创建<br />
3、不能跨分区 ，不能交叉文件系统进行硬链接的创建<br />
4、不能针对目录使用，只能针对文件创建</p>

<p>5、删除一个硬链接文件不影响其它有相同inode号的文件</p>

<p>.软链接特征：<br />
1、类似windows快捷方式，方便打开<br />
2、软链接拥有自己的i节点和block块，但是数据块中保存原文件的文件名和i节点号，并没有实际的文件数据，而是原文件的i节点和block块<br />
3、lrwxrwxrwx |软链接<br />
软链接文件权限都为rwxrwxrwx，查看软链接文件的权限，区别于原文件<br />
4、修改任意文件，另一个都改变<br />
5、删除原文件，软链接不能使用<br />
限制少，而且灵活</p>

<p>1-5.两个整数之间比较</p>

<p>测试选项<br />
作用</p>

<p>整数1 –eq 整数2<br />
判断整数1是否和整数2相等（相等为真）<br />
整数1 –ne 整数2<br />
判断整数1是否和整数2不相等（不相等为真）<br />
整数1–gt 整数2<br />
判断整数1是否大于整数2（大于为真）<br />
整数1 –lt 整数2<br />
判断整数1是否小于整数2（小于为真）<br />
整数1 –ge 整数2<br />
判断整数1是否大于等于整数2（大于等于为真）<br />
整数1 –le 整数2<br />
判断整数1是否小于等于整数2（小于等于为真）</p>

<p>例子：</p>

<p>[root@localhost ~]# [23 –ge 22] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<h1 id="判断23是否大于等于22">判断23是否大于等于22</h1>

<p>[root@localhost ~]# [23 –le 22] &amp;&amp; echo yes || echo no</p>

<p>no</p>

<h1 id="判断23是否小于等于22-no">判断23是否小于等于22，no</h1>

<p>1-6.字符串的判断</p>

<p>测试选项<br />
作用</p>

<p>-z 字符串<br />
判断字符串是否为空（为空返回真）<br />
-n 字符串<br />
判断字符串是否为空（非空返回真）Null<br />
字符串1 == 字符串2<br />
判断字符串1是否和字符串2相等（相等返回真）<br />
字符串1 ！= 字符串2<br />
判断字符串1是否和字符串2不想等（不想等返回真）</p>

<p>例子：</p>

<p>1）.判断字符串是否为空</p>

<p>[root@localhost ~]# name=fengj</p>

<p>[root@localhost ~]# [-z $name] &amp;&amp; echo yes || echo no</p>

<p>no</p>

<h1 id="不为空">不为空</h1>

<p>[root@localhost ~]# name=””</p>

<p>[root@localhost ~]# [-z $name] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<h1 id="为空">为空</h1>

<p>2）.判断字符串是否相等</p>

<p>[root@localhost ~]# aa=11</p>

<p>[root@localhost ~]# bb=22</p>

<p>[root@localhost ~]# [“ aa”==” bb”] &amp;&amp; echo yes || echo no</p>

<p>no</p>

<p>[root@localhost ~]# [“ aa”eq” bb”] &amp;&amp; echo yes || echo no</p>

<p>no</p>

<p>[root@localhost ~]# aa=22</p>

<p>[root@localhost ~]# [“ aa”==” bb”] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<p>[root@localhost ~]# [“ aa”eq” bb”] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<h1 id="判断两个变量的值是否相等-不想等返回假-记得字符串加上双引号-aa-没加可能出现错误">判断两个变量的值是否相等，不想等返回假，记得字符串加上双引号“$aa”,没加可能出现错误</h1>

<p>1-7.多重条件的判断</p>

<p>测试选项<br />
作用</p>

<p>判断1 –a 判断2<br />
逻辑与，判断1和判断2都成立，最终结果才为真；and<br />
判断1 –o 判断2<br />
逻辑或，判断1和判断2只要有一个为真，最终结果就为真；or<br />
！判断<br />
逻辑非，是原始的判断式取反</p>

<p>例子1：</p>

<p>[root@localhost ~]# aa=11</p>

<p>[root@localhost ~]# [-n “ aa”−a“ aa”-gt 23] &amp;&amp; echo yes || echo no</p>

<p>no</p>

<h1 id="n-aa-判断aa是否为空">-n “$aa”：判断aa是否为空</h1>

<h1 id="gt-ss-判断aa的值是否大于23">-gt “$ss”：判断aa的值是否大于23</h1>

<h1 id="a-逻辑与-因为aa-23-为假-所以结果也为假">-a：逻辑与，因为aa&lt;23，为假，所以结果也为假</h1>

<p>[root@localhost ~]# [-n “ aa”−a“ aa”-gt 2] &amp;&amp; echo yes || echo no</p>

<p>yes</p>

<p>二、单分支if语句</p>

<p>2-1.概述</p>

<p>Shell的语法结构不同于一些常见的语言</p>

<p>1）.目的:</p>

<p>掌握语法结构</p>

<p>了解Shell的作用</p>

<p>分析编程思想</p>

<p>2）.建立编程思想的方法：</p>

<p>熟悉Linux基本命令、规范、语法及Shell语法</p>

<p>实际与所学相互结合，了解每个程序的思路，也就是编程思想</p>

<p>具体方式：</p>

<p>抄写程序并正确运行</p>

<p>为程序打上注释</p>

<p>删除注释，为代码重新加注释</p>

<p>看注释写代码</p>

<p>删除代码程序，从头开始写</p>

<p>2-2.单分支if语句</p>

<p>格式：<br />
if [条件判断式]；then</p>

<pre><code>  程序
</code></pre>

<p>fi</p>

<pre><code>  或者
</code></pre>

<p>if [条件判断式]</p>

<pre><code> then

 程序
</code></pre>

<p>fi</p>

<h1 id="fi来标识结束-finish">fi来标识结束，finish</h1>

<p>解释：</p>

<p>if语句使用fi结尾，和一般的语言使用大括号结尾不同</p>

<p>[条件判断式]就是使用test命令判断，所以中括号和条件判断式之间必须有空格</p>

<p>then后面跟符合条件之后执行的程序，可以放在中括号[]之后，用分号”；”分割，也可以换行写入，就不需要分号“；”了</p>

<p>1）.例子1：判断登录用户是否是root</p>

<h1 id="bin-bash">！/bin/bash</h1>

<p>test=$(env | grep “USER”| cut –d “=”-f2)</p>

<p>if [ “$test” == root ]</p>

<pre><code>      then

      echo “Current user is root.”
</code></pre>

<p>fi</p>

<p>[root@localhost ~]# ls</p>

<p>anaconda-ks.cfg sh ….</p>

<p>[root@localhost ~]# cd sh/</p>

<p>[root@localhost sh]# ls</p>

<p>b1.sh hello.sh read.sh</p>

<p>[root@localhost sh]# whoami</p>

<p>root</p>

<p>[root@localhost sh]# vi if_1.sh</p>

<h1 id="bin-bash-1">！/bin/bash</h1>

<p>test=$(env | grep “USER”| cut –d “=”-f2) #提取env环境变量中USER的值</p>

<h1 id="注意-在shell编程中可以先输出结果测试后在接下来完成剩下的代码-如这里可以先">注意，在shell编程中可以先输出结果测试后在接下来完成剩下的代码，如这里可以先</h1>

<h1 id="echo-test">echo $test</h1>

<p>if [ “$test” == root ] #如果所提取的test值==root</p>

<pre><code>      then

      echo “Current user is root.”#返回用户比较结果
</code></pre>

<p>fi</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 if_1.sh</p>

<p>[root@localhost sh]# ./if_1.sh</p>

<p>Current user is root</p>

<h1 id="查看环境变量-截取到user-然后进行行提取-接下来根据-号进行列提取">查看环境变量，截取到USER，然后进行行提取，接下来根据=号进行列提取</h1>

<h1 id="补充-管道符-命令1-命令2-命令1的结果作为命令2的输入项">补充：|，管道符，命令1 | 命令2，命令1的结果作为命令2的输入项</h1>

<p>2）.例子2：判断分区使用率</p>

<h1 id="bin-bash-2">!/bin/bash</h1>

<h1 id="统计分区使用率">统计分区使用率</h1>

<p>rate=(df –h | grep “/dev/sda3”| awk ‘{print5}’| cut –d “%”-f1)</p>

<h1 id="把根分区使用率作为变量值赋予rate">把根分区使用率作为变量值赋予rate</h1>

<h1 id="df-h-显示分区情况">df -h：显示分区情况</h1>

<h1 id="grep-dev-sda3-提取行-dev-sda3">grep “/dev/sda3”提取行/dev/sda3</h1>

<h1 id="awk-print-5-把行-dev-sda3第五列5数据提取出来">awk ‘{print 5}’:把行/dev/sda3第五列5数据提取出来</h1>

<h1 id="cut-d-f1-使用cut-提取-前第一列的数字">cut –d “%”-f1：使用cut 提取“%”前第一列的数字</h1>

<h1 id="以上提取出来的就是分区使用率-赋值给rate">以上提取出来的就是分区使用率，赋值给rate</h1>

<p>if [ “$rate” –ge 80 ]</p>

<pre><code>    then

    echo “Warning! /dev/sda3 will full soon”
</code></pre>

<p>fi</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# df –h</p>

<p>文件系统 容量 已用 可用 已用% 挂载点</p>

<p>/dev/sda5 18G 1.8G 15G 11% /</p>

<p>tmpfs 504M 0 504M 0% /dev/shm</p>

<p>/dev/sda1 194M 26M 158M 15% /boot</p>

<p>/dev/sda2 2.0G 35M 1.8G 2% /home</p>

<h1 id="h-human-人性化显示">h:human，人性化显示</h1>

<p>[root@localhost sh]# df –h | grep /</p>

<p>/dev/sda5 18G 1.8G 15G 11% /</p>

<p>tmpfs 504M 0 504M 0% /dev/shm</p>

<p>/dev/sda1 194M 26M 158M 15% /boot</p>

<p>/dev/sda2 2.0G 35M 1.8G 2% /home</p>

<p>[root@localhost sh]# df –h | grep /dev/sda5</p>

<p>/dev/sda5 18G 1.8G 15G 11% /</p>

<p>[root@localhost sh]# df –h | grep /dev/sda5 | awk ‘{print $5}’</p>

<p>11%</p>

<p>[root@localhost sh]# df –h | grep /dev/sda5 | awk ‘{print $5}’| cut –d “%” –f
1</p>

<p>11</p>

<p>[root@localhost sh]# vi if_2.sh</p>

<h1 id="bin-bash-3">!/bin/bash</h1>

<h1 id="统计分区使用率-1">统计分区使用率</h1>

<p>rate=(df –h | grep “/dev/sda5”| awk ‘{print5}’| cut –d “%”-f1)</p>

<p>if [ “$rate” –ge 10 ]</p>

<pre><code>    then

    echo “Warning! /dev/sda5 will full soon”
</code></pre>

<p>fi</p>

<p>~</p>

<p>[root@localhost sh]# chmod 755 if_2.sh</p>

<p>[root@localhost sh]# ./if_2.sh</p>

<p>Warning! /dev/sda5 will full soon</p>

<p>三、双分支if语句</p>

<p>格式：<br />
if [ 条件判断式 ]</p>

<pre><code>   then

    条件成立时，执行的程序

   else

    条件不成立时，执行的程序
</code></pre>

<p>fi</p>

<p>补充：<br />
接收键盘输入</p>

<p>read [选项] [变量名]</p>

<p>选项：</p>

<pre><code>  -p ”提示信息“：在等待read输入的时候，输出提示信息

  -t 秒数 ：read命令会一直等待用户输入，使用此选项可以指定等待时间

  -n 字符数：read 命令只接收指定的字符数，就会执行

  -s ：隐藏输入的数据，适用于机密信息的输入
</code></pre>

<p>1.判断输入的是否是同一个目录</p>

<h1 id="bin-bash-4">！/bin/bash</h1>

<h1 id="判断输入的文件是否是一个目录">判断输入的文件是否是一个目录</h1>

<p>read –t 30 –p “Please input a directory:” dir</p>

<h1 id="read-读取">read：读取</h1>

<h1 id="t-30-等待20秒">-t 30 ：等待20秒</h1>

<h1 id="p-输出一个提示信息-please-input-a-directory">-p ：输出一个提示信息“Please input a directory”</h1>

<h1 id="dir-赋给变量dir">dir：赋给变量dir</h1>

<p>if [ –d “$dir”] #-d：判断文件是否存在，并且是否为目录文件（是目录则为真）</p>

<pre><code>     then 

             echo “yes” #是目录

     else

              echo  “no” #不是目录
</code></pre>

<p>fi</p>

<p>[root@localhost sh]# vi if_3.sh</p>

<h1 id="bin-bash-5">！/bin/bash</h1>

<p>read –t 30 –p “Please input a directory:” dir</p>

<p>if [ –d “$dir”]</p>

<pre><code>     then 

             echo “yes”

     else

              echo  “no”
</code></pre>

<p>fi</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 if_3.sh</p>

<p>[root@localhost sh]# ./if_3.sh</p>

<p>Please input a directory: /root</p>

<p>yes</p>

<p>[root@localhost sh]# ./if_3.sh</p>

<p>Please input a directory: sda110</p>

<p>no</p>

<p>2.判断Apache服务是否启动</p>

<p>apache,web服务</p>

<p>运维平台：美工+程序+数据库+web服务+系统环境Linux+服务器+域名+IP+网络+…</p>

<p>Netcraft：网站信息统计</p>

<p>[root@localhost ~]# ps aux</p>

<h1 id="查看系统所有正在运行的应用和服务">查看系统所有正在运行的应用和服务</h1>

<p>[root@localhost ~]# ps aux | grep httpd</p>

<p>root 6369 0.0 0.3 11188 3316 ? Ss 17:52 0:00 /usr/sbin/httpd</p>

<p>…</p>

<p>apache 6372 0.0 0.2 11188 2080 ? S 17:52 0:00 /usr/sbin/httpd</p>

<p>root 6564 0.0 0.0 5960 740 pts/0 s+ 17:52 0:00 grep –color=auto httpd</p>

<p>[root@localhost ~]# service httpd stop</p>

<p>停止 httpd： [确定]</p>

<p>[root@localhost ~]# ps aux | grep httpd</p>

<p>root 6564 0.0 0.0 5960 740 pts/0 s+ 17:52 0:00 grep –color=auto httpd</p>

<p>[root@localhost ~]#</p>

<h1 id="依旧包含了httpd相关的grep命令-我们可以取反">依旧包含了httpd相关的grep命令，我们可以取反</h1>

<p>[root@localhost ~]# service httpd start</p>

<p>正在启动httpd: httpd: Could not reliably datermine the server’s fully qualified
domain name, using ::1 for ServerName [确定]</p>

<p>[root@localhost ~]# ps aux | grep httpd | grep –v grep</p>

<p>root 6369 0.0 0.3 11188 3316 ? Ss 17:52 0:00 /usr/sbin/httpd</p>

<p>…</p>

<p>apache 6372 0.0 0.2 11188 2080 ? S 17:52 0:00 /usr/sbin/httpd</p>

<h1 id="没有了grep相关的httpd服务了">没有了grep相关的httpd服务了</h1>

<p>脚本代码：</p>

<h1 id="bin-bash-6">！/bin/bash</h1>

<p>tesh =$(ps aux | grep httpd | grep –v grep)</p>

<h1 id="截取httpd进程-并把结果赋予变量test">截取httpd进程，并把结果赋予变量test</h1>

<p>if [ –n “$test” ]#如果test的值不为空，则执行then中命令</p>

<h1 id="n-字符串-判断字符串是否为空">-n 字符串，判断字符串是否为空</h1>

<pre><code>        then

              echo “$(date) httpd is ok!”&gt;&gt; /tmp/autostart-acc.log

        else

               /etc/rc.d/init.d/httpd start &amp;&gt;/dev/null
</code></pre>

<h1 id="etc-rc-d-init-d-httpd-start-apache标准启动命令">/etc/rc.d/init.d/httpd start ：apache标准启动命令</h1>

<h1 id="输出重定向-把输出结果不论正确错误输出到指定目录或者文件">&amp;&gt; :输出重定向，把输出结果不论正确错误输出到指定目录或者文件</h1>

<pre><code>              echo “$(date) restart httpd!!”&gt;&gt; /tmp/autostart-err.log
</code></pre>

<p>fi</p>

<p>补充：</p>

<p>输出重定向：<br />
类型 符号 作用<br />
标准输出重定向 命令&gt;文件 以覆盖的方式，把命令的正确输出输出到的文件或设备当中<br />
命令&gt;&gt;文件 以追加的方式，把命令的正确输出输出到指定的文件或设备当中<br />
标准错误输出重定向 错误命令2&gt;文件 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中<br />
错误命令2&gt;&gt;文件 以追加的方式，把命令的错误输出输出到指定的文件或设备当中<br />
正确输出和错误输出 命令&gt;文件 2&gt;&amp;1 以覆盖的方式，把命令的正确和错误输出输出 同时保存到指定的文件当中<br />
命令&gt;&gt;文件 2&gt;&amp;1 以追加的方式，把命令的正确和错误输出输出到指定的文件当中<br />
命令&amp;&gt;文件 以覆盖的方式，把正确输出和错误输出都保存在同一个文件当中<br />
命令&amp;&gt;&gt;文件 以追加的方式，把命令的正确和错误输出输出到指定的文件当中<br />
命令&gt;&gt;文件1 2&gt;&gt;文件2 以追加的方式，把命令的正确输出保存到文件1，把错误的输出保存到文件2</p>

<pre><code>   通过输出重定向，把输出结果保存起来，可以实现无人值守
</code></pre>

<p>[root@localhost sh]# vi if_4.sh</p>

<h1 id="bin-bash-7">！/bin/bash</h1>

<p>tesh =$(ps aux | grep httpd | grep –v grep)</p>

<h1 id="截取httpd进程-并把结果赋予变量test-1">截取httpd进程，并把结果赋予变量test</h1>

<p>if [ –n “$test” ]#如果test的值不为空，则执行then中命令</p>

<h1 id="n-字符串-判断字符串是否为空-1">-n 字符串，判断字符串是否为空</h1>

<pre><code>        then

              echo “$(date) httpd is ok!”&gt;&gt; /tmp/autostart-acc.log

        else

               /etc/rc.d/init.d/httpd start &amp;&gt;/dev/null
</code></pre>

<h1 id="etc-rc-d-init-d-httpd-start-apache标准启动命令-1">/etc/rc.d/init.d/httpd start ：apache标准启动命令</h1>

<h1 id="输出重定向-把输出结果不论正确错误输出到指定目录或者文件-1">&amp;&gt; :输出重定向，把输出结果不论正确错误输出到指定目录或者文件</h1>

<pre><code>              echo “$(date) restart httpd!!”&gt;&gt; /tmp/autostart-err.log
</code></pre>

<p>fi</p>

<p>~wq</p>

<p>[root@localhost sh]# chmod 755 if_4.sh</p>

<p>[root@localhost sh]# ./if_4.sh</p>

<p>18:53 httpd is ok!</p>

<p>[root@localhost sh]# service httpd stop</p>

<p>[root@localhost sh]# ./if_4.sh</p>

<p>18:54 restart httpd!!</p>

<p>正在启动httpd: httpd: Could not reliably datermine the server’s fully qualified
domain name, using ::1 for ServerName [确定]</p>

<h1 id="在apache2-4版本之后启动基本都会报错-只是不认识主机名-但其实仍然启动了">在apache2.4版本之后启动基本都会报错，只是不认识主机名，但其实仍然启动了</h1>

<p>[root@localhost sh]# ./if_4.sh</p>

<p>18:54 httpd is ok!</p>

<h1 id="我们可以把脚本加入到linux的用户计划-让ta自动运行">我们可以把脚本加入到linux的用户计划，让ta自动运行</h1>

<p>缺陷：<br />
如果你把if_4.sh改成了httpd_if_4.sh之后会发现即使关闭了服务，仍然会提示：“httpd is ok！”</p>

<p>[root@localhost sh]# mv if_4.sh httpd_if_4.sh</p>

<p>[root@localhost sh]# ./httpd_if_4.sh</p>

<p>httpd is ok</p>

<p>[root@localhost sh]# service is stop</p>

<p>停止 httpd： [确定]</p>

<p>[root@localhost ~]# ps aux | grep httpd | grep –v grep</p>

<p>root 6369 0.0 0.3 11188 3316 ? Ss 17:52 0:00 /usr/sbin/httpd</p>

<p>…</p>

<p>apache 6372 0.0 0.2 11188 2080 ? S 17:52 0:00 /usr/sbin/httpd</p>

<p>[root@localhost sh]# ./httpd_if_4.sh</p>

<p>httpd is ok</p>

<h1 id="关闭服务依旧显示ok-所以要避免命名时不要带有httpd">关闭服务依旧显示ok，所以要避免命名时不要带有httpd</h1>

<p>改进：根据端口来判断服务是否启动<br />
四、多分支if语句</p>

<p>格式：<br />
if [ 条件判断式1 ]</p>

<pre><code>       then

                  当条件判断式1成立时，执行程序1
</code></pre>

<p>elif [ 条件判断式2 ]</p>

<pre><code>        then

                  当条件判断式2成立时，执行程序2
</code></pre>

<p>…更多条件判断式与程序…</p>

<p>else</p>

<pre><code>         所有条件都不成立是，执行这部分
</code></pre>

<p>fi</p>

<p>1.简介</p>

<p>单分支只有一个判断，然后就直接运行了；双分支有一个符合条件的分支和一个不满足的情况；多分支有多个条件以及对应的程序。</p>

<p>2.实例：计算器</p>

<p>进行数值运算：</p>

<p>1.有没有输入内容</p>

<p>2.是不是数值</p>

<p>3.什么运算，是什么运算符（加减乘除）</p>

<p>4.执行运算操作</p>

<p>代码：</p>

<h1 id="bin-bash-8">!/bin/bash</h1>

<h1 id="字符界面加减乘除计算器">字符界面加减乘除计算器</h1>

<p>read – t 30 –p “Please input num1:”num1</p>

<p>read –t 30 –p “Please input num2:”num2</p>

<h1 id="通过read命令接收要计算的数值-并赋予num1和num2">通过read命令接收要计算的数值，并赋予num1和num2</h1>

<p>read –t 30 –p “Please input a operator:”ope</p>

<h1 id="通过read命令接收要计算的符号-并赋予ope-进行接下来的运算准备">通过read命令接收要计算的符号，并赋予ope，进行接下来的运算准备</h1>

<p>if [ –n “ num1”–a–n“ num2”-a –n “$ope” ]</p>

<h1 id="n-判断字符串是否为空-非空返回真">-n:判断字符串是否为空，非空返回真</h1>

<h1 id="a-逻辑与and-判断1和判断2都成立-最终结果才为真">-a ：逻辑与and，判断1和判断2都成立，最终结果才为真</h1>

<h1 id="第一次判断-判断num1和num2以及ope是否有值">第一次判断，判断num1和num2以及ope是否有值</h1>

<pre><code>           then

           test1=$(echo $num1 | sed‘s/[0-9]//g’)

           test2=$(echo $num2 | sed ‘s/[0-9]//g’)
</code></pre>

<h1 id="定义变量test1和test2的值为-命令-的结果">定义变量test1和test2的值为$(命令)的结果</h1>

<h1 id="后续命令作用-把变来那个test1的值替换为空-吐过能够替换为空-证明num1的值为数字">后续命令作用，把变来那个test1的值替换为空，吐过能够替换为空，证明num1的值为数字</h1>

<h1 id="如果不能替换为空-证明num1-num2的值非数字-我们使用这种方法判断变量num1-num2的值">如果不能替换为空，证明num1，num2的值非数字，我们使用这种方法判断变量num1，num2的值</h1>

<pre><code>            if  [ –z “$test1” –a –z “$test2”]
</code></pre>

<h1 id="第二层判断-用来判断num1和num2是否为数值">第二层判断，用来判断num1和num2是否为数值</h1>

<h1 id="如果变量test1和test2的值为空-则证明num1和num2是数字">如果变量test1和test2的值为空，则证明num1和num2是数字</h1>

<pre><code>            then

             #如果test1和test2是数字，则执行以下命令

                          if [ “$ope” == ‘+‘ ]

                          #第三层判断用来确认运算符

                                      then

                                             sum = $(( $num1 + $num2))

                                              #如果是加号则执行加法程序

                           elif [ “$ope” == ‘-’]

                                      then 

                                                sum = $(( $num1 – $num2))

                                                #如果是减号则执行减法程序

                           elif [ “$ope” == ‘*’]

                                      then 

                                                sum = $(( $num1 * $num2))

                                                #如果是减号则执行乘法程序

                           elif [ “$ope” == ‘/’]

                                      then 

                                                sum = $(( $num1 / $num2))

                                                #如果是减号则执行除法程序

                            else

                                        echo “Please enter a valid symbol”

                                               #如果运算符不匹配，提示输入有效的符号

                                        exit 10

                                        #并退出程序，返回错误代码10

                             fi

            else

            #如果test1和test2不是数值

                     echo “Please enter a valid value”

                     #则提示输入和法的值

                     exit 11

                     #退出并返回错误代码11
</code></pre>

<p>else</p>

<pre><code>         echo “Please input num”

         exit 12
</code></pre>

<p>fi</p>

<p>详细执行：<br />
[root@localhost ~]# cd sh</p>

<p>[root@localhost sh]# vi if_5.sh</p>

<h1 id="bin-bash-9">!/bin/bash</h1>

<h1 id="字符界面加减乘除计算器-1">字符界面加减乘除计算器</h1>

<p>read – t 30 –p “Please input num1:”num1</p>

<p>read –t 30 –p “Please input num2:”num2</p>

<h1 id="通过read命令接收要计算的数值-并赋予num1和num2-1">通过read命令接收要计算的数值，并赋予num1和num2</h1>

<p>read –t 30 –p “Please input a operator:”ope</p>

<h1 id="通过read命令接收要计算的符号-并赋予ope-进行接下来的运算准备-1">通过read命令接收要计算的符号，并赋予ope，进行接下来的运算准备</h1>

<p>if [ –n “ num1”–a–n“ num2”-a –n “$ope” ]</p>

<pre><code>           then

           test1=$(echo $num1 | sed‘s/[0-9]//g’)

           test2=$(echo $num2 | sed ‘s/[0-9]//g’)

            if  [ –z “$test1” –a –z “$test2”]

            then

             #如果test1和test2是数字，则执行以下命令

                          if [ “$ope” == ‘+‘ ]

                          #第三层判断用来确认运算符

                                      then

                                             sum = $(( $num1 + $num2))

                                              #如果是加号则执行加法程序

                           elif [ “$ope” == ‘-’]

                                      then 

                                                sum = $(( $num1 – $num2))

                                                #如果是减号则执行减法程序

                           elif [ “$ope” == ‘*’]

                                      then 

                                                sum = $(( $num1 * $num2))

                                                #如果是减号则执行乘法程序

                           elif [ “$ope” == ‘/’]

                                      then 

                                                sum = $(( $num1 / $num2))

                                                #如果是减号则执行除法程序

                            else

                                        echo “Please enter a valid symbol”

                                               #如果运算符不匹配，提示输入有效的符号

                                        exit 10

                                        #并退出程序，返回错误代码10

                             fi

            else

            #如果test1和test2不是数值

                     echo “Please enter a valid value”

                     #则提示输入和法的值

                     exit 11

                     #退出并返回错误代码11
</code></pre>

<p>else</p>

<pre><code>         echo “Please input num”

         exit 12
</code></pre>

<p>fi</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 if_5.sh</p>

<p>[root@localhost sh]# ./if_5.sh</p>

<p>Please input num1:</p>

<p>Please input num2:</p>

<p>Please input a operator: *</p>

<p>Please input num</p>

<p>[root@localhost sh]# echo $?</p>

<p>12</p>

<p>[root@localhost sh]# ./if_5.sh</p>

<p>Please input num1: 7</p>

<p>Please input num2: 8</p>

<p>Please input a operator: *</p>

<p>7 * 8 = 56</p>

<p>3.实例：判断用户输入的是什么文件</p>

<p>代码：</p>

<h1 id="bin-bash-10">!/bin/bash</h1>

<h1 id="判断用户输入的是什么文件">判断用户输入的是什么文件</h1>

<p>read –p “Please input a filename :”file</p>

<h1 id="接收键盘的输入-并赋予变量file">接收键盘的输入，并赋予变量file</h1>

<p>if [ –z “$file” ]</p>

<h1 id="判断file是否为空-z-判断字符串是否为空">判断file是否为空，-z：判断字符串是否为空</h1>

<pre><code>  then 

          echo “Error,please input a filename”

          exit 1

   elif [ ! –e “$file” ]
</code></pre>

<h1 id="判断file的值是否存在-e-判断该文件是否存在">判断file的值是否存在,-e：判断该文件是否存在</h1>

<pre><code>            then

                       echo “Your input is not a file!”

                       exit 2

    elif [ –f “$file” ]
</code></pre>

<h1 id="判断file的值是否为普通文件-f-判断该文件是否存在-并且是否是普通文件">判断file的值是否为普通文件，-f：判断该文件是否存在，并且是否是普通文件</h1>

<pre><code>            then

                        echo “File is a regulare file!”

     elif [ –d “$file” ] 
</code></pre>

<h1 id="判断file的值是否是目录文件-d-判断文件是否存在-并且是否是目录文件">判断file的值是否是目录文件，-d ： 判断文件是否存在，并且是否是目录文件</h1>

<pre><code>             then

                         echo “File is a directory!”

     else

                       echo ”File is an other file!”
</code></pre>

<p>fi</p>

<p>具体实现：<br />
[root@localhost sh]# vi if_6.sh</p>

<h1 id="bin-bash-11">!/bin/bash</h1>

<h1 id="判断用户输入的是什么文件-1">判断用户输入的是什么文件</h1>

<p>read –p “Please input a filename :”file</p>

<h1 id="接收键盘的输入-并赋予变量file-1">接收键盘的输入，并赋予变量file</h1>

<p>if [ –z “$file” ]</p>

<h1 id="判断file是否为空-z-判断字符串是否为空-1">判断file是否为空，-z：判断字符串是否为空</h1>

<pre><code>  then 

          echo “Error,please input a filename”

          exit 1

   elif [ ! –e “$file” ]
</code></pre>

<h1 id="判断file的值是否存在-e-判断该文件是否存在-1">判断file的值是否存在,-e：判断该文件是否存在</h1>

<pre><code>            then

                       echo “Your input is not a file!”

                       exit 2

    elif [ –f “$file” ]
</code></pre>

<h1 id="判断file的值是否为普通文件-f-判断该文件是否存在-并且是否是普通文件-1">判断file的值是否为普通文件，-f：判断该文件是否存在，并且是否是普通文件</h1>

<pre><code>            then

                        echo “File is a regulare file!”

     elif [ –d “$file” ] 
</code></pre>

<h1 id="判断file的值是否是目录文件-d-判断文件是否存在-并且是否是目录文件-1">判断file的值是否是目录文件，-d ： 判断文件是否存在，并且是否是目录文件</h1>

<pre><code>             then

                         echo “File is a directory!”

     else

                       echo ”File is an other file!”
</code></pre>

<p>fi</p>

<p>~</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 if_6.sh</p>

<p>[root@localhost sh]# ./if_6.sh</p>

<p>Please input a filename :</p>

<p>Error,please input a filename</p>

<p>[root@localhost sh]# echo $?</p>

<p>1</p>

<p>[root@localhost sh]# ./if_6.sh</p>

<p>Please input a filename : sdaaaa</p>

<p>Your input is not a file!</p>

<p>[root@localhost sh]# ./if_6.sh</p>

<p>Please input a filename : /root</p>

<p>/root File is a directory!</p>

<p>[root@localhost sh]# ./if_6.sh</p>

<p>Please input a filename : /root/sh/if_6.sh</p>

<p>/root/sh/if_6.sh File is a regulare file!</p>

<p>[root@localhost sh]# ./if_6.sh</p>

<p>Please input a filename : /dev/sda1</p>

<p>/dev/sda1 File is an other file!</p>

<p>五、多分支case语句</p>

<p>case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if可以判断多种条件关系</p>

<p>格式：<br />
case $变量名 in</p>

<pre><code>      “值1”)

            如果变量的值等于值1，则执行程序1

            ;;

      “值2”)

            如果变量的值等于值2，则执行程序2

             ;;
</code></pre>

<p>…省略其他分支…</p>

<pre><code>         *)

             如果变量的值都不是以上的值，则执行此程序
</code></pre>

<p>;;</p>

<p>esac</p>

<h1 id="注意-分号不要忘了-还有结尾是easc">注意：分号不要忘了，还有结尾是easc，</h1>

<p>具体事例：<br />
[root@localhost ~]# cd sh</p>

<p>[root@localhost sh]# vi case.sh</p>

<h1 id="bin-bash-12">!/bin/bash</h1>

<p>read –t 30 –p “Please input your choose:Yes/No” cho</p>

<p>case “$cho” in</p>

<pre><code>        “Yes”)

                    echo “Your choose is Yes”

           ;;

        “yes”)

                    echo “Your choose is Yes”

           ;;

        “no”)

                    echo “Your choose is No”

           ;;

         “No”)

                     echo “Your choose is No”

            ;;

             *)

                      echo “Error input”      

             ;;
</code></pre>

<p>esac</p>

<p>~</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 case.sh</p>

<p>[root@localhost sh]# ./case.sh</p>

<p>Please input your choose:Yes/No Yes</p>

<p>Your choose is Yes</p>

<p>[root@localhost sh]# ./case.sh</p>

<p>Please input your choose:Yes/No yes</p>

<p>Your choose is Yes</p>

<p>[root@localhost sh]# ./case.sh</p>

<p>Please input your choose:Yes/No No</p>

<p>Your choose is No</p>

<p>[root@localhost sh]# ./case.sh</p>

<p>Please input your choose:Yes/No no</p>

<p>Your choose is No</p>

<p>[root@localhost sh]# ./case.sh</p>

<p>Please input your choose:Yes/No 123</p>

<p>Error choose</p>

<h1 id="运行速度快-主要用于一些直接的选择-类似于abcd-1234-地名之类可以确定的值">运行速度快，主要用于一些直接的选择，类似于ABCD，1234，地名之类可以确定的值</h1>

<p>六、for循环</p>

<p>重复型循环重要语句</p>

<p>格式：<br />
for 变量 in 值1 值2 值3</p>

<pre><code>     do

           程序

     done
</code></pre>

<p>例子1：</p>

<p>[root@localhost sh]# vi for_1.sh</p>

<h1 id="bin-bash-13">!/bin/bash</h1>

<p>for i in 1 2 3 4 5</p>

<pre><code>    do

           echo “$i”

     done
</code></pre>

<p>~</p>

<p>例子2：批量解压缩脚本</p>

<p>补充：<br />
压缩命令<br />
常用压缩格式： .zip .gz .bz2 .tar.gz .tar.bz2<br />
.rar压缩率高</p>

<p>（1）.zip格式压缩<br />
.zip压缩文件名 源文件<br />
#压缩文件<br />
.zip -r 压缩文件名 源目录<br />
#压缩目录<br />
[root@localhost ~]# ls<br />
anaconda-ks.cfg install.log install.log.syslog longzls<br />
[root@localhost ~]# zip longzls.zip longzls(空文件，所以压缩0%)<br />
adding: longzls (stored 0%)<br />
[root@localhost ~]# ls<br />
anaconda-ks.cfg install.log install.log.syslog longzls longzls.zip<br />
[root@localhost ~]#<br />
注意：后缀不能缺少，不是因为系统原因，毕竟linux不区分后缀名，但是为了方便管理员管理不应该缺少<br />
压缩文件是有个压缩格式的存储，如果源文件比较小，会发现压缩后文件反而更大，但是当你的压缩文件很大的时候，就会有比较好的效果<br />
[root@localhost ~]# mkdir jp<br />
[root@localhost ~]# ls<br />
anaconda-ks.cfg install.log install.log.syslog jp longzls longzls.zip<br />
[root@localhost ~]# touch jp/cangls<br />
[root@localhost ~]# touch jp/longls<br />
[root@localhost ~]# touch jp/bols<br />
[root@localhost ~]# zip -r jp.zip jp<br />
（2）.zip格式解压缩<br />
unzip压缩文件<br />
#解压缩.zip文件<br />
[root@localhost ~]# unzip jp.zip<br />
（3）.gz格式压缩<br />
1）.gzip 源文件<br />
#压缩为.gz格式的压缩文件，源文件会消失<br />
[root@localhost ~]# ls<br />
anaconda-ks.cfg install.log install.log.syslog jp longzls<br />
[root@localhost ~]# gzip longzls<br />
[root@localhost ~]# ls<br />
anaconda-ks.cfg install.log install.log.syslog jp longzls.gz<br />
2）.gzip -c 源文件 &gt; 压缩文件<br />
#-c是将文件内容输出，通过&gt;指向输出位置，实现压缩，原文件也没有消失，如果没有目标，那么将直接输出到屏幕上,源文件消失<br />
#压缩为.gz格式，原文件保留<br />
例如：<br />
gzip -c cangls &gt; cangls.gz<br />
3）. gzip -r 目录<br />
#压缩目录下所有的子文件，但是不能压缩目录<br />
补充：.gz可以在windows中解压缩，但是.rar在linux不可以解压缩<br />
[root@localhost ~]# gzip -r jp<br />
[root@localhost ~]# ls<br />
abc abc.gz anaconda-ks.cfg install.log install.long.syslog jp longzls.gz<br />
[root@localhost ~]# cd jp/<br />
[root@localhost jp]# ls<br />
bols.gz cangls.gz longls.gz<br />
压缩了目录下的子文件，但是没有压缩目录<br />
（4）.gz格式解压缩<br />
gzip -d 压缩文件<br />
#解压缩文件<br />
gunzip 压缩文件<br />
#解压缩文件<br />
解压缩后，压缩文件会消失，源文件出现，而且解压缩目录时候同样不能缺少-r，即<br />
gunzip -r 压缩文件<br />
（5）.bz2格式压缩<br />
bzip2 源文件<br />
#压缩为.bz2格式，不保留源文件<br />
但是：bzip2 -k 源文件 （keep保留）<br />
#压缩之后保留源文件<br />
注意：bzip2命令不能压缩目录<br />
（6）.bz2格式解压缩<br />
bzip2 -d 压缩文件<br />
#解压缩，-k保留压缩文件<br />
bunzip2 压缩文件<br />
#解压缩，-k保留压缩文件<br />
注意：bunzip2同样不能解压缩目录<br />
（7）.tar.gz，tar.bz2压缩格式<br />
tar打包，先打包，再压缩<br />
tar -cvf 打包文件名 源文件<br />
选项：<br />
-c:打包<br />
-v:显示过程<br />
-f:指定打包后的文件名<br />
-t: test测试，不解压只查看<br />
例如：<br />
tar -cvf longzls.tar longzls<br />
[root@localhost ~]# tar -cvf jp.tar jp<br />
jp/<br />
jp/bols<br />
jp/longls<br />
jp/cangls<br />
[root@localhost ~]# gzip jp.tar<br />
[root@localhost ~]# ls<br />
abc abc.gz anaconda-ks.cfg install.log install.long.syslog jp jp.tar.gz<br />
通过tar和gzip实现目录的压缩<br />
tar.gz压缩格式：<br />
其实.tar.gz格式是先打包为.tar格式，再压缩为.gz格式<br />
tar -zcvf 压缩包名 .tar.gz 源文件<br />
选项：<br />
-z：压缩为.tar.gz格式</p>

<pre><code> tar -zxvf 压缩包名 .tar.gz 
 选项： 
     -x： 解压缩.tar.gz格式

 tar.bz2压缩格式： 
</code></pre>

<p>同样.tar.bz2格式也是先打包为.tar格式，再压缩为.bz2格式<br />
tar -jcvf 压缩包名 .tar.bz2 源文件<br />
选项：<br />
-j：压缩为.tar.bz2格式</p>

<pre><code>  tar -jxvf 压缩包名 .tar.bz2 
 选项： 
     -x： 解压缩.tar.bz2格式 
</code></pre>

<p>注意前后压缩解压缩的格式一致性，不然会出错<br />
（8）.tar.gz，tar.bz2解压缩命令<br />
tar –xvf 压缩包名.tar.gz/压缩包名.tar.bz2<br />
选项：<br />
-x：解包<br />
-v：显示过程<br />
-f：指定打包后的文件<br />
-t: test测试，不解压只查看</p>

<h1 id="bin-bash-14">！/bin/bash</h1>

<p>cd /root/test</p>

<p>ls *.tar.gz &gt; ls.log</p>

<p>ls *.tgz &gt; ls.log</p>

<h1 id="覆盖-追加">&gt;覆盖，&gt;&gt;追加</h1>

<h1 id="列举出所有的压缩包-重定向到ls-log">列举出所有的压缩包，重定向到ls.log</h1>

<p>for i in $(cat ls.log)</p>

<pre><code>    do

              tar –zxf $i $&gt; /dev/null
</code></pre>

<h1 id="dev-null-所有的输出情况都不关注">/dev/null：所有的输出情况都不关注</h1>

<pre><code>    done
</code></pre>

<p>rm –rf /lamp/ls.log</p>

<h1 id="删除临时文件">删除临时文件</h1>

<p>[root@localhost sh]# cd /root/test</p>

<p>[root@localhost tset]# ls</p>

<p>etc.tar.gz Python-3.4.3.tgz tmp.tar.gz</p>

<p>[root@localhost tset]# vi tar.sh</p>

<h1 id="bin-bash-15">！/bin/bash</h1>

<p>cd /root/test</p>

<p>ls *.tar.gz &gt; ls.log</p>

<p>ls *.tgz &gt;&gt; ls.log</p>

<p>for i in $(cat ls.log)</p>

<pre><code>      do

              tar –zxf  $i  &amp;&gt; /dev/null

       done
</code></pre>

<p>rm –rf /lamp/ls.log</p>

<p>~</p>

<p>[root@localhost tset]# chmod 755 tar.sh</p>

<p>[root@localhost tset]# ./tar.sh</p>

<p>[root@localhost tset]# ls</p>

<p>etc etc.tar.gz Python-3.4.3 Python-3.4.3.tgz tar_for.sh tmp tmp.tar.gz</p>

<h1 id="解压缩成功">解压缩成功</h1>

<p>格式2：<br />
for (( 初始值；循环控制条件；变量变化 ))</p>

<pre><code>     do

             程序

     done
</code></pre>

<p>例子3：1+2+…+100：</p>

<h1 id="bin-bash-16">！/bin/bash</h1>

<h1 id="计算从1加到100">计算从1加到100</h1>

<p>s=0</p>

<p>for (( i=1;i&lt;=100;i=i+1 ))</p>

<pre><code>      do

               s=$(( $s+$i ))
</code></pre>

<h1 id="把s和i的数值按循环来依次叠加">把s和i的数值按循环来依次叠加</h1>

<pre><code>     done
</code></pre>

<p>echo “The sum of 1+2+..+100 is: $s”</p>

<h1 id="详细过程">详细过程：</h1>

<p>[root@localhost tset]# cd /root/sh/</p>

<p>[root@localhost sh]# vi for_sum.sh</p>

<h1 id="bin-bash-17">!/bin/bash</h1>

<p>s=0</p>

<p>for (( i=1;i&lt;=100;i=i+1 ))</p>

<pre><code>      do

                 s=$(( $s+$i ))

     done
</code></pre>

<p>echo “$s”</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 for_sum.sh</p>

<p>[root@localhost sh]# ./for_sum.sh</p>

<p>5050</p>

<p>例子4：批量添加指定数量的用户</p>

<h1 id="bin-bash-18">！/bin/bash</h1>

<h1 id="批量添加到指定数量的用户">批量添加到指定数量的用户</h1>

<p>read –p “Please input user name:” –t 30 name</p>

<h1 id="输入用户名-保存到name">输入用户名，保存到name</h1>

<p>read –p “Please input the number of users:” –t 30 num</p>

<h1 id="输入用户数量-保存到num">输入用户数量，保存到num</h1>

<p>read –p “Please input the password of users:” –t 30 pass</p>

<h1 id="输入密码-保存到pass">输入密码，保存到pass</h1>

<p>if [ ! –z “ name”–a!–z“ num” –a ! –z “$pass” ]</p>

<h1 id="原始判断式取反-z-判断字符串是否为空-a-逻辑与and-全为真结果才为真">！：原始判断式取反；-z：判断字符串是否为空；-a：逻辑与and，全为真结果才为真</h1>

<h1 id="即判断这三个结果不为空">即判断这三个结果不为空</h1>

<pre><code>      then

      y=$(echo $num | sed ‘s/[0-9]’)
</code></pre>

<h1 id="判断num是否为纯数字-是则输出空值">判断num是否为纯数字，是则输出空值，</h1>

<pre><code>       if[ –z “$y”]

              then

              for (( i=1;i&lt;=$num;i=i+1 ))

                     do

                             /usr/sbin/useradd $name$i &amp;&gt;/dev/null

                             echo $pass | /usr/bin/passwd - -stdin $name$i &amp;&gt;/dev/null
</code></pre>

<h1 id="给name用户赋予pass密码">给name用户赋予pass密码</h1>

<pre><code>                    done

       fi
</code></pre>

<p>fi</p>

<p>[root@localhost sh]# vi useradd.sh</p>

<h1 id="bin-bash-19">！/bin/bash</h1>

<p>read –p “Please input user name:” –t 30 name</p>

<p>read –p “Please input the number of users:” –t 30 num</p>

<p>read –p “Please input the password of users:” –t 30 pass</p>

<p>if [ ! –z “ name”–a!–z“ num” –a ! –z “$pass” ]</p>

<pre><code>      then

      y=$(echo $num | sed ‘s/[0-9]’)

       if[ –z “$y”]

              then

              for (( i=1;i&lt;=$num;i=i+1 ))

                     do

                             /usr/sbin/useradd $name$i &amp;&gt;/dev/null

                             echo $pass | /usr/bin/passwd - -stdin $name$i &amp;&gt;/dev/null

                    done

       fi
</code></pre>

<p>fi</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# cat /etc/passwd</p>

<h1 id="查看用户">查看用户</h1>

<p>[root@localhost sh]# chmod 755 useradd.sh</p>

<p>[root@localhost sh]# ./useradd.sh</p>

<p>Please input user name: DukeZ</p>

<p>Please input the number of users: 10</p>

<p>Please input the password of users: 123456</p>

<p>[root@localhost sh]# cat /etc/passwd</p>

<p>…</p>

<p>DukeZ1 :x: 520:520:: /home/DukeZ1: /bin/bash</p>

<p>..</p>

<p>DukeZ10 :x: 520:520:: /home/DukeZ10: /bin/bash</p>

<p>思考：批量删除用户<br />
提取出所用用户的用户名，通过登录用户bash来区分登录用户和伪用户</p>

<p>[root@localhost sh]# cat /etc/passwd | grep /bin/bash | grep –v root | cut –d
“:”-f1</p>

<p>[root@localhost sh]# vi userdel.sh</p>

<h1 id="bin-bash-20">!/bin/bash</h1>

<p>user=$( cat /etc/passwd | grep /bin/bash | grep –v root |cut –d “:” -f1)</p>

<p>for i in $user</p>

<pre><code>   do

          userdel –f  $i

   done
</code></pre>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 userdel.sh</p>

<p>[root@localhost sh]# ./userdel,sh</p>

<p>[root@localhost sh]# cat /etc/passwd</p>

<h1 id="删除dukez1-dukez10成功">删除DukeZ1-DukeZ10成功</h1>

<p>七、while循环和until循环</p>

<p>有if，case，for，怎么可以少了while，until</p>

<p>1.while循环</p>

<p>while循环是不定循环，也称条件循环，只要条件判断式成立，循环就会一直继续，条件没有设置好就容易出现死循环，直到条件判断式不成立，循环就会终止，这和for的固定循环不太一样</p>

<p>格式：<br />
while [ 条件判断式 ]</p>

<pre><code>  do

         程序

  done
</code></pre>

<p>详细实例：从1加到100</p>

<h1 id="bin-bash-21">!/bin/bash</h1>

<p>i=1</p>

<p>s=0</p>

<p>while [ $i –le 100]</p>

<h1 id="如果变量i的值小于100-则执行循环">如果变量i的值小于100，则执行循环</h1>

<pre><code>         do

                 s=$(( $s+$i ))

                 i=$(( $i+1 ))

          done
</code></pre>

<p>echo “The sum is : $s”</p>

<p>2.until循环</p>

<p>until循环，和while循环相反，until循环时只要条件判断式不成立就进行循环，并执行循环程序。一弹循环条件成立，则终止循环</p>

<p>格式：<br />
until [ 条件判断式 ]</p>

<pre><code>  do

         程序

  done
</code></pre>

<p>详细实例：从1加到100</p>

<h1 id="bin-bash-22">!/bin/bash</h1>

<p>i=1</p>

<p>s=0</p>

<p>while [ $i –gt 100]</p>

<h1 id="如果变量i的值大于于100-则终止循环">如果变量i的值大于于100，则终止循环</h1>

<pre><code>         do

                 s=$(( $s+$i ))

                 i=$(( $i+1 ))

          done
</code></pre>

<p>echo “The sum is : $s”</p>

<p>[root@localhost sh]# vi until.sh</p>

<h1 id="bin-bash-23">!/bin/bash</h1>

<p>i=1</p>

<p>s=0</p>

<p>while [ $i –le 100]</p>

<pre><code>         do

                 s=$(( $s+$i ))

                 i=$(( $i+1 ))

          done
</code></pre>

<p>echo “The sum is : $s”</p>

<p>~</p>

<p>wq</p>

<p>[root@localhost sh]# chmod 755 until.sh</p>

<p>[root@localhost sh]# ./until.sh</p>

<p>The sum is : 5050</p>

<p>八、总结</p>

<p>注意Shell主要是用来简化管理员操作的，考虑的更多的是功能的实现，而不是代码语法和算法的复杂</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>