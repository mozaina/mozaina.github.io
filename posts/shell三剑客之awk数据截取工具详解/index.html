<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>shell三剑客之awk数据截取工具详解 | 开发者问答集锦</title>
    <meta property="og:title" content="shell三剑客之awk数据截取工具详解 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="shell三剑客之awk数据截取工具详解">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bawk%E6%95%B0%E6%8D%AE%E6%88%AA%E5%8F%96%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">shell三剑客之awk数据截取工具详解</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p><strong>目录</strong></p>

<h1 id="awk-数据截取工具">awk 数据截取工具</h1>

<p>①awk简介</p>

<p>②awk语法结构</p>

<p>OPTIONS</p>

<p>PROGRAM</p>

<p>pattern</p>

<p>action</p>

<p>③变量</p>

<p>④流程控制</p>

<p>⑤数组</p>

<p>⑥内建函数</p>

<hr />

<p>#</p>

<h1 id="①-awk-简介"><strong>①</strong> <strong>awk</strong> <strong>简介</strong></h1>

<blockquote>
<blockquote>
<blockquote>
<p>awk是一种编程语言（解释性语言，不需要编译）， <strong>用于数据截取和报告的工具</strong></p>

<p>awk自动搜索输入的文件，并把每个输入行切分成多个字段（字段：根据分隔符分割成的单元）</p>

<p>擅长处理数据库和表型数据。适合编写短小一次性程序</p>

<p>centos默认的awk使用的是gawk，系统将awk通过软链接来指向gawk</p>

<p>可以使用新的内置函数和变量</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>&gt; &gt;&gt;</strong> <strong>在缺省的情况下，它使用扩展的正则表达式</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>awk不需要声明变量的数据类型，它内置字符串类型和数值类型</p>
</blockquote>
</blockquote>
</blockquote>

<hr />

<h1 id="②-awk-语法结构"><strong>②</strong> <strong>awk</strong> <strong>语法结构</strong></h1>

<h2 id="awk-options-program-filename-list"><strong>awk [OPTIONS] [&ndash;] program filename_list</strong></h2>

<p><strong>一个案例理解</strong> <strong>awk</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>date文件第一列为员工名字，第二列为时薪，第三列为工作时长</p>

<p>需求：打印输出时薪大于等于50，的员工名字和总薪资</p>
</blockquote>
</blockquote>
</blockquote>

<pre><code>[bei@localhost test]$ cat date

Sam 50 8

Bei 55 7

Tom 48 9

Tim 80 8

[bei@localhost test]$ awk '$2 &gt;= 50 { print $1,$2*$3 }' date

Sam 400

Bei 385

Tim 640
</code></pre>

<p><strong>说明：</strong> <strong>awk</strong> <strong>命令后面的程序用单引号引起来，单引号后面的部分为输入文件</strong></p>

<p><strong>单引号中包围的内容是一个</strong> <strong>awk</strong> <strong>程序，是一个</strong> <strong>program</strong> <strong>即模式</strong> <strong>-</strong> <strong>动作语句（</strong>
<strong>pattern-action</strong> <strong>）</strong></p>

<p><strong>其中模式</strong> <strong>pattern</strong> <strong>为</strong> <strong>&rsquo;$2 &gt;=50&rsquo;</strong> <strong>，表示扫描每一个输入的行，如果第二列大于</strong> <strong>0</strong>
<strong>，则执行动作</strong> <strong>action</strong> <strong>，否则不执行</strong> <strong>action</strong></p>

<p><strong>动作</strong> <strong>action</strong> <strong>为</strong> <strong>&rsquo;{ print $1,$2*$3 }&lsquo;,</strong>
<strong>模式匹配成功后执行的对应动作，该动作用于打印输出第一个字段和第二、三字段的乘积</strong></p>

<h2 id="options"><strong>OPTIONS</strong></h2>

<p><strong>选项</strong></p>

<p>|</p>

<p><strong>描述</strong></p>

<p>&mdash;|&mdash;</p>

<p><strong>-V</strong></p>

<p>|</p>

<p>显示awk的版本</p>

<p><strong>-f program-file</strong></p>

<p>|</p>

<p>指定包含了awk命令的文件，不是从命令行参数中去读取<br />
可以通过-f选项指定多个包含awk命令文件</p>

<p><strong>-F</strong> <strong>&lsquo;</strong> <strong>fs&rsquo;</strong></p>

<p><strong>--field-separator</strong></p>

<p>|</p>

<p><strong>指定分隔符</strong> <strong>即为定义</strong> <strong>FS</strong> <strong>变量对应的值</strong></p>

<p><strong>-v var=val</strong></p>

<p>|</p>

<p>在程序开始之前，将val这个值赋给var这个变量</p>

<p><strong>-d[file]</strong></p>

<p>|</p>

<p>将全局变量的类型和最终值排序，并将排序好后的结果打印输出到文件中</p>

<h2 id="program-pattern-action-awk-的核心"><strong>PROGRAM</strong> <strong>——</strong> <strong>&lsquo;</strong> <strong>pattern{ action }</strong> <strong>&lsquo;</strong> <strong>（</strong> <strong>awk</strong> <strong>的核心）</strong></h2>

<p><strong>关于</strong> <strong>pattern { action }</strong> <strong>的说明：</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>pattern与action并非同时存在，可以省略其中一个</p>

<p>如果action被省略，默认动作是将每个匹配的行输出</p>

<p>如果pattern被省略，对于每行都会执行动作</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>awk</strong> <strong>基本操作流程：</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>从输入流中读取一行内容，然后使用pattern{action}去处理</p>

<p>对读取的行进行扫描搜索，搜索行中是否有内容被pattern匹配</p>

<p>如果行被pattern匹配成功，则执行动作{action}</p>
</blockquote>
</blockquote>
</blockquote>

<p>如果行中内容不被pattern匹配，则不输出</p>

<blockquote>
<blockquote>
<blockquote>
<p>继续从输入流中读取新的一行，重复上述几个步骤</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="pattern"><strong>pattern</strong></h3>

<p><strong>&gt; &gt;&gt;</strong>pattern，即模式，是决定awk程序中定义的动作action是否能够被执行的关键</p>

<p><strong>&gt; &gt;&gt;</strong> <strong>pattern</strong> <strong>支持的规则：</strong> 正则表达式，字符串与数字比较，流程控制语句</p>

<p><strong>模式表示方式汇总：</strong></p>

<p><strong>BEGIN</strong></p>

<p><strong>END</strong></p>

<p><strong>/</strong> <strong>regexp</strong> <strong>/</strong></p>

<p><strong>relational expression</strong> ：</p>

<p><strong>pattern &amp;&amp; pattern</strong></p>

<p><strong>pattern || pattern</strong></p>

<p><strong>BEGIN</strong> ：放在程序开头，当awk从输入流中读取数据之前，BEGIN语句开始执行（初始化）</p>

<p>常见用法：改变分隔符 （FS、OFS、ORS）</p>

<p>可以执行多个BEGIN，按顺序执行，多个END同样适用</p>

<p><strong>END</strong> ：放在程序末尾，当所有输入流被读取完毕，END语句开始执行（扫尾）</p>

<p><strong>&gt; &gt;&gt;</strong> <strong>案例</strong></p>

<pre><code>[bei@localhost test]$ cat date
Sam 50 8
Bei 55 7
Tom 48 9
Tim 80 8
[bei@localhost test]$ awk 'BEGIN{OFS=&quot;:&quot;;ORS=&quot;\n\n&quot;} BEGIN{print &quot;name:total_salary&quot;} {print $1,$2*$3}' date
name:total_salary

Sam:400

Bei:385

Tom:432

Tim:640
</code></pre>

<p><strong>说明：</strong> 第一个BEGIN是对输出字段分隔符OFS和输出记录分隔符ORS的赋值</p>

<p>第二个BEGIN语句是输出字符串 &ldquo;name:total_salary&rdquo;</p>

<p>执行完BEGIN后，awk再从输入流中读取处理数据</p>

<p><strong>正则之字符串匹配模式</strong> <strong>/regexp/</strong> <strong>（使用的是拓展的正则表达式）</strong></p>

<p><strong>&gt; &gt;&gt;</strong> <strong>/regexp/</strong></p>

<p><strong>当前输入行包含能被</strong> <strong>regexp</strong> <strong>匹配的子字符串时，该模式被匹配</strong></p>

<p><strong>&gt; &gt;&gt;</strong> <strong>expression ~ /regexpr/</strong></p>

<p><strong>允许正则表达式限定在记录中的特定字段</strong></p>

<p><strong>例如</strong> <strong>$1</strong> <strong>~ /regexp/</strong> <strong>只匹配第一个字段符合表达式的记录，若</strong> <strong>$1</strong> <strong>匹配</strong> <strong>/regexp/</strong>
<strong>，则模式被匹配</strong></p>

<p><strong>&gt; &gt;&gt;</strong> <strong>expression !~ /regexpr/</strong></p>

<p><strong>若</strong> <strong>expression</strong> <strong>不包含</strong> <strong>regexp</strong> <strong>字符，则模式被匹配</strong></p>

<p><strong>模式表达式</strong> <strong>relational expression</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>当表达式拥有一个数值形式的值，运算符要求一个字符串值，则awk会将该数值自动转换成字符串</p>

<p>当表达式拥有一个字符串形式的值，运算符要求一个数值，则awk会将该字符串值自动转换成数值</p>

<p>关于表达式真与假的说明：如果一个表达式，对当前述入行的求值结果非零或不为空，那么该行就被匹配</p>

<p>如果比较字符串，比较时是逐字符依赖ASCII字符表比较</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>比较运算符汇总</strong></p>

<p><strong>运算符</strong></p>

<p>|</p>

<p><strong>描述</strong></p>

<p>&mdash;|&mdash;</p>

<p><strong>&lt;</strong></p>

<p>|</p>

<p><strong>小于</strong></p>

<p><strong>&lt; =</strong></p>

<p>|</p>

<p><strong>小于等于</strong></p>

<p><strong>==</strong></p>

<p>|</p>

<p><strong>等于</strong></p>

<p><strong>!=</strong></p>

<p>|</p>

<p><strong>不等于</strong></p>

<p><strong>&gt;</strong></p>

<p>|</p>

<p><strong>大于</strong></p>

<p><strong>&gt; =</strong></p>

<p>|</p>

<p><strong>大于等于</strong></p>

<p><strong>~</strong></p>

<p>|</p>

<p><strong>匹配</strong></p>

<p><strong>!~</strong></p>

<p>|</p>

<p><strong>不匹配</strong></p>

<p><strong>表达式运算符汇总（也可以用在</strong> <strong>action</strong> <strong>）</strong></p>

<p><strong>操作</strong></p>

<p>|</p>

<p><strong>运算符</strong></p>

<p>|</p>

<p><strong>例子</strong></p>

<p>&mdash;|&mdash;|&mdash;</p>

<p><strong>赋值</strong></p>

<p>|</p>

<p><strong>=</strong> <strong>、</strong> <strong>+=</strong> <strong>、</strong> <strong>-=</strong> <strong>、</strong> *<strong>=</strong> <strong>、</strong> <strong>/=</strong> <strong>、</strong> <strong>^=</strong></p>

<p>|</p>

<p>sum+=i 即sum=sum+i</p>

<p><strong>条件表达式</strong></p>

<p>|</p>

<p><strong>？</strong> <strong>:</strong></p>

<p>|</p>

<p><strong>x?y:z</strong> <strong>若</strong> <strong>x</strong> <strong>为真则为</strong> <strong>y</strong> <strong>，否则为</strong> <strong>z</strong></p>

<p><strong>逻辑或</strong></p>

<p>|</p>

<p><strong>||</strong></p>

<p>|</p>

<p>x||y 若x或y为真，则表达式为真</p>

<p><strong>逻辑与</strong></p>

<p>|</p>

<p><strong>&amp; &amp;</strong></p>

<p>|</p>

<p>x&amp;&amp;y 若x与y都为真，则表达式为真</p>

<p><strong>数组成员</strong></p>

<p>|</p>

<p><strong>in</strong></p>

<p>|</p>

<p>i in a</p>

<p><strong>匹配</strong></p>

<p><strong>不匹配</strong></p>

<p>|</p>

<p><strong>~</strong></p>

<p><strong>！</strong> <strong>~</strong></p>

<p>|</p>

<p><strong>自增自减</strong></p>

<p>|</p>

<p><strong>++</strong> <strong>、</strong> <strong>--</strong></p>

<p>|</p>

<p><strong>字段</strong></p>

<p>|</p>

<p><strong>$</strong></p>

<p>|</p>

<p>$1 表示输入行的第一个字段</p>

<p><strong>组合</strong></p>

<p>|</p>

<p><strong>( )</strong></p>

<p>|</p>

<p>($2+1) 表示第三个字段</p>

<p><strong>复合模式</strong></p>

<p><strong>&gt; &gt;&gt;</strong> <strong>通过（）括号、</strong> <strong>||</strong> <strong>或、</strong> <strong>&amp; &amp;</strong> <strong>与、！非</strong> <strong>组合</strong></p>

<p><strong>pattern &amp;&amp; pattern</strong></p>

<p><strong>pattern || pattern</strong></p>

<p><strong>需求：输出</strong> <strong>txt</strong> <strong>第一和二个字段都为数字或第三和四个字段都为字母的行</strong></p>

<pre><code>[bei@localhost test]$ cat txt
1 2 1 2
2 3 2 a
3 2 a b
4 a b d
a b 1 2
[bei@localhost test]$ awk '($1~/[0-9]/&amp;&amp;$2~/[0-9]/)||($3~/[a-zA-Z]/&amp;&amp;$4~/[a-zA-Z]/){print $0}' txt
1 2 1 2
2 3 2 a
3 2 a b
4 a b d
</code></pre>

<p>说明：$1~/[0-9]/与$2~/[0-9]/之间和$3~/[a-zA-Z]/与$4~/[a-zA-Z]之间是与的关系</p>

<p>($1~/[0-9]/&amp;&amp;$2~/[0-9]/)和($3~/[a-zA-Z]/&amp;&amp;$4~/[a-zA-Z]/)之间是或的关系</p>

<h3 id="action"><strong>action</strong></h3>

<p><strong>格式化输出</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>在print语句中，多个变量之间使用逗号作为分隔符，对变量进行分隔</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>案例</strong></p>

<pre><code>[bei@localhost test]$ cat awk.txt
Beth 3.00 0
Susie 4.50 40
Bei 4.00 50
Dan 4.00 50
[bei@localhost test]$ cat awk.txt | awk '{print $1,$2}'
Beth 3.00
Susie 4.50
Bei 4.00
Dan 4.00
&gt;&gt;&gt;NF（number of field）表示字段数，$NF表示最后一个字段
[bei@localhost test]$ awk '{print NF,$1,$NF}' awk.txt    
3 Beth 0
3 Susie 40
3 Bei 50
3 Dan 50
</code></pre>

<p><strong>&gt; &gt;&gt;</strong> <strong>awk</strong> <strong>提供了一个内建变量</strong> <strong>NR</strong> <strong>（</strong> <strong>number of row</strong>
<strong>），该变量用于记录当前从输入流中读取的行的</strong> <strong>行号</strong></p>

<p><strong>需求：输出时在每一行行首加上行号</strong></p>

<pre><code>[bei@localhost test]$ awk '{print NR,$0}' awk.txt     
1 Beth 3.00 0
2 Susie 4.50 40
3 Bei 4.00 50
4 Dan 4.00 50
</code></pre>

<p><strong>#</strong> <strong>可以将字符串放在字段中的任意位置</strong></p>

<pre><code>[bei@localhost test]$ awk '{print （&quot;The line_number is&quot;,NR,$0）}' awk.txt
The line_number is 1 Beth 3.00 0
The line_number is 2 Susie 4.50 40
The line_number is 3 Bei 4.00 50
The line_number is 4 Dan 4.00 50
</code></pre>

<p><strong>&gt; &gt;&gt;</strong> <strong>awk</strong> <strong>分隔符：</strong> <strong>FS</strong> <strong>变量、</strong> <strong>OFS</strong> <strong>变量和</strong> <strong>ORS</strong> <strong>变量</strong></p>

<p><strong>FS</strong> <strong>（</strong> <strong>Field Separator</strong> <strong>）字段分隔符，即读取输入流时，以</strong> <strong>FS</strong>
<strong>作为字段分隔的依据，默认情况下为一个空格符</strong></p>

<p><strong>OFS</strong> <strong>（</strong> <strong>Output Field Separator</strong> <strong>）输出字段分隔符，默认情况下为一个空格符</strong></p>

<p><strong>ORS</strong> <strong>（</strong> <strong>Output Record Separator</strong> <strong>）输出记录分隔符，默认情况下为一个换行符</strong></p>

<p>#需求：print输出/etc/passwd的第一列和最后一列，字段之间用冒号隔开，每一行之间还有一个空行</p>

<pre><code>[bei@localhost test]$ awk 'BEGIN{FS=&quot;:&quot;;OFS=&quot;:&quot;;ORS=&quot;\n\n&quot;}{print $1,$NF}' /etc/passwd
root:/bin/bash

bin:/sbin/nologin

daemon:/sbin/nologin

adm:/sbin/nologin

……
</code></pre>

<p><strong>注意：对变量</strong> <strong>FS</strong> <strong>、</strong> <strong>OFS</strong> <strong>和</strong> <strong>ORS</strong> <strong>赋值时，需要使用双引号，不能没有引号或使用单引号</strong></p>

<p><strong>&gt; &gt;&gt;</strong> <strong>printf</strong> <strong>语句</strong></p>

<p><strong>语法格式：</strong> printf( <strong>format</strong> ，expression1，expression2…)</p>

<blockquote>
<blockquote>
<blockquote>
<p>参数format是必须的，包含 <strong>百分号</strong> <strong>%</strong> <strong>、对齐方式、格式控制字符、字符串最大宽度</strong> <strong>（</strong> <strong>format</strong>
<strong>最后需要添加</strong> <strong>\n</strong> <strong>才会换行）</strong></p>
</blockquote>
</blockquote>
</blockquote>

<p>**&gt; &gt;&gt;format **<strong>之间不用</strong> <strong>&rdquo;,&rdquo;</strong> <strong>隔开</strong> <strong>而是用空格隔开</strong></p>

<p><strong>printf</strong> <strong>格式控制字符</strong></p>

<p><strong>字符</strong></p>

<p>|</p>

<p><strong>表达式将被打印成</strong></p>

<p>|</p>

<p><strong>$1</strong></p>

<p>|</p>

<p><strong>printf(format</strong> <strong>，</strong> <strong>$1)</strong></p>

<p>&mdash;|&mdash;|&mdash;|&mdash;</p>

<p><strong>%c</strong></p>

<p>|</p>

<p><strong>ASCII</strong> <strong>字符</strong></p>

<p>|</p>

<p><strong>97</strong></p>

<p>|</p>

<p><strong>a</strong></p>

<p><strong>%d</strong></p>

<p>|</p>

<p><strong>十进制整数</strong></p>

<p>|</p>

<p><strong>97.5</strong></p>

<p>|</p>

<p><strong>97</strong></p>

<p><strong>%5d</strong></p>

<p>|</p>

<p>|</p>

<p><strong>97.5</strong></p>

<p>|</p>

<p><strong>97</strong></p>

<p><strong>%e</strong></p>

<p>|</p>

<p><strong>[</strong> <strong>-</strong> <strong>]</strong> <strong>d.dddddd[+-]dd</strong></p>

<p>|</p>

<p><strong>97.5</strong></p>

<p>|</p>

<p><strong>9.750000</strong> <strong>e+01</strong> <strong>（</strong> <strong>01</strong> <strong>表示</strong> <strong>10</strong> <strong>的次方为</strong> <strong>1</strong> <strong>）</strong></p>

<p><strong>%f</strong></p>

<p>|</p>

<p><strong>[</strong> <strong>-</strong> <strong>]</strong> <strong>ddd.dddddd</strong></p>

<p>|</p>

<p><strong>97.5</strong></p>

<p>|</p>

<p><strong>97.500000</strong></p>

<p><strong>%7.2f</strong></p>

<p>|</p>

<p>|</p>

<p><strong>97.5</strong></p>

<p>|</p>

<p><strong>97.50</strong></p>

<p><strong>%g</strong></p>

<p>|</p>

<p><strong>按照</strong> <strong>e</strong> <strong>或</strong> <strong>f</strong> <strong>进行转换</strong></p>

<p>|</p>

<p><strong>97.5</strong></p>

<p>|</p>

<p><strong>97.5</strong></p>

<p><strong>%o</strong></p>

<p>|</p>

<p><strong>无符号八进制数</strong></p>

<p>|</p>

<p><strong>97</strong></p>

<p>|</p>

<p><strong>141</strong></p>

<p><strong>%06o</strong></p>

<p>|</p>

<p>|</p>

<p><strong>97</strong></p>

<p>|</p>

<p><strong>000141</strong></p>

<p><strong>%x</strong></p>

<p>|</p>

<p><strong>无符号十六进制数</strong></p>

<p>|</p>

<p><strong>97</strong></p>

<p>|</p>

<p><strong>61</strong></p>

<p><strong>%s</strong></p>

<p>|</p>

<p><strong>字符串</strong></p>

<p>|</p>

<p><strong>January</strong></p>

<p>|</p>

<p><strong>January</strong></p>

<p><strong>%</strong> <strong>10</strong> <strong>s</strong></p>

<p>|</p>

<p>|</p>

<p><strong>January</strong></p>

<p>|</p>

<p><strong>January</strong></p>

<p><strong>%-</strong> <strong>10</strong> <strong>s</strong></p>

<p>|</p>

<p>|</p>

<p><strong>January</strong></p>

<p>|</p>

<p><strong>January</strong> <strong>（后面还有三个空格）</strong></p>

<p><strong>%</strong> <strong>.</strong> <strong>3s</strong></p>

<p>|</p>

<p>|</p>

<p><strong>January</strong></p>

<p>|</p>

<p><strong>Jan</strong></p>

<p><strong>%</strong> <strong>10.3</strong> <strong>s</strong></p>

<p>|</p>

<p>|</p>

<p><strong>January</strong></p>

<p>|</p>

<p><strong>Jan</strong></p>

<p><strong>%-</strong> <strong>10.3</strong> <strong>s</strong></p>

<p>|</p>

<p>|</p>

<p><strong>January</strong></p>

<p>|</p>

<p><strong>Jan</strong> <strong>（后面还有七个空格）</strong></p>

<p><strong>%</strong></p>

<p>|</p>

<p><strong>打印一个百分号</strong> <strong>%</strong> <strong>，不会有参数被吸收</strong></p>

<p>|</p>

<p>|</p>

<p><strong>对齐方式：</strong></p>

<p><strong>连字符</strong> <strong>&lsquo;</strong> <strong>-</strong> <strong>&lsquo;</strong> 表示左对齐，不使用连字符默认是右对齐</p>

<p><strong>字符串最大宽度：</strong></p>

<p>为了达到规定宽度，必要时填充空格，前导的0用零填充</p>

<p><strong>&gt; &gt;&gt;</strong> <strong>awk</strong> <strong>程序可以使用重定向运算符</strong> <strong>&gt;</strong> <strong>或</strong> <strong>&gt; &gt;</strong><br />
<strong>使用</strong> <strong>&gt; &gt;</strong> <strong>重定向，打开文件时，不会清空文件内容，并追加文件到尾部</strong><br />
<strong>使用</strong> **&gt; **<strong>重定向，打开文件时，会清空文件内容，再把内容追加到文件</strong></p>

<p>awk &lsquo;$3 &gt; 100 {print $0 &gt;&gt; &ldquo;file_01&rdquo;}&rsquo;</p>

<p><strong>注意：重定向时，文件名必须使用双引号引起来，否则会将其当做一个未初始化的变量来使用</strong></p>

<p>awk &lsquo;$3 &gt; 100 {print $0 &gt; &ldquo;file_01&rdquo;}&rsquo;</p>

<p><strong>重定向时，会先将文件</strong> <strong>file_01</strong> <strong>原来的内容删除，相当于覆盖原来的内容</strong></p>

<p><strong>输出到管道</strong> <strong>|</strong> <strong>，并排序</strong> <strong>sort</strong></p>

<p><strong>&gt; &gt;&gt;</strong> <strong>语句</strong> <strong>: {</strong> <strong>print(…)|</strong> <strong>&ldquo;</strong> <strong>sort …&rdquo;}</strong> <strong>注意：</strong> <strong>sort</strong>
<strong>命令需要用双引号引起来</strong></p>

<p>需求：date文件是三门科目的考试成绩，需要格式化输出（名字，三科成绩，总成绩），再以总成绩降序排序</p>

<pre><code>[bei@localhost test]$ cat date
Simon 96 97 99
Bei 92 100 95
Tom 100 92 97
Tim 80 99 99
[bei@localhost test]$ awk '{printf(&quot;%-7s %-3d %-3d %-3d %-3d\n&quot;,$1,$2,$3,$4,$2+$3+$4)|&quot;sort -nr -k 5&quot;}' date 
Simon   96  97  99  292
Tom     100 92  97  289
Bei     92  100 95  287
Tim     80  99  99  278
</code></pre>

<p>#或者将awk的输出通过管道符传递给sort命令实现将格式化输出后的内容进行排序</p>

<p><strong>[bei@localhost test]$ awk &lsquo;{printf(&ldquo;%-7s %-3d %-3d %-3d
%-3d\n&rdquo;,$1,$2,$3,$4,$2+$3+$4)}&rsquo; date | sort -nr -k 5</strong></p>

<hr />

<h1 id="③变量"><strong>③变量</strong></h1>

<blockquote>
<blockquote>
<blockquote>
<p>表达式可以包含若干种类型的变量：内建的，字段或用户定义的</p>

<p>变量不需要事先声明，所以awk需要根据上下文环境推断出变量的类型（字符串或数值）</p>
</blockquote>
</blockquote>
</blockquote>

<h2 id="内建变量"><strong>内建变量</strong></h2>

<p><strong>&gt; &gt;&gt;</strong> <strong>内键变量可以简单理解是</strong> <strong>awk</strong> <strong>专属的环境变量，</strong></p>

<p><strong>变量</strong></p>

<p>|</p>

<p><strong>意义</strong></p>

<p>|</p>

<p><strong>默认值</strong></p>

<p>&mdash;|&mdash;|&mdash;</p>

<p><strong>ARGC</strong></p>

<p>|</p>

<p><strong>命令行参数的个数</strong></p>

<p>|</p>

<p><strong>-</strong></p>

<p><strong>ARGV</strong></p>

<p>|</p>

<p><strong>命令行参数数组</strong></p>

<p>|</p>

<p><strong>-</strong></p>

<p><strong>FILENAME</strong></p>

<p>|</p>

<p><strong>当前输入文件名</strong></p>

<p>|</p>

<p><strong>-</strong></p>

<p><strong>FNR</strong></p>

<p>|</p>

<p><strong>当前输入文件记录个数</strong></p>

<p>|</p>

<p><strong>-</strong></p>

<p><strong>FS</strong></p>

<p>|</p>

<p><strong>输入行字段分隔符</strong></p>

<p>|</p>

<p><strong>&rdquo; &ldquo;</strong></p>

<p><strong>NF</strong></p>

<p>|</p>

<p><strong>当前记录的字段个数</strong></p>

<p>|</p>

<p><strong>-</strong></p>

<p><strong>NR</strong></p>

<p>|</p>

<p><strong>到目前为止读的记录数量</strong></p>

<p>|</p>

<p><strong>-</strong></p>

<p><strong>OFMT</strong></p>

<p>|</p>

<p><strong>数值的输出格式</strong></p>

<p>|</p>

<p><strong>&ldquo;</strong> <strong>%</strong> <strong>.</strong> <strong>6g</strong> <strong>&ldquo;</strong></p>

<p><strong>OFS</strong></p>

<p>|</p>

<p><strong>输出字段分隔符</strong></p>

<p>|</p>

<p><strong>&rdquo; &ldquo;</strong></p>

<p><strong>ORS</strong></p>

<p>|</p>

<p><strong>输出的记录分隔符</strong></p>

<p>|</p>

<p>*<em>&ldquo;*</em> <strong>n&rdquo;</strong></p>

<p><strong>RLENGTH</strong></p>

<p>|</p>

<p><strong>被函数</strong> <strong>match</strong> <strong>匹配的字符串的长度</strong></p>

<p>|</p>

<p><strong>-</strong></p>

<p><strong>RS</strong></p>

<p>|</p>

<p><strong>控制着输入行的记录分隔符</strong></p>

<p>|</p>

<p>*<em>&ldquo;*</em> <strong>n&rdquo;</strong></p>

<p><strong>案例：</strong> <strong>ARGC</strong> <strong>与</strong> <strong>ARGV</strong></p>

<p><strong>需求：格式化输出文件</strong> <strong>date</strong> <strong>算出总数，并在每一行尾加上</strong> <strong>hello world</strong> <strong>两个字段，最后一行输出</strong>
<strong>ARGC</strong> <strong>和</strong> <strong>ARGV</strong></p>

<pre><code>[bei@localhost test]$ cat date
Simon 96 97 99
Bei 92 100 95
Tom 100 92 97
Tim 80 99 99

[bei@localhost test]$ cat awk.sh
#!/bin/bash
awk 'BEGIN{
printf(&quot;%-10s%-10s%-10s%-10s%-10s\n&quot;,&quot;name&quot;,&quot;chinese&quot;,&quot;maths&quot;,&quot;english&quot;,&quot;total&quot;)
}
{
        total = $2 + $3 + $4
        printf(&quot;%-10s%-10.0f%-10.0f%-10.0f%-10.0f%-10s%-10s\n&quot;,$1,$2,$3,$4,total,a,b)
}
END{
print(ARGC,ARGV[0],ARGV[1],ARGV[2],ARGV[3])
}' a=hello b=world date 

[bei@localhost test]$ bash awk.sh
name      chinese   maths     english   total    
Simon     96        97        99        292       hello     world    
Bei       92        100       95        287       hello     world    
Tom       100       92        97        289       hello     world    
Tim       80        99        99        278       hello     world    
4 awk a=hello b=world date
</code></pre>

<p><strong>说明：</strong> print(ARGC,ARGV[0],ARGV[1],ARGV[2],ARGV[3]) 对于这一行输出的理解</p>

<p>4 awk a=hello b=world date</p>

<p>ARGC是命令行参数个数，除了自己定义的两个变量&rdquo;a&rdquo;，&rdquo;b&rdquo;，还有一个参数存储程序名，一个参数存储文件名</p>

<p>ARGV[0]，即第一个参数，表示awk程序的程序名，为&rdquo;awk&rdquo;这个字符串</p>

<p>ARGV[1]，ARGV[2] ，表示属组中自己定义的第一个参数和第二个参数</p>

<p>ARGV[3]，即最后一个参数，表示文件的文件名</p>

<h2 id="字段变量"><strong>字段变量</strong></h2>

<blockquote>
<blockquote>
<blockquote>
<p>对记录通过字段分隔符分隔后的一个个单元，即为字段，对字段进行引用即为字段变量</p>

<p>字段变量可以用在算术或字符串运算中，也可以被赋值，即字段变量是可以修改的</p>
</blockquote>
</blockquote>
</blockquote>

<hr />

<h1 id="④流程控制"><strong>④流程控制</strong></h1>

<blockquote>
<blockquote>
<blockquote>
<p>流程控制语句中，if-else用于决策，while、for、do用于循环</p>
</blockquote>
</blockquote>
</blockquote>

<h2 id="if-else-语句"><strong>if-else</strong> <strong>语句</strong></h2>

<p><strong>语法结构：</strong></p>

<p>{</p>

<p>if （expression）</p>

<p>statements</p>

<p>else</p>

<p>statements</p>

<p>}</p>

<p><strong>或者</strong></p>

<p>{if (expression) statements;else statements}</p>

<p><strong>案例</strong></p>

<pre><code>[bei@localhost test]$ cat date
Simon 96 97 99
Bei 92 100 95
Tom 100 92 97
Tim 80 99 99

[bei@localhost test]$ cat control.awk
#!/bin/bash
{
        if ($2==100||$3==100||$4==100)
                print ( $1 &quot; has a full score in subjects.&quot; )
        else
                print ( $1 &quot; need to work hard.&quot; )
}

[bei@localhost test]$ awk -f control.awk date
Simon need to work hard.
Bei has a full score in subjects.
Tom has a full score in subjects.
Tim need to work hard.
</code></pre>

<h2 id="while-语句"><strong>while</strong> <strong>语句</strong></h2>

<p><strong>语法结构：</strong></p>

<p>{</p>

<p>while (expression)</p>

<p>{</p>

<p>statement1</p>

<p>statement2</p>

<p>……</p>

<p>}</p>

<p>}</p>

<p><strong>或者</strong></p>

<p>{while (expression) {statements;else statements}}</p>

<p><strong>说明：</strong></p>

<p><strong>&gt;
&gt;&gt;</strong>在while循环中，expression被求值，如果expression的值为真则statements会被执行，然后expression再被求值，只要expression为真，循环就一直被执行下去</p>

<blockquote>
<blockquote>
<blockquote>
<p>每从输入流读取一行，while循环就会被执行</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>案例：对</strong> <strong>txt</strong> <strong>每行求和</strong></p>

<pre><code>[bei@localhost test]$ cat txt
1 2 1 2
2 3 2 5 3
3 2
4 3 2
1 1 2

[bei@localhost test]$ cat control.awk
{
        i=1
        sum=0
        while (i&lt;=NF)
        {
                sum+=$i
                i++
        }
        print(&quot;line&quot;NR,&quot;Sum=&quot;sum)
}

[bei@localhost test]$ awk -f control.awk txt
line1 Sum=6
line2 Sum=15
line3 Sum=5
line4 Sum=9
line5 Sum=4
</code></pre>

<h2 id="for-语句"><strong>for</strong> <strong>语句</strong></h2>

<p><strong>语法结构：</strong></p>

<p>{</p>

<p>for (expression1;expression2;expression3)</p>

<p>{</p>

<p>statement1；</p>

<p>statement2；</p>

<p>……</p>

<p>}</p>

<p>}</p>

<p><strong>或者</strong></p>

<p>{for (expression1;expression2;expression3) {statement1;statement2;statement3}}</p>

<p>expression1对变量初始化</p>

<p>expression2用来做条件判断</p>

<p>expression3用来做变量变化，例如自增自减</p>

<p><strong>案例：对</strong> <strong>txt</strong> <strong>每行求和</strong></p>

<pre><code>[bei@localhost test]$ cat txt
1 2 1 2
2 3 2 5 3
3 2
4 3 2
1 1 2
[bei@localhost test]$ cat control.awk      
{
        sum=0
        for (i=1;i&lt;=NF;i++)
        {
                sum+=$i
        }
        print(&quot;line&quot;NR,&quot;Sum=&quot;sum)
}
[bei@localhost test]$ awk -f control.awk txt
line1 Sum=6
line2 Sum=15
line3 Sum=5
line4 Sum=9
line5 Sum=4
</code></pre>

<h2 id="do-while-语句"><strong>do-while</strong> <strong>语句</strong></h2>

<p><strong>语法结构：</strong></p>

<p>{</p>

<p>do</p>

<p>{</p>

<p>statement1;</p>

<p>statement2;</p>

<p>……</p>

<p>}</p>

<p>while (expression)</p>

<p>}</p>

<p><strong>或者</strong></p>

<p>{do{statement1;statement2;……} while (expression)}</p>

<p><strong>说明</strong></p>

<p><strong>&gt; &gt;&gt;</strong> <strong>do-while</strong> <strong>语句与</strong> <strong>while</strong> <strong>、</strong> <strong>for</strong>
<strong>循环相比，它的测试条件在循环体底部，所以循环体至少会被执行一次</strong></p>

<h2 id="break-continue-语句"><strong>break</strong> <strong>、</strong> <strong>continue</strong> <strong>语句</strong></h2>

<blockquote>
<blockquote>
<blockquote>
<p>这两个语句用于影响循环的运行</p>

<p>break会导致控制流马上从包围着它的循环内退出，循环包括while、for和do-while</p>

<p>continue导致下一次迭代开始，即为提前进入当前循环的下一个轮循</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>break</strong> <strong>案例：只对</strong> <strong>txt</strong> <strong>文件，每行的前三个字段求和</strong></p>

<pre><code>[bei@localhost test]$ cat txt
1 2 1 2
2 3 2 5 3
3 2
4 3 2
1 1 2

[bei@localhost test]$ cat control.awk
{
        sum=0
        for (i=1;i&lt;=NF;i++)
        {
                if (i&gt;3)
                {
                        break
                }
                sum+=$i
        }
        print(&quot;line&quot;NR,&quot;Sum=&quot;sum)
}

[bei@localhost test]$ awk -f control.awk txt
line1 Sum=4
line2 Sum=7
line3 Sum=5
line4 Sum=9
line5 Sum=4
</code></pre>

<p><strong>continue</strong> <strong>案例：只对</strong> <strong>txt</strong> <strong>文件，值小于</strong> <strong>3</strong> <strong>的字段求和</strong></p>

<pre><code>[bei@localhost test]$ cat txt
1 2 1 2
2 3 2 5 3
3 2
4 3 2
1 1 2

[bei@localhost test]$ cat control.awk      
{
        sum=0
        for (i=1;i&lt;=NF;i++)
        {
                if ($i&gt;=3)
                {
                        continue
                }
                sum+=$i
        }
        print(&quot;line&quot;NR,&quot;Sum=&quot;sum)
}

[bei@localhost test]$ awk -f control.awk txt
line1 Sum=6
line2 Sum=4
line3 Sum=2
line4 Sum=2
line5 Sum=4
</code></pre>

<h2 id="exit-next-语句"><strong>exit</strong> <strong>、</strong> <strong>next</strong> <strong>语句</strong></h2>

<blockquote>
<blockquote>
<blockquote>
<p>next使得awk抓取下一个输入行</p>

<p>exit会导致程序终止，如果END语句存在会执行END动作</p>
</blockquote>
</blockquote>
</blockquote>

<hr />

<h1 id="⑤数组"><strong>⑤数组</strong></h1>

<blockquote>
<blockquote>
<blockquote>
<p>awk提供了一维数组，用于存放字符串与数值</p>

<p>在awk中，数组可以称之为 <strong>关联数组（</strong> <strong>association array</strong> <strong>）</strong>
，关联数组在数组下标index和元素value之间建立了一种关联</p>

<p>数组与数组元素不需要事先声明，也不需要说明数组有多少个元素，即为无须定义并且可以直接使用，自动扩展</p>

<p>awk的数组下标可以是字符串也可以是数值</p>
</blockquote>
</blockquote>
</blockquote>

<p>例如：arrat[1]=&ldquo;bei&rdquo;为数值下标；array[&ldquo;first&rdquo;]=&ldquo;bei&rdquo;为字符串下标</p>

<p>注意：因为1的字符串值与&rdquo;1&rdquo;是相同的，所以array[1]与array[&ldquo;1&rdquo;]是同一个元素，但01和1的字符串值不相同</p>

<blockquote>
<blockquote>
<blockquote>
<p>如果下标使用的是字符串，一定要用双引号将字符串引起来，否则会把字符串当做一个未初始化过的变量（变量为空字符串），于是value会赋值到array[&ldquo;&rdquo;]中</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>案例：使用数组倒序输出文件</strong> <strong>date</strong></p>

<pre><code>[bei@localhost test]$ cat date
IP1 1.1.1.1
IP2 192.168.1.1
IP3 172.168.1.1
[bei@localhost test]$ awk '{x[NR]=$0} END{for(i=NR;i&gt;0;i--){print x[i]}}' date
IP3 172.168.1.1
IP2 192.168.1.1
IP1 1.1.1.1
</code></pre>

<p><strong>说明：</strong> x[NR]=$0将行号作为index，行的内容作为value，建立关联数组x</p>

<p>for(i=NR;i&gt;0;i&ndash;){print
x[i]}，这是个for循环，用来遍历数组x，此时i=NR等于尾行的行号，即循环第一次输出的是尾行，然后i自减，遍历倒数第二行，以此循环，实现倒序输出</p>

<p><strong>案例：将第一个字段相同的行的第二个字段累加作为</strong> <strong>value</strong> <strong>，赋值给下标为第一个字段的数组</strong> <strong>size</strong></p>

<pre><code>[bei@localhost test]$ cat txt
file 20
file 30
file 10
directory 14
directory 8
symbolic_link 4
symbolic_link 18

[bei@localhost test]$ cat array.awk
{
        size[$1]+=$2
}
END {
        for (i in size)
        {
                print (i,size[i])
        }
}

[bei@localhost test]$ awk -f array.awk txt
file 60
directory 22
symbolic_link 22
</code></pre>

<p><strong>操作数组</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>数组引用是如下所示的表达式：array[index]</p>
</blockquote>
</blockquote>
</blockquote>

<p>array即为数组的名称，index即为元素的索引，可以理解为下标</p>

<p><strong>判断数组是否存在某个元素</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>语法格式：index in array</p>

<p>这个表达式用于测试特定索引是否存在，如果不存在不会产生创建该元素的副作用</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>例</strong></p>

<p>if (2 in array)</p>

<p>print &ldquo;Subscript 2 is present.&rdquo;</p>

<blockquote>
<blockquote>
<blockquote>
<p>但是以下方案会导致在数组array中创建array[2]：</p>
</blockquote>
</blockquote>
</blockquote>

<p>if (array[2] != &ldquo;&rdquo;)</p>

<p>print &ldquo;Subscript 2 is present.&rdquo;</p>

<p><strong>删除数组中的元素</strong></p>

<blockquote>
<blockquote>
<blockquote>
<p>delete array[index]</p>
</blockquote>
</blockquote>
</blockquote>

<hr />

<h1 id="⑥内建函数"><strong>⑥内建函数</strong></h1>

<h2 id="内建算术函数"><strong>内建算术函数</strong></h2>

<p><a href="https://img.it610.com/image/info8/b76e05c2e28b46a486c32fcd2e882d3a.jpg"><img src="https://img.it610.com/image/info8/b76e05c2e28b46a486c32fcd2e882d3a.jpg" alt="shell三剑客之awk 数据截取工具
详解_第1张图片" /></a></p>

<h2 id="字符串函数"><strong>字符串函数</strong></h2>

<h3 id="sub-regexp-replacement-target"><strong>sub(regexp,replacement[,target])</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>搜索taget中最左并且是最长的，能被regexp匹配的子字符串，使用replacement进行替换，返回替换发生的次数</p>

<p>regexp为一个正则表达式，格式为/regexp/，需要用//</p>

<p>target可以省缺，搜索匹配的对象是$0，即为输入流那一行的内容</p>

<p>当replacement中有&amp;符号，表示对regexp的反向引用，用来拼接使用</p>
</blockquote>
</blockquote>
</blockquote>

<p>（如果需要使用&amp;这个字符，需要用两个转义符转义\\）</p>

<p><strong>案例</strong></p>

<pre><code>[bei@localhost test]$ cat 1.txt
IP1 2.4 IP1
IP2 ccna IP2
IP3 chinanet IP3
IP4 chinanet IP4
#将第三个字段的IP替换成ip
[bei@localhost test]$ awk '{sub(/IP/,&quot;ip&quot;,$3);print $0}' 1.txt
IP1 2.4 ip1
IP2 ccna ip2
IP3 chinanet ip3
IP4 chinanet ip4
#在replacement使用&quot;&amp;&quot;对regexp反向引用，用来拼接使用
[bei@localhost test]$ awk '{sub(/IP/,&quot;&amp;v4_&quot;,$3);print $0}' 1.txt
IP1 2.4 IPv4_1
IP2 ccna IPv4_2
IP3 chinanet IPv4_3
IP4 chinanet IPv4_4
</code></pre>

<p><strong>注意：</strong> replacement的字符串需要用双引号引起来，否则会将其当做变量使用</p>

<h3 id="gsub-regexp-replacement-target"><strong>gsub(regexp,replacement[,target])</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>g表示global，对输入流进行全局搜索替换，所有匹配到的内容都会被替换</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="gensub-regexp-replacement-how-target"><strong>gensub(regexp,replacement</strong> <strong>，</strong> <strong>how</strong> <strong>[,target])</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>这个函数可以灵活控制去替换第几个被匹配到的字符</p>

<p>how可以填充g或G表示全局匹配，也可以填充n表示替换匹配到的第n个</p>

<p>gensub函数不会对原来的内容直接替换，而是需要将函数的结果赋值给变量，然后再对变量输出</p>
</blockquote>
</blockquote>
</blockquote>

<p>当需要使用时，需要对gensub函数进行赋值 a=gensub(regexp,replacement，how[,target])，然后再print a</p>

<blockquote>
<blockquote>
<blockquote>
<p>gensub函数支持使用括号来标记正则表达式regexp，然后在replacement使用&rdquo;\\N&rdquo;来反向引用括号内的内容</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>案例：将</strong> <strong>txt</strong> <strong>文件每行的第一个字段和第二个字段对换</strong></p>

<pre><code>[bei@localhost test]$ cat txt
file 20
file 30
file 10
directory 14
directory 8
symbolic_link 4
symbolic_link 18

[bei@localhost test]$ awk '{str=gensub(/(.+) (.+)/,&quot;\\2 \\1&quot;,&quot;g&quot;,$0);print str}' txt
20 file
30 file
10 file
14 directory
8 directory
4 symbolic_link
18 symbolic_link
</code></pre>

<p><strong>说明：</strong> /(.+) (.+)/匹配第一个字段和第二个字段</p>

<p>&ldquo;\\2 \\1&rdquo;对匹配到的内容反向引用，\\1引用第一个()匹配的内容，\\2引用第二个()匹配到的内容</p>

<h3 id="index-in-find"><strong>index</strong> <strong>(</strong> <strong>in</strong> <strong>，</strong> <strong>find</strong> <strong>)</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>返回字符串find在in中出现的位置，位置是指find字符串的第一个字符在in中出现的位置</p>
</blockquote>
</blockquote>
</blockquote>

<p>如果没有找到，则函数的返回值为0</p>

<p><strong>案例</strong></p>

<pre><code>[bei@localhost test]$ cat 1.txt
hello
world
haha
[bei@localhost test]$ awk '{ print ( index($0,&quot;o&quot;) ) }' 1.txt
5
2
0
</code></pre>

<p><strong>说明：</strong> 通过index函数返回字符&rdquo;o&rdquo;在每一行出现的首个位置，如果没有则返回&rdquo;0&rdquo;</p>

<h3 id="length-string"><strong>length([string])</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>用于获取string中字符的数量，不是字段的数量</p>

<p>如果是一个数值，则返回值为该数值的数字字符串的长度</p>

<p>如果使用length计算不存在的变量，会报错</p>
</blockquote>
</blockquote>
</blockquote>

<p>#字符串用单引号引起来作为变量abc</p>

<p>awk &lsquo;BEGIN { print length(&lsquo;abc&rsquo;) }&rsquo;</p>

<p>0</p>

<p>#字符用双引号引起来作为字符串&rdquo;abc&rdquo;</p>

<p>awk &lsquo;BEGIN { print length(&ldquo;abc&rdquo;) }&rsquo;</p>

<p>3</p>

<blockquote>
<blockquote>
<blockquote>
<p>如果string被省略，默认计算$0</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="match-string-regexp-array"><strong>match(string,regexp[,array])</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>对string搜索，返回匹配到的内容在string中的位置</p>

<p>匹配到的内容会被记录在array中，可以通过array[1]搜索</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="split-string-array-fieldsep-seps"><strong>split(string,array[,fieldsep[,seps]])</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>string是被切割的字符串</p>

<p>array用来存储被切割后的字段</p>

<p>fieldsep用来定义被切割的分隔符</p>

<p>seps用来存储分隔符字符的数组</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="substr-string-start-length"><strong>substr(string,start[,length])</strong></h3>

<blockquote>
<blockquote>
<blockquote>
<p>该函数作用是获取字符串，可以使用该函数进行字符串拼接，函数的返回值是获取的子字符串</p>

<p>start表示从第几个字符开始，length表示获取的子字符串的长度</p>
</blockquote>
</blockquote>
</blockquote>

<p><strong>案例</strong></p>

<p>[bei@localhost test]$ awk &lsquo;BEGIN{string=&ldquo;abcdefg&rdquo;;string=substr(string,1,2)
&ldquo;CDE&rdquo; substr(string,6);print string}&rsquo;</p>

<p>abCDEfg</p>

<p><strong>说明：</strong> substr(string,1,2)获取函数第一个和第二个字符，substr(string,6)获取string从第六个字符以后的所有字符</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>