<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>新手入门shell入门 | 开发者问答集锦</title>
    <meta property="og:title" content="新手入门shell入门 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="新手入门shell入门">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8shell%E5%85%A5%E9%97%A8/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">新手入门shell入门</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>新手入门——shell入门<br />
前言<br />
使用 Shell</p>

<p>以下将介绍并解释基本的 shell  命令 和机制。</p>

<p>第一篇：超级工具／Terminals，xterms 和 Shells</p>

<p>一、超级工具</p>

<p>您或许听过这样的论调：命令行(the mommand line)早就已经过时了，那东西神秘兮兮的，等等。有些人甚至觉得操作系统中应该没有这些命令才好。</p>

<p>事实是上，您可以不懂任何 shell ，就能使用 Linux 。您启动系统后可以直接进入 X Window ，最后在 X Window 下关机。<br />
我坚信，用 Linux 而不懂 shell ，就象开车只会用头档(first gear)一样。当然，最初看起来，直接而简单，在大多数情况下都管用。但 速度
慢，而且无法真正体验驾驶的乐趣。</p>

<p>对，命令行很有趣。就象用一大堆收集到的积木，竟可 以完成许多意想不到的创举，一些极其复杂的工作，只需几行命令就可以解决。这是因为，在 Unix
中，shell 可不是简单的命令解释器（典型的有 Windows 中的 DOS ），而是一个全功能的编程环境。<br />
这并不意味着 shell 非常容易学通，您知道，好事多磨，这还是要花点工夫的。;-) 但请相信我，这绝对值得。您在很短时间内，就能被一大帮门外汉吹捧为
Unix wizard（奇才） 。<em>grin</em></p>

<p>二、为了说明 shell ，这里需要一些背景知识。</p>

<p>1、 Terminals, xterms 与 Shells</p>

<p>追溯到 Unix 诞生的那个年代，当时还没有现在流行的&rdquo;个人计算机&rdquo;。被称为计算机的机器，还是吞吐磁带与 magnetic memory
（用术语&rsquo;core&rsquo;来表示系统 memory）的庞然大物。DEC 公司（现在的 Compaq）推出的 PDP-11 ，体积小（被称为
mini）而且价格底，在大学中引起了巨大的反响，很多学校直到那时才买得起一台计算机（PDP-11 物美价廉，只有 10000$）。</p>

<p>这些机器的操作系统由汇编语言、机器语言写成，所以运行起来效率很高，但都无法移植(unportable)。每家计算机公司都给自己的机器配上独有的
操作系统，然后再销售。</p>

<p>这种笨拙的作法很快就被人们意识到了，于是就开始兴建一个可以在不同品牌机器上运行的操作系统。1969 年，Ken Thompson 开始写后来成为 Unix
的第一行代码。（Thompson 曾经参加了一个项目：MULTICS，Unix 是与这有关的一个玩笑词） 其实，Dennis Ritchie
为这个新的操作系统设计了一种新的编程语言&ndash; C 语言后，事情才真正开始。</p>

<p>虽然 Unix 的效率不及原来的操作系统，但有三个突出的优点：可以任意移植到其他机器，其中的 C 语言大大简化了编程，而且这些都 free
。很快，全美国的大学都忙着开始为机器安装 Unix 。</p>

<p>2、终端（Terminals）</p>

<p>Unix 是可以在许多种机器上运行的操作系统，但人们又如何使用这些机器呢？他们是通过哑终端来连接到这些机器，也就是用键盘、显示器及足够的
electronics （电子元件）组成的机器与中央计算机(central
computer)相连。在这些终端上，用户可以敲字符（teletypy），这就是字符串&rsquo;tty&rsquo;表示终端设备文件，和&rsquo;getty&rsquo;命令的名称来 历。</p>

<p>您可能会问，现在这些东西都在哪儿。 这些终端的厂家无法达成一项最终标准，这导致每种牌子的终端都有各自的键盘布局、各自的在屏幕上显示字符的方法、发送或接收
什么 信号表示什么字符、控制代码等等。</p>

<p>为了避免这些混乱，就创建了一个含有所有不同终端特
性的(capability)文件，这就是&rsquo;termcap&rsquo;。用一个工具打开&rsquo;/etc/termcap&rsquo;瞧瞧，可别吓着了 ;-) 。</p>

<p>Linux 终端大多数用&rsquo;vt100&rsquo;或&rsquo;linux&rsquo;作为终端类型。</p>

<p>3、xterms</p>

<p>在八十 年代初期，产生了一个 Unix 的图形子系统&ndash; the X Window System 。九十年代早期，为了更好地实现基于 Intel 的
Unix 类系统上（如FreeBSD、NetBSD、Linux）的应用，产生了一个系统分支&ndash; XFree86 。</p>

<p>X Window 中一个很大的好处是可以运行多个虚拟(virtual)终端。甚至在 X Window
下就有这么个应用程序&ndash;&lsquo;xterm&rsquo;。您将发现&rsquo;xterm&rsquo;和&rsquo;virtual terminal&rsquo;在很多情况下都是一样的。有的地方说&rsquo;打开一个
xterm&rsquo;，其实您不是非要用&rsquo;xterm&rsquo;程序，其他的终端模拟器(terminal emulator)，如
rxvt、konsole、aterm、eterm、wterm 等等，一样有效。</p>

<p>终端模拟器（又称为虚拟终端）通过伪 (pseudo) tty 设备&ndash; pty 与系统相连，并且使用自己的显示标准&ndash; xterm
。这导致不同的终端模拟器可能在一些按键或程序上存在细小的差别，这取决于模拟器多大程度上遵守了&rsquo;xterm&rsquo;的显示标准。</p>

<p>4、 Shells</p>

<p>为了在终端中运行程序，需要 shell 。shell 是操作系统的一部分，用来与用户打交道，并且可以用来协调各个命令。</p>

<p>第一个真正的 Unix shell &ndash; &lsquo;sh&rsquo;，亦称为&rsquo;Bourne shell&rsquo;，诞生于 1975 年，作者是 Steve Bourne
。很快，出现了其他 shell ，如基于原始&rsquo;Bourne shell&rsquo;的&rsquo;ksh&rsquo;、&rsquo;zsh&rsquo;，后者常用作专属 Unixes 系统中的标准 shell
；也有一些从 C 语言中衍生出来的 shell ，如&rsquo;csh&rsquo;或&rsquo;tcsh&rsquo;。</p>

<p>在 Linux 中，标注的 shell 是&rsquo;bash&rsquo;，即 the GNU Bourne-Again Shell （有点玩笑的味道……）。这个 shell
功能非常强大（甚至有人觉得太庞大了），压缩的 man page 就有 50 KB 。</p>

<p>三、Shell 起步</p>

<p>首先，有一点小说明：在平常应用中， 建议 您不要用&rsquo;root&rsquo;帐号运行 shell
，如果您还是新手，这一点尤其要注意。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是&rsquo;root&rsquo;，那就不同了，只要敲几个字母，就可能导
致灾难性后果。</p>

<p>当您登入系统或打开一个 xterm 窗口，首先看到的是提示符(prompt)。Red Hat Linux
的标准提示符包括了您的用户名、登入的主机名（没有设置的话，是&rsquo;localhost&rsquo;）、当前所在的目录(working directory)、提示符号：<br />
[tom@belbo tom]$</p>

<p>我以用户名&rsquo;tom&rsquo;登入名为&rsquo;belbo&rsquo;的主 机，当前在我的 home 目录&ndash;&lsquo;/home/tom&rsquo;中。&rsquo;root&rsquo;的提示符：</p>

<p>[root@belbo root]#</p>

<p>除了不同的用户名外，提示符号由&rsquo;$&lsquo;变成了&rsquo;#&lsquo;。根据 Bourne shell 的传统，普通用户的提示符以&rsquo;$&lsquo;结尾，而超级用户用&rsquo;#&lsquo;。</p>

<p>提示符的每个部分都可以定制，您在后面将有更深的了 解。</p>

<p>要运行命令的话，您只要在提示符后敲进命令，然后在按 键。shell
将在其路径中（详情见后）搜索这个命令，找到以后就运行，并在终端里输出相应的结果（如果有的话），命令结束后，再给出新的提示符：<br />
[tom@belbo tom]$ whoami<br />
tom<br />
[tom@belbo tom]$</p>

<p>顺带指出，当您敲 ENTER 时，光标(cursor)在哪里并不要紧，因为 shell 总是会整行地读取。</p>

<p>基本的命令 有：&rsquo;ls&rsquo;（list directory ，列出目录内容）、&rsquo;cp&rsquo;（copy ，复制）、&rsquo;mv&rsquo;（move / rename
，移动／重命名），&rsquo;cd &lsquo;（change directory ，改变目录），这些命令后面都可以跟上一帮可选项，这方面 man page
有详细的介绍（man ls, man mv 等等）。<br />
在您动身前往 shell 领地前，这里有几个术语(terminology)的简短说明。命令可能带一些可选项（options）、参数（arguments）：<br />
mv -i file dir</p>

<p>其中&rsquo;-i&rsquo;是命令&rsquo;mv&rsquo;的一个可选项，而&rsquo;file&rsquo;和&rsquo;dir&rsquo;则是参数。所有可选项在该命 令的 man page 都中有详细的介绍（此例中用 man
mv），而参数则由您提供。可选项决定命令如何工作，而参数则用于确定命令作用的目标。</p>

<p>到目前为止，介绍得有点象许多人厌恶轻视的 DOS shell ，但伴随着下面的介绍，您将会有新的体验。<br />
第二篇：自动补齐／命令行的历史 记录／编辑命令行／可用的 Shell 快捷方式</p>

<p>Unix （及后继者 Linux）在命令行下面诞生，因此，Unix 中的命令行有许多非常实用的功能。在本篇中，我们将来作一些了解。</p>

<p>一、自动补齐；</p>

<p>如何用&rsquo;cd&rsquo;（改变目录，change directory）最快地从您当前所在的 home 目录跳到&rsquo;/usr/src/redhat/&lsquo;呢？<br />
cd /usrr</p>

<p>这称为&rsquo;命令行自动补齐&rsquo;(automatic command line completion)，这在平常应用中是不可缺少的。让我们仔细看看这个例子：</p>

<p>cd /u</p>

<p>扩展成了 cd /usr/ ，很简单吧。下面的</p>

<p>cd /usr</p>

<p>扩展为 cd /usr/src/ 。如果您只敲了cd /us，&rsquo;/usr&rsquo;下匹配的（&rsquo;cd
/u<em>/s</em>&lsquo;）三个子目录将列出供您选择：&rsquo;/usr/sbin&rsquo;、&rsquo;/usr/share&rsquo;和&rsquo;/usr/src&rsquo;。</p>

<p>因此， 键可以很方便地用于根据前几个字母，来查找匹配的文件或子目录。比如，ls /usr/bin/zip
将列出所有&rsquo;/usr/bin&rsquo;下面，以字符串&rsquo;zip&rsquo;开头的文件或子目录。当然，完成这类任务还有更厉害的命令，但这个方法确实很管用。</p>

<p>另外，碰到长文件名时就显得特别方便。假设您要安装一个名为&rsquo;boomshakalakwhizbang-4.6.4.5-i586.rpm&rsquo;的 RPM 包，您输入
rpm -i boom ，如果目录下没有其他文件能够匹配，那 shell 就会自动帮忙补齐。</p>

<p>cd /usrl</p>

<p>将扩展成 cd /usr/src/linux
，并等待继续。&rsquo;/usr/src&rsquo;中有两个匹配的目录：&rsquo;/usr/src/linux-[&hellip;]&lsquo;、&rsquo;/usr/src/linux&rsquo;。如何告诉 shell
您想要后面的那个呢？只要跟一个斜线（/ ，slash），就可以选择后面的那个了。</p>

<p>假如您不确定是&rsquo;/usr
/src/linux/Documentation&rsquo;还是&rsquo;/usr/src/linux/documentation&rsquo;。而您知道，Linux
是区分大小写的。如果已经仔细读过前面部分的话，您想到可以用：</p>

<p>cd /usrl/d</p>

<p>扩展成了 &lsquo;/usr/src/linux/drivers/&lsquo;，因此应该是&rsquo;Documentation&rsquo;(大写的&rsquo;D&rsquo;)。</p>

<p>这种补齐对命令也有效：<br />
[tom@belbo tom]$ gre<br />
grecord grefer grep<br />
[tom@belbo tom]$ gre</p>

<p>在这里 shell 将列出所有以字符串&rsquo;gre&rsquo;开头的已知命令。</p>

<p>二、命令行的历史 记录</p>

<p>通过按向上方向键，您可以向后遍历近来在该控制台下输入的命令。用向下方向键可以向前遍历。与 SHIFT
键连用的话，您还可以遍历以往在该控制台中的输出。您也可以编辑旧的命令，然后再运行。</p>

<p>按 后，shell 就进入&rdquo;reverse-i(ncremental)-search&rdquo;（向后增量搜索）模式。现在输入您要找的命令的首字母：</p>

<p>(reverse-i-search)`&rsquo;:. 敲入 &lsquo;i&rsquo;可能会变成：</p>

<p>(reverse-i-search)`i&rsquo;: isdnctrl hangup ippp0</p>

<p>如果您再按 键，上面的命令将再次执行。而如果您按了向右、向左方向键或 ，上面的命令将回到普通的命令行，这样您就可以进行适当编辑。</p>

<p>编辑命令行</p>

<p>通过光标和功能键（Home、End 等键），您可以浏览并编辑命令行，如果您需要，还可以用键盘的快捷方式来完成一般的编辑：<br />
l ：删除从光标到行尾的部分<br />
l ：删除从光标到行首的部分<br />
l ：删除从光标到当前单词结尾的部分<br />
l ：删除从光标到当前单词开头的部分<br />
l ：将光标移到行首<br />
l ：将光标移到行尾<br />
l ：将光标移到当前单词头部<br />
l ：将光标移到当前单词尾部<br />
l ：插入最近删除的单词<br />
l ：重复前一个命令最后的参数。</p>

<p>例如：您用命令 mkdir peter/pan/documents/tinkerbell 新建了一个目录，现在您向用命令&rsquo;cd&rsquo;进入该目录，您可以用 cd
!$，shell 将把前一个命令&rsquo;mkdir&rsquo;的参数添加到现在的&rsquo;cd&rsquo;后面。</p>

<p>当您更深入了解Linux后，将看到这些快捷方式在其他应用程序 下输入时，有时也有效，比如，在浏览器中的输入框中。</p>

<p>三、可用的 Shell 快捷方式</p>

<p>Red Hat Linux 带有不少快捷方式，其中一部分是 bash 原来就有的，而还有一些则是为您预先设置的（在后面您将看到如何设置）。</p>

<p>由于 home 目录是每位用户的活动中心，许多 Unix 对此有特殊的快捷方式。</p>

<p>&lsquo;~&lsquo;就是您的 home 目录的简写形式。我们假设您在其他目录，想把一个名为&rsquo;sometext&rsquo;的文件复制到您 home 目录下的
&lsquo;docs&rsquo;子目录中。除了输入：<br />
cp sometext /home/myusername/docs</p>

<p>您还可以用简写：</p>

<p>cp sometext ~/docs</p>

<p>理论上，这也可以应用在命令&rsquo;cd&rsquo;上。无论当前路径在哪里，cd ~ 将回到您的 home 目录。其实还可以简化，只要键入 cd ，就可以返回 home
目录了。</p>

<p>Red Hat Linux 为您提供了一些预先设置的快捷方式（称为&rsquo;别名&rsquo;，aliases），比如：<br />
l ll ：将执行&rsquo;ls -l -k&rsquo;（以长格式列出目录内容，包括一些文件属性，并以 KB 而不是 byte 为单位显示文件大小）<br />
l ls ：将执行&rsquo;ls -F &ndash;color=auto&rsquo;（列出目录内容，加上文件类型标识，并使用颜色）</p>

<p>现在，您应该对 shell 及一些快捷方式有了进一步的了解，下面我们来看看除了应用一些简单的命令，shell 还能作什么。<br />
第三篇：命令的排列／命令的任务调度／命令 的替换</p>

<p>一、命令的排列</p>

<p>现在您将看到一些常用的命令排列。您可能想在一行中给出所有命令，然后就可以把注意力 转移到其他地方。没问题，shell
允许您在不同的命令之间，放上特殊的排列字符(queuing characters) 。这儿将介绍最常用的两种。</p>

<p>请注意，为了看起来更清楚，我在这些字符两旁加了空格。而在实际应用中，您不一定要这么做，&rsquo;ls -a ; du -hs&rsquo;和&rsquo;ls -a;du
-hs&rsquo;的效果是一样的。</p>

<p>command1 ; command2<br />
先执行 command1 ，不管 command1 是否出错，接下来执行 command2 。</p>

<p>例如：<br />
ls -a ; du -hs</p>

<p>将先在屏幕上列出目录中的所有内容，然后列出所有目录及其子目录所占磁盘大小。<br />
command1 &amp;&amp; command2</p>

<p>只有当 command1 正确运行完毕后，才执行 command2 。</p>

<p>例如：<br />
ls -a bogusdir &amp;&amp; du -hs<br />
将返回 ls: bogusdir: No such file or directory
，而&rsquo;du&rsquo;则根本没有运行（这是因为您没有&rsquo;bogusdir&rsquo;目录）。如果您将符号换成了&rsquo;;&lsquo;，&rsquo;du&rsquo;将被执行。</p>

<p>为了进一 步说明&rsquo;;&lsquo;和&rsquo;&amp;&amp;&lsquo;的区别，及一般命令排列的用处，下面举一个经典的例子：Linux 内核的编译和安装。</p>

<p>要 编译、安装 Linux ，您需要执行一串命令：&rsquo;make dep&rsquo;、&rsquo;make clean&rsquo;、&rsquo;make bzImage&rsquo;、&rsquo;make
modules&rsquo;、&rsquo;make modules_install&rsquo;和&rsquo;make
install&rsquo;。如果要等一个命令完成后，再输入下一个，再等，再输入，……，那就太麻烦了。另一方面，每个命令只有当前面的命令都正确执行完毕后，才
能开始执行。如果您用&rsquo;;&lsquo;来排列命令，则即使有命令执行失败，后面的也照常运行，最后，您可能在&rsquo;/boot&rsquo;目录下得到一个有问题的内核映像
(p_w_picpath)。而用&rsquo;&amp;&amp;&lsquo;：</p>

<p>make dep &amp;&amp; make clean &amp;&amp; make bzImage &amp;&amp; make modules &amp;&amp; make modules_install
&amp;&amp; make install</p>

<p>不需要中途打断，就可以编译内核及其模 块，并完成后面的安装。<br />
二、命令的任务调度</p>

<p>当您在终端里运行一个命令或开启一个程序时，终端要等到命令或程序运行完 毕后，才能再被使用。在 Unix
中，我们称这样的命令或程序在前台(foreground)运行。如果您想在终端下运行另一个命令，则需要再打开一个新的终端。</p>

<p>但 这里还有一个更优雅的办法，称为任务调度(jobbing)或后台(backgrounding)。当您运用任务的调度或将命令置于后台，终端就立即解放
了，这样一来，终端立即就可以接受新的输入。为实现这样的目的，您只需在命令后面添加一个 &amp; ：</p>

<p>gqview &amp;</p>

<p>告诉 shell 将 图片 查看器&rsquo;GQview&rsquo;放到后台去执行（即当成 job 来运行）。</p>

<p>命令 jobs 将告诉您，在这个终端窗口中，运行着哪些命令与程序：</p>

<p>jobs</p>

<p>[1]+ Running gqview &amp;</p>

<p>当您要关闭终端窗口时，这一点就很重要，因为关闭终端将导致所有在其中运行的任务都将被中止，在此例中，如果您关闭了终 端，由这个终端开启的 GQview
程序也将被关闭。</p>

<p>但如何将前台运行的一个程序放到后台去？没问题：</p>

<p>gqview</p>

<p>[2]+ Stopped gqview</p>

<p>bg</p>

<p>[2]+ gqview &amp;<br />
组合键 将挂起终端中正在运行的程序，然后您就可以用 bg 命令将其放到后台去执行。</p>

<p>请注意，在后台运行图形应用程序
有时候是有用处的，这样可以在终端下显示这个程序的出错信息，虽然这对您可能没有直接的帮助，当如果碰到了麻烦，向别人询问时，这些出错提示就有用武之地 了。</p>

<p>一些图形程序，很可能还处在测试期(Beta)，尽管在后台执行，也会在终端中输出一些信息。如果您对此不满，可以用 下面命令：</p>

<p>command &amp;&gt;/dev/null &amp;</p>

<p>这不仅将程序送到后台执 行，还将其输出发到&rsquo;/dev/null&rsquo;文件。&rsquo;/dev/null&rsquo;是系统的&rdquo;碎纸机&rdquo;
(shredder)，所有送到那里的信息都将消失殆尽。</p>

<p>三、命令的替换</p>

<p>命令替换(Command substitution)是一项很实用的功能。我们假设，您想看看 XFree86 文档中的
&lsquo;README.mouse&rsquo;文件，但您不知道这个文件的位置。但您是位机灵的用户，已经听说了&rsquo;locate&rsquo;命令，也安装了&rsquo;slocate&rsquo;包，您 就可以用：</p>

<p>locate README.mouse</p>

<p>发现那个文件在&rsquo;/usr/X11R6/lib/X11
/doc&rsquo;。现在您就可以在终端里用&rsquo;less&rsquo;或在文件管理器中进入那个目录然后读取文件。而命令替换可以给您带来一些便捷：</p>

<p>less $(locate README.mouse)</p>

<p>一步到位。命令&rsquo;locate README.mouse&rsquo;的输出(=
/usr/X11R6/lib/X11/doc/README.mouse)作为&rsquo;less&rsquo;的参数，然后就可以显示文件内容了。</p>

<p>这种机制的语法是：</p>

<p>command1 $(command2)</p>

<p>除了&rsquo;$( )&lsquo;，您还可以用后引号(backquote)：</p>

<p>command1 <code>command2</code></p>

<p>这样虽然可以 减少输入，但可读性差，而且很容易就和没有替换功能的一般单引号混淆。我更欣赏前一种方法，但这最终起决于您。</p>

<p>这里有另外一个例 子。我们假设，您打算结束一个名为&rsquo;rob&rsquo;的程序。您先得用命令&rsquo;pidof&rsquo;找出相应的进程号(Process ID)，然后以这个 PID
为参数，运行&rsquo;kill&rsquo;命令，这样就可以结束&rsquo;rob&rsquo;程序。除了用：</p>

<p>pidof rob</p>

<p>567</p>

<p>kill 567</p>

<p>您还可以试试：</p>

<p>kill <code>pidof rob</code></p>

<p>怎么 样，效率有所提高吧？<br />
在下一篇中，我将接着介绍 shell 的另外两种实用的机制：文件名匹配、输出重定向。</p>

<p>第四篇：文件名匹配／输出重定向</p>

<p>一、文件 名匹配</p>

<p>文件名匹配使得您不必一一写出名称，就可以指定多个文件。您将用到一些特殊的字符，称为通配符(wildcards)。</p>

<p>假设您想用&rsquo;rm&rsquo;命令删除目录下所有以字符串&rsquo;.bak&rsquo;结尾的文件。除了在&rsquo;rm&rsquo;后跟上所有文件名作为参数，您还可以用通配符&rsquo;*&lsquo;：</p>

<p>rm *.bak</p>

<p>&lsquo;<em>&lsquo;可匹配一个或多个字符。在本例中，您告诉 shell 将命令&rsquo;rm&rsquo;的参数扩展到&rdquo;所有以&rsquo;</em>.bak&rsquo;结尾的文件&rdquo;，shell
就将扩展后的参数告诉&rsquo;rm&rsquo;命令。</p>

<p>您将看 到，shell 在命令执行前，就将读取并解释命令行。正是因为这个，您才可以将通配符用于 shell 命令的参数中。</p>

<p>让我们更 进一步地来认识通配符&rsquo;*&lsquo;。假定您有个目录，其中含文件&rsquo;124.bak&rsquo;、&rsquo;346.bak&rsquo;及&rsquo;583.bak&rsquo;。您想只保留文件
&lsquo;583.bak&rsquo;，可以用：</p>

<p>rm <em>4</em>.bak</p>

<p>shell 就将&rsquo;<em>4</em>.bak&rsquo;扩展成&rdquo;所有含&rsquo;4&rsquo;并以&rsquo;.bak&rsquo;结尾的字符串&rdquo;。</p>

<p>注意到 rm 4*.bak 无法工作，因为这匹配的是以&rsquo;4&rsquo;开头的文件。由于目录中没有这样的文件，shell
将这个模式扩展为空的字符串，故&rsquo;rm&rsquo;将返回出错信息：</p>

<p>rm: cannot remove `4*.bak&rsquo;: No such file or directory</p>

<p>如果您想保留文
件&rsquo;345.bak&rsquo;，而删除&rsquo;124.bak&rsquo;和&rsquo;583.bak&rsquo;。这看起来有些难度，因为被删文件的名称除了后缀其他都不同。但幸运的是，您可以用
不含有来指定文件：</p>

<p>rm *[!6].bak</p>

<p>这将被读为：除了以&rsquo;6.bak&rsquo;结尾的文件，删除其他所 有以&rsquo;.bak&rsquo;结尾的文件。您必须将取反号(negation sign)与取反字符（这里是
6）放到括号中，不然的话，shell 会将惊叹号(exclamation mark)解释成历史记录替换的开始(the beginning of a
history substitution)。取反号在本篇介绍的所有匹配模式中都有效。</p>

<p>请注意：通配符&rsquo;*&lsquo;与取反号连用，很容易产生问题。猜猜</p>

<p>rm <em>[!6]</em>.bak</p>

<p>表示什么？这个命令将删除所有文件，甚至包括名称中包含&rsquo;6&rsquo;的文件。如果您将通配 符&rsquo;*&lsquo;放到了取反号前面和后面，实际上取反号将失效，因为 shell
将其解释为&rdquo;所有名称中任何位置都不含该字符的文件&rdquo;。在我们的例子里，只有文件&rsquo;666.bak&rsquo;不符合该模式。</p>

<p>第二个通配符是 问号(question
mark)：&rsquo;?&lsquo;。在匹配时，一个问号只能代表一个字符。为了示范其用途，我们在上例的假设中添加两个新文件：&rsquo;311.bak~&lsquo;和
&lsquo;some.text&rsquo;。现在，列出所有在点号后有四个字符的文件：</p>

<p>ls *.????</p>

<p>问号通配符能够有效地避 免上面提到的&rsquo;取反号陷阱&rsquo;(negation trap)：</p>

<p>rm <em>[!4]?.</em></p>

<p>将扩展成&rdquo;所有除了点号前 倒数第二个字符为&rsquo;4&rsquo;的文件&rdquo;，也就是只保留文件&rsquo;346.bak&rsquo;。</p>

<p>您可能会问，有没有其他匹配方式？到目前为止，您只看到了 在指定位置匹配唯一字符的方法。但其实您也可以这样：</p>

<p>ls [13]*</p>

<p>将列出所有以字符&rsquo;1&rsquo;或&rsquo;3&rsquo;开头的文
件；在我们的例子中，文件&rsquo;124.bak&rsquo;、&rsquo;311.bak~&lsquo;和&rsquo;346.bak&rsquo;匹配。注意到您必须用中括号将匹配的模式括起来，否则模式只匹配
以字符串&rsquo;13&rsquo;开头的文件。</p>

<p>接下来，您将高兴地看到还可以定义匹配的范围：</p>

<p>ls <em>[3-8]?.</em></p>

<p>将列出所有点号前倒数第二个字符落在&rsquo;3&rsquo;到&rsquo;8&rsquo;范围的文件。在我们的例子中，匹配的文件是 &lsquo;346.bak&rsquo;和&rsquo;583.bak&rsquo;。</p>

<p>二、引用 shell 的特殊字符<br />
但是，上面的那些机制存在一个缺 点：shell 总在命令执行前，试着进行扩展。有时候，会变得很棘手：</p>

<p>l 文件名包含特殊字符。假设您在那个目录中还有一个名为&rsquo;!56.bak&rsquo;的文件。下面试图进行模式匹配：</p>

<p>rm !*</p>

<p>rm</p>

<p>rm: too few arguments</p>

<p>shell 将&rsquo;!*&lsquo;解释成历史记录的替换（加入前一个命令的所有参数），而不是匹配方式。</p>

<p>l 命令本身带特殊字符作参数。一些 Linux 下的命令行工具，比如 (e)grep、sed、awk、find 及 locate
，都使用自己的正则表达式(regular expressions)。这些表达式与模式匹配看起来惊人地相似，但在某些地方又有所不同。</p>

<p>但为了使这些特殊命令生 效，shell 就不能先将其当作模式匹配来解释：</p>

<p>find . -name [1-9]* -print</p>

<p>find: paths must precede expression<br />
应该是：</p>

<p>find . -name &lsquo;[1-9]*&rsquo; -print</p>

<p>./346.bak</p>

<p>./124.bak</p>

<p>./583.bak</p>

<p>./311.bak~</p>

<p>您可以通过反斜线(back slash)来引用特殊字符，比如 ! 、$ 、? 或空格：</p>

<p>ls \!*</p>

<p>!56.bak</p>

<p>或者用（单）引号：</p>

<p>ls &lsquo;!&rsquo;*</p>

<p>!56.bak</p>

<p>请注意，要看清楚引号应该放在什么位置。命令 ls &lsquo;!<em>&rsquo; 将查找名为&rsquo;!</em>&lsquo;的文件，这是由于通配符也在引号间，所以只能依照字面来解释。</p>

<p>三、输出重定向</p>

<p>Unix 的理念是汇集许多小程序，每个东东都有特殊的专长。复杂的任务不是由大型 软件 完成，而是运用 shell
的机制，组合许多小程序共同完成。重定向就在其中发挥着重要的作用。</p>

<p>1、在多个命令间重定向</p>

<p>这要通过管道(pipe)，由管道符号｜来标识。语法是：</p>

<p>command1 | command2 | command3 等等</p>

<p>这种格式您一定已经见到过了。管道经常将一个程序的输出送到&rsquo;more&rsquo; 或&rsquo;less&rsquo;来阅读。</p>

<p>ls -l | less</p>

<p>其中，第一个命令提供目录内容，第二个则将其以翻页的 方式显示。更复杂的例子如：</p>

<p>rpm -qa | grep ^x | less</p>

<p>第一个命令给出所有已安 装的 RPM 包，第二个则将其过滤(filter：&rsquo;grep&rsquo;)，只剩下以&rsquo;^x&rsquo;开头的包，第三个命令则将结果以翻页的方式显示。</p>

<p>2、重定向至文件</p>

<p>有时，您希望将命令的输出结果 保存 到文件中，或以文件内容作为命令的参数。这可以通过&rsquo;&gt;&lsquo;和&rsquo;</p>

<p>command &gt; file</p>

<p>将 command 的输出保存到 file 中，这将覆盖 file 中的内容：</p>

<p>ls &gt; dirlist</p>

<p>将当前目录的内容保存到&rsquo;dirlist&rsquo;文件。</p>

<p>command &lt; file</p>

<p>将 file 内容作为 command 的输入：</p>

<p>sort &lt; dirlist &gt; sdirlist</p>

<p>将文件&rsquo;dirlist&rsquo;的内容送到命令&rsquo;sort&rsquo;，然后再将排序 后的结果送到文件&rsquo;sdirlist&rsquo;。当然，您也可以一步到位：</p>

<p>ls | sort &gt; sdirlist</p>

<p>一种特殊的方式是&rsquo;command 2&gt; file&rsquo;。这将 command 执行的出错信息送到 file 中。这个您到时候会需要……</p>

<p>另一种操作符是&rsquo;&gt;&gt;&lsquo;，这将输出添加到已存在的文件中：</p>

<p>echo &ldquo;string&rdquo; &gt;&gt; file</p>

<p>将 string 加到文件 file 中。这是不打开文件而完成编辑的好办法！</p>

<p>但是，&rdquo;操作符都有一个重要的限制：</p>

<p>command &lt; file1 &gt; file1</p>

<p>将删除 file1 的内容，而</p>

<p>command &lt; file1 &gt;&gt; file1</p>

<p>却可以很 好地工作，将加工过的 file1 内容加回到文件中。</p>

<p>是不是有点多？;-) 不必惊慌，您完全可以按照自己的速度，一步步地来学习。别忘了，实践是最好的学习方法……<br />
第五篇：bash  配置 文件／提示符／改变 $PATH</p>

<p>一、bash 配置文件</p>

<p>在您的 home 目录下，运行</p>

<p>ls .bash*</p>

<p>您将看到这些文件：</p>

<p>l .bash_history ：记录了您以前输入的命令，<br />
l .bash_logout ：当您退出 shell 时，要执行的命令，</p>

<p>l .bash_profile ：当您登入 shell 时，要执行的命令，</p>

<p>l .bashrc ：每次打开新的 shell 时，要执行的命令。</p>

<p>请注意后两个的区别：&rsquo;.bash_profile&rsquo;只在会话开始时被读取一次，而&rsquo;.bashrc&rsquo;则每次打 开新的终端（如新的 xterm
窗口）时，都要被读取。按照传统，您得将定义的变量，如 PATH ，放到&rsquo;.bash_profile&rsquo;中，而象
aliases（别名）和函数之类，则放在&rsquo;.bashrc&rsquo;。但由于&rsquo;.bash_profile&rsquo;经常被设置成先读取&rsquo;.bashrc&rsquo;的内容，您如
果图省事的话，就把所有配置都放进&rsquo;.bashrc&rsquo;。</p>

<p>这些文件是每一位用户的设置。系统级的设置存储在&rsquo;/etc
/profile&rsquo;、&rsquo;/etc/bashrc&rsquo;及目录&rsquo;/etc/profile.d&rsquo;下的文件中。但您得习惯用各自的配置文件：编辑不需要
&lsquo;root&rsquo;权限，还可以使您的设置更有个性。当系统级与用户级的设置发生冲突时，将采用用户的设置。</p>

<p>读取 &lsquo;.bashrc&rsquo;的内容，您如果要省点事的话，就把您所有的配置都放进&rsquo;.bashrc&rsquo;。</p>

<p>上面的这些文件是每位用户的设置，系
统级的设置存储在&rsquo;/etc/profile&rsquo;、&rsquo;/etc/bashrc&rsquo;及目录&rsquo;/etc/profile.d&rsquo;下的文件中。您最好习惯使用各自的配
置文件：编辑不需要&rsquo;root&rsquo;权限，还可以使您的设置更具个性。当系统级与用户级的设置发生冲突时，将优先采用用户的设置。</p>

<p>二、 提示符<br />
每次当您打开一个控制台(console)或 xterm 时，最先看到的就是提示符(prompt)，类似于：<br />
account@hostname ~ $</p>

<p>在默认设置下，提示符将显示您的用户名、主机名（默认是&rsquo;localhost&rsquo;）、当前所在目录（在 Unix 中，&rsquo;~&lsquo;表示您的 home 目录）。</p>

<p>按照传统，最后一个字符可以标识您是普通用户（$），还是&rsquo;root&rsquo;（#）。<br />
您可以通过 $PS1 变量来设置提示符。命令<br />
echo $PS1</p>

<p>将显示当前的设定。其中可用字符的含义在 man bash 的&rsquo;PROMPTING&rsquo;部分有说明。</p>

<p>如何才能完成理想的设置呢？对于健忘的初学者来讲，默认设定有些不友好，因为提示 符只显示当前目录的最后一部分。如果您看到象这样的提示符<br />
tom@localhost bin $</p>

<p>您的当前目录可能是 &lsquo;/bin&rsquo;、&rsquo;/usr/bin&rsquo;、&rsquo;/usr/local/bin&rsquo;及&rsquo;/usr/X11R6/bin&rsquo;。当然，您可以用<br />
pwd （输出当前目录，print working directory）</p>

<p>能不能叫 shell 自动告诉您当前目录呢？</p>

<p>当然可以。这里我将提到的设定，包括提示符，大都包含在文件&rsquo;/etc/bashrc&rsquo;中。您可以通过编辑各自 home
目录下的&rsquo;.bash_profile&rsquo;和&rsquo;.bashrc&rsquo;来改变设置。</p>

<p>在 man bash
中的&rsquo;PROMPTING&rsquo;部分，对这些参数(parameter)有详细说明。您可以加入一些小玩意，如不同格式的当前时间，命令的历史记录号，甚至不 同的颜色。</p>

<p>在&rsquo;~/.bashrc&rsquo;中，我喜欢的设定是：</p>

<p>PS1=&rdquo;\[\033[1m\][\w]\[\033[0m\] &ldquo;</p>

<p>&lsquo;root&rsquo;在&rsquo;~/.bashrc&rsquo;中的设定 是：</p>

<p>PS1=&rdquo;\[\033[0;31m\][\w]\[\033[0m\] &ldquo;</p>

<p>这样我得到的提示符就是：</p>

<p>[/usr/bin]</p>

<p>当用&rsquo;root&rsquo;时，变 成：<br />
[/usr/bin]</p>

<p>我已经除掉了主机名和用户名，因为我用不着这些。但我首先想一眼就能看出我的身份是普通用户还
是&rsquo;root&rsquo;。注意到，普通用户的提示符可以是黑底白字，或白底黑字。<br />
要在终端上获得恰当的颜色调配， 您可以编辑下面这个脚本color ，赋予执行 权限 （chmod +x color），然后再运行。<br />
#!/bin/bash</p>

<h1 id="this-file-echoes-a-bunch-of-color-codes-to-the">This file echoes a bunch of color codes to the</h1>

<h1 id="terminal-to-demonstrate-what-s-available-each">terminal to demonstrate what&rsquo;s available. Each</h1>

<h1 id="line-is-the-color-code-of-one-forground-color">line is the color code of one forground color,</h1>

<h1 id="out-of-17-default-16-escapes-followed-by-a">out of 17 (default + 16 escapes), followed by a</h1>

<h1 id="test-use-of-that-color-on-all-nine-background">test use of that color on all nine background</h1>

<h1 id="colors-default-8-escapes">colors (default + 8 escapes).</h1>

<p>T=&lsquo;gYw&rsquo; # The test text<br />
echo -e &ldquo;\n 40m 41m 42m 43m\<br />
44m 45m 46m 47m&rdquo;;<br />
for FGs in &lsquo; m&rsquo; &lsquo; 1m&rsquo; &lsquo; 30m&rsquo; &lsquo;1;30m&rsquo; &lsquo; 31m&rsquo; &lsquo;1;31m&rsquo; &lsquo; 32m&rsquo; \<br />
&lsquo;1;32m&rsquo; &lsquo; 33m&rsquo; &lsquo;1;33m&rsquo; &lsquo; 34m&rsquo; &lsquo;1;34m&rsquo; &lsquo; 35m&rsquo; &lsquo;1;35m&rsquo; \<br />
&rsquo; 36m&rsquo; &lsquo;1;36m&rsquo; &lsquo; 37m&rsquo; &lsquo;1;37m&rsquo;;<br />
do FG=${FGs// /}<br />
echo -en &ldquo; $FGs \033[$FG $T &ldquo;</p>

<p>for BG in 40m 41m 42m 43m 44m 45m 46m 47m;<br />
do echo -en &ldquo;$EINS \033[$FG\033[$BG $T \033[0m&rdquo;;<br />
done<br />
echo;<br />
done<br />
echo</p>

<p>一种更适当的设定：<br />
PS1=&rdquo;\u: \w\\$ &ldquo;</p>

<p>这样，提示符就变成：</p>

<p>user_name: /usr/bin$</p>

<p>您可以通过 命令 export 来测试不同的设置（比如，export PS1=&rdquo;\u: \w\\$
&ldquo;）。如果找到了适合的提示符，就将设置放到您的&rsquo;.bashrc&rdquo;中。这样，每次打开控制台或终端窗口时，都会生效。</p>

<p>您甚至可 以给提示符设定主题(theme)，也就是搭配不同的颜色，使其看起来象很棒的 ol<br />
的 C64 提示符。如果您对此感兴趣，可以看一下</p>

<p>Bashish（ <a href="http://hem.passagen.se/arnognulf/index2.html">http://hem.passagen.se/arnognulf/index2.html</a>  ）。<br />
三、改变 $PATH<br />
&rsquo;$PATH&rsquo;与&rsquo;$PS1&rsquo;一样，也是环境变量。输入<br />
set</p>

<p>将列出所有当前定义的环境变量。</p>

<p>您看到的这些环境变量在 shell 的配置文件中定义，可能是用户自己的配置文件，也可能是由&rsquo;root&rsquo;通过&rsquo;/etc&rsquo;下面的系统级文件定义的。如果您使用 X
，更多的一些变量将由 X 、您的窗口管理器或桌面环境的启动文件配置。<br />
如果对这些设置不很清楚，您暂时最好不要随便改动。了解如何改变 $PATH 变量很有用，因为这个变量决定了 shell
将到哪些目录中寻找命令或程序。如果要执行的命令的目录在 $PATH
中，您就不必输入这个命令的完整路径，直接输入命令就可以了。一些第三方软件没有将可执行文件放到 Linux 的标准目录中。因此，将这些非标准的安装目录添加到
$PATH 是一种解决的办法。此外，您也将看到如何处理一般的环境变量。</p>

<p>首 先，作为惯例，所有环境变量名都是大写。由于 Linux 区分大小写，这点您要留意。当然，您可以自己定义一些变量，如&rsquo;$path&rsquo;、&rsquo;$pAtH&rsquo;，但
shell 不会理睬这些变量。</p>

<p>第二点是变量名有时候以&rsquo;$&lsquo;开头，但有时又不是。当设置一个变量时，您直接用名称，而不需要加&rsquo;$&lsquo;：</p>

<p>PATH=/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin<br />
要获取变量值的话，就要在变量名前加&rsquo;$&lsquo;：<br />
echo $PATH<br />
/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin</p>

<p>否则的话，变量名就会被当作普通文本了：<br />
echo PATH<br />
PATH<br />
处理 $PATH 变量要注意的第三点是：您不能只替换变量，而是要将新的字符串添加到原来的值中。在大多数情况下，您不能用&rsquo;PATH=/some
/directory&rsquo;，因为这将删除 $PATH 中其他的所有目录，这样您在该终端运行程序时，就不得不给出完整路径。所以，只能作添加：</p>

<p>PATH=$PATH:/some/directory<br />
这样，PATH 被设成当前的值（以 $PATH 来表示）＋新添的目录。<br />
到目前为止，您只为当前终端设置了新的 $PATH 变量。如果您打开一个新的终端，运行 echo $PATH ，将返回旧的 $PATH
值，而看不到您刚才添加的新目录。因为您先前定义的是一个局部环境变量（仅限于当前的终端）。<br />
要定义一个全局变量，使在以后打开的终端中生 效，您需要将局部变量输出(export)，可以用&rsquo;export&rsquo;命令：<br />
export PATH=$PATH:/some/directory</p>

<p>现在如果您打开一个新的终端，输入 echo $PATH ，也能看到新设置的 $PATH
了。请注意，命令&rsquo;export&rsquo;只能改变当前终端及以后运行的终端里的变量。对于已经运行的终端没有作用。</p>

<p>为了将目录永久添加到您的 $PATH ，只要将&rsquo;export&rsquo;的那行添加到您的&rsquo;.bash_profile&rsquo;文件中。</p>

<p>请不 要在&rsquo;.bashrc&rsquo;中设置 PATH ，否则会导致 PATH 中目录的意外增长。您每次打开一个新的 shell
，&rsquo;.bashrc&rsquo;都会作用。所以如果在该文件中添加目录，您每次打开一个终端，目录又会被添加。这将导致 PATH 变量由于目录复制，不断地增长。</p>

<p>第六篇：命令的别名、Shell 函数／从这里出发／Shell 常见问题<br />
一、命令的别名、Shell 函数</p>

<p>记住所有的命令及各自带的可选项，然后每次一一输入，这确实有点枯燥。但幸运的是，您可以为常用命令定义快捷方式。这些快捷方
式可以用较简单的命令别名(alias)，或复杂一些的 shell 函数的语法来定义。</p>

<p>1、命令的别名</p>

<p>例如，我用下面的命令来上传 MUO 中的文件：</p>

<p>rsync -e ssh -z -t -r -vv &ndash;progress /home/tom/web/muo/rsmuo/docs
muo:/www/mandrakeuser/docs</p>

<p>显然，如果每次都要逐一输入，那我早晚会变成木头。因此我在&rsquo;~/.bashrc&rsquo;中定义了别名：</p>

<p>alias upmuo=&lsquo;rsync -e ssh -z -t -r -vv &ndash;progress /home/tom/web/muo/rsmuo/docs
muo:/www/mandrakeuser/docs&rsquo;</p>

<p>现在，我只要输入 upmuo 就可以完成上传任务了。</p>

<p>定义别名的语法是：</p>

<p>alias shortcut=&lsquo;command&rsquo;</p>

<p>命令中有空格的话 ，就需要用引号（如在命令与可选项间就有空格）。请注意，您可以用单引号或双引号，但他们是有区别的。</p>

<p>单引号将****其中的所有
字符的特殊含义，而双引号中的&rsquo;$&lsquo;（参数替换）和&rsquo;`&lsquo;（命令替换）是例外。这意味着，如果您想在别名中应用变量或命令的替换，就得用双引号。看一下上
面的例子，我在&rsquo;.bashrc&rsquo;中定义了一个称为 MUOHOME 的变量：</p>

<p>export MUOHOME=$HOME/web/muo/rsmuo/docs</p>

<p>要在上面的别名中用上这个变量，我就必须用双引号：<br />
alias upmuo=&ldquo;rsync -e ssh -z -t -r -vv &ndash;progress $MUOHOME
muo:/www/mandrakeuser/docs&rdquo;</p>

<p>否则，别名将查找一个名为&rsquo;$MUOHOME&rsquo;的目录或文件。</p>

<p>您可以用&rsquo;alias&rsquo;在命令行快速地创建别名，或将命令放到各自的&rsquo;~/.bashrc&rsquo;，或放到系统级的&rsquo;/etc/profile.d
/alias.sh&rsquo;中（而在 Mandrake Linux 8 以前的版本里，用的是&rsquo;/etc/bashrc&rsquo;）。要删除一个别名，只要输入：unalias
alias 。运行 alias 将列出您系统中所有定义的别名。</p>

<p>如果看一下&rsquo;~/.bashrc&rsquo;和&rsquo;/etc/profile.d/alias.sh&rsquo;，您会发
现系统已经定义了一些别名。您可以为同一个命令定义多个别名。当然，您得先确认别名与其他程序名不同，比如象 alias rm=&lsquo;ls -l&rsquo;
这样的就不能工作。您可以在命令行输入这些快捷方式，测试一下。如果 shell 找不到相同名称的命令，那您就可以将其用作别名了。</p>

<p>以下别名可能有用（不要忘了引号！） ：<br />
l alias rpmq=&lsquo;rpm -qa | grep&rsquo; ：现在 rpmq string 就将列出所有名称中含有 string 的已安装 RPM 包，</p>

<p>l alias ls=&lsquo;ls -ho &ndash;color | more&rsquo; ：ls 将以彩色分页方式列出文件，文件大小以 KB为单位，</p>

<p>l alias use=&lsquo;du &ndash;max-depth=1 | sort -n | more&rsquo; ：use 将子目录按大小排好，并以分页方式列出，</p>

<p>目录的别名 也可以是可移动的介质：alias dlm=&lsquo;/mnt/cdrom/RedHat/RPMS/&rsquo; 。<br />
提示：将有相似功能的别名以相同字母 开头，比如将所有目录的别名以&rsquo;d&rsquo;作开头，这样有助于记忆。</p>

<p>我相信，您将会用到这些功能。</p>

<p>2、Shell 函数</p>

<p>写 shell 函数涉及到了 shell 脚本，这超出了我们讨论的范围（也不在我的掌握范围之内 ;-)）。事实上，shell 函数属于 shell
脚本，但可以在同一 shell 下被预加载(preload)和执行（而一般的 shell 脚本至少要打开一个 sub-shell）。</p>

<p>通过 shell 函数，您可以做很多 aliases 无法完成的事情。下面就是一个例子：<br />
function apros() { apropos $1 | egrep -v &lsquo;(3|\(n\)&lsquo;; }</p>

<p>定义了一个新命令，称为&rsquo;apros&rsquo;。apros name 将先执行&rsquo;apropos name&rsquo;（即在 man page
中搜索命令），然后将得到的输出送到管道（|），接着用&rsquo;egrep&rsquo;过滤，排除第&rsquo;3&rsquo;和第&rsquo;n&rsquo;章节的 man page
，这个命令可能没什么大用处，但可以整理&rsquo;apropos&rsquo;命令的输出。</p>

<p>函数允许您在函数内部任何位置，使用运行时的 参数。而别名，则只允许在命令行尾放一个参数（比如前面的别名&rsquo;rpmq&rsquo;）。</p>

<p>&rsquo;$1&rsquo;就是位置参数(positional parameter)，表示函数第一个参数的位置标识符。依此类推，还有&rsquo;$2&rsquo;等。</p>

<p>function apros() { apropos $1 | egrep -v &ldquo;\($2&rdquo;; }</p>

<p>如果您这样运行&rsquo;apros&rsquo;命令：</p>

<p>apros name man_section_number</p>

<p>这个命令将搜索标题中含 name 的 man pages ，但排除 man_section_number 部分：<br />
apros menu 3</p>

<p>将搜索标题含&rsquo;menu&rsquo;的 man page ，但排除第三章节（关于编程的）。注意到您得引用（quote） 两次，而且还用到了双引号：</p>

<p>l 您必须引用&rsquo;egrep&rsquo;的搜索模式，这样可以不至于被 shell 误解。</p>

<p>l 您必须用双引号，这样第二个参数才能被正确解释。<br />
l 您必须引用圆括号，这样使&rsquo;egrep&rsquo;按字面意思对待对待参数。</p>

<p>是不是有点意思？;-)</p>

<p>shell 函数的处理类似于别名：将其放到您的&rsquo;.bashrc&rsquo;文件，这样就能永久生效了。</p>

<p>二、从这里出发</p>

<p>我们谈到的只是 shell 的一个开头。掌握了shell 脚本，您就可以做很多事情，比如将任务自动化，纠正别人脚本中的错误，按照您的习惯定制 Linux
系统。如果您打算学习某种复杂的编程语言，那 shell 脚本也是一个很好的开端，因为基本概念都是类似的。</p>

<p>转载于:<a href="https://blog.51cto.com/yueyuanyuan/352727">https://blog.51cto.com/yueyuanyuan/352727</a></p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>