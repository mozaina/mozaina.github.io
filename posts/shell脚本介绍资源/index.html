<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell脚本介绍资源 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell脚本介绍资源 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell脚本介绍资源">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E8%84%9A%E6%9C%AC%E4%BB%8B%E7%BB%8D%E8%B5%84%E6%BA%90/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell脚本介绍资源</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt;
<img src="https://img.it610.com/image/info8/35bf71b4b7ad4a72bcb9c6561b5679b1.jpg" alt="hot3.png" /></p>

<p><strong>导语 ：</strong>
在Linux环境下，我们一般通过Shell来与内核交流，并最终实现我们想要使用计算机资源的目的。由于Linux的开放性特点，使得在Linux下对Shell的选择也很多，CentOS
6.3系统中可以使用的Shell有/bin/sh、/bin/bash、/bin/tcsh、/bin/csh这几种，/etc/shells文件说明了当前系统有哪些可用的Shell。不同的Shell有不同的特点以及操作方式，我们这里以CentOS默认使用的Shell为讲解案例即Bash。</p>

<p>Linux下使用Shell处理文本时最常用的工具：</p>

<p>CentOS
6.3默认通过/etc/profile文件定义了HISTSIZE=1000，也就是最多可以记录最近所使用的1000条命令，当有第1001条命令执行时第一条命令会被覆盖，执行history
-c命令可以清空所有的历史记录。</p>

<p>记录命令历史的除了可以查看历史记录外，还可以在需要时直接调用历史记录再次执行该命令：</p>

<p>1．上下键翻阅历史命令，找到合适的命令后直接回车即可执行。</p>

<p>2. 输入!string调用命令历史（string为关键字），如!vim将调用最后一次执行的以vim开头的命令。或者通过 <strong>!n来准确定位历史记录</strong>
，如!242将直接调用命令历史的第242条记录 <strong>并执行。</strong></p>

<p>3. 通过 <strong>Ctrl+r快捷键打开搜索功能</strong> ，接着输入关键字即可在命令历史中搜索相关命令， <strong>回车完成执行操作</strong> 。如果没有搜索到适合的命令
<strong>按ESC键退出搜索</strong> 。</p>

<p>标准输入的文件描述符为0，标准输出的文件描述符为1，错误输出的文件描述符为2。但有时我们需要改变这样的标准输入与输出方式，Linux中我们可以使用重定向符（、&lt;&gt;、|）重新定义输入与输出。</p>

<p>管道符|的使用案例，使用ifconfig eth0 | grep ‘inet
addr’命令过滤包含IP地址的行，ifconfig本身会输出大量网络接口的信息，由于这里使用了管道符号（|）所以ifconfig命令的所有输出都将作为grep命令的输入内容，最终实现过滤包含IP地址的行。</p>

<p>以下通过几个简单的实例演示重定向的使用方法：</p>

<p><a href="https://img.it610.com/image/info8/4be7b3a567124dc8a0d4f40c04d6043c.jpg"><img src="https://img.it610.com/image/info8/4be7b3a567124dc8a0d4f40c04d6043c.jpg" alt="Shell脚本介绍（资源）_第1张图片" /></a></p>

<p><strong>Bash快捷键</strong></p>

<p><a href="https://img.it610.com/image/info8/40f049e7c1e248e4a2aebf366e1f2d57.jpg"><img src="https://img.it610.com/image/info8/40f049e7c1e248e4a2aebf366e1f2d57.jpg" alt="Shell脚本介绍（资源）_第2张图片" /></a></p>

<p><strong>花括号{}的使用</strong></p>

<p><a href="https://img.it610.com/image/info8/b7be1901fb3043039828c8b8d381b7a1.jpg"><img src="https://img.it610.com/image/info8/b7be1901fb3043039828c8b8d381b7a1.jpg" alt="Shell脚本介绍（资源）_第3张图片" /></a></p>

<h1 id="一-shell编程概念">一、SHELL编程概念</h1>

<p>1） <strong>SHELL、SHELL编程、SHELL脚本、SHELL命令区别</strong></p>

<p>Shell命令解释器，是用户和操作系统沟通的桥梁；</p>

<p>Shell编程，基于Shell解释器实现软件自动化功能；</p>

<p>Shell编程语言是非类型的解释型语言。</p>

<p>SHELL脚本，实现Shell编程实体；</p>

<p>SHELL命令，具体实现某个功能、内容的指令；</p>

<p><strong>SHELL变量</strong> 两种： <strong>局部变量和环境变量</strong> ，赋值符号=，使用$符号引用</p>

<p>SHELL <strong>编程变量</strong> 三种：系统变量、环境变量、用户变量</p>

<p>shel脚本变量类型 : <strong>局部变量、环境变量、shell变量</strong></p>

<p>元字符通常在Linux中分为两类 ：</p>

<ol>
<li><p><strong>Shell元字符</strong> ，由Linux Shell进行解析；</p></li>

<li><p><strong>正则表达式元字符</strong> ，由vi/grep/sed/awk等文本处理工具进行解析；</p></li>
</ol>

<p><strong>SHELL种类</strong> ： sh/dash/bash/ash/zsh</p>

<p>SHELL 配制文件 ： ~/.bashrc , .bash_profile , .environmnet</p>

<p>查询当前shell下的进程 ： ps -o pid,ppid,cmd&rsquo;</p>

<p><strong>Bash两种工作模式 ： 互动模式 、Shell Script模式</strong></p>

<p><strong>互动模式 ： 系统管理员由键盘键入命令，必须等待shell执行该命令之后，才能继续执行下一个命令。</strong></p>

<p><strong>Shell Script模式 ： 管理这可以设计shell script ,把要执行的命令写在一个文件中，交友Bash去读取和执行。</strong></p>

<p><strong>bash变量类型</strong> ： <strong>环境变量、本地变量（局部变量）、位置变量、特殊变量；</strong></p>

<p><strong>本地变量</strong> ：VARNAME=VALUE :作用域为整个bash进程；</p>

<p><strong>局部变量</strong> ： local VARNAME=VALUE : 作用域为当前代码段；</p>

<p><strong>环境变量</strong> ：作用域为当前shell进程及其子进程；</p>

<p>export VARNAME=VALUE</p>

<p>VARNAME=VALUE</p>

<p>export VARNAME</p>

<p>&ldquo;导出&rdquo;</p>

<p>位置变量 ：$1,$2&hellip;&hellip;..</p>

<p>注意 ：使用chsh命令可以改变默认的shell。</p>

<pre><code># chsh  -s 
# chsh linuxtechi -s /bin/sh
</code></pre>

<p>特殊变量 ：</p>

<p>$？ : 上一个命令的执行状态返回值；</p>

<ul>
<li>: 代表任意的字符串，可以是空字符串<br />
? : 代表一个字符，单不可以为空</li>
</ul>

<p>$# : <strong>计算传递进来的参数</strong></p>

<p>$0 : <strong>在脚本中获取脚本名称</strong></p>

<p>$? : <strong>检查之前的命令是否运行成功</strong></p>

<p>tail-1 : <strong>获取文件的最后一行</strong></p>

<p>head-1 : <strong>获取文件的第一行</strong></p>

<p>awk&rsquo;{print $3}&rsquo; : <strong>获取一个文件每一行的第三个元素</strong></p>

<p>awk&rsquo;{ if ($1 == &ldquo;FIND&rdquo;) print $2}&rsquo; : <strong>文件中每行第一个元素是 FIND，如何获取第二个元素</strong></p>

<p><strong>调试 bash 脚本</strong></p>

<p>将 <code>-xv</code> 参数加到 <code>#!/bin/bash</code> 后</p>

<p>例子：</p>

<p><code>#!/bin/bash –xv</code></p>

<p>程序执行 ：可能有两类返回值；</p>

<p>程序执行结果；</p>

<p>程序状态码返回代码（0-255）</p>

<p>0：正确执行</p>

<p>1-255 ： 错误执行，1，2，127系统预留；</p>

<p>输出重定向 ：</p>

<blockquote>
<blockquote>
</blockquote>
</blockquote>

<p>2&gt;</p>

<p>2&gt;&gt;</p>

<p>&amp;&gt;</p>

<p>撤销变量</p>

<p>unset VARNAME</p>

<p><strong>查看当shell中变量</strong></p>

<p>set</p>

<p><strong>查看当前shell中的环境变量</strong></p>

<p>printenv</p>

<p>env</p>

<p>export</p>

<p>脚本 ： 命令的堆砌，按实际需要，结合命令流程控制机制实现的源程序。</p>

<p>在大多数Linux和其他类Unix系统上， <strong>默认的shell是Bash。</strong></p>

<p><strong>SHELL &gt;SHELL编程&gt;SHELL脚本&gt;SHELL命令关系</strong></p>

<p>SHELL编程变量定义存储到内存中，除非你的SHELL终端断开，否则一直长存内存缓冲区，变量名称不能使用特殊符号，变量名称之间不能使用-
横杠，可以使用_下划线；</p>

<p>SHELL编程变量，变量名和变量值中间使用=，不能使用空格，SHELL变量用途主要减少重复去调用，化复杂为简单，化简单为自动化；</p>

<p>SHELL编程思想，通过手工操作的Linux/SHELL命令进行堆积；</p>

<p>脚本在执行时会启动一个子shell进程：</p>

<p>命令行中启动的脚本会继承当前 shell环境变量；</p>

<p>系统自动执行的脚本（非命令启动）就需要自定义需要各环境变量；</p>

<h2 id="shell的工作原理"><strong>Shell的工作原理</strong></h2>

<p>Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p>

<h2 id="注意事项"><strong>注意事项</strong></h2>

<p>1）开头加解释器：#!/bin/bash</p>

<p>2）语法缩进，使用四个空格；多加注释说明。</p>

<p>3）命名建议规则： <strong>变量名大写</strong> 、局部变量小写，函数名小写，名字体现出实际作用。</p>

<p>4） <strong>默认变量是全局的</strong> ，在函数中变量local指定为局部变量，避免污染其他作用域。</p>

<p>5）有两个命令能帮助我调试脚本： <strong>set -e 遇到执行非0时退出脚本</strong> ，set-x 打印执行过程。</p>

<p>6）写脚本一定先测试再到生产上。</p>

<h2 id="shell和shell编程概念"><strong>SHELL和SHELL编程概念</strong></h2>

<p>1）
SHELL，SHELL是一款命令解释器，用户可以输入指令，传递给SHELL，SHELL指令传递到Linux内核，Linux内核处理数据，处理完毕之后将数据返回给SHELL，需要经过SHELL解释，解释完毕之后将最终的数据返回给用户；</p>

<p>2） SHELL是一个中间件，位于用户和Linux内核之间的，是用户和Linux内核的沟通桥梁；</p>

<p>3） SHELL是中间件，可以看成是一款软件，软件的种类：</p>

<p>4） SHELL编程，基于SHELL解释器执行的各种指令和代码，从而实现各种需求；</p>

<p>5） SHELL编程的产物是SHELL脚本，脚本文件，脚本文件中写入单个或者多个Linux指令，以实现某个具体的功能；</p>

<p>6）bash的配置文件</p>

<p>profile类 : 登录式shell</p>

<p>bashrc类 : 非登录式shell</p>

<p>登录式shell ：
/etc/profile&ndash;&gt;/etc/profile.d/*.sh&ndash;&gt;~/.bash_profile&ndash;&gt;/.bashrc&mdash;&gt;/etc/bashrc</p>

<p>非登录式shell ：~/.bashrc&ndash;&gt;/etc/bashrc&ndash;&gt;/etc/profile.d/*.sh</p>

<h2 id="shell编程开始-编程规范"><strong>SHELL编程开始 &amp;编程规范</strong></h2>

<p>1） 任何的编程语言开始以打印世界，你好，表示开启新的一天；</p>

<p>2） 创建普通文件的指令：touch、vi、vim、cat、echo、mv、cp等；</p>

<p>3） 基于 <strong>编程工具</strong> ：vi、vim、gedit、sumlime、notepad等，推荐使用vi和vim编程；</p>

<p>4） SHELL编程内容第一行以#!开头，其后接SHELL解释器的类型，例如/bin/bash等，正文每个功能写一行，逐行编写；</p>

<p>5） SHELL脚本在被执行时，从上往下执行，SHELL指令从上到下；</p>

<h3 id="shell中的四则运算"><strong>Shell中的四则运算</strong></h3>

<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>+</td>
<td>加法运算</td>
</tr>

<tr>
<td>-</td>
<td>减法运算</td>
</tr>

<tr>
<td>*</td>
<td>乘法运算</td>
</tr>

<tr>
<td>/</td>
<td>除法运算</td>
</tr>
</tbody>
</table>

<p><strong>其它运算符 =、==、!=、！、-o、-a</strong></p>

<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>%</td>
<td>求余</td>
</tr>

<tr>
<td>==</td>
<td>相等</td>
</tr>

<tr>
<td>=</td>
<td>赋值</td>
</tr>

<tr>
<td>!=</td>
<td>不相等</td>
</tr>

<tr>
<td>!</td>
<td>与</td>
</tr>

<tr>
<td>-o</td>
<td>或</td>
</tr>

<tr>
<td>-a</td>
<td>非</td>
</tr>
</tbody>
</table>

<p><strong>关系运算符</strong></p>

<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>-eq</td>
<td>两个数相等返回true</td>
</tr>

<tr>
<td>-ne</td>
<td>两个数不相等返回true</td>
</tr>

<tr>
<td>-gt</td>
<td>左侧数大于右侧数返回true</td>
</tr>

<tr>
<td>-It</td>
<td>左侧数小于右侧数返回true</td>
</tr>

<tr>
<td>-ge</td>
<td>左侧数大于等于右侧数返回true</td>
</tr>

<tr>
<td>-le</td>
<td>左侧数小于等于右侧数返回true</td>
</tr>
</tbody>
</table>

<p>测试两个数值是否相等；</p>

<pre><code>[root@localhost ~]# [ 1024 -eq 1024 ]           //测试1024是否等于1024
[root@localhost ~]# echo $?
0                                               //两个数值相等
修改第一个数值为1124后再次进行测试。
[root@localhost ~]# [ 1124 -eq 1024 ]
[root@localhost ~]# echo $?
1                                               //两个数值不相等
[root@localhost ~]# number1=500                 //number1为500
[root@localhost ~]# number2=254                 //number2为254
[root@localhost ~]# [ $number1 -gt $number2 ]
[root@localhost ~]# echo $?
0                                               //number1大于number2
[root@localhost ~]#
</code></pre>

<p>###</p>

<h3 id="字符串运算符"><strong>字符串运算符</strong></h3>

<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>=</td>
<td>两个字符串相等返回true</td>
</tr>

<tr>
<td>!=</td>
<td>两个字符串不相等返回true</td>
</tr>

<tr>
<td>-z</td>
<td>字符串长度为0返回true</td>
</tr>

<tr>
<td>-n</td>
<td></td>
</tr>
</tbody>
</table>

<p>字符串长度不为0返回true</p>

<p>运算符</p>

<p>| 含义<br />
&mdash;|&mdash;<br />
-d file | 检测文件是否是目录，如果是，则返回 true<br />
-r file | 检测文件是否可读，如果是，则返回 true<br />
-w file | 检测文件是否可写，如果是，则返回 true<br />
-x file | 检测文件是否可执行，如果是，则返回 true<br />
-s file | 检测文件是否为空（文件大小是否大于0，不为空返回 true<br />
-e file | 检测文件（包括目录）是否存在，如果是，则返回 true</p>

<pre><code>要测试两个字符串是否相等
[root@localhost ~]# [ &quot;abc&quot; = &quot;abc&quot; ]
[root@localhost ~]# echo $?
0                                        //两个字符串相等
把第一个字符串更改为bac后进行测试
[root@localhost ~]# [ &quot;bac&quot; = &quot;abc&quot; ]
[root@localhost ~]# echo $?
1                                        //两个字符串不相等
如果把运算符改为“!=”
[root@localhost ~]# [ &quot;bac&quot; != &quot;abc&quot; ]
[root@localhost ~]# echo $?
0
判断环境变量是否为空或者非空
[root@localhost ~]# [ -z $python1 ]
[root@localhost ~]# echo $?
0
[root@localhost ~]# [ -n $python1 ]
[root@localhost ~]# echo $?
0                                        //python1变量为空
[root@localhost ~]# python1=&quot;test&quot;       //对python1变量进行赋值
[root@localhost ~]# [ -z $python1 ]
[root@localhost ~]# echo $?
1                                        //python1变量不为空
[root@localhost ~]#
</code></pre>

<h3 id="条件测试的逻辑操作符"><strong>条件测试的逻辑操作符</strong></h3>

<p>逻辑操作符分以下3种：</p>

<ul>
<li><p>-a：逻辑与，只有当操作符两边的条件均为真时，结果为真，否则为假。</p></li>

<li><p>-o：逻辑或，操作符两边的条件只要有一个为真，结果为真，只有当两边所有条件为假时，结果为假。</p></li>

<li><p>!：逻辑否，条件为假，结果为真。</p>

<p>如果要测试两个文件的状态
[root@localhost 20190105]# ll test1 test2
-rw-rw-r&ndash;. 1 root root 0 6月   4 09:25 test1
-rw-rw-r&ndash;. 1 root root 0 6月   4 09:25 test2
[root@localhost 20190105]# [ -r test1 -a -r test2 ] //测试文件 test1 和 test2 是否都可读
[root@localhost 20190105]# echo $?
0
[root@localhost 20190105]# [ -x test1 -o -x test2 ] //测试文件 test1 和 test2 是否至少有一个可执行
[root@localhost 20190105]# echo $?
1
如果要测试两个数值变量
[root@localhost 20190105]# number1=10
[root@localhost 20190105]# number2=20
[root@localhost 20190105]# [ $number1 -eq 10 -a $number2 -gt 20 ] //测试是否number1 大于10 且 number2 大于20
[root@localhost 20190105]# echo $?
1
如果要测试文件test1 是否为不可读
[root@localhost 20190105]# ls -l test1
-rw-rw-r&ndash;. 1 root root 0 6月   4 09:25 test1
[root@localhost 20190105]# [ ! -r test1 ] //测试文件test1 是否为不可读
[root@localhost 20190105]# echo $?
1
[root@localhost 20190105]#</p></li>
</ul>

<p>###</p>

<h3 id="条件测试的逻辑操作符-1"><strong>条件测试的逻辑操作符</strong></h3>

<p>逻辑操作符分以下3种：</p>

<ul>
<li><p>-a：逻辑与，只有当操作符两边的条件均为真时，结果为真，否则为假。</p></li>

<li><p>-o：逻辑或，操作符两边的条件只要有一个为真，结果为真，只有当两边所有条件为假时，结果为假。</p></li>

<li><p>!：逻辑否，条件为假，结果为真。</p>

<p>如果要测试两个文件的状态
[root@localhost 20190105]# ll test1 test2
-rw-rw-r&ndash;. 1 root root 0 6月   4 09:25 test1
-rw-rw-r&ndash;. 1 root root 0 6月   4 09:25 test2
[root@localhost 20190105]# [ -r test1 -a -r test2 ] //测试文件 test1 和 test2 是否都可读
[root@localhost 20190105]# echo $?
0
[root@localhost 20190105]# [ -x test1 -o -x test2 ] //测试文件 test1 和 test2 是否至少有一个可执行
[root@localhost 20190105]# echo $?
1
如果要测试两个数值变量
[root@localhost 20190105]# number1=10
[root@localhost 20190105]# number2=20
[root@localhost 20190105]# [ $number1 -eq 10 -a $number2 -gt 20 ] //测试是否number1 大于10 且 number2 大于20
[root@localhost 20190105]# echo $?
1
如果要测试文件test1 是否为不可读
[root@localhost 20190105]# ls -l test1
-rw-rw-r&ndash;. 1 root root 0 6月   4 09:25 test1
[root@localhost 20190105]# [ ! -r test1 ] //测试文件test1 是否为不可读
[root@localhost 20190105]# echo $?
1
[root@localhost 20190105]#</p></li>
</ul>

<p><strong>test命令</strong></p>

<pre><code>test $[num1] -eq $[num2]  #判断两个变量是否相等
test num1=num2  #判断两个数字是否相等
</code></pre>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>-e file</td>
<td>文件存在则返回真</td>
</tr>

<tr>
<td>-r file</td>
<td>文件存在并且可读则返回真</td>
</tr>

<tr>
<td>-w file</td>
<td>文件存在并且可写则返回真</td>
</tr>

<tr>
<td>-x file</td>
<td>文件存在并且可执行则返回真</td>
</tr>

<tr>
<td>-s file</td>
<td>文件存在并且内容不为空则返回真</td>
</tr>

<tr>
<td>-d file</td>
<td>文件目录存在则返回真</td>
</tr>
</tbody>
</table>

<h3 id="bash脚本的用法展示"><strong>Bash脚本的用法展示</strong></h3>

<p>一、条件选择、判断（if·、case）</p>

<p>二、四个循环（for、while、until、select）</p>

<p>三、循环里的一些命令与技巧（continue、break、shift&hellip;）</p>

<p>四、信号捕获trap</p>

<p>条件判断 ：</p>

<p>如果用户不存在</p>

<p>添加用户，给密码并显示添加成功；</p>

<p>否则</p>

<p>显示如果以及没在，没有添加；</p>

<p><strong>bash中如何实现条件判断？</strong></p>

<p>条件测试类型 ：</p>

<p>整数测试</p>

<p>字符测试</p>

<p>文件测试</p>

<p><strong>条件测试的表达式 ：</strong></p>

<p>[ expression ]</p>

<p>[ [ expression ] ]</p>

<p>test expression</p>

<p><strong>整数比较 ：</strong></p>

<p>-eq : 测试两个整数是否相等，比如$A -eq $B</p>

<p>-ne : 测试两个整数是否不等：不等，为真；相等，为假；</p>

<p>-gt : 测试一个数是否大于另一个数：小于，为真；否则，为假；</p>

<p>-lt : 测试 一个数是否小于另一个数：小于，为真；否则，为假；</p>

<p>-gt : 大于或等于</p>

<p>-gt : 小于或等于</p>

<p>命令的间逻辑关系 ：</p>

<p>逻辑与 ：&amp;&amp;</p>

<p>第一个条件为假时，第二条件不用再判断，最终结果已经有；</p>

<p>第一个条件为真时，第二条件必须得判断；</p>

<p>逻辑或 ：｜｜</p>

<p>如果用户user6 不存在，就添加用户user6</p>

<p>! id user6 &amp;&amp; useradd user6</p>

<p>id user6 || useradd user6</p>

<p>如果/etc/inittab文件的行数大于100，就显示好大的文件。</p>

<p>[ &lsquo;wc -l /etc/inittab | cut -d&rsquo; &lsquo;-f1&rsquo; -gt 100 ] &amp;&amp; echo &ldquo;Large file.&rdquo;</p>

<p><strong>变量名称 ：</strong></p>

<p>1、只能包含字母、数字和下划线，并且不能数字开头；</p>

<p>2、不应该跟系统中已有的环境变量重名；</p>

<p>3、最好做到见名知义</p>

<p><strong>如果用户存在，就显示用户已存在：否则，就添加此用户；</strong></p>

<p>id user1 &amp;&amp; echo &ldquo;user1 exists.&rdquo; || useradd user1</p>

<p><strong>如果用户不存在，就添加：否则，显示其已经存在；</strong></p>

<p>！ id user1 &amp;&amp; useradd user1 || echo &ldquo;user1 exists.&rdquo;</p>

<p><strong>如果用户不存在，添加并且给密码：否则，显示其已经存在</strong></p>

<p>！ id user1 &amp;&amp; useradd user1 &amp;&amp; echo &ldquo;user1&rdquo; | passwd &ndash;stdin user1 || echo
&ldquo;user1 exists.&rdquo;</p>

<p><strong>shell中如何进行算术运算 ：</strong></p>

<p>A=3</p>

<p>B=6</p>

<p>1、let 算术运算表达式</p>

<p>let c=$A+$B</p>

<p>2、$[算术运算表达式]</p>

<p>C=$[$A+$B]</p>

<p>3、$（[算术运算表达式]）</p>

<p>C=$(($A+$B))</p>

<p>4、expr算术运算表达式,表达式中各操作及运算符要有空格 ， 而且要使用命令引用。</p>

<p>C=&lsquo;expr $A + $B&rsquo;</p>

<p>案例 ：</p>

<p>给定一个用户，判断其UID与GID是否一样，如果一样，就显示此用户为“good guy”: 否则，就显示此用户为“bad guy”</p>

<p>#!/bin/bash</p>

<p>USERNAME=user1</p>

<p>USERID=&lsquo;id -u $USERNAME&rsquo;</p>

<p>GROUPID=&lsquo;id -g $USERNAME&rsquo;</p>

<p>if [ $USEID -eq $GROUPID ];then</p>

<p>echo &ldquo;Good guy&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Bad guy&rdquo;</p>

<p>fi</p>

<p>进一步要求：不使用id命令获得其id号：</p>

<p>#!/bin/bash</p>

<p>#</p>

<p>USERNAME=user1</p>

<p>USERID=&lsquo;grep &ldquo;^USERNAME&gt;&rdquo; /etc/passwd |ｃｕｔ －ｄ ：－ｆ３&rsquo;</p>

<p>GROUPID=&lsquo;grep &ldquo;^USERNAME&gt;&rdquo; /etc/passwd |ｃｕｔ －ｄ ：－ｆ３&rsquo;</p>

<p>if [ $USERID - eq $ GROUPID ]; then</p>

<p>echo &ldquo;Goo guy.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Bad guy.&rdquo;</p>

<p>fi</p>

<h2 id="二-shell-编程四剑客-find-sed-awk-grep"><strong>二、Shell</strong> <strong>编程四剑客（</strong> <strong>find</strong> <strong>、</strong> <strong>sed</strong> <strong>、</strong> <strong>awk</strong> <strong>、</strong> <strong>grep</strong></h2>

<p><strong>）功能及用途：</strong></p>

<p>Find工具：主要用于文件、文件夹的查找，找到文件的路径；</p>

<p>Sed工具：非交互模式编辑器、vim交互式编辑器，用于文件内容修改；</p>

<p>Awk工具：主要用于对文件内容进行处理、输出预定的结果；</p>

<p>Grep工具：主要用于操作系统文件内容的查找，对文件的内容的操作，匹配文件中的关键词；</p>

<h3 id="find命令工具">Find命令工具：</h3>

<h3 id="主要用于对操作系统文件路径的查找">主要用于对操作系统文件路径的查找；</h3>

<p>find path -option [ -print ] [ -exec -ok command ] { } \；</p>

<ol>
<li>find . 查找当前目录所有文件、文件夹；</li>
<li>find / -name &ldquo;test.txt&rdquo;|xargs rm -rf {} \;查找test.txt文件并删除；</li>
<li>find . -name &ldquo;*.txt&rdquo; -exec cp {} /root/ \;查找当前目录以.txt结尾文件，并且将该文件cp至/root目录；（推荐使用exec）</li>
<li><strong>恢复/tmp/下文件、目录原来权限；</strong></li>
<li>文件权限默认是：644</li>
</ol>

<p>目录权限默认是：755</p>

<p>find . -type d -exec chmod 755 -R {} \;（\；结束标记）修改当前目录，类型是目录的权限改完默认权限；</p>

<p>find . -type f -exec chmod 644 -R {} \; 修改当前目录，类型是文件的权限改完默认权限；</p>

<ol>
<li>查找当前目录文件大小，-size参数：find . -size +20M -a -size -200M -exec rm -rf {} \;</li>
<li>find . -name &ldquo;*.log&rdquo; ! -name &ldquo;access.log&rdquo; ! -name &ldquo;error.log&rdquo; -size +30M -size -40M -type f</li>
<li><strong>按天数、时间去查找文件及文件夹；</strong></li>
</ol>

<p>find . -name &ldquo;*.log&rdquo; ! -name &ldquo;access.log&rdquo; ! -name &ldquo;error.log&rdquo; -mtime +30 -exec
rm -rf {} \;-mtime -n +n #按文件更改时间来查找文件，-n指n天以内，+n指n天以前；</p>

<p>-atime -n +n #按文件访问时间来查找文件；</p>

<p>-ctime -n +n #按文件创建时间来查找文件；</p>

<p>9.查找系统所有的以.rpm结尾的软件包，并且将软件包拷贝至/root/20180327/;</p>

<p>find / -name &ldquo;*.rpm&rdquo; -exec cp {} /root/20180327/ \;</p>

<p>10.find / -name httpd 查找系统httpd名称的文件或者目录；</p>

<p>find / -name access.log 查找系统access.log路径；</p>

<p>find /usr/ -name “*.log”查看以.log结尾的文件，*表示0个或者多个匹配；</p>

<p>查找当前目录名称以.log结尾，是文件属性，大小大于100M，权限是644的文件：</p>

<p>find . -name &ldquo;*.log&rdquo; -type f -size +100M -perm 644 ! -name &ldquo;test1.log&rdquo;</p>

<p>atime：access time，文件被访问的时间；</p>

<p>ctime：change time，文件属性被修改时间；</p>

<p>mtime：modify time，文件内容修改时间</p>

<p><strong>查找txt文档，修改时间，小于一天，大于5M，权限755</strong></p>

<p><a href="https://img.it610.com/image/info8/f5a063eb676545bd8518c555e5fa1305.jpg"><img src="https://img.it610.com/image/info8/f5a063eb676545bd8518c555e5fa1305.jpg" alt="2e75bc90c7cc56108f2567f357fdae742f9.jpg" /></a></p>

<p><strong>查找log文件，大于100M，权限644，去掉test1.log文件，修改时间小于30分钟</strong></p>

<p>find . -name &ldquo;*.log&rdquo; -type f -size +100M -perm 644 ! -name &ldquo;test1.log&rdquo; -mtime
-30 -mmin -1</p>

<p><strong>拷贝到/tmp目录、在当前目录，只有一级目录</strong></p>

<p><img src="https://img.it610.com/image/info8/b8f99d8811384812a0fc499d5b99160b.jpg" alt="6225b5324f4131fc9bc0a16108fb4f0287b.jpg" /></p>

<p><a href="https://img.it610.com/image/info8/91c8394f943e46b0a034b62fa1f97065.jpg"><img src="https://img.it610.com/image/info8/91c8394f943e46b0a034b62fa1f97065.jpg" alt="9f3f80402367396b3e9d2f38dc3069fd896.jpg" /></a></p>

<p><a href="https://img.it610.com/image/info8/bd5d54dbe0ab442490acf093be0efc75.jpg"><img src="https://img.it610.com/image/info8/bd5d54dbe0ab442490acf093be0efc75.jpg" alt="Shell脚本介绍（资源）_第4张图片" /></a></p>

<p>应用场景：</p>

<p>根据你的需求，假设网卡的配置文件：</p>

<p>eth0查找网卡的配置文件，修改IP；</p>

<p><a href="https://img.it610.com/image/info8/2a5f195eef024f95935a6b4f80f5a4d3.jpg"><img src="https://img.it610.com/image/info8/2a5f195eef024f95935a6b4f80f5a4d3.jpg" alt="Shell脚本介绍（资源）_第5张图片" /></a></p>

<p><strong>恢复权限</strong></p>

<p><strong>恢复文档文件权限</strong></p>

<p>find . -type f -exec chmod -R 644 {} \;</p>

<p><strong>恢复目录权限</strong></p>

<p>find . -type d -exec chmod -R 755 {} \;</p>

<p><strong>把大于5M的文件文档，移到/tmp/目录</strong></p>

<p><img src="https://img.it610.com/image/info8/f0097f6ff4544f2ba83c643523a5bda7.jpg" alt="f952d188775283c43a736ca53e328e9cdb3.jpg" /></p>

<h3 id="sed命令工具"><strong>Sed命令工具：</strong></h3>

<p>SED是一个非交互式文本编辑器，它可对文本文件和标准输入进行编辑，标准输入可以来自键盘输入、文本重定向、字符串、变量，甚至来自于管道的文本，与VIM编辑器类似，它一次处理一行内容，Sed可以编辑一个或多个文件，简化对文件的反复操作、编写转换程序等。</p>

<p>在处理文本时把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern
space），紧接着用SED命令处理缓冲区中的内容，处理完成后把缓冲区的内容输出至屏幕或者写入文件。</p>

<p>逐行处理直到文件末尾，然而如果打印在屏幕上，实质文件内容并没有改变，除非你使用重定向存储输出或者写入文件。其语法参数格式为：</p>

<p>sed &lsquo;/^SELINUX/s/enforcing/disabled/g&rsquo; /etc/selinux/config
#把enforcing/disabled/替换成/etc/selinux/config</p>

<p>sed &rsquo;s/^SELINUX.*/SELINUX=disabled /g&rsquo; /etc/selinux/config
#把所有的SELINUX=disabled替换成/etc/selinux/config</p>

<p>基于sed打印最大、最小值：</p>

<p>238739</p>

<p>23923823</p>

<p>322938293829832</p>

<p>328922222222228</p>

<p>2382938923</p>

<p>-293238293</p>

<p><strong>使用#sed &rsquo;s/ /\n/g&rsquo; test.txt|grep -v &ldquo;^$&rdquo;|sort -n|sed -n &ldquo;1p;$&ldquo;p查询</strong></p>

<p>-8923293892839283928</p>

<p>3242348923233232323</p>

<p><a href="https://img.it610.com/image/info8/44aa9b38af344da0badbfd6f966a3ce8.png"><img src="https://img.it610.com/image/info8/44aa9b38af344da0badbfd6f966a3ce8.png" alt="591f706a9ffed5ceae1c87ce65b08814c7c.jpg" /></a></p>

<p>匹配IP地址</p>

<p><a href="https://img.it610.com/image/info8/22b9a32b12524af19daeb0fe6d84139a.jpg"><img src="https://img.it610.com/image/info8/22b9a32b12524af19daeb0fe6d84139a.jpg" alt="145c9bac52a2e7be05041f12498908c9b9d.jpg" /></a></p>

<p>严格匹配IP地址</p>

<p><a href="https://img.it610.com/image/info8/57078313698a42369bd9715e57935f3c.jpg"><img src="https://img.it610.com/image/info8/57078313698a42369bd9715e57935f3c.jpg" alt="7c74fa2f8c25c2bb0c42e7ab7be2a56c9a9.jpg" /></a></p>

<p>意思同上</p>

<p><a href="https://img.it610.com/image/info8/02633fd4f0c642439c8bee25112875ca.jpg"><img src="https://img.it610.com/image/info8/02633fd4f0c642439c8bee25112875ca.jpg" alt="843e61680215cd4f98a225815728a69c442.jpg" /></a></p>

<p>shell变量为弱类型，定义变量不需要声明类型，但使用时需要明确变量大的类型，可以是使用Declare指定类型，Declare常见参数：</p>

<p>+/- &ldquo;-&ldquo;可用来指定变量的属性，“+”为取消变量所设的属性</p>

<p>-f 仅显示函数</p>

<p>r 将变量设置为只读</p>

<p>x 指定的变量会成为环境变量，可供shell以外的程序来使用。</p>

<p>i 指定类型为数值，字符串或运算符</p>

<h2 id="shell-变量详解"><strong>SHELL</strong> <strong>变量详解</strong></h2>

<ol>
<li>变量是一个可变的值，SHELL变量主要是为了减少重复引用；</li>
<li>SHELL变量是弱类型，使用时直接=赋值即可，ABC=123，ABC是变量名称，123位变量的值；</li>
<li>SHELL变量在定义的时候不需要声明，可以声明，declare声明；</li>
</ol>

<p>shell使用案例：</p>

<p>#！/bin/bash</p>

<p>wget <a href="https://mirrors.tuna.tsinghua.edu.cn/apache/httpd/httpd-2.4.27.tar.bz2">https://mirrors.tuna.tsinghua.edu.cn/apache/httpd/httpd-2.4.27.tar.bz2</a></p>

<p>yum update apr apr-devel apr-util apr-util-devel -y</p>

<p>tar -xf httpd-2.4.27.tar.bz2</p>

<p>cd httpd-2.4.27</p>

<p>./configure &ndash;prefix=/usr/local/apache2/ &ndash;enable-so &ndash;enable-rewrite
&ndash;enable-ssl</p>

<p>make</p>

<p>make install</p>

<p>2）、自动删除test.txt文件脚本，脚本的功能实现从/root/目录cp拷贝test.txt到/tmp目录，并且在/tmp目录创建一个目录abc,并且删除原/root下test.txt。</p>

<p>#！/bin/bash</p>

<p>#the auto cp file and rm files</p>

<p>FILES=/root/test.txt #把/root/test.txt定义为FILES</p>

<p>DIR=/tmp #把/tmp定义为DIR</p>

<p>cp $FILES $DIR</p>

<p>mkdir -p $DIR/abc</p>

<p>rm -rf $FILES</p>

<p>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;</p>

<p>echo &ldquo;The shell exec scuccessful&rdquo;</p>

<p>2） <strong>Shell编程特点：</strong></p>

<p>q 语法和结构通常比较简单；</p>

<p>q 学习和使用通常比较简单；</p>

<p>q 基于Shell解释器运行，不需要编译运行；</p>

<p>q 程序的开发产能优于运行效能。</p>

<p><strong>3）Linux Shell的种类非常多，常见的SHELL分类</strong></p>

<p>q Bourne Shell（/usr/bin/sh或/bin/sh）</p>

<p>q <strong>Bourne Again Shell</strong> <strong>（</strong> <strong>/bin/bash</strong> <strong>）最常用，大部分系统自带！</strong></p>

<p>q C Shell（/usr/bin/csh）</p>

<p>q K Shell（/usr/bin/ksh）</p>

<p>q Shell for Root（/sbin/sh）</p>

<p><strong>注：shell</strong> <strong>是操作系统的最外层，shell可以合并编程语言以控制进程和文件，以及启动和控制其他程序。</strong></p>

<p><strong>简单来说：shell就是一个用户跟操作系统之间交互的命令解释器</strong></p>

<p><strong>如图，shell在系统各种的位置</strong></p>

<p><a href="https://img.it610.com/image/info8/57180601cc6045a79b86a0720e56420c.jpg"><img src="https://img.it610.com/image/info8/57180601cc6045a79b86a0720e56420c.jpg" alt="Shell脚本介绍（资源）_第6张图片" /></a></p>

<p><strong>shell</strong>
<strong>独立于内核，它是链接内核和应用程序的桥梁。内核是linux系统的心脏，从开机自检就驻扎在计算机内存中，直到计算机关闭为止。用户的应用程序存储在计算机硬盘上，仅当需要时才被调入内存。shell是一种应用程序，当用户登陆linux系统时，shell就会被调用到内存执行。</strong></p>

<p><strong>查看常见的shell解释器</strong></p>

<pre><code>**[root@localhosts ~** **]# cat /etc/shells**


**/bin/sh**


**/bin/bash**


**/sbin/nologin**


**/bin/tcsh**


**/bin/csh**
</code></pre>

<p><strong>注意： /bin/bash</strong> <strong>是大多数linux中默认的shell解释器</strong> 。 <strong>之后的所有脚本的编写都是bash脚本</strong></p>

<p><strong>我们来编写第一个脚本frist.sh</strong></p>

<p><strong>linux</strong> <strong>不以后缀名区分文件，为了方便记忆这里我就以.sh为结尾</strong></p>

<p><strong>写第一个脚本：</strong></p>

<pre><code>**[root@localhosts 桌面]# vim first.sh**


**#!/bin/bash**


**#auto my frist scripts**


**#by  authors cd**


**echo &quot;hello world&quot;**


**mkdir /root/shell**


**free -m**
</code></pre>

<p><strong>注释：</strong></p>

<p><strong>#</strong> <strong>！/bin/bash 主要是为了声明，我所写的均为bash语言(我是用的是bash解释器)[定义我的脚本是shell脚本].{固定格式}</strong></p>

<p><strong>第二行为注释行，注释信息不生效</strong></p>

<p><strong>#auto echo hello world!</strong></p>

<p><strong>#by authors tree 2016</strong> <strong>本脚本是由谁来写的，写这个是为了完成什么目的。</strong></p>

<h2 id="执行过程"><strong>执行过程</strong></h2>

<pre><code>**[root@localhosts ~]# ll first.sh         #** **查看是否具有执行权限**


**-rw-r--r-- 1 root root 65 Aug 30 06:50 first.sh**


**[root@localhosts ~]# chmod   o+x first.sh           #** **添加执行权限**


**[root@localhosts ~]# ll first.sh          #** **查看是否具有执行权限**


**-rwxr-xr-x** **1 root root 65 Aug 30 06:50 first.sh**
</code></pre>

<p><strong>执行的结果</strong></p>

<pre><code>**[root@localhosts ~]# ./first.sh**
**hello world**
           **total       used       free     shared    buffers     cached**
           **Mem:          2006        728       1277          0         28        330**
**-/+ buffers/cache:        370       1636**
**Swap:         1999          0       1999**

**或者可以用 /bin/bash/+脚本来执行，这样的就不需要加权限了。**
</code></pre>

<p><strong>编写LAMP YUM自动安装脚本</strong></p>

<pre><code>**[root@localhosts ~]# vim lamp.sh**
**#!/bin/bash**
#2018/5/23
**#auto install linux for lamp**
#Intall HTTP **WEB service**


yum install httpd httpd-devel -y
#Intall MYSQL **service**
yum install mysql-server mysql mysql-devel –y
#Intall PHP **service**
yum install php php-devel php-mysql –y
#启动httpd和mysql服务,并关闭防火墙和selinux
/etc/init.d/httpd restart
/etc/init.d/mysqld restart
/etc/init.d/iptables stop 
setenforce 0
echo &quot;The shell script Exec Success.&quot;
exit
</code></pre>

<p>执行脚本,就能自动安装LAMP了。</p>

<pre><code>**[root@localhosts ~]# sh lamp.sh**
</code></pre>

<p><a href="https://img.it610.com/image/info8/37fff4807b0645efb18a4f782f7e7670.jpg"><img src="https://img.it610.com/image/info8/37fff4807b0645efb18a4f782f7e7670.jpg" alt="Shell脚本介绍（资源）_第7张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/dfaabbc08f0e419080b618d112d98b5c.jpg"><img src="https://img.it610.com/image/info8/dfaabbc08f0e419080b618d112d98b5c.jpg" alt="Shell脚本介绍（资源）_第8张图片" /></a></p>

<p>使用命令：&gt;&gt;/var/www/html/phpinfo.php 追加到/var/www/html/phpinfo.php 中。</p>

<p><a href="https://img.it610.com/image/info8/7f1d26066d7249eeacc97d46846e63bb.png"><img src="https://img.it610.com/image/info8/7f1d26066d7249eeacc97d46846e63bb.png" alt="Shell脚本介绍（资源）_第9张图片" /></a></p>

<h2 id="执行脚本的不同方式"><strong>执行脚本的不同方式</strong></h2>

<p><strong>第一种使用绝对路径执行 例如 ： /bin/bash first_shell.sh</strong></p>

<p><strong>第二种使用相对路径执行，如./的方式 ./first_shell.sh</strong></p>

<p><strong>第三种使用 sh命令来执行 格式 sh 脚本名 不需要执行权限 sh first_shell.sh</strong></p>

<p><strong>第四种使用 . (空格)脚本名称的方式执行 不需要执行权限 . a.sh</strong></p>

<p><strong>第五种使用 source 脚本名称 不需要执行权限(主要用于生效配置文件)</strong></p>

<p><strong>注意 ：建议使用后三种,在生产环境中不要轻易的给文件可执行权限;</strong></p>

<p><strong>执行脚本的方法</strong></p>

<p>$source ./script.sh</p>

<p>或者</p>

<p>$ . ./script.sh</p>

<p>source或者.命令是shell的内建命令，这种方式也不会创建子shell,而是直接在交互式</p>

<p>shell下逐行执行脚本中的命令。</p>

<p><strong>2</strong> <strong>、变量</strong></p>

<p><strong>变量用来保存有用信息，比如路径名，文件名，数字等，变量的本质是存储数据的一个或多个计算机内存地址</strong></p>

<p><strong>接下来我们来探讨脚本中作重要的东西&mdash;变量,变量的定义是：可以存放一个可变的值的空间</strong></p>

<p><strong>可以通过不同的环境进行改变就是一个可以变的值.</strong></p>

<hr />

<p><strong>默认情况下: 在Linux中可以将每个shell看成不同的执行环境,所以相同的一个变量名称在不同的变量执行环境中的变量值是不同的.</strong></p>

<p><strong>常见的shell变量分类</strong></p>

<p><strong>自定义变量、环境变量、位置变量、预定义变量</strong></p>

<p><strong>变量的输出</strong></p>

<p><strong>一般使用echo 输出变量 echo $变量名</strong></p>

<p><strong>shell</strong> <strong>变量总结：</strong></p>

<p><strong>1.</strong> <strong>声明变量不用声明类型</strong></p>

<p><strong>2.</strong> <strong>可以存储不同类型内容</strong></p>

<p><strong>3.</strong> <strong>使用时要明确变量类型</strong></p>

<p><strong>区分大小写。</strong></p>

<p><strong>自定义变量</strong></p>

<p><strong>自定义变量是用户根据自己的环境自己定义的变量,Bash中比较简单的变量;</strong></p>

<p><strong>不用进行提前声明，而是直接指定变量名称并赋给初始值;</strong></p>

<p><strong>定义变量的基本格式为 变量名=变量值</strong></p>

<p><strong>要求:</strong></p>

<p><strong>等号两遍不允许出现空格;</strong></p>

<p><strong>变量名称只能以字母和下划线开头名称中不能包含+、- * 、 / . , 、 ？ % * 等一些特殊字符.</strong></p>

<p><strong>举例： var=”hello world”</strong></p>

<p><strong>变量名的命名须遵循如下规则：</strong></p>

<p><strong>首个字符必须为字母（a-z，A-Z）。</strong></p>

<p><strong>中间不能有空格，可以使用下划线（_）。</strong></p>

<p><strong>不能使用标点符号。</strong></p>

<p><strong>不能使用bash里的关键字（可用help命令查看保留关键字）。</strong></p>

<hr />

<p><strong>变量的使用：</strong></p>

<p><strong>格式：$变量名或者${变量名}</strong></p>

<p><strong>echo $var</strong> <strong>或者echo ${var}</strong></p>

<p><strong>举例:</strong> ****<strong>来进行定义一个变量名字为Linux值为7.2</strong></p>

<pre><code>**[root@localhosts ~]# Linux=7.2      #** **为变量Linux赋值**


**[root@localhosts ~]# echo $Linux    #输出变量Linux的值**


**7.2**


**[ro[root@localhosts ~]# linux=6.5      #为变量linux赋值**


**[ro[root@localhosts ~]# echo $linux      #** **输出变量linux的值**


**6.5**
</code></pre>

<p><strong>可以直接在命令行定义一个变量并赋予值，通过echo进行输出变量 $是引用变量的特殊字符（必须使用$符号）</strong></p>

<p><strong>echo</strong> <strong>和调用的变量之间必须要有空格</strong></p>

<p><strong>注意大小写的变量的值是不同的</strong></p>

<p><strong>举例2:</strong> <strong>当需要一起调用两组变量时</strong></p>

<pre><code>**[root@localhosts ~]#echo $Linux $linux**


**7.2 6.5**
</code></pre>

<p><strong>直接使用echo 后面跟$调用的变量 如果有多个则空格隔开</strong></p>

<p><strong>举例3:</strong> <strong>当变量名和后面的字符容易混淆的时候应该使用{}将变量名括起来</strong></p>

<pre><code>**[root@localhosts ~]#echo system{$Linux}**


**system{7.2}**
</code></pre>

<p><strong>取消变量：</strong></p>

<p><strong>语法：unset +变量</strong></p>

<pre><code>**[root@localhosts ~]# unset linux**


**[root@localhosts ~]# echo $linux**
</code></pre>

<p><strong>其他的特殊操作</strong></p>

<hr />

<p><strong>双引号( &ldquo; )</strong></p>

<p><strong>1.</strong> <strong>当=号右边赋值出现空格的时候，需要使用双引号将其扩起</strong></p>

<pre><code>**[root@localhosts ~]# webserver=&quot; nginx 1.11&quot;**


**[root@localhosts ~]# echo $webserver**


**nginx 1.11**
</code></pre>

<p><strong>2、</strong> <strong>来看下没有引号，有单引号和双引号的区别</strong></p>

<p>**# Y=a</p>

<h1 id="echo-y">echo $Y</h1>

<p>a**</p>

<p>**# echo &lsquo;$x&rsquo;<br />
$x</p>

<h1 id="echo-x">echo &ldquo;$x&rdquo;</h1>

<p>a **</p>

<p><strong>read</strong> <strong>命令</strong></p>

<p><strong>除了上面的赋值之外还可以使用read命令进行赋值，read命令用来提示用户输入信息，从而实现简单的交互式过程（其实我们所输入的命令就是一种交互式的过程）</strong></p>

<p><strong>执行时需要从标准输入设备键盘读取一行，并以空格为分隔符</strong></p>

<p><strong>执行时需要从标准输入设备键盘读取一行，并以空格为分隔符</strong></p>

<p><strong>[root@xuegod63 ~]# read kernel system #</strong> <strong>同时定义两个变量操作</strong></p>

<p><strong>3.10 7.2 -</strong> <strong>à</strong> <strong>手动输入的变量值</strong></p>

<p><strong>由于read命令提供了-p参数，这里可以缩写为：</strong></p>

<p><strong>#!/bin/bash</strong></p>

<p><strong>#by authors tree 20160904</strong></p>

<p><strong>read -p &ldquo;Enter your name: &ldquo; name</strong></p>

<hr />

<p><strong>echo &ldquo;hello $name,welcome to my class&rdquo;</strong></p>

<p><strong>exit 0</strong></p>

<p><strong>注意：</strong></p>

<p><strong>由于使用read存在一定的风险，既有可能需要等待用户输入，但用户一直不输入，就没法继续运行。</strong></p>

<p><strong>这时候可以使用read的另外一个参数-t</strong></p>

<p><strong>-t</strong> <strong>是一个计时器，指定read命令需要等待输入的秒数，当计时满时，直接返回一个非零退出状态。</strong></p>

<hr />

<p>**#!/bin/bash</p>

<p>if read -t 5 -p &ldquo;please enter your name:&rdquo; name</p>

<p>then</p>

<p>echo &ldquo;hello $name ,welcome to my script&rdquo;</p>

<p>else</p>

<p>echo &ldquo;sorry,too slow&rdquo;</p>

<p>fi</p>

<p>exit 0 **</p>

<ol>
<li><p><strong>SHELL编程实战优化</strong></p></li>

<li><p>SHELL脚本优化引入变量；</p></li>
</ol>

<p>SHELL变量，是一个可变的值，跟常量是对应关系，常量是一个固定的值，变量可变；</p>

<p>变量相当于别名，xiaoming=110101199410234012，获取身份证ID号，$xiaoming；</p>

<ol>
<li>SHELL脚本引入if、for、while、case条件判断；</li>
<li>检查SHELL脚本功能、需求是否有缺陷；</li>
<li>检查SHELL脚本能否扩展，批量生产！</li>
</ol>

<h2 id="shell9个实例">SHELL9个实例 ：</h2>

<h3 id="1-获取随机字符串或数字">1、 获取随机字符串或数字</h3>

<p>获取随机8位字符串：</p>

<p><a href="https://img.it610.com/image/info8/0f07d654756141f3a95a8e39b27feb17.jpg"><img src="https://img.it610.com/image/info8/0f07d654756141f3a95a8e39b27feb17.jpg" alt="Shell脚本介绍（资源）_第10张图片" /></a></p>

<p>获取随机8位数字：</p>

<p><a href="https://img.it610.com/image/info8/e6ba3d9e2009455ab81c5ee1e10030e4.jpg"><img src="https://img.it610.com/image/info8/e6ba3d9e2009455ab81c5ee1e10030e4.jpg" alt="Shell脚本介绍（资源）_第11张图片" /></a></p>

<h3 id="2-定义一个颜色输出字符串函数">2 、定义一个颜色输出字符串函数</h3>

<p><a href="https://img.it610.com/image/info8/d0a901355a3446bc864a03c795aced66.jpg"><img src="https://img.it610.com/image/info8/d0a901355a3446bc864a03c795aced66.jpg" alt="Shell脚本介绍（资源）_第12张图片" /></a></p>

<h3 id="3-批量创建用户">3、 批量创建用户</h3>

<p><a href="https://img.it610.com/image/info8/df15ffd77dbe4fc0a1591781826c0b76.jpg"><img src="https://img.it610.com/image/info8/df15ffd77dbe4fc0a1591781826c0b76.jpg" alt="Shell脚本介绍（资源）_第13张图片" /></a></p>

<h3 id="4-检查软件包是否安装">4 、检查软件包是否安装</h3>

<p><a href="https://img.it610.com/image/info8/f0910868ddf34f0382a10abfe4387aca.jpg"><img src="https://img.it610.com/image/info8/f0910868ddf34f0382a10abfe4387aca.jpg" alt="Shell脚本介绍（资源）_第14张图片" /></a></p>

<h3 id="5-检查服务状态">5、 检查服务状态</h3>

<p><a href="https://img.it610.com/image/info8/49a997c828ea481b8d3cf0e9854ec2df.jpg"><img src="https://img.it610.com/image/info8/49a997c828ea481b8d3cf0e9854ec2df.jpg" alt="Shell脚本介绍（资源）_第15张图片" /></a></p>

<h3 id="6-检查主机存活状态">6 、检查主机存活状态</h3>

<p>方法1： 将错误IP放到数组里面判断是否ping失败三次</p>

<p><a href="https://img.it610.com/image/info8/b0ecbf95e9ff4bc9935a057d2fd164f6.jpg"><img src="https://img.it610.com/image/info8/b0ecbf95e9ff4bc9935a057d2fd164f6.jpg" alt="Shell脚本介绍（资源）_第16张图片" /></a></p>

<p>方法2： 将错误次数放到FAIL_COUNT变量里面判断是否ping失败三次</p>

<p><a href="https://img.it610.com/image/info8/6322478d42ed40599c1f828e139ef0fe.jpg"><img src="https://img.it610.com/image/info8/6322478d42ed40599c1f828e139ef0fe.jpg" alt="Shell脚本介绍（资源）_第17张图片" /></a></p>

<p>方法3： 利用for循环将ping通就跳出循环继续，如果不跳出就会走到打印ping失败</p>

<p><a href="https://img.it610.com/image/info8/c032b4d789ca48d48a4f83e824a7ef05.jpg"><img src="https://img.it610.com/image/info8/c032b4d789ca48d48a4f83e824a7ef05.jpg" alt="Shell脚本介绍（资源）_第18张图片" /></a></p>

<h3 id="7-监控cpu-内存和硬盘利用率">7 、监控CPU、内存和硬盘利用率</h3>

<p>1）CPU</p>

<p>借助vmstat工具来分析CPU统计信息。</p>

<p><a href="https://img.it610.com/image/info8/566e3b83ce214456b6eb4c1c09b2f530.jpg"><img src="https://img.it610.com/image/info8/566e3b83ce214456b6eb4c1c09b2f530.jpg" alt="Shell脚本介绍（资源）_第19张图片" /></a></p>

<p>2）内存</p>

<p><a href="https://img.it610.com/image/info8/0c3d4c2e5bea46f8b6dd7962f0af61c1.jpg"><img src="https://img.it610.com/image/info8/0c3d4c2e5bea46f8b6dd7962f0af61c1.jpg" alt="Shell脚本介绍（资源）_第20张图片" /></a></p>

<p>3）硬盘</p>

<p><a href="https://img.it610.com/image/info8/c41d2272a9434bfba55a34da366cc6cb.jpg"><img src="https://img.it610.com/image/info8/c41d2272a9434bfba55a34da366cc6cb.jpg" alt="Shell脚本介绍（资源）_第21张图片" /></a></p>

<h3 id="8-批量主机磁盘利用率监控">8 、批量主机磁盘利用率监控</h3>

<p>前提监控端和被监控端SSH免交互登录或者密钥登录。</p>

<p>写一个配置文件保存被监控主机SSH连接信息，文件内容格式：IP User Port</p>

<p><a href="https://img.it610.com/image/info8/913ddeda59c24d3aa38f6377f123c05c.jpg"><img src="https://img.it610.com/image/info8/913ddeda59c24d3aa38f6377f123c05c.jpg" alt="Shell脚本介绍（资源）_第22张图片" /></a></p>

<h3 id="9-检查网站可用性">9 、检查网站可用性</h3>

<p>1）检查URL可用性</p>

<p><a href="https://img.it610.com/image/info8/f81999543fac47d490050b118469bccb.jpg"><img src="https://img.it610.com/image/info8/f81999543fac47d490050b118469bccb.jpg" alt="Shell脚本介绍（资源）_第23张图片" /></a></p>

<p>2）判断三次URL可用性</p>

<p>思路与上面检查主机存活状态一样。</p>

<p><a href="https://img.it610.com/image/info8/78fd06d58cdf4dbba9179966db0719fc.jpg"><img src="https://img.it610.com/image/info8/78fd06d58cdf4dbba9179966db0719fc.jpg" alt="Shell脚本介绍（资源）_第24张图片" /></a></p>

<p><strong>10、用ping命令统计某个网段的IP状态，如192.168.0，200到254之间的IP登录状态情况。</strong></p>

<p>答 ： #！/bin/bash</p>

<p>#</p>

<p>NET=192.168.0</p>

<p>trap &lsquo;echo &ldquo;quit .&rdquo;&rsquo;;exit 1INT #添加捕捉信号，按CTRL+C，退出</p>

<p>for I in {200..254}; do</p>

<p>if ping -c 1 -W 1 $NET.$I &amp;&gt; /dev/null; then</p>

<p>echo &ldquo;$NET.$I is up.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;$NET.$I is down.&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>11、查看用户有没有登录，并每个一段时间刷新。</p>

<p>#!/bin/bash</p>

<p>who |grep &ldquo;hadoop&rdquo; &amp;&gt; /dev/null<br />
RETVAL=$?</p>

<p>until [ $RETVAL -eq 0 ]; do<br />
echo &ldquo;hadoop is no come.&rdquo;<br />
sleep 5<br />
who | grep &ldquo;hadoop&rdquo; &amp;&gt; /dev/null<br />
RETVAL=$?<br />
done</p>

<p>echo &ldquo;hadoop is logged in.&rdquo;</p>

<p>12、100以内正整数的和</p>

<p>#!/bin/bash</p>

<p>declare -i SUM=0</p>

<p>for I in (1..100); do</p>

<p>let SUM+=$I</p>

<p>done</p>

<p>echo $SUM</p>

<p>declare -i SUM2=0</p>

<p>for ((J=2,I&lt;100,J+=2)); do</p>

<p>let SUM2+=$J</p>

<p>done</p>

<p>echo $SUM2</p>

<p>13、写一个猜数字脚本，当用户输入的数字和预设数字（随机生成一个小于100的数字）一样时，直接退出，否则让用户一直输入，并且提示用户的数字比预设数字大或者小。</p>

<p>答 ： #!/bin/bash<br />
m=<code>echo $RANDOM</code><br />
n1=$[$m%100]<br />
while :<br />
do<br />
read -p &ldquo;Please input a number: &ldquo; n<br />
if [ $n == $n1 ]<br />
then<br />
break<br />
elif [ $n -gt $n1 ]<br />
then<br />
echo &ldquo;bigger&rdquo;<br />
continue<br />
else<br />
echo &ldquo;smaller&rdquo;<br />
continue<br />
fi<br />
done<br />
echo &ldquo;You are right.&rdquo;</p>

<p>14、1、写一个脚本执行后，输入名字，产生随机数01-99之间的数字。<br />
2、如果相同的名字重复输入，抓到的数字还是第一次抓取的结果，<br />
3、前面已经抓到的数字，下次不能在出现相同数字。<br />
4、第一个输入名字后，屏幕输出信息，并将名字和数字记录到文件里，程序不能退出<br />
继续等待别的学生输入。</p>

<p>while :</p>

<p>do</p>

<p>read -p &ldquo;Please input a name:&rdquo; name</p>

<p>if [ -f /work/test/1.log ];then</p>

<p>bb=<code>cat /work/test/1.log | awk -F: '{print $1}' | grep &quot;$name&quot;</code></p>

<p>if [ &ldquo;$bb&rdquo; != &ldquo;$name&rdquo; ];then #名字不重复情况下</p>

<p>aa=<code>echo $RANDOM | awk -F &quot;&quot; '{print $2 $3}'</code></p>

<p>while :</p>

<p>do</p>

<p>dd=<code>cat /work/test/1.log | awk -F: '{print $2}' | grep &quot;$aa&quot;</code></p>

<p>if [ &ldquo;$aa&rdquo; == &ldquo;$dd&rdquo; ];then #数字已经存在情况下</p>

<p>echo &ldquo;数字已存在.&rdquo;</p>

<p>aa=<code>echo $RANDOM | awk -F &quot;&quot; '{print $2 $3}'</code></p>

<p>else</p>

<p>break</p>

<p>fi</p>

<p>done</p>

<p>echo &ldquo;$name:$aa&rdquo; | tee -a /work/test/1.log</p>

<p>else</p>

<p>aa=<code>cat /work/test/1.log | grep &quot;$name&quot; | awk -F: '{print $2}'</code> #名字重复</p>

<p>echo $aa</p>

<p>echo &ldquo;重复名字.&rdquo;</p>

<p>fi</p>

<p>else</p>

<p>aa=<code>echo $RANDOM | awk -F &quot;&quot; '{print $2 $3}'</code></p>

<p>echo &ldquo;$name:$aa&rdquo; | tee -a /work/test/1.log</p>

<p>fi</p>

<p>done</p>

<p>15、写一个猜数字脚本，当用户输入的数字和预设数字（随机生成一个小于100的数字）一样时，直接退出，否则让用户一直输入，并且提示用户的数字比预设数字大或者小。</p>

<p>#!/bin/bash<br />
m=<code>echo $RANDOM</code><br />
n1=$[$m%100]<br />
while :<br />
do<br />
read -p &ldquo;Please input a number: &ldquo; n<br />
if [ $n == $n1 ]<br />
then<br />
break<br />
elif [ $n -gt $n1 ]<br />
then<br />
echo &ldquo;bigger&rdquo;<br />
continue<br />
else<br />
echo &ldquo;smaller&rdquo;<br />
continue<br />
fi<br />
done<br />
echo &ldquo;You are right.&rdquo;</p>

<p>16、创建一个函数，能接受两个参数：<br />
1)第一个参数为URL，即可下载的文件；第二个参数为目录，即下载后保存的位置；<br />
2)如果用户给的目录不存在，则提示用户是否创建；如果创建就继续执行，否则，函数返回一个51的错误值给调用脚本；<br />
3)如果给的目录存在，则下载文件；下载命令执行结束后测试文件下载成功与否；如果成功，则&gt;返回0给调用脚本，否则，返回52给调用脚本；</p>

<p>提示，在函数中返回错误值给调用脚本，使用return</p>

<p>答 ：</p>

<p>#!/bin/bash</p>

<p>if [ ! -d $2 ]</p>

<p>then</p>

<p>echo &ldquo;please make directory&rdquo;</p>

<p>exit 51</p>

<p>fi</p>

<p>cd $2</p>

<p>wget $1</p>

<p>n=<code>echo $?</code></p>

<p>if [ $n -eq 0 ];then</p>

<p>exit 0</p>

<p>else</p>

<p>exit 52</p>

<p>fi</p>

<p>17、脚本的功能：<br />
脚本可以带参数也可以不带，参数可以有多个，每个参数必须是一个目录，脚本检查参数个数，若等于0，则列出当前目录本身；否则，显示每个参数包含的子目录。</p>

<blockquote>
<p>#!/bin/bash<br />
 if [ $# == 0 ]<br />
 then<br />
 ls -ld <code>pwd</code><br />
 else<br />
 for i in <code>seq 1 $#</code><br />
 do<br />
 a=$i<br />
 echo &ldquo;ls ${!a}&rdquo;<br />
 ls -l ${!a} |grep &lsquo;^d&rsquo;<br />
 done<br />
 fi</p>

<p>标注：
你可能会对${!a}有疑问，这里是一个特殊用法，在shell中，$1为第一个参数，$2为第二个参数，以此类推，那么这里的数字要是一个变量如何表示呢？比如n=3,我想取第三个参数，能否写成
$$n？ shell中是不支持的，那怎么办？ 就用脚本中的这种方法： a=$n, echo ${!a}</p>
</blockquote>

<p>18、提示用户输入网卡的名字，然后我们用脚本输出网卡的ip。
看似简单，但是需要考虑多个方面，比如我们输入的不符合网卡名字的规范，怎么应对。名字符合规范，但是根本就没有这个网卡有怎么应对。</p>

<p>#!/bin/bash</p>

<p>while :</p>

<p>do</p>

<p>read -p &ldquo;请输入网卡名: &ldquo; e</p>

<p>e1=<code>echo &quot;$e&quot; | sed 's/[-0-9]//g'</code></p>

<p>e2=<code>echo &quot;$e&quot; | sed 's/[a-zA-Z]//g'</code></p>

<p>if [ -z $e ]</p>

<p>then</p>

<p>echo &ldquo;你没有输入任何东西&rdquo;</p>

<p>continue</p>

<p>elif [ -z $e1 ]</p>

<p>then</p>

<p>echo &ldquo;不要输入纯数字在centos中网卡名是以eth开头后面加数字&rdquo;</p>

<p>continue</p>

<p>elif [ -z $e2 ]</p>

<p>then</p>

<p>echo &ldquo;不要输入纯字母在centos中网卡名是以eth开头后面加数字&rdquo;</p>

<p>continue</p>

<p>else</p>

<p>break</p>

<p>fi</p>

<p>done</p>

<p>ip() {</p>

<p>ifconfig | grep -A1 &ldquo;$1 &rdquo; |tail -1 | awk &lsquo;{print $2}&rsquo; | awk -F &ldquo;:&rdquo; &lsquo;{print
$2}&rsquo;</p>

<p>}</p>

<p>myip=<code>ip $e</code></p>

<p>if [ -z $myip ]</p>

<p>then</p>

<p>echo &ldquo;抱歉，没有这个网卡。&rdquo;</p>

<p>else</p>

<p>echo &ldquo;你的网卡IP地址是$myip&rdquo;</p>

<p>fi</p>

<p>19、写一个脚本，执行后，打印一行提示“Please input a
number:&ldquo;，要求用户输入数值，然后打印出该数值，然后再次要求用户输入数值。直到用户输入&rdquo;end&rdquo;停止。</p>

<p>#!/bin/bash</p>

<p>while :</p>

<p>do</p>

<p>read -p &ldquo;Please input a number:(end for exit) &ldquo; n</p>

<p>num=<code>echo $n |sed -r 's/[0-9]//g'|wc -c</code></p>

<p>if [ $n == &ldquo;end&rdquo; ]</p>

<p>then</p>

<p>exit</p>

<p>elif [ $num -ne 1 ]</p>

<p>then</p>

<p>echo &ldquo;what you input is not a number!Try again!&rdquo;</p>

<p>else</p>

<p>echo &ldquo;your input number is: $n&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>20、使用传参的方法写个脚本，实现加减乘除的功能。例如： sh a.sh 1 2，这样会分别计算加、减、乘、除的结果。</p>

<p>要求：</p>

<p>1 脚本需判断提供的两个数字必须为整数</p>

<p>2 当做减法或者除法时，需要判断哪个数字大</p>

<p>3 减法时需要用大的数字减小的数字</p>

<p>4 除法时需要用大的数字除以小的数字，并且结果需要保留两个小数点。</p>

<p>#!/bin/bash</p>

<p>if [ $# -ne 2 ]</p>

<p>then</p>

<p>echo &ldquo;The number of parameter is not 2, Please useage: ./$0 1 2&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>is_int()</p>

<p>{</p>

<p>if echo &ldquo;$1&rdquo;|grep -q &lsquo;[^0-9]&rsquo;</p>

<p>then</p>

<p>echo &ldquo;$1 is not integer number.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>}</p>

<p>max()</p>

<p>{</p>

<p>if [ $1 -ge $2 ]</p>

<p>then</p>

<p>echo $1</p>

<p>else</p>

<p>echo $2</p>

<p>fi</p>

<p>}</p>

<p>min()</p>

<p>{</p>

<p>if [ $1 -lt $2 ]</p>

<p>then</p>

<p>echo $1</p>

<p>else</p>

<p>echo $2</p>

<p>fi</p>

<p>}</p>

<p>sum()</p>

<p>{</p>

<p>echo &ldquo;$1 + $2 = $[$1+$2]&rdquo;</p>

<p>}</p>

<p>minus()</p>

<p>{</p>

<p>big=<code>max $1 $2</code></p>

<p>small=<code>min $1 $2</code></p>

<p>echo &ldquo;$big - $small = $[$big-$small]&rdquo;</p>

<p>}</p>

<p>mult()</p>

<p>{</p>

<p>echo &ldquo;$1 * $2 = $[$1*$2]&rdquo;</p>

<p>}</p>

<p>div()</p>

<p>{</p>

<p>big=<code>max $1 $2</code></p>

<p>small=<code>min $1 $2</code></p>

<p>d=<code>echo &quot;scale =2; $big / $small&quot;|bc</code></p>

<p>echo &ldquo;$big / $small = $d&rdquo;</p>

<p>}</p>

<p>is_int $1</p>

<p>is_int $2</p>

<p>sum $1 $2</p>

<p>minus $1 $2</p>

<p>mult $1 $2</p>

<p>div $1 $2</p>

<p>21、写一个脚本： 计算100以内所有能被3整除的正整数的和</p>

<p>#!/bin/bash<br />
sum=0<br />
for i in {1..100};do<br />
if [ $[$i%3] -eq 0 ];then<br />
sum=$[$i+$sum]<br />
fi<br />
done</p>

<p>echo &ldquo;sum:$sum&rdquo;</p>

<p>22、</p>

<p>#!/bin/bash</p>

<p>#written by aming.</p>

<p>if [ $# -eq 0 -o $# -gt 2 ]</p>

<p>then</p>

<p>echo &ldquo;use $0 &ndash;add username or $0 &ndash;del username or $0 &ndash;help.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>case $1 in</p>

<p>--add)</p>

<p>n=0</p>

<p>for u in <code>echo $2|sed 's/,/ /g'</code>; do</p>

<p>if awk -F: &lsquo;{print $1}&rsquo; /etc/passwd |grep -qw &ldquo;$u&rdquo;</p>

<p>then</p>

<p>echo &ldquo;The user $u exist.&rdquo;</p>

<p>else</p>

<p>useradd $u</p>

<p>echo -e &ldquo;$u\n$u&rdquo;|passwd $u &gt;/dev/null 2&gt;&amp;1</p>

<p>echo &ldquo;The user $u added successfully.&rdquo;</p>

<p>n=$[$n+1]</p>

<p>fi</p>

<p>done</p>

<p>if [ $n -eq 0 ]; then</p>

<p>exit 2</p>

<p>fi</p>

<p>;;</p>

<p>--del)</p>

<p>n=0</p>

<p>for u in <code>echo $2|sed 's/,/ /g'</code>; do</p>

<p>if awk -F: &lsquo;{print $1}&rsquo; /etc/passwd|grep -qw &ldquo;$u&rdquo;</p>

<p>then</p>

<p>userdel -r $u</p>

<p>echo &ldquo;The user $u deleted successfully.&rdquo;</p>

<p>n=$[$n+1]</p>

<p>else</p>

<p>echo &ldquo;The user $u not exist.&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>if [ $n -eq 0 ]; then</p>

<p>exit 3</p>

<p>fi</p>

<p>;;</p>

<p>--help)</p>

<p>echo -e &ldquo;&ndash;add can add user,and the passwd is the same as username.</p>

<p>It can add multiuser such as &ndash;add user1,user2,user3&hellip;&rdquo;</p>

<p>echo &ldquo;&ndash;del cat delete user.It can delete user such as &ndash;del
user1,user2,user3&hellip;&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;use $0 &ndash;add username or $0 &ndash;del username or $0 &ndash;help.&rdquo;</p>

<p>exit 1</p>

<p>;;</p>

<p>esac</p>

<p>23、要求如下：</p>

<ul>
<li><p>只支持三个选项 ‘&ndash;del’ ‘&ndash;add’ &ndash;help输入其他选项报错。</p></li>

<li><p>使用‘&ndash;add’需要验证用户名是否存在，存在则反馈存在。且不添加。 不存在则创建该用户，切添加与该用户名相同的密码。并且反馈。</p></li>

<li><p>使用‘&ndash;del’ 需要验证用户名是否存在，存在则删除用户及其家目录。不存在则反馈该用户不存在。</p></li>

<li><p>--help 选项反馈出使用方法</p></li>

<li><p>支持以，分隔 一次删除多个或者添加多个用户。</p></li>

<li><p>能用echo $? 检测脚本执行情况 成功删除或者添加为0,报错信息为其他数字。</p></li>

<li><p>能以，分割。一次性添加或者 删除多个用户。 例如 adddel.sh &ndash;add user1,user2,user3&hellip;&hellip;.</p></li>

<li><p>不允许存在明显bug。</p></li>
</ul>

<p>#!/bin/bash</p>

<p>#written by aming.</p>

<p>if [ $# -eq 0 -o $# -gt 2 ]</p>

<p>then</p>

<p>echo &ldquo;use $0 &ndash;add username or $0 &ndash;del username or $0 &ndash;help.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>case $1 in</p>

<p>--add)</p>

<p>n=0</p>

<p>for u in <code>echo $2|sed 's/,/ /g'</code>; do</p>

<p>if awk -F: &lsquo;{print $1}&rsquo; /etc/passwd |grep -qw &ldquo;$u&rdquo;</p>

<p>then</p>

<p>echo &ldquo;The user $u exist.&rdquo;</p>

<p>else</p>

<p>useradd $u</p>

<p>echo -e &ldquo;$u\n$u&rdquo;|passwd $u &gt;/dev/null 2&gt;&amp;1</p>

<p>echo &ldquo;The user $u added successfully.&rdquo;</p>

<p>n=$[$n+1]</p>

<p>fi</p>

<p>done</p>

<p>if [ $n -eq 0 ]; then</p>

<p>exit 2</p>

<p>fi</p>

<p>;;</p>

<p>--del)</p>

<p>n=0</p>

<p>for u in <code>echo $2|sed 's/,/ /g'</code>; do</p>

<p>if awk -F: &lsquo;{print $1}&rsquo; /etc/passwd|grep -qw &ldquo;$u&rdquo;</p>

<p>then</p>

<p>userdel -r $u</p>

<p>echo &ldquo;The user $u deleted successfully.&rdquo;</p>

<p>n=$[$n+1]</p>

<p>else</p>

<p>echo &ldquo;The user $u not exist.&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>if [ $n -eq 0 ]; then</p>

<p>exit 3</p>

<p>fi</p>

<p>;;</p>

<p>--help)</p>

<p>echo -e &ldquo;&ndash;add can add user,and the passwd is the same as username.</p>

<p>It can add multiuser such as &ndash;add user1,user2,user3&hellip;&rdquo;</p>

<p>echo &ldquo;&ndash;del cat delete user.It can delete user such as &ndash;del
user1,user2,user3&hellip;&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;use $0 &ndash;add username or $0 &ndash;del username or $0 &ndash;help.&rdquo;</p>

<p>exit 1</p>

<p>;;</p>

<p>esac</p>

<p>24、假设，当前MySQL服务的root密码为123456，写脚本检测MySQL服务是否正常（比如，可以正常进入mysql执行show
processlist），并检测一下当前的MySQL服务是主还是从，如果是从，请判断它的主从服务是否异常。如果是主，则不需要做什么</p>

<p>#!/bin/bash</p>

<p>Mysql_c=&ldquo;mysql -uroot -p123456&rdquo;</p>

<p>$Mysql_c -e &ldquo;show processlist&rdquo; &gt;/tmp/mysql_pro.log 2&gt;/tmp/mysql_log.err</p>

<p>n=<code>wc -l /tmp/mysql_log.err|awk '{print $1}'</code></p>

<p>if [ $n -gt 0 ]</p>

<p>then</p>

<p>echo &ldquo;mysql service sth wrong.&rdquo;</p>

<p>else</p>

<p>$Mysql_c -e &ldquo;show slave status\G&rdquo; &gt;/tmp/mysql_s.log</p>

<p>n1=<code>wc -l /tmp/mysql_s.log|awk '{print $1}'</code></p>

<p>if [ $n1 -gt 0 ]</p>

<p>then</p>

<p>y1=<code>grep 'Slave_IO_Running:' /tmp/mysql_s.log|awk -F : '{print $2}'|sed 's/
//g'</code></p>

<p>y2=<code>grep 'Slave_SQL_Running:' /tmp/mysql_s.log|awk -F : '{print $2}'|sed 's/
//g'</code></p>

<p>if [ $y1 == &ldquo;Yes&rdquo; ] &amp;&amp; [ $y2 == &ldquo;Yes&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;slave status good.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;slave down.&rdquo;</p>

<p>fi</p>

<p>fi</p>

<p>fi</p>

<p>25、写一个脚本判断你的Linux服务器里是否开启web服务？（监听80端口）如果开启了，请判断出跑的是什么服务，是httpd呢还是nginx又或者是其他的什么？</p>

<p>#!/bin/bash</p>

<p>#</p>

<p>if <code>netstat -an | grep '^tcp' | awk '{print$4}'| grep -q '80$'</code>;then</p>

<p>echo &ldquo;Web Service:<code>lsof -i:80 | awk '{print$1}' | grep -v 'COMMAND' | sort |
uniq</code>&ldquo;</p>

<p>else</p>

<p>echo &ldquo;There is no Web Service&rdquo;</p>

<p>fi</p>

<p>26、批量杀进程 把当前用户下所有进程名字中含有&rdquo;aming&rdquo;的进程关闭。</p>

<p>#!/bin/bash</p>

<p>ps -u $USER |awk &lsquo;$NF ~ /aming/ {print $1}&lsquo;|xargs kill</p>

<p>27、用shell实现，以并发进程的形式将mysql数据库所有的表备份到当前目录，并把所有的表压缩到一个压缩包文件里。</p>

<p>假设数据库名字为mydb，用户名为aming，密码为passwd。</p>

<p>提示： 在shell中加上&amp;可以将命令丢到后台，从而可以同时执行多条命令达到并发的效果。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>pre=<code>date +%F</code></p>

<p>for d in <code>mysql -uaming -ppasswd mydb -e &quot;show tables&quot;|grep -v 'Tables_in_'</code></p>

<p>do</p>

<p>mysqldump -uaming -ppasswd mydb $d &gt; $d.sql &amp;</p>

<p>done</p>

<p>tar czf $pre.tar.gz *.sql</p>

<p>rm -f *.sql</p>
</blockquote>

<pre><code> 
</code></pre>

<p>28、有两个文件a.txt和b.txt，需求是，把a.txt中有的并且b.txt中没有的行找出来，并写入到c.txt，然后计算c.txt文件的行数。</p>

<p>#!/bin/bash</p>

<p>n=<code>wc -l a.txt|awk '{print $1}'</code></p>

<p>[ -f c.txt ] &amp;&amp; rm -f c.txt</p>

<p>for i in <code>seq 1 $n</code></p>

<p>do</p>

<p>l=<code>sed -n &quot;$i&quot;p a.txt</code></p>

<p>if ! grep -q &ldquo;^$l$&rdquo; b.txt</p>

<p>then</p>

<p>echo $l &gt;&gt;c.txt</p>

<p>fi</p>

<p>done</p>

<p>wc -l c.txt</p>

<p>或者用grep实现</p>

<p>grep -vwf b.txt a.txt &gt; c.txt； wc -l c.txt</p>

<p>29、题目如下：</p>

<p>a=0.5 b=3 c=a*b 求c的值</p>

<p>#!/bin/bash</p>

<p>a=0.5</p>

<p>b=3</p>

<p>c=<code>echo &quot;scale=1;$a*$b&quot;|bc</code></p>

<p>echo $c</p>

<p>30、需求是，把所有的成员平均得分成若干个小组。这里，我会提供一个人员列表，比如成员有50人，需要分成7个小组，要求随机性，每次和每次分组的结构应该不一致。</p>

<blockquote>
<p>假设成员列表文件为members.txt</p>

<p>#!/bin/bash</p>

<p>f=members.txt</p>

<p>n=<code>wc -l $f|awk '{print $1}'</code></p>

<p>get_n()</p>

<p>{</p>

<p>l=<code>echo $1|wc -c</code></p>

<p>n1=$RANDOM</p>

<p>n2=$[$n1+$l]</p>

<p>g_id=$[$n1%7]</p>

<p>if [ $g_id -eq 0 ]</p>

<p>then</p>

<p>g_id=7</p>

<p>fi</p>

<p>echo $g_id</p>

<p>}</p>

<p>for i in <code>seq 1 7</code></p>

<p>do</p>

<p>[ -f n<em>$i.txt ] &amp;&amp; rm -f n</em>$i.txt</p>

<p>done</p>

<p>for i in <code>seq 1 $n</code></p>

<p>do</p>

<p>name=<code>sed -n &quot;$i&quot;p $f</code></p>

<p>g=<code>get_n $name</code></p>

<p>echo $name &gt;&gt; n_$g.txt</p>

<p>done</p>

<p>nu(){</p>

<p>wc -l $1|awk &lsquo;{print $1}&rsquo;</p>

<p>}</p>

<p>max(){</p>

<p>ma=0</p>

<p>for i in <code>seq 1 7</code></p>

<p>do</p>

<p>n=<code>nu n_$i.txt</code></p>

<p>if [ $n -gt $ma ]</p>

<p>then</p>

<p>ma=$n</p>

<p>fi</p>

<p>done</p>

<p>echo $ma</p>

<p>}</p>

<p>min(){</p>

<p>mi=50</p>

<p>for i in <code>seq 1 7</code></p>

<p>do</p>

<p>n=<code>nu n_$i.txt</code></p>

<p>if [ $n -lt $mi ]</p>

<p>then</p>

<p>mi=$n</p>

<p>fi</p>

<p>done</p>

<p>echo $mi</p>

<p>}</p>

<p>ini_min=1</p>

<p>while [ $ini_min -le 7 ]</p>

<p>do</p>

<p>m1=<code>max</code></p>

<p>m2=<code>min</code></p>

<p>ini_min=m2</p>

<p>for i in <code>seq 1 7</code></p>

<p>do</p>

<p>n=<code>nu n_$i.txt</code></p>

<p>if [ $n -eq $m1 ]</p>

<p>then</p>

<p>f1=n_$i.txt</p>

<p>elif [ $n -eq $m2 ]</p>

<p>then</p>

<p>f2=n_$i.txt</p>

<p>fi</p>

<p>done</p>

<p>name=<code>tail -n1 $f1</code></p>

<p>echo $name &gt;&gt; $f2</p>

<p>sed -i &ldquo;/$name/d&rdquo; $f1</p>

<p>ini_min=$[$ini_min+1]</p>

<p>done</p>

<p>for i in <code>seq 1 7</code></p>

<p>do</p>

<p>echo &ldquo;$i 组成员有：&rdquo;</p>

<p>cat n_$i.txt</p>

<p>echo</p>

<p>done</p>
</blockquote>

<p>31、将文件内所有的单词的重复次数计算出来，只需要列出重复次数最多的10个单词。</p>

<p>假设文档名字叫做a.txt</p>

<p>sed &rsquo;s/[^a-zA-Z]/ /g&rsquo; a.txt|xargs -n1 |sort |uniq -c |sort -nr |head</p>

<p>32、设计一个shell程序，在每月第一天备份并压缩/etc目录的所有内容，存放在/root/bak目录里，且文件名为如下形式&rdquo;yymmdd_etc.tar.gz&rdquo;，yy为年，mm为月，dd为日。</p>

<blockquote>
<p>#!/bin/sh</p>

<p>if [ -d /root/bak ]</p>

<p>then</p>

<p>mkdir /root/bak</p>

<p>fi</p>

<p>prefix=<code>date +%y%m%d</code></p>

<p>d=<code>date +%m</code></p>

<p>if [ $d == &ldquo;01&rdquo; ]</p>

<p>then</p>

<p>cd /etc/</p>

<p>tar czf /root/bak/$prefix_etc.tar.gz ./</p>

<p>fi</p>
</blockquote>

<p>33、在文本文档1.txt第5行后面增加如下内容：</p>

<h1 id="this-is-a-test-file">This is a test file.</h1>

<h1 id="test-insert-line-into-this-file">Test insert line into this file.</h1>

<p>答 ： sed -i &ldquo;5a # This is a test file.\n# Test insert line into this file.&rdquo;
1.txt</p>

<p>34、写一个shell脚本。提示你输入一个暂停的数字，然后从1打印到该数字。然后询问是否继续。继续的话在输入个在数字 接着打印。不继续退出。</p>

<p>例：如果输入的是5，打印1 2 3 4 5 然后继续 输入15 然后打印 6 7 &hellip;14 15 依此类推。</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;请输入您想要暂停的数字：&rdquo; number_1</p>

<p>for i in <code>seq 1 $number_1</code>;</p>

<p>do</p>

<p>echo $i</p>

<p>done</p>

<p>read -p &ldquo;是否继续输入数字？&rdquo; a</p>

<p>if [ $a == &ldquo;yes&rdquo; ];then</p>

<p>read -p &ldquo;请继续输入您想要暂停的数字：&rdquo; number_2</p>

<p>number_3=$[$number_1+1]</p>

<p>if [ $number_2 -gt $number_1 ];then</p>

<p>for h in <code>seq $number_3 $number_2</code>;</p>

<p>do</p>

<p>echo $h</p>

<p>done</p>

<p>else</p>

<p>echo &ldquo;输入数字错误，请输入大于的数字!&rdquo;</p>

<p>fi</p>

<p>else</p>

<p>exit</p>

<p>fi</p>

<p>35、已知nginx访问的日志文件在/usr/local/nginx/logs/access.log内</p>

<p>请统计下早上10点到12点 来访ip最多的是哪个?</p>

<p>日志样例：</p>

<p>111.199.186.68 - [15/Sep/2017:09:58:37 +0800] &ldquo;//plugin.php?id=security:job&rdquo;
200 &ldquo;POST //plugin.php?id=security:job
HTTP/1.1&rdquo;&ldquo;<a href="http://a.lishiming.net/forum.php?mod=viewthread&amp;tid=11338&amp;extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline&quot;">http://a.lishiming.net/forum.php?mod=viewthread&amp;tid=11338&amp;extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline&quot;</a>
&ldquo;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)
Chrome/61.0.3141.7 Safari/537.36&rdquo; &ldquo;0.516&rdquo;</p>

<p>203.208.60.208 - [15/Sep/2017:09:58:46 +0800]
&ldquo;/misc.php?mod=patch&amp;action=ipnotice&amp;_r=0.05560809863330207&amp;inajax=1&amp;ajaxtarget=ip_notice&rdquo;
200 &ldquo;GET
/misc.php?mod=patch&amp;action=ipnotice&amp;_r=0.05560809863330207&amp;inajax=1&amp;ajaxtarget=ip_notice
HTTP/1.1&rdquo;&ldquo;<a href="http://a.lishiming.net/forum.php?mod=forumdisplay&amp;fid=65&amp;filter=author&amp;orderby=dateline&quot;">http://a.lishiming.net/forum.php?mod=forumdisplay&amp;fid=65&amp;filter=author&amp;orderby=dateline&quot;</a>
&ldquo;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)
Chrome/61.0.3141.7 Safari/537.36&rdquo; &ldquo;0.065&rdquo;</p>

<p>答 ： grep &lsquo;15/Sep/2017:1[0-2]:[0-5][0-9]:&rsquo; /usr/local/nginx/logs/access.log|awk
&lsquo;{print $1}&rsquo;|sort -n|uniq -c |tail -n1</p>

<p>36、一个同学提到一个问题，他不小心用iptables规则把sshd端口22给封掉了，结果不能远程登陆，要想解决这问题，还要去机房，登陆真机去删除这规则。
问题来了，要写个监控脚本，监控iptables规则是否封掉了22端口，如果封掉了，给打开。 写好脚本，放到任务计划里，每分钟执行一次。</p>

<blockquote>
<p>#!/bin/bash</p>

<h1 id="check-sshd-port-drop">check sshd port drop</h1>

<p>/sbin/iptables -nvL &ndash;line-number|grep &ldquo;dpt:22&rdquo;|awk -F &lsquo; &rsquo; &lsquo;{print $4}&rsquo; &gt;
/tmp/drop.txt</p>

<p>i=<code>cat /tmp/drop.txt|head -n 1|egrep -iE &quot;DROP|REJECT&quot;|wc -l</code></p>

<p>if [ $i -gt 0 ]</p>

<p>then</p>

<p>/sbin/iptables -I INPUT 1 -p tcp &ndash;dport 22 -j ACCEPT</p>

<p>fi</p>
</blockquote>

<p>37、需求：将用户家目录（考虑到执行脚本的用户可能是普通用户也可能是root）下面小于5KB的文件打包成tar.gz的压缩包，并以当前日期为文件名前缀，例如今天打包的文件为2017-09-14.tar.gz。</p>

<p>#!/bin/bash</p>

<p>t=<code>date +%F</code></p>

<p>cd $HOME</p>

<p>tar czf $t.tar.gz <code>find . -type f -size -5k</code></p>

<p>38、写一个shell脚本，通过curl -I 返回的状态码来判定所访问的网站是否正常。比如，当状态码为200时，才算正常。</p>

<blockquote>
<p>#/bin/bash</p>

<p>url=&ldquo;<a href="http://www.apelearn.com/index.php&quot;">http://www.apelearn.com/index.php&quot;</a></p>

<p>sta=<code>curl -I $url 2&gt;/dev/null |head -1 |awk '{print $2}'</code></p>

<p>if [ $sta != &ldquo;200&rdquo; ]</p>

<p>then</p>

<p>python /usr/local/sbin/mail.py xxx@qq.com &ldquo;$url down.&rdquo; &ldquo;$url down&rdquo;</p>

<p>fi</p>
</blockquote>

<p>39、1 每10分钟检测一次指定网卡的流量</p>

<p>2 如果流量为0，则重启网卡</p>

<p>#!/bin/bash</p>

<p>LANG=en</p>

<p>n1=<code>sar -n DEV 1 60 |grep eth0 |grep -i average|awk '{print $5}'|sed
's/\\.//g'</code></p>

<p>n2=<code>sar -n DEV 1 60 |grep eth0 |grep -i average|awk '{print $6}'|sed
's/\\.//g'</code></p>

<p>if [ $n1 == &ldquo;000&rdquo; ] &amp;&amp; [ $n2 == &ldquo;000&rdquo; ]</p>

<p>then</p>

<p>ifdown eth0</p>

<p>ifup eth0</p>

<p>fi</p>

<p>然后写个cron，10分钟执行一次</p>

<p>40、用shell脚本判断输入的日期是否合法。就是判断日期是都是真实的日期，比如20170110就是合法日期，20171332就不合法。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>#check date</p>

<p>if [ $# -ne 1 ] || [ ${#1} -ne 8 ]</p>

<p>then</p>

<p>echo &ldquo;Usage: bash $0 yyyymmdd&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>datem=$1</p>

<p>year=${datem:0:4}</p>

<p>month=${datem:4:2}</p>

<p>day=${datem:6:2}</p>

<p>if echo $day|grep -q &lsquo;^0&rsquo;</p>

<p>then</p>

<p>day=<code>echo $day |sed 's/^0//'</code></p>

<p>fi</p>

<p>if cal $month $year &gt;/dev/null 2&gt;/dev/null</p>

<p>then</p>

<p>daym=<code>cal $month $year|egrep -v &quot;$year|Su&quot;|grep -w &quot;$day&quot;</code></p>

<p>if [ &ldquo;$daym&rdquo; != &ldquo;&rdquo; ]</p>

<p>then</p>

<p>echo ok</p>

<p>else</p>

<p>echo &ldquo;Error: Please input a wright date.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>else</p>

<p>echo &ldquo;Error: Please input a wright date.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>
</blockquote>

<p>41、先判断是否安装http和mysql，没有安装进行安装，安装了检查是否启动服务，若没有启动则需要启动服务。</p>

<p>说明：操作系统为centos6，httpd和mysql全部为rpm包安装。</p>

<p>#!/bin/bash</p>

<p>if_install()</p>

<p>{</p>

<p>n=<code>rpm -qa|grep -cw &quot;$1&quot;</code></p>

<p>if [ $n -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;$1 not install.&rdquo;</p>

<p>yum install -y $1</p>

<p>else</p>

<p>echo &ldquo;$1 installed.&rdquo;</p>

<p>fi</p>

<p>}</p>

<p>if_install httpd</p>

<p>if_install mysql-server</p>

<p>chk_ser()</p>

<p>{</p>

<p>p_n=<code>ps -C &quot;$1&quot; --no-heading |wc -l</code></p>

<p>if [ $p_n -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;$1 not start.&rdquo;</p>

<p>/etc/init.d/$1 start</p>

<p>else</p>

<p>echo &ldquo;$1 started.&rdquo;</p>

<p>fi</p>

<p>}</p>

<p>chk_httpd</p>

<p>chk_mysqld</p>

<p>42、写一个脚本产生随机3位的数字，并且可以根据用户的输入参数来判断输出几组。 比如，脚本名字为 number3.sh。<br />
执行方法：<br />
bash number3.sh<br />
直接产生一组3位数字。<br />
bash number3.sh 10<br />
插上10组3位数字。</p>

<p>思路： 可以使用echo $RANDOM获取一个随机数字，然后再除以10，取余获取0-9随机数字，三次运算获得一组。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>get_a_num() {<br />
 n=$[$RANDOM%10]<br />
 echo $n<br />
 }</p>

<p>get_numbers() {<br />
 for i in 1 2 3; do<br />
 a[$i]=<code>get_a_num</code><br />
 done<br />
 echo ${a[@]}<br />
 }</p>

<p>if [ -n &ldquo;$1&rdquo; ]; then<br />
 m=<code>echo $1|sed 's/[0-9]//g'</code><br />
 if [ -n &ldquo;$m&rdquo; ]; then<br />
 echo &ldquo;Useage bash $0 n, n is a number, example: bash $0 5&rdquo;<br />
 exit<br />
 else<br />
 for i in <code>seq 1 $1</code><br />
 do<br />
 get_numbers<br />
 done<br />
 fi<br />
 else<br />
 get_numbers</p>

<p>fi</p>
</blockquote>

<p>43、写一个getinterface.sh 脚本可以接受选项[i，I]，完成下面任务：</p>

<p>1）使用一下形式：getinterface.sh [-i interface | -I ip]</p>

<p>2）当用户使用-i选项时，显示指定网卡的IP地址；当用户使用-I选项时，显示其指定ip所属的网卡。</p>

<p>例：sh getinterface.sh -i eth0</p>

<p>sh getinterface.sh -I 192.168.0.1</p>

<p>3）当用户使用除[-i | -I]选项时，显示[-i interface | -I ip]此信息。</p>

<p>4）当用户指定信息不符合时，显示错误。（比如指定的eth0没有，而是eth1时）</p>

<p>#!/bin/bash</p>

<p>ip add |awk -F &ldquo;:&rdquo; &lsquo;$1 ~ /<sup class="footnote-ref" id="fnref:1-9"><a href="#fn:1-9">1</a></sup>/ {print $2}&lsquo;|sed &rsquo;s/ //g&rsquo; &gt; /tmp/eths.txt</p>

<p>[ -f /tmp/eth_ip.log ] &amp;&amp; rm -f /tmp/eth_ip.log</p>

<p>for eth in <code>cat /tmp/eths.txt</code></p>

<p>do</p>

<p>ip=<code>ip add |grep -A2 &quot;: $eth&quot; |grep inet |awk '{print $2}' |cut -d '/' -f 1</code></p>

<p>echo &ldquo;$eth:$ip&rdquo; &gt;&gt; /tmp/eth_ip.log</p>

<p>done</p>

<p>useage()</p>

<p>{</p>

<p>echo &ldquo;Please useage: $0 -i 网卡名字 or $0 -I ip地址&rdquo;</p>

<p>}</p>

<p>wrong_eth()</p>

<p>{</p>

<p>if ! grep -q &ldquo;$1&rdquo; /tmp/eth_ip.log</p>

<p>then</p>

<p>echo &ldquo;请指定正确的网卡名字&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>}</p>

<p>wrong_ip()</p>

<p>{</p>

<p>if ! grep -qw &ldquo;$1&rdquo; /tmp/eth_ip.log</p>

<p>then</p>

<p>echo &ldquo;请指定正确的ip地址&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>}</p>

<p>if [ $# -ne 2 ]</p>

<p>then</p>

<p>useage</p>

<p>exit</p>

<p>fi</p>

<p>case $1 in</p>

<p>-i)</p>

<p>wrong_eth $2</p>

<p>grep $2 /tmp/eth_ip.log |awk -F &lsquo;:&rsquo; &lsquo;{print $2}&rsquo;</p>

<p>;;</p>

<p>-I)</p>

<p>wrong_ip $2</p>

<p>grep $2 /tmp/eth_ip.log |awk -F &lsquo;:&rsquo; &lsquo;{print $1}&rsquo;</p>

<p>;;</p>

<p>*)</p>

<p>useage</p>

<p>exit</p>

<p>esac</p>

<p>44、比如1.txt内容<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7</p>

<p>处理后应该是<br />
1 2 3<br />
4 5 6<br />
7</p>

<p>sed &lsquo;N;N;s/\n/ /g&rsquo; 1.txt</p>

<p>45、先普及一小段知识,我们用ps
aux可以查看到进程的PID，而每个PID都会在/proc内产生。如果查看到的pid而proc内是没有的，则是进程被人修改了，这就代表你的系统很有可能已经被入侵过了。</p>

<p>请大家用上面知识编写一个shell，定期检查下自己的系统是否被人入侵过。</p>

<p>#!/bin/bash</p>

<p>ps aux|awk &lsquo;/[0-9]/ {print $2}&lsquo;|while read pid</p>

<p>do</p>

<p>result=<code>find /proc/ -maxdepth 1 -type d -name &quot;$pid&quot;</code></p>

<p>if [ -z $result ]; then</p>

<p>echo &ldquo;$pid abnormal!&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>46、1 编写一个名为chname的程序，将当前目录下所有的.txt文件更名为.doc文件。</p>

<p>2 编写一个名为chuser的程序，执行中每隔5分钟检查指定的用户是否登录系统，用户名从命令行输入；如果指定的用户已经登录，则显示相关信息。</p>

<p>#!/bin/bash</p>

<p>find . -type f -name &ldquo;*.txt&rdquo; &gt; /tmp/txt.list</p>

<p>for f in <code>cat /tmp/txt.list</code></p>

<p>do</p>

<p>n=<code>echo $f|sed -r 's/(.*)\\.txt/\1/'</code></p>

<p>echo &ldquo;mv $f $n.doc&rdquo;</p>

<p>done</p>

<p>2</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;Please input the username: &ldquo; user</p>

<p>while :</p>

<p>do</p>

<p>if who | grep -qw $user</p>

<p>then</p>

<p>echo $user login.</p>

<p>else</p>

<p>echo $user not login.</p>

<p>fi</p>

<p>sleep 300</p>

<p>done</p>

<p>47、1 编写一个名为ifuser的程序，它执行时带用户名作为命令行参数，判断该用户是否已经在系统中登录，并给出相关信息。</p>

<p>2 编写一个名为menu的程序，实现简单的弹出式菜单功能，用户能根据显示的菜单项从键盘选择执行对应的命令。</p>

<p>1 #!/bin/bash</p>

<p>read -p &ldquo;Please input the username: &ldquo; user</p>

<p>if who | grep -qw $user</p>

<p>then</p>

<p>echo $user is online.</p>

<p>else</p>

<p>echo $user not online.</p>

<p>fi</p>

<p>2.</p>

<p>#!/bin/bash</p>

<p>function message()</p>

<p>{</p>

<p>echo &ldquo;0. w&rdquo;</p>

<p>echo &ldquo;1. ls&rdquo;</p>

<p>echo &ldquo;2.quit&rdquo;</p>

<p>read -p &ldquo;Please input parameter: &ldquo; Par</p>

<p>}</p>

<p>message</p>

<p>while [ $Par -ne &lsquo;2&rsquo; ] ; do</p>

<p>case $Par in</p>

<p>0)</p>

<p>w</p>

<p>;;</p>

<p>1)</p>

<p>ls</p>

<p>;;</p>

<p>2)</p>

<p>exit</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;Unkown command&rdquo;</p>

<p>;;</p>

<p>esac</p>

<p>message</p>

<p>done</p>

<p>48、1 编写一个名为iffile程序，它执行时判断/bin目录下date文件是否存在？</p>

<p>2 编写一个名为greet的问候程序，它执行时能根据系统当前的时间向用户输出问候信息。设从半夜到中午为早晨，中午到下午六点为下午，下午六点到半夜为晚上。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>if [ -f /bin/date ]</p>

<p>then</p>

<p>echo &ldquo;/bin/date file exist.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;/bin/date not exist.&rdquo;</p>

<p>fi</p>

<p>2</p>

<p>#!/bin/bash</p>

<p>h=<code>date +%H</code></p>

<p>if [ $h -ge 0 ] &amp;&amp; [ $h -lt 12 ]</p>

<p>then</p>

<p>echo &ldquo;Good morning.&rdquo;</p>

<p>elif [ $h -ge 12 ] &amp;&amp; [ $h -lt 18 ]</p>

<p>then</p>

<p>echo &ldquo;Good afternoon.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Good evening.&rdquo;</p>

<p>fi</p>
</blockquote>

<p>49、输入一串随机数字，然后按千分位输出。</p>

<p>比如输入数字串为“123456789”，输出为123,456,789</p>

<blockquote>
<p>#!/bin/bash</p>

<p>read -p &ldquo;输入一串数字：&rdquo; num</p>

<p>v=<code>echo $num|sed 's/[0-9]//g'</code></p>

<p>if [ -n &ldquo;$v&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;请输入纯数字.&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>length=${#num}</p>

<p>len=0</p>

<p>sum=&rdquo;</p>

<p>for i in $(seq 1 $length)</p>

<p>do</p>

<p>len=$[$len+1]</p>

<p>if [[ $len == 3 ]]</p>

<p>then</p>

<p>sum=&lsquo;,&rsquo;${num:$[0-$i]:1}$sum</p>

<p>len=0</p>

<p>else</p>

<p>sum=${num:$[0-$i]:1}$sum</p>

<p>fi</p>

<p>done</p>

<p>if [[ -n $(echo $sum | grep &lsquo;^,&rsquo; ) ]]</p>

<p>then</p>

<p>echo ${sum:1}</p>

<p>else</p>

<p>echo $sum</p>

<p>fi</p>

<p>上面这个答案比较复杂，下面再来一个sed的</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;输入一串数字：&rdquo; num</p>

<p>v=<code>echo $num|sed 's/[0-9]//g'</code></p>

<p>if [ -n &ldquo;$v&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;请输入纯数字.&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>echo $num|sed -r &lsquo;{:number;s/([0-9]+)([0-9]{3})/\1,\2/;t number}&rsquo;</p>
</blockquote>

<p>50、检查错误</p>

<blockquote>
<p>#!/bin/bash<br />
 sh -n $1 2&gt;/tmp/err<br />
 if [ $? -eq &ldquo;0&rdquo; ]<br />
 then<br />
 echo &ldquo;The script is OK.&rdquo;<br />
 else<br />
 cat /tmp/err<br />
 read -p &ldquo;Please inpupt Q/q to exit, or others to edit it by vim. &rdquo; n<br />
 if [ -z $n ]<br />
 then<br />
 vim $1<br />
 exit<br />
 fi<br />
 if [ $n == &ldquo;q&rdquo; -o $n == &ldquo;Q&rdquo; ]<br />
 then<br />
 exit<br />
 else<br />
 vim $1<br />
 exit<br />
 fi</p>

<p>fi</p>
</blockquote>

<p>51、一个网站，使用了cdn，全国各地有几十个节点。需要你写一个shell脚本来监控各个节点是否正常。</p>

<p>假如</p>

<p>1 监控的url为www.aming.com/index.php</p>

<p>2 源站ip为88.88.88.88</p>

<p>3 以及各个节点ip列表文件为/tmp/ip.txt</p>

<p>#!/bin/bash</p>

<p>url=&ldquo;www.aming.com/index.php&rdquo;</p>

<p>s_ip=&ldquo;88.88.88.88&rdquo;</p>

<p>curl -x $s_ip:80 $url &gt; /tmp/source.html 2&gt;/dev/null</p>

<p>for ip in <code>cat /tmp/ip.txt</code></p>

<p>do</p>

<p>curl -x $ip:80 $url 2&gt;/dev/null &gt;/tmp/$ip.html</p>

<p>[ -f /tmp/$ip.diff ] &amp;&amp; rm -f /tmp/$ip.diff</p>

<p>touch /tmp/$ip.diff</p>

<p>diff /tmp/source.html /tmp/$ip.html &gt; /tmp/$ip.diff 2&gt;/dev/null</p>

<p>n=<code>wc -l /tmp/$ip.diff|awk '{print $1}'</code></p>

<p>if [ $n -lt 0 ]</p>

<p>then</p>

<p>echo &ldquo;node $ip sth wrong.&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>52、写一个脚本：<br />
判断当前主机的CPU生产商，其信息在/proc/cpuinfo文件中vendor id一行中。<br />
如果其生产商为AuthenticAMD，就显示其为AMD公司；<br />
如果其生产商为GenuineIntel，就显示其为Intel公司；<br />
否则，就说其为非主流公司。</p>

<p>#!/bin/bash</p>

<p>m=<code>cat /proc/cpuinfo |grep vendor_id|awk -F&quot;:&quot; '{print $2}'|tail -1</code></p>

<p>if [ $m == &ldquo;GenuineIntel&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;cpu is 英特尔&rdquo;</p>

<p>elif [ $m == &ldquo;AuthenticAMD&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;cpu is AMD&rdquo;</p>

<p>else</p>

<p>echo &ldquo;cpu is 非主流&rdquo;</p>

<p>fi</p>

<p><strong>53、破解字符串</strong></p>

<p>说明：题目中最后一个字符串少写了一位，应该是890684ba</p>

<p>#!/bin/bash</p>

<p>for n in {0..32767}</p>

<p>do</p>

<p>MD5=<code>echo $n | md5sum | cut -c 1-8</code></p>

<p>if [ &ldquo;$MD5&rdquo; == &ldquo;$1&rdquo; ];then</p>

<p>echo &ldquo;$n $c &ldquo;</p>

<p>break</p>

<p>fi</p>

<p>done</p>

<p>54、用shell写一个监控服务器cpu使用率的监控脚本。</p>

<p>思路：用top -bn1 命令，取当前空闲cpu百份比值（只取整数部分），然后用100去剑这个数值。</p>

<p>55、脚本添加了只要使用率超过80%就会发一封报警邮件，脚本每隔5秒钟执行一次！ #! /bin/bash</p>

<p>##monitoring the cpu value if alwasy higher or not</p>

<p>##written by zhdya_20171012</p>

<p>while :</p>

<p>do</p>

<p>sum=0</p>

<p>for i in <code>top -bn1 | awk '{print $9}'| sed -n '8,$'p | cut -d &quot;.&quot; -f 1</code></p>

<p>do</p>

<p>sum=$[$sum+$i]</p>

<p>done</p>

<p>echo &ldquo;the cpu already used $sum%&rdquo;</p>

<p>if [ $sum -gt 80 ]</p>

<p>then</p>

<p>echo &ldquo;the cpu already used $sum%, pls pay attention..&rdquo; ##sendmail</p>

<p>fi</p>

<p>sleep 5</p>

<p>done</p>

<p>56、说明：本shell题目是一个网友在公众号中提问的，正好利用这个每日习题的机会拿出来让大家一起做一做。</p>

<p>给出一个进程PID，打印出该进程下面的子进程以及子进程下面的所有子进程。（只需要考虑子进程的子进程，再往深层次则不考虑）</p>

<p>57、用shell写一个监控服务器cpu使用率的监控脚本。</p>

<p>思路：用top -bn1 命令，取当前空闲cpu百份比值（只取整数部分），然后用100去剑这个数值。</p>

<p>#!/bin/bash</p>

<p>while :</p>

<p>do</p>

<p>idle=<code>top -bn1 |sed -n '3p' |awk '{print $5}'|cut -d . -f1</code></p>

<p>use=$[100-$idle]</p>

<p>if [ $use -gt 90 ]</p>

<p>then</p>

<p>echo &ldquo;cpu use percent too high.&rdquo;</p>

<p>#发邮件省略</p>

<p>fi</p>

<p>sleep 10</p>

<p>done</p>

<p>58、上一篇文章我们介绍了命名管道FIFO，利用里面的知识点，实现这个需求。</p>

<p>需求背景：</p>

<p>领导要求小明备份数据库服务器里面的100个库（数据量在几十到几百G），需要以最快的时间完成（5小时内），并且不能影响服务器性能。</p>

<p>需求分析：</p>

<p>由于数据量比较大，单个库备份时间少则10几分钟，多则几个小时，我们算平均每个库30分钟，若一个库一个库的去备份，则需要3000分钟，相当于50个小时。很明显不可取。但全部丢到后台去备份，100个并发，数据库服务器也无法承受。所以，需要写一个脚本，能够控制并发数就可以实现了。</p>

<p>#!/bin/sh</p>

<p>##假设100个库的名字存到了一个文件里，文件名字为/tmp/databases.list</p>

<p>##其中备份数据库用了mysqldump，这里你可以换成xtrabackup，更快</p>

<p>function bak_data {</p>

<p>dbname=$1</p>

<p>d=<code>date +%y%d</code></p>

<p>mysqldump -uroot -pxxxxx $dbname &gt; /backup/$1.$d</p>

<p>}</p>

<p>mkfifo $tmp_fifofile</p>

<p>exec 1000&lt;&gt;$tmp_fifofile</p>

<p>rm -f $tmp_fifofile</p>

<p>thread=10</p>

<p>for ((i=0;i</p>

<p>do</p>

<p>echo &gt;&amp;1000</p>

<p>done</p>

<p>for d in <code>cat /tmp/databases.list</code></p>

<p>do</p>

<p>read -u6</p>

<p>{</p>

<p>bak_data $d</p>

<p>echo &gt;&amp;1000</p>

<p>} &amp;</p>

<p>done</p>

<p>wait</p>

<p>exec 1000&gt;&amp;-</p>

<p>59、我们使用的云主机，购买一块云盘后，默认并不是挂载状态的，用shell写一个脚本，只要把盘符和挂载点以参数的形式提供给脚本，该脚本就可以自动格式化、挂载。</p>

<p>要求：</p>

<p>1 不用分区，直接格式化</p>

<p>2 格式化为ext4文件系统类型</p>

<p>#!/bin/bash</p>

<p>echo &ldquo;Useage $0 盘符 挂载点, 如： $0 /dev/xvdb /data&rdquo;</p>

<p>if [ $# -ne 2 ]</p>

<p>then</p>

<p>exit</p>

<p>fi</p>

<p>if [ ! -b $1 ]</p>

<p>then</p>

<p>echo &ldquo;你提供的盘符不正确，请检查后再操作&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>mkfs -t ext4 $1</p>

<p>if [ ! -d $2 ] ;then</p>

<p>mkdir -p $2</p>

<p>fi</p>

<p>n=<code>egrep &quot; $2 &quot; /etc/fstab|wc -l</code></p>

<p>if [ $n -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;$1 $2 ext4 defaults 0 0&rdquo; &gt;&gt; /etc/fstab</p>

<p>mount -a</p>

<p>else</p>

<p>mount $1 $2</p>

<p>echo &ldquo;配置文件/etc/fstab中已经存在挂载点$2,请检查一下.&rdquo;</p>

<p>fi</p>

<p>60、自动封/解封ip</p>

<p>需求背景：</p>

<p>discuz论坛，每天有很多注册机注册的用户，然后发垃圾广告帖子。虽然使用了一些插件但没有效果。分析访问日志，发现有几个ip访问量特别大，所以想到可以写个shell脚本，通过分析访问日志，把访问量大的ip直接封掉。</p>

<p>但是这个脚本很有可能误伤，所以还需要考虑到自动解封这些ip。</p>

<p>思路：</p>

<p>1 可以每分钟分析1次访问日志，设定一个阈值，把访问量大的ip用iptables封掉80端口</p>

<p>2 每20分钟检测一次已经被封ip的请求数据包数量，设定阈值，把没有请求的或者请求量很小的解封</p>

<p>#! /bin/bash</p>

<h2 id="to-block-the-ip-of-bad-requesting">To block the ip of bad requesting.</h2>

<h2 id="writen-by-aming-2017-11-18">Writen by aming 2017-11-18.</h2>

<p>log=&ldquo;/data/logs/www.xxx.com.log&rdquo;</p>

<p>tmpdir=&ldquo;/tmp/badip&rdquo;</p>

<p>#白名单ip，不应该被封</p>

<p>goodip=&ldquo;27.133.28.101&rdquo;</p>

<p>[ -d $tmpdir ] || mkdir -p $tmpdir</p>

<p>t=<code>date -d &quot;-1 min&quot; +%Y:%H:%M</code></p>

<p>#截取一分钟以前的日志</p>

<p>grep &ldquo;$t:&rdquo; $log &gt; $tmpdir/last_min.log</p>

<p>#把一分钟内日志条数大于120的标记为不正常的请求</p>

<p>awk &lsquo;{print $1}&rsquo; $tmpdir/last_min.log |sort -n |uniq -c |sort -n |tail |awk
&lsquo;$1&gt;120 {print $2}&rsquo;|grep -v &ldquo;$good_ip&rdquo;&gt; $tmpdir/bad.ip</p>

<p>d3=<code>date +%M</code></p>

<p>#每隔20分钟解封一次ip</p>

<p>if [ $d3 -eq &ldquo;20&rdquo; ] || [ $d3 -eq &ldquo;40&rdquo; ] || [ $d3 -eq &ldquo;00&rdquo; ]; then</p>

<p>/sbin/iptables -nvL INPUT|grep &lsquo;DROP&rsquo; |awk &lsquo;$1<10 {print $8}'>$tmpdir/good.ip</p>

<p>if [ -s $tmpdir/good.ip ]; then</p>

<p>for ip in <code>cat $tmpdir/good.ip</code></p>

<p>do</p>

<p>/sbin/iptables -D INPUT -p tcp &ndash;dport 80 -s $ip -j DROP</p>

<p>d4=<code>date +%Y%m%d-%H:%M</code></p>

<p>echo &ldquo;$d4 $ip unblock&rdquo; &gt;&gt;$tmpdir/unblock.ip</p>

<p>done</p>

<p>fi</p>

<p>#解封后，再把iptables的计数器清零</p>

<p>/sbin/iptables -Z INPUT</p>

<p>fi</p>

<p>if [ -s $tmpdir/bad.ip ] ; then</p>

<p>for ip in <code>cat $tmpdir/bad.ip</code></p>

<p>do</p>

<p>/sbin/iptables -A INPUT -p tcp &ndash;dport 80 -s $ip -j DROP</p>

<p>d4=<code>date +%Y%m%d-%H:%M</code></p>

<p>echo &ldquo;$d4 $ip block&rdquo; &gt;&gt;$tmpdir/block.ip</p>

<p>done</p>

<p>fi</p>

<p>61、写个shell脚本，能够实现一键安装并配置samba服务，执行该脚本时需要带一个参数，为共享的目录，目录可以不存在，若不存在，需要脚本自动创建。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>is_samba_installed=<code>rpm -qa|grep samba|wc -l</code></p>

<p>if [ $is_samba_installed != 0 ]</p>

<p>then</p>

<p>echo &ldquo;You had already installed Samba.&rdquo;</p>

<p>exit 0</p>

<p>fi</p>

<p>echo &ldquo;It will install Samba.&rdquo;</p>

<p>sleep 1</p>

<p>cnfdir=&ldquo;/etc/samba/smb.conf&rdquo;</p>

<p>chkok(){</p>

<p>if [ $? != 0 ]</p>

<p>then</p>

<p>echo &ldquo;Error, Please try again.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>}</p>

<p>yum install -y samba</p>

<p>chkok</p>

<p>sed -i &rsquo;s/MYGROUP/WORKGROUP/&rsquo; $cnfdir</p>

<p>sed -i &rsquo;s/user/share/&rsquo; $cnfdir</p>

<p>sed -i &lsquo;$a\[fish]&rsquo; $cnfdir</p>

<p>if [ -d $1 ]</p>

<p>then</p>

<p>cd $1</p>

<p>echo &ldquo;test&rdquo; &gt; test.txt</p>

<p>sed -i &lsquo;$a\[fish]\n\tcomment = Share All\n\tpath = &ldquo;&lsquo;$1&rsquo;&rdquo;\n\tbrowseable =
yes\n\tpublic = yes\n\twritable = no&rsquo; $cnfdir</p>

<p>else</p>

<p>mkdir $1</p>

<p>cd $1</p>

<p>echo &ldquo;test&rdquo; &gt; test.txt</p>

<p>sed -i &lsquo;$a\[fish]\n\tcomment = Share All\n\tpath = &ldquo;&lsquo;$1&rsquo;&rdquo;\n\tbrowseable =
yes\n\tpublic = yes\n\twritable = no&rsquo; $cnfdir</p>

<p>fi</p>

<p>/etc/init.d/smb start</p>

<p>chkok</p>

<p>echo &ldquo;Please input [\\sambaIP\sharename] to access the share dir.&rdquo;</p>
</blockquote>

<p>62、用shell写一个脚本，实现一键管理docker容器，比如启动/关闭/删除容器等操作。</p>

<p>要求：</p>

<p>1 脚本支持启动全部容器、关闭全部容器、删除全部容器</p>

<p>2 需要提示用户如何使用该脚本，需给出范例</p>

<p>#! /bin/bash</p>

<p>##start,restart,delete the docker containers</p>

<p>##written by zhdya_20171114</p>

<p>list=<code>docker ps -a |awk '{print $2}'| grep -v 'ID'</code></p>

<p>echo &ldquo;=======================================&rdquo;</p>

<p>echo -e &ldquo;pls check the follow list of container: \n$list&rdquo;</p>

<p>read -p &ldquo;pls choose an action which you want!<1.start 2.stop 3.rm > &ldquo; act</p>

<p>echo &ldquo;======================================&rdquo;</p>

<p>echo -e &ldquo;stop\nstart\nrm\nrmi&rdquo; &gt; /tmp/docker.txt</p>

<p>##judge if input the words or not!</p>

<p>if [ -z $act ]</p>

<p>then</p>

<p>echo &ldquo;you type was wrong,pls just input &ldquo;start&rdquo;.&ldquo;stop&rdquo;.&ldquo;rm&rdquo;.&ldquo;rmi&rdquo;.&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>##judge if input a wrong words!!</p>

<p>if grep -wq $act /tmp/docker.txt</p>

<p>then</p>

<p>case $act in</p>

<p>start)</p>

<p>docker start $(docker ps -a | awk &lsquo;{ print $1}&rsquo; | tail -n +2)</p>

<p>echo &ldquo;already start all of container,pls checking it..&rdquo;</p>

<p>;;</p>

<p>stop)</p>

<p>docker stop $(docker ps -a | awk &lsquo;{ print $1}&rsquo; | tail -n +2)</p>

<p>echo &ldquo;already restart all of container,pls checking it..&rdquo;</p>

<p>;;</p>

<p>rm)</p>

<p>docker rm $(docker ps -a | awk &lsquo;{ print $1}&rsquo; | tail -n +2)</p>

<p>echo &ldquo;already rm all of container,pls checking it..&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>docker rmi $(docker images | awk &lsquo;{print $3}&rsquo; |tail -n +2)</p>

<p>echo &ldquo;already rm all of container,pls checking it..&rdquo;</p>

<p>esac</p>

<p>else</p>

<p>echo &ldquo;you type was wrong,pls just input &ldquo;start&rdquo;.&ldquo;stop&rdquo;.&ldquo;rm&rdquo;.&ldquo;rmi&rdquo;.&rdquo;</p>

<p>fi</p>

<p><strong>63、用shell脚本实现，部署mysql主从架构。</strong></p>

<p>思路是这样的：</p>

<p>1）master.sh脚本用来安装master的mysql</p>

<p>2）然后通过expect脚本+rsync工具把slave.sh脚本、/etc/my.cnf、 /etc/init.d/mysqld
还有mysqldump下来的all.sql，以及在master下载下来的mysql二进制安装包传到slave上</p>

<p>3）通过expect脚本来运行slave.sh的脚本来安装，并且配置好主从，期间，用slave.tmp来记录master机子的binlog的状态，以便于传到slave后用命令添加进去。</p>

<blockquote>
<p><strong>cp_slave.expect</strong></p>

<p>#!/usr/bin/expect</p>

<p>set user [lindex $argv 0]</p>

<p>set host [lindex $argv 1]</p>

<p>set passwd [lindex $argv 2]</p>

<p>set file [lindex $argv 3]</p>

<p>spawn rsync -avzP $file $user@$host:/tmp</p>

<p>set timeout 600</p>

<p>expect {</p>

<p>&ldquo;yes/no&rdquo; { send &ldquo;yes\r&rdquo;}</p>

<p>&ldquo;password:&rdquo; { send &ldquo;$passwd\r&rdquo; }</p>

<p>}</p>

<p>expect eof</p>

<p><strong>ins_rsync.expect</strong></p>

<p>#!/usr/bin/expect</p>

<p>set user [lindex $argv 0]</p>

<p>set host [lindex $argv 1]</p>

<p>set passwd [lindex $argv 2]</p>

<p>spawn ssh $user@$host</p>

<p>expect {</p>

<p>&ldquo;yes/no&rdquo; { send &ldquo;yes\r&rdquo;;exp_continue}</p>

<p>&ldquo;password:&rdquo; { send &ldquo;$passwd\r&rdquo; }</p>

<p>}</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;yum install -y rsync\rexit\r&rdquo;</p>

<p>interact</p>

<p><strong>slave.expect</strong></p>

<p>#!/usr/bin/expect</p>

<p>set host [lindex $argv 0]</p>

<p>set passwd [lindex $argv 1]</p>

<p>set cm [lindex $argv 2]</p>

<p>spawn ssh root@$host</p>

<p>expect {</p>

<p>&ldquo;yes/no&rdquo; { send &ldquo;yes\r&rdquo;}</p>

<p>&ldquo;password:&rdquo; { send &ldquo;$passwd\r&rdquo; }</p>

<p>}</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;$cm\rexit\r&rdquo;</p>

<p>interact</p>

<p><strong>slave.sh</strong></p>

<p>#!/bin/bash</p>

<p>####this is for building slave script</p>

<p>##by lv.</p>

<p>####master ip address</p>

<p>mas_ip=192.168.47.24</p>

<p>###mysql password conf</p>

<p>my_passwd=hd8832508</p>

<p>####replication user and password</p>

<p>rp_user=hd</p>

<p>rp_passwd=hd8832508</p>

<p>###check ok</p>

<p>check(){</p>

<p>if [ $? != 0 ]</p>

<p>then</p>

<p>echo &ldquo;error,please check log.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>}</p>

<p>##close seliux</p>

<p>sed -i &rsquo;s/SELINUX=enforcing/SELINUX=disabled/&rsquo; /etc/selinux/config</p>

<p>selinux_s=<code>getenforce</code></p>

<p>if [ $selinux_s == &ldquo;Enforcing&rdquo; -o $selinux_s == &ldquo;enforcing&rdquo; ]</p>

<p>then</p>

<p>setenforce 0</p>

<p>fi</p>

<p>##close iptables</p>

<p>iptables-save &gt; /etc/sysconfig/iptables_<code>date +%s</code></p>

<p>iptables -F</p>

<p>service iptables save</p>

<p>##install the mirror.aliyun.com</p>

<p>cd /etc/yum.repos.d/</p>

<p>if rpm -qa |grep epel-release &gt;/dev/null</p>

<p>then</p>

<p>rpm -e epel-release</p>

<p>fi</p>

<p>if [ -f epel.repo ]</p>

<p>then</p>

<p>/bin/mv epel.repo epel.repo.bak</p>

<p>fi</p>

<p>yum install -y wget</p>

<p>if [ -f CentOS-Base.repo ]</p>

<p>then</p>

<p>/bin/mv CentOS-Base.repo CentOS-Base.repo.bak</p>

<p>wget -O /etc/yum.repos.d/CentOS-Base.repo
<a href="http://mirrors.aliyun.com/repo/Centos-6.repo">http://mirrors.aliyun.com/repo/Centos-6.repo</a></p>

<p>wget <a href="http://mirrors.aliyun.com/repo/epel-6.repo">http://mirrors.aliyun.com/repo/epel-6.repo</a> -O
/etc/yum.repos.d/epel.repo</p>

<p>fi</p>

<p>yum clean all</p>

<p>yum makecache</p>

<p>#first to update datetime</p>

<p>[ <code>rpm -qa |grep ntpdate|wc -l</code> -eq 1 ] || yum install -y ntpdate</p>

<p>ntpdate 0.openwrt.pool.ntp.org 2&gt;&amp;1 &gt;/dev/null;clock -w</p>

<p>###install lib software</p>

<p>syum(){</p>

<p>if ! rpm -qa|grep -q $1</p>

<p>then</p>

<p>yum install -y $1</p>

<p>check</p>

<p>else</p>

<p>echo &ldquo;$1 is already installed&rdquo;</p>

<p>fi</p>

<p>}</p>

<h2 id="install-some-packges-for-the-first-on-setup">install some packges for the first on setup.</h2>

<p>for p in gcc perl perl-devel libaio libaio-devel pcre-devel zlib-devel cmake
glibc pcre compat-libstdc++-33</p>

<p>do</p>

<p>syum $p</p>

<p>done</p>

<p>###check file is already in tmp</p>

<p>if [ ! -f /tmp/my.cnf ] &amp;&amp; [ ! -f /tmp/mysqld ] &amp;&amp; [ ! -f /tmp/mysql-* ] &amp;&amp;
[ ! -f /tmp/slave.tmp ]</p>

<p>then</p>

<p>echo &ldquo;error,please try to sync again&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>mysql=<code>ls /tmp |grep tar.gz</code></p>

<p>version=<code>echo /tmp/$mysql|awk -F - '{print $2}'|cut -d. -f2</code></p>

<p>######install mysql</p>

<p>cd /tmp</p>

<p>tar -zxf $mysql</p>

<p>mv <code>echo $mysql|sed 's/.tar.gz//g'</code> /usr/local/mysql</p>

<p>cd /usr/local/mysql</p>

<p>if ! grep &ldquo;^mysql:&rdquo; /etc/passwd</p>

<p>then</p>

<p>useradd -s /sbin/nologin -M mysql</p>

<p>check</p>

<p>fi</p>

<p>[ -d /data/mysql ] &amp;&amp; /bin/mv /data/mysql /data/mysql_<code>date +%s</code></p>

<p>mkdir -p /data/mysql</p>

<p>chown -R mysql:mysql /data/mysql</p>

<p>###initialize</p>

<p>case $version in</p>

<p>1)</p>

<p>/usr/local/mysql/scripts/mysql_install_db &ndash;user=mysql &ndash;datadir=/data/mysql</p>

<p>check</p>

<p>sed -i &lsquo;/^server-id/&rsquo;d /tmp/my.cnf</p>

<p>check</p>

<p>sed -i &lsquo;/\[mysqld\]/a\server-id=2&rsquo; /tmp/my.cnf</p>

<p>check</p>

<p>;;</p>

<p>6)</p>

<p>/usr/local/mysql/scripts/mysql_install_db &ndash;user=mysql &ndash;datadir=/data/mysql</p>

<p>check</p>

<p>sed -i &lsquo;/^server_id/&rsquo;d /tmp/my.cnf</p>

<p>check</p>

<p>sed -i &lsquo;/\[mysqld\]/a\server_id = 2&rsquo; /tmp/my.cnf</p>

<p>check</p>

<p>;;</p>

<p>7)</p>

<p>pswd5_7=<code>/usr/local/mysql/bin/mysqld --user=mysql --datadir=/data/mysql
--initialize 2&gt;&amp;1 |sed -r -n '/localhost: /p'|sed 's/.* //g'</code></p>

<p>/usr/local/mysql/bin/mysql_ssl_rsa_setup &ndash;datadir=/data/mysql</p>

<p>check</p>

<p>sed -i &lsquo;/^server_id/&rsquo;d /tmp/my.cnf</p>

<p>check</p>

<p>sed -i &lsquo;/\[mysqld\]/a\server_id = 2&rsquo; /tmp/my.cnf</p>

<p>check</p>

<p>;;</p>

<p>esac</p>

<p>###cp conf file</p>

<p>/bin/cp -rf /tmp/my.cnf /etc/my.cnf</p>

<p>check</p>

<p>/bin/cp -rf /tmp/mysqld /etc/init.d/</p>

<p>check</p>

<p>chmod 755 /etc/init.d/mysqld</p>

<p>chkconfig &ndash;add mysqld</p>

<p>chkconfig mysqld on</p>

<p>service mysqld start</p>

<p>check</p>

<p>####change mysql password</p>

<p>if [ $version -eq 7 ]</p>

<p>then</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$pswd5_7 &ndash;connect-expired-password -e
&ldquo;set password=password(&lsquo;$my_passwd&rsquo;);&rdquo;</p>

<p>check</p>

<p>else</p>

<p>/usr/local/mysql/bin/mysql -uroot -e &ldquo;set password=password(&lsquo;$my_passwd&rsquo;);&rdquo;</p>

<p>check</p>

<p>fi</p>

<p>###input date</p>

<p>if [ -f /tmp/all.sql ]</p>

<p>then</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$my_passwd &lt; /tmp/all.sql</p>

<p>check</p>

<p>else</p>

<p>echo &ldquo;date error.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>######binlog</p>

<p>slave_bin=<code>grep &quot;mysql-bin&quot; /tmp/slave.tmp</code></p>

<p>slave_pos=<code>grep '^[0-9]' /tmp/slave.tmp</code></p>

<p>###stop slave</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &ldquo;stop slave;&rdquo;</p>

<p>check</p>

<p>###configure slave</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &ldquo;change master to
master_host=&lsquo;$mas_ip&rsquo;,master_port=3306,master_user=&lsquo;$rp_user&rsquo;,master_password=&lsquo;$rp_passwd&rsquo;,master_log_file=&lsquo;$slave_bin&rsquo;,master_log_pos=$slave_pos;&rdquo;</p>

<p>check</p>

<p>###start slave</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &ldquo;start slave;&rdquo;</p>

<p>check</p>

<p>###check repecation status</p>

<p>show=<code>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &quot;show slave
status\G;&quot;|grep 'Slave_IO_Running:'</code></p>

<p>slaveIO=<code>echo $show|awk -F':' '{print $2}'</code></p>

<p>Slave_SQL=<code>echo $show|awk -F':' '{print $2}'</code></p>

<p>if [ $slaveIO == Yes ] &amp;&amp; [$Slave_SQL == Yes ]</p>

<p>then</p>

<p>echo &ldquo;mysql repliation is start&rdquo;</p>

<p>/bin/rm -rf /tmp/all.sql /tmp/$mysql /tmp/mysqld /tmp/my.cnf /tmp/slave.tmp</p>

<p>else</p>

<p>echo &ldquo;error,please check the log.&rdquo;</p>

<p>fi</p>

<p><strong>master.sh</strong></p>

<p>#!/bin/bash</p>

<p>#####this is building mysql replication###</p>

<p>##by lv.</p>

<p>ml=<code>pwd</code></p>

<p>ar=<code>arch</code></p>

<p>###mysql password conf</p>

<p>my_passwd=hd8832508</p>

<p>####replication user and password</p>

<p>rp_user=hd</p>

<p>rp_passwd=hd8832508</p>

<p>###slave conf</p>

<p>s_user=root</p>

<p>s_host=192.168.47.25</p>

<p>s_passwd=hd8832508</p>

<p>###check ok</p>

<p>check(){</p>

<p>if [ $? != 0 ]</p>

<p>then</p>

<p>echo &ldquo;error,please check log.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>}</p>

<p>####check the file is exist</p>

<p>for wj in $ml/cp_slave.expect $ml/ins_rsync.expect $ml/slave.expect
$ml/slave.sh</p>

<p>do</p>

<p>if [ ! -f $wj ]</p>

<p>then</p>

<p>echo &ldquo;error,your miss $wj file.&rdquo;</p>

<p>exit 1</p>

<p>else</p>

<p>/bin/chmod +x $wj</p>

<p>check</p>

<p>fi</p>

<p>done</p>

<p>##close seliux</p>

<p>sed -i &rsquo;s/SELINUX=enforcing/SELINUX=disabled/&rsquo; /etc/selinux/config</p>

<p>selinux_s=<code>getenforce</code></p>

<p>if [ $selinux_s == &ldquo;Enforcing&rdquo; -o $selinux_s == &ldquo;enforcing&rdquo; ]</p>

<p>then</p>

<p>setenforce 0</p>

<p>fi</p>

<p>##close iptables</p>

<p>iptables-save &gt; /etc/sysconfig/iptables_<code>date +%s</code></p>

<p>iptables -F</p>

<p>service iptables save</p>

<p>##install the mirror.aliyun.com</p>

<p>aliyun(){</p>

<p>cd /etc/yum.repos.d/</p>

<p>if rpm -qa |grep epel-release &gt;/dev/null</p>

<p>then</p>

<p>rpm -e epel-release</p>

<p>fi</p>

<p>if [ -f epel.repo ]</p>

<p>then</p>

<p>/bin/mv epel.repo epel.repo.bak</p>

<p>fi</p>

<p>yum install -y wget</p>

<p>if [ -f CentOS-Base.repo ]</p>

<p>then</p>

<p>/bin/mv CentOS-Base.repo CentOS-Base.repo.bak</p>

<p>wget -O /etc/yum.repos.d/CentOS-Base.repo
<a href="http://mirrors.aliyun.com/repo/Centos-6.repo">http://mirrors.aliyun.com/repo/Centos-6.repo</a></p>

<p>wget <a href="http://mirrors.aliyun.com/repo/epel-6.repo">http://mirrors.aliyun.com/repo/epel-6.repo</a> -O
/etc/yum.repos.d/epel.repo</p>

<p>fi</p>

<p>yum clean all</p>

<p>yum makecache</p>

<p>}</p>

<p>if [ <code>grep &quot;aliyun.com&quot; /etc/yum.repos.d/CentOS-Base.repo|wc -l</code> -eq 0 ]</p>

<p>then</p>

<p>aliyun</p>

<p>else</p>

<p>echo &ldquo;aliyun epel is already installed.&rdquo;</p>

<p>fi</p>

<p>#first to update datetime</p>

<p>[ <code>rpm -qa |grep ntpdate|wc -l</code> -eq 1 ] || yum install -y ntpdate</p>

<p>ntpdate 0.openwrt.pool.ntp.org 2&gt;&amp;1 &gt;/dev/null;clock -w</p>

<p>###install lib software</p>

<p>syum(){</p>

<p>if ! rpm -qa|grep -q $1</p>

<p>then</p>

<p>yum install -y $1</p>

<p>check</p>

<p>else</p>

<p>echo &ldquo;$1 is already installed&rdquo;</p>

<p>fi</p>

<p>}</p>

<h2 id="install-some-packges-for-the-first-on-setup-1">install some packges for the first on setup.</h2>

<p>for p in gcc perl perl-devel libaio libaio-devel pcre-devel zlib-devel cmake
glibc pcre compat-libstdc++-33</p>

<p>do</p>

<p>syum $p</p>

<p>done</p>

<p>###variables,fuctions</p>

<p>mysql_5_1=<a href="http://mirrors.sohu.com/mysql/MySQL-5.1/mysql-5.1.73-linux-$ar-">http://mirrors.sohu.com/mysql/MySQL-5.1/mysql-5.1.73-linux-$ar-</a>
glibc23.tar.gz</p>

<p>mysql_5_6=<a href="http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.31-linux-">http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.31-linux-</a>
glibc2.5-$ar.tar.gz</p>

<p>mysql_5_7=<a href="http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-5.7.12-linux-">http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-5.7.12-linux-</a>
glibc2.5-$ar.tar.gz</p>

<p>#######################################</p>

<p>conf_mysql(){</p>

<p>cd /usr/local/mysql</p>

<p>if ! grep &ldquo;^mysql:&rdquo; /etc/passwd</p>

<p>then</p>

<p>useradd -s /sbin/nologin -M mysql</p>

<p>check</p>

<p>fi</p>

<p>[ -d /data/mysql ] &amp;&amp; /bin/mv /data/mysql /data/mysql_<code>date +%s</code></p>

<p>mkdir -p /data/mysql</p>

<p>chown -R mysql:mysql /data/mysql</p>

<p>###initialize</p>

<p>case $version in</p>

<p>5.1)</p>

<p>./scripts/mysql_install_db &ndash;user=mysql &ndash;datadir=/data/mysql</p>

<p>check</p>

<p>;;</p>

<p>5.6)</p>

<p>./scripts/mysql_install_db &ndash;user=mysql &ndash;datadir=/data/mysql</p>

<p>check</p>

<p>;;</p>

<p>5.7)</p>

<p>pswd5_7=<code>./bin/mysqld --user=mysql --datadir=/data/mysql --initialize 2&gt;&amp;1
|sed -r -n '/localhost: /p'|sed 's/.* //g'</code></p>

<p>./bin/mysql_ssl_rsa_setup &ndash;datadir=/data/mysql</p>

<p>check</p>

<p>;;</p>

<p>esac</p>

<p>}</p>

<p>cp_mysql(){</p>

<p>###my.cnf</p>

<p>if [ -f /usr/local/mysql/support-files/my-huge.cnf ]</p>

<p>then</p>

<p>/bin/cp -rf support-files/my-huge.cnf /etc/my.cnf</p>

<p>check</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\datadir = /data/mysql&rsquo; /etc/my.cnf</p>

<p>check</p>

<p>else</p>

<p>/bin/cp -rf support-files/my-default.cnf /etc/my.cnf</p>

<p>check</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\socket = /tmp/mysql.sock&rsquo; /etc/my.cnf</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\port = 3306&rsquo; /etc/my.cnf</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\datadir = /data/mysql&rsquo; /etc/my.cnf</p>

<p>check</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\basedir = /usr/local/mysql&rsquo; /etc/my.cnf</p>

<p>fi</p>

<p>####/etc/init.d/mysqld</p>

<p>if [ $version == 5.7 ]</p>

<p>then</p>

<p>/bin/cp support-files/mysql.server /etc/init.d/mysqld</p>

<p>check</p>

<p>sed -i &rsquo;s#^datadir=#datadir=/data/mysql#&rsquo; /etc/init.d/mysqld</p>

<p>sed -i &rsquo;s#^basedir=#basedir=/usr/local/mysql#&rsquo; /etc/init.d/mysqld</p>

<p>check</p>

<p>chmod 755 /etc/init.d/mysqld</p>

<p>chkconfig &ndash;add mysqld</p>

<p>chkconfig mysqld on</p>

<p>service mysqld start</p>

<p>check</p>

<p>else</p>

<p>/bin/cp support-files/mysql.server /etc/init.d/mysqld</p>

<p>sed -i &rsquo;s#^datadir=#datadir=/data/mysql#&rsquo; /etc/init.d/mysqld</p>

<p>chmod 755 /etc/init.d/mysqld</p>

<p>chkconfig &ndash;add mysqld</p>

<p>chkconfig mysqld on</p>

<p>service mysqld start</p>

<p>check</p>

<p>fi</p>

<p>}</p>

<p>###install mysql</p>

<p>insall_mysql(){</p>

<p>echo &ldquo;Chose the version of mysql.&rdquo;</p>

<p>select mysql_v in 5.1 5.6 5.7</p>

<p>do</p>

<p>case $mysql_v in</p>

<p>5.1)</p>

<p>cd /usr/local/src</p>

<p>[ -f ${mysql_5_1##*/} ] || wget $mysql_5_1</p>

<p>tar zxf ${mysql_5_1##*/}</p>

<p>check_ok</p>

<p>[ -d /usr/local/mysql ] &amp;&amp; /bin/mv /usr/local/mysql /usr/local/mysql_<code>date
+%s</code></p>

<p>mv <code>echo ${mysql_5_1##*/}|sed 's/.tar.gz//g'</code> /usr/local/mysql</p>

<p>check_ok</p>

<p>version=5.1</p>

<p>conf_mysql</p>

<p>cp_mysql</p>

<p>break</p>

<p>;;</p>

<p>5.6)</p>

<p>cd /usr/local/src</p>

<p>[ -f ${mysql_5_6##*/} ] || wget $mysql_5_6</p>

<p>tar zxf ${mysql_5_6##*/}</p>

<p>check_ok</p>

<p>[ -d /usr/local/mysql ] &amp;&amp; /bin/mv /usr/local/mysql /usr/local/mysql_bak</p>

<p>mv <code>echo ${mysql_5_6##*/}|sed 's/.tar.gz//g'</code> /usr/local/mysql</p>

<p>check_ok</p>

<p>version=5.6</p>

<p>conf_mysql</p>

<p>cp_mysql</p>

<p>break</p>

<p>;;</p>

<p>5.7)</p>

<p>cd /usr/local/src</p>

<p>[ -f ${mysql_5_7##*/} ] || wget $mysql_5_7</p>

<p>tar zxf ${mysql_5_7##*/}</p>

<p>check_ok</p>

<p>[ -d /usr/local/mysql ] &amp;&amp; /bin/mv /usr/local/mysql /usr/local/mysql_bak</p>

<p>mv <code>echo ${mysql_5_7##*/}|sed 's/.tar.gz//g'</code> /usr/local/mysql</p>

<p>check_ok</p>

<p>version=5.7</p>

<p>conf_mysql</p>

<p>cp_mysql</p>

<p>break</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;only 1(5.1) 2(5.6) or 3(5.7) &ldquo;</p>

<p>exit 1</p>

<p>;;</p>

<p>esac</p>

<p>done</p>

<p>}</p>

<p>####change mysql password</p>

<p>passwd_mysql(){</p>

<p>if [ $version == 5.7 ]</p>

<p>then</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$pswd5_7 &ndash;connect-expired-password -e
&ldquo;set password=password(&lsquo;$my_passwd&rsquo;);&rdquo;</p>

<p>check</p>

<p>else</p>

<p>/usr/local/mysql/bin/mysql -uroot -e &ldquo;set password=password(&lsquo;$my_passwd&rsquo;);&rdquo;</p>

<p>check</p>

<p>fi</p>

<p>}</p>

<p>######</p>

<p>if [ <code>ps aux|grep mysql|wc -l</code> -gt 1 ]</p>

<p>then</p>

<p>echo &ldquo;mysql is already start&rdquo;</p>

<p>else</p>

<p>insall_mysql</p>

<p>passwd_mysql</p>

<p>fi</p>

<p>####start install slave</p>

<p>echo &ldquo;#############################&rdquo;</p>

<p>echo &ldquo;## ##&rdquo;</p>

<p>echo &ldquo;## slave install ##&rdquo;</p>

<p>echo &ldquo;## ##&rdquo;</p>

<p>echo &ldquo;#############################&rdquo;</p>

<p>##first check master tool</p>

<p>if ! rpm -qa|grep -q rsync</p>

<p>then</p>

<p>yum install -y rsync</p>

<p>fi</p>

<p>if ! rpm -qa|grep -q expect</p>

<p>then</p>

<p>yum install -y expect</p>

<p>fi</p>

<p>###replication building for master first</p>

<p>if [ <code>ps aux|grep mysql|wc -l</code> -gt 1 ] &amp;&amp; [ <code>grep &quot;log_bin = mysql-bin&quot;
/etc/my.cnf|wc -l</code> -eq 0 ] &amp;&amp; [ <code>grep &quot;log-bin=mysql-bin&quot; /etc/my.cnf|wc -l</code>
-eq 0 ]</p>

<p>then</p>

<p>/etc/init.d/mysqld stop</p>

<p>check</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\server_id = 1&rsquo; /etc/my.cnf</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\log_bin = mysql-bin&rsquo; /etc/my.cnf</p>

<p>sed -i &lsquo;/^\[mysqld\]$/a\binlog_format = &ldquo;MIXED&rdquo;&rsquo; /etc/my.cnf</p>

<p>check</p>

<p>/etc/init.d/mysqld start</p>

<p>check</p>

<p>fi</p>

<p>master_bin=<code>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &quot;show master
status \G;&quot;|grep File|awk '{print $2}'</code></p>

<p>master_pos=<code>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &quot;show master
status \G;&quot;|grep Position|awk '{print $2}'</code></p>

<p>echo $master_bin &gt;&gt;/tmp/slave.tmp</p>

<p>echo $master_pos &gt;&gt;/tmp/slave.tmp</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &ldquo;grant replication slave
on <em>.</em> to $rp_user@&lsquo;$s_host&rsquo; identified by &lsquo;$rp_passwd&rsquo;;&rdquo;</p>

<p>check</p>

<p>/usr/local/mysql/bin/mysql -uroot -p$my_passwd -e &ldquo;flush privileges;&rdquo;</p>

<p>check</p>

<p>###dump date</p>

<p>/usr/local/mysql/bin/mysqldump -uroot -p$my_passwd &ndash;single-transaction -A &gt;
/tmp/all.sql</p>

<p>check</p>

<p>####cp file to slave</p>

<p>if [ <code>pwd</code> != $ml ]</p>

<p>then</p>

<p>cd $ml</p>

<p>fi</p>

<p>./ins_rsync.expect $s_user $s_host $s_passwd</p>

<p>for file in /usr/local/src/mysql-* /etc/my.cnf /etc/init.d/mysqld ./slave.sh
/tmp/slave.tmp /tmp/all.sql</p>

<p>do</p>

<p>./cp_slave.expect $s_user $s_host $s_passwd $file</p>

<p>done</p>

<p>./slave.expect $s_host $s_passwd /tmp/slave.sh</p>
</blockquote>

<p>64、写一个shell脚本，当我们执行时，提示要输入对方的ip和root密码，然后可以自动把本机的公钥增加到对方机器上，从而实现密钥认证。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>read -p &ldquo;Input IP: &ldquo; ip</p>

<p>ping $ip -w 2 -c 2 &gt;&gt; /dev/null</p>

<h2 id="查看ip是否可用">查看ip是否可用</h2>

<p>while [ $? -ne 0 ]</p>

<p>do</p>

<p>read -p &ldquo;your ip may not useable, Please Input your IP: &ldquo; ip</p>

<p>ping $ip -w 2 -c 2 &gt;&gt; /dev/null</p>

<p>done</p>

<p>read -p &ldquo;Input root\&rsquo;s password of this host: &ldquo; password</p>

<h2 id="检查命令子函数">检查命令子函数</h2>

<p>check_ok() {</p>

<p>if [ $? != 0 ]</p>

<p>then</p>

<p>echo &ldquo;Error!.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>}</p>

<h2 id="yum需要用到的包">yum需要用到的包</h2>

<p>myyum() {</p>

<p>if ! rpm -qa |grep -q &ldquo;$1&rdquo;</p>

<p>then</p>

<p>yum install -y $1</p>

<p>check_ok</p>

<p>else</p>

<p>echo $1 already installed</p>

<p>fi</p>

<p>}</p>

<p>for p in openssh-clients openssh expect</p>

<p>do</p>

<p>myyum $p</p>

<p>done</p>

<h2 id="在主机a上创建密钥对">在主机A上创建密钥对</h2>

<p>if [ ! -f ~/.ssh/id_rsa ] || [ ! -f ~/.ssh/id_rsa.pub ]</p>

<p>then</p>

<p>if [ -d ~/.ssh ]</p>

<p>then</p>

<p>mv ~/.ssh/ ~/.ssh_old</p>

<p>fi</p>

<p>echo -e &ldquo;\n&rdquo; | ssh-keygen -t rsa -P &ldquo;</p>

<p>check_ok</p>

<p>fi</p>

<h2 id="传私钥给主机b">传私钥给主机B</h2>

<p>if [ ! -d /usr/local/sbin/rsync_keys ]</p>

<p>then</p>

<p>mkdir /usr/local/sbin/rsync_keys</p>

<p>fi</p>

<p>cd /usr/local/sbin/rsync_keys</p>

<p>if [ -f rsync.expect ]</p>

<p>then</p>

<p>d=<code>date +%F-%T</code></p>

<p>mv rsync.expect $d.expect</p>

<p>fi</p>

<p>#创建远程同步的expect文件</p>

<p>cat &gt; rsync.expect &lt;</p>

<p>#!/usr/bin/expect</p>

<p>set host [lindex \$argv 0]</p>

<p>#主机B的密码</p>

<p>set passwd [lindex \$argv 1]</p>

<p>spawn rsync -av /root/.ssh/id_rsa.pub root@\$host:/tmp/tmp.txt</p>

<p>expect {</p>

<p>&ldquo;yes/no&rdquo; { send &ldquo;yes\r&rdquo;; exp_continue}</p>

<p>&ldquo;password:&rdquo; { send &ldquo;\$passwd\r&rdquo; }</p>

<p>}</p>

<p>expect eof</p>

<p>spawn ssh root@\$host</p>

<p>expect {</p>

<p>&ldquo;password:&rdquo; { send &ldquo;\$passwd\r&rdquo; }</p>

<p>}</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;\[ -f /root/.ssh/authorized_keys \] &amp;&amp; cat /tmp/tmp.txt
&gt;&gt;/root/.ssh/authorized_keys \r&rdquo;</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;\[ -f /root/.ssh/authorized_keys \] || mkdir -p /root/.ssh/ \r&rdquo;</p>

<p>send &ldquo;\[ -f /root/.ssh/authorized_keys \] || mv /tmp/tmp.txt
/root/.ssh/authorized_keys\r&rdquo;</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;chmod 700 /root/.ssh; chmod 600 /root/.ssh/authorized_keys\r&rdquo;</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;exit\r&rdquo;</p>

<p>EOF</p>

<p>check_ok</p>

<p>/usr/bin/expect /usr/local/sbin/rsync_keys/rsync.expect $ip $password</p>

<p>echo &ldquo;OK,this script is successful. ssh $ip to test it&rdquo;</p>
</blockquote>

<p>65、写一个shell脚本，查询指定域名的过期时间，并在到期前一周，每天发一封提醒邮件。</p>

<p>思路： 大家可以在linux下使用命令“whois 域名”，如&rdquo;whois apelearn.com&rdquo;，来获取该域名的一些信息。</p>

<p>提示： whois命令，需要安装jwhois包</p>

<blockquote>
<p>#!/bin/bash</p>

<p>t1=<code>date +%s</code></p>

<p>is_install_whois()</p>

<p>{</p>

<p>which whois &gt;/dev/null 2&gt;/dev/null</p>

<p>if [ $? -ne 0 ]</p>

<p>then</p>

<p>yum install -y jwhois</p>

<p>fi</p>

<p>}</p>

<p>notify()</p>

<p>{</p>

<p>e_d=<code>whois $1|grep 'Expiry Date'|awk '{print $4}'|cut -d 'T' -f 1</code></p>

<p>e_t=<code>date -d &quot;$e_d&quot; +%s</code></p>

<p>n=<code>echo &quot;86400*7&quot;|bc</code></p>

<p>e_t1=$[$e_t-$n]</p>

<p>if [ $t1 -ge $e_t1 ] &amp;&amp; [ $t1 -lt $e_t ]</p>

<p>then</p>

<p>/usr/local/sbin/mail2.py aming_test@163.com &ldquo;Domain $1 will be expire.&rdquo;
&ldquo;Domain $1 expire date is $e_d.&rdquo;</p>

<p>fi</p>

<p>}</p>

<p>is_install_whois</p>

<p>notify aminglinux.com</p>
</blockquote>

<p>66、至少用两种方法，批量把当前目录下面所有文件名后缀为.bak的后缀去掉，比如1.txt.bak去掉后为1.txt</p>

<p>答 ：</p>

<p>假设取消的后缀为.bak</p>

<p>方法一：</p>

<p>for i in <code>ls *.bak</code></p>

<p>do</p>

<p>mv $i <code>echo $i|sed 's/\\.bak//g'</code></p>

<p>done</p>

<p>方法二：</p>

<p>for i in <code>ls *.bak</code></p>

<p>do</p>

<p>newname=<code>echo $i|awk -F '.bak' '{print $1}'</code></p>

<p>mv $i $newname</p>

<p>done</p>

<p>67、在生产环境中，经常遇到tomcat无法彻底关闭，也就是说用tomcat自带shutdown.sh脚本无法将java进程完全关掉。所以，需要借助shell脚本，将进程杀死，然后再启动。</p>

<p>写一个shell脚本，实现上述功能。彻底杀死一个进程的命令是 kill -9 pid.</p>

<p>答 ： 注明：以下脚本为猿课同学实际线上跑的shell脚本，考虑的方面比较多，大家可以学一学他的思路</p>

<p>#!/bin/bash</p>

<p>###功能： 重启 tomcat 进程</p>

<p>###要求：对于tomcat中的某些应用，使用shutdown.sh是无法完全停掉所有服务的 实际操作中都需要kill掉tomcat再重启</p>

<p>##</p>

<h3 id="root-can-not-run-this-script">root can not run this script.</h3>

<p>##</p>

<p>if [ $USER = root ]</p>

<p>then</p>

<p>echo &ldquo;root cann&rsquo;t run this script!please run with other user!&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>##</p>

<h3 id="check-the-parameter">check the Parameter</h3>

<p>##</p>

<p>if [[ $# -ne 1 ]]</p>

<p>then</p>

<p>echo &ldquo;Usage:$0 tomcatname&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>##</p>

<h3 id="only-one-process-can-run-one-time">only one process can run one time</h3>

<p>##</p>

<p>TMP_FILE_U=/tmp/.tmp.ps.keyword.$USER.956327.txt</p>

<p>#echo $TMP_FILE_U</p>

<p>KEYWORD1=&ldquo;$0&rdquo;</p>

<p>KEYWORD2=&ldquo;$1&rdquo;</p>

<h1 id="使用赋值会多fork出一个进程-所以要先重定向到一个文本-再统计">使用赋值会多fork出一个进程,所以要先重定向到一个文本,再统计.</h1>

<p>ps ux |grep &ldquo;$KEYWORD1&rdquo;|grep &ldquo;\&ldquo;|grep -v &ldquo;grep&rdquo; &gt; $TMP_FILE_U</p>

<p>Pro_count=<code>cat $TMP_FILE_U |wc -l</code></p>

<p>if [ $Pro_count -gt 1 ]</p>

<p>then</p>

<p>echo &ldquo;An other process already running ,exit now!&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>###################################################</p>

<h1 id="begin-of-the-script">begin of the script</h1>

<p>###################################################</p>

<p>##</p>

<h3 id="set-the-parameter">set the Parameter</h3>

<p>##</p>

<p>TOM=<code>echo $1|sed 's#/##g'</code></p>

<p>TOMCAT_DIRECTORY=~/usr/local/$TOM</p>

<p>STARTUP_SCRIPT=$TOMCAT_DIRECTORY/bin/startup.sh</p>

<p>TOMCAT_LOG=$TOMCAT_DIRECTORY/logs/catalina.out</p>

<p>CONF_FILE=$TOMCAT_DIRECTORY/conf/server.xml</p>

<p>TEMPFILE=/tmp/.tmpfile.x.89342.c4r3.tmp</p>

<p>##</p>

<h3 id="check-if-the-tomcat-directory-exist">check if the tomcat directory exist</h3>

<p>##</p>

<p>if [ ! -d &ldquo;$TOMCAT_DIRECTORY&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;the tomcat \&ldquo;$TOM\&rdquo; not exist.check again!&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>##</p>

<h3 id="log-roteta-and-delete-log-one-week-ago">log roteta and delete log one week ago</h3>

<p>##</p>

<p>rotate_log(){</p>

<p>TIME_FORMART=$(date +%Y%m%d%H%M%S)</p>

<p>LOG_DIR=$(dirname $TOMCAT_LOG)</p>

<p>mv $TOMCAT_LOG ${TOMCAT<em>LOG}</em>${TIME_FORMART}</p>

<p>find $LOG_DIR -type f -ctime +7 -exec rm -rf {} \;</p>

<p>}</p>

<p>##</p>

<h3 id="function-start-the-tomcat">function start the tomcat</h3>

<p>##</p>

<p>start_tomcat()</p>

<p>{</p>

<p>#echo start-tomcat-func</p>

<p>if [ -x &ldquo;$STARTUP_SCRIPT&rdquo; ]</p>

<p>then</p>

<p>rotate_log</p>

<p>$STARTUP_SCRIPT</p>

<p>sleep 1</p>

<p>tail -f $TOMCAT_LOG</p>

<p>else</p>

<p>if [ -e $STARTUP_SCRIPT ]</p>

<p>then</p>

<p>chmod +x $STARTUP_SCRIPT</p>

<h1 id="echo-permition-added">echo &ldquo;permition added!&rdquo;</h1>

<p>if [ -x &ldquo;$STARTUP_SCRIPT&rdquo; ]</p>

<p>then</p>

<p>rotate_log</p>

<p>$STARTUP_SCRIPT</p>

<p>sleep 1</p>

<p>tail -f $TOMCAT_LOG</p>

<p>else</p>

<p>echo &ldquo;The script not have excute permision,Couldn&rsquo;t add permision to Script!&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>else</p>

<p>echo &ldquo;error,the script \&ldquo;startup.sh\&rdquo; not exist!&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>fi</p>

<p>}</p>

<p>##</p>

<h3 id="function-stop-the-tomcat">function stop the tomcat</h3>

<p>##</p>

<p>stop_tomcat()</p>

<p>{</p>

<p>rm -rf $TEMPFILE</p>

<p>ps ux |grep /$TOM/ |grep -v &ldquo;grep /$TOM/&rdquo;|grep java &gt; $TEMPFILE</p>

<p>Pro_Count=<code>cat $TEMPFILE|wc -l</code></p>

<p>PIDS=<code>cat $TEMPFILE|awk '{print $2}'</code></p>

<p>rm -rf $TEMPFILE</p>

<p>#echo $Pro_Count</p>

<p>if [ $Pro_Count -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;The tomcat not running now!&rdquo;</p>

<p>else</p>

<p>if [ $Pro_Count -ne 1 ]</p>

<p>then</p>

<p>echo &ldquo;The have $Pro_Count process running,killed!&rdquo;</p>

<p>kill -9 <code>echo $PIDS</code></p>

<p>WC=<code>ps aux | grep &quot;/$TOM/&quot; | grep -v &quot;grep /$TOM/&quot; | grep java |wc -l</code></p>

<p>[ $WC -ne 0 ] &amp;&amp; (echo &ldquo;kill process failed!&rdquo;;exit 1)</p>

<p>else</p>

<p>echo &ldquo;Process killed!&rdquo;</p>

<p>kill -9 <code>echo $PIDS</code></p>

<p>WC=<code>ps aux | grep &quot;/$TOM/&quot; | grep -v &quot;grep /$TOM/&quot; | grep java |wc -l</code></p>

<p>[ $WC -ne 0 ] &amp;&amp; (echo &ldquo;kill process failed!&rdquo;;exit 1)</p>

<p>fi</p>

<p>fi</p>

<p>}</p>

<p>###########################</p>

<h4 id="the-main-script">The main script</h4>

<p>###########################</p>

<p>echo -e &ldquo;are you sure restart $TOM?(y or n)&rdquo;</p>

<p>read ANS</p>

<p>if [ &ldquo;$ANS&rdquo;a != ya ]</p>

<p>then</p>

<p>echo -e &ldquo;bye! \n&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>stop_tomcat</p>

<p>echo &ldquo;start tomcat &hellip;&rdquo;</p>

<p>sleep 2</p>

<p>start_tomcat</p>

<h1 id="end">end</h1>

<p>68、在centos6系统里，我们可以使用ntsysv关闭不需要开机启动的服务，当然也可以使用chkconfig工具来实现。</p>

<p>写一个shell脚本，用chkconfig工具把不常用的服务关闭。脚本需要写成交互式的，需要我们给它提供关闭的服务名字。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>LANG=en</p>

<p>c=&ldquo;1&rdquo;</p>

<p>while [ ! $c == &ldquo;q&rdquo; ]</p>

<p>do</p>

<p>echo -e &ldquo;\033[35mPlease chose a service to close from this list: \033[0m&rdquo;</p>

<p>chkconfig &ndash;list |awk &lsquo;/3:on/ {print $1}&rsquo;</p>

<p>read -p &ldquo;Which service to close: &ldquo; s</p>

<p>chkconfig $s off</p>

<p>service $s stop</p>

<p>read -p &ldquo;If you want&rsquo;s to quit this program, tab &ldquo;q&rdquo;, or tab &ldquo;Ctrl c&rdquo;: &ldquo; c</p>

<p>done</p>
</blockquote>

<p>69、统计并发量</p>

<p>需求背景：</p>

<p>需要统计网站的并发量，并绘图。</p>

<p>思路：</p>

<p>1 借助zabbix成图</p>

<p>2 通过统计访问日志每秒的日志条数来判定并发量</p>

<p>3 zabbix获取数据间隔30s</p>

<p>说明： 只需要写出shell脚本即可，不用关心zabbix配置。</p>

<p>假设日志路径 /data/logs/www.aaa.com_access.log</p>

<p>日志格式如下</p>

<p>112.107.15.12 - [07/Nov/2017:09:59:01 +0800] www.aaa.com &ldquo;/api/live.php&rdquo;
200&rdquo;-&rdquo; &ldquo;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)&rdquo;</p>

<p>答 #!/bin/bash</p>

<p>log=/data/logs/www.aaa.com_access.log</p>

<p>t=<code>date -d &quot;-1 second&quot; +%Y:%H:%M:%S</code></p>

<p>#可以大概分析一下每分钟日志的量级，比如说不超过3000</p>

<p>n=tail -3000 $log |grep -c &ldquo;$t&rdquo;</p>

<p>echo $n</p>

<p>70、需求背景是：</p>

<p>一个业务，有3台服务器（A，B，C）做负载均衡，由于规模太小目前并未使用专业的自动化运维工具。有新的需求时，开发同事改完代码会把变更上传到其中一台服务器A上。但是其他2台服务器也需要做相同变更。</p>

<p>写一个shell脚本，把A服务器上的变更代码同步到B和C上。</p>

<p>其中，你需要考虑到不需要同步的目录（假如有tmp、upload、logs、caches）</p>

<p>答 :</p>

<p>#!/bin/bash</p>

<p>echo &ldquo;该脚本将会把A机器上的/data/wwwroot/www.aaa.com目录同步到B,C机器上&rdquo;;</p>

<p>read -p &ldquo;是否要继续？(y|n) &ldquo;</p>

<p>rs() {</p>

<p>rsync -azP </p>

<p>--exclude logs </p>

<p>--exclude upload </p>

<p>--exclude caches </p>

<p>--exclude tmp </p>

<p>www.aaa.com/ $1:/data/wwwroot/www.aaa.com/</p>

<p>}</p>

<p>if [ $REPLY == &lsquo;y&rsquo; -o $REPLY == &lsquo;Y&rsquo; ]</p>

<p>then</p>

<p>echo &ldquo;即将同步……&rdquo;</p>

<p>sleep 2</p>

<p>cd /data/wwwroot/</p>

<p>rs B机器ip</p>

<p>rs C机器ip</p>

<p>echo &ldquo;同步完成。&rdquo;</p>

<p>elif [ $REPLY == &lsquo;n&rsquo; -o $REPLY == &lsquo;N&rsquo; ]</p>

<p>then</p>

<p>exit 1</p>

<p>else</p>

<p>echo &ldquo;请输入字母y或者n&rdquo;</p>

<p>fi</p>

<p>71、写一个脚本让用户输入多个城市的名字（可以是中文），要求不少于5个，然后把这些城市存到一个数组里，最后用for循环把它们打印出来。</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;请输入至少5个城市的名字，用空格分隔:&rdquo; city</p>

<p>n=<code>echo $city|awk '{print NF}'</code></p>

<p>if [ $n -lt 5 ]</p>

<p>then</p>

<p>echo &ldquo;输入的城市个数至少为5&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>name=($city)</p>

<p>for i in ${name[@]}</p>

<p>do</p>

<p>echo $i</p>

<p>done</p>

<p>72、写一个截取tomcat catalina.out日志的脚本</p>

<p>tomcat实例t1-t4</p>

<h1 id="tree-l-1-opt-tom">tree -L 1 /opt/TOM/</h1>

<p>/opt/TOM/</p>

<p>├── crontabs</p>

<p>├── t1</p>

<p>├── t2</p>

<p>├── t3</p>

<p>└── t4</p>

<p>5 directories, 0 files</p>

<h1 id="find-opt-tom-name-catalina-out">find /opt/TOM/ -name catalina.out</h1>

<p>/opt/TOM/t1/logs/catalina.out</p>

<p>/opt/TOM/t3/logs/catalina.out</p>

<p>/opt/TOM/t4/logs/catalina.out</p>

<p>/opt/TOM/t2/logs/catalina.out</p>

<p>要求：</p>

<p>1.这个脚本可以取tomcat实例t1-t4的日志</p>

<p>2.这个脚本可以自定义取日志的起始点 ，比如取今天早上10点之后到现在的数据</p>

<p>3.这个脚本可以自定义取日志的起始点和终点，比如取今天早上9点到晚上8点的数据</p>

<p>catalina.out 日志内容</p>

<p>Mar 29, 2016 1:52:24 PM org.apache.coyote.AbstractProtocol start</p>

<p>INFO: Starting ProtocolHandler [&ldquo;http-bio-8080&rdquo;]</p>

<p>Mar 29, 2016 1:52:24 PM org.apache.coyote.AbstractProtocol start</p>

<p>INFO: Starting ProtocolHandler [&ldquo;ajp-bio-8009&rdquo;]</p>

<p>Mar 29, 2016 1:52:24 PM org.apache.catalina.startup.Catalina start</p>

<p>INFO: Server startup in 2102 ms</p>

<p>答 ：</p>

<p>#!/bin/bash</p>

<p>##</p>

<p>#Author: 7期孙东</p>

<p>#</p>

<p>export LANG=en_US.UTF-8</p>

<p>export PATH=$PATH</p>

<p>IPADD=<code>/sbin/ifconfig | grep &quot;inet addr&quot; | head -1 | awk '{print $2}'| awk -F
'.' '{print $NF}'</code></p>

<p>LOGFILE=&ldquo;/opt/TOM/$1/logs/catalina.out&rdquo;</p>

<p>YEAR=<code>date +%Y</code></p>

<p>DATE=<code>date +%m%d_%H%M</code></p>

<p>TOMCAT=$1</p>

<p>BEGIN_TIME=$YEAR$2</p>

<p>END_TIME=$YEAR$3</p>

<p>##judge is a.m.or p.m.</p>

<p>TIME_HOUR1=<code>echo ${BEGIN_TIME:9:2}</code></p>

<p>cut_log() {</p>

<p>N_DATE1=<code>echo $1 | sed 's/_/ /g'</code></p>

<p>D_DATE1=<code>echo $2 | sed 's/_/ /g'</code></p>

<p>E_DATE1=<code>echo $3 | sed 's/_/ /g'</code></p>

<p>[ $4 ] &amp;&amp; N_DATE2=<code>echo $4 | sed 's/_/ /g'</code></p>

<p>[ $5 ] &amp;&amp; D_DATE2=<code>echo $5 | sed 's/_/ /g'</code></p>

<p>[ $6 ] &amp;&amp; E_DATE2=<code>echo $6 | sed 's/_/ /g'</code></p>

<p>BEGIN=<code>grep -nE &quot;${N_DATE1}|${D_DATE1}|${E_DATE1}&quot; ${LOGFILE} | head -1 | cut
-d : -f1</code></p>

<p>[ &ldquo;$N_DATE2&rdquo; ] &amp;&amp; END=<code>grep -nE &quot;${N_DATE2}|${D_DATE2}|${E_DATE2}&quot; ${LOGFILE}
| tail -1 | cut -d : -f1</code></p>

<p>[ ! -z &ldquo;${TIME_HOUR1}&rdquo; ] &amp;&amp; if [ ${TIME_HOUR1} -gt 12 ] ; then</p>

<p>BEGIN1=<code>grep -nE &quot;${N_DATE1}|${D_DATE1}|${E_DATE1}&quot; ${LOGFILE} |grep &quot; PM &quot;
|grep &quot;${E_DATE1}&quot; | head -1 | cut -d : -f1</code></p>

<p>if [ ! -z &ldquo;${BEGIN1}&rdquo; ] ; then</p>

<p>[ &ldquo;${BEGIN1}&rdquo; -gt &ldquo;${BEGIN}&rdquo; ] ; BEGIN=${BEGIN1}</p>

<p>fi</p>

<p>fi</p>

<p>if [ &ldquo;$BEGIN&rdquo; ] &amp;&amp; [ -z &ldquo;$END&rdquo; ] ; then</p>

<p>if [ &ldquo;$N_DATE2&rdquo; ]; then</p>

<p>echo &ldquo;${END_TIME}时间点没有访问日志，请重新设置时间点.&rdquo;</p>

<p>else</p>

<p>sed -n &ldquo;${BEGIN},[ DISCUZ_CODE<em>0 ]quot;p ${LOGFILE} &gt;
/home/gcweb/${IPADD}</em>${TOMCAT}_${DATE}.log</p>

<p>fi</p>

<p>elif [ &ldquo;$END&rdquo; ];then</p>

<p>[ &ldquo;$BEGIN&rdquo; ] || BEGIN=1</p>

<p>sed -n &ldquo;${BEGIN},${END}&ldquo;p ${LOGFILE} &gt;
/home/gcweb/${IPADD}<em>${TOMCAT}</em>${DATE}.log</p>

<p>else</p>

<p>[ &ldquo;$END_TIME&rdquo; != &ldquo;$YEAR&rdquo; ] &amp;&amp; echo &ldquo;该时段 ${BEGIN_TIME}～${END_TIME} 没有日志.&rdquo;</p>

<p>[ &ldquo;$END_TIME&rdquo; = &ldquo;$YEAR&rdquo; ] &amp;&amp; echo &ldquo;该时段 ${BEGIN_TIME}～now 没有日志.&rdquo;</p>

<p>fi</p>

<p>if [ -s /home/gcweb/${IPADD}<em>${TOMCAT}</em>${DATE}.log ]; then</p>

<p>cd /home/gcweb &amp;&amp; tar -zcf ${IPADD}<em>${TOMCAT}</em>${DATE}.tar.gz
${IPADD}<em>${TOMCAT}</em>${DATE}.log</p>

<p>rm -f /home/gcweb/${IPADD}<em>${TOMCAT}</em>${DATE}.log</p>

<p>sz /home/gcweb/${IPADD}<em>${TOMCAT}</em>${DATE}.tar.gz</p>

<p>echo &ldquo;Success to get logs.&rdquo;</p>

<p>rm -f /home/gcweb/${IPADD}<em>${TOMCAT}</em>${DATE}.tar.gz</p>

<p>fi</p>

<p>}</p>

<p>get_time() {</p>

<p>case &ldquo;$1&rdquo; in</p>

<p>4)</p>

<p>N_DATE=<code>date -d &quot;$2&quot; +&quot;%Y-%m-%d&quot; 2&gt;/dev/null</code></p>

<p>D_DATE=<code>date -d &quot;$2&quot; +&quot;%Y/%m/%d&quot; 2&gt;/dev/null</code></p>

<p>E_DATE=<code>date -d &quot;$2&quot; +&quot;%h %e,_%Y&quot; 2&gt;/dev/null|sed 's/ /_/g'</code></p>

<p>echo $N_DATE $D_DATE $E_DATE</p>

<p>;;</p>

<p>7)</p>

<p>TIME=<code>echo $2 | awk -F'_' '{print $1,$2}'</code></p>

<p>N_DATE=<code>date -d &quot;$TIME&quot; +&quot;%Y-%m-%d_%H&quot; 2&gt;/dev/null</code></p>

<p>D_DATE=<code>date -d &quot;$TIME&quot; +&quot;%Y/%m/%d_%H&quot; 2&gt;/dev/null</code></p>

<p>E_DATE=<code>date -d &quot;$TIME&quot; +&quot;%h %e,_%Y %l&quot; 2&gt;/dev/null|sed 's/ /_/g'</code></p>

<p>echo &ldquo;$N_DATE&rdquo; &ldquo;$D_DATE&rdquo; &ldquo;$E_DATE&rdquo;</p>

<p>;;</p>

<p>9)</p>

<p>TIME=<code>echo $2 | awk -F'_' '{print $1,$2}'</code></p>

<p>N_DATE=<code>date -d &quot;$TIME&quot; +&quot;%Y-%m-%d_%H:%M&quot; 2&gt;/dev/null</code></p>

<p>D_DATE=<code>date -d &quot;$TIME&quot; +&quot;%Y/%m/%d_%H:%M&quot; 2&gt;/dev/null</code></p>

<p>E_DATE=<code>date -d &quot;$TIME&quot; +&quot;%h %e,_%Y %l:%M&quot; 2&gt;/dev/null|sed 's/ /_/g'</code></p>

<p>echo &ldquo;$N_DATE&rdquo; &ldquo;$D_DATE&rdquo; &ldquo;$E_DATE&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>echo 1</p>

<p>;;</p>

<p>esac</p>

<p>}</p>

<p>check_arguments () {</p>

<p>if [ &ldquo;$1&rdquo; == 1 ] || [ -z &ldquo;$1&rdquo; ] ;then</p>

<p>echo &ldquo;你输入时间参数的格式无法识别, usage: 0108、0108_10、0108_1020&rdquo;</p>

<p>exit 3</p>

<p>fi</p>

<p>}</p>

<p>check_tomcat () {</p>

<p>if [ ! -s &ldquo;${LOGFILE}&rdquo; ] ;then</p>

<p>echo &ldquo;tomcat_name: ${TOMCAT} is not exist&rdquo;</p>

<p>echo &ldquo;you can choose:&rdquo;</p>

<p>/bin/ls /home/gcweb/usr/local/</p>

<p>fi</p>

<p>if [ $1 -lt 2 ] || [ ! -s &ldquo;${LOGFILE}&rdquo; ];then</p>

<p>echo &ldquo;usage: $0 tomcat_name {begin_time|begin_time end_time}&rdquo;</p>

<p>exit 2</p>

<p>fi</p>

<p>}</p>

<p>case &ldquo;$#&rdquo; in</p>

<p>0)</p>

<p>echo &ldquo;usage: $0 tomcat_name {begin_time|begin_time end_time}&rdquo;</p>

<p>exit 1</p>

<p>;;</p>

<p>1)</p>

<p>check_tomcat $#</p>

<p>;;</p>

<p>2)</p>

<p>check_tomcat $#</p>

<p>len=<code>echo $2 | awk '{print length($0)}'</code></p>

<p>A_DATE=$(get_time $len $BEGIN_TIME)</p>

<p>eval $( echo $A_DATE |awk &lsquo;{print &ldquo;N_DATE=&ldquo;$1,&ldquo;D_DATE=&ldquo;$2,&ldquo;E_DATE=&ldquo;$3}&lsquo;)</p>

<p>check_arguments &ldquo;${N_DATE}&rdquo;</p>

<p>cut_log &ldquo;${N_DATE}&rdquo; &ldquo;${D_DATE}&rdquo; &ldquo;${E_DATE}&rdquo;</p>

<p>;;</p>

<p>3)</p>

<p>check_tomcat $#</p>

<p>len1=<code>echo $2 | awk '{print length($0)}'</code></p>

<p>len2=<code>echo $3 | awk '{print length($0)}'</code></p>

<p>A_DATE=$(get_time ${len1} $BEGIN_TIME)</p>

<p>eval $( echo $A_DATE |awk &lsquo;{print &ldquo;N_DATE1=&ldquo;$1,&ldquo;D_DATE1=&ldquo;$2,&ldquo;E_DATE1=&ldquo;$3}&lsquo;)</p>

<p>check_arguments &ldquo;${N_DATE1}&rdquo;</p>

<p>A_DATE=$(get_time ${len2} $END_TIME)</p>

<p>eval $( echo $A_DATE |awk &lsquo;{print &ldquo;N_DATE=&ldquo;$1,&ldquo;D_DATE=&ldquo;$2,&ldquo;E_DATE=&ldquo;$3}&lsquo;)</p>

<p>check_arguments &ldquo;${N_DATE}&rdquo;</p>

<p>cut_log ${N_DATE1} ${D_DATE1} ${E_DATE1} &ldquo;${N_DATE}&rdquo; &ldquo;${D_DATE}&rdquo; &ldquo;${E_DATE}&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;usage: $0 tomcat_name {begin_time|begin_time end_time};你使用的参数太多哦.&rdquo;</p>

<p>;;</p>

<p>esac</p>

<p>73、阿里云的机器，今天收到客服来的电话，说服务器的磁盘io很重。于是登录到服务器查看，并没有发现问题，所以怀疑是间歇性地。</p>

<p>正要考虑写个脚本的时候，幸运的抓到了一个线索，造成磁盘io很高的幕后黑手是mysql。此时去show processlist，但未发现队列。原来只是一瞬间。</p>

<p>只好继续来写脚本，思路是，每5s检测一次磁盘io，当发现问题去查询mysql的processlist。</p>

<p>帮助：你可以用iostat -x 1 5 来判定磁盘的io，主要看%util</p>

<p>答 ：</p>

<p>#!/bin/bash</p>

<p>while :</p>

<p>do</p>

<p>n=<code>iostat -x 1 5 |tail -n3|head -n1 |awk '{print $NF}'|cut -d. -f1</code></p>

<p>if [ $n -gt 70 ]</p>

<p>then</p>

<p>echo &ldquo;<code>date</code> util% is $n%&rdquo; &gt;&gt;/tmp/mysql_processlist.log</p>

<p>mysql -uroot -pxxxxxx -e &ldquo;show full processlist&rdquo; &gt;&gt; /tmp/mysql_processlist.log</p>

<p>fi</p>

<p>sleep 5</p>

<p>done</p>

<p>74、贷款有两种还款的方式：等额本金法和等额本息法</p>

<p>简单说明一下等额本息法与等额本金法的主要区别：</p>

<p>等额本息法的特点是：每月的还款额相同，在月供中“本金与利息”的分配比例中，前半段时期所还的利息比例大、本金比例小，还款期限过半后逐步转为本金比例大、利息比例小。所支出的总利息比等额本金法多，而且贷款期限越长，利息相差越大。</p>

<p>等额本金法的特点是：每月的还款额不同，它是将贷款额按还款的总月数均分（等额本金），再加上上期剩余本金的月利息，形成一个月还款额，所以等额本金法第一个月的还款额最多
，尔后逐月减少，越还越少。所支出的总利息比等额本息法少。</p>

<p>两种还款方式的比较不是我们今天的讨论范围，我们的任务就是做一个贷款计算器。</p>

<p>其中：等额本息每月还款额的计算公式是：<br />
[贷款本金×月利率×（1+月利率）^还款月数]÷[（1+月利率）^还款月数－1]</p>

<p>答 ：</p>

<p>#!/bin/bash</p>

<h1 id="author-maria-12期-马黎阳">Author: Maria.（12期-马黎阳）</h1>

<h1 id="date-time-2016-03-07-09-04-01">Date &amp; Time: 2016-03-07 09:04:01</h1>

<h1 id="description-贷款计算器">Description: 贷款计算器.</h1>

<p>read -p &ldquo;请输入贷款总额（单位：万元）：&rdquo; dkzewy</p>

<p>read -p &ldquo;请输入贷款年利率（如年利率为6.5%，直接输入6.5）：&rdquo; dknll</p>

<p>read -p &ldquo;请输入贷款年限（单位：年）：&rdquo; dknx</p>

<p>echo &ldquo;贷款计算方式：&rdquo;</p>

<p>echo &ldquo;1)等额本金计算法&rdquo;</p>

<p>echo &ldquo;2)等额本息计算法&rdquo;</p>

<p>read -p &ldquo;请选择贷款方式（1|2）&rdquo; dkfs</p>

<p>dkze=<code>echo &quot;scale=2;$dkzewy*10000 &quot; | bc -l</code></p>

<p>dkll=<code>echo &quot;scale=6;$dknll/100 &quot; | bc -l</code></p>

<p>dkyll=<code>echo &quot;scale=6;$dkll/12 &quot; | bc -l</code></p>

<p>dkqc=$[$dknx*12]</p>

<p>echo &ldquo;期次 本月还款额 本月利息 未还款额&rdquo;</p>

<p>debjjsf()</p>

<p>{</p>

<p>yhbj=<code>echo &quot;scale=2;($dkze/$dkqc)/1 &quot; | bc -l</code></p>

<p>whbj=$dkze</p>

<p>for((i=1;i&lt;=$dkqc;i++))</p>

<p>do</p>

<p>bylx=<code>echo &quot;scale=2;($whbj*$dkyll)/1 &quot; | bc -l</code></p>

<p>bybx=<code>echo &quot;scale=2;($yhbj+$bylx)/1 &quot; | bc -l</code></p>

<p>yhke=<code>echo &quot;scale=2;($yhbj*$i)/1 &quot; | bc -l</code></p>

<p>whbj=<code>echo &quot;$dkze-$yhke &quot; | bc -l</code></p>

<p>if [ $i -eq $dkqc ]</p>

<p>then</p>

<p>yhbj=<code>echo &quot;scale=2;($yhbj+$whbj)/1 &quot; | bc -l</code></p>

<p>whbj=&ldquo;0.00&rdquo;</p>

<p>bybx=<code>echo &quot;scale=2;($yhbj+$bylx)/1 &quot; | bc -l</code></p>

<p>fi</p>

<p>echo &ldquo;$i $bybx $bylx $whbj&rdquo;</p>

<p>done</p>

<p>}</p>

<p>debxjsf()</p>

<p>{</p>

<p>bybx=<code>echo
&quot;scale=2;(($dkze*$dkyll*((1+$dkyll)^$dkqc))/(((1+$dkyll)^$dkqc)-1))/1 &quot; | bc
-l</code></p>

<p>whbj=$dkze</p>

<p>for((i=1;i&lt;=$dkqc;i++))</p>

<p>do</p>

<p>bylx=<code>echo &quot;scale=2;($whbj*$dkyll)/1 &quot; | bc -l</code></p>

<p>yhbj=<code>echo &quot;scale=2;($bybx-$bylx)/1 &quot; | bc -l</code></p>

<p>whbj=<code>echo &quot;scale=2;($whbj-$yhbj)/1 &quot; | bc -l</code></p>

<p>if [ $i -eq $dkqc ]</p>

<p>then</p>

<p>bybx=<code>echo &quot;scale=2;($yhbj+$whbj)/1 &quot; | bc -l</code></p>

<p>whbj=&ldquo;0.00&rdquo;</p>

<p>fi</p>

<p>echo &ldquo;$i $bybx $bylx $whbj&rdquo;</p>

<p>done</p>

<p>}</p>

<p>case $dkfs in</p>

<p>1) debjjsf</p>

<p>;;</p>

<p>2) debxjsf</p>

<p>;;</p>

<p>*) exit 1</p>

<p>;;</p>

<p>esac</p>

<p>75、要求：两类机器一共300多台，写个脚本自动清理这两类机器里面的日志文件。在堡垒机批量发布，也要批量发布到crontab里面。</p>

<p>A类机器日志存放路径很统一，B类机器日志存放路径需要用<em>匹配（因为这个目录里除了日志外，还有其他文件，不能删除。匹配的时候可用</em>.log）</p>

<p>A类：/opt/cloud/log/ 删除7天前的<br />
B类: /opt/cloud/instances/ 删除15天前的</p>

<p>要求写在一个脚本里面。不用考虑堡垒机上的操作，只需要写出shell脚本。</p>

<p>#!/bin/bash</p>

<p>dir1=/opt/cloud/instances/</p>

<p>dir2=/opt/cloud/log/</p>

<p>if [ -d $dir1 ];then</p>

<p>find $dir1 -type f -name &ldquo;*.log&rdquo; -mtime +15 |xargs rm -f</p>

<p>elif [ -d $dir2 ];then</p>

<p>find $dir2 -type f -mtime +7 |xargs rm -f</p>

<p>fi</p>

<p>76、有如下文本，其中前5行内容为</p>

<p>1111111:13443253456<br />
2222222:13211222122<br />
1111111:13643543544<br />
3333333:12341243123<br />
2222222:12123123123</p>

<p>用shell脚本处理后，按下面格式输出：</p>

<p>[1111111]<br />
13443253456<br />
13643543544<br />
[2222222]<br />
13211222122<br />
12123123123<br />
[3333333]<br />
12341243123</p>

<blockquote>
<p>#! /bin/bash</p>

<p>sort -n filename |awk -F &lsquo;:&rsquo; &lsquo;{print $1}&rsquo;|uniq &gt;id.txt</p>

<p>for id in <code>cat id.txt</code>; do</p>

<p>echo &ldquo;[$id]&rdquo;</p>

<p>awk -v id2=$id -F &lsquo;:&rsquo; &lsquo;$1==id2 {print $2}&rsquo; filename // 另外的方式为: awk -F &lsquo;:&rsquo;
&lsquo;$1==&ldquo;&lsquo;id&rsquo;&rdquo; {print $2}&rsquo; filename</p>

<p>done</p>
</blockquote>

<p>77、写一个脚本查找/data/log目录下，最后创建时间是3天前，后缀是*.log的文件，打包后发送至192.168.1.2服务上的/data/log下，并删除原始.log文件，仅保留打包后的文件</p>

<p>#!/bin/bash</p>

<p>find /data/log -name “*.log” -mtime +3 &gt; /tmp/file.list</p>

<p>cd /data/log</p>

<p>tar czvf log.tar.gz <code>cat /tmp/file.list|xargs</code></p>

<p>rsync -a log.tar.gz 192.168.1.2:/data/log //这一步需要提前做一个免密码登录</p>

<p>for f in <code>cat /tmp/file.list</code></p>

<p>do</p>

<p>rm -f $f</p>

<p>done</p>

<p>78、请使用条件函数if撰写一个shell函数 函数名为 f_judge，实现以下功能</p>

<p>1）当/home/log 目录存在时 将/home目录下所有tmp开头的文件或目录移/home/log 目录。</p>

<p>2）当/home/log目录不存在时，创建该目录，然后退出。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>f_judge (){</p>

<p>if [ -d /home/log ]</p>

<p>then</p>

<p>mv /home/tmp* /home/log/</p>

<p>else</p>

<p>mkdir -p /home/log</p>

<p>exit</p>

<p>fi</p>

<p>}</p>
</blockquote>

<p>79、linux系统中，根目录/root/下有一个文件ip-pwd.ini,内容如下</p>

<p>10.111.11.1,root,xyxyxy</p>

<p>10.111.11.1,root,xzxzxz</p>

<p>10.111.11.1,root,123456</p>

<p>10.111.11.1,root,xxxxxx</p>

<p>……</p>

<p>文件中每一行的格式都为linux服务器的ip,root用户名,root密码，请用一个shell批量将这些服务器中的所有tomcat进程kill掉。</p>

<p>讲解：
有了ip，用户名和密码，剩下的就是登录机器，然后执行命令了。批量登录机器，并执行命令，咱们课程当中有讲过一个expect脚本。所以本题就是需要这个东西来完成。</p>

<p>首先编辑expect脚本 kill_tomcat.expect</p>

<p>#!/usr/bin/expect</p>

<p>set passwd [lindex $argv 0]</p>

<p>set host [lindex $argv 1]</p>

<p>spawn ssh root@$host</p>

<p>expect {</p>

<p>&ldquo;yes/no&rdquo; { send &ldquo;yes\r&rdquo;; exp_continue}</p>

<p>&ldquo;password:&rdquo; { send &ldquo;$passwd\r&rdquo; }</p>

<p>}</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;killall java\r&rdquo;</p>

<p>expect &ldquo;]*&rdquo;</p>

<p>send &ldquo;exit\r&rdquo;</p>

<p>编辑完后需要给这个文件执行权限</p>

<p>chmod a+x kill_tomcat.expect</p>

<p>然后编辑shell脚本</p>

<p>#!/bin/bash</p>

<p>n=<code>wc -l ip-pwd.ini</code></p>

<p>for i in <code>seq 1 $n</code></p>

<p>do</p>

<p>ip=<code>sed -n &quot;$n&quot;p ip-pwd.ini |awk -F ',' '{print $1}'</code></p>

<p>pw=<code>sed -n &quot;$n&quot;p ip-pwd.ini |awk -F ',' '{print $3}'</code></p>

<p>./kill_tomcat.expect $pw $ip</p>

<p>done</p>

<p>80、linux系统 /home目录下有一个文件test.xml，内容如下：</p>

<p>zzz</p>

<p>aaa</p>

<p>xxx</p>

<p>yyy</p>

<p>请写出shell脚本删除文件中的注释部分内容，获取文件中所有artifactItem的内容，并用如下格式逐行输出
artifactItem：groupId：artifactId</p>

<p>分析：这个文件比较特殊，但是却很有规律。注释部分内容其实就是中间的内容，所以我们想办法把这些内容删除掉就ok了。而artifactItem的内容，其实就是获取中间的内容。然后想办法用提到的格式输出即可。</p>

<p>答 ：</p>

<blockquote>
<p>#!/bin/bash</p>

<p>egrep -v &ldquo; 1.txt |tee 2.txt //这行就是删除掉注释的行</p>

<p>grep -n &lsquo;artifactItem&gt;&rsquo; 2.txt |awk &lsquo;{print $1}&rsquo; |sed &rsquo;s/://&rsquo; &gt;
/tmp/line_number.txt</p>

<p>n=<code>wc -l /tmp/line_number.txt|awk '{print $1}'</code></p>

<p>get_value(){</p>

<p>sed -n &ldquo;$1,$2&rdquo;p 2.txt|awk -F &ldquo; &lsquo;{print $1,$2}&rsquo; &gt; /tmp/value.txt</p>

<p>nu=<code>wc -l /tmp/value.txt|awk '{print $1}'</code></p>

<p>for i in <code>seq 1 $nu</code></p>

<p>do</p>

<p>x=<code>sed -n &quot;$i&quot;p /tmp/value.txt|awk '{print $1}'</code></p>

<p>y=<code>sed -n &quot;$i&quot;p /tmp/value.txt|awk '{print $2}'</code></p>

<p>echo artifactItem:$x:$y</p>

<p>done</p>

<p>}</p>

<p>n2=$[$n/2]</p>

<p>for j in <code>seq 1 $n2</code></p>

<p>do</p>

<p>m1=$[$j*2-1]</p>

<p>m2=$[$j*2]</p>

<p>nu1=<code>sed -n &quot;$m1&quot;p /tmp/line_number.txt</code></p>

<p>nu2=<code>sed -n &quot;$m2&quot;p /tmp/line_number.txt</code></p>

<p>nu3=$[$nu1+1]</p>

<p>nu4=$[$nu2-1]</p>

<p>get_value $nu3 $nu4</p>

<p>done</p>
</blockquote>

<p>81、写一个脚本，依次向/etc/passwd中的每个用户问好，并且说出对方的ID是什么<br />
Hello,root，your UID is 0.</p>

<p>awk -F &lsquo;:&rsquo; &lsquo;{print &ldquo;Hello,&rdquo;$1&rdquo;,your uid is &ldquo;$3.}&rsquo; /etc/passwd</p>

<p>82、交互式脚本，根据提示，需要用户输入一个数字作为参数，最终打印出一个正方形。</p>

<p>在这里我提供一个linux下面的特殊字符■，可以直接打印出来。</p>

<p>示例： 如果用户输入数字为5，则最终显示的效果为</p>

<p>■ ■ ■ ■ ■</p>

<p>■ ■ ■ ■ ■</p>

<p>■ ■ ■ ■ ■</p>

<p>■ ■ ■ ■ ■</p>

<p>■ ■ ■ ■ ■</p>

<p>#!/bin/bash</p>

<p>read -p &ldquo;please input a number:&rdquo; sum</p>

<p>a=<code>echo $sum |sed 's/[0-9]//g'</code></p>

<p>if [ -n &ldquo;$a&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;请输入一个纯数字。&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>for n in <code>seq $sum</code></p>

<p>do</p>

<p>for m in <code>seq $sum</code></p>

<p>do</p>

<p>if [ $m -lt $sum ]</p>

<p>then</p>

<p>echo -n &ldquo;■ &ldquo;</p>

<p>else</p>

<p>echo &ldquo;■&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>done</p>

<p>83、用户交互脚本</p>

<p>写一个脚本，执行后，打印一行提示“Please input a
number:&ldquo;，要求用户输入数值，然后打印出该数值，然后再次要求用户输入数值。直到用户输入&rdquo;end&rdquo;停止。</p>

<p>#!/bin/bash</p>

<p>while :</p>

<p>do</p>

<p>read -p &ldquo;Please input a number:(end for exit) &ldquo; n</p>

<p>num=<code>echo $n |sed -r 's/[0-9]//g'|wc -c</code></p>

<p>if [ $n == &ldquo;end&rdquo; ]</p>

<p>then</p>

<p>exit</p>

<p>elif [ $num -ne 1 ]</p>

<p>then</p>

<p>echo &ldquo;what you input is not a number!Try again!&rdquo;</p>

<p>else</p>

<p>echo &ldquo;your input number is: $n&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>84、判断所给目录内哪些二级目录下没有text.txt文件。</p>

<p>有text.txt文件的二级目录，根据文件计算选项中单词数最大的值（选项间以|分割，单词间以空格分隔）。</p>

<p>假如脚本名字为1.sh， 运行脚本的格式为 ./1.sh 123 root，其中123为目录名字，而root为要计算数量的单词。</p>

<p>答 ：说明： 这个shell脚本题目出的有点歧义。 原题给的描述不是很清楚，我另外又改了一下需求，依然不是很清晰。在这里我再做一个补充：
对于有test.txt的目录，计算出该test.txt文件里面所给出单词的次数。不用找最大。</p>

<p>##</p>

<blockquote>
<p>#!/bin/bash</p>

<p>if [ $# -ne 2 ]</p>

<p>then</p>

<p>echo &ldquo;useage $0 dir word&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>if [ -d $1 ]</p>

<p>then</p>

<p>cd $1</p>

<p>else</p>

<p>echo &ldquo;$1目录不存在&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>for f in <code>ls $1</code></p>

<p>do</p>

<p>if [ -d $f ]</p>

<p>then</p>

<p>if [ -f $f/test.txt ]</p>

<p>then</p>

<p>n=<code>grep -cw &quot;$2&quot; $f/test.txt</code></p>

<p>echo &ldquo;$1/$f/test.txt 里面有$n个$2&rdquo;</p>

<p>else</p>

<p>echo &ldquo;$1/$f 下面没有test.txt&rdquo;</p>

<p>fi</p>

<p>fi</p>

<p>done</p>
</blockquote>

<p>85、用shell写一个简易计算器，可以实现加、减、乘、除运算，假如脚本名字为1.sh，执行示例：./1.sh 1 + 2</p>

<p>#!/bin/bash</p>

<p>if [ $# -ne 3 ]</p>

<p>then</p>

<p>echo &ldquo;参数个数不为3&rdquo;</p>

<p>echo &ldquo;当使用乘法时，需要加上脱义符号，例如 $0 1 \* 2&rdquo;</p>

<p>exit 1;</p>

<p>fi</p>

<p>num1=<code>echo $1|sed 's/[0-9.]//g'</code> ;</p>

<p>if [ -n &ldquo;$num1&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;$1 不是数字&rdquo; ;</p>

<p>exit 1</p>

<p>fi</p>

<p>num3=<code>echo $3|sed 's/[0-9.]//g'</code> ;</p>

<p>if [ -n &ldquo;$num3&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;$3 不是数字&rdquo; ;</p>

<p>exit 1</p>

<p>fi</p>

<p>case $2 in</p>

<p>+)</p>

<p>echo &ldquo;scale=2;$1+$3&rdquo; | bc</p>

<p>;;</p>

<p>-)</p>

<p>echo &ldquo;scale=2;$1-$3&rdquo; | bc</p>

<p>;;</p>

<p>\*)</p>

<p>echo &ldquo;scale=2;$1*$3&rdquo; | bc</p>

<p>;;</p>

<p>/)</p>

<p>echo &ldquo;scale=2;$1/$3&rdquo; | bc</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;$2 不是运算符&rdquo;</p>

<p>;;</p>

<p>esac</p>

<p>86、需求背景：<br />
服务器上，跑的lamp环境，上面有很多客户的项目，每个项目就是一个网站。
由于客户在不断增加，每次增加一个客户，就需要配置相应的mysql、ftp以及httpd. 这种工作是重复性非常强的，所以用脚本实现非常合适。</p>

<p>mysql增加的是对应客户项目的数据库、用户、密码，ftp增加的是对应项目的用户、密码（使用vsftpd，虚拟用户模式），httpd就是要增加虚拟主机配置段。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>webdir=/home/wwwroot</p>

<p>ftpudir=/etc/vsftpd/vuuser</p>

<p>mysqlc=&ldquo;/usr/bin/mysql -uroot -xxxxxx&rdquo;</p>

<p>httpd_config_f=&ldquo;/usr/local/apache2/conf/extra/httpd-vhosts.conf&rdquo;</p>

<p>add_mysql_user()</p>

<p>{</p>

<p>mysql_p=<code>mkpasswd -s 0 -l 12</code></p>

<p>echo &ldquo;$pro $mysql_p&rdquo; &gt;/tmp/$pro.txt</p>

<p>$mysqlc &lt;</p>

<p>grant all on $p.* to &ldquo;$pro&rdquo;@&lsquo;127.0.0.1&rsquo; identified by &ldquo;$mysql_p&rdquo;;</p>

<p>EOF</p>

<p>}</p>

<p>add_ftp_user()</p>

<p>{</p>

<p>ftp_p=<code>mkpasswd -s 0 -l 12</code></p>

<p>echo &ldquo;$pro&rdquo; &gt;&gt; /root/login.txt</p>

<p>echo &ldquo;$ftp_p&rdquo; &gt;&gt; /root/login.txt</p>

<p>db_load -T -t hash -f /root/login.txt /etc/vsftpd/vsftpd_login.db</p>

<p>cd $ftpudir</p>

<p>cp aaa $pro //这里的aaa是一个文件，是之前的一个项目，可以作为配置模板</p>

<p>sed -i &ldquo;s/aaa/$pro/&rdquo; $pro //把里面的aaa改为新的项目名字</p>

<p>/etc/init.d/vsftpd restart</p>

<p>}</p>

<p>config_httpd()</p>

<p>{</p>

<p>mkdir $webdir/$pro</p>

<p>chown vsftpd:vsftpd $webdir/$pro</p>

<p>echo -e &ldquo; \n DocumentRoot &ldquo;/home/internet/www/$pro/&rdquo; \n ServerName $dom \n
#ServerAlias \n &ldquo; &gt;&gt; $httpd_config_f</p>

<p>/usr/local/apache2/bin/apachectl graceful</p>

<p>}</p>

<p>read -p &ldquo;input the project name: &ldquo; pro</p>

<p>read -p &ldquo;input the domain: &ldquo; dom</p>

<p>add_mysql_user</p>

<p>add_ftp_user</p>

<p>config_httpd</p>
</blockquote>

<p>87、 获取子进程</p>

<p>说明：本shell题目是一个网友在公众号中提问的，正好利用这个每日习题的机会拿出来让大家一起做一做。</p>

<p>给出一个进程PID，打印出该进程下面的子进程以及子进程下面的所有子进程。（只需要考虑子进程的子进程，再往深层次则不考虑）</p>

<blockquote>
<p>#!/bin/bash</p>

<p>read -p &ldquo;please input a pid number: &ldquo; p</p>

<p>ps -elf &gt; /tmp/ps.log</p>

<p>is_ppid(){</p>

<p>awk &lsquo;{print $5}&rsquo; /tmp/ps.log &gt; /tmp/ps1.log</p>

<p>if ! grep -qw &ldquo;$1&rdquo; /tmp/ps1.log</p>

<p>then</p>

<p>echo &ldquo;PID $1 不是系统进程号，或者它不是父进程&rdquo;</p>

<p>return 1</p>

<p>fi</p>

<p>}</p>

<p>is_ppid $p</p>

<p>if [ $? -eq &ldquo;1&rdquo; ]</p>

<p>then</p>

<p>exit</p>

<p>fi</p>

<p>print_cpid(){</p>

<p>p=$1</p>

<p>awk -v p1=$p &lsquo;$5 == p1 {print $4}&rsquo; /tmp/ps.log |sort -n |uniq &gt;/tmp/p1.log</p>

<p>n=<code>wc -l /tmp/p1.log|awk '{print $1}'</code></p>

<p>if [ $n -ne 0 ]</p>

<p>then</p>

<p>echo &ldquo;PID $p 子进程 pid 如下:&rdquo;</p>

<p>cat /tmp/p1.log</p>

<p>else</p>

<p>echo &ldquo;PID $p 没有子进程&rdquo;</p>

<p>fi</p>

<p>}</p>

<p>print_cpid $p</p>

<p>for cp in <code>cat /tmp/p1.log</code></p>

<p>do</p>

<p>print_cpid $cp</p>

<p>done</p>

<p>另外，一条命令查询的方法是：pstree -p pid</p>
</blockquote>

<p>88、用shell打印下面这句话中字母数小于6的单词。<br />
Bash also interprets a number of multi-character options.</p>

<p>#!/bin/bash</p>

<p>for s in Bash also interprets a number of multi-character options</p>

<p>do</p>

<p>n=<code>echo $s|wc -c</code></p>

<p>if [ $n -lt 6 ]</p>

<p>then echo $s</p>

<p>fi</p>

<p>done</p>

<p>89、输入数字执行对应命令</p>

<p>写一个脚本实现如下功能： 输入一个数字，然后运行对应的一个命令。显示命令如下：*cmd meau** 1&mdash;date 2&ndash;ls 3&ndash;who 4&ndash;
pwd<br />
当输入1时，会运行date, 输入2时运行ls, 依此类推。</p>

<p>90、要求：</p>

<p>把一个文本文档的前5行中包含字母的行删除掉，同时把6到10行中的全部字母删除掉。</p>

<p>答 ：假设文本名字叫做1.txt，并且文本行数大于10，脚本如下</p>

<blockquote>
<p>#!/bin/bash</p>

<p>##先获取该文本的行数</p>

<p>nu=<code>wc -l 1.txt |awk '{print $1}'</code></p>

<p>##对前5行进程处理</p>

<p>for i in <code>seq 1 5</code></p>

<p>do</p>

<p>##使用sed把每一行的内容赋值给变量</p>

<p>l=<code>sed -n &quot;$i&quot;p 1.txt</code></p>

<p>##用grep 判定是否匹配字母,-v取反，-q不输出内容</p>

<p>if echo $l |grep -vq &lsquo;[a-zA-Z]&rsquo;</p>

<p>then</p>

<p>echo $l</p>

<p>fi</p>

<p>done</p>

<p>##对6-10行做删除字母处理</p>

<p>for i in <code>seq 6 10</code></p>

<p>do</p>

<p>l=<code>sed -n &quot;$i&quot;p 1.txt</code></p>

<p>echo $l|sed &rsquo;s/[a-zA-Z]//g&rsquo;</p>

<p>done</p>

<p>##剩余的直接输出</p>

<p>for i in <code>seq 11 $nu</code></p>

<p>do</p>

<p>sed -n &ldquo;$i&rdquo;p 1.txt</p>

<p>done</p>

<p>##若想把更改内容写入到1.txt，还需要把以上内容重定向到一个文本中，然后删除1.txt，再把刚刚重定向的文件更名为1.txt</p>
</blockquote>

<p>91、 <strong>自动重启nginx服务</strong></p>

<p>服务器上跑的是LNMP环境，近期总是有502现象。502为网站访问的状态码，200正常，
<strong>502错误是nginx最为普通的错误状态码。由于502只是暂时的，并且只要一重启php-fpm服务则502消失</strong>
，但不重启的话，则会一直持续很长时间。所以有必要写一个监控脚本，监控访问日志的状态码，一旦发生502，则自动重启一下php-fpm。</p>

<p>我们设定：<br />
1. access_log /data/log/access.log<br />
2. 脚本死循环，每10s检测一次（假设每10s钟的日志条数为300左右）<br />
3. 重启php-fpm的方法是 /etc/init.d/php-fpm restart</p>

<p>答 ： 其实不是重启nginx，应该说是自动重启php-fpm服务。</p>

<blockquote>
<p>#! /bin/bash</p>

<p>log=/data/log/access.log</p>

<p>N=10</p>

<p>while :; do</p>

<p>##因为10秒钟大概产生300条日志</p>

<p>tail -n 300 $log &gt; /tmp/log</p>

<p>n_502=<code>grep -c ' 502&quot;' /tmp/log</code></p>

<p>if [ $n_502 -ge $N ]; then</p>

<p>##记录系统的状态</p>

<p>top -bn1 &gt;/tmp/<code>date +%H%M%S</code>-top.log</p>

<p>vmstat 1 5 &gt;/tmp/<code>date +%H%M%S</code>-vm.log</p>

<p>/etc/init.d/php-fpm restart 2&gt;/dev/null</p>

<p>##重启php-fpm服务后，应先暂缓1分钟，而后继续每隔10s检测一次</p>

<p>sleep 60</p>

<p>fi</p>

<p>sleep 10</p>

<p>done</p>
</blockquote>

<p>92、备份数据库【答案】</p>

<blockquote>
<p>#! /bin/bash</p>

<h3 id="backup-mysql-data">backup mysql data</h3>

<h3 id="writen-by-aming">Writen by Aming.</h3>

<p>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/mysql/bin</p>

<p>d1=<code>data +%w</code></p>

<p>d2=<code>date +%d</code></p>

<p>pass=&ldquo;your_mysql_password&rdquo;</p>

<p>bakdir=/bak/mysql</p>

<p>r_bakdir=192.168.123.30::backup</p>

<p>exec 1&gt;/var/log/mysqlbak.log 2&gt;/var/log/mysqlbak.log</p>

<p>echo &ldquo;mysql backup begin at <code>date +&quot;%F %T&quot;</code>.&rdquo;</p>

<p>mysqldump -uroot -p$pass &ndash;default-character-set=gbk discuz &gt;$bakdir/$d1.sql</p>

<p>rsync -az $bakdir/$d1.sql $r_bakdir/$d2.sql</p>

<p>echo &ldquo;mysql backup end at <code>date +&quot;%F %T&quot;</code>.&rdquo;</p>
</blockquote>

<p>然后加入cron</p>

<blockquote>
<p>0 3 * * * /bin/bash /usr/local/sbin/mysqlbak.sh</p>
</blockquote>

<p>93、使用传参的方法写个脚本，实现加减乘除的功能。例如： sh a.sh 1 2，这样会分别计算加、减、乘、除的结果。</p>

<p>要求：</p>

<p>1 脚本需判断提供的两个数字必须为整数</p>

<p>2 当做减法或者除法时，需要判断哪个数字大</p>

<p>3 减法时需要用大的数字减小的数字</p>

<p>4 除法时需要用大的数字除以小的数字，并且结果需要保留两个小数点。</p>

<blockquote>
<p>#!/bin/bash</p>

<p>if [ $# -ne 2 ]</p>

<p>then</p>

<p>echo &ldquo;The number of parameter is not 2, Please useage: ./$0 1 2&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>is_int()</p>

<p>{</p>

<p>if echo &ldquo;$1&rdquo;|grep -q &lsquo;[^0-9]&rsquo;</p>

<p>then</p>

<p>echo &ldquo;$1 is not integer number.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>}</p>

<p>max()</p>

<p>{</p>

<p>if [ $1 -ge $2 ]</p>

<p>then</p>

<p>echo $1</p>

<p>else</p>

<p>echo $2</p>

<p>fi</p>

<p>}</p>

<p>min()</p>

<p>{</p>

<p>if [ $1 -lt $2 ]</p>

<p>then</p>

<p>echo $1</p>

<p>else</p>

<p>echo $2</p>

<p>fi</p>

<p>}</p>

<p>sum()</p>

<p>{</p>

<p>echo &ldquo;$1 + $2 = $[$1+$2]&rdquo;</p>

<p>}</p>

<p>minus()</p>

<p>{</p>

<p>big=<code>max $1 $2</code></p>

<p>small=<code>min $1 $2</code></p>

<p>echo &ldquo;$big - $small = $[$big-$small]&rdquo;</p>

<p>}</p>

<p>mult()</p>

<p>{</p>

<p>echo &ldquo;$1 * $2 = $[$1*$2]&rdquo;</p>

<p>}</p>

<p>div()</p>

<p>{</p>

<p>big=<code>max $1 $2</code></p>

<p>small=<code>min $1 $2</code></p>

<p>d=<code>echo &quot;scale =2; $big / $small&quot;|bc</code></p>

<p>echo &ldquo;$big / $small = $d&rdquo;</p>

<p>}</p>

<p>is_int $1</p>

<p>is_int $2</p>

<p>sum $1 $2</p>

<p>minus $1 $2</p>

<p>mult $1 $2</p>

<p>div $1 $2</p>
</blockquote>

<p>94、写一个脚本： 计算100以内所有能被3整除的正整数的和</p>

<p>#!/bin/bash<br />
sum=0<br />
for i in {1..100};do<br />
if [ $[$i%3] -eq 0 ];then<br />
sum=$[$i+$sum]<br />
fi<br />
done</p>

<p>echo &ldquo;sum:$sum&rdquo;</p>

<p>95、带选项的用户脚本</p>

<p>要求如下：</p>

<ul>
<li><p>只支持三个选项 ‘&ndash;del’ ‘&ndash;add’ &ndash;help输入其他选项报错。</p></li>

<li><p>使用‘&ndash;add’需要验证用户名是否存在，存在则反馈存在。且不添加。 不存在则创建该用户，切添加与该用户名相同的密码。并且反馈。</p></li>

<li><p>使用‘&ndash;del’ 需要验证用户名是否存在，存在则删除用户及其家目录。不存在则反馈该用户不存在。</p></li>

<li><p>--help 选项反馈出使用方法</p></li>

<li><p>支持以，分隔 一次删除多个或者添加多个用户。</p></li>

<li><p>能用echo $? 检测脚本执行情况 成功删除或者添加为0,报错信息为其他数字。</p></li>

<li><p>能以，分割。一次性添加或者 删除多个用户。 例如 adddel.sh &ndash;add user1,user2,user3&hellip;&hellip;.</p></li>

<li><p>不允许存在明显bug。</p></li>
</ul>

<blockquote>
<p>#!/bin/bash</p>

<p>#written by aming.</p>

<p>if [ $# -eq 0 -o $# -gt 2 ]</p>

<p>then</p>

<p>echo &ldquo;use $0 &ndash;add username or $0 &ndash;del username or $0 &ndash;help.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>case $1 in</p>

<p>--add)</p>

<p>n=0</p>

<p>for u in <code>echo $2|sed 's/,/ /g'</code>; do</p>

<p>if awk -F: &lsquo;{print $1}&rsquo; /etc/passwd |grep -qw &ldquo;$u&rdquo;</p>

<p>then</p>

<p>echo &ldquo;The user $u exist.&rdquo;</p>

<p>else</p>

<p>useradd $u</p>

<p>echo -e &ldquo;$u\n$u&rdquo;|passwd $u &gt;/dev/null 2&gt;&amp;1</p>

<p>echo &ldquo;The user $u added successfully.&rdquo;</p>

<p>n=$[$n+1]</p>

<p>fi</p>

<p>done</p>

<p>if [ $n -eq 0 ]; then</p>

<p>exit 2</p>

<p>fi</p>

<p>;;</p>

<p>--del)</p>

<p>n=0</p>

<p>for u in <code>echo $2|sed 's/,/ /g'</code>; do</p>

<p>if awk -F: &lsquo;{print $1}&rsquo; /etc/passwd|grep -qw &ldquo;$u&rdquo;</p>

<p>then</p>

<p>userdel -r $u</p>

<p>echo &ldquo;The user $u deleted successfully.&rdquo;</p>

<p>n=$[$n+1]</p>

<p>else</p>

<p>echo &ldquo;The user $u not exist.&rdquo;</p>

<p>fi</p>

<p>done</p>

<p>if [ $n -eq 0 ]; then</p>

<p>exit 3</p>

<p>fi</p>

<p>;;</p>

<p>--help)</p>

<p>echo -e &ldquo;&ndash;add can add user,and the passwd is the same as username.</p>

<p>It can add multiuser such as &ndash;add user1,user2,user3&hellip;&rdquo;</p>

<p>echo &ldquo;&ndash;del cat delete user.It can delete user such as &ndash;del
user1,user2,user3&hellip;&rdquo;</p>

<p>;;</p>

<p>*)</p>

<p>echo &ldquo;use $0 &ndash;add username or $0 &ndash;del username or $0 &ndash;help.&rdquo;</p>

<p>exit 1</p>

<p>;;</p>

<p>esac</p>
</blockquote>

<p>96、假设，当前MySQL服务的root密码为123456，写脚本检测MySQL服务是否正常（比如，可以正常进入mysql执行show
processlist），并检测一下当前的MySQL服务是主还是从，如果是从，请判断它的主从服务是否异常。如果是主，则不需要做什么。</p>

<p>#!/bin/bash</p>

<p>Mysql_c=&ldquo;mysql -uroot -p123456&rdquo;</p>

<p>$Mysql_c -e &ldquo;show processlist&rdquo; &gt;/tmp/mysql_pro.log 2&gt;/tmp/mysql_log.err</p>

<p>n=<code>wc -l /tmp/mysql_log.err|awk '{print $1}'</code></p>

<p>if [ $n -gt 0 ]</p>

<p>then</p>

<p>echo &ldquo;mysql service sth wrong.&rdquo;</p>

<p>else</p>

<p>$Mysql_c -e &ldquo;show slave status\G&rdquo; &gt;/tmp/mysql_s.log</p>

<p>n1=<code>wc -l /tmp/mysql_s.log|awk '{print $1}'</code></p>

<p>if [ $n1 -gt 0 ]</p>

<p>then</p>

<p>y1=<code>grep 'Slave_IO_Running:' /tmp/mysql_s.log|awk -F : '{print $2}'|sed 's/
//g'</code></p>

<p>y2=<code>grep 'Slave_SQL_Running:' /tmp/mysql_s.log|awk -F : '{print $2}'|sed 's/
//g'</code></p>

<p>if [ $y1 == &ldquo;Yes&rdquo; ] &amp;&amp; [ $y2 == &ldquo;Yes&rdquo; ]</p>

<p>then</p>

<p>echo &ldquo;slave status good.&rdquo;</p>

<p>else</p>

<p>echo &ldquo;slave down.&rdquo;</p>

<p>fi</p>

<p>fi</p>

<p>fi</p>

<p>97、写一个脚本判断你的Linux服务器里是否开启web服务？（监听80端口）如果开启了，请判断出跑的是什么服务，是httpd呢还是nginx又或者是其他的什么？</p>

<blockquote>
<p>#!/bin/bash</p>

<p>port=<code>netstat -lnp | grep 80</code></p>

<p>if [ -z &ldquo;port&rdquo; ]; then</p>

<p>echo &ldquo;not start service.&rdquo;;</p>

<p>exit;</p>

<p>fi</p>

<p>web_server=<code>echo $port | awk -F'/' '{print $2}'|awk -F : '{print $1}'</code></p>

<p>case $web_server in</p>

<p>httpd )</p>

<p>echo &ldquo;apache server.&rdquo;</p>

<p>;;</p>

<p>nginx )</p>

<p>echo &ldquo;nginx server.&rdquo;</p>

<p>;;</p>

<ul>
<li>)</li>
</ul>

<p>echo &ldquo;other server.&rdquo;</p>

<p>;;</p>

<p>esac</p>
</blockquote>

<p>98、 <strong>监控磁盘使用率</strong></p>

<p>写一个shell脚本，检测所有磁盘分区使用率和inode使用率并记录到以当天日期为命名的日志文件里，当发现某个分区容量或者inode使用量大于85%时，发邮件通知你自己。</p>

<p>思路：就是先df -h 然后过滤出已使用的那一列，然后再想办法过滤出百分比的整数部分，然后和85去比较，同理，inode也是一样的思路。</p>

<p>#!/bin/bash</p>

<h2 id="this-script-is-for-record-filesystem-use-iuse-everyday-and-send-alert">This script is for record Filesystem Use%,IUse% everyday and send alert</h2>

<p>mail when % is more than 85%.</p>

<p>log=/var/log/disk/<code>date +%F</code>.log<br />
date +&lsquo;%F %T&rsquo; &gt; $log<br />
df -h &gt;&gt; $log<br />
echo &gt;&gt; $log<br />
df -i &gt;&gt; $log</p>

<p>for i in <code>df -h|grep -v 'Use%'|sed 's/%//'|awk '{print $5}'</code>; do<br />
if [ $i -gt 85 ]; then<br />
use=<code>df -h|grep -v 'Use%'|sed 's/%//'|awk '$5=='$i' {print $1,$5}'</code><br />
echo &ldquo;$use&rdquo; &gt;&gt; use<br />
fi<br />
done<br />
if [ -e use ]; then</p>

<p>##这里可以使用咱们之前介绍的mail.py发邮件<br />
mail -s &ldquo;Filesystem Use% check&rdquo; root@localhost &lt; use<br />
rm -rf use<br />
fi</p>

<p>for j in <code>df -i|grep -v 'IUse%'|sed 's/%//'|awk '{print $5}'</code>; do<br />
if [ $j -gt 85 ]; then<br />
iuse=<code>df -i|grep -v 'IUse%'|sed 's/%//'|awk '$5=='$j' {print $1,$5}'</code><br />
echo &ldquo;$iuse&rdquo; &gt;&gt; iuse<br />
fi<br />
done<br />
if [ -e iuse ]; then<br />
mail -s &ldquo;Filesystem IUse% check&rdquo; root@localhost &lt; iuse<br />
rm -rf iuse<br />
fi</p>

<p>思路：<br />
1、df -h、df -i 记录磁盘分区使用率和inode使用率，date +%F 日志名格式<br />
2、取出使用率(第5列)百分比序列，for循环逐一与85比较，大于85则记录到新文件里，当for循环结束后，汇总超过85的一并发送邮件(邮箱服务因未搭建，发送本地root账户)。</p>

<p>此脚本正确运行前提：</p>

<p>该系统没有逻辑卷的情况下使用，因为逻辑卷df -h、df -i 时，使用率百分比是在第4列，而不是第5列。如有逻辑卷，则会漏统计逻辑卷使用情况。</p>

<p>99、写个shell，看看你的Linux系统中是否有自定义用户（普通用户），若是有，一共有几个？</p>

<p>假设所有普通用户都是uid大于1000的</p>

<blockquote>
<p>#!/bin/bash<br />
 n=<code>awk -F ':' '$3&gt;1000' /etc/passwd|wc -l</code><br />
 if [ $n -gt 0 ]<br />
 then<br />
 echo &ldquo;There are $n common users.&rdquo;<br />
 else<br />
 echo &ldquo;No common users.&rdquo;<br />
 fi</p>
</blockquote>

<p>100、请详细查看如下几个数字的规律，并使用shell脚本输出后面的十个数字。<br />
10 31 53 77 105 141 &hellip;&hellip;.</p>

<p>试题解析：<br />
我想大多数人都会去比较这些数字的差值：<br />
10 31 53 77 105 141<br />
21 22 24 28 36<br />
但是这个差值看，并没有什么规律，而我们再仔细看的时候，发现这个差值的差值是有规律的：<br />
10 31 53 77 105 141<br />
21 22 24 28 36<br />
1 2 4 8</p>

<blockquote>
<p>#! /bin/bash</p>

<p>x=21</p>

<p>m=10</p>

<p>echo $m</p>

<p>for i in <code>seq 0 14</code>; do</p>

<p>j=$[2**$i]</p>

<p>m=$[$m+$x]</p>

<p>echo $m</p>

<p>x=$[$x+$j]</p>

<p>done</p>
</blockquote>

<p>101、需求： 根据web服务器上的访问日志，把一些请求量非常高的ip给拒绝掉！<br />
分析： 我们要做的，不仅是要找到哪些ip请求量不合法，并且还要每隔一段时间把之前封掉的ip（若不再继续请求了）给解封。
所以该脚本的关键点在于定一个合适的时间段和阈值。</p>

<p>比如， 我们可以每一分钟去查看一下日志，把上一分钟的日志给过滤出来分析，并且只要请求的ip数量超过100次那么就直接封掉。
而解封的时间又规定为每半小时分析一次，把几乎没有请求量的ip给解封！</p>

<p>参考日志文件片段：</p>

<p>157.55.39.107 [20/Mar/2015:00:01:24 +0800] www.aminglinux.com
&ldquo;/bbs/thread-5622-3-1.html&rdquo; 200 &ldquo;-&rdquo; &ldquo;Mozilla/5.0 (compatible; bingbot/2.0;
+<a href="http://www.bing.com/bingbot.htm)&quot;">http://www.bing.com/bingbot.htm)&quot;</a><br />
61.240.150.37 [20/Mar/2015:00:01:34 +0800] www.aminglinux.com
&ldquo;/bbs/search.php?mod=forum&amp;srchtxt=LNMP&amp;formhash=8f0c7da9&amp;searchsubmit=true&amp;source=hotsearch&rdquo;
200 &ldquo;-&rdquo; &ldquo;Mozilla/5.0 (compatible; bingbot/2.0;
+<a href="http://www.bing.com/bingbot.htm)&quot;">http://www.bing.com/bingbot.htm)&quot;</a></p>

<blockquote>
<p>#! /bin/bash</p>

<p>logfile=/home/logs/access.log<br />
 d1=<code>date -d &quot;-1 minute&quot; +%H:%M</code><br />
 d2=<code>date +%M</code><br />
 ipt=/sbin/iptables<br />
 ips=/tmp/ips.txt</p>

<p>block(){<br />
 grep &ldquo;$d1:&rdquo; $logfile|awk &lsquo;{print $1}&rsquo; |sort -n |uniq -c |sort -n &gt;$ips<br />
 for ip in <code>awk '$1&gt;100 {print $2}' $ips</code>; do<br />
 $ipt -I INPUT -p tcp &ndash;dport 80 -s $ip -j REJECT<br />
 echo &ldquo;<code>date +%F-%T</code> $ip&rdquo; &gt;&gt; /tmp/badip.txt<br />
 done<br />
 }</p>

<p>unblock(){<br />
 for i in <code>$ipt -nvL --line-numbers |grep '0.0.0.0/0'|awk '$2&lt;15 {print
$1}'|sort -nr</code>; do<br />
 $ipt -D INPUT $i<br />
 done<br />
 $ipt -Z<br />
 }</p>

<p>if [ $d2 == &ldquo;00&rdquo; ] || [ $d2 == &ldquo;30&rdquo; ]; then<br />
 unblock<br />
 block<br />
 else<br />
 block<br />
 fi</p>
</blockquote>

<p>102、监控httpd进程</p>

<p>在服务器上，写一个监控脚本。</p>

<p>1. 每隔10s去检测一次服务器上的httpd进程数，如果大于等于500的时候，就需要自动重启一下apache服务，并检测启动是否成功？<br />
2. 若没有正常启动还需再一次启动，最大不成功数超过5次则需要理解发邮件通知管理员，并且以后不需要再检测！<br />
3.
如果启动成功后，1分钟后再次检测httpd进程数，若正常则重复之前操作（每隔10s检测一次），若还是大于等于500，那放弃重启并需要发邮件给管理员，然后自动退出该脚本。假设其中发邮件脚本为之前咱们使用的mail.py</p>

<blockquote>
<p>#!/bin/bash<br />
 check_service()<br />
 {<br />
 n=0<br />
 for i in <code>seq 1 5</code><br />
 do<br />
 /usr/local/apache2/bin/apachectl restart 2&gt;/tmp/apache.err<br />
 if [ $? -ne 0 ]<br />
 then<br />
 n=$[$n+1]<br />
 else<br />
 break<br />
 fi<br />
 done<br />
 if [ $n -eq 5 ]<br />
 then<br />
 ##下面的mail.py参考<a href="https://coding.net/u/aminglinux/p/aminglinux-">https://coding.net/u/aminglinux/p/aminglinux-</a>
book/git/blob/master/D22Z/mail.py<br />
 python mai.py &ldquo;123@qq.com&rdquo; &ldquo;httpd service down&rdquo; <code>cat /tmp/apache.err</code></p>

<p>exit</p>

<p>fi<br />
 }</p>

<p>while :<br />
 do<br />
 t_n=<code>ps -C httpd --no-heading |wc -l</code><br />
 if [ $t_n -ge 500 ]<br />
 then<br />
 /usr/local/apache2/bin/apachectl restart<br />
 if [ $? -ne 0 ]<br />
 then<br />
 check_service<br />
 fi<br />
 sleep 60<br />
 fi<br />
 sleep 10<br />
 done</p>
</blockquote>

<p>103、用shell脚本实现如下需求：<br />
添加user_00 - user_09
10个用户，并且给他们设置一个随机密码，密码要求10位包含大小写字母以及数字，注意需要把每个用户的密码记录到一个日志文件里。</p>

<p>提示：<br />
1. 随机密码使用命令 mkpasswd<br />
2. 在脚本中给用户设置密码，可以使用echo 然后管道passwd命令</p>

<p>#!/bin/bash<br />
for i in <code>seq -w 00 09</code><br />
do<br />
useradd user<em>$i<br />
p=<code>mkpasswd -s 0 -l 10</code><br />
echo &ldquo;user</em>$i $p&rdquo; &gt;&gt;/tmp/user0<em>9.pass<br />
echo $p |passwd &ndash;stdin user</em>$i<br />
done</p>

<p>104、输入数字执行对应命令</p>

<p>写一个脚本实现如下功能： 输入一个数字，然后运行对应的一个命令。显示命令如下：*cmd meau** 1&mdash;date 2&ndash;ls 3&ndash;who 4&ndash;
pwd<br />
当输入1时，会运行date, 输入2时运行ls, 依此类推。</p>

<p>#!/usr/bin/env bash</p>

<p>echo &ldquo;*******<strong><em>cmd menu</em></strong>********&rdquo;</p>

<p>cmdTip=(</p>

<p>&ldquo;1&ndash;date&rdquo;</p>

<p>&ldquo;2&ndash;ls&rdquo;</p>

<p>&ldquo;3&ndash;who&rdquo;</p>

<p>&ldquo;4&ndash;pwd&rdquo;</p>

<p>)</p>

<p>for tip in ${cmdTip[@]};</p>

<p>do</p>

<p>echo ${tip}</p>

<p>done</p>

<p>cmd=(</p>

<p>&ldquo;date&rdquo;</p>

<p>&ldquo;ls&rdquo;</p>

<p>&ldquo;who&rdquo;</p>

<p>&ldquo;pwd&rdquo;</p>

<p>)</p>

<p>read -p &ldquo;Please enter the nature index of the cmd(DEFAULT 1):&rdquo; num</p>

<p>echo ${num}</p>

<p>if [ -z ${num} ];then</p>

<p>num=1</p>

<p>fi</p>

<p>echo $(${cmd[num-1]})</p>

<p>exit 0</p>

<p>105、用shell打印下面这句话中字母数小于6的单词。<br />
Bash also interprets a number of multi-character options.</p>

<p>#!/bin/bash</p>

<p>for s in Bash also interprets a number of multi-character options</p>

<p>do</p>

<p>n=<code>echo $s|wc -c</code></p>

<p>if [ $n -lt 6 ]</p>

<p>then echo $s</p>

<p>fi</p>

<p>done</p>

<p>106、 <strong>写一个脚本</strong></p>

<p>创建一个函数，能接受两个参数：</p>

<p>1).第一个参数为URL，即可下载的文件；第二个参数为目录，即下载后保存的位置；</p>

<p>2).如果用户给的目录不存在，则提示用户是否创建；如果创建就继续执行，否则，函数返回一个51的错误值给调用脚本；</p>

<p>3).如果给的目录存在，则下载文件；下载命令执行结束后测试文件下载成功与否；如果成功，则返回0给调用脚本，否则，返回52给调用脚本；</p>

<pre><code>[root@localhost tmp]# cat downfile.sh
#!/bin/bash
url=$1
dir=$2
download()
{
cd $dir &gt;&gt; /dev/null 2&gt;&amp;1
if [ $? -ne 0 ];then
 read -p &quot;$dir No such file or directory,create?(y/n)&quot; answer
if [ &quot;$answer&quot; == &quot;y&quot; ];then
  mkdir -p $dir
  cd $dir
  wget $url 1&gt; /dev/null 2&gt;&amp;1
 else
  return &quot;51&quot;
 fi
fi
if [ $? -ne 0 ]; then
 return &quot;52&quot;
fi
}
download $url $dir
echo $
</code></pre>

<p>107、 <strong>写一个脚本</strong></p>

<p>1、创建一个函数，可以接受一个磁盘设备路径（如/dev/sdb）作为参数;在真正开始后面步骤之前提醒用户有危险，并让用户选择是否继续；而后将此磁盘设备上的所有分区清空（提示，使用命令dd
if=/dev/zero of=/dev/sdb bs=512 count=1实现，注意其中的设备路径不要写错了；</p>

<p>如果此步骤失败，返回67给主程序；</p>

<p>接着在此磁盘设备上创建两个主分区，一个大小为100M，一个大小为1G；如果此步骤失败，返回68给主程序；</p>

<p>格式化此两分区，文件系统类型为ext3；如果此步骤失败，返回69给主程序；</p>

<p>如果上述过程都正常，返回0给主程序；</p>

<p>2、调用此函数；并通过接收函数执行的返回值来判断其执行情况，并将信息显示出来；</p>

<pre><code>local Darray=(`ls /dev/sd[a-z]`)
for i in ${Darray};do
[[ &quot;$i&quot; == &quot;$1&quot; ]] &amp;&amp; Sd=$i &amp;&amp;break
done
else
return66
fi
</code></pre>

<p>#当匹配成功，进入选择，告诉用户，是否继续，输错的话进入无限循环，当用户选择<br />
Y,则清空目标分区，且跳出while循环<br />
while :;do<br />
read -p &ldquo;Warning!!!This operation will clean $Sd data.Next=y,<br />
Quit=n [y|n]:&rdquo; Choice<br />
case $Choice in<br />
y)<br />
dd if=/dev/zero of=$Sd bs=512 count=1 &amp;&gt; /dev/null &amp;&amp;break ||<br />
return 67 ;;<br />
n)<br />
exit 88 ;;<br />
*)<br />
echo &ldquo;Invalid choice,please choice again.&rdquo; ;;<br />
esac<br />
done</p>

<p>使用echo传递给fdisk进行分区，如果此命令失败，则跳转出去，错误值68，需要注意的是，有时候这个返回值很诡异，笔者之前成功与否都是返回的1，后来重启之后，就好了，如果慎重的话，可以对创建的分区，进行判断，不过就需要使用其他工具截取相关字段了，虽有些小麻烦，但无大碍</p>

<pre><code>echo-e &quot;n\np\n1\n\n+100M\nn\np\n2\n\n+1024M\nw\n&quot;|
fdisk /dev/sdb&amp;&gt; /dev/null || return 68
</code></pre>

<p>格式化之前，让内核重新读取磁盘分区表，值得注意的是，有的系统版本，使用partprobe无效，譬如笔者的环境是rhel5.8，而rhel6.0以后，这个命令就很危险了，而使用partx
-a /dev/sdb则效果更好…此项需慎重，如果格式化失败，则告知把失败的分区定义成变量，且跳出函数，并带出错误值69</p>

<pre><code>`partprobe`
Part=`fdisk -l /dev/$Sd|tail -2|cut -d” ” -f1`
for M in ${Part};do
mke2fs -j $M &amp;&gt; /dev/null &amp;&amp; ErrorPart=$M &amp;&amp;return 69
done
return 0
}
</code></pre>

<p>下面代码，调用函数，接收函数返回值，根据返回值进行判断哪里出错。</p>

<pre><code>Disk_Mod $1
Res=$?
[ $Res-eq 0 ] &amp;&amp; exit 0
[ $Res-eq 66 ] &amp;&amp; echo &quot;Error! Invalid input.&quot;
[ $Res-eq 67 ] &amp;&amp; echo &quot;Error! Command -&gt; dd &lt; - Faild.&quot;
[ $Res-eq 68 ] &amp;&amp; echo &quot;Error! Command -&gt; fdisk &lt; - Faild.&quot;
[ $Res-eq 69 ] &amp;&amp; echo &quot;Error! Command -&gt; mke2fs &lt; - Faild.&quot;
</code></pre>

<p>108、编写个shell脚本将当前目录下大于10K的文件转移到/tmp目录下</p>

<p>Q：主要是考察awk 这些的用法</p>

<p>#/bin/sh<br />
#Programm :</p>

<h1 id="using-for-move-currently-directory-to-tmp">Using for move currently directory to /tmp</h1>

<p>for FileName in <code>ls -l |awk ‘$5&gt;10240 {print $9}’</code><br />
do<br />
mv $FileName /tmp<br />
done<br />
ls -la /tmp<br />
echo “Done! ”</p>

<p>109、编写shell脚本获取本机的网络地址。比如：本机的ip地址是：192.168.100.<sup>2</sup>&frasl;<sub>255</sub>.255.255.0，那么它的网络地址是192.168.100.<sup>1</sup>&frasl;<sub>255</sub>.255.255.0</p>

<p>方法一：</p>

<p>#!/bin/bash<br />
#This script print ip and network<br />
file=”/etc/sysconfig/network-scripts/ifcfg-eth0″<br />
if [ -f $file ] ;then<br />
IP=<code>grep “IPADDR” $file|awk -F”=” ‘{ print $2 }’</code><br />
MASK=<code>grep “NETMASK” $file|awk-F”=” ‘{ print $2 }’</code><br />
echo “$IP/$MASK”<br />
exit 1<br />
fi</p>

<p>方法二：</p>

<p>#!/bin/bash<br />
#This programm will printf ip/network</p>

<p>IP=<code>ifconfig eth0 |grep ‘inet ‘ |sed ’s/^.*addr://g’|sed ’s/ Bcast.*$//g’</code><br />
NETMASK=<code>ifconfig eth0 |grep ‘inet ‘|sed ’s/^.*Mask://g’</code><br />
echo “$IP/$NETMASK”<br />
exit</p>

<h3 id="110-字符串替换命令"><strong>110、字符串替换命令</strong></h3>

<blockquote>
<dl>
<dt>:s/well/good/ 替换当前行第一个well 为 good</dt>
<dt>:s/well/good/g 替换当前行所有well 为 good</dt>
<dt>:n,$s/well/good/ 替换第 n 行开始到最后一行中每一行的第一个 well 为 good</dt>
</dl>

<p>:n,$s/well/good/g 替换第 n 行开始到最后一行中每一行所有 well 为 good</p>

<dl>
<dt>n 为数字，若 n 为 .， 表示从当前行开始到最后一行</dt>
<dt>:%s/well/good/ （等同于 :g/well/s//good/） 替换每一行的第一个 well 为 good</dt>
</dl>

<p>:%s/well/good/g （等同于 :g/well/s//good/g） 替换每一行中所有 well 为 good</p>

<dl>
<dt><strong>特殊符号转义：</strong> 可以使用 <strong>#</strong> 作为分隔符，此时中间出现的 / 不会作为分隔符</dt>
<dt>:s#well/#good/# 替换当前行第一个 well/ 为 good/</dt>
</dl>

<p>:%s#/usr/bin#/bin#g 可以把文件中所有路径/usr/bin换成/bin</p>
</blockquote>

<h3 id="111-删除多行"><strong>111、删除多行</strong></h3>

<blockquote>
<p>删除多行步骤如下：</p>

<dl>
<dt>1. 首先要显示对应的行数这样方能知道从第几行到第几行删除</dt>
<dd><p>set nu</p></dd>
</dl>

<p>2. 按Esc键退出，在命令行中输入：190,6233d(即[190 , 6233]都删除掉)</p>

<p>如果想要情况整个文件内容，在直接运行以下命令：</p>

<p><strong>清空文件内容： &gt; log.txt</strong></p>
</blockquote>

<h3 id="112-行位定位"><strong>112、 行位定位</strong></h3>

<blockquote>
<p><strong>直接定位到最后一行：</strong></p>

<p>按Esc键退出，在命令行中输入： G</p>

<p><strong>直接定位到第一行：</strong></p>

<p>按Esc键退出，在命令行中输入： 1 G</p>

<p><strong>直接定位到某一行：（第１７行）</strong></p>

<p>按Esc键退出，在命令行中输入：17 G</p>
</blockquote>

<h3 id="113-复制一行或多行"><strong>113、复制一行或多行</strong></h3>

<blockquote>
<p><strong>&lt; 1. 复制一行</strong></p>

<p>yy 复制当前行</p>

<p>p 粘贴</p>

<p><strong>&lt; 2. 复制多行</strong></p>

<p>7yy 从当前行开始复制７行</p>

<p>p 粘贴</p>
</blockquote>

<p>114、 <strong>grep 的用法</strong></p>

<blockquote>
<p><strong>&lt; 1. 显示匹配的后n行 （after）</strong></p>

<p>grep -A n</p>

<p><strong>&lt; 2. 显示匹配的前n行 （before）</strong></p>

<p>grep -B n</p>

<p><strong>&lt; 3. 显示匹配的前后n行 （context）</strong></p>

<p>grep -C n</p>

<p><strong>&lt; 4. 忽略大小写</strong></p>

<p>grep -i str</p>
</blockquote>

<p>115、</p>

<p>116、</p>

<p>117、</p>

<h2 id="shell脚本处理浮点数的运算和比较实例">Shell脚本处理浮点数的运算和比较实例</h2>

<p><strong>1. 用bc来处理计算（包括整型和浮点计算）</strong></p>

<p>bc – An arbitrary precision calculator language<br />
(1). 通常在Bash脚本中使用bc的范例格式为：<br />
variable=$(echo “OPTIONS; OPERATIONS” | bc [options]) 即：echo “[选项];操作” | bc
<a href="2">选项</a>.
在下面的脚本中，提到在第一个选项中，“scale”变量表示输出中小数点后的精度，可以用于控制计算结果的精度；“ibase”和“obase”分别表示输入和输出数据的进制，可以用于数值进制的转换。<br />
(3). 浮点数的比较，如“if [ $(echo &ldquo;$big &gt; $small&rdquo; | bc) -eq 1
]”，将一个逻辑判断式用管道传给bc。如果结果为真则输出1，否则输出0，然后就可以利用这个结果进行进一步的操作了。<br />
(4). bc本来是用一个文件作为输入进行计算的（后面也有演示），所以可以将很复杂的计算写到文件中，然后让bc工具去处理到处计算结果。<br />
注意一下：在使用除法运算符/时，要想保留小数，需要自己设置scale，否则默认时scale，小数点后时0位。</p>

<p><strong>2. 使用awk来处理浮点计算和浮点数比较</strong></p>

<p>不解释过多了，写了示例脚本如下，看懂了这个就会知道怎么处理浮点计算和浮点数比较了。</p>

<p><a href="https://img.it610.com/image/info8/d038a93cea82491498d4d304f6aea337.jpg"><img src="https://img.it610.com/image/info8/d038a93cea82491498d4d304f6aea337.jpg" alt="Shell脚本介绍（资源）_第25张图片" /></a></p>

<p>执行的结果如下：</p>

<p><a href="https://img.it610.com/image/info8/e4c86b79d32a45adb2a2438802510593.jpg"><img src="https://img.it610.com/image/info8/e4c86b79d32a45adb2a2438802510593.jpg" alt="Shell脚本介绍（资源）_第26张图片" /></a></p>

<p>另外，bc处理一个文件中的计算逻辑，演示如下：</p>

<p><a href="https://img.it610.com/image/info8/e21b92a6cde342f7bd38b0ac09c4dc1f.jpg"><img src="https://img.it610.com/image/info8/e21b92a6cde342f7bd38b0ac09c4dc1f.jpg" alt="Shell脚本介绍（资源）_第27张图片" /></a></p>

<p>请“man bc”查看详情；同样，请“man awk”。</p>

<h2 id="bash经典用法及其案例">Bash经典用法及其案例</h2>

<h3 id="一-条件选择-判断">一、条件选择、判断</h3>

<blockquote>
<p>**（1）条件选择 <strong>if</strong>**</p>
</blockquote>

<p><strong>1、用法格式</strong></p>

<p><strong>if</strong> 判断条件 1 <strong>; then</strong></p>

<p>条件为真的分支代码</p>

<p><strong>elif</strong> 判断条件 2 <strong>; then</strong></p>

<p>条件为真的分支代码</p>

<p>elif 判断条件 3 ; then</p>

<p>条件为真的分支代码</p>

<p><strong>else</strong></p>

<p>以上条件都为假的分支代码</p>

<p><strong>fi</strong></p>

<p>逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if。</p>

<p><strong>2、经典案例：</strong></p>

<p>① 判断年纪</p>

<p><a href="https://img.it610.com/image/info8/4be2735a1feb4a5d96737673466fe8f0.jpg"><img src="https://img.it610.com/image/info8/4be2735a1feb4a5d96737673466fe8f0.jpg" alt="Shell脚本介绍（资源）_第28张图片" /></a></p>

<p>分析：请输入年纪，先判断输入的是否含有除数字以外的字符，有，就报错；没有，继续判断是否小于150，是否大于18。</p>

<p>② 判断分数</p>

<p><a href="https://img.it610.com/image/info8/81effbd072c94186b53e6522617dbec3.jpg"><img src="https://img.it610.com/image/info8/81effbd072c94186b53e6522617dbec3.jpg" alt="Shell脚本介绍（资源）_第29张图片" /></a></p>

<p>分析：请输入成绩，先判断输入的是否含有除数字以外的字符，有，就报错；没有，继续判断是否大于100，是否大于85，是否大于60。</p>

<blockquote>
<p>**（2）条件判断 <strong>case</strong>**</p>
</blockquote>

<p><strong>1、用法格式</strong></p>

<p><strong>case</strong> $name <strong>in;</strong></p>

<p><strong>PART1)</strong></p>

<p>cmd</p>

<p><strong>;;</strong></p>

<p>PART2)</p>

<p>cmd</p>

<p><strong>;;</strong></p>

<p>*<strong>)</strong></p>

<p>cmd</p>

<p><strong>;;</strong></p>

<p><strong>esac</strong></p>

<p>注意：case 支持glob 风格的通配符：</p>

<p>*: 任意长度任意字符</p>

<p>?: 任意单个字符</p>

<p>[] ：指定范围内的任意单个字符</p>

<p>a|b: a 或b</p>

<p><strong>2、案例：</strong></p>

<p>判断yes or no</p>

<p><a href="https://img.it610.com/image/info8/ded57e3d27514001836ea2e2255589df.jpg"><img src="https://img.it610.com/image/info8/ded57e3d27514001836ea2e2255589df.jpg" alt="Shell脚本介绍（资源）_第30张图片" /></a></p>

<p>分析：请输入yes or no，回答Y/y、yes各种大小写组合为yes；回答N/n、No各种大小写组合为no。</p>

<h3 id="二-四个循环">二、四个循环</h3>

<blockquote>
<p>**（1） <strong>for</strong>**</p>
</blockquote>

<p><strong>1、用法格式</strong></p>

<p><strong>① for</strong> <strong>name in</strong> 列表 <strong>;do</strong></p>

<p>循环体</p>

<p><strong>done</strong></p>

<p>② <strong>for (( exp1; exp2; exp3 )) ;do</strong></p>

<p>cmd</p>

<p><strong>done</strong></p>

<p><a href="https://img.it610.com/image/info8/374ca6f2ae14482c8e9ea085c8823247.jpg"><img src="https://img.it610.com/image/info8/374ca6f2ae14482c8e9ea085c8823247.jpg" alt="Shell脚本介绍（资源）_第31张图片" /></a></p>

<p>exp1只执行一次，相当于在for里嵌了while</p>

<p>③ 执行机制：依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束</p>

<p>列表的表示方法，可以glob 通配符，如{1..10} 、*.sh ；也可以变量引用，如： <code>seq 1 $name</code></p>

<p><strong>2、案例：</strong></p>

<p>① 求出（1+2+&hellip;+n）的总和</p>

<p><a href="https://img.it610.com/image/info8/992a7c16a1f04a69a8d1f08e1883b96d.jpg"><img src="https://img.it610.com/image/info8/992a7c16a1f04a69a8d1f08e1883b96d.jpg" alt="Shell脚本介绍（资源）_第32张图片" /></a></p>

<p>分析：sum初始值为0，请输入一个数，先判断输入的是否含有除数字以外的字符，有，就报错；没有判断是否为0，不为0进入for循环，i的范围为1~输入的数，每次的循环为sum=sum+i，循环结束，最后输出sum的值。</p>

<p>② 求出（1+2+&hellip;+100）的总和</p>

<p><a href="https://img.it610.com/image/info8/f2a4fbb4df3544b392f07a6ee8048597.jpg"><img src="https://img.it610.com/image/info8/f2a4fbb4df3544b392f07a6ee8048597.jpg" alt="Shell脚本介绍（资源）_第33张图片" /></a></p>

<p>分析：i=1,num=0；当i&lt;=100，进入循环，若i÷2取余=1，则sum=sum+i，i=i+1。</p>

<blockquote>
<p><strong>（2）while</strong></p>
</blockquote>

<p><strong>1、用法格式</strong></p>

<p><strong>while</strong> 循环控制条件 <strong>;do</strong></p>

<p>循环</p>

<p><strong>done</strong></p>

<p>循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true” ，则执行一次循环；直到条件测试状态为“false” 终止循环</p>

<p><strong>2、特殊用法（遍历文件的每一行）：</strong></p>

<p>while read line; do控制变量初始化</p>

<p>循环体</p>

<p>done <strong>&lt;</strong> /PATH/FROM/SOMEFILE</p>

<p>或 <strong>cat</strong> /PATH/FROM/SOMEFILE <strong>|</strong> while read line; do</p>

<p>循环体</p>

<p>done</p>

<p>依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line</p>

<h2 id="3-案例"><strong>3、案例：</strong></h2>

<p>① 100以内所有正奇数之和</p>

<p><a href="https://img.it610.com/image/info8/27b291493b914e0aa4fcbee921095a88.jpg"><img src="https://img.it610.com/image/info8/27b291493b914e0aa4fcbee921095a88.jpg" alt="Shell脚本介绍（资源）_第34张图片" /></a></p>

<p>分析：sum初始值为0，i的初始值为1；请输入一个数，先判断输入的是否含有除数字以外的字符，有，就报错；没有当i&lt;100时，进入循环，判断 i÷2取余
是否不为0，不为0时为奇数，sum=sum+i，i+1，为0，i+1；循环结束，最后输出sum的值。</p>

<blockquote>
<p>**（3） <strong>until</strong> 循环**</p>
</blockquote>

<p><strong>1、用法</strong></p>

<p><strong>unitl</strong> 循环条件 <strong>;do</strong></p>

<p>循环</p>

<p><strong>done</strong></p>

<p>进入条件：循环条件为true ；退出条件：循环条件为false；刚好 <strong>和while相反</strong> ，所以不常用，用while就行。</p>

<p><strong>2、案例</strong></p>

<p>监控xiaoming用户，登录就杀死</p>

<p><a href="https://img.it610.com/image/info8/5084c25887004c25ab55da63c49375ef.jpg"><img src="https://img.it610.com/image/info8/5084c25887004c25ab55da63c49375ef.jpg" alt="Shell脚本介绍（资源）_第35张图片" /></a></p>

<p>分析：每隔0.5秒扫描，直到发现xiaoming用户登录，杀死这个进程，退出脚本，用于监控用户登录。</p>

<blockquote>
<p>**（4） <strong>select</strong> 循环与菜单**</p>
</blockquote>

<p><strong>1、用法</strong></p>

<p><strong>select</strong> variable <strong>in</strong> list</p>

<p><strong>do</strong></p>

<p>循环体命令</p>

<p><strong>done</strong></p>

<p>① select 循环主要用于创建菜单，按数字顺序排列的示菜单项将显示在标准错误上，并显示PS3 提示符，等待用户输入</p>

<p>② 用户输入菜单列表中的某个数字，执行相应的命令</p>

<p>③ 用户输入被保存在内置变量 REPLY 中</p>

<p>④ select 是个无限循环，因此要记住用 break 命令退出循环，或用 exit 按 命令终止脚本。也可以按 ctrl+c退出循环</p>

<p>⑤ select 和 经常和 case 联合使用</p>

<p>⑥ 与for循环类似，可以省略 in list， 此时使用位置参量</p>

<p><strong>2、案例：</strong></p>

<p>生成菜单，并显示选中的价钱</p>

<p><a href="https://img.it610.com/image/info8/6e92a13103524a5b9ef04fe33bcddeeb.jpg"><img src="https://img.it610.com/image/info8/6e92a13103524a5b9ef04fe33bcddeeb.jpg" alt="Shell脚本介绍（资源）_第36张图片" /></a></p>

<p>分析：PS3是select的提示符，自动生成菜单，选择5break退出循环。</p>

<p><a href="https://img.it610.com/image/info8/56c19723a7704805a7db6543d700b118.jpg"><img src="https://img.it610.com/image/info8/56c19723a7704805a7db6543d700b118.jpg" alt="Shell脚本介绍（资源）_第37张图片" /></a></p>

<h2 id="三-循环里的一些用法">三、循环里的一些用法</h2>

<blockquote>
<p><strong>（1）循环控制语句</strong></p>
</blockquote>

<p><strong>continue</strong> [N]：提前结束 <strong>第N层的本轮</strong> 循环，而直接进入下一轮判断；最内层为第1层</p>

<p><strong>break</strong> [N]：提前结束 <strong>第N层</strong> 循环，最内侧为第1层</p>

<p>例：while CONDTITON1; do</p>

<p>CMD1</p>

<p>if CONDITION2; then</p>

<p>continue / break</p>

<p>fi</p>

<p>CMD2</p>

<p>done</p>

<p><strong>2、案例：</strong></p>

<p>① 求（1+3+&hellip;+49+53+&hellip;+100）的和</p>

<p><a href="https://img.it610.com/image/info8/b73a3ecc2ac14a2fa3e9673e86c01c73.jpg"><img src="https://img.it610.com/image/info8/b73a3ecc2ac14a2fa3e9673e86c01c73.jpg" alt="Shell脚本介绍（资源）_第38张图片" /></a></p>

<p>分析：做1+2+&hellip;+100的循环，当i=51时，跳过这次循环，但是继续整个循环，结果为：sum=2449</p>

<p>② 求（1+3+&hellip;+49）的和</p>

<p><a href="https://img.it610.com/image/info8/0425829f951b45918174d955dc3802ad.jpg"><img src="https://img.it610.com/image/info8/0425829f951b45918174d955dc3802ad.jpg" alt="Shell脚本介绍（资源）_第39张图片" /></a></p>

<p>分析：做1+2+&hellip;+100的循环，当i=51时，跳出整个循环，结果为：sum=625</p>

<blockquote>
<p><strong>（2）循环控制shift命令</strong></p>
</blockquote>

<p><strong>1、作用</strong></p>

<p>用于将参数列表list左移指定次数，最左端的那个参数就从列表中删除，其后边的参数继续进入循环</p>

<p><strong>2、案例：</strong></p>

<p>① 创建指定的多个用户</p>

<p><a href="https://img.it610.com/image/info8/6d3e3fb0330a4d8ead307fb606a41d2a.jpg"><img src="https://img.it610.com/image/info8/6d3e3fb0330a4d8ead307fb606a41d2a.jpg" alt="Shell脚本介绍（资源）_第40张图片" /></a></p>

<p>分析：如果没有输入参数（参数的总数为0），提示错误并退出；反之，进入循环；若第一个参数不为空字符，则创建以第一个参数为名的用户，并移除第一个参数，将紧跟的参数左移作为第一个参数，直到没有第一个参数，退出。</p>

<p>② 打印直角三角形的字符</p>

<p><a href="https://img.it610.com/image/info8/56c4339e5e55460db47d798e47211f7b.jpg"><img src="https://img.it610.com/image/info8/56c4339e5e55460db47d798e47211f7b.jpg" alt="Shell脚本介绍（资源）_第41张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/d34d884f9f16462d9c4ae2faf279b30a.jpg"><img src="https://img.it610.com/image/info8/d34d884f9f16462d9c4ae2faf279b30a.jpg" alt="Shell脚本介绍（资源）_第42张图片" /></a></p>

<blockquote>
<p><strong>（3）返回值结果</strong></p>
</blockquote>

<p><strong>true</strong> 永远返回成功结果</p>

<p><strong>:</strong> null command ,什么也不干，返回成功结果</p>

<p><strong>false</strong> 永远返回错误结果</p>

<p>创建无限循环</p>

<p>while true ;do</p>

<p>循环体</p>

<p>done</p>

<blockquote>
<p><strong>（4）循环中可并行执行，使脚本运行更快</strong></p>
</blockquote>

<p><strong>1、用法</strong></p>

<p>for name in 列表 ;do</p>

<p><strong>{</strong></p>

<p>循环体</p>

<p><strong>} &amp;</strong></p>

<p>done</p>

<p><strong>wait</strong></p>

<p><strong>2、实例：</strong></p>

<p>搜寻自己指定ip（子网掩码为24的）的网段中，UP的ip地址</p>

<p><a href="https://img.it610.com/image/info8/9a7e1e8897864e289bfff368c0c649b3.jpg"><img src="https://img.it610.com/image/info8/9a7e1e8897864e289bfff368c0c649b3.jpg" alt="Shell脚本介绍（资源）_第43张图片" /></a></p>

<p>分析：请输入一个IP地址例192.168.37.234，如果格式不是0.0.0.0 则报错退出；正确则进入循环，IP变量的值为192.168.37.
i的范围为1-254，并行ping 192.168.37.1-154，ping通就输出此IP为UP。直到循环结束。</p>

<h2 id="四-信号捕获trap">四、信号捕获trap</h2>

<p><strong>1、用法格式</strong></p>

<p><strong>trap &lsquo; 触发指令&rsquo;</strong> 信号，自定义进程收到系统发出的指定信号后，将执行触发指令，而不会执行原操作</p>

<p><strong>trap &ldquo;</strong> 信号，忽略信号的操作</p>

<p><strong>trap &lsquo;-&rsquo;</strong> 信号，恢复原信号的操作</p>

<p><strong>trap -p</strong> ，列出自定义信号操作</p>

<p>信号可以3种表达方法：信号的数字2、全名SIGINT、缩写INT</p>

<p><strong>2、常用信号：</strong></p>

<p>1) SIGHUP: 无须关闭进程而让其重读配置文件</p>

<p>2) SIGINT: 中止正在运行的进程；相当于Ctrl+c</p>

<p>3) SIGQUIT: 相当于ctrl+</p>

<p>9) SIGKILL: 强制杀死正在运行的进程</p>

<p>15) SIGTERM ：终止正在运行的进程（默认为15）</p>

<p>18) SIGCONT ：继续运行</p>

<p>19) SIGSTOP ：后台休眠</p>

<p><strong>9 信号，强制杀死，捕获不住</strong></p>

<p><strong>3、案例：</strong></p>

<p>① 打印0-9，ctrl+c不能终止</p>

<p><a href="https://img.it610.com/image/info8/512ffa7d54934b6db9784df48f171ed4.jpg"><img src="https://img.it610.com/image/info8/512ffa7d54934b6db9784df48f171ed4.jpg" alt="Shell脚本介绍（资源）_第44张图片" /></a></p>

<p>分析：i=0，当i&lt;10，每休眠1秒，i+1，捕获2信号，并执行echo press ctrl+c</p>

<p>分析：i=0，当i&lt;10，每休眠1秒，i+1，捕获2信号，并执行echo press ctrl+c</p>

<p><a href="https://img.it610.com/image/info8/8d1d370c7fb64b84acf9bfc18dd6cd82.jpg"><img src="https://img.it610.com/image/info8/8d1d370c7fb64b84acf9bfc18dd6cd82.jpg" alt="Shell脚本介绍（资源）_第45张图片" /></a></p>

<p>② 打印0-3，ctrl+c不能终止，3之后恢复，能终止</p>

<p><a href="https://img.it610.com/image/info8/927e7e646fc74afda880ac8f6e90394c.jpg"><img src="https://img.it610.com/image/info8/927e7e646fc74afda880ac8f6e90394c.jpg" alt="Shell脚本介绍（资源）_第46张图片" /></a></p>

<p>分析：i=0，当i<3，每休眠1秒，i+1，捕获2信号；i>3时，解除捕获2信号。</p>

<p><a href="https://img.it610.com/image/info8/89f411258e3d44aba2f694bc5d84bae3.jpg"><img src="https://img.it610.com/image/info8/89f411258e3d44aba2f694bc5d84bae3.jpg" alt="Shell脚本介绍（资源）_第47张图片" /></a></p>

<h2 id="五-脚本小知识">五、脚本小知识</h2>

<p><strong>1、生成随机字符 cat /dev/urandom</strong></p>

<p>生成8个随机大小写字母或数字 cat /dev/urandom |tr -dc [:alnum:] |head -c 8</p>

<p><strong>2、生成随机数 echo $RANDOM</strong></p>

<p>确定范围 echo $[RANDOM%7] 随机7个数（0-6）</p>

<p>echo $[$[RANDOM%7]+31] 随机7个数（31-37）</p>

<p><strong>3、echo打印颜色字</strong></p>

<p>echo -e &ldquo;\033[31malong\033[0m&rdquo; 显示红色along</p>

<p>echo -e &ldquo;\033[1;31malong\033[0m&rdquo; 高亮显示红色along</p>

<p>echo -e &ldquo;\033[41malong\033[0m&rdquo; 显示背景色为红色的along</p>

<p>echo -e &ldquo;\033[31;5malong\033[0m&rdquo; 显示闪烁的红色along</p>

<p>color=$[$[RANDOM%7]+31]</p>

<p>echo -ne &ldquo;\033[1;${color};5m*\033[0m&rdquo; 显示闪烁的随机色along</p>

<h3 id="脚本">脚本</h3>

<p><strong>1、9x9乘法表</strong></p>

<p><a href="https://img.it610.com/image/info8/9a0de8859fcf499cb3fb1fb6684d868b.jpg"><img src="https://img.it610.com/image/info8/9a0de8859fcf499cb3fb1fb6684d868b.jpg" alt="Shell脚本介绍（资源）_第48张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/1b11c705ba9449faa1d72f6da1658b8e.jpg"><img src="https://img.it610.com/image/info8/1b11c705ba9449faa1d72f6da1658b8e.jpg" alt="Shell脚本介绍（资源）_第49张图片" /></a></p>

<p><strong>2、彩色等腰三角形</strong></p>

<p><a href="https://img.it610.com/image/info8/2f0e31474a6347f4aed95bee9a79c2e4.jpg"><img src="https://img.it610.com/image/info8/2f0e31474a6347f4aed95bee9a79c2e4.jpg" alt="Shell脚本介绍（资源）_第50张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/a5790235f7874c33a2a7aa7f301c8626.jpg"><img src="https://img.it610.com/image/info8/a5790235f7874c33a2a7aa7f301c8626.jpg" alt="Shell脚本介绍（资源）_第51张图片" /></a></p>

<p><strong>3、国际象棋棋盘</strong></p>

<p><a href="https://img.it610.com/image/info8/eff3eb5453ae4d128adb844ebdbe4f69.jpg"><img src="https://img.it610.com/image/info8/eff3eb5453ae4d128adb844ebdbe4f69.jpg" alt="Shell脚本介绍（资源）_第52张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/4a7fae3ec2a34a3084dab383da05e09e.jpg"><img src="https://img.it610.com/image/info8/4a7fae3ec2a34a3084dab383da05e09e.jpg" alt="Shell脚本介绍（资源）_第53张图片" /></a></p>

<h2 id="常用shell语句"><strong>常用shell语句</strong></h2>

<p><strong>if语句</strong></p>

<p><strong>一、条件测试的表达式：</strong></p>

<p>[ expression ] 括号两端必须要有空格</p>

<p>[[ expression ]] 括号两端必须要有空格</p>

<p>test expression</p>

<p><strong>组合测试条件：</strong></p>

<p>-a: and</p>

<p>-o: or</p>

<p>!: 非</p>

<p><strong>二、整数比较：</strong></p>

<p>-eq 测试两个整数是否相等</p>

<p>-ne 测试两个整数是否不等</p>

<p>-gt 测试一个数是否大于另一个数</p>

<p>-lt 测试一个数是否小于另一个数</p>

<p>-ge 大于或等于</p>

<p>-le 小于或等于</p>

<p><strong>三、命令间的逻辑关系</strong></p>

<p>逻辑与：&amp;&amp;</p>

<p>第一个条件为假 第二个条件不用在判断，最总结果已经有</p>

<p>第一个条件为真，第二个条件必须得判断</p>

<p>逻辑或：||</p>

<p><strong>四、字符串比较</strong></p>

<p>== 等于 两边要有空格</p>

<p>!= 不等</p>

<blockquote>
<p>大于</p>
</blockquote>

<p><strong>五、文件测试</strong></p>

<p>-z string 测试指定字符是否为空，空着真，非空为假</p>

<p>-n string 测试指定字符串是否为不空，空为假 非空为真</p>

<p>-e file 测试文件是否存在</p>

<p>-f file 测试文件是否为普通文件</p>

<p>-d file 测试指定路径是否为目录</p>

<p>-r file 测试文件对当前用户是否可读</p>

<p>-w file 测试文件对当前用户是否可写</p>

<p>-x file 测试文件对当前用户是都可执行</p>

<p>-z 是否为空 为空则为真</p>

<p>-a 是否不空</p>

<p>这里， <strong>如果then不写在if后面，if后面就不用分好了；还有，末尾记得fi结尾呀！</strong></p>

<h2 id="shell实战">SHELL实战</h2>

<ol>
<li>SHELL实战Nginx WEB源码安装</li>
</ol>

<p>#!/bin/bash</p>

<p>#2017年9月6日15:00:17</p>

<p>#auto install nginx web</p>

<p>#by author www.jfedu.net</p>

<p>########################</p>

<p>rm -rf /usr/local/nginx/</p>

<p>wget -c <a href="http://nginx.org/download/nginx-1.12.1.tar.gz">http://nginx.org/download/nginx-1.12.1.tar.gz</a></p>

<p>tar -xzvf nginx-1.12.1.tar.gz</p>

<p>cd nginx-1.12.1/</p>

<p>./configure</p>

<p>make</p>

<p>make install</p>

<p>/usr/local/nginx/sbin/nginx</p>

<p>2、SHELL编程实战Vsftpd虚拟用户</p>

<p>#!/bin/bash</p>

<p>#2017年9月6日15:20:07</p>

<p>#auto config vsftpd user</p>

<p>#by author www.jfedu.net</p>

<p>####################</p>

<p>#Install Vsftpd Soft</p>

<p>yum install vsftpd* -y</p>

<p>#/etc/init.d/vsftp restart</p>

<p>service vsftpd restart</p>

<p>#Config vsftp virtual user</p>

<p>yum install pam libdb-utils libdb &ndash;skip-broken -y</p>

<p>touch /etc/vsftpd/ftpusers.txt</p>

<p>#echo &ldquo;jfedu001</p>

<p>#123456&rdquo;&gt;/etc/vsftpd/ftpusers.txt</p>

<p>cat&gt;&gt;/etc/vsftpd/ftpusers.txt&lt;</p>

<p>jfedu001</p>

<p>123456</p>

<p>EOF</p>

<p>db_load -T -t hash -f /etc/vsftpd/ftpusers.txt /etc/vsftpd/vsftpd_login.db</p>

<p>chmod 700 /etc/vsftpd/vsftpd_login.db</p>

<p>chmod 700 /etc/vsftpd/ftpusers.txt</p>

<p>cat&gt;/etc/pam.d/vsftpd&lt;</p>

<p>auth required pam_userdb.so db=/etc/vsftpd/vsftpd_login</p>

<p>account required pam_userdb.so db=/etc/vsftpd/vsftpd_login</p>

<p>EOF</p>

<p>#Create vsftpd system user</p>

<p>useradd -s /sbin/nologin ftpuser</p>

<p>cat&gt;&gt;/etc/vsftpd/vsftpd.conf&lt;</p>

<p>#config virtual user FTP</p>

<p>pam_service_name=vsftpd</p>

<p>guest_enable=YES</p>

<p>guest_username=ftpuser</p>

<p>user_config_dir=/etc/vsftpd/vsftpd_user_conf</p>

<p>virtual_use_local_privs=YES</p>

<p>EOF</p>

<p>mkdir -p /etc/vsftpd/vsftpd_user_conf/</p>

<p>touch /etc/vsftpd/vsftpd_user_conf/jfedu001</p>

<p>cat&gt;/etc/vsftpd/vsftpd_user_conf/jfedu001 &lt;</p>

<p>local_root=/home/ftpuser/jfedu001</p>

<p>write_enable=YES</p>

<p>anon_world_readable_only=YES</p>

<p>anon_upload_enable=YES</p>

<p>anon_mkdir_write_enable=YES</p>

<p>anon_other_write_enable=YES</p>

<p>EOF</p>

<p>#Create virtual user basedir</p>

<p>mkdir -p /home/ftpuser/jfedu001</p>

<p>chown -R ftpuser:ftpuser /home/ftpuser</p>

<p>service vsftpd restart</p>

<p>service firewalld stop</p>

<p>setenforce 0</p>

<p>#Vsftpd config done.</p>

<p>**注意 ： **</p>

<p>1、脚本里为什么要另外在path 加环境变量</p>

<p>答：在cron里执行时，cron的PATH并不全，所以额外定义一下会更保险</p>

<p>2、 <strong>exec</strong> 这行在这里的 <strong>作用</strong> 是什么</p>

<p>这行用来 <strong>定义输出内容到哪个文件</strong> 。</p>

<p>3、请问:本地保存一周，远程保存一个月是怎么实现的！ 每天凌晨三点执行一次，每次均拷贝远程地址，远程拷贝的前一天数据会被覆盖吗？</p>

<p>答 ：本地一周，就用那个 date +%w 实现，一周不是7天么。 远程一个月，是需要加一个任务计划，find 找一下一个月以前的文件，然后删除掉</p>

<p>4、shell脚本不执行</p>

<p><strong>问题：</strong> 某天研发同事找我说帮他看看他写的shell脚本，死活不执行，报错。我看了下，脚本很简单，也没有常规性的错误，
<strong>报“:badinterpreter:Nosuchfileordirectory”错。</strong><br />
看这错，我就问他是不是在windows下编写的脚本，然后在上传到linux服务器的……果然。<br />
<strong>原因：</strong>
在DOS/windows里，文本文件的换行符为rn，而在*nix系统里则为n，所以DOS/Windows里编辑过的文本文件到了*nix里，每一行都多了个^M。<br />
解决：<br />
1）重新在linux下编写脚本；<br />
2）vi:%s/r//g:%s/^M//g（^M输入用Ctrl+v,Ctrl+m）<br />
附：sh-x脚本文件名，可以单步执行并回显结果，有助于排查复杂脚本问题。</p>

<p>5、 <strong>Shell脚本是什么、它是必需的吗?</strong></p>

<p>答:一个Shell脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell脚本)来完成这些日常工作任务。</p>

<p>6、 <strong>什么是默认登录shell，如何改变指定用户的登录shell</strong></p>

<p>答:在Linux操作系统，“/bin/bash”是默认登录shell，是在创建用户时分配的。使用chsh命令可以改变默认的shell。示例如下所示:</p>

<pre><code># chsh  -s 
# chsh linuxtechi -s /bin/sh
</code></pre>

<p>7、 <strong>可以在shell脚本中使用哪些类型的变量?</strong></p>

<p>答：在shell脚本，我们可以使用两种类型的变量：</p>

<ul>
<li><p><strong>系统定义变量</strong></p></li>

<li><p><strong>用户定义变量</strong></p></li>
</ul>

<p><strong>系统变量</strong> 是由系统系统自己创建的。这些变量通常由大写字母组成，可以 <strong>通过“set”命令查看。</strong></p>

<p><strong>用户变量</strong> 由系统用户来生成和定义，变量的值可以 <strong>通过命令“echo $”查看。</strong></p>

<p>8、 <strong>如何将标准输出和错误输出同时重定向到同一位置?</strong></p>

<p>答：这里有两个方法来实现：</p>

<p>方法一：</p>

<pre><code>2&gt;&amp;1 (如# ls /usr/share/doc &gt; out.txt 2&gt;&amp;1 )
</code></pre>

<p>方法二：</p>

<pre><code>&amp;&gt; (如# ls /usr/share/doc &amp;&gt; out.txt )
</code></pre>

<p>9、 <strong>shell脚本中“if”语法如何嵌套?</strong></p>

<p>答：基础语法如下：</p>

<pre><code>if [ 条件 ]
then
命令1
命令2
…..
else
if [ 条件 ]
then
命令1
命令2
….
else
命令1
命令2
…..
fi
fi
</code></pre>

<p>10、 <strong>shell脚本中“$?”标记的用途是什么？</strong></p>

<p>答：在写一个shell脚本时，如果你想要检查前一命令是否执行成功，在if条件中使 <strong>用“$?”可以来检查前一命令的结束状态</strong> 。简单的例子如下：</p>

<pre><code>root@localhost:~# ls /usr/bin/shar
/usr/bin/shar
root@localhost:~# echo $?
0
</code></pre>

<p>如果结束状态是0，说明前一个命令执行成功。</p>

<pre><code>root@localhost:~# ls /usr/bin/share
ls: cannot access /usr/bin/share: No such file or directory
root@localhost:~# echo $?
2
</code></pre>

<p>如果结束状态不是0，说明命令执行失败。</p>

<p>11、 <strong>在shell脚本中如何比较两个数字 ?</strong></p>

<p>答：在if-then中使用测试命令（ -gt 等）来比较两个数字，例子如下：</p>

<pre><code>#!/bin/bash
x=10
y=20
if [ $x -gt $y ]
then
echo “x is greater than y”
else
echo “y is greater than x”
fi
</code></pre>

<p>12、 <strong>shell脚本中break命令的作用 ?</strong></p>

<p>答：break命令一个简单的用途是退出执行中的循环。我们可以在while和until循环中使用break命令跳出循环。</p>

<p>13、 <strong>shell脚本中continue命令的作用 ?</strong></p>

<p>答：continue命令不同于break命令，它只跳出当前循环的迭代，而不是整个循环。continue命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。</p>

<p>14、 <strong>告诉我shell脚本中Case语句的语法 ?</strong></p>

<p>答：基础语法如下：</p>

<pre><code>case 变量 in
值1)
命令1
命令2
…..
最后命令
!!
值2)
命令1
命令2
……
最后命令
;;
esac
</code></pre>

<p>15、 <strong>shell脚本中while循环语法 ?</strong></p>

<p>答： 如同for循环，while循环只要条件成立就重复它的命令块。不同于for循环，while循环会不断迭代，直到它的条件不为真。基础语法：</p>

<pre><code>while [ 条件 ]
do
命令…
done
</code></pre>

<p>16、 <strong>如何使脚本可执行 ?</strong></p>

<p>答：使用chmod命令来使脚本可执行。例子如下：</p>

<pre><code># chmod a+x myscript.sh
</code></pre>

<p>17、 <strong>“#!/bin/bash”的作用 ?</strong></p>

<p>答：#!/bin/bash是shell脚本的第一行，称为 <strong>释伴（shebang）行</strong> 。这里 <strong>#符号叫做hash，而! 叫做 bang</strong>
。它的意思是命令通过 /bin/bash 来执行。</p>

<p>18、for循环的基础语法：</p>

<pre><code>for 变量 in 循环列表
do
命令1
命令2
….
最后命令
done
</code></pre>

<p>19、 <strong>如何调试shell脚本 ?</strong></p>

<p>答：使用&rsquo;-x&rsquo;参数（sh -x myscript.sh）可以调试shell脚本。另一个种方法是使用‘-nv’参数( sh -nv
myscript.sh)。</p>

<p>20、 <strong>shell脚本如何比较字符串?</strong></p>

<p>答：test命令可以用来比较字符串。测试命令会通过比较字符串中的每一个字符来比较。</p>

<p>21、 <strong>Bourne shell(bash) 中有哪些特殊的变量 ?</strong></p>

<p>答：下面的表列出了Bourne shell为命令行设置的特殊变量。</p>

<pre><code>内建变量    解释
$0    命令行中的脚本名字
$1    第一个命令行参数
$2    第二个命令行参数
…..    …….
$9    第九个命令行参数
$#    命令行参数的数量
$*    所有命令行参数，以空格隔开
</code></pre>

<p>22、 <strong>在shell脚本中，如何测试文件 ?</strong></p>

<p>答：test命令可以用来测试文件。基础用法如下表格：</p>

<pre><code>Test         用法
-d 文件名    如果文件存在并且是目录，返回true
-e 文件名    如果文件存在，返回true
-f 文件名    如果文件存在并且是普通文件，返回true
-r 文件名    如果文件存在并可读，返回true
-s 文件名    如果文件存在并且不为空，返回true
-w 文件名    如果文件存在并可写，返回true
-x 文件名    如果文件存在并可执行，返回true
</code></pre>

<p>23、 <strong>在shell脚本中，如何写入注释 ?</strong></p>

<p>答：注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以#开头。例子如下：</p>

<pre><code>#!/bin/bash
# This is a command
echo “I am logged in as $USER”
</code></pre>

<p>24、 <strong>如何让 shell 就脚本得到来自终端的输入?</strong></p>

<p>答：read命令可以读取来自终端（使用键盘）的数据。read命令得到用户的输入并置于你给出的变量中。例子如下：</p>

<pre><code># vi /tmp/test.sh
#!/bin/bash
echo ‘Please enter your name’
read name
echo “My Name is $name”
# ./test.sh

Please enter your name
LinuxTechi
My Name is LinuxTechi
</code></pre>

<p>25、 <strong>如何取消变量或取消变量赋值 ?</strong></p>

<p>答：“unset”命令用于取消变量或取消变量赋值。语法如下所示：</p>

<pre><code># unset 
</code></pre>

<p>26、 <strong>如何执行算术运算 ?</strong></p>

<p>答：有两种方法来执行算术运算：</p>

<p>1.使用expr命令</p>

<pre><code># expr 5 + 2
</code></pre>

<p>2.用一个美元符号和方括号（$[ 表达式 ]）例如：</p>

<pre><code>test=$[16 + 4] ; test=$[16 + 4]
</code></pre>

<p>27、 <strong>do-while语句的基本格式 ?</strong></p>

<p>答：do-while语句类似于while语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用do-while语句的语法</p>

<pre><code>do
{
命令
} while (条件)
</code></pre>

<p>28、 <strong>在shell脚本如何定义函数呢 ?</strong></p>

<p>答：函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：</p>

<pre><code>$ diskusage () { df -h ; }
译注：下面是我给的shell函数语法，原文没有
[ function ] 函数名 [()]
{
命令;
[return int;]
}
</code></pre>

<p>29、乘法口诀</p>

<h1 id="vi-1-py">vi 1.py</h1>

<p>#!/usr/bin/python</p>

<p>#</p>

<p>for i in xrange(1,10):</p>

<p>for j in xrange(1,i+1):</p>

<p>print &ldquo;$s X %s = %s&rdquo; %(i，j，i*j),</p>

<p>print</p>

<h1 id="python-1-py">python 1.py</h1>

<p>30、系统随机生成一个1-20的随机数</p>

<h1 id="vi-1-py-1">vi 1.py</h1>

<p>#/usr/bin/python<br />
#coding:utf-8<br />
print‘游戏规则：系统随机生成一个1-20的数字，你有6次机会，猜一下吧。’<br />
import random<br />
import sys<br />
snum=random.randint(1,20)<br />
#print snum<br />
num=int(raw_input(&lsquo;请输入一个数字：&rsquo;)）<br />
if num == snum:<br />
print &lsquo;恭喜你，你猜对了。&rsquo;<br />
else：<br />
for i in xrange(1,7):<br />
if num ==snum:<br />
print &lsquo;恭喜你，猜对了。&rsquo;<br />
sys.exit()<br />
elif num &gt; snum:<br />
print &lsquo;猜的数字太大了。&rsquo;<br />
elif num &gt; snum:<br />
print &lsquo;猜的数字太小了。&rsquo;<br />
if i == 6:<br />
print &lsquo;6次机会用完了&rsquo;<br />
sys.exit()<br />
num=int(raw_input(&lsquo;猜错了，再猜一次吧：&rsquo;))</p>

<h1 id="python-1-py-1">python 1.py</h1>

<p><a href="https://img.it610.com/image/info8/090ebcb2c459437fb6fd41b9e6e38e12.jpg"><img src="https://img.it610.com/image/info8/090ebcb2c459437fb6fd41b9e6e38e12.jpg" alt="Shell脚本介绍（资源）_第54张图片" /></a></p>

<p>31、查看磁盘空间大小</p>

<p>#!/usr/bin/python</p>

<p>#coding:utf-8</p>

<p>with open(&lsquo;/proc/meminfo&rsquo;) as fd:</p>

<p>for line in fd:</p>

<p>if line.startswith(&lsquo;MemTotal&rsquo;):</p>

<p>total=linesplit()[1]</p>

<p>contine</p>

<p>if line.startswith(&lsquo;MemFree&rsquo;):</p>

<p>total=linesplit()[1]</p>

<p>break</p>

<p>#print total.free</p>

<p>print &ldquo;总内存数&rdquo;+&ldquo;%.2f&rdquo; %(int(total)/1024.0)+&lsquo;M内存&rsquo;</p>

<p>print &ldquo;剩余&rdquo;+&ldquo;%.2f&rdquo; %(int(total)/1024.0)+&lsquo;M内存&rsquo;</p>

<p>memused=int(total)-int(free)</p>

<p>print &ldquo;使用&rdquo;+&ldquo;%.2f&rdquo; %(int(memused)/1024.0)+&lsquo;M内存&rsquo;</p>

<p>print &ldquo;占用&rdquo;+&ldquo;%.2f&rdquo; %(int(memused)/1.0/int(total))+&lsquo;%&rsquo;</p>

<p>#python men.py</p>

<p><a href="https://img.it610.com/image/info8/d5ae26e4019f4db491a75257bb2788f3.jpg"><img src="https://img.it610.com/image/info8/d5ae26e4019f4db491a75257bb2788f3.jpg" alt="Shell脚本介绍（资源）_第55张图片" /></a></p>

<p>32什么时候不使用shell脚本</p>

<p>答 ： 需要大规模的文件操作</p>

<p>需要多维数组的支持</p>

<p>需要直接操作系统硬件</p>

<p>33、test 与[ ]等价</p>

<p>如果flie文件存在，则输出true，否则（||）输出false。</p>

<p><a href="https://img.it610.com/image/info8/7d4087d59ae54ea1a025f61f09cd01b2.jpg"><img src="https://img.it610.com/image/info8/7d4087d59ae54ea1a025f61f09cd01b2.jpg" alt="Shell脚本介绍（资源）_第56张图片" /></a></p>

<p>-f #文件 <strong>存在且为普通文件</strong> 则表达式成立</p>

<p>-z #如果 <strong>测试字符串的长度为0</strong> ，则表达式成立</p>

<p>&amp;&amp;、||、&gt;、</p>

<p>例：使用read传入数字等于1，就打印1。如果等于2，就打印2。如果不等于1也不等于2，就提示错误。</p>

<p><a href="https://img.it610.com/image/info8/ec6c92cc8e8441af8db8ff2e462412e9.jpg"><img src="https://img.it610.com/image/info8/ec6c92cc8e8441af8db8ff2e462412e9.jpg" alt="Shell脚本介绍（资源）_第57张图片" /></a></p>

<p>34、使用read读入方式比较两个整数的大小。</p>

<p><a href="https://img.it610.com/image/info8/3e38a062d2e545c9be1a3f11715601ff.png"><img src="https://img.it610.com/image/info8/3e38a062d2e545c9be1a3f11715601ff.png" alt="Shell脚本介绍（资源）_第58张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/21c44480cfaf4cb289cacfc2abe85c64.jpg"><img src="https://img.it610.com/image/info8/21c44480cfaf4cb289cacfc2abe85c64.jpg" alt="Shell脚本介绍（资源）_第59张图片" /></a></p>

<p><a href="https://img.it610.com/image/info8/1f01cb115ccb49f2afa730b952f1a6c6.png"><img src="https://img.it610.com/image/info8/1f01cb115ccb49f2afa730b952f1a6c6.png" alt="Shell脚本介绍（资源）_第60张图片" /></a></p>

<p>35、 <strong>打印选择菜单</strong> ，按照选择项一键 <strong>安装不同的WEB服务。</strong></p>

<p>代码：</p>

<p>#!/bin/sh</p>

<p>cat &lt;</p>

<p>1.[install lamp]</p>

<p>2.[install lnmp]</p>

<p>3.[exit]</p>

<p>please input the num:</p>

<p>EOF</p>

<p>sh_path=/server/scripts</p>

<p>[ ! -d ${sh_path} ] &amp;&amp; {</p>

<p>mkdir -p ${sh_path}</p>

<p>}</p>

<p>read num</p>

<p>expr ${num} + 1 &amp;&gt;/dev/null;</p>

<p>[ $? -ne 0 ] &amp;&amp; {</p>

<p>echo &ldquo;please input the num is {1|2|3}!&rdquo;;</p>

<p>exit 0;</p>

<p>}</p>

<p>[[ ! ${num} = [1-3] ]] &amp;&amp; {</p>

<p>echo &ldquo;please input the num is {1|2|3}!&rdquo;;</p>

<p>exit 1;</p>

<p>}</p>

<p>[ ${num} -eq 1 ] &amp;&amp; {</p>

<p>echo &ldquo;start installing lamp:&ldquo;;</p>

<p>[ -x ${sh_path}/lamp.sh ] || {</p>

<p>echo &ldquo;${sh_path}/lamp.sh does not exist or can&rsquo;t be exe.&ldquo;;</p>

<p>exit 2;</p>

<p>}</p>

<p>${sh_path}/lamp.sh;</p>

<p>exit $?;</p>

<p>}</p>

<p>[ ${num} -eq 2 ] &amp;&amp; {</p>

<p>echo &ldquo;start installing lnmp:&ldquo;;</p>

<p>[ -x ${sh_path}/lnmp.sh ] || {</p>

<p>echo &ldquo;${sh_path}/lnmp.sh does&rsquo;t exist or can&rsquo;t be exec.&ldquo;;</p>

<p>exit 3;</p>

<p>}</p>

<p>${sh_path}/lnmp.sh;</p>

<p>exit $?;</p>

<p>}</p>

<p>[ ${num} -eq 3 ] &amp;&amp; {</p>

<p>echo &ldquo;exit&rdquo;</p>

<p>exit 4;</p>

<p>}</p>

<p>执行结果：</p>

<p>36、编写shell脚本，批量生成30个密码</p>

<p>vi mkpasswd.sh</p>

<p>#!/bin/bash</p>

<p>i=1</p>

<p>echo &ldquo;########kim by 51cto.com##########&rdquo; &gt;/tmp/passwd.txt</p>

<p>while [ $i -le 30 ];do</p>

<p>/usr/bin/mkpasswd -l 14 -s 2 -c 3 -C 3 -d 4 &gt;&gt;/tmp/passwd.txt</p>

<p>let i+=1</p>

<p>done</p>

<p>exit;</p>

<p>mkpasswd参数详解</p>

<p>-l # (length of password, default = 7)</p>

<p>指定密码的长度，默认是7位数</p>

<p>-d # (min # of digits, default = 2)</p>

<p>指定密码中数字最少位数，默认是2位</p>

<p>-c # (min # of lowercase chars, default = 2)</p>

<p>指定密码中小写字母最少位数，默认是2位</p>

<p>-C # (min # of uppercase chars, default = 2)</p>

<p>指定密码中大写字母最少位数，默认是2位</p>

<p>-s # (min # of special chars, default = 1)</p>

<p>指定密码中特殊字符最少位数，默认是1位</p>

<p>37、 <strong>写一个shell脚本来 得到当前的日期，时间，用户名和当前工作目录。</strong></p>

<p>#!/bin/bash<br />
echo &ldquo;Hello, $LOGNAME&rdquo;<br />
echo &ldquo;Current date is <code>date</code>&rdquo;<br />
echo &ldquo;User is <code>who i am</code>&rdquo;<br />
echo &ldquo;Current directory <code>pwd</code>&ldquo;</p>

<h1 id="chmod-755-21-sh">chmod 755 21.sh</h1>

<h1 id="21-sh">./21.sh</h1>

<p><a href="https://img.it610.com/image/info8/53d61936f99a421da355a8cb1195d6cc.png"><img src="https://img.it610.com/image/info8/53d61936f99a421da355a8cb1195d6cc.png" alt="Shell脚本介绍（资源）_第61张图片" /></a></p>

<p>38、比较数字大小</p>

<p>#!/bin/bash<br />
test $1 -gt $2 &amp;&amp; echo $1<br />
test $1 -lt $2 &amp;&amp; echo $2<br />
test $1 -eq $2 &amp;&amp; echo $1=$2</p>

<p><a href="https://img.it610.com/image/info8/3356cc1806a64cca81611e5dc4f4c77e.png"><img src="https://img.it610.com/image/info8/3356cc1806a64cca81611e5dc4f4c77e.png" alt="Shell脚本介绍（资源）_第62张图片" /></a></p>

<p>39、</p>

<p>40、</p>

<p>参考链接 ：</p>

<p><a href="http://www.cnblogs.com/along21/p/7519710.html">http://www.cnblogs.com/along21/p/7519710.html</a></p>

<p>五分钟搞定Bash功能与使用技巧 ： <a href="https://mp.weixin.qq.com/s/qxyV0Ye9yIqkUA7V8Kx0wQ">https://mp.weixin.qq.com/s/qxyV0Ye9yIqkUA7V8Kx0wQ</a></p>

<p>17个案例带你3分钟搞定Linux正则表达式<a href="https://mp.weixin.qq.com/s/bAc-coGwnKxvQHOkqZRJAQ">https://mp.weixin.qq.com/s/bAc-coGwnKxvQHOkqZRJAQ</a></p>

<p><strong>Shell编程：shell脚本的条件测试</strong> :
<a href="https://mp.weixin.qq.com/s?__biz=MzU4MjUzNDMyOQ==&amp;mid=2247483848&amp;idx=1&amp;sn=2d3165fefd1573e3f46b7133bc786982&amp;chksm=fdb7941ecac01d0841a39cac28392a613d466ba88b4d7168583d5dedfddc845e4fb0254833a4&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU4MjUzNDMyOQ==&amp;mid=2247483848&amp;idx=1&amp;sn=2d3165fefd1573e3f46b7133bc786982&amp;chksm=fdb7941ecac01d0841a39cac28392a613d466ba88b4d7168583d5dedfddc845e4fb0254833a4&amp;scene=21#wechat_redirect</a></p>

<p>资料：</p>

<h1 id="shell脚本常用知识-http-ju-outofmemory-cn-entry-225010">shell脚本常用知识 ： <a href="http://ju.outofmemory.cn/entry/225010">http://ju.outofmemory.cn/entry/225010</a></h1>

<h1 id="如何让执行到中途中断的程序继续自动执行-http-www-voidcn-com-code-p-noktlbvp-p-html">如何让执行到中途中断的程序继续自动执行? : <a href="http://www.voidcn.com/code/p-noktlbvp-p.html">http://www.voidcn.com/code/p-noktlbvp-p.html</a></h1>

<h1 id="重启tomcat的shell脚本-http-www-voidcn-com-code-p-gejgbzas-h-html">重启Tomcat的shell脚本 : <a href="http://www.voidcn.com/code/p-gejgbzas-h.html">http://www.voidcn.com/code/p-gejgbzas-h.html</a></h1>

<h2 id="shell产生随机数七种方法-http-blog-sina-com-cn-s-blog-638b7ebb0102vurp-html">shell产生随机数七种方法 ： <a href="http://blog.sina.com.cn/s/blog_638b7ebb0102vurp.html">http://blog.sina.com.cn/s/blog_638b7ebb0102vurp.html</a></h2>

<h1 id="linux-网卡流量监控-脚本-http-www-voidcn-com-code-p-glpuwwga-p-html">linux 网卡流量监控 (脚本) : <a href="http://www.voidcn.com/code/p-glpuwwga-p.html">http://www.voidcn.com/code/p-glpuwwga-p.html</a></h1>

<p>Shell 入门指南 : <a href="https://wdxtub.com/2016/08/02/shell-guide/">https://wdxtub.com/2016/08/02/shell-guide/</a></p>

<p>《shell脚本系统监控&mdash;&mdash;-邮件告警》 : <a href="http://blog.51cto.com/leoheng/1955773">http://blog.51cto.com/leoheng/1955773</a></p>

<h1 id="编写了一个ssh管理并自动登录shell脚本-https-www-jianshu-com-p-789287ba0e6b">编写了一个ssh管理并自动登录shell脚本 : <a href="https://www.jianshu.com/p/789287ba0e6b">https://www.jianshu.com/p/789287ba0e6b</a></h1>

<p>shell脚本加密 | shc : <a href="https://www.jianshu.com/p/7f3db04c0786">https://www.jianshu.com/p/7f3db04c0786</a></p>

<p>shell脚本进阶 详解及其实例（一） : <a href="https://www.cnblogs.com/keerya/p/7530802.html">https://www.cnblogs.com/keerya/p/7530802.html</a></p>

<p><strong>Shell编程：shell脚本的条件测试</strong> :
<a href="https://mp.weixin.qq.com/s?__biz=MzU4MjUzNDMyOQ==&amp;mid=2247483892&amp;idx=1&amp;sn=8490118c4babd6ff9582d80507ecee14&amp;chksm=fdb79422cac01d34ac60c528dd8acd538242d857b9b51a6fea177cb402d7ed9c0f51d7a8648f&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU4MjUzNDMyOQ==&amp;mid=2247483892&amp;idx=1&amp;sn=8490118c4babd6ff9582d80507ecee14&amp;chksm=fdb79422cac01d34ac60c528dd8acd538242d857b9b51a6fea177cb402d7ed9c0f51d7a8648f&amp;scene=21#wechat_redirect</a></p>

<p>If条件语句-监测系统内存报警 :
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjUzNDMyOQ==&amp;mid=2247483877&amp;idx=1&amp;sn=87eb31b447ce9c995e5e8861d9b9dfc8&amp;chksm=fdb79433cac01d252b39e7c5447a999674b988b1d5b8706b3cfde8ddb38665688a84111a8b71&amp;scene=21#wechat_redirect">http://mp.weixin.qq.com/s?__biz=MzU4MjUzNDMyOQ==&amp;mid=2247483877&amp;idx=1&amp;sn=87eb31b447ce9c995e5e8861d9b9dfc8&amp;chksm=fdb79433cac01d252b39e7c5447a999674b988b1d5b8706b3cfde8ddb38665688a84111a8b71&amp;scene=21#wechat_redirect</a></p>

<p>Shell学习&mdash;Shell脚本的静态检查工具shellcheck :
<a href="https://www.cnblogs.com/ftl1012/p/9568635.html">https://www.cnblogs.com/ftl1012/p/9568635.html</a></p>

<p>Linux 下Shell的学习之优秀博主推荐 : <a href="https://www.cnblogs.com/ftl1012/p/9567984.html">https://www.cnblogs.com/ftl1012/p/9567984.html</a></p>

<p>Linux 下Shell的学习3-优秀demo : <a href="https://www.cnblogs.com/ftl1012/p/9314069.html">https://www.cnblogs.com/ftl1012/p/9314069.html</a></p>

<p>Linux 下shell中exec解析 : <a href="https://www.cnblogs.com/ftl1012/p/9310536.html">https://www.cnblogs.com/ftl1012/p/9310536.html</a></p>

<p>Linux 下Shell的学习2 : <a href="https://www.cnblogs.com/ftl1012/p/9310505.html">https://www.cnblogs.com/ftl1012/p/9310505.html</a></p>

<p>Linux 下Shell的学习 : <a href="https://www.cnblogs.com/ftl1012/p/shell.html">https://www.cnblogs.com/ftl1012/p/shell.html</a></p>

<p>shell脚本_查看网段中的存活主机和MAC地址 : <a href="http://blog.51cto.com/11638832/1855990">http://blog.51cto.com/11638832/1855990</a></p>

<p>shell脚本_while、if脚本语句_价格竞猜 : <a href="http://blog.51cto.com/11638832/1855989">http://blog.51cto.com/11638832/1855989</a></p>

<p>根据字段状态删除指定目录文件的shell脚本 荐 : <a href="http://blog.51cto.com/liangey/1641878">http://blog.51cto.com/liangey/1641878</a></p>

<p>SHELL网络爬虫实例剖析 荐 :: <a href="http://blog.51cto.com/nolinux/1552472">http://blog.51cto.com/nolinux/1552472</a></p>

<p>如何用SHELL写好网络爬虫 荐 : <a href="http://blog.51cto.com/nolinux/1550976">http://blog.51cto.com/nolinux/1550976</a></p>

<p>SHELL（20篇） ： <a href="https://blog.csdn.net/stpeace/article/category/6952361">https://blog.csdn.net/stpeace/article/category/6952361</a></p>

<p>Shell中的循环语句for、while、until实例讲解 : <a href="https://www.jb51.net/article/50643.htm">https://www.jb51.net/article/50643.htm</a></p>

<p>笔记 | 史上最全的正则表达式 : <a href="https://mp.weixin.qq.com/s/SA3OnfZD-cFVi7IVfKwKnw">https://mp.weixin.qq.com/s/SA3OnfZD-cFVi7IVfKwKnw</a></p>

<p><strong>shell去掉文件中空行(空白行)的方法详解</strong> : <a href="https://www.jb51.net/article/42288.htm">https://www.jb51.net/article/42288.htm</a></p>

<p>转载于:<a href="https://my.oschina.net/u/3803405/blog/1816950">https://my.oschina.net/u/3803405/blog/1816950</a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1-9">1-9 <a class="footnote-return" href="#fnref:1-9"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>