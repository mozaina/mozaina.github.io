<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>linux命令行与shell脚本 | 开发者问答集锦</title>
    <meta property="og:title" content="linux命令行与shell脚本 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="linux命令行与shell脚本">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">linux命令行与shell脚本</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="一-显示信息echo"><strong>一、显示信息echo</strong></h2>

<h3 id="1-不带回车打印-echo-n"><strong>1.不带回车打印 echo -n</strong></h3>

<p>simpim@DESKTOP-1ATCJJG ~<br />
$ cat 1.sh<br />
#!/bin/bash<br />
echo -n &ldquo;this a no1&rdquo;<br />
echo &ldquo;second line&rdquo;<br />
simpim@DESKTOP-1ATCJJG ~<br />
$ sh 1.sh</p>

<p>this a no1second line</p>

<h3 id="2-特殊字符打印-使用-转义字符"><strong>2.特殊字符打印，使用\转义字符</strong></h3>

<p>echo &ldquo;The cost of the item is \$15&rdquo;</p>

<p>二、使用变量</p>

<p>1.set 命令查看当前环境变量</p>

<p>$ set<br />
&hellip;<br />
BASH=/bin/bash<br />
HOME=/home/simpim<br />
HOMEPATH=&rsquo;\Users\simpim&rsquo;<br />
HOSTTYPE=x86_64</p>

<p>IFS=$&rsquo; \t\n&rsquo;</p>

<p>&hellip;</p>

<h2 id="二-打印变量">二.打印变量</h2>

<p>$ echo $HOME</p>

<p>/home/simpim</p>

<p>echo ${HOME}</p>

<h3 id="2-用户变量">2.用户变量</h3>

<p>1）.基本赋值</p>

<p>var1=10</p>

<p>echo &ldquo;var1=$var1&rdquo;</p>

<p>2）命令输出赋值</p>

<p>test=<code>date</code> 或者 test=$(date),其中date为命令</p>

<p>simpim@DESKTOP-1ATCJJG ~<br />
$ test=$(date +%y%m%d)<br />
simpim@DESKTOP-1ATCJJG ~<br />
$ echo $test<br />
180627</p>

<h2 id="三-管道">三、管道 |</h2>

<p>管道被放在命令之间，将一个命令的输出重定向到另一个命令中</p>

<p>comdand1 | comdand2 | command3&hellip;.</p>

<p>simpim@DESKTOP-1ATCJJG ~<br />
$ cat sort.txt<br />
aaa:10:1.1<br />
ccc:30:3.3<br />
ddd:40:4.4<br />
bbb:20:2.2<br />
eee:50:5.5<br />
eee:50:5.5<br />
simpim@DESKTOP-1ATCJJG ~<br />
$ cat sort.txt | sort<br />
aaa:10:1.1<br />
bbb:20:2.2<br />
ccc:30:3.3<br />
ddd:40:4.4<br />
eee:50:5.5</p>

<p>eee:50:5.5</p>

<h2 id="四-数学运算">四、数学运算</h2>

<h3 id="1-expr">1.expr</h3>

<p>$ expr 5 \* 2</p>

<p>10</p>

<p>2.方括号 $[ operation ]</p>

<p>$ echo $[5 * 2]</p>

<p>bash shell 数学运算只支持整数运算</p>

<p>$ echo $[ 45 / 10 ]<br />
4<br />
simpim@DESKTOP-1ATCJJG ~<br />
$ expr 45 / 10<br />
4</p>

<h3 id="2-浮点运算-bc">2.浮点运算 bc</h3>

<p>1)scale只对除法、取余、乘幂有效，乘法无效</p>

<p>$ echo &ldquo;scale=4;4.<sup>44444444</sup>&frasl;<sub>2</sub>&rdquo; | bc</p>

<p>2.2222</p>

<p><strong>2）bc 多个表达式计算</strong></p>

<p>variable=$(bc &lt;&lt; EOF</p>

<p>options</p>

<p>statements</p>

<p>expressions</p>

<p>EOF</p>

<p>)</p>

<pre><code>#!/bin/bash
var1=10.46
var2=43.67
var3=33.2
var4=71
var5=$(bc &lt;&lt; EOF
scale=4
a1=($var1 * $var2)
b1 =($var3 *$var4)
a1+b1
EOF
)
echo the final answer for this mess is $var5var5=$(bc &lt;&lt; EOF
scale=4
a1=($var1 * $var2)
b1 =($var3 *$var4)
a1+b1
EOF
)
echo the final answer for this mess is $var5
</code></pre>

<h2 id="五-退出脚本">五、退出脚本</h2>

<h3 id="1-查看命令执行的退出状态码">1、查看命令执行的退出状态码</h3>

<p>1) date;echo $?</p>

<p>0</p>

<p>成功结束的命令的退出状态码是0</p>

<p>$ abc || echo $?<br />
-bash: abc: 未找到命令<br />
127</p>

<h3 id="2-exit命令指定脚本结束后返回指定的状态码">2）exit命令指定脚本结束后返回指定的状态码</h3>

<p>exit 5</p>

<h2 id="六-结构化命令">六、结构化命令</h2>

<p>以下转载 <a href="https://blog.csdn.net/u011436666/article/details/73480207">https://blog.csdn.net/u011436666/article/details/73480207</a></p>

<h3 id="1-if-then语句">1、if-then语句</h3>

<p>if-then语句格式如下：</p>

<pre><code>if command
then    
    commands
fi


或者if command;then   commandsfi
</code></pre>

<ul>
<li></li>
</ul>

<p>在bash shell中if后面的是一个命令，如果该命令的退出状态码是0（说明该命令执行成功），那么位于then后面的命令才会被执行。 <strong>注意，</strong>
这和其他编程语言的if语句返回true或false不一样。只要关注了这个，这个语句使用起来很容易：</p>

<p><a href="https://img.it610.com/image/info8/ed082cbacbc74d84897ea26e6d751659.jpg"><img src="https://img.it610.com/image/info8/ed082cbacbc74d84897ea26e6d751659.jpg" alt="【linux
命令行与shell脚本】_第1张图片" /></a></p>

<h3 id="2-if-then-else语句">2、if-then-else语句</h3>

<p>在if-then语句中不管命令是否执行成功，你都只有一种选择：成功则执行then中的命令；命令失败则继续往下执行。有的情况下，我们需要使用if-then-
else语句：</p>

<pre><code>if command
then 
    commands
else
    commands
fi
</code></pre>

<p>这个语句的使用也很直观，请看以下示例：</p>

<p><a href="https://img.it610.com/image/info8/fdc8e4c208a1424eb8b72b81351fb910.jpg"><img src="https://img.it610.com/image/info8/fdc8e4c208a1424eb8b72b81351fb910.jpg" alt="【linux
命令行与shell脚本】_第2张图片" /></a></p>

<h3 id="3-嵌套if">3、嵌套if</h3>

<p>如果使用上面的语句仍然不能很多好的满足要求，那我们可以使用嵌套if来工作：</p>

<pre><code>if command1
then 
    commands
elif command2
thenelif command3thenelif command4then
    more commands
fi
</code></pre>

<p>其实这里只是将else里面又嵌入了一个if-then语句，只是将else-
if连起来写成了elif；我们可以随意组合嵌套，完成更复杂的逻辑。这里就不做示例了，很简单，并且后面经常会用到。</p>

<h3 id="4-test命令">4、test命令</h3>

<p>到目前为止，在if中用到的命令都是普通的shell命令，那么if后面是否可以测试出退出状态码以外的条件呢？
是不能的，但是我们可以用test命令来测试其他条件，只要test命令中列出的条件成立，test命令就会退出并返回退出状态码0，这样就可以完成类似于其他语言中那样的if-
then语句了。<br />
<strong>test命令</strong> 的格式非常简单：<code>test
condition</code>，condition是命令要测试的一系列参数和值相当于我们用test命令代替了之前的command命令。</p>

<p><a href="https://img.it610.com/image/info8/018b5b02256c46d989707d145d15728b.jpg"><img src="https://img.it610.com/image/info8/018b5b02256c46d989707d145d15728b.jpg" alt="【linux
命令行与shell脚本】_第3张图片" /></a></p>

<p>如上图所示，我们在test命令里面测试一个存在的变量，会返回0，使得then中的语句会执行；相反则返回的退出状态码不为0。</p>

<p>test命令还有另一种常用的简便写法： <strong>单方括号</strong> <code>[ condition ]</code>，注意方括号距字符串必须加上一个空格。</p>

<p>var1=10.46<br />
if [ $var1 &gt; 1 ]<br />
then<br />
echo OK<br />
else<br />
echo $?<br />
echo fail<br />
fi</p>

<p>test命令可以用来判断三类条件：</p>

<ol>
<li>数值比较</li>
<li>字符串比较</li>
<li>文件比较</li>
</ol>

<p>下面我们来学习这几种条件测试的使用方法，后面也会经常用到这些。</p>

<h3 id="1-数值比较"><strong>1、数值比较：</strong></h3>

<p>数值比较功能如下表，可以用在数字和变量上。</p>

<table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>n1 -eq n2</td>
<td>检查n1与n2是否相等（equal）</td>
</tr>

<tr>
<td>n1 -ge n2</td>
<td>检查n1是否大于或等于n2（greater、equal）</td>
</tr>

<tr>
<td>n1 -gt n2</td>
<td>检查n1是否大于n2（greater than）</td>
</tr>

<tr>
<td>n1 -le n2</td>
<td>检查n1是否小于或等于n2（less、equal）</td>
</tr>

<tr>
<td>n1 -lt n2</td>
<td>检查n1小于n2（less than）</td>
</tr>

<tr>
<td>n1 -ne n2</td>
<td>检查n1与n2是否不相等（not equal）</td>
</tr>
</tbody>
</table>

<p>~<br />
需要记住， <strong>bash shell只能处理整数</strong> 。</p>

<h3 id="2-字符串比较"><strong>2、字符串比较：</strong></h3>

<table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>str1 = str2</td>
<td>检查str1和str2是否相同</td>
</tr>

<tr>
<td>str1 != str2</td>
<td>检查str1和str2是不同</td>
</tr>

<tr>
<td>str1 &lt; str2</td>
<td>检查str1是否小于str2</td>
</tr>

<tr>
<td>str1 &gt; str2</td>
<td>检查str1是否大于str2</td>
</tr>

<tr>
<td>-n str</td>
<td>检查str的长度是否非0</td>
</tr>

<tr>
<td>-z str</td>
<td>检查str长度是否为0</td>
</tr>
</tbody>
</table>

<p>~<br />
这里需要注意两个问题：</p>

<ol>
<li>大于号和小于号必须转移，否则shell会把它们当做重定向符号，把字符串当做文件名</li>
<li>大于小于的排序是按照ASCII码的顺序（即由小到大为0~9，A~Z，a~z）</li>
</ol>

<p>我们编辑如下的脚本，用来检测变量是否长度为0。</p>

<pre><code>#!/bin/bash

value1=testing
value2=&quot;&quot;

if  [ -n $value1 ]
then
    echo &quot;Then string $value1 not empty&quot;
else
   echo &quot;The string $value1 is empty&quot;
fi

if [ -z $value2 ]
then 
    echo &quot;The string $value2 is empty&quot;
else
   echo &quot;The string $value2 is not empty&quot;
fi

if [ -z $value3 ] 
then 
    echo &quot;The string $value3 is empty&quot;
else
   echo &quot;The string $value3 is not empty&quot;
fi
</code></pre>

<p>执行输出后，我们发现：定义了数值的变量长度不为0；而定义为空和 <strong>未定义的变量</strong> 其长度均为0。</p>

<pre><code>Then string testing not empty
The string  is empty
The string  is empty
</code></pre>

<ul>
<li></li>
</ul>

<blockquote>
<p>空的和为初始化的变量会对我们的脚本造成很大的影响。如果不确定其值的内容，在使用之前，最好可以用-n或-z测试一下是否含有值。</p>
</blockquote>

<h3 id="3-文件比较"><strong>3、文件比较：</strong></h3>

<p>文件比较是shell编程中很强大也最常用的比较形式，它允许你测试Linux文件系统上的文件和目录的状态。比较形式如下表：</p>

<table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-d file</td>
<td>file是否存在并是一个目录</td>
</tr>

<tr>
<td>-f file</td>
<td>file是否存在并是一个文件</td>
</tr>

<tr>
<td>-e file</td>
<td>file是否存在</td>
</tr>

<tr>
<td>-r file</td>
<td>file是否存在并且可读</td>
</tr>

<tr>
<td>-w file</td>
<td>file是否存在并且可写</td>
</tr>

<tr>
<td>-s file</td>
<td>file是否存在并且非空</td>
</tr>

<tr>
<td>-x file</td>
<td>file是否存在并且可执行</td>
</tr>

<tr>
<td>-O file</td>
<td>file是否存在并且属当前用户所有</td>
</tr>

<tr>
<td>-G file</td>
<td>file是否存在并且默认组和当前用户相同</td>
</tr>

<tr>
<td>file1 -nt file2</td>
<td>file1是否比file2新（new than）</td>
</tr>

<tr>
<td>file1 -ot file2</td>
<td>file1是否比file2旧（old than）</td>
</tr>
</tbody>
</table>

<p>~<br />
这些条件使用起来也是比较简单的，我们应当先搞清楚逻辑再去做一系列的测试。</p>

<p><a href="https://img.it610.com/image/info8/a8189e10e188494db242cc358ab24c27.jpg"><img src="https://img.it610.com/image/info8/a8189e10e188494db242cc358ab24c27.jpg" alt="【linux
命令行与shell脚本】_第4张图片" /></a></p>

<p>如上所示，这里我们直接比较了两个文件的新旧，然而我们并没有确认这连个文件是否存在，如果没有存在的话，就可能得到一个错误的结果。我们可以使用布尔运算符来组合测试：</p>

<pre><code>#复合条件测试
[ condition1 ] &amp;&amp; [ condition2 ] 
[ condition1 ] || [ condition2 ]
</code></pre>

<ul>
<li></li>
</ul>

<p><a href="https://img.it610.com/image/info8/9c785d6b6df44151b5ab7d40bb3a4b8b.jpg"><img src="https://img.it610.com/image/info8/9c785d6b6df44151b5ab7d40bb3a4b8b.jpg" alt="【linux
命令行与shell脚本】_第5张图片" /></a></p>

<h3 id="4-使用双小括号和双方括号">4、使用双小括号和双方括号</h3>

<p><strong>双小括号：</strong><br />
使用双小括号来使用高级数学表达式，提供了很多其他编程语言类似的运算符。格式如下：</p>

<pre><code>(( expression ))
</code></pre>

<p>1、在双括号结构中，所有表达式可以像C语言一样，如：a++,b&ndash;等。</p>

<p>2、在双括号结构中，所有变量可以不加入：“$”符号前缀。</p>

<p>3、双括号可以进行逻辑运算，四则运算</p>

<p>4、双括号结构 扩展了for，while,if条件测试运算</p>

<p>5、支持多个表达式运算，各个表达式之间用“，”分开</p>

<pre><code>#!/bin/sh

num=100;
total=0;

for((i=0;i&lt;=num;i++));
do
    ((total+=i));
done
echo $total;

total=0;
i=0;
while((i&lt;=num));
do
    ((total+=i,i++));
done
echo $total;

if((total&gt;=5050));then
    echo &quot;ok&quot;;
fi
</code></pre>

<ul>
<li></li>
</ul>

<p>能够用在这里的表达式很多，比如：i++、i–、++i、–i之类的；逻辑求反！；一些布尔运算和位运算等等。在其他编程语言中可以用于的数学赋值或比较表达式等都可以用。</p>

<p><strong>双方括号：</strong><br />
双方括号命令提供了针对字符串比较的高级特性。双方括号里面的表达式使用了test命令中采用的标准字符串比较。并且提供了 <strong>模式匹配</strong>
这个强大的特性。格式如下：</p>

<pre><code>[[ expression ]]
</code></pre>

<p><a href="https://img.it610.com/image/info8/e193b648c9064f52b058ca4ad08e82e1.jpg"><img src="https://img.it610.com/image/info8/e193b648c9064f52b058ca4ad08e82e1.jpg" alt="【linux
命令行与shell脚本】_第6张图片" /></a></p>

<p>我们再来总结一下几种括号的使用：</p>

<blockquote>
<p>方括号[ ]：类似于test命令，用判断三类条件：数值、字符串、文件<br />
 双小括号(( ))：在比较中使用高级数学表达式<br />
 双方括号[[ ]]：字符串比较的升级-模式匹配（并不是所有shell都支持？）</p>
</blockquote>

<h3 id="6-case命令-简化if-then-else">6、case命令-简化if-then-else</h3>

<p>当我们尝试在一组可能的值中寻找特定值，再来进行其他操作时。可能需要写下很长的if-then-
else语句，这时可以使用case语句来简化脚本，case命令的格式如下：</p>

<pre><code>#可以通过或操作符|在一行中使用多个pattern
case variable in
pattern1) command1;;
pattern2|pattern3) command2;;
*) default commands;;
esac
</code></pre>

<p><a href="https://img.it610.com/image/info8/74be1d91ad6c49bd9524356c5852e777.jpg"><img src="https://img.it610.com/image/info8/74be1d91ad6c49bd9524356c5852e777.jpg" alt="【linux
命令行与shell脚本】_第7张图片" /></a></p>

<p>上面这个简单的示例演示了获取当前目录并使用case来判断在哪个目录里面。不难发现使用case的场景还是比较多的。</p>

<p>以下转载来至<a href="https://blog.csdn.net/u011436666/article/details/73498354">https://blog.csdn.net/u011436666/article/details/73498354</a></p>

<h2 id="七-for命令">七、for命令</h2>

<p>下面是bash shell中for命令的基本格式:</p>

<pre><code>for var in list
do 
    commands
done
</code></pre>

<p>在每次迭代过程中，变量var会包含列表中的当前值，$var变量包含着这次迭代对应的当前列表项中的值。可以通过以下几种方式来指定列表：</p>

<p><strong>读取列表中的值：</strong><br />
最简单的用法就是，直接指定一系列值，如下：</p>

<p><a href="https://img.it610.com/image/info8/6907a7bc998648c6991e9ebfa251cebf.jpg"><img src="https://img.it610.com/image/info8/6907a7bc998648c6991e9ebfa251cebf.jpg" alt="【linux
命令行与shell脚本】_第8张图片" /></a><br />
~</p>

<p><strong>读取列表中的复杂值：</strong><br />
我们先看以下，运行下面的脚本会输出什么：</p>

<pre><code>#!/bin/bash

for test in I'm very happy today's night
do
    echo &quot;The next string is $test&quot;
done
</code></pre>

<p>可以发现，它将单引号中的字符串设别成了一个字符，所以没有达到我们想要的效果。</p>

<p><a href="https://img.it610.com/image/info8/71e5cf20dd7440c096c3a63d4c5e4b2a.jpg"><img src="https://img.it610.com/image/info8/71e5cf20dd7440c096c3a63d4c5e4b2a.jpg" alt="【linux
命令行与shell脚本】_第9张图片" /></a></p>

<p>有两种方法可以解决这个问题：</p>

<ul>
<li>使用转义字符<br /></li>
<li>用双引号“ ”来定义用到的值</li>
</ul>

<blockquote>
<p>for循环默认认为每个值都是由空格分割的。</p>
</blockquote>

<p><strong>从变量读取值：</strong><br />
使用起来也是很简单的，只是先定义了一个变量，如下所示：</p>

<p><a href="https://img.it610.com/image/info8/8316a56947c543f4bce61d797846e27f.jpg"><img src="https://img.it610.com/image/info8/8316a56947c543f4bce61d797846e27f.jpg" alt="【linux
命令行与shell脚本】_第10张图片" /></a></p>

<h3 id="字符串拼接">字符串拼接</h3>

<pre><code>list=&quot;l1 l2 l3 l4 l5 l6&quot;
list=$list&quot; l7&quot; #字符拼接
for state in $list
do
    echo &quot;$state in the list&quot;
done
</code></pre>

<h3 id="从命令读取值"><strong>从命令读取值：</strong></h3>

<p>如下，使用<code>$(command)</code>就可以将命令作为列表读入for循环中。</p>

<pre><code>#!/bin/bash
for file in $(ls)
do
    echo &quot;The file/folder is $file&quot;
done
</code></pre>

<p>这里显示了当前目录下的所有文件或文件夹名。</p>

<hr />

<h3 id="更改字段分隔符"><strong>更改字段分隔符：</strong></h3>

<p>有个环境变量叫做IFS(internal field separator)，即内部字段分隔符。默认情况下，bash
shell将空格、制表符、换行符当做字段分隔符。可以这样来修改IFS的值：<code>IFS=</code>，比如，我们可以使用如下代码，拆分当前路径：</p>

<pre><code>#!/bin/bash

IFS.OLD=$IFS
IFS=/

for file in $(pwd)
do
    echo &quot;The path is: $file&quot;
done




list=&quot;l1;l2 :l3 l4; l5 l6   l8&quot;
list=$list&quot; l7&quot;
#IFS=$' \t\n'
IFS=$'\t\n:;'
echo &quot;$IFS&quot;
for state in $list
do
    echo &quot;$state in the list&quot;
done
</code></pre>

<p>如果想使用多个分隔符，直接将其它们在赋值行串起来即可。这里了使用<code>IFS.OLD=$IFS；IFS=/</code>先将默认的分隔符保存起来，使用完毕之后可以将其恢复。</p>

<hr />

<p><strong>使用通配符读取目录：</strong><br />
可以在for循环中使用通配符来处理目录中的文件。如下图所示我们匹配了用户目录下所有已test开头的文件和文件夹。</p>

<p><a href="https://img.it610.com/image/info8/7a77f733142547949b53f4b909eb8d0a.jpg"><img src="https://img.it610.com/image/info8/7a77f733142547949b53f4b909eb8d0a.jpg" alt="【linux
命令行与shell脚本】_第11张图片" /></a></p>

<p>稍加修改就可以完成更加强大的功能，比如遍历某个目录下的文件和目录，并用test命令将其进行分类。</p>

<p><strong>注意</strong> ：我们可以在数据列表中放入任何东西，比如前面说到的数值、文件和目录。</p>

<hr />

<p><strong>使用C语言分风格的for命令：使用双小括号</strong><br />
如同我们在shell-
结构化命令之跳转中说到的在if语句重中使用双小括号来实现高级的数学表达式一样。for循环中也可以使用双小括号来实现C语言风格的变量引用方式（其实也类似于数学表达式），格式为<code>for((
expression ))</code>，这里的表达式类似于C语言等语言中的。给一个简单的例子：</p>

<p><a href="https://img.it610.com/image/info8/2cf938f7a8c94ed0a45d653aaae5f896.jpg"><img src="https://img.it610.com/image/info8/2cf938f7a8c94ed0a45d653aaae5f896.jpg" alt="【linux
命令行与shell脚本】_第12张图片" /></a></p>

<p>嵌套循环，修改IFS环境变量遍历文件数据</p>

<pre><code>#!/bin/bash
#处理/etc/passwd文件中的数据，逐行遍历文件，并将IFS变量的值改成冒号，分割每行中的各个数据段

IFS_OLD=$IFS
IFS=$'\n'
for entry in $(cat /etc/passwd)  #entry一次性用IFS取出
do
    echo &quot;Value in $entry -&quot;
    IFS=:
    for value in $entry
    do
        echo $value
    done
done
</code></pre>

<h2 id="八-while-until命令">八、while&amp;until命令</h2>

<p>while命令的格式如下：</p>

<pre><code>while test command
do
    other commands
done
</code></pre>

<p>test command这里和之前if中的test命令一模一样。</p>

<p>until命令和while的工作方式完全相反，其格式如下：</p>

<pre><code>until test commands
    other commands
done
</code></pre>

<p>直到test命令返回退出状态码为0时，循环才结束；退出状态码不为0时，往下执行循环。</p>

<p>while/until 使用多个测试命令（每个命令单独占一行），只有最后一个测试命令的退出状态码作为循环结束的判断条件</p>

<pre><code>while echo $val1
    [ $val1 -ge 0 ]
do
    echo $val1
    val1 = $[ $val1 - 1 ]
done
</code></pre>

<h2 id="九-break-continue命令">九、break&amp;continue命令</h2>

<p>和其他编程语言中的完全类似：</p>

<p><strong>break用于：</strong></p>

<ul>
<li>跳出单个循环，此循环终止</li>
<li>跳出内部循环（嵌套循环时）</li>

<li><p>跳出外部循环（break n，用n指定外部循环的层级，默认情况下n为1，表示跳出当前循环</p>

<p>#!/bin/bash
for (( a = 1; a &lt; 4; a++ ))
do
    echo &ldquo;Outer loop $a&rdquo;
    for (( b = 1; b &lt; 100; b++ ))
        if [ $b -gt 4 ]
        then
            break 2
        fi
        echo &ldquo;Inner loop : $b&rdquo;
    done
done</p></li>
</ul>

<p><strong>continue用于：</strong></p>

<ul>
<li>提前终止某次循环，但并不会终止整个循环</li>
<li>类似的用 continue n</li>
<li></li>
</ul>

<h2 id="十-处理循环输出-使用管道或者重定向处理-read命令">十、处理循环输出，使用管道或者重定向处理 &gt; | &lt; read命令</h2>

<pre><code>#!/bin/bash
#-----------------1. &gt; ----------------------
for file in /home/rich/*
do
    if [ -d $file ]
    then 
        echo &quot;$file is a directory&quot;
    elif
        echo &quot;$file is a file&quot;
    fi
done &gt; output.txt

#-----------------2. | ----------------------
for state in &quot;North Dakota&quot; china hongkong
do
    echo &quot;$state is the next place to go&quot;
done | sort

#for 命令的输出结果传递给了sort,实际的输出结果已经排序

#-----------------3. &lt; ----------------------
#创建多个用户

#read命令会自动读取.csv文本文件中的下一行内容 rich,Richard Blum
input=&quot;users.csv&quot;
while IFS=',' read -r userid name
do
    echo &quot;adding $userid&quot;
    useradd -C &quot;$name&quot; -m $userid
done &lt; &quot;$input&quot;
</code></pre>

<h3 id="五-处理用户输入-参数-10-basename">五、处理用户输入（参数${10}、basename）</h3>

<h3 id="1-命令行参数-0-9-10-n-n-10"><strong>1.命令行参数 $0~$9 ${10} ${n} #n &gt;=10</strong></h3>

<h3 id="2-basename-name-basename-0-basename命令返回不包含路径的脚本命"><strong>2.basename: name=${basename $0} basename命令返回不包含路径的脚本命</strong></h3>

<h3 id="3-判断命令行参数是否存在"><strong>3.判断命令行参数是否存在</strong></h3>

<pre><code>#!/bin/bash
if [ -n &quot;$1&quot; ]
then
    echo  hell ,$1
else
    echo sorry ,I don`t know you
fi
</code></pre>

<h3 id="4-特殊参数变量-shift-n-0"><strong>4.特殊参数变量（shift n,</strong> $0, $#, $*, $@, $?, $$ <strong>）</strong></h3>

<p><strong>$# 脚本运行时携带的参数个数</strong></p>

<p><strong>shift命令会将所有参数的位置移动一个位置，当第一个参数的长度为0时，循环结束。注意：使用shift时，参数会被移除丢弃，无法恢复。</strong></p>

<p><strong>shift n，指定移动的位数，可以跳过不需要的参数。</strong></p>

<pre><code>#!/bin/bash
count=1
while [ -n &quot;$1&quot; ]
do
    echo &quot;Parameter #$count = $1 &quot;
    count=$[ $count + 1 ]
    shift
done


#本段代码来自https://blog.csdn.net/u011341352/article/details/53215180/
Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数

特殊变量列表

变量  含义
$0      当前脚本的文件名
$n      传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
$#      传递给脚本或函数的参数个数。
$*      传递给脚本或函数的所有参数。
$@      传递给脚本或函数的所有参数。被双引号(&quot; &quot;)包含时，与 $* 稍有不同，下面将会讲到。
$?      上个命令的退出状态，或函数的返回值。一般情况下，大部分命令执行成功会返回 0，失败返回 1。
$$      当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。


$* 和 $@ 的区别
$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(&quot; &quot;)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。
但是当它们被双引号(&quot; &quot;)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。

下面的例子可以清楚的看到 $* 和 $@ 的区别：
#!/bin/bash
echo &quot;\$*=&quot; $*
echo &quot;\&quot;\$*\&quot;=&quot; &quot;$*&quot;
echo &quot;\$@=&quot; $@
echo &quot;\&quot;\$@\&quot;=&quot; &quot;$@&quot;
echo &quot;print each param from \$*&quot;
for var in $*
do
    echo &quot;$var&quot;
done
echo &quot;print each param from \$@&quot;
for var in $@
do
    echo &quot;$var&quot;
done
echo &quot;print each param from \&quot;\$*\&quot;&quot;
for var in &quot;$*&quot;
do
    echo &quot;$var&quot;
done
echo &quot;print each param from \&quot;\$@\&quot;&quot;
for var in &quot;$@&quot;
do
    echo &quot;$var&quot;
done

执行 ./test.sh &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;，看到下面的结果：
$*=  a b c d
&quot;$*&quot;= a b c d
$@=  a b c d
&quot;$@&quot;= a b c d
print each param from $*
a
b
c
d
print each param from $@
a
b
c
d
print each param from &quot;$*&quot;
a b c d
print each param from &quot;$@&quot;
a
b
c
d
说明：双引号包含时，&quot;$*&quot;的参数被当做一个整体，而&quot;$@&quot;还是遍历每一个参数
</code></pre>

<h1 id="十一-处理用户输入">十一、处理用户输入</h1>

<p>1、查找选项</p>

<pre><code>#!/bin/bash
echo
while [ -n &quot;$1&quot; ]
do
    case &quot;$1&quot; in
    -a) echo &quot;found the -a option&quot; ;;
    -b) echo &quot;found the -b option&quot; ;;
     *) echo &quot;$1 is not an option&quot; ;;
    esac
    shift
done
</code></pre>

<h3 id="2-分离参数和选项">2、分离参数和选项 &ndash;</h3>

<h3 id="shell-会用双破折线来表明选项列表结束">shell 会用双破折线来表明选项列表结束</h3>

<pre><code>#!/bin/bash
echo
while [ -n &quot;$1&quot; ]
do
    case &quot;$1&quot; in
    -a) echo &quot;-a&quot;
    -b) echo &quot;-b&quot;
    --) shift
    esac
    shift
done

count=1
for param in $@
do
    echo &quot;parameter #$count : $param&quot;
    count=$[ $count + 1 ]
done
</code></pre>

<p>2.getopts 命令格式： getopts optstring variable</p>

<p>###
getopts命令会用到两个环境变量，如果选项需要跟一个参数值，OPTARG环境变量会保存这个值，OPTING环境变量保存了参数列表中getopts正在处理的参数的位置。</p>

<pre><code>#!/bin/bash

#processing options &amp; parameters with getopts
echo
while getopts :ab:cd opt
do
    case &quot;$opt&quot; in
    a) echo &quot;Found the -a option&quot; ;;
    b) echo &quot;Found the -b option,with value $OPTARG&quot; ;;
    c) echo &quot;Found the -c option&quot; ;;
    d) echo &quot;Found the -d option&quot; ;;
    *) &quot;Unknow option: $opt&quot; ;;
    esac
done
shift $[ $OPTIND -1 ]
echo 
count=1
for param in &quot;$@&quot;
do
    echo &quot;Parameter $count:$param&quot;
    count=$[ $count + 1 ]
done
</code></pre>

<h3 id="3-选项标准化">3.选项标准化</h3>

<p>在创建shell脚本时可以尽量符合常用命令选项，使脚本更友好</p>

<table>
<thead>
<tr>
<th>常用linux命令选项  选项</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>-a</td>
<td></td>
</tr>
</tbody>
</table>

<p>显示所有对象</p>

<p>-c | 生成一个计数<br />
-d | 制定一个目录<br />
-e | 扩展一个对象<br />
-f | 指定读入数据的文件<br />
-h | 显示命令的帮助信息<br />
-i | 忽略文本大小写<br />
-l | 产生输出的长格式版本<br />
-n | 使用非交互模式（批处理））<br />
-o | 将所有的输出重定向到指定的输出文件<br />
-q | 以安静模式运行<br />
-r | 递归处理目录和文件<br />
-s | 以安静模式运行<br />
-v | 生成详细输出<br />
-x | 排除某个对象<br />
-y | 对所有问题回答yes</p>

<h2 id="十二-read-获取用户输入">十二、read 获取用户输入</h2>

<pre><code>#!/bin/bash
#超时、读取字符长度、隐藏方式读取-s 、从文本中读取
echo -n enter your name
if read -t 5 -p &quot;enter your name&quot; name
then
    echo &quot;hello $name&quot;
else
    echo &quot;sorry timeout&quot;
fi
#输入密码 read -s
read -s -p &quot;Enter your password&quot;
#字符长度限制 read -n$num
read -n1 -p &quot;Do you want to go [Y|N]?&quot; answer
case $answer in
Y | y) echo
    echo &quot;ok, go&quot;
N | n) echo
    echo ok,goobye
    exit;;
esac
#从文本中读取

count=1
cat test | while read line
do
    echo &quot;Line $count : $line&quot;
done
</code></pre>

<h2 id="十三-文件描述符与重定向">十三、文件描述符与重定向</h2>

<p>1.STDIN（0） STDOUT（1） STDERR（2）</p>

<pre><code>#!/bin/bash
outfile='members.sql'
IFS=','
while read lname fname address city state zip
do
    cat &gt;&gt; $outfile &lt;&lt; EOF
    INSERT INTO members (lname,fname,address,city,state,zip) VALUES
('$lname','$fname','$address','$city','$state','$zip');
EOF
done &lt; ${1}
#done &lt; ${1}  指定read从脚本输入参数的文本中读取
# cat &gt;&gt; $outfile &lt;&lt; EOF：EOF指定数据的起止
#./test23 &lt; members.csv
# members.csv: Blum,Richard,123 Main St.,Chicago,IL,60601
#
</code></pre>

<p>重定向错误与数据</p>

<p>1）ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</p>

<p>2)&amp;&gt;:将STDERR与STDOUT输出重定向到同一个文件</p>

<p>3）临时重定向在数字前加&amp;： echo &ldquo;this&rdquo; &gt; &amp;2</p>

<p>4)永久重定向： exec 1 &gt; testout</p>

<p>5)重定向输入： exec 0 &lt; testfile</p>

<pre><code>#!/bin/bash
exec 0&lt; testfile
count=1
while read line
do 
    echo &quot;Line $count : $line&quot;
    count=$[ $count + 1 ]
done
</code></pre>

<p>6)创建自己的重定向（3~8数字可以用于自定义描述符），恢复已重定向的文件描述符</p>

<pre><code>#!/bin/bash
exec 3&gt;&amp;1
exec 1 &gt; testout
echo &quot; This should store in the output file&quot;
exec 1&gt;&amp;3
echo &quot;Now things should be back to normal&quot;
</code></pre>

<p>7）关闭文件描述符 exec 3&gt;&amp;-</p>

<p>8)列出打开的文件描述符lsof: lsof -a -p</p>

<p>9)阻止输出： &gt;/dev/null ： ls -al &gt; /dev/null</p>

<h2 id="十四-创建临时文件">十四、创建临时文件</h2>

<p>1）创建临时文件</p>

<p>mktemp会用6个字符码替换着6个X</p>

<p>mktemp testing.XXXXXX</p>

<p>2）在/tmp目录下创建临时文件</p>

<p>mktemp -t test.XXXXXX</p>

<p>3)创建临时目录</p>

<p>mktemp -d dir.XXXXXX</p>

<pre><code>#!/bin/bash
tempdir=$(mktemp -d dir.XXXXXX)
cd $tempdir
tempfile1=$(mktemp temp.XXXXXX) 
tempfile2=$(mktemp temp.XXXXXX)
exec 7 &gt; $tempfile1
exec 8 &gt; $tempfile2
echo &quot;Sending data to directory $tempdir&quot;
echo &quot;This is a test line of data for $tempfile1&quot; &gt;&amp;7
echo &quot;This is a test line of data for $tempfile2&quot; &gt;&amp;8
</code></pre>

<p>4）记录消息 tee</p>

<p>tee -a filename (-a 文本追加）</p>

<p>tee命令将STDIN过来的数据同时发往两处，STDOUT和tee指定的文件</p>

<h2 id="十五-后台运行与定时运行">十五、后台运行与定时运行</h2>

<p>1）nohup ./test.sh &amp; : nohup自动将输入输出重定向到nohup.out文件中</p>

<p>2）定期执行：cron 时间表</p>

<p>min hour dayofmonth month dayofweek command</p>

<p>明天10:15运行 ： 15 10 * * * comomand</p>

<p>dayofmonth 取值（1~31） dayofweek取值（0~6,0为周日）</p>

<p>每月最后一天执行： 00 12 * * * if [ <code>date +%d -d tommorrow</code> = 01 ] ; then ; command</p>

<p>crontab -l查看cron时间表</p>

<p>cron唯一的问题是，假如某个作业在cron时间表中安排的时间已到，而linux系统处于关机状态，该作业不会被执行，重新开机后，系统不会执行错过的作业，而anacron可以。</p>

<p>3）anacron</p>

<p>period delay identifier command</p>

<p>4）cat .bashrc</p>

<p>修改.bashrc文件可以在用户打开新的shell启动时运行指定的脚步</p>

<h2 id="十六-创建函数">十六、创建函数</h2>

<h3 id="1-创建函数的两种格式">1. 创建函数的两种格式</h3>

<p><em>function name {</em></p>

<p><em>commands</em></p>

<p><em>} 或者</em></p>

<p><em>name()</em></p>

<p><em>{</em></p>

<p><em>commands</em></p>

<p><em>}</em></p>

<h3 id="2-函数返回值">2.函数返回值</h3>

<p>1）默认退出状态码：默认情况下，函数的退出码是函数中最后一条命令的返回的退出状态码。</p>

<p>2）使用return 命令返回值（退出码必须是0~·255之间）</p>

<pre><code>#!/bin/bash
function db1 {
    read -p &quot;Enter a value: &quot; value
    return $[ $value * 2 ]
}

dbl
echo &quot;The new value is $?&quot;
</code></pre>

<p>3)使用函数输出</p>

<pre><code>#!/bin/bash
function db1 {
    read -p &quot;Enter a value: &quot; value
    echo $[ $value * 2 ]
}

result =$(db1) # result=`db1`
echo &quot;The new value is $result&quot;
</code></pre>

<p>3.在函数中使用变量（参数传递）</p>

<pre><code>#!/bin/bash
function func7 {
    echo $[ $1 * $2 ]
}

if [ $# -eq 2 ]
then
    value=$(func7 $1 $2)
    echo &quot;The result is $value&quot;
else
    echo &quot;Usage : badtest1 a b&quot;
fi

#./test7 10 15
</code></pre>

<h3 id="1-全局变量和局部变量-local-temp">1)全局变量和局部变量（local temp）</h3>

<p>默认情况下，在脚本中定义的任何变量都是全局变量，可以在shell脚本中的任何地方使用。</p>

<pre><code>#!/bin/bash
function func1 {
    local temp=$[ $value +5 ] 
    result=$[ $temp * 2 ]
}

temp=4
value=6
func1
echo &quot;The result is $result&quot;
if [ $temp -gt $value ]
then
    echo &quot;temp is larger&quot;
else
    echo &quot;temp is smaller&quot;
fi

#./test9-&gt;22-&gt;smaller
</code></pre>

<h3 id="3-数组变量和函数">3.数组变量和函数</h3>

<p>1）向函数传递数组参数</p>

<pre><code>#!/bin/bash
function testit {
    echo &quot;The parameters are : $@&quot;
    thisarray=$1
    echo &quot;The received array is ${thisarray[*] }&quot;
}

myarray=(1 2 3 4 5)
echo &quot;the original array is : ${myarray[*]}&quot;
testit $myarray
#The parameters are 1
#如果你试图将数组变量作为函数参数，函数只会取数组变量的第一个值

function testit1 {
    local newarray
    newarray=(;'echo &quot;$@&quot;')
    echo &quot;The new array value is : ${newarray[*]}&quot;
}
myarray1=(1 2 3 4 5)
echo &quot;the original array is : ${myarray1[*]}&quot;
testit1 ${myarray1[*]}
</code></pre>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>