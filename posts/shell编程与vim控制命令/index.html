<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Shell编程与vim控制命令 | 开发者问答集锦</title>
    <meta property="og:title" content="Shell编程与vim控制命令 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Shell编程与vim控制命令">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/shell%E7%BC%96%E7%A8%8B%E4%B8%8Evim%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Shell编程与vim控制命令</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h1 id="shell-编程">Shell 编程</h1>

<h2 id="linux命令">Linux命令</h2>

<h3 id="linux登录命令">linux登录命令</h3>

<ol>
<li><ol>
<li>telnet远程网络登录：tlenethostip。此操作需要远程主机开启telnet服务端，一般为telnetd。</li>
</ol>

<ol>
<li>通过ssh登录：

<br /></li>
</ol></li>
</ol>

<p>ssh -l username hostip</p>

<p>ssh username@hostip</p>

<p>scp –r username@hostip:/path/of/file local_path</p>

<hr />

<h3 id="命令帮助man">命令帮助man</h3>

<p>man命令可以查看命令或者函数的帮助文档，具体可以指定一个数字指定查找范围。如man3 printf。man
–kkeyword：可以按照keyword进行搜索</p>

<h3 id="基本工具">基本工具</h3>

<ol>
<li><p>ls:显示文件名，ls–la; ls –lh可以看到Humanreadable的大小显示</p></li>

<li><p>cat：显示文件内容</p></li>

<li><p>rm：删除文件，rm–f强制删除，rm –r 删除目录</p></li>

<li><p>less/more:分屏显示，man3 printf|more</p></li>

<li><p>hostname:显示系统名，此系统名记录在/etc/hostname文件里面</p></li>

<li><p>apropos：此命令在man的简短描述中搜索关键字。用于查找某个功能的命令。</p></li>

<li><p>which/whereis：查找某个命令的执行体位置。</p></li>

<li><p>locate：查找文件（比如动态库）所在位置</p></li>

<li><p>who/finger：列出系统上的用户</p></li>

<li><p>ps显示进程号,psaux|grep “minicom”查找minicom的进程号</p></li>

<li><p>kill：给进程发信号。kill-9 1111，杀死进程号为1111的进程。kill还可以杀死真正运行的作业jobs，如kill%1,杀死一号作业，%号表示后面的数字为作业号。</p></li>

<li><p>chmod：修改文件权限</p></li>
</ol>

<p>chmod –R u+x ./ #当前目录及其子目录的文件加执行权限。</p>

<hr />

<ol>
<li>find：查找文件，一般和其他命令搭配使用。

<br /></li>
</ol>

<p>find ./ -name “*.c”|wc –l #当前目录及其子目录下c文件的个数</p>

<hr />

<h3 id="文件操作">文件操作</h3>

<ol>
<li><p>cp：复制文件</p></li>

<li><p>mv：移动文件，如果在同一目录下就表示重命名文件</p></li>

<li><p>grep：查找字符串，如查找当前目录下所有c文件中printf的具体位置：</p></li>
</ol>

<p>find ./ -name “*.c” | xargs grep “printf”</p>

<hr />

<ol>
<li><p>xargs：将标准输入按命令行格式解释</p></li>

<li><p>head/tail：显示文件的头部/尾部。</p></li>

<li><p>sort:按顺序显示文件。默认按照首字母排列。sort–n,按照字符串的大小升序排列。sort–r，翻转排列顺序。</p></li>

<li><p>uniq:显示文件同cat，但是忽略文件中的重复行</p></li>

<li><p>diff：比较两个文件，diff–y file1 file2，将两个文件并排显示，并指出两个文件的不同。diff–urN dir1/ dir2/递归比较两个目录的差异，形成patch文件</p></li>

<li><p>file:获取文件信息</p></li>

<li><p>echo：复制内容并回显。</p></li>

<li><p>date：显示时间和日期</p></li>

<li><p>script:记录会话</p></li>

<li><p>unix2dos/dos2unix：将linux文件转换为windows格式。</p></li>

<li><p>tar:归档文件管理。</p></li>
</ol>

<p>tar –zcvf file.tgz file #将file压缩成gzip格式的归档文件。</p>

<hr />

<p>tar –zxvf file.tgz –C ~/ #将file.tgz解压到用户目录下。</p>

<p>jcvf和jxvf为bzip2格式的创建和解压参数。</p>

<ol>
<li><p>mkdir:创建文件夹，mkdir–p ~/work/test/abc，-p参数可以创建多层目录。</p></li>

<li><p>ln：创建一个文件的链接，注意：默认为硬链接，硬链接为一个直接指向文件的指针，它和原文件（也是一个指向文件的指针）共享文件的inode，删除时，需要将所有的链接全部删除后，系统才会删除磁盘上的文件。软连接（符号链接）为指向硬链接的指针，创建时需加-s需用绝对路径名（相对路径名容易出错），比如</p></li>
</ol>

<p>ln –s /usr/bin/vi /bin/vim #将vi命令链接成为vim，</p>

<hr />

<p>这样输入vi的时候启动的是vim，它相当于一个快捷方式。</p>

<h2 id="shell命令行">shell命令行</h2>

<h3 id="标准输入输出">标准输入输出：</h3>

<ol>
<li><p>shell将键盘作为标准输入，屏幕作为标准输出。</p></li>

<li><p>通过 &gt;可以重定向输出, &lt;重定向输入,比如</p></li>
</ol>

<p>b cat #表示以a为输入，b文件输出执行cat命令</p>

<hr />

<p>，</p>

<p>需要特别注意的是标准输出的定向文件会覆盖原来的文件，如果是&gt;&gt;在某个文件末尾追加输出。</p>

<h3 id="管道">管道</h3>

<p>shell用管道将一个命令的输出直接连接到另一个命令的输入。符号：|。如</p>

<p>cat test.c | grep “printf”</p>

<hr />

<p>管道可以很好的连接多个命令来完成一个功能。</p>

<p>tee：tee可以将一个输入输出到两个输出，如</p>

<p>who | teewho.out | grep root #将命令who的输出定位到who.out文件，同时作为grep的输入，查找root项。</p>

<hr />

<h3 id="在后台运行程序">在后台运行程序</h3>

<p>将一个任务后台运行可以通过命令行加&amp;符号</p>

<p>cat test.c | lpr &amp; #后台打印test.c</p>

<hr />

<p>bg：首先用CONTROL+Z将任务挂起，输入bg+%jobnum命令可以使任务在后台运行，如果只有一个任务被挂起，可不指定任务号。注意后台运行的程序标准输入和键盘断开，如果任务需要充键盘输入，则任务被阻塞。</p>

<p>fg：将某个后台运行的任务切换到前台运行，如果只有一个后台运行的任务，可以不指定任务号。</p>

<h3 id="特殊字符">特殊字符</h3>

<p>字符？：？表示单个字符匹配,注意的是？无法在文件名开头匹配句号“．”。如.cache就不能用?chache进行匹配。</p>

<p>字符*：字符*可以匹配0到任意多个连续的字符。如*abc,表示以abc结尾的所有文件</p>

<p>字符[]:[]表示与括号内的单独一个字符进行匹配。如[abc]*表示以a,b,c中任一字母开头的所有文件。字符号还可以跟！和^组合表示否定，如[^abc]*表示不以a,b,c中任一字符开头的所有文件。</p>

<p>任何shell命令都会在执行之前进行上述的shell展开，比如下面的命令可能无法找到所有的c文件</p>

<p>find –name *.c</p>

<p>因为*.c在命令执行之前，shell展开成当前目录的c文件，如果当前目录确实有.c文件，展开后命令格式出错，应该写成</p>

<p>find –name “*.c”</p>

<h2 id="编辑器vim">编辑器vim</h2>

<p>vim是linux下面强大的编辑器。vim有3种模式，普通模式，插入模式和命令模式。一开始为普通模式。按”:”冒号进入命令模式，按o,i,a进入插入模式。</p>

<p>下面就以写个test.c描述vim的使用。</p>

<h3 id="vim的配置">vim的配置</h3>

<p>vim强大之处在于它有很多很好用的插件。作为程序人员，首先要安装ctags。</p>

<p>再安装vim的插件,taglist和winmanager。还有其他很多插件，不过我一般就只用这两个。</p>

<p>下面是我的vimrc</p>

<p>&rdquo; All system-wide defaults areset in $VIMRUNTIME/debian.vim (usually just</p>

<p>&rdquo;/usr/share/vim/vimcurrent/debian.vim) and sourced by the call to:runtime</p>

<p>&rdquo; you can find below. If youwish to change any of those settings, you should</p>

<p>&rdquo; do it in this file(/etc/vim/vimrc), since debian.vim will be overwritten</p>

<p>&rdquo; everytime an upgrade of thevim packages is performed. It is recommended to</p>

<p>&rdquo; make changes after sourcingdebian.vim since it alters the value of the</p>

<p>&rdquo; &lsquo;compatible&rsquo; option.</p>

<p>&rdquo; This line should not beremoved as it ensures that various options are</p>

<p>&rdquo; properly set to work with theVim-related packages available in Debian.</p>

<p>runtime! debian.vim</p>

<p>setfileencodings=utf-8,gb2312,gbk,gb18130,cp936</p>

<p>&rdquo; Uncomment the next line tomake Vim more Vi-compatible</p>

<p>&rdquo; NOTE: debian.vim sets&rsquo;nocompatible&rsquo;. Setting &lsquo;compatible&rsquo; changes numerous</p>

<p>&rdquo; options, so any other optionsshould be set AFTER setting &lsquo;compatible&rsquo;.</p>

<p>set nocompatible</p>

<p>&rdquo; Vim5 and later versionssupport syntax highlighting. Uncommenting the</p>

<p>&rdquo; following enables syntaxhighlighting by default.</p>

<p>if has(&ldquo;syntax&rdquo;)</p>

<p>syntax on</p>

<p>endif</p>

<p>&rdquo; If using a dark backgroundwithin the editing area and syntax highlighting</p>

<p>&rdquo; turn on this option as well</p>

<p>&ldquo;set background=dark</p>

<p>&rdquo; Uncomment the following tohave Vim jump to the last position when</p>

<p>&rdquo; reopening a file</p>

<p>if has(&ldquo;autocmd&rdquo;)</p>

<p>au BufReadPost * if line(&ldquo;&rsquo;\&ldquo;&rdquo;)&gt; 1 &amp;&amp; line(&ldquo;&rsquo;\&ldquo;&rdquo;) &lt;= line(&ldquo;$&rdquo;)| exe &ldquo;normal!
g&rsquo;\&ldquo;&rdquo; | endif</p>

<p>endif</p>

<p>&rdquo; Uncomment the following tohave Vim load indentation rules and plugins</p>

<p>&rdquo; according to the detectedfiletype.</p>

<p>if has(&ldquo;autocmd&rdquo;)</p>

<p>filetype plugin indent on</p>

<p>endif</p>

<p>&rdquo; The following are commentedout as they cause vim to behave a lot</p>

<p>&rdquo; differently from regular Vi.They are highly recommended though.</p>

<p>set showcmd &ldquo; Show (partial)command in status line.</p>

<p>set showmatch &ldquo; Show matchingbrackets.</p>

<p>set ignorecase &ldquo; Do caseinsensitive matching</p>

<p>set smartcase &ldquo; Do smart casematching</p>

<p>set incsearch &ldquo; Incrementalsearch</p>

<p>set autowrite &ldquo; Automaticallysave before commands like :next and :make</p>

<p>&ldquo;set hidden &ldquo;Hide buffers when they are abandoned</p>

<p>set mouse=a &ldquo; Enable mouseusage (all modes)</p>

<p>&rdquo; Source a global configurationfile if available</p>

<p>iffilereadable(&ldquo;/etc/vim/vimrc.local&rdquo;)</p>

<p>source /etc/vim/vimrc.local</p>

<p>endif</p>

<p>set nu</p>

<p>set foldmethod=syntax</p>

<p>set foldlevel=100</p>

<p>set autoindent</p>

<p>set smartindent</p>

<p>set tabstop=4</p>

<p>set shiftwidth=4</p>

<p>&ldquo;TList</p>

<p>let Tlist_Show_One_File=1</p>

<p>let Tlist_Exit_OnlyWindow=1</p>

<p>nmap tl :Tlist</p>

<p>&ldquo;Tlist</p>

<p>&ldquo;winmannger</p>

<p>letg:winManagerWindowLayout=&lsquo;FileExplorer|TagList&rsquo; &ldquo;winmanagerTagList</p>

<p>nmap wm :WMToggle</p>

<p>&ldquo;winmanager</p>

<hr />

<p>注意的几点：</p>

<ol>
<li><p>filecoding，编码方式，里面设置可以支持中文，不然中文乱码</p></li>

<li><p>setnocompatiable:不兼容老版本，不然键盘输入出问题（方向键变成了abcd）</p></li>

<li><p>set mouse=a：这句话让鼠标全局使能，可以使用鼠标</p></li>

<li><p>set nu：显示行号</p></li>

<li><p>setfoldmethod：设置折叠方式，普通模式下zc折叠代码，zo打开代码，在看大的代码块非常有用</p></li>

<li><p>set autoindent：自动缩进</p></li>

<li><p>tabstop=4：制表位宽度为4</p></li>

<li><p>tl映射命令Tlist,需要安装taglist插件</p></li>

<li><p>wm映射命令WMToggle,需安装winmanager。</p></li>
</ol>

<h3 id="vim编辑">vim编辑</h3>

<ul>
<li>vim +filename就打开或者新建了一个文件</li>
</ul>

<p>然后按键盘i, 进入插入模式，输入代码。输入代码是可以使用ctrl+n/ctrl+p
进行自动补全（这个补全功能很弱，只是在本文件内部进行查找匹配）。然后wq 保存。</p>

<p>这里介绍下vim文本编辑的常用命令：</p>

<ol>
<li><ol>
<li>：nu，命令模式下输入行号可以直接跳到改行</li>
</ol>

<ol>
<li><p>num+yy：普通模式当前光标所在向下复制num行，不加num表示复制本行，yw表示复制一个word</p></li>

<li><p>num+dd：删除当前光标向下num行，如果不加num表示删除本行，dw表示删除一个work，dG表示删除到末尾，d$删除到行尾。</p></li>

<li><p>u：撤销修改</p></li>

<li><p>p：粘贴最近复制的或者删除的内容</p></li>

<li><p>q：q在普通模式下表示记录操作。qa：表示记录操作到寄存器a，记录完成以q结束。然后按句点“。”重复寄存器里面的动作，也可以times@a将寄存器里的动作重复times次。</p></li>

<li><p>大面积注释：光标移到要注释的行首，CONTROL+V进入visual模式，下移光标到注释块最后一行行首，shift+i，输入//注释符号，按两次esc就可以看到这块代码被注释了。反注释时同样操作，将//删除就可以了。</p></li>

<li><p>格式化代码:vim提供num+=来格式化num行。或者使用visual模式选定需要格式化的区域，然后按=</p></li>

<li><p>查找字符：普通模式下“/“查找字符，”:%s“替换字符，如</p></li>
</ol></li>
</ol>

<p>：%s/\/10/g</p>

<hr />

<p>上命令表示将ten替换为10,:%s为替换开头。&lt;匹配字符串的左边界,&gt;匹配字符串的右边界，g表示全局范围。</p>

<p>这样就完成了一个文件的编辑。写个makefile编译这个文件。打开vim，在里面输入:make(vim支持make命令)，如果编译出错，可以输入:cope，快速定位到错误所在</p>

<p>按CONTROL+WW可以把光标在不同的窗口之间移动，编辑不同的窗口，输入ls可以看到当前vim有哪些缓冲器，即同时编辑的文件，输入buffer+缓冲区号可以将对应缓冲区切到前台编辑。</p>

<h3 id="vim看代码">vim看代码</h3>

<p>vim看大的项目工程我用的还不是很习惯，提供一些常用命令</p>

<ol>
<li><p>ctags –R *生成tags文件。这个命令需要在shell命令行下面敲,，在vim里面使用：！执行shell命令</p></li>

<li><p>tags+=tagpath，把一个tagpath的tags文件导入到当前的vim使用环境中。如tags+=./tags，表示把当前目录下的tags文件导入到vim中。</p></li>

<li><p>tagtagname:打开tagname所在的文件,如果该tagname在多处出现，可以使用:ts，该命令列出每个tagname的具体位置，你可以选择正确的tag打开。</p></li>

<li><p>gf：打开头文件。将光标移到头文件名上，按gf就可以打开该头文件，前提是该头文件在vim的path变量指定的路径内，如果没有，可以用setpath+=来增加搜索路径。</p></li>

<li><p>gd在函数内所需光标下的单词第一次出现的位置，gD在文件范围内寻找光标下的单词第一次出现的位置，通常可以用来搜索的局部变量和全局变量</p></li>

<li><p>#往回找光标当前的单词，*往后找光标当前的单词，配合hlsearch，可以很容一的找到函数中某个变量使用的地方，如果要清楚hlsearch，使用：setnohlsearch。%可以在大括号之间跳转。</p></li>

<li><p>CONTROL+]跳到变量/函数的定义，CONTROL+T调回上一步（和CONTROL+]）对应。gctrl+]可以弹出选择列表</p></li>

<li><p>CONTROL+i跳到前一步，CONTROL+o跳到后一步。</p></li>
</ol>

<h2 id="shell脚本编程">shell脚本编程</h2>

<h3 id="特殊符号变量">特殊符号变量</h3>

<p>$#:表示输入的参数个数</p>

<p>$$:在脚本中表示进程号</p>

<p>$@与$*:都表示命令行参数，$*把所有的参数当成一个参数，$@则生成一串参数。</p>

<p>$?:最近一条命令的退出状态</p>

<p>$!:后台运行的pid号</p>

<p>$0:调用程序名称</p>

<p>$1-$n:命令行对应位置上的参数</p>

<p>[]:作用相当于test命令,[ command ]判断command执行结果的真值。[之后，]之前必须各有一个空格。</p>

<p>--:&ndash; -v表示-v不是一个命令的参数，如cat–v和cat &ndash; -v。</p>

<h3 id="控制结构">控制结构</h3>

<ol>
<li>if&hellip;then

<br /></li>
</ol>

<p>if [ $# -eq 0 ]</p>

<p>then</p>

<p>echo “argnum= 0”</p>

<p>elseif [ $# -eq1 ]</p>

<p>then</p>

<p>echo“argnum = 1”</p>

<p>else</p>

<p>echo “argnum= $#”</p>

<p>fi</p>

<hr />

<p>test：测试后面条件的真值</p>

<p>eq(等于)/ne(不等于)/gt(大于)/ge（大于等于/lt(小于)/le（小于等于）</p>

<p>-d:文件是否存在并且是否为目录</p>

<p>-e:文件是否存在</p>

<p>-f:文件是否存在以及文件是否为普通文件（不是目录）</p>

<p>-r:文件是否存在以及文件是否可读</p>

<p>-s：文件是否存在以及文件是否大于0字节</p>

<p>-w：文件是否存在以及文件是否可写</p>

<p>-x：文件是否存在以及文件是否可执行</p>

<p>-a: AND运算</p>

<p>-o:OR运算</p>

<ol>
<li>for&hellip;in</li>
</ol>

<p>for loop-index in argument-list</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<hr />

<p>注意for默认的$@可以传递带空格的参数，如下面的一个test.sh</p>

<p>#!/bin/sh</p>

<p>echo “$@”</p>

<p>for i</p>

<p>do</p>

<p>echo $i</p>

<p>done</p>

<p>for i in $@</p>

<p>do</p>

<p>echo $i</p>

<p>done</p>

<hr />

<ol>
<li>while</li>
</ol>

<p>while test-command</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<hr />

<ol>
<li>until</li>
</ol>

<p>until test-command</p>

<p>do</p>

<p>commands</p>

<p>done</p>

<hr />

<ol>
<li><p>break与continue</p></li>

<li><p>case</p></li>
</ol>

<p>case test-string in</p>

<p>pattern-1)</p>

<p>commands-1</p>

<p>;;</p>

<p>pattern-2)</p>

<p>commands-2</p>

<p>;;</p>

<p>esac</p>

<hr />

<p>case结构中的匹配类型类似于一个模糊文件引用，可以匹配</p>

<p>*</p>

<p>|</p>

<p>匹配任一字符串，用作默认的case匹配</p>

<p>&mdash;|&mdash;</p>

<p>？</p>

<p>|</p>

<p>匹配单个字符</p>

<p>[&hellip;]</p>

<p>|</p>

<p>匹配括号内任一字符，可用两字符指定匹配范围，如[a-zA-Z]</p>

<p>|</p>

<p>|</p>

<p>case的分支可以满足多个条件，如A|B|C),pattern为A,B,C都可以进入这个分支</p>

<ol>
<li>select

<br /></li>
</ol>

<p>#!/bin/bash</p>

<p>PS3=&ldquo;yourselect: &ldquo;</p>

<p>selectchoice in apple peach orange QUIT</p>

<p>do</p>

<p>num=$REPLY</p>

<p>if[ $choice = QUIT ]</p>

<p>then</p>

<p>echo&rdquo;thank you!&rdquo;</p>

<p>break</p>

<p>fi</p>

<p>echo&rdquo;your choice is $num:$choice!&rdquo;</p>

<p>continue</p>

<p>done</p>

<hr />

<p>select语句后选择的数字保存在键盘变量REPLY中，select是个循环语句，需要break或者exit退出。</p>

<h3 id="文件描述符">文件描述符</h3>

<p>打开文件描述符</p>

<p>exec n&gt;outfile</p>

<p>exec m</p>

<hr />

<p>复制文件描述符</p>

<p>exec n&gt;&amp;outfile</p>

<p>exec m</p>

<hr />

<p>关闭复制的文件描述符</p>

<p>exec n&gt;&amp;-</p>

<p>exec m</p>

<hr />

<h3 id="数组">数组</h3>

<p>数组的声明：names=(element1element2 &hellip;)</p>

<p>数组的引用：${names[index]}</p>

<p>下标[*]和[@]的作用是提取整个数组元素,但是:</p>

<p>A=(“${names[*]}”)表示把元素的内容合并复制给A，这样A只有一个元素</p>

<p>B=(“${names[@]}”)表示把元素复制个B，B和names是一样的。</p>

<p>NAMES=(maxles)</p>

<p>A=(&ldquo;${NAMES[*]}&ldquo;)</p>

<p>B=(&ldquo;${NAMES[@]}&ldquo;)</p>

<p>declare-a</p>

<hr />

<p>运行结果</p>

<p>用${#names[*]}可以返回数组长度，用$(#names[index])可以返回对应下标的内容长度。</p>

<p>例子：</p>

<p>#!/bin/bash</p>

<p>PS3=&ldquo;yourselect: &ldquo;</p>

<p>choiceArr=(applepeach orange QUIT)</p>

<p>echo&rdquo;arrlen= &ldquo; ${#choiceArr[*]}</p>

<p>echo&rdquo;length of arr[0]: &ldquo; ${#choiceArr[0]}</p>

<p>selectchoice in ${choiceArr[@]}</p>

<p>do</p>

<p>num=$REPLY</p>

<p>if[ $choice = QUIT ]</p>

<p>then</p>

<p>echo&rdquo;thank you!&rdquo;</p>

<p>break</p>

<p>fi</p>

<p>echo&rdquo;your choice is $num:$choice!&rdquo;</p>

<p>continue</p>

<p>done</p>

<hr />

<p>执行结果：</p>

<h3 id="变量局部性">变量局部性</h3>

<p>export:脚本可以通过export声明导出变量的副本给其子进程使用。子进程对该变量的操作不影响父进程。</p>

<h3 id="变量的初始化">变量的初始化</h3>

<dl>
<dt>:-符号不是使用默认值，如${name:-default}</dt>
</dl>

<p>:=表示设置默认值,如${name:=default}</p>

<p>${name:?message}显示错误信息，判断变量是否为空或者未赋值，如果是,输出message并推出执行，返回码1。</p>

<h3 id="shell内置命令">shell内置命令</h3>

<p>trap:截获信号，如可以防止用户通过发送CONTROL+Z(信号数字18)来终止脚本运行。</p>

<p>stty:改变和打印终端设置。</p>

<p>tput:初始化终端或者查询终端信息。tputclear：清屏</p>

<p>basename:移除文件的路径和后缀名basename /home/test.sh .sh输出为test</p>

<p>set:用来初始化命令行参数变量，用于脚本的输入</p>

<p>unset：删除一个变量或者函数</p>

<p>read：接受用户输入，存在变量REPLY？？中。read命令每次从标准输入中读入一行，并赋值给一个或者几个变量，read开始一一对应的赋值，最后一个变量接受所有剩下的参数。</p>

<p>exec:执行命令。注意exec执行命令不会返回返回到原来的脚本中，但是用exec重定位？？会返回到原来的脚本。</p>

<p>如execdate;echo “hello”，这个echo“hello”就不会执行，但是exec；echo “hello”中的后一句就会执行。</p>

<p>shift:将位置参数左移一位，如原来的$1就变成$0了。</p>

<p>kill:终止进程</p>

<p>getopt：分析命令行参数</p>

<h3 id="表达式">表达式</h3>

<ol>
<li>算术表达式：算术表达式可以用let，但是带有空格的变量或者表达式必须用双引号“”,下面3中写法等价</li>
</ol>

<p>let “VALUE = VALUE * 10 + NEW”</p>

<p>let VALUE=VALUE*10+NEW #表达式内部没有空格</p>

<p>((VALUE=VALUE * 10 + NEW))</p>

<hr />

<ol>
<li>逻辑表达式：逻辑表达式用[[expression]]来表示，同样的，[[之后和]]之前的空格是必须的。注意在shell的判读语句中，0表示真的状态，1表示状态为false:

<br /></li>
</ol>

<p>#!/bin/bash</p>

<p>if [ $# -ne 2 ]; then</p>

<p>echo &ldquo;Usage:./logicexp.sh num1 num2&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>let &ldquo;value1 = $1 +(12 + 3)*0&rdquo;</p>

<p>let value2=$2+0</p>

<p>[[ $value1 == $value2 ]]</p>

<p>echo &ldquo;the reslutof [[ $1==$2 ]]: &ldquo; $?</p>

<p>[[ $value1 != $value2 ]]</p>

<p>echo &ldquo;the reslut of [[ $1!=$2 ]]: &ldquo; $?</p>

<hr />

<p>执行结果：</p>

<p>逻辑表达式和测试语句式什么区别？</p>

<p>逻辑表达式比测试语句式多了字符串的比较</p>

<ol>
<li>字符串模式匹配：

<br /></li>
</ol>

<p>#</p>

<p>|</p>

<p>去除最小匹配前缀（从字符串头部匹配，删掉头部最小匹配字符串，所谓前缀）</p>

<p>&mdash;|&mdash;</p>

<p>##</p>

<p>|</p>

<p>去除最大前缀匹配（从字符串头部匹配，删掉头部最大匹配字符串）</p>

<p>%</p>

<p>|</p>

<p>去除最小匹配后缀（从字符串尾部匹配，删掉尾部最大匹配字符串，所谓后缀）</p>

<p>%%</p>

<p>|</p>

<p>去除最大匹配后缀（从字符串尾部匹配，删除尾部最大匹配字符串）</p>

<p>例子：</p>

<p>结果：</p>

<h2 id="gawk模式处理语言">gawk模式处理语言</h2>

<p>gawk [options] [program] [file-list]</p>

<p>gawk [options] –f program-file[file-list]</p>

<p>gawk中默认变量</p>

<p>$0</p>

<p>|</p>

<p>当前记录（作为单个变量）</p>

<p>&mdash;|&mdash;</p>

<p>$1~$n</p>

<p>|</p>

<p>当前记录的字段</p>

<p>FILENAME</p>

<p>|</p>

<p>当前输入的文件名</p>

<p>FS</p>

<p>|</p>

<p>输入文件分隔字段</p>

<p>NF</p>

<p>|</p>

<p>当前记录的字段数目</p>

<p>NR</p>

<p>|</p>

<p>当前记录的记录编号</p>

<p>OFS</p>

<p>|</p>

<p>输出字段的分隔符（默认为空格符）</p>

<p>ORS</p>

<p>|</p>

<p>输出记录的分隔符（默认为换行符）</p>

<p>RS</p>

<p>|</p>

<p>输入记录分隔符（默认为换行符）</p>

<p>gawk默认从标准输入获取输入，可以用–f指定执行gawk程序，如</p>

<p>gawk –f testpasswd /etc/passwd</p>

<hr />

<p>testpasswd为gawk文件，从/etc/passwd中获得root用户信息</p>

<p>执行结果</p>

<p>BEGIN表示在gawk之前的动作，一般可以设置一些变量，打印开始的信息。END为gawk处理完之后的动作。</p>

<p>如果在命令行下可以用</p>

<p>gawk –F: ‘$1==”root” {print}’ /etc/passwd</p>

<hr />

<p>其中-F表示指定输入记录的字段分隔符为”</p>

<p>再查找一个名为cars的文件中所有代码honda字段的行</p>

<p>gawk /honda/ cars</p>

<hr />

<h2 id="sed编辑器">sed编辑器</h2>

<p>sed [-n] program [file-list]</p>

<p>sed [-n] –f program-file [file-list]</p>

<p>sed从指定文件或者标准输入中获取输入，将结果输出到标准输出。</p>

<p>sed程序写法：</p>

<p>[address[ ,address] ] instruction [argument-list]</p>

<hr />

<p>sed –n ‘3,6 p’ testfile #将testfile的3~6行打印</p>

<p>sed默认是显示所有的行，-n选项可以指定只显示选定的行，如果上述命令没有-n，那么testfile的3~6行将被打印两次。</p>

<p>sed也可以通过-f选项指定sed脚本</p>

<p>sed –f test.sh test.c #用test.sh脚本处理test.c</p>

<hr />

<p>sed –e:后面紧跟命令执行的脚本</p>

<p>sed –n –e ’3,6 p’ testfile #打印testfile的3~6行</p>

<hr />

<p>sed–i:将输出送入原来的输入文件，如果带有suffix，sed以原文件名加上后缀suffix备份原来的文件。</p>

<p>sed –i.bak –e ‘2,5 i\#abc’ testfile
#j将testfile的2~5行前面加#abc，输出到testfile，将原来的testfile的存储为testfile.bak</p>

<hr />

<ul>
<li>sed常用正则表达式</li>
</ul>

<p>！：选中没有匹配的行，sed‘/./ !d’表示删除所有空行</p>

<p>^:匹配行开头,^A表示以A开头的行</p>

<p>$:表示匹配行尾A$表示以A结尾的行。</p>

<p>&lt;: style=&ldquo;font-family:&lsquo;DejaVu Sans&rsquo;;&ldquo;&gt;匹配单词的左边界</p>

<p>&gt;:匹配单词的右边界，如\表示查找单词abc.</p>

<p>\(&hellip;\):标记匹配字符，如\(love\)被匹配，标记为1</p>

<p>sed ‘s/\(love\)\(.*\)/\1 you \2/’ test #在love后面加上you</p>

<hr />

<p>&amp;：表示正则表达式匹配到的值</p>

<p>*：匹配零个或多个先前字符，如a*，表示匹配任意个a，a.*表示a开头的所有文件（.*匹配任意多个非换行符字符）。</p>

<p>. ：句号“.”匹配一个任意非换行符字符</p>

<p>sed ‘s/^./\t&amp;/’ file #表达式（^.）匹配行首第一个字符不为空格的行，该命令对file中不以空格开头的行后移一个TAB字符。</p>

<hr />

<p>sed –i.$$ ‘s/<sup class="footnote-ref" id="fnref:a-z"><a href="#fn:a-z">1</a></sup>*[^a-z]$/\t&amp;/g’
file#将file中以字母开头并且不以字母结尾的行前面加一个TAB字符，写入输入文件，并将原输入文件以进程号为后缀重新保存。</p>

<hr />

<p>sed=file | sed ‘N;s/\n/\t/’ #给file加上行号</p>

<p>sed &rsquo;s/.$//&rsquo; #去掉非unix换行符的结尾</p>

<p>sed&rsquo;s/[ \t]*$//&rsquo; #将每一行拖尾的“空白字符”（空格，制表符）删除</p>

<p>sed&rsquo;s/<sup class="footnote-ref" id="fnref:t"><a href="#fn:t">2</a></sup><em>//;s/[ \t]</em>$//&rsquo; #将每一行中的前导和拖尾的空白字符删除</p>

<p>sed&rsquo;$!N; /^\(.*\)\n\1$/!P; D&rsquo; #只保留重复行中的第一行，其他行删除</p>

<hr />

<p>分析一下：sed ‘$!N;/^\(.*\)\n\1$/!P;D’：</p>

<p>N表示下一条指令输出当前的行，然后从输入中读入下一行，并且用下一条指令处理新读入的行。什么意思呢？</p>

<ol>
<li><p>首先在sed中有pattern区和hold区的区别，pattern区表示当前处理的区域，而hold相当于一个备用的缓冲区，N可以读入下一行到当前的pattern区，也就是所N选项可以对当下两行进行处理。注意的是对于文件最后一行，N的操作会不成功，因为没有下一行了。$!选择了除最后一行外的所有行。综上：$!N的意思就是读取两行到pattern区等待同一行的下一条命令进行处理。</p></li>

<li><p>；表示命令分割，所以N的下一条指令为’/^\(.<em>\)\n\1$/!P;’,这条命令中^表示行首匹配，\(.</em>\)将第一行中所有内容标记为1，匹配\n后进入第二行的内容，\1为前面匹配的第一行的内容，$匹配行尾。！取反匹配结果，即如果匹配成功选择的是第二行，匹配失败，选择第一行。大写的P表示打印一行内容，小写p打印整个pattern区两行内容，所以P和D都是对第二行的操作。</p></li>
</ol>

<ul>
<li>grep表达式</li>
</ul>

<p>grep的正则表达式和sed的用法基本一样。增加如下：</p>

<p>x\{m\}：重复字符x，m次，如：&rsquo;0\{5\}&lsquo;匹配包含5个o的行。</p>

<p>grep &lsquo;[a-z]\{5\}&rsquo; aa #显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p>

<p>find ./ -name “*.c”|xargs grep –i ‘\’ #在当前的文件夹c文件中查找字符串var</p>

<hr />

<p>sed和grep的正则表达式要作为重点来介绍</p>

<p>参考</p>

<p>_<a href="http://sed.sourceforge.net/sed1line_zh-CN.html_">http://sed.sourceforge.net/sed1line_zh-CN.html_</a></p>

<p><a href="http://man.chinaunix.net/newsoft/grep/open.htm">http://man.chinaunix.net/newsoft/grep/open.htm</a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:a-z">a-z <a class="footnote-return" href="#fnref:a-z"><sup>[return]</sup></a></li>
<li id="fn:t"> \t <a class="footnote-return" href="#fnref:t"><sup>[return]</sup></a></li>
</ol>
</div>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>