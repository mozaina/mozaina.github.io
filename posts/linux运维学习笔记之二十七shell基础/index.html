<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>Linux运维学习笔记之二十七Shell基础 | 开发者问答集锦</title>
    <meta property="og:title" content="Linux运维学习笔记之二十七Shell基础 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="Linux运维学习笔记之二十七Shell基础">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/linux%E8%BF%90%E7%BB%B4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E5%8D%81%E4%B8%83shell%E5%9F%BA%E7%A1%80/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">Linux运维学习笔记之二十七Shell基础</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>###</p>

<h3 id="第三十九章-shell基础">第三十九章 Shell基础</h3>

<h4 id="一-学好shell编程的基础必备-练-想-再练-再想">一、学好Shell编程的基础必备（练、想、再练、再想）</h4>

<h5 id="1-vi-vim编辑器的熟练使用-ssh终端及-vimrc-的设置等需要熟练">1、vi/vim编辑器的熟练使用，SSH终端及&rdquo;.vimrc&rdquo;的设置等需要熟练</h5>

<h5 id="2-命令基础-linux的150个常用命令的熟练使用">2、命令基础：Linux的150个常用命令的熟练使用</h5>

<h5 id="3-常见linux网络服务部署及排错-如crond-nfs-rsync-inotify-lanmp-sersync-ssh等">3、常见Linux网络服务部署及排错。如crond、nfs、rsync、inotify、lanmp、sersync、ssh等</h5>

<h5 id="4-基本语法-敲n-1遍-为什么不是n遍那-因为n遍是你刚开始为了编程而努力的几天-也就是说要每天都要写写想想-至少是要看看">4、基本语法，敲n+1遍。为什么不是n遍那，因为n遍是你刚开始为了编程而努力的几天，也就是说要每天都要写写想想，至少是要看看。</h5>

<h5 id="5-各种基本语法-if多种判断都要会-这样做不是为了什么都要学而是为了看懂别人的代码-这个要写一段时间-各种都用">5、各种基本语法，if多种判断都要会，这样做不是为了什么都要学而是为了看懂别人的代码。 这个要写一段时间，各种都用。</h5>

<h5 id="6-解决上边说的问题-各种语法都要学的问题-现在是不要做各种语法的程序-与上边相反-形成自己风格-if用一种">6、解决上边说的问题，各种语法都要学的问题，现在是不要做各种语法的程序，与上边相反，形成自己风格，if用一种。</h5>

<h5 id="7-从简单做起-简单判断-简单循环">7、从简单做起，简单判断，简单循环.</h5>

<h5 id="8-多找几个例子分析一下-不要光看-会了-当你闭上眼睛时候-你还能写出来吗">8、多找几个例子分析一下，不要光看，会了。当你闭上眼睛时候，你还能写出来吗？</h5>

<h5 id="9-对于问题分析形成编程思维-就是如果要用到编程的问题-脚本的问题-能不能脑子里首先把大问题分解">9、对于问题分析形成编程思维，就是如果要用到编程的问题，脚本的问题，能不能脑子里首先把大问题分解。</h5>

<p>例如关闭不需要服务的脚本，对于这句话的理解分析：</p>

<p>关闭服务首先命令：chkconfig 服务名 &ndash;level 345 off</p>

<p>然后服务时多个：多个要用多条，但是分析以上命令出来服务名不同其他都一样，那就会想到循环。</p>

<p>你自己看到这句话能想到这些吗，当你想到了，你的思维就形成了初级的编程思维。</p>

<p>当你看到很大一个问题，然后能分析到一个一个单元，但到大的方面，函数，然后是判断，</p>

<p>循环，然后是命令组合.</p>

<p>你就会了编程，一般的问题，只要让你在机器上调试，就能写出来。</p>

<h5 id="10-编程变量名字规范-驼峰表示-ipttmpasdfdd">10、编程变量名字规范，驼峰表示，iptTmpAsdfDd</h5>

<p>#####
11、初期时候，不要去看大的脚本，要从小问题，从小方面，当你觉得小的方面就是判断，循环等在你脑子里瞬间就能出来时候，在开始大方面。初期最好的学习方法就是多敲和分解问题练习。</p>

<h5 id="12-最高的编程自我感觉是">12、最高的编程自我感觉是：</h5>

<p>问题分析分解快速完整。</p>

<p>完整性：就是判断出各种可能性。</p>

<p>高效率，高性能，1+2+3&hellip;+100 =(1+100)*(<sup>100</sup>&frasl;<sub>2</sub>)/2</p>

<h4 id="二-shell概述">二、Shell概述</h4>

<h5 id="1-查看linux系统支持的shell">1、查看Linux系统支持的Shell</h5>

<p>cat /etc/shells</p>

<p>/bin/sh</p>

<p>/bin/bash</p>

<p>/sbin/nologin</p>

<p>/bin/dash</p>

<p>/bin/tcsh</p>

<p>/bin/csh</p>

<p>/bin/zsh</p>

<p>/bin/ksh</p>

<p>/bin/mksh</p>

<h5 id="2-查看linux系统默认shell">2、查看Linux系统默认Shell</h5>

<h6 id="1-方法一">（1）方法一</h6>

<p>echo $SHELL</p>

<p>/bin/bash</p>

<h6 id="2-方法二">（2）方法二</h6>

<p>grep root /etc/passwd</p>

<p>root:x:0:0:root:/root:/bin/bash</p>

<h5 id="3-查看shell版本">3、查看shell版本</h5>

<p>bash &ndash;version</p>

<p>GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu)</p>

<h5 id="4-sh和bash的区别">4、sh和bash的区别</h5>

<p>ls -l /bin/sh</p>

<p>lrwxrwxrwx. 1 root root 4 Nov 4 11:57 /bin/sh -&gt; bash</p>

<p><strong>说明： sh是bash的软链接</strong></p>

<h5 id="5-shell脚本格式">5、Shell脚本格式</h5>

<h6 id="1-脚本开头-第一行">（1）脚本开头（第一行）</h6>

<p>规范的shell脚本的第一行会指出由哪个程序（解释器）来执行脚本中的内容，在Linux bash编程中一般为：</p>

<p>#!/bin/bash或#!/bin/sh</p>

<p>其中开头的&rdquo;#!&ldquo;称为幻数，在执行bash脚本的时候，内核会根据&rdquo;#!&ldquo;后的解释器来确定由哪个程序来解释脚本中的内容。</p>

<h6 id="2-格式">（2）格式</h6>

<p>一般来说Linux
的系统脚本都是以#!/bin/bash开头，而其它软件的脚本开头就是要看开发者的习惯了，有的以#!/bin/bash开头，有的以#!/bin/sh开头</p>

<h6 id="3-注意事项">（3）注意事项</h6>

<p>这一行必须在每个脚本的顶端第一行，要在255个字符以内。写在其它行了就是注释了。</p>

<p>CentOS和RedHat默认的shell均是bash，因此，在写shell脚本的时候，在脚本的第一行也可以不加&rdquo;#!/bin/bash&rdquo;，但如果当前系统默认的shell不是bash时，那么就必须要写#！了。否则脚本的执行结果可能就不是想要的。所以最好的编程习惯，就是不管什么脚本都加上开头语言标识“#！/bin/bash”.</p>

<h6 id="4-脚本注释">（4）脚本注释</h6>

<p>在shell脚本中，跟在&rdquo;#&ldquo;后面的内容表示注释。可以单独自成一行，也可跟在命令后，与命令在同一行。一定要有良好的写注释的习惯，因为注释不仅方便他人，也方便自己，防止时间久了，忘记代码意思。</p>

<h6 id="5-示例">（5）示例</h6>

<p>head -1 /etc/rc.d/rc.sysinit</p>

<p>#!/bin/bash</p>

<p>head -1 /etc/init.d/nfs</p>

<p>#!/bin/sh</p>

<p><strong>建议用标准写法： #!/bin/bash</strong></p>

<h5 id="6-shell脚本的执行">6、Shell脚本的执行</h5>

<p>当shell脚本以非交互的方式运行时，它会先查找环境变量ENV，该变量指定了一个环境文件（通常是.bashrca、.bash_profile、/etc/bashrc、/etc/profile等文件），然后从该环境变量文件开始执行，当读取了ENV文件后，shell程序才开始执行shell脚本中的内容。</p>

<p><strong>例外是： crond任务中，需把用到的环境变量要在脚本中重新定义，因为crond中可以识别的环境变量很少。</strong></p>

<h6 id="1-执行方法">（1）执行方法</h6>

<p>a、方法一：指定bash解释器执行（推荐方法）</p>

<p>bash script-name或shscript-name</p>

<p>b、方法二：全路径或./当前路径下执行</p>

<p>/path/script-name或./script-name</p>

<p>c、方法三：source命令或&rdquo;. &ldquo;执行（注意.后面有空格）</p>

<p>source script-name或.script-name</p>

<h6 id="2-三种方法的区别">（2）三种方法的区别</h6>

<p>a、方法一指定bash解释器执行时，不需要脚本文件有+x的可执行权限。通过bash解释器，可直接执行。</p>

<p>b、方法二全路径或当前路径执行时，脚本文件必须要有+x的可执行权限。</p>

<p>c、方法三source命令或&rdquo;. &ldquo;执行时，不需要脚本文件有+x的可执行权限。</p>

<p>d、第三种方法与前2种方法的主要区别</p>

<p>通过source命令或&rdquo;.
&ldquo;执行时，可以把该脚本中的变量或函数带到当前shell中，也就是就是会将结果加入当前环境变量中，让当前shell可以正常引用。（可以这样理解：正常的shell脚本执行相当于函数的内部局部变量，函数执行完后，局部变量的作用空间就结束了，而source或&rdquo;.
&ldquo;执行时相当于将局部变量变为了全局变量）</p>

<p>所以系统的脚本中全部是用的source命令或&rdquo;. &ldquo;来执行的</p>

<p>cat /etc/init.d/nfs</p>

<p>#!/bin/sh</p>

<p>。。。</p>

<h1 id="source-function-library">Source function library.</h1>

<p><strong>./etc/rc.d/init.d/functions</strong></p>

<h6 id="3-示例1">（3）示例1</h6>

<p>cat test.sh</p>

<p>user=<code>whoami</code></p>

<p>cat zhixi.sh</p>

<p>sh test.sh</p>

<p>echo $user</p>

<p>sh zhixi.sh的执行结果是什么？</p>

<p>解答：返回结果为空</p>

<h6 id="4-示例2">（4）示例2</h6>

<p>[ryan@test ~]$ cat test.sh</p>

<p>user=<code>whoami</code></p>

<p>[ryan@test ~]$ sh test.sh &amp;&amp; echo $user的执行结果是什么？</p>

<p>解答：返回结果为空</p>

<p>因为sh
test.sh只是执行了这个文件，不会将user引入当前环境变量，只有用点&rdquo;.&ldquo;或source命令执行过的脚本，在脚本结束后脚本中的变量（包括函数）值在当前shell中依然存在，也就是会将结果加入当前环境变量中，而sh和bash则不行，脚本执行完后变量就丢弃了。本题中sh
test.sh执行完后只是把当前用户ryan赋给了user，并没有把user=ryan加入到当前环境变量中，所以echo $user的值为空。</p>

<p>如果用. test.sh &amp;&amp; echo $user或source test.sh &amp;&amp; echo $user来执行，则结果为ryan。</p>

<h6 id="5-示例3">（5）示例3</h6>

<p>vi 3.sh</p>

<p>#!/bin/sh</p>

<p>source /etc/init.d/functions</p>

<p>action &ldquo;This is my Linux Study&rdquo; /bin/true</p>

<p>sh 3.sh</p>

<p>This is my Linux Study [ OK ]</p>

<h6 id="6-示例4">（6）示例4</h6>

<p>vi /etc/init.d/functions</p>

<p>#以结尾加入自定义函数mytestFun()</p>

<p>mytestFun(){</p>

<p>echo &ldquo; This is myLinux Study! bye! &ldquo;</p>

<p>}</p>

<p>echo mytestFun &gt;&gt; 3.sh</p>

<p>sh 3.sh</p>

<p>This is my Linux Study [ OK ]</p>

<p>This is my Linux Study! bye!</p>

<h5 id="7-shell脚本的基本开发规范及习惯">7、Shell脚本的基本开发规范及习惯</h5>

<h6 id="1-开头指定脚本解释器">（1）开头指定脚本解释器</h6>

<p>#!/bin/bash或#!/bin/sh</p>

<h6 id="2-开头加版本版权等信息">（2）开头加版本版权等信息</h6>

<p>#Date：21:32 2017-05-03</p>

<p>#Author: Created by myName</p>

<p>#Mail: 12345678@aaa.com</p>

<p>#Function: This scripts function is &hellip;.</p>

<p>#Version: 1.1</p>

<p><strong>提示：也可以在配置 vim编辑文件时自动加上以上信息，方法是修改~/.vimrc配置文件</strong></p>

<h6 id="3-脚本中不要用中文注释">（3）脚本中不要用中文注释</h6>

<h6 id="4-脚本要以-sh为扩展名">（4）脚本要以.sh为扩展名</h6>

<h6 id="5-规范代码书写">（5）规范代码书写</h6>

<p>a、成对的内容要一次写出来，防止遗漏。</p>

<p>如{}、[]、&rdquo;、&rdquo;&ldquo;等。</p>

<p>b、中括号&rdquo;[]&ldquo;内两端要有空格。</p>

<p>在书写中括号&rdquo;[]&ldquo;时，可先留出空格[ ]，然后在退格到中括号内书写内容。</p>

<p>c、流程控制语句要按格式一次书写完，再添加内容。</p>

<p>（i）if语句格式</p>

<p>if 条件内容</p>

<p>then</p>

<p>内容</p>

<p>fi</p>

<p>（i）for语句格式</p>

<p>for</p>

<p>do</p>

<p>内容</p>

<p>done</p>

<p>（iii）while、until、case等语句也是一样</p>

<h6 id="6-通过缩进让代码易读">（6）通过缩进让代码易读</h6>

<h4 id="三-shell变量">三、Shell变量</h4>

<h5 id="1-变量分类">1、变量分类</h5>

<p>变量可分为2类：环境变量（全局变量）和局部变量（本地变量）。</p>

<p>环境变量可以在创建他们的shell及其派生出来的任意子进程shell中使用。局部变量只能在创建他们的shell函数或脚本中使用。</p>

<p>命名规范：</p>

<p>一般是字母、数字、下划线组成，必须以字母开头。</p>

<p>语义要清晰，能够正确表达变量内容的含义，过长的英文单词可采用前几个字符代替。多个单词用&rdquo;_&ldquo;连接。</p>

<p>避免无含义的字符或数字。</p>

<h5 id="2-环境变量">2、环境变量</h5>

<h6 id="1-概念">（1）概念</h6>

<p>环境变量用于定义Shell的运行环境，保证Shell命令的正确执行。所有环境变量都是系统全局变量，可用于所有子进程中。</p>

<p>环境变量可以在命令行中设置，但用户退出时这些变量值也会丢失，因此，最好在用户Home目录下的.bash_profile或全局配置文件/etc/bashrc、/ect/profile，还可以将定义文件放在/etc/profile.d/目录下定义，在每次用户登录时将其初始化。</p>

<p>根据规范，所有环境变量应均为大写。在用于用户进程前，必须用export命令抛出。</p>

<p>使用习惯：一般数字不加引号，其它默认加双引号。</p>

<h6 id="2-查看系统所有环境变量">（2）查看系统所有环境变量</h6>

<p>a、env命令查看</p>

<p>[root@lamp scripts]# env</p>

<p>HOSTNAME=lamp</p>

<p>TERM=linux</p>

<p>SHELL=/bin/bash</p>

<p>HISTSIZE=1000</p>

<p>。。。</p>

<p>b、set命令查看</p>

<p>[root@lamp scripts]# set</p>

<p>BASH=/bin/bash</p>

<p>&hellip;</p>

<p>HISTCONTROL=ignoredups</p>

<p>HISTFILE=/root/.bash_history</p>

<p>HISTFILESIZE=1000</p>

<p>&hellip;</p>

<h6 id="3-临时生效自定义环境变量">（3）临时生效自定义环境变量</h6>

<p>a、export命令设置</p>

<p>变量名=value; export 变量名</p>

<p>或</p>

<p>export 变量名=value</p>

<p>b、declare -x命令设置</p>

<p>declare -x变量名=value</p>

<p>c、示例</p>

<p>abc=20</p>

<p>export abc</p>

<p>export abd=30</p>

<p>declare -x abe=40</p>

<h6 id="4-永久生效自定义环境变量-别名alias也是一样">（4）永久生效自定义环境变量（别名alias也是一样）</h6>

<p>a、全局生效（所有用户）</p>

<p>vi /etc/profile 或 vi /etc/bashrc</p>

<p>export abc = 20</p>

<p>b、当前用户生效</p>

<p>vi ~/.bashrc 或 vi ~/.bash_profile</p>

<p>export abc = 20</p>

<h6 id="5-etc-profile-d-方式定义环境变量">（5）/etc/profile.d/方式定义环境变量</h6>

<p>vi /etc/profile.d/test.sh</p>

<p>echo &ldquo;Thisis /etc/profile.d/test.sh&hellip;.&rdquo;</p>

<p>exportTEST_ABC=30</p>

<p>chmod +x /etc/profile.d/test.sh</p>

<p>logout</p>

<p>回车登入</p>

<p>Last login: SatMay 6 11:53:28 2017 from 192.168.1.11</p>

<p>This is/etc/profile.d/test.sh&hellip;.</p>

<p>[root@lamp ~]#echo $TEST_ABC</p>

<p>30</p>

<h6 id="6-显示和取消环境变量">（6）显示和取消环境变量</h6>

<p>a、通过echo命令打印环境变量</p>

<p>echo $HOME</p>

<p>/root</p>

<p>echo $UID</p>

<p>0</p>

<p>echo $PWD</p>

<p>/root</p>

<p>echo $SHELL</p>

<p>/bin/bash</p>

<p>echo $USER</p>

<p>root</p>

<p>b、通过printf命令打印环境变量（需在结尾加\n，显示的格式比echo丰富）</p>

<p>printf &ldquo;$HOME\n&rdquo;</p>

<p>/root</p>

<p>c、通过unset命令取消环境变量（此时不要带$）</p>

<p>echo $TEST_ABC</p>

<p>30</p>

<p>unset TEST_ABC #不能加$</p>

<p>echo $TEST_ABC #值为空</p>

<h5 id="3-局部变量">3、局部变量</h5>

<h6 id="1-概念-1">（1）概念</h6>

<p>局部变量又称本地变量，只在用户当前的Shell生存期的脚本中使用。如果在Shell中启动另一个进程或退出，则本地变量的值将无效。</p>

<h6 id="2-定义局部变量">（2）定义局部变量</h6>

<p>a、普通字符串变量定义</p>

<p>变量名=value</p>

<p>变量名=&lsquo;value&rsquo;</p>

<p>变量名=&ldquo;value&rdquo;</p>

<p>b、命令变量定义</p>

<p>变量名=``</p>

<p>变量名=$()</p>

<p>c、函数中变量定义</p>

<p>local 变量名</p>

<p>local 变量名=value</p>

<p>一定要用local方式进行声明，使之只在本函数作用域内有效，防止变量在函数中命名与变量外部程序中变量重名，造成程序异常。</p>

<h6 id="3-示例1-命令行输入下列命令返加什么结果">（3）示例1：命令行输入下列命令返加什么结果</h6>

<p>题干：</p>

<p>a=192.168.1.2</p>

<p>b=&lsquo;192.168.1.2&rsquo;</p>

<p>c=&ldquo;192.168.1.2&rdquo;</p>

<p>echo &ldquo;a=$a&rdquo;</p>

<p>echo &ldquo;b=$b&rdquo;</p>

<p>echo &ldquo;c=${c}&rdquo;</p>

<p>提示：</p>

<p>$c与${c}在这里是等同的</p>

<p>解答：</p>

<p>a=192.168.1.2</p>

<p>b=192.168.1.2</p>

<p>c=192.168.1.2</p>

<p>小结：</p>

<p>将连接普通字符串的内容赋值给变量，打印变量时，是原样输出。</p>

<h6 id="4-示例2-命令行输入下列命令返加什么结果">（4）示例2：命令行输入下列命令返加什么结果</h6>

<p>题干：</p>

<p>a=192.168.1.2-$a</p>

<p>b=&lsquo;192.168.1.2-$a&rsquo;</p>

<p>c=&ldquo;192.168.1.2-$a&rdquo;</p>

<p>echo &ldquo;a=$a&rdquo;</p>

<p>echo &ldquo;b=$b&rdquo;</p>

<p>echo &ldquo;c=${c}&rdquo;</p>

<p>解答：</p>

<p>a=192.168.1.2-192.168.1.2</p>

<p>b=192.168.1.2-$a</p>

<p>c=192.168.1.2-192.168.1.2-192.168.1.2</p>

<p>小结：</p>

<p>单引号“&rsquo;”是原样输出，不论引号内有什么，即使引号有变量，也会把变量名原样输出。适用于定义纯字符串。</p>

<p>双引号““”中的内容是会被解析的，将引号中的变量解析成该变量的内容结果输出。适用于字符串中附带有变量的内容的定义。</p>

<h5 id="4-单引号-双引号和无引号的区别">4、单引号、双引号和无引号的区别</h5>

<h6 id="1-单引号">（1）单引号</h6>

<p>所见即所得，将单引号内的所有内容都不解析，原样输出。</p>

<h6 id="2-双引号">（2）双引号</h6>

<p>输出比引号中的所有内容。如果引号中有命令（反引号中）、变量、特殊转义符等，就会先解析变量，将解析结果输出到最终内容中。</p>

<h6 id="3-无引号">（3）无引号</h6>

<p>类似于双引号，把解析结果输出到最终内容中，但如果字符串中带有空格等特殊字符，则不能完整的输出，需要加上双引号。最好用双引号代替无引号。一般脚本中单纯的数字可以不加引号，普通字符串尽量用双引号。</p>

<h6 id="4-注意事项">（4）注意事项</h6>

<p>对某些语言不适合，如awk内部就有特殊规定（单、双引号正好与shell中相反）。</p>

<h6 id="5-示例1-awk调用数据型shell变量">（5）示例1：awk调用数据型shell变量</h6>

<p>[root@mysqldb scripts]# ETT=123</p>

<p>[root@mysqldb scripts]# echo $ETT</p>

<p>123</p>

<p>[root@mysqldb scripts]# awk &lsquo;BEGIN {print &ldquo;$ETT&rdquo;}&rsquo;</p>

<p>$ETT <strong>没有调用 shell变量</strong></p>

<p>[root@mysqldb scripts]# awk &lsquo;BEGIN {print &lsquo;$ETT&rsquo;}&rsquo;</p>

<p>123 ** 正确调用shell变量**</p>

<p>[root@mysqldb scripts]# awk &lsquo;BEGIN {print $ETT}&rsquo;</p>

<p><strong>结果为空</strong></p>

<p>[root@mysqldb scripts]#</p>

<h6 id="6-示例2-awk调用字符型shell变量">（6）示例2：awk调用字符型shell变量</h6>

<p>[root@mysqldb scripts]# ETT=&lsquo;abc&rsquo;</p>

<p>[root@mysqldb scripts]# echo $ETT</p>

<p>abc</p>

<p>[root@mysqldb scripts]# awk &lsquo;BEGIN {print &ldquo;$ETT&rdquo;}&rsquo;</p>

<p>$ETT <strong>没有调用 shell变量</strong></p>

<p>[root@mysqldb scripts]# awk &lsquo;BEGIN {print &lsquo;$ETT&rsquo;}&rsquo;</p>

<p><strong>结果为空</strong></p>

<p>[root@mysqldb scripts]# awk &lsquo;BEGIN {print $ETT}&rsquo;</p>

<p><strong>结果为空</strong></p>

<p>[root@mysqldb scripts]# awk &lsquo;BEGIN {print &ldquo;&rsquo;$ETT&rsquo;&rdquo;}&rsquo;</p>

<p>abc ** 正确调用shell变量**</p>

<p>[root@mysqldb scripts]#</p>

<h5 id="5-shell特殊变量">5、Shell特殊变量</h5>

<h6 id="1-位置变量">（1）位置变量</h6>

<p>a、$0：获取当前执行的shell脚本的文件名，如果执行脚本带路径，则包含脚本路径。</p>

<p>（i）示例1</p>

<p>cat 1.sh</p>

<p>echo $0</p>

<p>sh 1.sh</p>

<p>1.sh</p>

<p>sh $(pwd)/1.sh</p>

<p>/wddg/scripts/1.sh</p>

<p>（ii）示例2</p>

<p>cat 2.sh</p>

<p>echo &lsquo;$0 = &lsquo;$0</p>

<p>echo &lsquo;dirname =&rsquo;$(dirname $0)</p>

<p>echo &lsquo;basename =&rsquo;$(basename $0)</p>

<p>sh $(pwd)/2.sh</p>

<p>$0 = /wddg/scripts/2.sh</p>

<p>dirname =/wddg/scripts</p>

<p>basename = 2.sh</p>

<p>b、$n：获取当前执行的shell脚本的第n个参数值，n&gt;1，如果n&gt;9时，则需用大括号括起来，如${10}。</p>

<p>（i）示例1</p>

<p>cat 3.sh</p>

<p>echo $1</p>

<p>sh 3.sh</p>

<p><strong>没有参数，结果为空</strong></p>

<p>sh 3.sh aaa</p>

<p>aaa <strong>正确返回第一个参数</strong></p>

<p>sh 3.sh aaa bbb</p>

<p>aaa <strong>正确返回第一个参数，第二个参数没有接收</strong></p>

<p>sh 3.sh &ldquo;aaa bbb&rdquo;</p>

<p>aaa bbb <strong>双引号内为一个参数</strong></p>

<p>（ii）示例2</p>

<p>echo $(echo -n &lsquo;echo $1&rsquo; &amp;&amp; echo &lsquo; $&rsquo;{2..15}) &gt; 4.sh</p>

<p>cat 4.sh</p>

<p>echo $1 $2 $3 $4$5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15</p>

<p>sh 4.sh {a..z}</p>

<p>a b c d e f g hi a0 a1 a2 a3 a4 a5 <strong>开始不正确，显示为 ($1)0了。</strong></p>

<p>echo $(echo -n &lsquo;echo $1&rsquo; &amp;&amp; echo -n &lsquo; $&rsquo;{2..9} &amp;&amp;echo &lsquo; ${&rsquo;{10..15}&lsquo;}&rsquo;) &gt;4.sh</p>

<p>cat 4.sh</p>

<p>echo $1 $2 $3 $4$5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15}</p>

<p>sh 4.sh {a..z}</p>

<p>a b c d e f g hi j k l m n o <strong>正确返回</strong></p>

<p>c、$#：获取当前执行的shell命令行中参数的总个数。</p>

<p>（i）示例1</p>

<p>echo &lsquo;echo $#&rsquo; &gt; 5.sh</p>

<p>cat 5.sh</p>

<p>echo $#</p>

<p>sh 5.sh {a..z}</p>

<p>26</p>

<p>（ii）示例2</p>

<p>cat &gt; 6.sh</p>

<p>[ $# -ne 2 ]&amp;&amp; {</p>

<p>echo &ldquo;musetwo&rdquo;</p>

<p>exit 1</p>

<p>}</p>

<p>echo &lsquo;OK&rsquo;</p>

<p>^C ****</p>

<p>[root@mysqldb scripts]# cat 6.sh</p>

<p>[ $# -ne 2 ]&amp;&amp; {</p>

<p>echo &ldquo;musetwo&rdquo;</p>

<p>exit 1</p>

<p>}</p>

<p>echo &lsquo;OK&rsquo;</p>

<p>sh 6.sh</p>

<p>muse two</p>

<p>sh 6.sh aaa bbb</p>

<p>OK</p>

<p>sh 6.sh aaa bbb ccc</p>

<p>muse two</p>

<p>d、$*：获取当前执行的shell的所有参数，但将命令行的所有参数视为一个字符串。相当于&rdquo;$1$2$3..&ldquo;。</p>

<p>e、$@：获取当前执行的shell的所有参数，是将命令行的所有参数视为一个个的单个个体，以&rdquo;$1&rdquo;&ldquo;$2&rdquo; &ldquo;$3&rdquo;
&ldquo;$4&rdquo;&hellip;形式获取，这是将参数传递给其它程序的最佳方式。</p>

<p>f、$*与$@的区别</p>

<p>（i）示例1：有双引号</p>

<p>set &ndash; &ldquo;I am&rdquo; handsome test <strong>以 set方式来模拟传入3个参数</strong></p>

<p>echo $#</p>

<p>3 <strong>当前共传入 3个参数</strong></p>

<p>for i in &ldquo;$*&ldquo;;do echo $i;done</p>

<p>I am handsometest <strong>将 3个参数视为1个参数</strong></p>

<p>for i in &ldquo;$@&rdquo;;do echo $i;done</p>

<p>I am <strong>个参数还是认为是 3个参数</strong></p>

<p>handsome</p>

<p>test</p>

<p>（ii）示例2：无引号（$*与$@效果一样）</p>

<p>for i in $@;do echo $i;done</p>

<p>I</p>

<p>am <strong>将第 1个参数“I am”也折分了</strong></p>

<p>handsome</p>

<p>test</p>

<p>for i in $*;do echo $i;done</p>

<p>I</p>

<p>am</p>

<p>handsome</p>

<p>test</p>

<p>g、课外作业-看懂参考博27：linux下set和eval的使用小案例精彩解答</p>

<p>网址:<a href="http://oldboy.blog.51cto.com/2561410/1175971">http://oldboy.blog.51cto.com/2561410/1175971</a></p>

<h6 id="2-进程状态变量">（2）进程状态变量</h6>

<p>a、$$：获取当前Shell的进程号（PID）</p>

<p>（i）作用</p>

<p>获取当前Shell的进程号，在企业应用中场景是如果某个脚本只能运行一个进程时，在启动时，需自动kill以前运行的进程。</p>

<p>（ii）示例1</p>

<p>sh 6.sh aaa bbb ccc</p>

<p>muse two</p>

<p>echo $$</p>

<p>2066</p>

<p>（iii）示例2</p>

<p>vi pid.sh</p>

<p>#!/bin/sh</p>

<p>pidpath=/tmp/a.pid</p>

<p>if [ -f&rdquo;$pidpath&rdquo; ]</p>

<p>then</p>

<p>kill -USR2 <code>cat $pidpath</code></p>

<p>rm -f $pidpath</p>

<p>fi</p>

<p>echo $$ &gt;$pidpath</p>

<p>sleep 300</p>

<p>b、$!：上一个指令的PID</p>

<p>c、$?：获取上一个指令执行后的返回值（0表示成功，非0表示失败）</p>

<p>（i）示例1</p>

<p>sh 6.sh aaa bbb</p>

<p>OK</p>

<p>echo $?</p>

<p>0</p>

<p>（ii）示例2</p>

<p>su - mysql</p>

<p>ls /root</p>

<p>ls: cannot opendirectory /root: Permission denied</p>

<p>echo $?</p>

<p>2</p>

<p>（iii）返回值参考</p>

<p>返回值</p>

<p>|</p>

<p>表达意义</p>

<p>&mdash;|&mdash;</p>

<p>0</p>

<p>|</p>

<p>运行成功</p>

<p>1-125</p>

<p>|</p>

<p>运行失败。原因多种多样，如命令错误或参数传递错误、权限拒绝Permission denied等</p>

<p>126</p>

<p>|</p>

<p>找到命令，但无法执行</p>

<p>127</p>

<p>|</p>

<p>没有找到命令</p>

<blockquote>
<p>128</p>
</blockquote>

<p>|</p>

<p>命令被系统强制结束。如命令在执行过程中被Ctrl+C中止</p>

<p>d、$_：在此之前扫行的命令或脚本的最后一个参数</p>

<p>sh 6.sh aaa bbb ccc</p>

<p>muse two</p>

<p>echo $_</p>

<p>ccc</p>

<h6 id="3-移动位置变量的命令shift">（3）移动位置变量的命令shift</h6>

<p>a、说明</p>

<p>将后面的变量位置依次往前移动。不指定位移量的默认情况下每次前移1个位置。</p>

<p>每执行一次shift命令，都会使所有位置的参数依次向左移动1个位置（默认），并使位置参数$#减1，直至0为止。</p>

<p>作用：就是方便。</p>

<p>b、查看帮助</p>

<p>help shift</p>

<p>shift: shift [n]</p>

<p>Shift positionalparameters.</p>

<p>Rename the positionalparameters $N+1,$N+2 &hellip; to $1,$2 &hellip; IfN is</p>

<p>not given, it is assumedto be 1.</p>

<p>Exit Status:</p>

<p>Returns success unless Nis negative or greater than $#.</p>

<p>c、示例1</p>

<p>for i in &ldquo;$@&rdquo;;do echo $i;done</p>

<p>I am</p>

<p>handsome</p>

<p>test</p>

<p>shift</p>

<p>for i in &ldquo;$@&rdquo;;do echo $i;done</p>

<p>handsome</p>

<p>test</p>

<p>shift</p>

<p>for i in &ldquo;$@&rdquo;;do echo $i;done</p>

<p>test</p>

<p>d、示例2：查看ssh-copy-id命令内容，学习shift命令使用</p>

<p>cat $(which ssh-copy-id)</p>

<p>。。。</p>

<p>if [ &ldquo;-i&rdquo; = &ldquo;$1&rdquo; ]; then</p>

<p><strong>shift</strong></p>

<h1 id="check-if-we-have-2parameters-left-if-so-the-first-is-the-new-id-file">check if we have 2parameters left, if so the first is the new ID file</h1>

<p>if [ -n &ldquo;$2&rdquo; ];then</p>

<p>if expr &ldquo;$1&rdquo; :&ldquo;.*\.pub&rdquo; &gt; /dev/null ; then</p>

<p>ID_FILE=&ldquo;$1&rdquo;</p>

<p>else</p>

<p>ID_FILE=&ldquo;$1.pub&rdquo;</p>

<p>fi</p>

<p><strong>shift</strong> # and this should leave $1 as the targetname</p>

<p>fi</p>

<p>else</p>

<p>if [ x$SSH_AUTH_SOCK != x ]; then</p>

<p>GET_ID=&ldquo;$GET_IDssh-add -L&rdquo;</p>

<p>fi</p>

<p>fi</p>

<h5 id="6-shell内置命令">6、Shell内置命令</h5>

<p>alias, bg, bind, break,builtin, caller, cd, command, compgen, complete,
compopt,</p>

<p>continue, declare, dirs, disown,echo, enable, eval, exec, exit,export, false,
fc, fg,</p>

<p>getopts, hash, help, history, jobs, kill, let, local, logout, mapfile,
popd,printf, pushd, pwd,read, readonly, return, set, shift, shopt, source,
suspend, test, times, trap,true, type, typeset, ulimit, umask,unalias, unset,
wait</p>

<h4 id="四-字符串操作">四、字符串操作</h4>

<h5 id="1-字符串操作列表-长度-读取-替换-是从开头开始-是从结尾开始匹配">1、字符串操作列表（长度，读取，替换，#是从开头开始，%是从结尾开始匹配）</h5>

<p><strong>表达式</strong></p>

<p>|</p>

<p><strong>含义</strong></p>

<p>&mdash;|&mdash;</p>

<p>${#string}</p>

<p>|</p>

<p>$string的长度</p>

<p>${string:position}</p>

<p>|</p>

<p>在$string中, 从位置$position开始提取子串（从0开始，类似cut -c）</p>

<p>${string:position:length}</p>

<p>|</p>

<p>在$string中, 从位置$position开始提取长度为$length的子串</p>

<p>${string#substring}</p>

<p>|</p>

<p>从变量$string的开头, 删除最短匹配$substring的子串</p>

<p>${string##substring}</p>

<p>|</p>

<p>从变量$string的开头, 删除最长匹配$substring的子串</p>

<p>${string%substring}</p>

<p>|</p>

<p>从变量$string的结尾, 删除最短匹配$substring的子串</p>

<p>${string%%substring}</p>

<p>|</p>

<p>从变量$string的结尾, 删除最长匹配$substring的子串</p>

<p>${string/substring/replacement}</p>

<p>|</p>

<p>使用$replacement, 来代替第一个匹配的$substring</p>

<p>${string//substring/replacement}</p>

<p>|</p>

<p>使用$replacement, 代替所有匹配的$substring</p>

<p>${string/#substring/replacement}</p>

<p>|</p>

<p>如果$string的前缀匹配$substring, 就用$replacement来代替匹配到的$substring</p>

<p>${string/%substring/replacement}</p>

<p>|</p>

<p>如果$string的后缀匹配$substring, 就用$replacement来代替匹配到的$substring</p>

<h5 id="2-演示示例">2、演示示例</h5>

<p>TEST=&ldquo;This is a cup&rdquo;</p>

<p>echo ${TEST}</p>

<p>This is a cup</p>

<h5 id="3-示例1-获取字符串长度">3、示例1：获取字符串长度</h5>

<h6 id="string">（1）方法一：$</h6>

<p>echo ${#TEST}</p>

<p>13</p>

<h6 id="2-方法二-wc-l">（2）方法二：wc -L</h6>

<p>echo $TEST | wc -L</p>

<p>13 <strong>最准确</strong></p>

<p>echo $TEST | wc -c</p>

<p>14 <strong>按字节，多 1位</strong></p>

<p>echo $TEST | wc -m</p>

<p>14 <strong>按字符，多 1位</strong></p>

<h5 id="4-示例2-截取子串">4、示例2：截取子串</h5>

<h6 id="1-方法一-string-position-起始位置为0">（1）方法一：${string:position}，起始位置为0</h6>

<p>a、从第2个位置开始截取到结尾</p>

<p>echo ${TEST:2}</p>

<p>is is a cup</p>

<p>b、从第2个位置开始截取2个字符</p>

<p>echo ${TEST:2:2}</p>

<p>is</p>

<p>c、从第2个位置开始截取4个字符</p>

<p>echo ${TEST:2:4}</p>

<p>is i</p>

<h6 id="2-方法二-cut-c-起始位置为1">（2）方法二：cut -c，起始位置为1</h6>

<p>a、从第2个位置开始截取到结尾</p>

<p>echo $TEST | cut -c 2-</p>

<p>his is a cup</p>

<p>b、从第2个位置开始截取2个字符</p>

<p>echo $TEST | cut -c 2-4</p>

<p>his</p>

<p>c、从第2个位置开始截取4个字符</p>

<p>echo $TEST | cut -c 2-6</p>

<p>his i</p>

<h5 id="5-示例3-删除子串">5、示例3：删除子串</h5>

<h6 id="1-示例">（1）示例</h6>

<p>echo $DEL</p>

<p>abcABC123ABCabc</p>

<h6 id="2-方式一-string-substring-从开头-删除最短匹配的子串">（2）方式一：${string#substring}，从开头,删除最短匹配的子串</h6>

<p>#删除开头最短匹配a*C子串</p>

<p>echo ${DEL#a*C}</p>

<p>123ABCabc</p>

<h6 id="3-方式二-string-substring-从开头-删除最长匹配的子串">（3）方式二：${string##substring}，从开头,删除最长匹配的子串</h6>

<p>#删除开头最长匹配a*C子串</p>

<p>echo ${DEL##a*C}</p>

<p>abc</p>

<h6 id="4-方式三-string-substring-从结尾-删除最短匹配的子串">（4）方式三：${string%substring}，从结尾 删除最短匹配的子串</h6>

<p>#删除开头最短匹配a*c子串</p>

<p>echo ${DEL%a*c}</p>

<p>abcABC123ABC</p>

<h6 id="5-方式四-string-substring-从结尾删除最长匹配的子串">（5）方式四：${string%%substring}，从结尾删除最长匹配的子串</h6>

<p>#删除开头最短匹配a*c子串</p>

<p>echo ${DEL%%a*c}</p>

<p><strong>结果为空，全部匹配删除</strong></p>

<h5 id="6-示例4-替换子串">6、示例4：替换子串</h5>

<h6 id="1-方法一-string-substring-replacement-从开头替换第一个匹配子串">（1）方法一：${string/substring/replacement}，从开头替换第一个匹配子串</h6>

<p>echo ${DEL/abc/mmm}</p>

<p>mmmABC123ABCabc</p>

<h6 id="2-方法二-string-substring-replacement-从结尾替换第一个匹配子串">（2）方法二：${string/%substring/replacement}，从结尾替换第一个匹配子串</h6>

<p>echo ${DEL/%abc/mmm}</p>

<p>abcABC123ABCmmm</p>

<h4 id="五-变量操作">五、变量操作</h4>

<h5 id="1-变量替换表">1、变量替换表</h5>

<p><strong>形式</strong></p>

<p>|</p>

<p><strong>说明</strong></p>

<p>&mdash;|&mdash;</p>

<p>${var}</p>

<p>|</p>

<p>变量本来的值</p>

<p>${var:-word}</p>

<p>|</p>

<p>如果变量 var 为空或已被删除(unset)，那么返回word，但不改变 var 的值。</p>

<p>${var:=word}</p>

<p>|</p>

<p>如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。</p>

<p>${var:?message}</p>

<p>|</p>

<p>如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。<br />
若此替换出现在Shell脚本中，那么脚本将停止运行。</p>

<p>${var:+word}</p>

<p>|</p>

<p>如果变量 var 被定义，那么返回 word，但不改变 var 的值。用于测试变量var是否存在</p>

<h5 id="2-示例1-var-word">2、示例1：${var:-word}</h5>

<p>echo $result</p>

<p><strong>空，无值</strong></p>

<p>echo $test</p>

<p><strong>空，无值</strong></p>

<p>result=${test:-&ldquo;aaaa&rdquo;}</p>

<p>echo $result</p>

<p>aaaa</p>

<p>test=&lsquo;kkkk&rsquo;</p>

<p>result=${test:-&ldquo;aaaa&rdquo;}</p>

<p>echo $result</p>

<p>kkkk</p>

<p>[root@mysqldb ~]#</p>

<h5 id="3-示例2-var-message">3、示例2：${var:?message}</h5>

<p>echo ${value:?&ldquo;this var is not defined&rdquo;}</p>

<p>-bash: value:this var is not defined</p>

<p>value=1</p>

<p>echo ${value:?&ldquo;this var is not defined&rdquo;}</p>

<p>1</p>

<h5 id="4-示例3-var-word">4、示例3：${var:+word}</h5>

<p>r=${value:+1}</p>

<p>echo $r</p>

<p>1</p>

<p>unset value</p>

<p>r=${value:+1}</p>

<p>echo $r</p>

<p><strong>空，无值</strong></p>

<h5 id="5-示例4-var-word-等同于-var-word">5、示例4：${var-word}等同于${var:-word}</h5>

<p>http=${HTTPD-/usr/sbin/httpd}</p>

<p>echo $http</p>

<p>/usr/sbin/httpd</p>

<p>HTTPD=&ldquo;/var/https&rdquo;</p>

<p>http=${HTTPD-/usr/sbin/httpd}</p>

<p>echo $http</p>

<p>/var/https</p>

<h5 id="6-示例5-var-word">6、示例5：${var:=word}</h5>

<p>echo $HTTPD</p>

<p><strong>空，无值</strong></p>

<p>http=${HTTPD:=/usr/sbin/httpd}</p>

<p>echo $http</p>

<p>/usr/sbin/httpd</p>

<p>echo $HTTPD</p>

<p>/usr/sbin/httpd</p>

<h5 id="7-示例6-查看系统脚本">7、示例6：查看系统脚本</h5>

<p>cat /etc/init.d/httpd</p>

<p>httpd=${HTTPD-/usr/sbin/httpd}</p>

<p>pidfile=${PIDFILE-/var/run/httpd/httpd.pid}</p>

<p>lockfile=${LOCKFILE-/var/lock/subsys/httpd}</p>

<h5 id="8-示例7-防止脚本误删除案例">8、示例7：防止脚本误删除案例</h5>

<h6 id="1-现象">（1）现象</h6>

<p>有很多脚本会调用环境变量，通过环境变量代表的路径来删除文件，但有时环境变量会变其它人删除或不小必替代，导致直接删除根目录或其它目录（为空时，大多数是home目录）下的文件，造成误删除事故。如命令rm
-fr $logs/*本是删除log目录下所有文件及文件夹，但当$log为空时，则命令变为rm -fr /*，删除根目录下的所有文件和文件夹了。</p>

<h6 id="2-原则">（2）原则</h6>

<p>有变量路径的操作，必须事先判断路径是否为空，特别是删除操作，高风险。</p>

<h6 id="3-示例">（3）示例</h6>

<p>（i）不严谨方法</p>

<p>path=/tmp</p>

<p>find $path -type f -name &ldquo;*.log -mtime +7 | xargs rm -f&rdquo;</p>

<p>（ii）严谨方法</p>

<p>find ${path-/tmp} -type f -name &ldquo;*.log -mtime +7 | xargs rm-f&rdquo;</p>

<h5 id="9-示例8-通过取字符串长度测试命令执行时间">9、示例8：通过取字符串长度测试命令执行时间</h5>

<h6 id="1-取字符串长度测试">（1）取字符串长度测试</h6>

<p>chars=<code>seq -s&quot; &quot; 10</code></p>

<p>echo $chars</p>

<p>1 2 3 4 5 6 7 89 10</p>

<p>echo ${#chars}</p>

<p>20</p>

<p>echo ${chars} | wc -L</p>

<p>20</p>

<p>echo ${chars} | wc -m</p>

<p>21</p>

<p>echo $(expr length &ldquo;$chars&rdquo;)</p>

<p>20</p>

<h6 id="2-不同方法取字符串长度耗时对比">（2）不同方法取字符串长度耗时对比</h6>

<p>chars=<code>seq -s&quot; &quot; 100</code></p>

<p>time for i in $(seq 1111);do count=${#chars};done; <strong># 最快</strong></p>

<p>real 0m0.204s</p>

<p>user 0m0.179s</p>

<p>sys 0m0.023s</p>

<p>time for i in $(seq 1111);do count=<code>echo ${chars} | wc -L</code>;done;</p>

<p>real 0m17.784s</p>

<p>user 0m0.182s</p>

<p>sys 0m16.217s</p>

<p>time for i in $(seq 1111);do count=<code>echo ${chars} | wc -m</code>;done; <strong>#
最慢，因为多个字符</strong></p>

<p>real 0m18.268s</p>

<p>user 0m0.205s</p>

<p>sys 0m16.603s</p>

<p>time for i in $(seq 1111);do count=<code>echo $(expr length&quot;$chars&quot;)</code>;done;</p>

<p>real 0m17.899s</p>

<p>user 0m0.148s</p>

<p>sys 0m15.849s</p>

<h6 id="3-结论">（3）结论</h6>

<p>一般情况下调用外部命令，与内置功能操作性能相差较大（相差几十到上百倍），所以在shell编程时，应尽量用内置操作或函数来完成。</p>

<h4 id="六-变量的数值计算">六、变量的数值计算</h4>

<h5 id="1-常用变量的数据计算命令">1、常用变量的数据计算命令</h5>

<h6 id="1-命令">（1）命令</h6>

<p>(())、let、expr、bc、$[]</p>

<h6 id="2-说明">（2）说明</h6>

<p>bc：可能计算浮点数（小数），其它只能计算整数。最常用的是(())，效率也最高。</p>

<h5 id="2-双括号-命令">2、双括号(())命令</h5>

<h6 id="1-示例1-普通计算">（1）示例1：普通计算</h6>

<p>((a=1+2**3-4%3)) # **表示幂运算</p>

<p>echo $a</p>

<p>8</p>

<p>b=$((1+2**3-4%3))</p>

<p>echo $b</p>

<p>8</p>

<p>echo $((1+2**3-4%3))</p>

<p>8</p>

<h6 id="2-示例2-自加计算-变量在前-先输出-后运算-变量在后-先运算-后输出">（2）示例2：自加计算（变量在前，先输出，后运算；变量在后，先运算，后输出）</h6>

<p>echo $((a+=1))</p>

<p>9</p>

<p>echo $a</p>

<p>9</p>

<p>echo $((a++))</p>

<p>9</p>

<p>echo $a</p>

<p>10</p>

<p>echo $((++a))</p>

<p>11</p>

<p>echo $a</p>

<p>11</p>

<p>echo $((a&ndash;))</p>

<p>11</p>

<p>echo $a</p>

<p>10</p>

<p>echo $((&ndash;a))</p>

<p>9</p>

<p>echo $a</p>

<p>9</p>

<h6 id="3-示例3-定义变量进行计算">（3）示例3：定义变量进行计算</h6>

<p>myvar=99</p>

<p>echo $(($myvar + 1))</p>

<p>100</p>

<p>echo $(( $myvar + 1 ))</p>

<p>100</p>

<p>myvar=$(( $myvar + 1 ))</p>

<p>echo $myvar</p>

<p>100</p>

<p>echo $((myvar+1)) # (())中的变量也可以去掉$符号</p>

<p>101</p>

<h6 id="4-示例4-各种计算">（4）示例4：各种计算</h6>

<p>echo $(( 100 + 5)) # 加</p>

<p>105</p>

<p>echo $(( 100 - 5)) # 减</p>

<p>95</p>

<p>echo $(( 100 * 5)) # 乘</p>

<p>500</p>

<p>echo $(( 100 / 5)) # 除</p>

<p>20</p>

<p>echo $(( 100 ** 2)) # 幂</p>

<p>10000</p>

<p>echo $(( 100 % 3)) # 取模，求余</p>

<p>1</p>

<h6 id="5-示例5-shell脚本">（5）示例5：shell脚本</h6>

<p>vi test.sh</p>

<p>#!/bin/bash</p>

<p>a=6</p>

<p>b=2</p>

<p>echo &ldquo;a+b=$(($a + $b))&rdquo;</p>

<p>echo &ldquo;a-b=$(($a - $b))&rdquo;</p>

<p>echo &ldquo;a*b=$(($a * $b))&rdquo;</p>

<p>echo &ldquo;a/b=$(($a / $b))&rdquo;</p>

<p>echo &ldquo;a**b=$(($a ** $b))&rdquo;</p>

<p>echo &ldquo;a%b=$(($a % $b))&rdquo;</p>

<p>sh test.sh</p>

<p>a+b =8</p>

<p>a-b =4</p>

<p>a*b =12</p>

<p>a/b =3</p>

<p>a**b =36</p>

<p>a%b =0</p>

<h6 id="6-示例6-将上述shell脚本改为由命令行获取参数值进行计算">（6）示例6：将上述shell脚本改为由命令行获取参数值进行计算</h6>

<p>vi test1.sh</p>

<p>#!/bin/bash</p>

<p>a=$1</p>

<p>b=$2</p>

<p>echo &ldquo;a+b=$(($a + $b))&rdquo;</p>

<p>echo &ldquo;a-b=$(($a - $b))&rdquo;</p>

<p>echo &ldquo;a*b=$(($a * $b))&rdquo;</p>

<p>echo &ldquo;a/b=$(($a / $b))&rdquo;</p>

<p>echo &ldquo;a**b=$(($a ** $b))&rdquo;</p>

<p>echo &ldquo;a%b=$(($a % $b))&rdquo;</p>

<p>sh test1.sh 4 3</p>

<p>a+b =7</p>

<p>a-b =1</p>

<p>a*b =12</p>

<p>a/b =1</p>

<p>a**b =64</p>

<p>a%b =1</p>

<h6 id="7-示例7-实现一个加减乘除的计算器-命令行传参">（7）示例7：实现一个加减乘除的计算器，命令行传参</h6>

<p>vi test2.sh</p>

<p>#!/bin/bash</p>

<p>echo $(($1$2$3))</p>

<p>sh test2.sh 3*5 <strong># 等同于$(($1))：参数中间没有空格分隔，相当于$1=3*5 $2和$3为空。</strong></p>

<p>15</p>

<p>sh test2.sh <sup>5</sup>&frasl;<sub>3</sub></p>

<p>1</p>

<p>sh test2.sh 5 + 3 <strong># $1=5 $2=&ldquo;+&rdquo; $3=3</strong></p>

<p>8</p>

<h5 id="3-let命令">3、let命令</h5>

<h6 id="1-格式">（1）格式</h6>

<p>let 赋值表达式 #等同于((赋值表达式))</p>

<h6 id="2-示例1-let基本用法">（2）示例1：let基本用法</h6>

<p>i=2</p>

<p>i=i+8</p>

<p>echo $i</p>

<p>i+8</p>

<p>i=2</p>

<p>let i=i+8</p>

<p>echo $i</p>

<p>10</p>

<p>i=2</p>

<p>echo $((i=i+8))</p>

<p>10</p>

<h6 id="3-示例2-利用let计数监控web服务状态-守护进程">（3）示例2：利用let计数监控web服务状态(守护进程)</h6>

<p>#监控服务状态</p>

<p>ServerMonitor () {</p>

<p>#服务状态监控</p>

<p>timeout=10</p>

<p>fails=0</p>

<p>success=0</p>

<p>while true</p>

<p>do</p>

<p>/usr/bin/wget &ndash;timeout=$timeout&ndash;tries=1 <a href="http://192.168.20.84/">http://192.168.20.84/</a> -q -O
/dev/null</p>

<p>if [ $? -ne 0 ]</p>

<p>then</p>

<p>let fails=fails+1</p>

<p>success=0</p>

<p>else</p>

<p>fails=0</p>

<p>let success=1</p>

<p>fi</p>

<p>if [ $success -ge 1 ]</p>

<p>then</p>

<p>exit 0</p>

<p>fi</p>

<p>if [ $fails -ge 2 ]</p>

<p>then</p>

<p>Critical=&ldquo;TMS应用服务出现故障，请紧急处理！&rdquo;</p>

<p>echo $Critical | mutt -s &ldquo;服务down&rdquo; oldboy@etiantian.org</p>

<p>exit</p>

<p>fi</p>

<p>done</p>

<p>}</p>

<h5 id="3-expr命令">3、expr命令</h5>

<h6 id="1-说明">（1）说明</h6>

<p>expr命令一般用于整数值，但也可用于字符串，用来求表达式变量的值。同时，expr是一个手工命令行计算器。expr命令格式严格，表达式的运算符及计算的数字等各参数前后必须要有空格（多空格也行），且乘号&rdquo;*&ldquo;需要&rdquo;\&ldquo;转义。</p>

<h6 id="2-格式-1">（2）格式</h6>

<p>expr Expression</p>

<h6 id="3-示例1-手工命令行计算器">（3）示例1：手工命令行计算器</h6>

<p>expr 2 + 2</p>

<p>4</p>

<p>expr 2 + 1</p>

<p>3</p>

<p>expr 2-1 <strong># 没有空格，当成字符串了</strong></p>

<p>2-1</p>

<p>expr 2 * 3 <strong># 需要转义</strong></p>

<p>expr: syntaxerror</p>

<p>expr 2 \* 3 <strong># 需要转义</strong></p>

<p>6</p>

<h6 id="4-示例2-增量计数">（4）示例2：增量计数</h6>

<p>i=0</p>

<p>i=<code>expr $i + 1</code></p>

<p>echo $i</p>

<p>1</p>

<h6 id="5-示例3-与-配合-实际是-的功能-用echo也一样">（5）示例3：与[]配合。实际是$[]的功能，用echo也一样</h6>

<p>expr $[2*3]</p>

<p>6</p>

<p>expr $[2**3]</p>

<p>8</p>

<p>expr $[2+3]</p>

<p>5</p>

<p>expr $[ 2 + 3 ] <strong>#</strong></p>

<p>5</p>

<p>echo $[ 2 + 3 ] <strong>#</strong></p>

<p>5</p>

<h6 id="6-示例4-查看系统脚本中的expr用法">（6）示例4：查看系统脚本中的expr用法</h6>

<p>cat <code>which ssh-copy-id</code></p>

<p>ID_FILE=&ldquo;${HOME}/.ssh/id_rsa.pub&rdquo;</p>

<p>if [&ldquo;-i&rdquo; = &ldquo;$1&rdquo; ]; then</p>

<p>shift</p>

<h1 id="check-if-we-have-2-parameters-left-if-sothe-first-is-the-new-id-file">check if we have 2 parameters left, if sothe first is the new ID file</h1>

<p>if [ -n &ldquo;$2&rdquo; ]; then</p>

<p>if <strong>expr</strong> &ldquo;$1&rdquo; : &ldquo;.*\.pub&rdquo; &gt;/dev/null ; then</p>

<p>ID_FILE=&ldquo;$1&rdquo;</p>

<p>else</p>

<p>ID_FILE=&ldquo;$1.pub&rdquo;</p>

<p>fi</p>

<p>shift # and this should leave $1 as thetarget name</p>

<p>fi</p>

<p>else</p>

<p>if [ x$SSH_AUTH_SOCK != x ] ; then</p>

<p>GET_ID=&ldquo;$GET_ID ssh-add -L&rdquo;</p>

<p>fi</p>

<p>fi</p>

<h6 id="7-示例5-判断文件扩展名">（7）示例5：判断文件扩展名</h6>

<p>expr &ldquo;test.pub&rdquo; : &ldquo;.*\.pub&rdquo; &gt; /dev/null&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>expr &ldquo;test.txt&rdquo; : &ldquo;.*\.pub&rdquo; &gt; /dev/null&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h6 id="8-示例6-判断变量是否为整数-技巧">（8）示例6：判断变量是否为整数（技巧）</h6>

<p>a、命令行测试</p>

<p>expr 1 + 2</p>

<p>3 <strong># 正常</strong></p>

<p>echo $?</p>

<p>0 <strong># 正常返回值为0</strong></p>

<p>expr 1 + a</p>

<p>expr:non-numeric argument <strong># 报错</strong></p>

<p>echo $?</p>

<p>2 <strong># 错误返回值不为0</strong></p>

<p>b、shell脚本测试</p>

<p>vi expr.sh</p>

<p>expr 1 + $1&amp;&gt;/dev/null</p>

<p>if [ $? -eq 0 ]</p>

<p>then</p>

<p>echo &ldquo;This is a zhengshu&rdquo;</p>

<p>else</p>

<p>echo &ldquo;This isn&rsquo;t a zhengshu&rdquo;</p>

<p>fi</p>

<p>sh expr.sh 1</p>

<p>This is azhengshu</p>

<p>sh expr.sh a</p>

<p>This isn&rsquo;t azhengshu</p>

<p>sh expr.sh 1.2</p>

<p>This isn&rsquo;t azhengshu</p>

<p>sh expr.sh 100</p>

<p>This is azhengshu</p>

<h6 id="9-示例7-计算字符串长度">（9）示例7：计算字符串长度</h6>

<p>chars=<code>seq -s &quot; &quot; 100</code></p>

<p>echo ${#chars}</p>

<p>291</p>

<p>echo $(expr length &ldquo;$chars&rdquo;)</p>

<p>291</p>

<h5 id="4-bc命令">4、bc命令</h5>

<h6 id="1-说明-1">（1）说明</h6>

<p>bc是UNIX下的计算器，支持小数计算，也可以在命令行下执行。同时，bc支持科学计算。</p>

<h6 id="2-示例1-命令行计算功能-类似python">（2）示例1：命令行计算功能（类似python）</h6>

<p>bc</p>

<p>bc 1.06.95</p>

<p>Copyright1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation,
Inc.</p>

<p>This is freesoftware with ABSOLUTELY NO WARRANTY.</p>

<p>For details type`warranty&rsquo;.</p>

<p>9 - 8</p>

<p>1</p>

<p><sup>5</sup>&frasl;<sub>2</sub></p>

<p>2</p>

<p>5%2</p>

<p>1</p>

<h6 id="3-示例2-通过管道命令-交由bc进行计算">（3）示例2：通过管道命令&rdquo;|&ldquo;交由bc进行计算</h6>

<p>echo 1 + 1 | bc</p>

<p>2</p>

<p>echo 1 + 1 + a | bc</p>

<p>2</p>

<p>echo 1+2 | bc</p>

<p>3</p>

<p>echo 1.1+2 | bc <strong># 支持小数，正常计算</strong></p>

<p>3.1</p>

<p>expr 1.1 + 2 <strong># 不支持小数，报错</strong></p>

<p>expr:non-numeric argument</p>

<p>echo $((1.1+2)) <strong># 不支持小数，报错</strong></p>

<p>-bash: 1.1+2:syntax error: invalid arithmetic operator (error token is &ldquo;.1+2&rdquo;)</p>

<h6 id="4-示例3-通过scale参数设置结果中小数点后的位数-scale只对除法-取余-乘幂有效-对乘法就有问题">（4）示例3：通过scale参数设置结果中小数点后的位数（scale只对除法、取余、乘幂有效，对乘法就有问题）</h6>

<p>echo &ldquo;scale=0;5.23*3.13&rdquo;|bc</p>

<p>16.36 <strong># 乘法，保留0位小数，无效</strong></p>

<p>echo &ldquo;scale=1;5.23*3.13&rdquo;|bc</p>

<p>16.36 <strong># 乘法，保留1位小数，无效</strong></p>

<p>echo &ldquo;scale=2;5.23*3.13&rdquo;|bc</p>

<p>16.36 <strong># 乘法，保留2位小数，不知是否有效，默认为保留2位</strong></p>

<p>echo &ldquo;scale=3;5.23*3.13&rdquo;|bc</p>

<p>16.369 <strong># 乘法，保留3位小数，有效</strong></p>

<p>echo &ldquo;scale=4;5.23*3.13&rdquo;|bc</p>

<p>16.3699 <strong># 乘法，保留4位小数，有效</strong></p>

<p>echo &ldquo;scale=0;5.<sup>23</sup>&frasl;<sub>3</sub>.13&rdquo;|bc</p>

<p>1 <strong># 除法，保留0位小数，有效</strong></p>

<p>echo &ldquo;scale=1;5.<sup>23</sup>&frasl;<sub>3</sub>.13&rdquo;|bc</p>

<p>1.6 <strong># 除法，保留1位小数，有效</strong></p>

<p>echo &ldquo;scale=2;5.<sup>23</sup>&frasl;<sub>3</sub>.13&rdquo;|bc</p>

<p>1.67 <strong># 除法，保留2位小数，有效</strong></p>

<p>echo &ldquo;scale=3;5.<sup>23</sup>&frasl;<sub>3</sub>.13&rdquo;|bc</p>

<p>1.670 <strong># 除法，保留3位小数，有效</strong></p>

<h6 id="5-示例4-通过obase参数进行进制转换">（5）示例4：通过obase参数进行进制转换</h6>

<p>a、十进制8转为二进制</p>

<p>echo &ldquo;obase=2;8&rdquo;|bc</p>

<p>1000</p>

<p>b、十进制20转为十六进制</p>

<p>echo &ldquo;obase=16;20&rdquo;|bc</p>

<p>14</p>

<h6 id="6-示例5-通过命令生成表达式-并计算出结果-结果格式-1-2-3-4-5-6-7-8-9-10-55">（6）示例5：通过命令生成表达式，并计算出结果（结果格式：1+2+3+4+5+6+7+8+9+10=55）</h6>

<p>a、方法一</p>

<p>echo <code>seq -s &quot;+&quot; 10</code> = <code>seq -s &quot;+&quot; 10 |bc</code></p>

<p>1+2+3+4+5+6+7+8+9+10= 55</p>

<p>b、方法二</p>

<p>echo <code>seq -s &quot;+&quot; 10</code> = $((<code>seq -s &quot;+&quot; 10</code>))</p>

<p>1+2+3+4+5+6+7+8+9+10= 55</p>

<p>c、方法三</p>

<p>echo <code>seq -s &quot;+&quot; 10</code> = <code>seq -s **&quot; + &quot;** 10 | xargs expr</code> <strong># 第二个&rdquo;
+&ldquo;加号前后一定要有空格</strong></p>

<p>1+2+3+4+5+6+7+8+9+10= 55</p>

<h5 id="5-typeset命令">5、typeset命令</h5>

<p>typeset -i A=1 B=3</p>

<p>A=A+B <strong># 效率高</strong></p>

<p>echo $A</p>

<p>4</p>

<h5 id="6-命令">6、$[]命令</h5>

<p>echo $[2+3]</p>

<p>5</p>

<p>echo $[ 2 + 3 ]</p>

<p>5</p>

<p>echo $[ 2 + 3 ]</p>

<p>5</p>

<p>echo $[2*3]</p>

<p>6</p>

<h4 id="七-shell变量的输入-read命令">七、Shell变量的输入（read命令）</h4>

<p>Shell变量除了可以直接赋值或脚本传参外，还可以使用read命令从标准输入获得。read是Shell的内置命令，可以通过help read查看帮助。</p>

<p>read从键盘读取变量的值，通常用在shell脚本中与用户进行交互的场合。该命令可以一次读取多个变量的值，变量和输入的值都需要使用空格隔开。在read命令后面，如果没有指定变量名，读取的数据将被自动赋值给特定的变量REPLY。</p>

<h6 id="1-格式-1">（1）格式</h6>

<p>read [参数] [变量名]</p>

<h6 id="2-参数">（2）参数</h6>

<p>-p prompt：指定读取值时的提示信息；</p>

<p>-t timeout：指定读取值时等待的时间（秒）。</p>

<h6 id="3-示例1-t参数">（3）示例1：-t参数</h6>

<p>read -t 5 -p &ldquo;please input: &ldquo; a</p>

<p>please input: <strong># 秒没有任何输入操作，自动退出。这就是-t的作用</strong></p>

<p>[root@my ~]#</p>

<h6 id="4-示例2-赋值">（4）示例2：赋值</h6>

<p>read -t 5 -p &ldquo;please input: &ldquo; a <strong># 变量a前面一定要有空格</strong></p>

<p>please input: 1</p>

<p>echo $a</p>

<p>1</p>

<h6 id="5-示例3-批量赋值">（5）示例3：批量赋值</h6>

<p>read -p &ldquo;please input two number: &ldquo; a1 a2</p>

<p>please input two number: 12 13</p>

<p>echo $a1</p>

<p>12</p>

<p>echo $a2</p>

<p>13</p>

<p>echo $a1 $a2</p>

<p>12 13</p>

<h6 id="5-示例4-批量赋值的echo-read实现">（5）示例4：批量赋值的echo + read实现</h6>

<p>vi echotoread.sh</p>

<p>echo -n&rdquo;please input two number: &ldquo;</p>

<p>read a1 a2</p>

<p>echo $a1 $a2</p>

<h6 id="6-示例5-read方式读入实现-加减乘除读计算的脚本">（6）示例5： read方式读入实现 加减乘除读计算的脚本</h6>

<p>vim read.sh</p>

<p>#!/bin/bash</p>

<p>read -t 10 -p&rdquo;pls input&rdquo;: a b</p>

<p>echo &ldquo;$a-$b=$(( $a - $b ))&rdquo;</p>

<p>echo &ldquo;$a+$b=$(( $a + $b ))&rdquo;</p>

<p>echo &ldquo;$a*$b=$(( $a * $b ))&rdquo;</p>

<p>echo &ldquo;$a/$b=$(( $a / $b ))&rdquo;</p>

<p>echo &ldquo;$a**$b=$(( $a ** $b ))&rdquo;</p>

<p>echo &ldquo;$a%$b=$(( $a % $b ))&rdquo;</p>

<h6 id="7-示例6-综合示例-分别以定义变量-脚本传参-read读入方式比较2个整数大小">（7）示例6：综合示例，分别以定义变量、脚本传参、read读入方式比较2个整数大小</h6>

<p>a、要求</p>

<p>用条件表达式进行判断，并以屏幕输出方式提醒用户比较结果。当用脚本传参和read读入的方式时，需要对充数量是否为数字做判断。</p>

<p>b、方式一：定义变量</p>

<p>vi var7601.sh</p>

<p>#!/bin/bash</p>

<p>a=1</p>

<p>b=2</p>

<p>[ -z&rdquo;$a&rdquo; ] || [ -z &ldquo;$b&rdquo; ] &amp;&amp;{</p>

<p>echo &ldquo;please input two numagain.&rdquo;</p>

<p>exit 1</p>

<p>}</p>

<p>expr $a + 0&amp;&gt;/dev/null</p>

<p>RETVAL1=$?</p>

<p>expr $b + 0&amp;&gt;/dev/null</p>

<p>RETVAL2=$?</p>

<p>test $RETVAL1-eq 0 -a $RETVAL2 -eq 0 || {</p>

<p>echo &lsquo;please input two &ldquo;num&rdquo;again.&rsquo;</p>

<p>exit 2</p>

<p>}</p>

<p>[ $a -lt $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a &lt; $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>[ $a -eq $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a = $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>[ $a -gt $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a &gt; $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>c、方式二：脚本传参</p>

<p>vi args7602.sh</p>

<p>#!/bin/bash</p>

<p>a=$1</p>

<p>b=$2</p>

<p>[ $# -ne 2 ] &amp;&amp;{</p>

<p>echo &ldquo;please input two numagain.&rdquo;</p>

<p>exit 1</p>

<p>}</p>

<p>expr $a + 0&amp;&gt;/dev/null</p>

<p>RETVAL1=$?</p>

<p>expr $b + 0&amp;&gt;/dev/null</p>

<p>RETVAL2=$?</p>

<p>test $RETVAL1-eq 0 -a $RETVAL2 -eq 0 || {</p>

<p>echo &lsquo;please input two &ldquo;num&rdquo;again.&rsquo;</p>

<p>exit 2</p>

<p>}</p>

<p>[ $a -lt $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a &lt; $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>[ $a -eq $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a = $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>[ $a -gt $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a &gt; $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>d、方式三：read读入</p>

<p>vi read7603.sh</p>

<p>#!/bin/bash</p>

<p>read -p&rdquo;please input two number: &ldquo; a b</p>

<p>[ -z&rdquo;$a&rdquo; ] || [ -z &ldquo;$b&rdquo; ] &amp;&amp;{</p>

<p>echo &ldquo;please input two numagain.&rdquo;</p>

<p>exit 1</p>

<p>}</p>

<p>expr $a + 0&amp;&gt;/dev/null</p>

<p>RETVAL1=$?</p>

<p>expr $b + 0&amp;&gt;/dev/null</p>

<p>RETVAL2=$?</p>

<p>test $RETVAL1-eq 0 -a $RETVAL2 -eq 0 || {</p>

<p>echo &lsquo;please input two &ldquo;num&rdquo;again.&rsquo;</p>

<p>exit 2</p>

<p>}</p>

<p>[ $a -lt $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a &lt; $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>[ $a -eq $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a = $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>[ $a -gt $b ]&amp;&amp; {</p>

<p>echo &ldquo;$a &gt; $b&rdquo;</p>

<p>exit 0</p>

<p>}</p>

<p>sh read7603.sh</p>

<p>please input two number: 1 2</p>

<p>1 &lt; 2</p>

<p>sh read7603.sh</p>

<p>please input two number: 2 2</p>

<p>2 = 2</p>

<p>sh read7603.sh</p>

<p>please input two number: 2 1</p>

<p>2 &gt; 1</p>

<p>sh read7603.sh</p>

<p>please input two number: a</p>

<p>please input twonum again.</p>

<p>sh read7603.sh</p>

<p>please input two number: 1 a</p>

<p>please input two&rdquo;num&rdquo; again.</p>

<p>sh read7603.sh</p>

<p>please input two number: a b c</p>

<p>please input two&rdquo;num&rdquo; again.</p>

<h6 id="8-示例7-综合示例-开发shell菜单">（8）示例7：综合示例，开发shell菜单</h6>

<p>a、效果</p>

<p>sh menu.sh</p>

<p>1. [installlamp]</p>

<p>2. [installlnmp]</p>

<p>3. [exit]</p>

<p>please input thenum you want:</p>

<p>当输入1时：</p>

<p>installing&hellip;. lamp</p>

<p>当输入2时：</p>

<p>installing&hellip;. lnmp</p>

<p>当输入3时：退出脚本</p>

<p>b、解答</p>

<p>menu(){</p>

<p>cat &lt;</p>

<hr />

<p>1. [install lamp]</p>

<p>2. [install lnmp]</p>

<p>3. [exit]</p>

<p>please input the num you want:</p>

<hr />

<p>END</p>

<p>read -t 15 a</p>

<p>}</p>

<p>menu</p>

<p>[ $a -eq 1 ]&amp;&amp; {</p>

<p>echo &ldquo;installing lamp&hellip;.&rdquo;</p>

<p>sleep 3</p>

<p>echo &ldquo;lamp is installed.&rdquo;</p>

<p>menu</p>

<p>}</p>

<p>[ $a -eq 2 ]&amp;&amp; {</p>

<p>echo &ldquo;installing lnmp&hellip;.&rdquo;</p>

<p>sleep 3</p>

<p>echo &ldquo;lnmp is installed.&rdquo;</p>

<p>menu</p>

<p>}</p>

<p>[ $a -eq 3 ]&amp;&amp; {</p>

<p>exit</p>

<p>}</p>

<p>[ $a -ne 1 -o $a-ne 2 -o $a -ne 3 ] &amp;&amp; {</p>

<p>read -p &ldquo; please input the num (1 2 3)you want: &ldquo; -t 15 a</p>

<p>}</p>

<h4 id="八-判断字符串是否为数字的多种方法">八、判断字符串是否为数字的多种方法</h4>

<h5 id="1-方法一-sed加正则表达式-思路-过滤数字后为空-则都是数字-否则有数字以外的字符">1、方法一：sed加正则表达式（思路：过滤数字后为空，则都是数字，否则有数字以外的字符）</h5>

<p>[ -n &ldquo;<code>echo $num|sed 's/[0-9]//g'</code>&rdquo; -a -n &ldquo;<code>echo$2|sed 's/[0-9]//g'</code>&rdquo;] &amp;&amp; </p>

<p>echo &ldquo;两个参数必须为数字&rdquo; &amp;&amp; exit 1</p>

<h5 id="2-方法二-变量的子串替换加正则表达式-思路-过滤数字后为0-则都是数字-否则有数字以外的字符">2、方法二：变量的子串替换加正则表达式（思路：过滤数字后为0，则都是数字，否则有数字以外的字符）</h5>

<p>[ -z &ldquo;<code>echo '${num//[0-9]}'</code>&rdquo; ] &amp;&amp; echo 1 || echo0</p>

<h5 id="3-方法三-变量的子串替换加正则表达式-思路-不为空时-过滤非数字部分-如果结果等本身-则都是数字">3、方法三：变量的子串替换加正则表达式（思路：不为空时，过滤非数字部分，如果结果等本身，则都是数字）</h5>

<p>[ -n &ldquo;$num&rdquo; -a&rdquo;$num&rdquo;=&ldquo;${num//[^0-9]/}&rdquo; ] &amp;&amp; echo &ldquo;it isnum&rdquo;</p>

<p>-n &ldquo;$num&rdquo;：表示num不为空</p>

<p>&rdquo;$num&rdquo;=&ldquo;${num//[^0-9]/}&ldquo;：去掉num中的非数字部分，判断是否相等，等则为数字，不等则含有其它字符</p>

<h5 id="4-方法四-expr计算判断-思路-把变量和整数相加-看是否成功执行">4、方法四：expr计算判断（思路：把变量和整数相加，看是否成功执行）</h5>

<p>expr $1 + 0 &gt;/dev/null 2&gt;&amp;1</p>

<p>[ $? -eq 0 ] &amp;&amp; echo int</p>

<h5 id="5-方法五-利符号-来判断">5、方法五：利符号“=~”来判断</h5>

<p>[[ ! $a =~ [0-9] ]] || [[ ! $b =~ [0-9] ]] &amp;&amp; {</p>

<p>echo &ldquo;please input two numbers like : num1 num2&rdquo;</p>

<p>exit 2</p>

<p>}</p>

<h5 id="6-方法六-bc判断">6、方法六：bc判断</h5>

<p>echo 12|bc</p>

<p>12</p>

<p>echo aa|bc</p>

<p>0</p>

<p>echo aa12|bc</p>

<p>0</p>

<p>echo 2d|bc</p>

<p>(standard_in) 1:syntax error</p>

<h4 id="九-if条件句">九、if条件句</h4>

<h5 id="1-语法格式">1、语法格式</h5>

<h6 id="1-单分支结构">（1）单分支结构</h6>

<p>a、格式一</p>

<p>if [条件]</p>

<p>then</p>

<p>命令</p>

<p>fi</p>

<p>b、格式二</p>

<p>if [条件];then</p>

<p>命令</p>

<p>fi</p>

<h6 id="2-双分支结构">（2）双分支结构</h6>

<p>a、格式一</p>

<p>if [条件]</p>

<p>then</p>

<p>命令</p>

<p>else</p>

<p>命令</p>

<p>fi</p>

<p>b、格式二</p>

<p>if [条件];then 命令;else命令;fi</p>

<h6 id="3-多分支结构">（3）多分支结构</h6>

<p>if [条件]</p>

<p>then</p>

<p>命令</p>

<p>elif [条件]</p>

<p>then</p>

<p>命令</p>

<p>else</p>

<p>命令</p>

<p>fi</p>

<h5 id="2-示例1-单分支比较2个整数大小">2、示例1：单分支比较2个整数大小</h5>

<h6 id="1-方法一-脚本传参">（1）方法一：脚本传参</h6>

<p>vi if1.sh</p>

<p>#!/bin/bash</p>

<p>if [ $1 -lt $2 ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $1 is less than $2&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>if [ $1 -eq $2 ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $1 equal $2&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>if [ $1 -gt $2 ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $1 is greater than$2&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>sh if1.sh 10 12</p>

<p>Yes, 10 is lessthan 12</p>

<h6 id="2-方法二-read读入">（2）方法二：read读入</h6>

<p>vi if2.sh</p>

<p>#!/bin/bash</p>

<p>read -p&rdquo;please input two num: &ldquo; -t a b</p>

<p>if [ $a -lt $b ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $a is less than $b&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>if [ $a -eq $b ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $a equal $b&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>if [ $a -gt $b ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $a is greater than $b&rdquo;</p>

<p>exit</p>

<p>fi</p>

<h5 id="3-示例2-开发shell脚本-如果-server-scripts下有if3-sh-则输出提示-不存在-则创建">3、示例2：开发shell脚本，如果/server/scripts下有if3.sh，则输出提示，不存在，则创建</h5>

<p>vi /service/scripts/findif3.sh</p>

<p>#!/bin/bash</p>

<p>path=/server/scripts</p>

<p>file=if3.sh</p>

<p>if [ ! -d $path]</p>

<p>then</p>

<p>mkdir -p $path</p>

<p>echo &ldquo;$path dir is not exitst,already created it.&rdquo;</p>

<p>fi</p>

<p>if [ ! -f$path/$file ]</p>

<p>then</p>

<p>touch $path/$file</p>

<p>echo &ldquo;$path/$file is not exitst,already created it.&rdquo;</p>

<p>fi</p>

<p>echo &ldquo;ls -l$path/$file&rdquo;</p>

<p>ls -l$path/$file</p>

<h5 id="4-示例3-开发shell脚本-判断系统剩余内存大小-如低于100m-则发邮件提示-3分钟检查一次">4、示例3：开发shell脚本，判断系统剩余内存大小，如低于100M，则发邮件提示，3分钟检查一次</h5>

<h6 id="1-思路">（1）思路</h6>

<p>a、查看系统内存的命令</p>

<p>free -m</p>

<p>b、命令结果</p>

<p>total used free shared buffers cached</p>

<p>Mem: 2022 1244 777 0 286 690</p>

<p>-/+ buffers/cache: 267 <strong>1755</strong></p>

<p>Swap: 4063 0 4063</p>

<p>c、查看剩余内存</p>

<p>Linux系统剩余内存要看-/+buffers/cache行的free列，因为在Linux系统中如果内存没有使用，则做为缓存使用。所台buffers/cache行的free列才是系统真正剩余内存。</p>

<h6 id="2-解答步骤">（2）解答步骤</h6>

<p>a、第一步：获取剩余内存</p>

<p>（i）方法一</p>

<p>free -m | grep buffers/cache | awk &lsquo;{print $NF}&rsquo; # $NF：awk中表示最后一列，还可以$(NF-1)</p>

<p>1755</p>

<p>（ii）方法一</p>

<p>free -m | awk &lsquo;NR==3 {print $NF}&rsquo;</p>

<p>1755</p>

<p>b、第二步：发邮件</p>

<p>（i）sendmail服务要启动</p>

<p>/etc/init.d/sendmail start</p>

<p>（ii）发邮件</p>

<p>mail -s &ldquo;title&rdquo; abcd@qq.com &lt; $char</p>

<p>c、第三步：编写脚本</p>

<p>vi /service/scripts/getfree.sh</p>

<p>#!/bin/sh</p>

<p>free_mem=<code>free-m | awk 'NR==3 {print $NF}'</code></p>

<p>if [ $free_mem-lt 100 ]</p>

<p>then</p>

<p>echo &ldquo;mem is not enough,$free_mem.&rdquo;</p>

<p>echo &ldquo;mem is not enough,$free_mem.&rdquo; | mail -s &ldquo;mem waring $(date +%F)&rdquo;
aaa@a.com</p>

<p>fi</p>

<p>d、第四步：编写定进任务</p>

<p>crontab -e</p>

<h4 id="this-is-afree-mem">This is afree mem</h4>

<p>*/3 * * * */bin/sh /service/scripts/getfree.sh &amp;&gt;/dev/null</p>

<h5 id="5-示例4-多分支比较2个整数大小">5、示例4：多分支比较2个整数大小</h5>

<p>vi if4.sh</p>

<p>#!/bin/bash</p>

<p>if [ $1 -lt $2 ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $1 is less than $2&rdquo;</p>

<p>elif [ $1 -eq $2]</p>

<p>then</p>

<p>echo &ldquo;Yes, $1 equal $2&rdquo;</p>

<p>else</p>

<p>echo &ldquo;Yes, $1 is greater than$2&rdquo;</p>

<p>fi</p>

<p>exit 0</p>

<h5 id="6-示例5-read读入-比较2个整数大小-要求判断输入参数个数和是否是整数">6、示例5：read读入，比较2个整数大小（要求判断输入参数个数和是否是整数）</h5>

<p>vi read.sh</p>

<p>#!/bin/bash</p>

<p><strong># 提示输入参数</strong></p>

<p>read -p&rdquo;please input two num: &ldquo; -t 10 a b</p>

<p><strong># 判断参数个数</strong></p>

<p>if [ $# -ne 2 ]</p>

<p>then</p>

<p>echo &ldquo; USAGE：$0 num1 num 2. please input twonumbers.&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p><strong># 判断参数是否是整数（$a + $b如果不是整数，说明至少有一个不是整数）</strong></p>

<p>expr $a + $b&amp;&gt;/dev/null</p>

<p>if [ $? -ne 0 ]</p>

<p>then</p>

<p>echo &ldquo;please input two numbers.&rdquo;</p>

<p>exit 2</p>

<p>fi</p>

<p><strong># 进行判断</strong></p>

<p>if [ $a -lt $b ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $a is less than $b&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>if [ $a -eq $b ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $a equal $b&rdquo;</p>

<p>exit</p>

<p>fi</p>

<p>if [ $a -gt $b ]</p>

<p>then</p>

<p>echo &ldquo;Yes, $a is greater than $b&rdquo;</p>

<p>exit</p>

<p>fi</p>

<h5 id="7-示例6-监控mysql服务">7、示例6：监控MySQL服务</h5>

<h6 id="1-要求">（1）要求</h6>

<p>监控MySQL服务是否正常启动，如果未正常启动，则启动MySQL</p>

<h6 id="2-演示示例-1">（2）演示示例</h6>

<p>以多实例MySQL数据库中的3306数据库为例。启动命令/data/3306/mysqlstart</p>

<h6 id="3-方法一-通过3306端口进行判断">（3）方法一：通过3306端口进行判断</h6>

<p>a、初始脚本</p>

<p>vi /server/scripts/judgedb_port.sh</p>

<p>#!/bin/sh</p>

<p>port=<code>netstat-lntup | grep 3306 | awk -F '[: ]+' '{print $5}'</code></p>

<p>if [&ldquo;$port&rdquo; != &ldquo;3306&rdquo; ];then</p>

<p>/data/3306/mysqlstart</p>

<p>fi</p>

<p>b、存在问题</p>

<p>（i）过滤出 3306端口赋值给port的思路不是最佳的</p>

<p>一但mysql没有启动，port的取值将为空。下面判断时，如果使用整数来判断，则会出现问题。</p>

<p>（ii）进行端口判断时，最好使用字符串进行判断，不要用整数比较，整数比较时，一旦端口不存在则报错</p>

<p>[ &ldquo;$port&rdquo; != &ldquo;3306&rdquo; ]：字符串判断</p>

<p>[ $port ne 3306 ]：整数比较</p>

<p>（iii）获取端口的过程太复杂，不是最好方法</p>

<p>c、最终脚本（比较好的脚本，思路是将端口号转变为行数）</p>

<p>vi /server/scripts/judgedb_port.sh</p>

<p>#!/bin/sh</p>

<p>port=<code>netstat-lntup | grep 3306 | wc -l</code></p>

<p>if [ $port -ne 1];then</p>

<p>/data/3306/mysqlstart</p>

<p>fi</p>

<h6 id="4-方法二-通过mysql进程进行判断">（4）方法二：通过mysql进程进行判断</h6>

<p>a、脚本</p>

<p>vi /server/scripts/judgedb_process.sh</p>

<p>#!/bin/sh</p>

<p>pnum=<code>ps -ef |grep mysql | grep -v grep | wc -l</code></p>

<p>if [ pnum -ne 2];then</p>

<p>/data/3306/mysqlstart</p>

<p>fi</p>

<p>b、存在问题</p>

<p>在使用进程进行判断时，如果脚本中有grep过滤，则一定要保证脚本名称中不能含有grep过滤的内容，否则会导致计数不准确。如</p>

<p>ps -ef | grepmysql | grep -v grep | wc -l 的结果为2</p>

<p>如果脚本名称为judgemysqldb_process.sh，则结果为4</p>

<h6 id="5-方法三-通过端口和mysql进程进行判断">（5）方法三：通过端口和mysql进程进行判断</h6>

<p>vi /server/scripts/judgedb_portandprocess.sh</p>

<p>#!/bin/sh</p>

<p>pnum=<code>ps -ef |grep mysql | grep -v grep | wc -l</code></p>

<p>port=<code>netstat-lntup | grep 3306 | wc -l</code></p>

<p>if [ pnum -eq 2] &amp;&amp; [ port -eq 1 ]</p>

<p>then</p>

<p>echo &ldquo;MySQL is running&rdquo;</p>

<p>else</p>

<p>/data/3306/mysqlstart</p>

<p>fi</p>

<h6 id="6-方法四-通过-e在命令行执行mysql查询的返回值进行判断">（6）方法四：通过-e在命令行执行mysql查询的返回值进行判断</h6>

<p>vi /server/scripts/judgedb_cmd.sh</p>

<p>#!/bin/sh</p>

<p>mysql -uroot-p&rsquo;123456&rsquo; -e &ldquo;select version();&rdquo; &amp;&gt;/dev/null</p>

<p>if [ $? -ne 0];then</p>

<p>/data/3306/mysqlstart</p>

<p>fi</p>

<h6 id="7-方法五-通过php-java程序url连接进行判断">（7）方法五：通过php/java程序url连接进行判断</h6>

<p>#php</p>

<p>$link_id=mysql_connect(&lsquo;localhost&rsquo;,&lsquo;root&rsquo;,&lsquo;123456&rsquo;) ormysql_error();</p>

<p>if($link_id){</p>

<p>echo &ldquo;mysqlsuccessful&rdquo;</p>

<p>}else{</p>

<p>echo mysql_error();</p>

<p>}</p>

<h4 id="十-条件测试表达式">十、条件测试表达式</h4>

<h5 id="1-条件测试语法">1、条件测试语法</h5>

<p>（1）格式一：test 测试表达式</p>

<p>（2）格式二：[测试表达式]</p>

<p>（3）格式三：[[测试表达式]]</p>

<h5 id="2-语法说明">2、语法说明</h5>

<p>（1）格式一和格式二是等价的。格式三是扩展的test命令，有网友推荐用格式三，实际上格式无好坏，看个人习惯。</p>

<p>（2）在[[]]中可以使用通配符进行模式匹配。&amp;&amp;、||、&gt;、</p>

<p>（3）对整数进行关系运算时，也可以使用shell的（（））算术运算符。</p>

<h5 id="3-查看帮助">3、查看帮助</h5>

<p>man test</p>

<h5 id="4-test判断示例">4、test判断示例</h5>

<h6 id="1-示例1-测试文件是否存在">（1）示例1：测试文件是否存在</h6>

<p>test -f file&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>touch file</p>

<p>test -f file&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<h6 id="2-示例2-非-的用法">（2）示例2：非“！”的用法</h6>

<p>test ！ -f file &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h6 id="3-示例3-z-参数0值判断-判断长度为0">（3）示例3：-z 参数0值判断（判断长度为0）</h6>

<p>arg=</p>

<p>test -z&rdquo;$arg&rdquo; &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>arg=&ldquo;aaaaa&rdquo;</p>

<p>test -z&rdquo;$arg&rdquo; &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h6 id="4-示例4-n-参数的非0值判断-判断长度不为0">（4）示例4：-n 参数的非0值判断（判断长度不为0）</h6>

<p>arg=</p>

<p>test -n&rdquo;$arg&rdquo; &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>arg=&ldquo;aaaaa&rdquo;</p>

<p>test -z&rdquo;$arg&rdquo; &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<h5 id="5-中括号-判断示例">5、中括号“[]”判断示例</h5>

<h6 id="1-示例1-测试文件是否存在-1">（1）示例1：测试文件是否存在</h6>

<p>[ -f file ]&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>touch file</p>

<p>[ -f file ]&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<h6 id="2-示例2-非-的用法-1">（2）示例2：非“！”的用法</h6>

<p>[ ！ -f file ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h5 id="6-双中括号-判断示例">6、双中括号“[[]]”判断示例</h5>

<h6 id="1-示例1-测试文件是否存在-2">（1）示例1：测试文件是否存在</h6>

<p>[[ -f file ]]&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>touch file</p>

<p>[[ -f file ]]&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<h6 id="2-示例2-非-的用法-2">（2）示例2：非“！”的用法</h6>

<p>[[ ！ -f file ]] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h6 id="3-示例3-中有-等操作符的用法">（3）示例3：[[]]中有&amp;&amp;、||等操作符的用法</h6>

<p>[[ ！ -f file &amp;&amp; -d dir]] &amp;&amp;echo 1 || echo 0</p>

<p>0</p>

<p>touch file</p>

<p>[[ ！ -f file &amp;&amp; -d dir]] &amp;&amp;echo 1 || echo 0</p>

<p>0</p>

<p>[[ ！ -f file || -d dir]] &amp;&amp; echo 1|| echo 0</p>

<p>1</p>

<p>mkdir dir</p>

<p>[[ ！ -f file &amp;&amp; -d dir]] &amp;&amp;echo 1 || echo 0</p>

<p>1</p>

<h5 id="7-常用判断示例-以中括号来演示">7、常用判断示例：以中括号来演示</h5>

<h6 id="1-模拟环境">（1）模拟环境</h6>

<p>pwd</p>

<p>/wddg-data/scripts</p>

<p>mkdir 03</p>

<p>cd 03</p>

<p>touch oldboy</p>

<h6 id="2-测试-f参数">（2）测试-f参数</h6>

<p>[ -f oldboy ]&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>mkdir oldgirl</p>

<p>[ -f oldgirl ]&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h6 id="3-测试-e参数">（3）测试-e参数</h6>

<p>[ -e oldgirl ]&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<h6 id="4-测试-d参数">（4）测试-d参数</h6>

<p>[ -d oldgirl ]&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>[ -d oldboy ]&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h6 id="5-测试-r-w-x参数-root用户比较特殊-没有权限-也可以读写">（5）测试-r、-w、-x参数（root用户比较特殊，没有权限，也可以读写）</h6>

<p>chmod 000 oldboy</p>

<p>ll oldboy</p>

<p>-&mdash;&mdash;&mdash; 1root root 0 May 29 12:56 oldboy</p>

<p>[ -r oldboy ]&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>[ -x oldboy ]&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>[ -w oldboy ]&amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>su - oracle</p>

<p>[ -r oldboy ]&amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>[wddg@myCentOS03]$ [ -x oldboy ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>[wddg@myCentOS03]$ [ -w oldboy ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<h4 id="十一-字符串测试操作符">十一、字符串测试操作符</h4>

<h5 id="1-作用">1、作用</h5>

<p>比较2个字符串是否相同、测试字符串长度是否为零、测试字符串是否为NULL（bash区分零长度字符串和空字符串）等</p>

<h5 id="2-注意事项">2、注意事项</h5>

<h6 id="1-在字符串判断中-和-是等价的-都是比较两个字符串是否相同-但最好是用-因为在其它地方-表示的是赋值">（1）在字符串判断中，“=”和“==”是等价的，都是比较两个字符串是否相同，但最好是用“==”，因为在其它地方“=”表示的是赋值。</h6>

<p>######
（2）变量最好是用双引号“”括起来（单引号也行），如“aaa”、“$a”等，因为如果中间有空格、*号等符号时，就可能出错了。最好的方法是[&ldquo;${a}&rdquo;=&ldquo;${b}&rdquo;]。</p>

<h6 id="3-字符串比较-比较特号两端最好有空格-如果没有空格-有时候会导致结果不正确">（3）字符串比较，比较特号两端最好有空格。如果没有空格，有时候会导致结果不正确。</h6>

<h6 id="4-多参考系统脚本">（4）多参考系统脚本。</h6>

<p>sed -n &lsquo;30,31p&rsquo;/etc/init.d/network</p>

<h1 id="check-thatnetworking-is-up">Check thatnetworking is up.</h1>

<p>[&ldquo;${NETWORKING}&rdquo; = &ldquo;no&rdquo; ] &amp;&amp; exit 6 <strong># 等号两边有空格</strong></p>

<h5 id="3-常用字符串操作符">3、常用字符串操作符</h5>

<p>操作符</p>

<p>|</p>

<p>说明</p>

<p>&mdash;|&mdash;</p>

<p>-z &ldquo;字符串&rdquo;</p>

<p>|</p>

<p>如果字符串长度为0，表达式值则为真。-z表示zero</p>

<p>-n &ldquo;字符串&rdquo;</p>

<p>|</p>

<p>如果字符串长度不为0，表达式值则为真。-n表示no zero</p>

<p>&ldquo;字符串1&rdquo; = &ldquo;字符串2&rdquo;</p>

<p>|</p>

<p>如果字符串1等于字符串2，表达式值则为真。最好是用“==”代替“=”</p>

<p>&ldquo;字符串1&rdquo; != &ldquo;字符串2&rdquo;</p>

<p>|</p>

<p>如果字符串1不等于字符串2，表达式值则为真。最好是用“==”代替“=”</p>

<h5 id="4-示例">4、示例</h5>

<p>[ -n &ldquo;abc&rdquo; ] &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>[ -n &ldquo;&rdquo; ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>test=&ldquo;abcd&rdquo;</p>

<p>[ -n &ldquo;$test&rdquo; ] &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>[ -n $test ] &amp;&amp; echo 1 || echo 0 <strong># 没有用双引号“”将变量括起来，有时会不对。</strong></p>

<p>1</p>

<p>test=&ldquo;&rdquo;</p>

<p>[ -n $test ] &amp;&amp; echo 1 || echo 0 <strong># 此处，变量为空，但没有没有用双引号“”将变量括起来，结果不对。</strong></p>

<p>1</p>

<p>[ &ldquo;$test&rdquo; = &ldquo;abc&rdquo; ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>[ &ldquo;$test&rdquo; = &ldquo;abcd&rdquo; ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>[ &ldquo;abcd&rdquo; = &ldquo;abcd&rdquo; ] &amp;&amp; echo 1 || echo0</p>

<p>1</p>

<p>test=&ldquo;abcd&rdquo;</p>

<p>[ &ldquo;$test&rdquo; = &ldquo;abcd&rdquo; ] &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<h4 id="十二-整数二元比较操作符">十二、整数二元比较操作符</h4>

<h5 id="1-常用整数操作符">1、常用整数操作符</h5>

<p>在[]中使用的比较符</p>

<p>|</p>

<p>在(())和[[]]中使用的比较符</p>

<p>|</p>

<p>说明</p>

<p>&mdash;|&mdash;|&mdash;</p>

<p>-eq</p>

<p>|</p>

<p>==</p>

<p>|</p>

<p>等于，equal的缩写</p>

<p>-ne</p>

<p>|</p>

<p>!=</p>

<p>|</p>

<p>不相等，not equal的缩写</p>

<p>-gt</p>

<p>|</p>

<blockquote>
</blockquote>

<p>|</p>

<p>大于，greater than的缩写</p>

<p>-ge</p>

<p>|</p>

<blockquote>
<p>=</p>
</blockquote>

<p>|</p>

<p>大于等于，greater equal的缩写</p>

<p>-lt</p>

<p>|</p>

<p>|</p>

<p>小于，less than的缩写</p>

<p>-le</p>

<p>|</p>

<p>&lt;=</p>

<p>|</p>

<p>小于等于，less equal的缩写</p>

<p>说明：如果[]中想使用在(())和[[]]中使用的比较符，除“=”和“！=”外，其它需要用&rdquo;\&ldquo;转义。麻烦，最好不用。</p>

<h5 id="2-示例">2、示例</h5>

<p>[ 12 -eq 13 ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>[ 12 -ne 13 ] &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>[ 12 -gt 13 ] &amp;&amp; echo1 || echo 0</p>

<p>0</p>

<p>[ 12 -lt 13 ] &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>[ 12 &lt; 13 ] &amp;&amp;echo 1 || echo 0 <strong># 报错，需转义</strong></p>

<p>-bash: 13: No suchfile or directory</p>

<p>0</p>

<p>[ 12 &lt; 13 ] &amp;&amp; echo 1 || echo 0 <strong># 转义，麻烦</strong></p>

<p>1</p>

<p>[[ 12 &lt; 13 ]] &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>[ 12 = 13 ] &amp;&amp; echo 1 || echo 0 <strong># 等号“=”可以不转义，最好不这样用，遵循标准</strong></p>

<p>0</p>

<p>[ 12 \= 13 ] &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>[ 12 != 13 ] &amp;&amp; echo 1 || echo 0 <strong># 不等号“!=”可以不转义，最好不这样用，遵循标准</strong></p>

<p>1</p>

<p>[ 12 \!= 13 ] &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<p>(( 12 &gt; 12 )) &amp;&amp; echo 1 || echo 0</p>

<p>0</p>

<p>(( 12 = 12 )) &amp;&amp; echo 1 || echo 0 <strong># 等于时，最好使用“==”，否则容易发生错误。</strong></p>

<p>-bash: ((: 12 =12 : attempted assignment to non-variable (error token is &ldquo;= 12 &ldquo;)</p>

<p>0</p>

<p>(( 12 == 12 )) &amp;&amp; echo 1 || echo 0</p>

<p>1</p>

<h4 id="十三-逻辑操作符">十三、逻辑操作符</h4>

<h5 id="1-常用整数操作符-1">1、常用整数操作符</h5>

<p>在[]中使用的比较符</p>

<p>|</p>

<p>在(())和[[]]中使用的比较符</p>

<p>|</p>

<p>说明</p>

<p>&mdash;|&mdash;|&mdash;</p>

<p>-a</p>

<p>|</p>

<p>&amp;&amp;</p>

<p>|</p>

<p>与，and</p>

<p>-o</p>

<p>|</p>

<p>||</p>

<p>|</p>

<p>或，or</p>

<p>!</p>

<p>|</p>

<p>!</p>

<p>|</p>

<p>非，not</p>

<h5 id="2-示例-1">2、示例</h5>

<p>f1=/etc/rc.local</p>

<p>f2=/etc/services</p>

<p>[ -f &ldquo;$f1&rdquo; -a -f &ldquo;$f2&rdquo; ] &amp;&amp; echo 1 ||echo 0</p>

<p>1</p>

<p>[ -f &ldquo;$f1&rdquo; -a -f &ldquo;$f2&rdquo; ] &amp;&amp; echo 1 ||echo 0</p>

<p>1</p>

<p>[[ -f &ldquo;$f1&rdquo; &amp;&amp; -f &ldquo;$f2&rdquo; ]] &amp;&amp;echo 1 || echo 0</p>

<p>1</p>

<p>[[ -f &ldquo;$f1&rdquo; &amp;&amp; -f &ldquo;$f2&rdquo; ]] &amp;&amp;echo 1 || echo 01</p>

<p>[ -n &ldquo;$f1&rdquo; -a -z &ldquo;$f2&rdquo; ] &amp;&amp; echo 1 ||echo 0</p>

<p>0</p>

<p>[ -n &ldquo;$f1&rdquo; || &ldquo;$f1&rdquo; = &ldquo;$f2&rdquo; ] &amp;&amp; echo 1 || echo0 <strong># 报错，[]不能用||</strong></p>

<p>-bash: [:missing `]&rsquo;</p>

<p>1</p>

<p>[[ -n &ldquo;$f1&rdquo; || &ldquo;$f1&rdquo; = &ldquo;$f2&rdquo; ]] &amp;&amp; echo 1 || echo0</p>

<p>1</p>

<p>[ -n &ldquo;$f1&rdquo; -o &ldquo;$f1&rdquo; = &ldquo;$f2&rdquo; ] &amp;&amp; echo 1 || echo0 #字符串内容比较</p>

<p>1</p>

<p>echo ${#f1} #求字符串长度</p>

<p>13</p>

<p>echo ${#f2}</p>

<p>13</p>

<p>[ -n &ldquo;$f1&rdquo; -a &ldquo;${#f1}&rdquo; = &ldquo;${#f2}&rdquo; ] &amp;&amp; echo 1 ||echo 0 #字符串长度比较</p>

<p>1</p>

<h4 id="十四-学习系统脚本">十四、学习系统脚本</h4>

<h6 id="1-etc-init-d-nfs">（1）/etc/init.d/nfs</h6>

<p>cat /etc/init.d/nfs</p>

<p>#!/bin/sh</p>

<h1 id="source-functionlibrary">Source functionlibrary.</h1>

<p>./etc/rc.d/init.d/functions</p>

<h1 id="sourcenetworking-configuration">Sourcenetworking configuration.</h1>

<p>[ -f/etc/sysconfig/network ] &amp;&amp; ./etc/sysconfig/network</p>

<h1 id="check-for-andsource-configuration-file-otherwise-set-defaults">Check for andsource configuration file otherwise set defaults</h1>

<p>[ -f/etc/sysconfig/nfs ] &amp;&amp; . /etc/sysconfig/nfs</p>

<h1 id="remote-quotaserver">Remote quotaserver</h1>

<p>[ -z&rdquo;$RQUOTAD&rdquo; ] &amp;&amp; RQUOTAD=<code>type -path rpc.rquotad</code></p>

<p>RETVAL=0</p>

<p>uid=<code>id | cut-d\\( -f1 | cut -d= -f2</code></p>

<h1 id="see-how-wewere-called">See how wewere called.</h1>

<p>case&rdquo;$1&rdquo; in</p>

<p>start)</p>

<h1 id="check-that-networking-is-up">Check that networking is up.</h1>

<p>[ &ldquo;${NETWORKING}&rdquo; !=&ldquo;yes&rdquo; ] &amp;&amp; exit 6</p>

<p>[ -x /usr/sbin/rpc.nfsd ] || exit 5</p>

<p>[ -x /usr/sbin/rpc.mountd ] || exit 5</p>

<p>[ -x /usr/sbin/exportfs ] || exit 5</p>

<h1 id="make-sure-the-rpc-mountd-is-notalready-running">Make sure the rpc.mountd is notalready running.</h1>

<p>if status rpc.mountd &gt; /dev/null ;then</p>

<p>exit 0</p>

<p>fi</p>

<p>。。。。。。</p>

<h6 id="2-etc-init-d-crond">（2）/etc/init.d/crond</h6>

<p>cat /etc/init.d/crond</p>

<p>#!/bin/sh</p>

<p>[ -f/etc/sysconfig/crond ] || {</p>

<p>[ &ldquo;$1&rdquo; = &ldquo;status&rdquo; ]&amp;&amp; exit 4 || exit 6</p>

<p>}</p>

<p>&hellip;&hellip;</p>

<p>[ $UID -eq 0 ]&amp;&amp; [ -e /etc/sysconfig/$prog ] &amp;&amp; . /etc/sysconfig/$prog</p>

<p>start() {</p>

<p>if [ $UID -ne 0 ] ; then</p>

<p>echo &ldquo;User has insufficientprivilege.&rdquo;</p>

<p>exit 4</p>

<p>fi</p>

<p>[ -x $exec ] || exit 5</p>

<p>[ -f $config ] || exit 6</p>

<p>&hellip;&hellip;</p>

<p>}</p>

<h6 id="3-etc-rc-d-rc-sysinit">（3）/etc/rc.d/rc.sysinit</h6>

<p>cat /etc/rc.d/rc.sysinit</p>

<p>#!/bin/bash</p>

<h1 id="print-a-text-banner">Print a text banner.</h1>

<p>echo -en$&rdquo;\t\tWelcome to &ldquo;</p>

<p>read -rsystem_release &lt; /etc/system-release</p>

<p>if [[&ldquo;$system_release&rdquo; == <em>&ldquo;Red Hat&rdquo;</em> ]]; then</p>

<p>[ &ldquo;$BOOTUP&rdquo; = &ldquo;color&rdquo; ]&amp;&amp; echo -en &ldquo;\\033[0;31m&rdquo;</p>

<p>echo -en &ldquo;Red Hat&rdquo;</p>

<p>[ &ldquo;$BOOTUP&rdquo; = &ldquo;color&rdquo; ]&amp;&amp; echo -en &ldquo;\\033[0;39m&rdquo;</p>

<p>PRODUCT=$(sed &ldquo;s/Red Hat \(.<em>\)release.</em>/\1/&rdquo; /etc/system-release)</p>

<p>echo &ldquo; $PRODUCT&rdquo;</p>

<p>elif [[&ldquo;$system_release&rdquo; == <em>Fedora</em> ]]; then</p>

<p>[ &ldquo;$BOOTUP&rdquo; = &ldquo;color&rdquo; ]&amp;&amp; echo -en &ldquo;\\033[0;34m&rdquo;</p>

<p>echo -en &ldquo;Fedora&rdquo;</p>

<p>[ &ldquo;$BOOTUP&rdquo; = &ldquo;color&rdquo; ]&amp;&amp; echo -en &ldquo;\\033[0;39m&rdquo;</p>

<p>PRODUCT=$(sed &ldquo;s/Fedora \(.<em>\)\?release.</em>/\1/&rdquo; /etc/system-release)</p>

<p>echo &ldquo; $PRODUCT&rdquo;</p>

<p>elif [[&ldquo;$system_release&rdquo; =~ &ldquo;CentOS&rdquo; ]]; then</p>

<p>[ &ldquo;$BOOTUP&rdquo; = &ldquo;color&rdquo; ]&amp;&amp; echo -en &ldquo;\\033[0;36m&rdquo;</p>

<p>echo -en &ldquo;CentOS&rdquo;</p>

<p>[ &ldquo;$BOOTUP&rdquo; = &ldquo;color&rdquo; ]&amp;&amp; echo -en &ldquo;\\033[0;39m&rdquo;</p>

<p>PRODUCT=$(sed &ldquo;s/CentOS \(.<em>\)\?release.</em>/\1/&rdquo; /etc/system-release)</p>

<p>echo &ldquo; $PRODUCT&rdquo;</p>

<p>else</p>

<p>PRODUCT=$(sed &ldquo;s/ release.*//g&rdquo;/etc/system-release)</p>

<p>echo &ldquo;$PRODUCT&rdquo;</p>

<p>fi</p>

<p>&hellip;&hellip;</p>

<h4 id="十五-综合示例1-linux-web服务监控">十五、综合示例1：Linux Web服务监控</h4>

<h5 id="1-思路-1">1、思路</h5>

<h6 id="1-监控端口">（1）监控端口</h6>

<p>本地：ss、netstat、lsof</p>

<p>远程：telnet、nmap、nc</p>

<p>注：查看远端的端口是否通畅3个简单实用案例<a href="http://oldboy.blog.51cto.com/2561410/942530">http://oldboy.blog.51cto.com/2561410/942530</a></p>

<h6 id="2-查看本地进程数">（2）查看本地进程数</h6>

<h6 id="3-http连接查看httpcode">（3）Http连接查看httpcode</h6>

<p>header、curl -l：返回200就OK</p>

<p>注：掌握技术思想比解决问题本身更重要<a href="http://oldboy.blog.51cto.com/2561410/1196298">http://oldboy.blog.51cto.com/2561410/1196298</a></p>

<h6 id="4-模拟用户的方式">（4）模拟用户的方式</h6>

<p>URL（wget、curl）</p>

<p>PHP、Java等应用程序监控</p>

<h5 id="2-单项测试">2、单项测试</h5>

<h6 id="1-监控端口-1">（1）监控端口</h6>

<p>a、本地监控：</p>

<p>lsof -i :80 | wc-l #一般要求大于等于1</p>

<p>b、远程监控：</p>

<p>nmap 192.168.1.5-p 80 | grep open | wc -l #一般要求大于等于1</p>

<h6 id="2-查看本地进程数-1">（2）查看本地进程数</h6>

<p>ps -ef | grepapache | wc -l #一般要求大于2或3</p>

<h6 id="3-http连接查看httpcode-1">（3）Http连接查看httpcode</h6>

<p>a、原始内容</p>

<p>curl -I <a href="http://192.168.1.5">http://192.168.1.5</a></p>

<p>HTTP/1.1 200 OK</p>

<p>Date: Tue, 30May 2017 02:20:04 GMT</p>

<p>Server: Apache</p>

<p>Last-Modified:Wed, 22 Feb 2017 13:40:55 GMT</p>

<p>ETag:&ldquo;1bf365-13-5491ea5590f07&rdquo;</p>

<p>Accept-Ranges:bytes</p>

<p>Content-Length:19</p>

<p>Content-Type:text/html</p>

<p>b、失败的获取httpcode方式（也就是HTTP/1.1 200 OK这行）</p>

<p>curl -I <a href="http://192.168.1.5">http://192.168.1.5</a> | head -1</p>

<p>% Total % Received% Xferd Average Speed Time Time Time &hellip;</p>

<p>0 19 0 0 0 0 0 0 &ndash;:&ndash;:&ndash; &ndash;:&ndash; &hellip;</p>

<p>HTTP/1.1 200 OK</p>

<p>curl -I <a href="http://192.168.1.5">http://192.168.1.5</a> | grep HTTP/1.1</p>

<p>% Total %Received % Xferd Average Speed Time TimeTime &hellip;</p>

<p>0 19 0 0 0 0 0 0 &ndash;:&ndash;:&ndash; &ndash;:&ndash; &hellip;</p>

<p>HTTP/1.1 200 OK</p>

<p>curl -I <a href="http://192.168.1.5">http://192.168.1.5</a> | grep HTTP/1.1 | tail -1</p>

<p>% Total %Received % Xferd Average Speed Time TimeTime &hellip;</p>

<p>0 19 0 0 0 0 0 0 &ndash;:&ndash;:&ndash; &ndash;:&ndash; &hellip;</p>

<p>HTTP/1.1 200 OK</p>

<p>c、获取httpcode方式一：wget</p>

<p>（i）步骤一：获取header</p>

<p>wget &ndash;spider&ndash;timeout=5 &ndash;tries=2 192.168.1.5</p>

<p>Spider modeenabled. Check if remote file exists.</p>

<p>--2017-05-3010:45:00&ndash; <a href="http://192.168.1.5/">http://192.168.1.5/</a></p>

<p>Connecting to 192.168.1.5:80&hellip;connected.</p>

<p>HTTP requestsent, awaiting response&hellip; 200 OK</p>

<p>Length: 19[text/html]</p>

<p>Remote fileexists and could contain further links,</p>

<p>but recursion isdisabled &ndash; not retrieving.</p>

<p>（ii）步骤二：通过命令返回值判断wget命令是否正确执行</p>

<p>wget &ndash;spider&ndash;timeout=5 &ndash;tries=2 192.168.1.92 &amp;&gt;/dev/null</p>

<p>echo $?</p>

<p>4 #192.168.1.92不存在，返回值错误</p>

<p>wget &ndash;spider&ndash;timeout=5 &ndash;tries=2 192.168.1.5 &amp;&gt;/dev/null</p>

<p>echo $?</p>

<p>0 #正确</p>

<p>d、获取httpcode方式二：curl</p>

<p>（i）步骤一：获取第一行：HTTP/1.1200 OK</p>

<p>curl -I -shttp://192.168.1.5 | head -1</p>

<p>HTTP/1.1 200 OK</p>

<p>curl -I <a href="http://192.168.1.5">http://192.168.1.5</a> 2&gt;/dev/null | head -1</p>

<p>HTTP/1.1 200 OK</p>

<p>（ii）步骤二：直接获取httpcode</p>

<p>curl -I -s -w&rdquo;%{http_code}&rdquo; -o /dev/null <a href="http://192.168.1.5">http://192.168.1.5</a></p>

<p>200</p>

<h6 id="4-模拟用户的方式-1">（4）模拟用户的方式</h6>

<p>$link_id=mysql_connect(&lsquo;localhost&rsquo;,&lsquo;root&rsquo;,&lsquo;123456&rsquo;) or mysql_error();</p>

<p>if($link_id){</p>

<p>echo &ldquo;mysqlsuccessful by aaa&rdquo;;</p>

<p>}else{</p>

<p>echo mysql_error();</p>

<p>}</p>

<p>?&gt;</p>

<h5 id="3-完整脚本-以curl为例">3、完整脚本（以curl为例）</h5>

<p>vi /service/scripts/check_web.sh</p>

<p>#!/bin/sh</p>

<p>http_code=<code>curl-I -s -w &quot;%{http_code}&quot; -o /dev/null http://192.168.1.5</code></p>

<p>if [ $http_code-ne 200 ]</p>

<p>then</p>

<p>echo &ldquo; Web is error.&rdquo;</p>

<p>else</p>

<p>echo &ldquo; Web is OK.&rdquo;</p>

<p>fi</p>

<p>sh check_web.sh</p>

<p>Web is OK.</p>

<p>/application/apache/bin/apachectl stop</p>

<p>sh check_web.sh</p>

<p>Web is error.</p>

<p>/application/apache/bin/apachectl start</p>

<p>sh check_web.sh</p>

<p>Web is OK.</p>

<h4 id="十六-综合示例2-利用系统函数模拟实现web服务脚本启动的特殊颜色效果">十六、综合示例2：利用系统函数模拟实现web服务脚本启动的特殊颜色效果</h4>

<h5 id="1-系统脚本效果">1、系统脚本效果</h5>

<h5 id="2-完整脚本">2、完整脚本</h5>

<p>vi /services/scripts/webctl_apache.sh</p>

<p>#!/bin/sh</p>

<p>./etc/init.d/functions</p>

<p>if [ $# -ne 1 ]</p>

<p>then</p>

<p>echo &ldquo;USAGE $0{start|stop|restart}&rdquo;</p>

<p>exit 1</p>

<p>fi</p>

<p>if [&ldquo;$1&rdquo; == &ldquo;start&rdquo; ]</p>

<p>then</p>

<p>action &ldquo;Starting webctl_apache: &ldquo; /bin/true</p>

<p>exit 0</p>

<p>elif [&ldquo;$1&rdquo; == &ldquo;stop&rdquo; ]</p>

<p>then</p>

<p>action &ldquo;Stopping webctl_apache: &ldquo; /bin/true</p>

<p>exit 0</p>

<p>elif [&ldquo;$1&rdquo; == &ldquo;restart&rdquo; ]</p>

<p>then</p>

<p>action &ldquo;Stopping webctl_apache: &ldquo; /bin/true</p>

<p>action &ldquo;Starting webctl_apache: &ldquo; /bin/true</p>

<p>exit 0</p>

<p>else</p>

<p>echo &ldquo;USAGE $0&rdquo; {start|stop|restart}</p>

<p>exit 1</p>

<p>fi</p>

<h5 id="3-脚本演示">3、脚本演示</h5>

<p>sh webctl_apache.sh</p>

<p>USAGEwebctl_apache.sh {start|stop|restart}</p>

<p>sh webctl_apache.sh start</p>

<p>Startingwebctl_apache: [ OK ]</p>

<p>sh webctl_apache.sh stop</p>

<p>Stoppingwebctl_apache: [ OK ]</p>

<p>sh webctl_apache.sh restart</p>

<p>Stoppingwebctl_apache: [ OK ]</p>

<p>Startingwebctl_apache: [ OK ]</p>

<h4 id="十七-综合示例3-监控web站点目录下所有文件是否被篡改">十七、综合示例3：监控web站点目录下所有文件是否被篡改</h4>

<h5 id="1-要求-1">1、要求</h5>

<h6 id="1-站点目录-var-html-www">（1）站点目录：/var/html/www</h6>

<h6 id="2-将被篡改的文件的文件名发邮件给管理员">（2）将被篡改的文件的文件名发邮件给管理员</h6>

<h6 id="3-每3分钟执行一次检查">（3）每3分钟执行一次检查</h6>

<h5 id="2-思路">2、思路</h5>

<p>（1）什么是恶意篡改：只要未经许可的改动都是篡改</p>

<p>（2）文件被篡改后的特征</p>

<p>a、大小可能会有变化</p>

<p>b、修改时间会变化（通过文件测试符：ot、nt来判断）</p>

<p>c、文件内容会变化（通过md5 sum指纹来判断）</p>

<p>d、增加或删除文件</p>

<p>（3）</p>

<h5 id="3-完整脚本">3、完整脚本</h5>

<p>vi /services/scripts/webSiteCheck.sh</p>

<h5 id="4-脚本演示">4、脚本演示</h5>

<h4 id="十八-后台执行脚本">十八、后台执行脚本</h4>

<h5 id="1-防止脚本执行中断的方法">1、防止脚本执行中断的方法</h5>

<h6 id="1-sh-test-sh">（1）sh test.sh &amp;</h6>

<h6 id="2-screen命令">（2）screen命令</h6>

<h6 id="3-nohup-test-sh">（3）nohup test.sh &amp;</h6>

<h5 id="2-后台执行脚本的控制">2、后台执行脚本的控制</h5>

<p>命令</p>

<p>|</p>

<p>功能</p>

<p>&mdash;|&mdash;</p>

<p>sh test.sh &amp;</p>

<p>|</p>

<p>把脚本test.sh放到后台执行</p>

<p>ctrl + c</p>

<p>|</p>

<p>停止执行当前脚本或任务</p>

<p>ctrl + z</p>

<p>|</p>

<p>暂停执行当前脚本或任务</p>

<p>bg</p>

<p>|</p>

<p>把当前脚本或任务放到后台执行</p>

<p>fg</p>

<p>|</p>

<p>把当前脚本或任务拿到前台执行，如果有多个任务，可以fg加任务编号调出，如fg 1</p>

<p>jobs</p>

<p>|</p>

<p>查看执行的脚本或任务</p>

<h5 id="3-示例-1">3、示例</h5>

<h6 id="1-示例1-bg命令演示">（1）示例1：bg命令演示</h6>

<p>a、场景</p>

<p>已执行sh while01.sh，但忘记加&amp;，让脚本后台执行，发现时，该脚本已执行完一半任务，不想停止脚本，全部重新执行，希望把脚本直接放到后台继续执行。</p>

<p>b、操作步骤</p>

<p>（i）ctrl + Z：先暂停脚本的执行</p>

<p>（ii）bg ：将脚本放到后台继续执行</p>

<p>c、脚本演示</p>

<p>cat while01.sh</p>

<p>#!/bin/sh</p>

<p>while true</p>

<p>do</p>

<p>uptime &gt;&gt;/var/log/uptime.log</p>

<p>sleep 2</p>

<p>done</p>

<p>sh while01.sh</p>

<p>^Z # <strong>这是 ctrl + z</strong></p>

<p>[1]+ Stopped sh while01.sh</p>

<p>bg</p>

<p>[1]+ sh while01.sh &amp; # <strong>脚本已在后台继续执行</strong></p>

<h6 id="2-示例2-fg命令演示">（2）示例2：fg命令演示</h6>

<p>a、场景</p>

<p>后台已执行2个while01.sh脚本，希望把第2个脚本停止执行。</p>

<p>b、操作步骤</p>

<p>（i）jobs：查看当前正在执行的脚本或任务</p>

<p>（ii）fg 2 ：将第2个脚本放到前台执行</p>

<p>（iii）ctrl + c ：停止执行第2个脚本</p>

<p>c、脚本演示</p>

<p>sh while01.sh &amp;</p>

<p>[1] 3980</p>

<p>sh while01.sh &amp;</p>

<p>[2] 3985</p>

<p>jobs</p>

<p>[1]- Running sh while01.sh &amp;</p>

<p>[2]+ Running sh while01.sh &amp;</p>

<p>fg 2</p>

<p>sh while01.sh</p>

<p>^C # <strong>这是 ctrl + c</strong></p>

<p>jobs</p>

<p>[1]+ Running sh while01.sh &amp;</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>