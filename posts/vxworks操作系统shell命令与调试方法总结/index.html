<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">


    <title>VxWorks操作系统shell命令与调试方法总结 | 开发者问答集锦</title>
    <meta property="og:title" content="VxWorks操作系统shell命令与调试方法总结 - 开发者问答集锦">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-09-02T00:00:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-09-02T00:00:00&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="VxWorks操作系统shell命令与调试方法总结">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://zaina.newban.cn/posts/vxworks%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fshell%E5%91%BD%E4%BB%A4%E4%B8%8E%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    
    
    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://zaina.newban.cn">
                        开发者问答集锦
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://zaina.newban.cn">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">VxWorks操作系统shell命令与调试方法总结</h1>
        </header>
        <date class="post-meta meta-date">
            2020年9月2日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>目录(?)[+]</p>

<p>VxWorks下的调试手段</p>

<p>主要介绍在Tornado集成开发环境下的调试方法，和利用支撑定位问题的步骤、思路。</p>

<h1 id="1-tornado的调试工具">1 Tornado的调试工具</h1>

<p>嵌入式实时操作系统VxWorks和集成开发环境Tornado的组成结构如下图1。分为主机和目标机系统。</p>

<p>图1 集成开发环境结构图</p>

<p>在Tornado下，调试相关操作在Debug菜单下，包括：</p>

<p>图2 Debug菜单</p>

<p>简单解释各菜单项的功能</p>

<h2 id="1-1-windshell">1.1 WindShell</h2>

<h3 id="1-1-1-简介">1.1.1 简介</h3>

<p>Vxworks的Shell分为两种：hostshell 和 target shell；</p>

<p>Tornado提供的WindShell建立了2者间的一个桥梁,从宿主机到目标机之间的一个命令 shell。WindSh
是一种非常受欢迎的开发工具，它具有很强的交互性和可操作性，允许用户调用内存中的应用程序模块或是
VxWorks模块中的任何例程。它不但具有一般命令语言的功能，而且也具有 C 语言的设计特点，能够解释几乎任何 C 语言表达式， 执行大多数 C
语言算子，解析符号表数据。对初用者来说，WindSh学习起来比较简单，使用比较方便，对熟练用户而言，则有较为高级的手段可以应用。</p>

<p>WindSh是一个驻留在主机内的C语言解释器，通过它可运行下载到目标机上的所有函数，包括VxWorks系统调用和应用函数。Tornado外壳还能解释常规的工具命令语言TCL。</p>

<p>WindSh不仅可以解释几乎所有的C语言表达式，而且可以实现所有的调试功能。它主要有以下调试功能：下载软件模块；删除软件模块；产生任务；删除任务；设置断点；删除断点；运行、单步、继续执行程序；查看内存、寄存器、变量；修改内存、寄存器、变量；查看任务列表、内存使用情况、CPU利用率；查看特定的对象（任务、信号量、消息队列、内存分区、类）；复位目标机等。</p>

<h3 id="1-1-2-功能键">1.1.2 功能键</h3>

<p>Tab</p>

<p>补齐剩余部分</p>

<p>Ctrl+D</p>

<p>l 显示与之匹配的所有符号</p>

<p>-&gt; CurM^D</p>

<p>_CurMaster _CurModule</p>

<p>l 补齐剩余部分：</p>

<p>-&gt;CurMo^D</p>

<p>-&gt;CurModule</p>

<p>l 显示命令摘要</p>

<p>-&gt;moduleShow ^D</p>

<p>moduleShow() - show the current status for all theloaded modules (WindSh)</p>

<p>STATUS moduleShow</p>

<p>(</p>

<p>char <em>moduleNameOrId /</em> name or ID of the module to show */</p>

<p>)</p>

<p>Ctrl+W</p>

<p>键入完整的命令后，继续键入空格+ [Ctrl+W]。将会显示html页帮助信息.</p>

<p>Ctrl+H</p>

<p>删除一字符</p>

<p>Ctrl+U</p>

<p>删除一行</p>

<p>CTRL+C</p>

<p>重起shell</p>

<p>CTRL+X</p>

<p>Reboot</p>

<p>CTRL+S</p>

<p>临时挂起输出</p>

<p>CTRL+Q</p>

<p>恢复挂起</p>

<p>Esc</p>

<p>在输入和编辑模式间切换</p>

<p>输入类似Vi编辑命令, 如[Esc + k]：显示前一次输入的命令</p>

<p>h←j↓k↑l→</p>

<p>h()设置命令缓冲区长度。-&gt;h 500</p>

<h3 id="1-1-3-特殊控制符">1.1.3 特殊控制符</h3>

<p>?</p>

<p>C和TCL模式转换符号, 在c模式下敲?进入tcl模式, 在tcl下敲?则进入c模式;</p>

<p>@</p>

<p>在target还是在host上运行, 在指令前加上@则在target上运行, 否则在host上运行</p>

<blockquote>
</blockquote>

<p>指令输出重定向</p>

<p>指令输入重定向</p>

<h3 id="1-1-4-计算功能">1.1.4 计算功能</h3>

<p>数据转换：键入整数或字符后回车可以显示该整数的十进制及十六进制值。也可以键入字符常量或符号地址。</p>

<p>比如：</p>

<p>-&gt;0x54+64</p>

<p>value = 148 = 0x94</p>

<p>-&gt;x = (8 * 6) / 4</p>

<p>x = 0x20ff378: value = 12 = 0xc</p>

<p>-&gt;Nom = “Nelson”</p>

<p>new symbol “Nom” added to symbol table.</p>

<p>Nom = 0x23fe798: value = 37742496 = 0x23fe7a0 =</p>

<p>Nom + 0x8</p>

<h3 id="1-1-5-环境变量">1.1.5 环境变量</h3>

<p>使用 ？shConfig 命令修改环境变量:</p>

<p>SH_GET_TASK_IO</p>

<p>为调用函数设置I/O重定向。ON:重定向到WindSh;OFF:I/O显示到目标机控制台。</p>

<p>LD_PATH</p>

<p>为模块设置搜索路径，用“；”隔开。 例如：ld 命令提交后，Shell搜寻模块的路径顺序为：首先在当前目录，然后到LD_PATH设置的路径。</p>

<p>LD_SEND_MODULES</p>

<p>设置load模式。</p>

<p>以下3个用不到</p>

<p>LD_CALL_XTORS</p>

<p>LD_COMMON_MATCH_ALL</p>

<p>DSM_HEX_MOD</p>

<h3 id="1-1-6-内置指令">1.1.6 内置指令</h3>

<h4 id="1-1-6-1-所有内置指令">1.1.6.1 所有内置指令</h4>

<p>tcl&gt; setshellProcList</p>

<p>b bh bd bdall ccret e s so sysResume sysSuspend d l ld lkAddr lkup m mRegs
unld agentMode Showbrowse checkStack classShow devs i intVecShow iStrict
iosDevShow iosDrvShowiosFdShow memPartShow memShow moduleIdFigure moduleShow
mqPxShow mqShowmsgQShow rBuffShow semPxSho w semShow show smMemPartShow
smMemShowsysStatusShow taskShow trgShow version wdShow sp sp s
taskIdDefaulttaskIdFigure td ti tr ts tt bootChange cd h help ls period
printErrno printLogo pwd quit reboot repeat shellHistory shellPromptSet
cplusXtorSetcplusStratShow cplus Ctors cplusDtors wvHostInfoShow
evtBufferToFile hostShowicmpstatShow ifShow inetstatShow ipstatShow
routestatShow taskCreateHookShowtaskDeleteHookShow taskSwitchHookShow taskRegs
Show tw w taskWaitShowtcpstatShow tftpInfoShow udpstatShow</p>

<h4 id="1-1-6-2-任务管理">1.1.6.2 任务管理</h4>

<p>sp</p>

<p>用缺省参数创建一个任务（priority=100 返回值为任务ID，或错误）,立刻返回。任务的I/O不被重定向到shell。</p>

<p>如果直接敲例程名，回车，执行完才返回。I/O被重定向。</p>

<p>sps</p>

<p>与上者不同在于启动该任务后马上将其挂起</p>

<p>tr</p>

<p>恢复一个挂起的任务</p>

<p>ts</p>

<p>挂起一个任务</p>

<p>td</p>

<p>删除一个任务</p>

<p>period</p>

<p>创建一个周期调用函数的任务</p>

<p>period 5testPrn 每隔5秒调用testPrn，易于做调试打印。</p>

<p>repeat</p>

<p>创建一个重复调用函数的任务</p>

<p>repeat 10testFunc1 连续执行10次testFunc1函数，易于做测试用。</p>

<p>mRegs</p>

<p>修改任务的寄存器变量。比较有用的是修改pc值，使程序退回到具体位置再运行。 程序位置可以使用shift+F7(混合汇编方式显示代码)</p>

<p>-&gt; mRegs&rdquo;pc&rdquo;, s1u0</p>

<p>pc : 0499efd7 - 0x499efd1</p>

<h4 id="1-1-6-3-任务状态信息">1.1.6.3 任务状态信息</h4>

<p>i 显示系统信息:</p>

<p>NAME ENTRY TID PRI STATUS PC SP ERRNO DELAY</p>

<h2 id="toc_11">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; &mdash;&mdash;&ndash; &mdash; &mdash;&mdash;&mdash;- &mdash;&mdash;&ndash; &mdash;&mdash;&ndash; &mdash;&mdash;-</h2>

<p>tExcTask _excTask 4b79170 0 PEND 4276be 4b7908c d0003 0</p>

<p>iStrict 类似于i，但只查询目标机一次</p>

<p>ti 显示相应任务的TCB信息:</p>

<p>-&gt; ti tWdbTask</p>

<p>NAME ENTRY TID PRI STATUS PC SP ERRNO DELAY</p>

<h2 id="toc_12">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; &mdash;&mdash;&ndash; &mdash; &mdash;&mdash;&mdash;- &mdash;&mdash;&ndash; &mdash;&mdash;&ndash; &mdash;&mdash;-</h2>

<p>tWdbTask 0x417cc4 4b70c08 3 READY 4276be 4b70ae4 d0003 0</p>

<p>stack: base 0x4b70c08 end 0x4b6ccc8 size 16176 high 3840 margin 12336</p>

<p>options: 0xe</p>

<p>VX_UNBREAKABLE VX_DEALLOC_STACK VX_FP_TASK</p>

<p>edi = ffffffff esi = 4b70fb8 ebp = 4b70aec esp = 4b70ae4</p>

<p>ebx = 0 edx = 4276be ecx = 10101 eax = 0</p>

<p>eflags = 212 pc = 4276be</p>

<p>taskShow</p>

<p>显示任务TCB信息, 基本同ti</p>

<p>taskCreateHookShow</p>

<p>显示任务创建调用例程列表</p>

<p>_fppCreateHook 0x177008</p>

<p>_envCreateHook 0x156954</p>

<p>___wdbTaskCreat 0x114718</p>

<p>taskDeleteHookShow</p>

<p>显示任务删除调用例程列表</p>

<p>taskSwitchHookShow</p>

<p>显示任务切换调用例程列表</p>

<p>_dbgTaskSwitch 0x180384</p>

<p>_SwitchHook 0xde7b78</p>

<p>w</p>

<p>显示所有或者一个挂起任务的信息</p>

<p>-&gt; w s1u1</p>

<p>NAME ENTRY TID STATUS DELAY OBJ_TYPE OBJ_ID OBJ_NAME</p>

<h2 id="toc_13">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &mdash;&mdash;&ndash; &mdash;&mdash;&mdash;- &mdash;&ndash; &mdash;&mdash;&mdash;- &mdash;&mdash;&ndash;</h2>

<p>s1u1 _t2 4b65898 PEND 0 SEM_M 4b7ea48 N/A</p>

<p>tw</p>

<p>显示某挂起任务的详细信息。</p>

<p>-&gt; tw s1u1</p>

<p>NAME ENTRY TID STATUS DELAY OBJ_TYPE OBJ_ID OBJ_NAME</p>

<h2 id="toc_14">-&mdash;&mdash;&mdash; &mdash;&mdash;&mdash;- &mdash;&mdash;&ndash; &mdash;&mdash;&mdash;- &mdash;&ndash; &mdash;&mdash;&mdash;-</h2>

<p>s1u1 _t2 4b65898 PEND 0 SEM_M 4b7ea48 N/A</p>

<p>Semaphore Id : 0x4b7ea48</p>

<p>Semaphore Type : MUTEX</p>

<p>Task Queueing : FIFO</p>

<p>Pended Tasks : 1</p>

<p>State : Owner=0x4b6c960</p>

<p>taskWaitShow</p>

<p>同tw</p>

<p>taskRegsShow</p>

<p>显示任务寄存器的内容</p>

<p>-&gt;taskRegsShow 0x1c615534</p>

<p>edi = 0 esi = 1dd65514 ebp = 1c61546c esp = 1c615458</p>

<p>ebx = 1 edx = 1dfccac8 ecx = 7 eax = 0</p>

<p>eflags = 246 pc = 119604</p>

<p>CheckStack</p>

<p>显示一个任务的使用堆栈的情况，没有定义任务时显示所有</p>

<p>-&gt; checkStack tWdbTask</p>

<p>NAME ENTRY TID SIZE CUR HIGH MARGIN</p>

<p>-&mdash;&mdash;&mdash;&ndash; &mdash;&mdash;&mdash;&mdash; &mdash;&mdash;&ndash; &mdash;&ndash; &mdash;&ndash; &mdash;&mdash;&mdash;&ndash;</p>

<p>tWdbTask 0x417cc4 4b70c08 16176 292 3840 12336</p>

<p>tt</p>

<p>显示一个任务的调用状况,解析堆栈</p>

<p>-&gt; tt tShell</p>

<p>地址 函数名 偏移 被调用函数（函数参数）</p>

<p>43ad37 _vxTaskEntry +47 : _shell (1, 0,0, 0, 0, 0, 0, 0, 0, 0)</p>

<p>41c414 _shell +13c: 41c438 ([1,0, 0, 0, 41c23c])</p>

<p>41c52e _shell +256: _ledRead(522efb8, 51e45e4, 80)</p>

<p>如果认为被挂起，可找出在哪个函数调用时失败。</p>

<p>taskIdFigure</p>

<p>报告任务的ID,以及名称</p>

<p>taskIdDefault</p>

<p>设置或者取得缺省的任务id</p>

<p>int taskIdDefault</p>

<p>(</p>

<p>int tid /* user-supplied task ID; if 0,return default */</p>

<p>)</p>

<p>taskPrioritySet</p>

<p>实时改变任务运行的优先级</p>

<h4 id="1-1-6-4-一组调试指令">1.1.6.4 一组调试指令</h4>

<p>d</p>

<p>显示目标机内存, 可以替代内存观察;</p>

<p>如： d 0x12345, 128, 1 显示128个字节</p>

<p>d 0x12345, 32, 4 显示32个DWORD</p>

<p>m 0x12345, 128, 1</p>

<pre><code>      m  0x12345, 32,  4
</code></pre>

<p>m</p>

<p>修改内存</p>

<pre><code>void m


(


void * adrs, /* address to change */


int    width /* width of unit to be modified (1, 2, 4, 8) */
</code></pre>

<p>)</p>

<p>lkup</p>

<p>显示指定符号信息, 和以下指令使用可以找到该变量附近变量, 对于查找变量被更改很有益处</p>

<p>-&gt; lkup &ldquo;CurModule&rdquo;</p>

<p>_CurModule 0x01fd3160 comm (down.out)</p>

<p>-&gt; lkup (“^_print”)</p>

<p>_printf 0x00029622 text (vxWorks)</p>

<p>_printErr 0x00029640 text (vxWorks)</p>

<p>_printExc 0x0002965e text (vxWorks)</p>

<p>value = 0 = 0x0</p>

<p>lkAddr</p>

<p>根据指定值搜索符号表，显示的符号地址小于并最接近指定值</p>

<p>-&gt; lkAddr 0x01fd3160</p>

<p>_CurUnit 0x01fd315c comm (down.out)</p>

<p>_CurModule 0x01fd3160 comm (down.out)</p>

<p>_IsFsStarted 0x01fd3164 comm (down.out)</p>

<p>_IntTaskSemaphore 0x01fd3168 comm (down.out)</p>

<p>_gtSemTaskTable 0x01fd316c comm (down.out)</p>

<p>_tR04ModuleReportState 0x01fd3174 comm (down.out)</p>

<p>l</p>

<p>显示从指定位置开始多少行的汇编</p>

<p>printError</p>

<p>将错误号翻译为具体错误信息。前16位错误号为：module 在vwModNum.h中定义，对应不同头文件。后16位错误号为：error
number在相应的头文件中定义。</p>

<p>-&gt; printErrno 0x110001</p>

<p>0x110001 = S_memLib_NOT_ENOUGH_MEMORY</p>

<p>ld</p>

<p>加载模块到系统</p>

<p>[syms[,noAbort][,&ldquo;name&rdquo;]]Load stdin, or file, into memory</p>

<p>(syms = add symbols to table: -1 = none, 0 = globals, 1 = all)</p>

<p>unld</p>

<p>卸载模块</p>

<p>reboot</p>

<p>reset network devices and transfercontrol to boot ROMs 重起, 有些mp板不能执行;</p>

<p>bootChange</p>

<p>修改启动行参数</p>

<p>boot device : fei</p>

<p>processor number : 0</p>

<p>host name : host</p>

<p>file name : vxWorks</p>

<p>inet on ethernet (e) : 168.2.11.41:ffff0000</p>

<p>inet on backplane (b) :</p>

<p>host inet (h) : 168.2.111.1</p>

<p>gateway inet (g) :</p>

<p>user (u) : x86</p>

<p>ftp password (pw) (blank = use rsh) : x86</p>

<p>flags (f) :</p>

<p>target name (tn) :</p>

<p>startup script (s) :</p>

<p>other (o)</p>

<h4 id="1-1-6-5-系统信息查看">1.1.6.5 系统信息查看</h4>

<p>devs</p>

<p>列出目标机系统上的所有设备, host:是指映象文件所在目录,有些上面为mars:</p>

<p>-&gt; devs</p>

<p>drv name</p>

<p>0 /null</p>

<p>2 /pcConsole/0</p>

<p>2 /pcConsole/1</p>

<p>7 host:</p>

<p>8 /vio</p>

<p>9 /tgtsvr</p>

<p>4 /HDisk</p>

<p>3 prnpip</p>

<p>iosDevShow</p>

<p>基本同devs</p>

<p>iosDrvShow</p>

<p>显示系统中的驱动状态</p>

<p>drv create delete open close read write ioctl</p>

<p>1 421db4 0 421db4 421ddc 42b76c 42b69c 421e08</p>

<p>2 0 0 424fd4 0 425004 425044 425130</p>

<p>3 426e88 426f04 427170 426e34 427228 427254 426ffc</p>

<p>4 415f40 0 415f40 416000 42b76c 42b69c 416074</p>

<p>5 41626c 41642c 416288 416520 4165d0 416670 416710</p>

<p>iosFdShow</p>

<p>显示系统中的文件标识符</p>

<p>fdname drv</p>

<p>3/tyCo/0 1</p>

<p>4/vio/1 4</p>

<p>5/vio/2 4</p>

<p>6/vio/3 4</p>

<p>intVecShow</p>

<p>查看中断向量表,</p>

<p>void intVecShow</p>

<p>(</p>

<p>int vector /* interrupt vector number or -1 to display the whole vectortable
*/</p>

<p>)</p>

<p>moduleShow</p>

<p>显示系统中所有加载的模块</p>

<p>MODULENAME MODULE ID GROUP # TEXT START DATA START BSS START</p>

<h2 id="toc_17">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; &mdash;&mdash;&mdash;- &mdash;&mdash;&mdash;-</h2>

<p>vxWorks.exe 0x365420 1 0x401000 0x43f000 0x442000</p>

<p>test.o 0xd32888 2 0x499efac 0x499eff4</p>

<p>msgQShow</p>

<p>显示队列的使用状况</p>

<p>Message Queue Id : 0x1c710c0c</p>

<p>Task Queueing : FIFO</p>

<p>Message Byte Len : 8</p>

<p>Messages Max : 4000</p>

<p>Messages Queued : 0</p>

<p>Receivers Blocked : 1</p>

<p>Send Timeouts : 0</p>

<p>Receive Timeouts : 709968</p>

<p>SemShow</p>

<p>显示信号量的信息</p>

<p>STATUS semShow</p>

<p>(</p>

<p>SEM_ID semId,/* semaphore to display */</p>

<p>int level /* 0 = summary, 1 = details */</p>

<p>)</p>

<p>-&gt;semShow NodeSemaphore ,0</p>

<p>Semaphore Id : 0x1c7a443c</p>

<p>Semaphore Type : MUTEX</p>

<p>Task Queueing : FIFO</p>

<p>Pended Tasks : 0</p>

<p>State : NotOwned</p>

<p>SemPxShow</p>

<p>显示POSIX信号量的信息</p>

<p>wdShow</p>

<p>显示看门狗的信息</p>

<p>mqPxShow</p>

<p>显示POSIX消息队列的信息</p>

<p>memPartShow</p>

<p>显示分区块及统计信息</p>

<p>memShow</p>

<p>显示系统分区上空闲和已分配空间的总数等等</p>

<p>SUMMARY:</p>

<p>status bytes blocks avg block max block</p>

<p>-&mdash;&ndash; &mdash;&mdash;&mdash;&mdash;&mdash;&ndash; &mdash;&mdash;&mdash;- &mdash;&mdash;&mdash;-</p>

<p>current</p>

<p>free 443257168 140 3166122 442697252</p>

<p>alloc 27726464 517 53629 -</p>

<p>cumulative</p>

<p>alloc 50636892 5873 8621 -</p>

<p>hostShow</p>

<p>显示host列表</p>

<p>hostname inet address aliases</p>

<p>-&mdash;&mdash;- &mdash;&mdash;&mdash;&mdash; &mdash;&mdash;-</p>

<p>vxTarget 168.2.11.9</p>

<p>localhost 127.0.0.1</p>

<p>host 168.2.111.1</p>

<p>arpShow</p>

<p>显示arp列表</p>

<p>LINK LEVEL ARP TABLE</p>

<p>destination gateway flags Refcnt Use Interface</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>168.2.111.1 00:05:5d:e4:14:3b 405 0 6897 fei0</p>

<p>-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p>ifShow</p>

<p>显示网口信息</p>

<p>fei (unit number 0):</p>

<p>Flags:(0x8063) UP BROADCAST RUNNING ARP MULTICAST</p>

<p>Type:ETHERNET_CSMACD</p>

<p>Internetaddress: 168.2.11.9</p>

<p>Broadcastaddress: 168.2.255.255</p>

<p>Netmask0xffff0000 Subnetmask 0xffff0000</p>

<p>Ethernetaddress is 00:d0:d0:10:0b:09</p>

<p>Metric is 0</p>

<p>MaximumTransfer Unit size is 1500</p>

<p>11325 packetsreceived; 6965 packets sent</p>

<p>4374 multicastpackets received</p>

<p>11 multicastpackets sent</p>

<p>0 inputerrors; 0 output errors</p>

<p>0 collisions;0 dropped</p>

<p>lo (unit number 0):</p>

<p>Flags:(0x8069) UP LOOPBACK RUNNING ARP MULTICAST</p>

<p>Type:SOFTWARE_LOOPBACK</p>

<p>Internetaddress: 127.0.0.1</p>

<p>Netmask0xff000000 Subnetmask 0xff000000</p>

<p>Metric is 0</p>

<p>MaximumTransfer Unit size is 32768</p>

<p>0 packetsreceived; 0 packets sent</p>

<p>0 multicastpackets received</p>

<p>0 multicastpackets sent</p>

<p>0 inputerrors; 0 output errors</p>

<p>0 collisions;0 dropped</p>

<p>ipstatShow</p>

<p>显示ip信息</p>

<p>total 7571</p>

<p>badsum 0</p>

<p>tooshort 0</p>

<p>toosmall 0</p>

<p>badhlen 0</p>

<p>badlen 0</p>

<p>infragments 0</p>

<p>fragdropped 0</p>

<p>fragtimeout 0</p>

<p>forward 0</p>

<p>cantforward 0</p>

<p>redirectsent 0</p>

<p>unknownprotocol 6996</p>

<p>nobuffers 0</p>

<p>reassembled 0</p>

<p>outfragments 0</p>

<p>noroute 0</p>

<p>icmpstatShow</p>

<p>显示icmp信息</p>

<p>ICMP:</p>

<p>7060 calls toicmp_error</p>

<p>0 error notgenerated because old message was icmp</p>

<p>Outputhistogram:</p>

<p>destinationunreachable: 7060</p>

<p>0 message withbad code fields</p>

<p>0 message</p>

<p>0 bad checksum</p>

<p>0 message withbad length</p>

<p>0 messageresponse generated</p>

<p>routestatShow</p>

<p>显示路由信息</p>

<p>routing:</p>

<p>0 bad routingredirect</p>

<p>0 dynamicallycreated route</p>

<p>0 new gatewaydue to redirects</p>

<p>12 destinationsfound unreachable</p>

<p>0 use of a wildcard route</p>

<p>tcpstatShow</p>

<p>显示tcp信息</p>

<p>TCP:</p>

<p>11740 packets sent</p>

<p>2840 data packets (137764 bytes)</p>

<p>6 data packets (1867 bytes)retransmitted</p>

<p>5642 ack-only packets (0 delayed)</p>

<p>0 URG only packet</p>

<p>0 window probe packet</p>

<p>0 window update packet</p>

<p>3254 control packets</p>

<p>8485packets received</p>

<p>44 acks (for 2429 bytes)</p>

<p>2801 duplicate acks</p>

<p>0 ack for unsent data</p>

<p>2840 packets (2128 bytes) receivedin-sequence</p>

<p>1 completely duplicate packet (29 bytes)</p>

<p>0 packet with some dup. data (0 byte duped)</p>

<p>2 out-of-order packets (0 byte)</p>

<p>0 packet (0 byte) of data after window</p>

<p>0 window probe</p>

<p>0 window update packet</p>

<p>0 packet received after close</p>

<p>0 discarded for bad checksum</p>

<p>0 discarded for bad header offset field</p>

<p>0 discarded because packet too short</p>

<p>2953 connection requests</p>

<p>0 connection accept</p>

<p>2802 connections established (includingaccepts)</p>

<p>2950 connections closed (including 2798drops)</p>

<p>147 embryonic connections dropped</p>

<p>2846 segments updated rtt (of 5797 attempts)</p>

<p>304 retransmit timeouts</p>

<p>0 connection dropped by rexmit timeout</p>

<p>0 persist timeout</p>

<p>147 keepalive timeouts</p>

<p>0 keepalive probe sent</p>

<p>147connections dropped by keepalive</p>

<p>udpstatShow</p>

<p>显示udp信息</p>

<p>UDP:</p>

<p>7759 total packets</p>

<p>7757 input packets</p>

<p>2 output packets</p>

<p>0 incomplete header</p>

<p>0 bad data length field</p>

<p>0 bad checksum</p>

<p>581 broadcasts received with no ports</p>

<p>0 full socket</p>

<p>7176 pcb cache lookups failed</p>

<p>7176 pcb hash lookups failed</p>

<p>inetstatShow</p>

<p>显示连接信息</p>

<p>Active Internetconnections (including servers)</p>

<p>PCB Proto Recv-Q Send-Q Local Address Foreign Address (state)</p>

<p>-&mdash;&mdash;- &mdash;&mdash;&mdash;&ndash; &mdash;&mdash; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; &mdash;&mdash;-</p>

<p>1de70b94TCP 0 0 0.0.0.0.111 0.0.0.0.0 LISTEN</p>

<p>1de70a08UDP 0 0 0.0.0.0.111 0.0.0.0.0</p>

<p>tftpInfoShow</p>

<p>显示ftp信息</p>

<h4 id="1-1-6-6-文件操作">1.1.6.6 文件操作</h4>

<p>注意分清是对target还是host上的文件进行操作, 而相应使用@</p>

<p>cd</p>

<p>改变工作目录</p>

<p>ls</p>

<p>列出工作目录下的文件</p>

<p>pwd</p>

<p>显示当前工作目录</p>

<p>copy</p>

<p>拷贝文件</p>

<p>copy “host:cnset.cfg”，“/HDisk/cnset.cfg”</p>

<p>remove</p>

<p>删除文件</p>

<p>remove “/HDisk/trace/error.log”</p>

<p>rename</p>

<p>更改文件名称</p>

<p>usrAtaConfig</p>

<p>将ATA硬盘作为一个dos文件系统加载</p>

<p>STATUS usrAtaConfig</p>

<p>(</p>

<pre><code>int    ctrl,    /* 0: primary address, 1: secondary address */


 int    drive,   /* drive number of hard disk (0 or 1) */


char * fileName /* mount point */


)


    如在MP上配置电子盘和硬盘：


usrAtaConfig（0，0，“HDISK”）  加载硬盘


usrAtaConfig（1，0，“FDISK”）  加载电子盘
</code></pre>

<p>usrTffsConfig</p>

<p>将Flash作为一个dos文件系统加载</p>

<p>usrTffsConfig(int drive, int removable, char * fileName)</p>

<p>如在PPC板上配FLASH：</p>

<p>usrTffsConfig（0，0，“输入自己的设备名”） 加载Flash盘</p>

<p>tffsDevFormat</p>

<p>格式化flash：</p>

<pre><code>STATUS tffsDevFormat


(


int tffsDriveNo,  /* TrueFFS drive number (0 - DRIVES-1) */


 int arg          /* pointer to tffsDevFormatParams structure */


)
</code></pre>

<p>例如: tffsDevFormat 0, 0</p>

<h4 id="1-1-6-7-其他">1.1.6.7 其他</h4>

<p>1) shell 本身的一些指令</p>

<p>help Print this list</p>

<p>h Print (or set) shell history</p>

<p>shellHistory 设置或显示Shell命令</p>

<p>shellPromptSet 改变C解释器Shell 提示</p>

<p>printLogo 显示Tornado Shell 登陆</p>

<p>version Print VxWorks version info, andboot line</p>

<p>exit 退出shell</p>

<p>quit 退出shell</p>

<p>2) 几个系统调试指令</p>

<p>b Display breakpoints</p>

<p>b Set breakpoint</p>

<p>bd Delete breakpoint</p>

<p>bdall Delete all breakpoints</p>

<p>c Continue from breakpoint</p>

<p>s Single step</p>

<p>bh Set hardware breakpoint</p>

<p>sysSuspend Suspend the system</p>

<p>sysResume Resume the system</p>

<p>agentModeShow 显示代理模式（系统模式 或 任务模式）</p>

<p>sysStatusShow 显示系统上下文（suspend或 running,系统模式下使用）</p>

<p>3) 几个不常用的指令</p>

<p>smMemShow show the shared memory systempartition blocks and statistics</p>

<p>smMemPartShow show user&rsquo;s shared memory systempartition blocks and statistics</p>

<p>trgShow show trigger information</p>

<p>show 在shell窗口打印特定对象的信息</p>

<p>browse 在Tornado browser 显示特定的对象</p>

<p>注：某些命令只在TargetServer上执行，如lkAddr。</p>

<p>某些需要到Target上执行，如period()、repeat()。</p>

<h2 id="1-2-browse">1.2 BROWSE</h2>

<p>可对系统对象（任务、消息队列、信号量等）和存储器使用情况进行观察的浏览器。可以方便地监视用户的目标系统。Browser汇总了应用进程，内存消耗和一个目标内存的映像。通过Browser，用户可以观察信号量、消息队列、内存分配、看门狗计时器、堆栈使用情况、目标
CPU使用率、对象模块结构和符号表以及每个任务的详细信息。</p>

<p>可以分析: 内存泄漏、内存碎片、堆栈溢出、优先级反转</p>

<h3 id="1-2-1-内存查看">1.2.1 内存查看</h3>

<p>Tools条显示的是归taget agent管理的内存，归Tornado tools使用；</p>

<p>Application条显示的是归目标系统内所有任务使用；</p>

<p>以上2者独立分开，共同占用目标板的内存；</p>

<p>栏内显示的是所有模块的所占用内存的信息；</p>

<h3 id="1-2-2-模块信息">1.2.2 模块信息</h3>

<p>可以知道该模块的地址空间，比较有用的是他的符号表；</p>

<h3 id="1-2-3-堆栈使用率">1.2.3 堆栈使用率</h3>

<p>可以检查堆栈状况</p>

<h3 id="1-2-4-cpu占有率">1.2.4 CPU占有率</h3>

<p>由于辅助时钟和目前3gcn内的冲突，建议不要使用，否则会造成系统紊乱；</p>

<h3 id="1-2-5-任务信息">1.2.5 任务信息</h3>

<h3 id="1-2-6-中断向量表">1.2.6 中断向量表</h3>

<p>Std Excep. Handler standard exception handler</p>

<p>Default Trap default trap (Sparc)</p>

<p>Uninit. Int uninitialized interrupt vector</p>

<p>Corrupted Int corrupted interrupt vector</p>

<h3 id="1-2-7-实体查看">1.2.7 实体查看</h3>

<p>可以查看诸如消息队列、信号量、watchdog、任务、系统内存等的状况。如：</p>

<h2 id="1-3-debugger">1.3 Debugger</h2>

<h3 id="1-3-1-条件断点">1.3.1 条件断点</h3>

<p>condition 填入条件,变成条件断点</p>

<p>keep 指一直有效</p>

<p>delete 在断点到达后将之删除</p>

<p>disable 先不让该断点有效</p>

<h3 id="1-3-2-代码显示">1.3.2 代码显示</h3>

<p>Source</p>

<p>以高级语言(c、c++)显示，缺省的显示方式</p>

<p>Disassembly</p>

<p>以反汇编方式显示</p>

<p>MixedSource and Disassembly</p>

<p>混合高级和反汇编方式显示，配和修改一些寄存器值如pc，来达到控制调试流程。</p>

<h2 id="1-4-target-server">1.4 Target Server</h2>

<p>创建Target Server时需要配置的变量。</p>

<h3 id="1-4-1-使用串口调试">1.4.1 使用串口调试</h3>

<p>提供了几种target/host联系方式：</p>

<p>wdbpipe 一般用于vxworks目标模拟</p>

<p>netrom 我们用不着</p>

<p>wdbrpc 用的最多的一种，只要是ip连接的都行，需要配置目标机的IP地址</p>

<p>wdbserial 使用串口,填入连接的串口号,及其波特率即可</p>

<h3 id="1-4-2-重定向">1.4.2 重定向</h3>

<p>RedirectTarget IO</p>

<p>重定向目标机上的全局stdin、 stdout和stderr 到target server。如果没有创建控制台窗口，当有字符从目标机发送过来的时候， WTX
事件被发送给所有的WTX 工具 。</p>

<p>Create Console Window</p>

<p>在target server 所在的主机上创建一个虚拟控制台窗口作为目标机的I/O口。</p>

<p>Redirect Target Shell</p>

<p>创建一个虚拟控制台窗口，当前target shell的标准input、output和error被重定向到该窗口。</p>

<h2 id="1-5-windview">1.5 WindView</h2>

<p>在运行中可以记录一些重要信息(比如：任务调度状况、信号量、消息队列、watchdog,、内存、信号)的状况，从而便于对复杂的实时系统运行状况进行分析。</p>

<p>可以对调度异常、资源挂死、死机等进行分析。</p>

<h3 id="1-5-1-记录层次">1.5.1 记录层次</h3>

<p>根据需要，可以记录3个层次上数据：</p>

<ul>
<li><p>Context Switch Event-Logging Level ( <em>CSE Level</em> )</p></li>

<li><p>Task State Transition Event-Logging Level ( <em>TST Level</em> )</p></li>

<li><p>Additional Instrumentation Event-Logging Level ( <em>AIL Level</em> )</p></li>
</ul>

<h3 id="1-5-2-记录数据存储方式">1.5.2 记录数据存储方式</h3>

<p>可以设定一定大小的内存，在target上作为保存数据的缓冲。有这样几种方式将该缓冲输出，一般用前两者：</p>

<p>Direct toGraph</p>

<p>直接显示到屏幕</p>

<p>File via TSFS</p>

<p>送到target server上的一个文件中/tgtsvr/XXX.Wvr文件。Targetserver的路径如下在TargetServer
Configuration 中设置</p>

<p>__</p>

<p>Socket viaTSFS</p>

<p>通过菜单打开/tgtsvr/TCP:xiaxinguo:6164[其实是创建了个连接]来接收taget的输出到屏幕</p>

<p>Socket viaTCP/IP</p>

<p>通过菜单打开xiaxinguo:6164[其实是创建了个连接]来接收taget的输出到屏幕</p>

<p>NFS toFile</p>

<p>保存到文件 __</p>

<h3 id="1-5-3-传送方式">1.5.3 传送方式</h3>

<p>Deferred</p>

<p>host取一次，taget记一次。</p>

<p>Continuous</p>

<p>target在记到一定程度后，传送到后台，继续记录，连续进行。</p>

<p>Post-Mortem</p>

<p>target将数据记录到保留内存，在异常热启动后可再取得相应数据，从而可以知道是异常在哪里。</p>

<h3 id="1-5-4-数据分析">1.5.4 数据分析</h3>

<p>Ø 具体图形的意义可以参看帮助”Event Dictionary”。</p>

<p>Ø 可以选择关心的任务，关心的实体，而将不关心的部分隐藏掉。</p>

<p>Ø 为便于查找，可以自己创建几个实体以便标识，比如信号量。在错误处操作，从而可以很快定位，而不用再达海中捞针。</p>

<h2 id="1-6-trigger">1.6 Trigger</h2>

<p>通过设置一些触发器，触发一些操作，主要有以下2个功能：</p>

<p>Ø 可以监控变量，函数的执行情况，特别对变量被修改这种问题有帮助。</p>

<p>Ø 和windview配合使用，使记录可控。</p>

<h2 id="1-7-telnet">1.7 telnet</h2>

<p>telnet功能类似shell，不用起tornado而已，省却启动target server，对release比较有用。使用方法如下：</p>

<p>在包含了INCLUDE_TELNET 后能使用telnet；如果要加上user/pass验证，则需要加上 INCLUDE_SECURITY
。但注意的是，下图中的pass为加密后的密码，可以使用/host/x86-win32/bin/vxencrypt来将密码加密。</p>

<h2 id="1-8-调试模式">1.8 调试模式</h2>

<p>Tornado集成环境提供两种调试模式：任务调试模式和系统调试模式。在任务调试模式下，在一个集成环境下一个时间内只能调试一个任务。调试只影响当前被调试的任务，其它任务正常运行。在系统调试模式下，可以同时调试多个任务、中断服务程序（ISR），调试影响整个系统。</p>

<p>通过下面的例子说明调试步骤：</p>

<p>/* VxWorks includes */</p>

<p>#include &ldquo;vxWorks.h&rdquo;</p>

<p>#include &ldquo;taskLib.h&rdquo;</p>

<p>#include &ldquo;stdio.h&rdquo;</p>

<p>#include &ldquo;msgQLib.h&rdquo;</p>

<p>int g_lTaskATid;</p>

<p>int g_lTaskBTid;</p>

<p>MSG_Q_ID g_MsgQ1id;</p>

<p>MSG_Q_ID g_MsgQ2id;</p>

<p>void MultiTaskTestTaskA(void)</p>

<p>{</p>

<p>char cMsgToTaskB[100];</p>

<p>char cMsgFromTaskB[100];</p>

<p>sprintf(cMsgToTaskB,&ldquo;To TaskB \n&rdquo;);</p>

<p>printf(&rdquo; Hello from MultiTaskTestTaskA \n&rdquo;);</p>

<p>taskSuspend(0); /<em>挂起</em>/</p>

<p>for(;;)</p>

<p>{</p>

<p>printf(&rdquo; Hello from MultiTaskTestTaskA \n&rdquo;);</p>

<p>msgQSend(g_MsgQ1id,cMsgToTaskB,sizeof(cMsgToTaskB),WAIT_FOREVER,
MSG_PRI_NORMAL);</p>

<p>msgQReceive(g_MsgQ2id,cMsgFromTaskB,100,WAIT_FOREVER);</p>

<p>printf(&ldquo;%s&rdquo;,cMsgFromTaskB);</p>

<p>}</p>

<p>}</p>

<p>void MultiTaskTestTaskB(void)</p>

<p>{</p>

<p>char cMsgToTaskA[100];</p>

<p>char cMsgFromTaskA[100];</p>

<p>sprintf(cMsgToTaskA,&ldquo;To TaskA \n&rdquo;);</p>

<p>printf(&rdquo; Hello from MultiTaskTestTaskB \n&rdquo;);</p>

<p>taskSuspend(0);</p>

<p>for(;;)</p>

<p>{</p>

<p>printf(&rdquo; Hello from MultiTaskTestTaskB \n&rdquo;);</p>

<p>msgQSend(g_MsgQ2id,cMsgToTaskA,sizeof(cMsgToTaskA),WAIT_FOREVER,
MSG_PRI_NORMAL);</p>

<p>msgQReceive(g_MsgQ1id,cMsgFromTaskA,100,WAIT_FOREVER);</p>

<p>printf(&ldquo;%s&rdquo;,cMsgFromTaskA);</p>

<p>}</p>

<p>}</p>

<p>void MultiTaskTestInit(void)</p>

<p>{</p>

<p>printf(&rdquo; Hello from MultiTaskTestInit \n&rdquo;);</p>

<p>g_MsgQ1id=msgQCreate(20,100,MSG_Q_FIFO); /<em>创建消息队列</em>/</p>

<p>if(g_MsgQ1id==NULL)</p>

<p>{</p>

<p>printf(&rdquo; ERROR: create g_MsgQ1 error \n&rdquo;);</p>

<p>}</p>

<p>g_MsgQ2id=msgQCreate(20,100,MSG_Q_FIFO);</p>

<p>if(g_MsgQ1id==NULL)</p>

<p>{</p>

<p>printf(&rdquo; ERROR: create g_MsgQ2 error \n&rdquo;);</p>

<p>}</p>

<p>printf(&rdquo; Spawning a new task called MultiTaskTestTaskA \n\n&rdquo;);</p>

<p>g_lTaskATid=taskSpawn(&ldquo;MultiTaskTestTaskA&rdquo;,100,0,10000,
(FUNCPTR)MultiTaskTestTaskA,0,0,0,0,0,0,0,0,0,0);</p>

<p>if(g_lTaskATid == ERROR)</p>

<p>{</p>

<p>printf(&rdquo; ERROR: task did not spawn \n&rdquo;);</p>

<p>exit(1);</p>

<p>}</p>

<p>printf(&rdquo; Spawning a new task called MultiTaskTestTaskB \n&rdquo;);</p>

<p>g_lTaskBTid=taskSpawn(&ldquo;MultiTaskTestTaskB&rdquo;,100,0,10000,
(FUNCPTR)MultiTaskTestTaskB, 0,0,0,0,0,0,0,0,0,0);</p>

<p>if(g_lTaskBTid == ERROR)</p>

<p>{</p>

<p>printf(&rdquo; ERROR: task did not spawn \n&rdquo;);</p>

<p>exit(1);</p>

<p>}</p>

<p>exit(0);</p>

<p>}</p>

<h3 id="1-8-1-任务调试模式下的多任务调试">1.8.1 任务调试模式下的多任务调试</h3>

<p>在任务调试模式下，在一个集成环境中，在一个任务中调试，在另一个任务中设置断点，设置的断点不起作用。这是因为一个调试器只能处理一个TCB（任务控制块），每个任务都有一个TCB，因此一个调试器只能调试一个任务，要调试几个任务就要启动几个调试器。一个集成环境只能启动一个调试器，所以要调试几个任务就要启动几个集成环境。另外，需要在被调试的任务的待调试的第一条语句前加入taskSuspend(0)语句，挂起该任务，否则任务就可能会在调试前被执行。</p>

<p>多任务调试步骤：</p>

<ul>
<li><p>用-g选项编译源代码产生目标文件</p></li>

<li><p>下载产生的目标文件</p></li>

<li><p>在MultiTaskTestInit函数的开始设置断点</p></li>

<li><p>把MultiTaskTestInit设置为调试任务的人口函数</p></li>

<li><p>单步执行产生MultiTaskTestTaskA任务的语句后可以在串口（超级终端）上看到字符串Hello from MultiTaskTestTaskA，用Browser查看任务，可以看到任务MultiTaskTestTaskA出于挂起态（suspended），表明程序执行了taskSuspend(0)语句。</p></li>

<li><p>运行另一个Tornado集成环境</p></li>

<li><p>Attach任务MultiTaskTestTaskA，</p></li>

<li><p>在语句msgQReceive(g_MsgQ2id,cMsgFromTaskB,100,WAIT_FOREVER)的下一条语句处设置断点</p></li>

<li><p>运行任务MultiTaskTestTaskA。可以看到没有执行到断点处，用Browser查看任务状态，MultiTaskTestTaskA出于阻塞态（pended），因为它在等待消息。</p></li>

<li><p>单步执行MultiTaskTestInit到产生MultiTaskTestTaskB任务的下一条语句，可以看到MultiTaskTestTaskB任务处于挂起态</p></li>

<li><p>再运行另一个Tornado集成环境</p></li>

<li><p>Attach任务MultiTaskTestTaskB，</p></li>

<li><p>在语句msgQReceive(g_MsgQ1id,cMsgFromTaskA,100,WAIT_FOREVER)下一条语句处设置断点</p></li>

<li><p>运行任务MultiTaskTestTaskB。可以看到执行到断点处停下。这是因为MultiTaskTestTaskA任务已经发送一条消息到MultiTaskTestTaskB的接收队列中。</p></li>

<li><p>此时，可以看到MultiTaskTestTaskA任务也运行到断点处，因为为MultiTaskTestTaskB任务已经发送一条消息到MultiTaskTestTaskA的接收队列中。</p></li>
</ul>

<h3 id="1-8-2-系统调试模式下多任务的调试">1.8.2 系统调试模式下多任务的调试：</h3>

<p>Tornado2.0集成环境提供了通过网口进行系统模式调试的功能。系统缺省使用网口通信，如果需要使用串口通信，需要修改文件C: \ Tornado <br />
target \ config\ all \ configAll.h的一些宏定义，修改为：</p>

<p>#define WDB_COMM_TYPE WDB_COMM_SERIAL /<em>使用串口通信</em>/</p>

<p>#define WDB_TTY_CHANNEL 0 /<em>使用第一个串口</em>/</p>

<p>#define WDB_TTY_BAUD 38400 /<em>波特率：38400bps</em>/</p>

<p>重新编译链接vxWorks。 在启动Target server时，要选择串口通信，并进行相应配置。</p>

<p>调试使用的源代码与任务调试模式中使用的代码相同。但是，需要去掉为了能够在任务调试模式下进行多任务调试的MultiTaskTestTaskA和MultiTaskTestTaskB中的语句taskSuspend(0);。</p>

<p>多任务调试步骤：</p>

<ul>
<li><p>用-g选项编译源代码产生目标文件。</p></li>

<li><p>下载产生的目标文件。</p></li>

<li><p>在MultiTaskTestInit函数的开始设置断点。</p></li>

<li><p>在Debugger命令窗口输入命令attach system进入系统调试模式。</p></li>

<li><p>在Shell窗口输入命令sp MultiTaskTestInit产生一个以MultiTaskTestInit为入口函数的任务，因为整个系统都停下了，新产生的任务还没有执行，这可以通过在Debugger命令窗口输入命令info threads显示当前系统中的任务列表看出来。</p></li>

<li><p>执行菜单命令Debug | Continue（F5）继续运行程序。</p></li>

<li><p>系统在设置的断点处停下。</p></li>

<li><p>在函数MultiTaskTestTaskA中的语句msgQReceive(g_MsgQ2id,cMsgFromTaskB, 100,WAIT_FOREVER)的下一条语句处设置断点。</p></li>

<li><p>在函数MultiTaskTestTaskB中的语句msgQReceive(g_MsgQ1id,cMsgFromTaskA, 100,WAIT_FOREVER)的下一条语句处设置断点。</p></li>

<li><p>执行菜单命令Debug | Continue继续运行程序。</p></li>

<li><p>程序在任务MultiTaskTestTaskB中的断点处停下（为什么不是在任务MultiTaskTestTaskA中停下？请考虑）。</p></li>

<li><p>执行菜单命令Debug | Continue继续运行程序。</p></li>

<li><p>程序在任务MultiTaskTestTaskA中的断点处停下。</p></li>

<li><p>执行菜单命令Debug | Continue继续运行程序。</p></li>

<li><p>程序又一次在任务MultiTaskTestTaskA中的断点处停下（为什么停两次？请考虑，以后依次增加停的次数）。</p></li>

<li><p>执行菜单命令Debug | Continue继续运行程序。</p></li>

<li><p>程序在任务MultiTaskTestTaskB中的断点处停下。</p></li>
</ul>

<h3 id="1-8-3-中断服务程序的调试">1.8.3 中断服务程序的调试</h3>

<p>中断服务程序只能在系统调试模式下调试，不能在任务调试模式下调试。因为中断服务程序是作为系统的一部分运行，不是以任务方式运行，因此不需要为它产生任务。</p>

<p>中断服务程序调试步骤：</p>

<ul>
<li><p>用-g选项编译源代码产生目标文件。</p></li>

<li><p>下载产生的目标文件。</p></li>

<li><p>在MultiTaskTestInit函数的开始设置断点。</p></li>

<li><p>在Debugger命令窗口输入命令attach system进入系统调试模式。</p></li>

<li><p>执行菜单命令Debug | Continue继续运行程序。</p></li>

<li><p>如果产生相应的中断，程序就会在中断服务程序的断点处停下。进行需要的调试。</p></li>
</ul>

<p>使用logMsg()打印，不能用printf()。</p>

<h1 id="2-v2支撑的调试手段">2 V2支撑的调试手段</h1>

<h2 id="2-1-各模块提供的函数">2.1 各模块提供的函数</h2>

<p>R01提供的调试函数：需要将MEM_TRACE_ON宏定义打开，重新编译生成目标文件。</p>

<p>VOID r01UBUseStatShow (VOID);</p>

<p>显示所有内存池的占用信息，包括内存池大小, 总共个数, 使用个数, 使用峰值个数,
失败个数。如果用的个数不变小,可以使用r01UBPoolShow来看是被谁占用;</p>

<p>VOID r01DispCpu (VOID);</p>

<p>打印当前CPU占用情况</p>

<p>BOOL r01PcbShow (WORD16 wPno);</p>

<p>打印进程的运行状态</p>

<p>BOOL r01UBShowByPno (WORD16 pno)</p>

<p>显示所有进程占用内存情况</p>

<p>BOOL r01ProcShow (WORD16dwFlag)</p>

<p>显示当前激活的进程信息，包括进程名, 任务号，PID, 运行时间（pentium为ms,powerpc为10ms）,
进程堆栈使用率。DwFlag低四位=1，dwRunTickSum字段清零；其余不清零。</p>

<p>BOOL r01TcbShow (WORD16 dwFlag)</p>

<p>功能：打印显示任务情况，可以显示相应任务所用的邮箱(消息队列)的ID号, 运行时间。</p>

<p>=======================================================</p>

<p>no name mail_box ready block run_times</p>

<p>0 uMonitor 0x1a4d8200 0 0 0</p>

<p>1 uSchTask1 0x1a4c87a0 0 8 3268</p>

<p>2 uSchTask2 0x1a4b8d40 0 42 53638</p>

<p>3 uSchTask3 0x1a4a92e0 0 2 0</p>

<p>4 uSchTask4 0x1a499880 0 11 66</p>

<p>5 uSchTask5 0x1a489e20 0 20 35440</p>

<p>6 uSchTask6 0x1a47a3c0 0 0 0</p>

<p>7 uSchTask7 0x1a46a960 0 2 0</p>

<p>8 uSchTask8 0x1a45af00 0 1 17518</p>

<p>9 uSchTask9 0x1a44b4a0 0 0 0</p>

<p>10 uTimer 0x1a43ba40 0 0 0</p>

<p>BOOL r01UBShowByPno (WORD16pno)</p>

<p>显示所有进程占用内存情况</p>

<p>WORD16 r01UBPoolPeakGet (WORD16wPool)</p>

<p>显示某个内存池的UB使用峰值</p>

<p>BOOL r01ProcMsgTrace (WORD16wPno, BYTE byTrace)</p>

<p>打开进程的消息跟踪，生效后收发消息有打印</p>

<p>BOOL r01UBPoolShow (WORD16wPool)</p>

<p>显示所有某个内存池的当前占用情况</p>

<p>BOOL r03Trace(BYTE m, BYTE u, BYTE trace)</p>

<p>打印与逻辑节点（m，u）间的所以通信消息。</p>

<p>VOID r04node(BYTE md_in, BYTE ut_in, BYTE sut_in)</p>

<p>打印指定节点的信息</p>

<p>VOID r04dogoff()</p>

<p>关闭硬件狗，要调试程序，需先关闭看门狗，否则系统将被复位。</p>

<h2 id="2-2-如何查看error-log文件">2.2 如何查看error.log文件</h2>

<p>典型错误：page fault</p>

<hr />

<p>** Schedule Task Page Fault</p>

<p>Date: 2004-08-03 14:38:55</p>

<p>Module: 1, Unit: 0</p>

<p>State: Master</p>

<p>Cpu Percent: 1%</p>

<p>UB: 3998, 4000, 4000, 3988, 3995,4000, 199, 200, 100,</p>

<p>Process Name: M01Mgt</p>

<p>Task No: 3</p>

<p>Process Entry Address: 0x15a1f0</p>

<p>Ret EIP(pEsf-&gt;pc): 0x15a813</p>

<p>taskIdCurrent-&gt;excInfo.pc:0x15a813</p>

<p>taskIdCurrent-&gt;regs.pc: 0x114c2e2</p>

<p>taskIdCurrent-&gt;pExcRegSet-&gt;pc0x15a813</p>

<p>Stack Size: 8192</p>

<p>Last Run Count: 1</p>

<p>Current Run Count: 2</p>

<p>Send Msg Count: 0</p>

<p>Send Msg Bytes: 0</p>

<p>Syn Wait Flag: 0</p>

<p>MsgNum in Process Queue: 0</p>

<p>Process SP: 0x1d8d4c64</p>

<p>Current Send Event: 0</p>

<p>Current Receiver: 255-255-16383-255-1</p>

<p>Current State: 3</p>

<p>Current Receive Event: 8404</p>

<p>Current Sender: 1-0-97-200-0</p>

<p>Msg:</p>

<p>01 cc 01 03 10 01 cd cd cd</p>

<p>Code:</p>

<p>8a 90 1e 01 00 00 0f b6 c2 83 f8 0274 3f 83 f8 02 7f 0a 83 f8 01 74 15 e9</p>

<p>a0 00 00 00 83 f8 03 74 4b 83 f8 0474 06 e9 91 00 00 00 90 0f b7 45 a2 50</p>

<p>8b 45 94 50 8b 45 08 50 e8 0e 06 0000 83 c4 0c 89 c0 88 45 aa eb 78 8d 74</p>

<p>26 00 0f b7 45 a2 50 8b 45 94 50 8b45 08 50 e8 fe 06 00 00 83 c4 0c 89 c0</p>

<p>88 45 aa eb 58 8d 74 26 00 80 7d 9801 74 0a 80 7d 98 41 74 04 eb 22 8d 36</p>

<p>0f b6 45 98 50 8b 45 08 50 e8 d2 0000 00 83 c4 08 89 c0 88 45 aa eb 22 90</p>

<p>8d b4 26 00 00 00 00 0f b7 45 a2 508b 45 94 50 8b 45 08 50 e8 7e 03 00 00</p>

<p>83 c4 0c 89 c0 88 45 aa eb 08 8d 7426 00 c6 45 aa 04 80 7d aa 46 74 26 83</p>

<p>taskIdCurrent-&gt;pStackBase:0x1d7b6070;</p>

<p>pStackLimit:0x1d7b507c;pStackEnd:0x1d7b5070;</p>

<p>taskIdCurrent-&gt;wdbInfo.taskSp:0x00000000;</p>

<p>Current call stack:</p>

<p>nargs=10; 0x1157c02 : 0x115f80 (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</p>

<p>nargs= 1; 0x115f91 : 0x11c09f (0)</p>

<p>nargs= 1; 0x11c106 : 0x11e89c (0x1d8db07b)</p>

<p>nargs= 1; 0x11e8c5 : 0x11bac8 (0x1d8db07b)</p>

<p>nargs= 0; 0x11bae0 : 0x11e91c ()</p>

<p>nargs= 3; 0x11e947 : 0x15a1f0 (0x1df0c7fb, 0, 0)</p>

<p>nargs= 1; 0x15a2e4 : 0x15a640 (0x1df0c7fb)</p>

<p>Total size: 1924 bytes</p>

<p>分析其记录的堆栈调用关系可找到发生异常的函数。lkAddr 0x15a640</p>

<h3 id="2-2-1-定位到具体的出错行">2.2.1 定位到具体的出错行</h3>

<p>1） 使用tornado中view\mixed source and
disassembly，会将代码和反汇编混合显示，反汇编中会显示具体位置，比对异常记录中出错位置指针就可找到具体代码行。</p>

<p>2）
Error.log会记录异常发生时该进程的接收消息内容和事件号，如果内容比较少的话，可找一块没有使用的内存，将该内容敲进去；如果比较多的话，可将接收内容放到一全局数组，重编版本。在shell中启动一任务，入口是该进程入口，并停在该进程入口处，修改相关内容指针，状态，事件号等，跟踪下去直到出错的行。</p>

<p>3） 最简便办法是使用bh，硬件断点，一些情况可在前后加上内存页保护；这两种均能找到具体行，如果被修改的有规律，可往被修改的地址往上查。</p>

<p>常见错误：死循环、pagefault、除0错、越界修改内存、</p>

<h1 id="3-v3支撑的调试手段">3 V3支撑的调试手段</h1>

<h2 id="1-1-进程调试">1.1. 进程调试</h2>

<p>平台的OSS在vxWorks的基础上创建了一些通信任务、监控任务、485任务、调度任务等等。其中在调度任务下又引入了进程的概念，进程的用法见相关设计文档。</p>

<h2 id="1-2-查看所有进程信息-oss-dbggetallusepcbinfo">1.2. 查看所有进程信息：OSS_DbgGetAllUsePCBInfo</h2>

<p>-&gt;OSS_DbgGetAllUsePCBInfo</p>

<p>*********************<strong><em>UsedProcess Info</em></strong>************************</p>

<p>WTno</p>

<p>|</p>

<p>wProcType</p>

<p>|</p>

<p>MsgCount</p>

<p>|</p>

<p>ucRunStatus</p>

<p>|</p>

<p>PCB</p>

<p>|</p>

<p>ScheCount</p>

<p>&mdash;|&mdash;|&mdash;|&mdash;|&mdash;|&mdash;</p>

<p>0x0009</p>

<p>|</p>

<p>0x0805</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bc390</p>

<p>|</p>

<p>0x000005b2</p>

<p>0x0008</p>

<p>|</p>

<p>0x0804</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bc498</p>

<p>|</p>

<p>0x000015ef</p>

<p>0x0008</p>

<p>|</p>

<p>0x0803</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bc5a0</p>

<p>|</p>

<p>0x00000001</p>

<p>0x0000</p>

<p>|</p>

<p>0x0807</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bc6a8</p>

<p>|</p>

<p>0x0000009d</p>

<p>0x0009</p>

<p>|</p>

<p>0x0401</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bcbd0</p>

<p>|</p>

<p>0x00000019</p>

<p>0x0009</p>

<p>|</p>

<p>0x0402</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bccd8</p>

<p>|</p>

<p>0x000028a7</p>

<p>0x0009</p>

<p>|</p>

<p>0x0404</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bcde0</p>

<p>|</p>

<p>0x000015e1</p>

<p>0x0001</p>

<p>|</p>

<p>0x0411</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bcee8</p>

<p>|</p>

<p>0x000003a8</p>

<p>0x0008</p>

<p>|</p>

<p>0x0406</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bcff0</p>

<p>|</p>

<p>0x00000013</p>

<p>0x0008</p>

<p>|</p>

<p>0x0407</p>

<p>|</p>

<p>0x0000</p>

<p>|</p>

<p>0x03</p>

<p>|</p>

<p>0x038bd0f8</p>

<p>|</p>

<p>0x000008e2</p>

<p>MsgCount一栏是进程待处理的消息，一般为0。PCB这一列是进程控制块指针，可以在GDB中用 p *((T_PCB
*)0x38bc390)命令查看详细信息。ScheCount是进程的运行次数。</p>

<h2 id="1-3-查看当前运行的进程信息">1.3. 查看当前运行的进程信息</h2>

<h3 id="1-3-1-进程断点设置-b">1.3.1. 进程断点设置：b</h3>

<p>如果不设置断点，一般是不会有任何显示的，因为进程的运行时间很短。</p>

<p>在状态管理中心进程入口设置断点：</p>

<p>-&gt; b SCS_BSMgt</p>

<p>断点到达：</p>

<p>-&gt;</p>

<p>Break at 0x06086dac:SCS_BSMgt Task: 0x7e97c40(SCH9)</p>

<h3 id="1-3-2-当前进程运行信息-oss-dbggetcurpcbinfo">1.3.2. 当前进程运行信息：OSS_DbgGetCurPCBInfo</h3>

<p>查看当前运行进程信息，就可以看到显示了状态管理中心进程：</p>

<p>-&gt;OSS_DbgGetCurPCBInfo</p>

<p>Current ProcessType 0x402, InstanceNo 0x1 , wTno 0x9,Status 0x2</p>

<h3 id="1-3-3-当前进程的消息信息-oss-dbggetcurmsginfo">1.3.3. 当前进程的消息信息：OSS_DbgGetCurMsgInfo</h3>

<p>查看当前进程的消息，可以看到进程消息信息：</p>

<p>-&gt;OSS_DbgGetCurMsgInfo</p>

<p>Current Msg 0x5dd issent From Pno 0x4020001 ,wUnit 0xffff To Pno 0x4020001
,wUnit 0xffff</p>

<p>消息号0x5dd，十进制为1501，可以看出是TIMER1消息。</p>

<p>-&gt; 0x5dd</p>

<p>value = 1501 = 0x5dd</p>

<h3 id="1-3-4-进程断点取消-bd">1.3.4. 进程断点取消：bd</h3>

<p>取消断点：</p>

<p>è bd SCS_BSMgt</p>

<h3 id="1-3-5-恢复进程运行-tr">1.3.5. 恢复进程运行：tr</h3>

<p>再恢复SCH9的运行</p>

<p>-&gt; tr SCH9</p>

<p>这时再看当前进程的消息，已经没有可显示的了。</p>

<p>-&gt;OSS_DbgGetCurMsgInfo</p>

<p>No Running Process,No message!</p>

<h2 id="1-4-内存观察">1.4. 内存观察</h2>

<h3 id="1-4-1-消息队列堆积-阻塞观察-tw">1.4.1. 消息队列堆积、阻塞观察：tw</h3>

<p>任务间通信(包括不同调度任务的进程间)是通过队列来进行的。因此每个任务都有一个队列，该任务不停地从队列中取消息进行处理，相当于消费者，如果队列为空，则任务挂起，等待消息。其他任务(如通信任务等)向该任务的队列发送消息，相当于生产者。在一个稳定的系统中，消息队列应该基本不堆积消息。以调度任务9为例，用tw命令可以清楚地看到SCH9阻塞在队列上。</p>

<p>-&gt; tw SCH9</p>

<p>NAME ENTRY TID STATUS DELAY OBJ_TYPE OBJ_ID OBJ_NAME</p>

<h2 id="toc_60">-&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &mdash;&mdash;&ndash; &mdash;&mdash;&mdash;- &mdash;&ndash; &mdash;&mdash;&mdash;- &mdash;&mdash;&ndash;</h2>

<p>SCH9 0x5fe4110 7e97c40 PEND 0 MSG_Q&reg; 7e97e58 N/A</p>

<p>Message QueueId : 0x7e97e58</p>

<p>Task Queueing : FIFO</p>

<p>Message ByteLen : 4</p>

<p>Messages Max : 4000</p>

<p>Messages Queued : 0</p>

<p>ReceiversBlocked : 1</p>

<p>Send Timeouts : 0</p>

<p>ReceiveTimeouts : 0</p>

<p>Receivers Blocked:</p>

<p>NAME TID PRI TIMEOUT</p>

<p>-&mdash;&mdash;&mdash; &mdash;&mdash;&mdash;&ndash; &mdash;&mdash;-</p>

<p>SCH9 7e97c40 80 0</p>

<p>此外，在系统中，还有一个统一的内存UB池，包括内部UB和用户UB。生产者发送消息时，从UB池中获取内存，发送给消费者，消费者处理消息后，释放UB。这一切对上层应用而言是透明的。</p>

<p>在状态管理中心进程入口设置断点：</p>

<p>-&gt; b SCS_BSMgt</p>

<p>断点到达，可以看到调度任务9被断住。</p>

<p>-&gt;</p>

<p>Break at 0x06086dac:SCS_BSMgt Task: 0x7e97c40(SCH9)</p>

<p>还可以用msgQNumMsgs（0x7e97e58）看当前消息个数。</p>

<h3 id="1-4-2-任务消息队列观察-oss-dbgshowqueuectl">1.4.2. 任务消息队列观察：OSS_DbgShowQueueCtl</h3>

<p>通过OSS_DbgShowQueueCtl调试函数，可以看出调度任务9地队列堆积了22个消息。</p>

<p>-&gt;OSS_DbgShowQueueCtl</p>

<p>Display the contentof all used queue control block</p>

<p>QueueName</p>

<p>|</p>

<p>EntrySize</p>

<p>|</p>

<p>TotalCount</p>

<p>|</p>

<p>UsedCount</p>

<p>|</p>

<p>VxWorksId</p>

<p>|</p>

<p>ptHead</p>

<p>|</p>

<p>&mdash;|&mdash;|&mdash;|&mdash;|&mdash;|&mdash;|&mdash;</p>

<p>CommRudpProto</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7f43400</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH0</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7f337d8</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH1</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7f22b60</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH2</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7f11ee8</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH3</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7f01270</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH4</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7ef05f8</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH5</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7edf980</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH6</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7eced08</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH7</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7ebe090</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH8</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7ead418</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>SCH9</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>22</p>

<p>|</p>

<p>7e9c7a0</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>RS485</p>

<p>|</p>

<p>16</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e83e28</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>USB</p>

<p>|</p>

<p>16</p>

<p>|</p>

<p>1</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e7fb98</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>EXCINT</p>

<p>|</p>

<p>16</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e64220</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>BootAgt</p>

<p>|</p>

<p>16</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e488a8</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>MateScan</p>

<p>|</p>

<p>16</p>

<p>|</p>

<p>4000</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e2cf30</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>MONI</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>100</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e28678</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>TIMER</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>100</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e26dc0</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>PRIN</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>100</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e25508</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>IDLE</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>100</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e23c50</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>DLDEAL</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>100</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e22398</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>TOIL</p>

<p>|</p>

<p>4</p>

<p>|</p>

<p>100</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7e20ae0</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<p>UDPPrintf</p>

<p>|</p>

<p>4096</p>

<p>|</p>

<p>100</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>7dbb548</p>

<p>|</p>

<p>VXWORKS</p>

<p>|</p>

<h3 id="1-4-3-任务ub使用观察-oss-dbgshowtaskub">1.4.3. 任务UB使用观察：OSS_DbgShowTaskUB</h3>

<p>通过OSS_DbgShowTaskUB，可以大致看出，消息的生产者是定时器任务和通信任务，定时器任务有5个UB还没有释放，通信任务有26个UB没有释放。</p>

<p>-&gt;OSS_DbgShowTaskUB</p>

<p>TASK UB SHOW:</p>

<p>Task</p>

<p>|</p>

<p>tNetTask</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>&mdash;|&mdash;|&mdash;|&mdash;|&mdash;|&mdash;</p>

<p>Task</p>

<p>|</p>

<p>tFtpdTask</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>s1u0</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>WATCHDOG</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH0</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH1</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH2</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH3</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH4</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH5</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000003</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH6</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH7</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH8</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>SCH9</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>RS485</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>USB</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>EXCINT</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>BootAgt</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>MateScan</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>MONI</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>TIMER</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000005</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>PRIN</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>DLDEAL</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>TOIL</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>tUdpPrnCln</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>tUdpPrnSvr</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>CommRudpProtoTask</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>CommUdpDaemonTask</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x0000001a</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<p>Task</p>

<p>|</p>

<p>CommTcpDaemonTask</p>

<p>|</p>

<p>InnerUB</p>

<p>|</p>

<p>0x00000000</p>

<p>|</p>

<p>UserUB</p>

<p>|</p>

<p>0x00000000</p>

<h3 id="1-4-4-进程使用ub情况-oss-dbgshowprocubinfo">1.4.4. 进程使用UB情况：OSS_DbgShowProcUBInfo</h3>

<p>另外还提供了一个进程使用UB情况的调试函数，这个函数的参数是调度任务的TID。如下为查看调度任务9下的所有进程的UB使用情况。</p>

<p>-&gt;OSS_DbgShowProcUBInfo 0x7e97c40</p>

<p>PROC UB SHOW:</p>

<p>Proc CommControlProc</p>

<p>|</p>

<p>Pno 0x08050001</p>

<p>|</p>

<p>InnerUB 0x00 UserUB 0x00</p>

<p>&mdash;|&mdash;|&mdash;</p>

<p>Proc SCSMCProc</p>

<p>|</p>

<p>Pno 0x04010001</p>

<p>|</p>

<p>InnerUB 0x00 UserUB 0x00</p>

<p>Proc SCS_BSMgt</p>

<p>|</p>

<p>Pno 0x04020001</p>

<p>|</p>

<p>InnerUB 0x00 UserUB 0x00</p>

<p>Proc SCS_RTMgt</p>

<p>|</p>

<p>Pno 0x04040001</p>

<p>|</p>

<p>InnerUB 0x00 UserUB 0x00</p>

<h3 id="1-4-5-ub的配置和当前状态-oss-dbgmemubuseprn-oss-dbgshowubpool">1.4.5. UB的配置和当前状态：OSS_DbgMemUbUsePrn/ OSS_DbgShowUbPool</h3>

<p>以下调试函数查看UB的配置和当前状态。另有一个调试函数OSS_DbgShowUbPool功能类似。</p>

<p>-&gt;OSS_DbgMemUbUsePrn</p>

<p>UB info for Sys UbPool!</p>

<p>#######################</p>

<p>UBSize TotalNumUsedNum</p>

<p>64 4000 9</p>

<p>128 3000 7</p>

<p>256 2000 7</p>

<p>512 3000 0</p>

<p>640 2000 0</p>

<p>16384 10 0</p>

<p>UB info for User UbPool!</p>

<p>#######################</p>

<p>UBSize TotalNumUsedNum</p>

<p>64 200 0</p>

<p>128 200 0</p>

<p>256 100 0</p>

<p>512 20 0</p>

<p>640 20 0</p>

<p>6400 20 0</p>

<h2 id="1-5-通信和定时器状态观察">1.5. 通信和定时器状态观察</h2>

<h3 id="1-5-1-通信状态显示oss-dbgshowcomm">1.5.1. 通信状态显示OSS_DbgShowComm</h3>

<p>单板上电时根据物理地址可以算出自身的IP和MAC地址，逻辑地址需要向OMP请求，根据数据库的配置得到。对于应用程序使用板间通信来说，要用逻辑地址、主备、左右等参数定位目标板，而底层通信需要根据目标板的逻辑地址获取目标板的IP地址，本地解析不了，就需要向OMP解析。</p>

<p>在OMP上运行OSS_DbgShowComm可以看到已上电运行的单板对应连接板，包括逻辑地址、左右板位、IP地址、连接状态等。连接状态为3表示通信正常。以下是在OMP的主用左板上运行该函数时显示的信息。</p>

<p>-&gt;OSS_DbgShowComm</p>

<p>Rudp LinkTable(Board is master):</p>

<p>Item (subsys moduleunit sunit ) pos state IP(hex) sndQ bufQ udpQ</p>

<p>0 (255 128 65535 255 )L 0 ffffffff 0 0 0</p>

<p>0 (255 128 65535 255 )R 0 ffffffff 0 0 0</p>

<p>1 (255 1 65535 255 )L 0 80001f01 0 0 0</p>

<p>1 (255 1 65535 255 )R 1 80001f09 2 0 0</p>

<p>2 (2 1 3 1 ) L 3 80502301 0 0 0</p>

<p>2 (2 1 3 1 ) R 0 ffffffff 0 0 0</p>

<p>3 (2 1 7 1 ) L 3 80502d01 0 0 0</p>

<p>3 (2 1 7 1 ) R 0 ffffffff 0 0 0</p>

<p>Back ground linktable:(Ip attached)</p>

<p>module IP(hex) socket state kpalive rcvFrag sndFrag sndQ</p>

<p>GroupTable:</p>

<p>20,127,</p>

<h3 id="1-5-2-测试板间通信是否正常-oss-dbgrudpping">1.5.2. 测试板间通信是否正常：OSS_DbgRudpPing</h3>

<dl>
<dt>ucRouteType)，可以测试本板和指定目标板的通信是否正常。运行命令之前先打开本板的telnet打印界面，运行命令之后，如果通信正常，在telnet打印界面上会打印消息返回成功。UcRouteType</dt>
<dd>1 主板，2 备板，3 左板，4 右板。</dd>
</dl>

<dl>
<dt>面上会打印消息返回成功。UcRouteType</dt>
<dd>1 主板，2 备板，3 左板，4 右板。</dd>
</dl>

<h3 id="1-5-3-单板上定时器的使用信息-oss-dbggettimerinfo">1.5.3. 单板上定时器的使用信息：OSS_DbgGetTimerInfo</h3>

<p>定时器调试函数OSS_DbgGetTimerInfo用来查看单板上定时器的使用信息。</p>

<h3 id="1-5-4-单板进程使用定时器的信息-oss-dbggettimerinfoofproc">1.5.4. 单板进程使用定时器的信息：OSS_DbgGetTimerInfoOfProc</h3>

<p>定时器调试函数 OSS_DbgGetTimerInfoOfProc(dwPno)用来查看某个进程使用定时器的信息。</p>

<h2 id="1-6-杂项观察">1.6. 杂项观察</h2>

<h3 id="1-6-1-异常发生后信息观察-oss-dbgshowexcinfo">1.6.1. 异常发生后信息观察：OSS_DbgShowExcInfo</h3>

<p>异常发生后可以用OSS_DbgShowExcInfo查看异常发生的一些信息。</p>

<h3 id="1-6-2-堆栈使用率-运行时间统计-zte">1.6.2. 堆栈使用率/运行时间统计：zte</h3>

<p>zte命令可以观察所有进程和任务的一些运行信息。其中ID &lt;
0x10000的为任务，反之为进程。可以显示堆栈的使用率。对于进程来说还可以显示最近20秒运行的次数/总运行次数(RunCount)，最近20秒运行的时间/总运行时间(以毫秒为单位),
进程打印内容的总长度，进程是否被断住。</p>

<p>-&gt;zte</p>

<p>Id</p>

<p>|</p>

<p>IdName</p>

<p>|</p>

<p>StackUse(%)</p>

<p>|</p>

<p>RunCount</p>

<p>|</p>

<p>Run(ms)</p>

<p>|</p>

<p>PrnLen</p>

<p>|</p>

<p>Breaked</p>

<p>&mdash;|&mdash;|&mdash;|&mdash;|&mdash;|&mdash;|&mdash;</p>

<p>0x1</p>

<p>|</p>

<p>tDcacheUpd</p>

<p>|</p>

<p>7</p>

<p>|</p>

<p>0/0</p>

<p>|</p>

<p>0/0</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>0x8050001</p>

<p>|</p>

<p>CommControlProc</p>

<p>|</p>

<p>11</p>

<p>|</p>

<p><sup>6</sup>&frasl;<sub>956</sub></p>

<p>|</p>

<p>0/16</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>0x8040001</p>

<p>|</p>

<p>OSS_Config</p>

<p>|</p>

<p>7</p>

<p>|</p>

<p><sup>24</sup>&frasl;<sub>3611</sub></p>

<p>|</p>

<p>0/166</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>0x8030001</p>

<p>|</p>

<p>P_R_485Agent</p>

<p>|</p>

<p>6</p>

<p>|</p>

<p>0/1</p>

<p>|</p>

<p>0/0</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>0x8070001</p>

<p>|</p>

<p>P_R_FileManageAgt</p>

<p>|</p>

<p>52</p>

<p>|</p>

<p>0/157</p>

<p>|</p>

<p>0/1116</p>

<p>|</p>

<p>0</p>

<p>|</p>

<p>0x4010001</p>

<p>|</p>

<p>SCSMCProc</p>

<p>|</p>

<p>32</p>

<p>|</p>

<p>0/15</p>

<p>|</p>

<p>0/266</p>

<p>|</p>

<p>203</p>

<p>|</p>

<h3 id="1-6-3-进程最近打印内容观察-ztecall-ztemsg">1.6.3. 进程最近打印内容观察：ztecall/ztemsg</h3>

<p>调试函数ztecall
进程号，可以查看指定进程的处理的最近若干个消息及处理消息时打印的内容。以主控进程为例，可以看出处理1201消息，耗时16个Tick(TickRate为60Hz,每个tick为16.6毫秒，所以耗时约为267毫秒，对于MPX86，TickRate约为700MHZ，即每个tick为1.5纳秒左右)。</p>

<p>-&gt; ztecall0x4010001</p>

<p>Tick Rate = 60 Hz</p>

<p>SCSMCProc</p>

<p>Name MsgId(MsgPtr) Time TickUse Stk</p>

<p>UniProcEntry 1201(0x7f8fb2d) 0:00:01:000 16 27</p>

<p>- SCSMCProc: OMP Start.</p>

<p>- SCSMCProc: The board is startingMasterPowerOn!</p>

<p>UniProcEntry 3003(0x419e764) 0:00:01:266 0 27</p>

<p>UniProcEntry 3003(0x419e9a4)0:00:01:266 0 27</p>

<p>UniProcEntry 1021(0x40ddddc)0:00:01:500 0 27</p>

<p>UniProcEntry 1021(0x40de0dc)0:00:01:500 0 27</p>

<p>UniProcEntry 3003(0x41a73a4)0:00:02:266 0 27</p>

<p>UniProcEntry 3003(0x41ae664)0:00:02:300 0 27</p>

<p>UniProcEntry 3003(0x7f8fb2d)0:00:02:300 0 27</p>

<p>- SCSMCProc: The Board finished Poweron Ok!</p>

<p>- SCSMCProc: ******ProcessPowerOnFinished0xbd5!</p>

<p>UniProcEntry 1021(0x40f06dc) 0:02:55:600 0 27</p>

<p>UniProcEntry 1021(0x40f10dc)0:02:55:600 0 27</p>

<p>UniProcEntry 1021(0x40f12dc)0:02:55:600 0 27</p>

<p>从上面还可以看出，消息号后的括号内时消息指针，该消息指针只是示意性的，短时有效。有以个例外是，OSS拷贝了进程最后一次打印时处理的消息，如上图所示的指针0x7f8fb2d。</p>

<p>ztemsg 消息指针可以显示消息的详细内容。如下所示，可以看出该消息是SCS_VMM_MGT给主控的上电成功消息。</p>

<p>-&gt; ztemsg 0x7f8fb2d</p>

<p>MsgId 3003 Length 0</p>

<p>Sender(Module-SubSys-Unit-Sunit-Pno-Route) 1-255-65535-255-0x4060001-3</p>

<p>Receiver(Module-SubSys-Unit-Sunit-Pno-Route)1-255-65535-255-0x4010001-0</p>

<p>-&gt;PrnProcName 0x406</p>

<p>SCS_VMM_MGT</p>

<h3 id="1-6-4-进程最近打印的1k内容和打印时间-zteprint">1.6.4. 进程最近打印的1K内容和打印时间：zteprint</h3>

<p>用zteprint 进程号 命令可以看到该进程最近打印的1K内容和打印时间等。如下所示，</p>

<p>同时显示了进程拷贝发生打印的消息指针。</p>

<p>-&gt; zteprint0x4010001</p>

<p>SCSMCProc ptr_of_msgsave0x7f8fb2d</p>

<p>0:00:01:266 SCSMCProc: OMP Start.</p>

<p>0:00:01:266 SCSMCProc: The board is startingMasterPowerOn!</p>

<p>0:00:02:300 SCSMCProc: The Board finished Poweron Ok!</p>

<p>0:00:02:300 SCSMCProc: ******ProcessPowerOnFinished0xbd5!</p>

<p>注：打印的内容中，最好只在每行的最后加回车即可，否则显示比较难看。</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a></li>
        
        <li><a href="/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/">009Shell脚本下条件测试eqne</a></li>
        
        <li><a href="/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/">00Pythonmanagepyshell和Python的分析</a></li>
        
        <li><a href="/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a></li>
        
        <li><a href="/posts/018dockerfileshell/">018DockerfileSHELL</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://zaina.newban.cn/tags/shell'>shell</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2020 <a href="https://zaina.newban.cn">开发者问答集锦 By </a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://zaina.newban.cn/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zaina.newban.cn">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://zaina.newban.cn/posts/001rubyruby%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8Fsymbol%E5%AF%B9%E6%AF%94/" title="001rubyRuby中全局变量实例变量局部变量类变量Symbol对比">001rubyRuby中全局变量实例变量局部变量类变量Symbol对比</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/007hadoop%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E6%B5%8B%E8%AF%95ssh%E5%85%8D%E7%99%BB%E9%99%86%E9%85%8D%E7%BD%AEstartallshhdfs%E5%B8%B8%E7%94%A8%E7%9A%84shell/" title="007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell">007Hadoop集群配置Hadoop集群的启动和测试SSH免登陆配置startallshhdfs常用的shell</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/009shell%E8%84%9A%E6%9C%AC%E4%B8%8B%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95eqne/" title="009Shell脚本下条件测试eqne">009Shell脚本下条件测试eqne</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/00pythonmanagepyshell%E5%92%8Cpython%E7%9A%84%E5%88%86%E6%9E%90/" title="00Pythonmanagepyshell和Python的分析">00Pythonmanagepyshell和Python的分析</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/010zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BAzookeeper%E7%9A%84shell%E5%91%BD%E4%BB%A4/" title="010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令">010Zookeeper的基本概念Zookeeper的集群搭建Zookeeper的shell命令</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/018dockerfileshell/" title="018DockerfileSHELL">018DockerfileSHELL</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%85%A5%E9%97%A801bashshell%E7%89%B9%E6%80%A7/" title="01Shell入门01bashShell特性">01Shell入门01bashShell特性</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%8F%98%E9%87%8F/" title="01Shell变量">01Shell变量</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8Fbash%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" title="01Shell基础概述脚本执行方式Bash基本功能">01Shell基础概述脚本执行方式Bash基本功能</a>
    </li>
    
    <li>
        <a href="https://zaina.newban.cn/posts/01shell%E7%BC%96%E7%A8%8Bhelloworld/" title="01shell编程helloworld">01shell编程helloworld</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href="/categories">分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href="/tags">标签</a></h3>
<div class="tagcloud">
    
    <a href="https://zaina.newban.cn/tags/ruby/">ruby</a>
    
    <a href="https://zaina.newban.cn/tags/shell/">shell</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://zaina.newban.cn/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>